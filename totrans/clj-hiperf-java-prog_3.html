<html><head></head><body><div class="part" title="Part&#xA0;3.&#xA0;Module 3"><div class="titlepage"><div><div><h1 class="title"><a id="part03"/>Part 3. Module 3</h1></div></div></div><div class="partintro" title="Module 3"><div/><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Mastering Clojure</strong></span>
</p><p>
<span class="emphasis"><em>
Understand the philosophy of the Clojure language and dive into its inner workings to unlock its advanced features, methodologies, and constructs
</em></span>
</p></blockquote></div></div></div>
<div class="chapter" title="Chapter&#xA0;1.&#xA0;Working with Sequences and Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch16"/>Chapter 1. Working with Sequences and Patterns</h1></div></div></div><p>In this chapter, we'll revisit a few basic programming techniques, such as recursion and sequences, with Clojure. As we will see, Clojure focuses on the use of higher-order functions to abstract computation, like any other functional programming language. This design can be observed in most, if not all, of the Clojure standard library. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exploring recursion</li><li class="listitem" style="list-style-type: disc">Learning about sequences and laziness</li><li class="listitem" style="list-style-type: disc">Examining zippers</li><li class="listitem" style="list-style-type: disc">Briefly studying pattern matching</li></ul></div><div class="section" title="Defining recursive functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec0012"/>Defining recursive functions</h1></div></div></div><p>
<span class="strong"><strong>Recursion</strong></span> is one of the<a class="indexterm" id="id000"/> central methodologies of computer science. It allows us to elegantly solve problems that have cumbersome non-recursive solutions. Yet, recursive functions are discouraged in quite a few imperative programming languages in favor of non-recursive functions. Clojure does no such thing and completely embraces recursion along with all its pros and cons. In this section, we will explore how to define recursive functions.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0002"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c1/recur.clj</code> of the book's source code.</p></div></div><p>In general, a function can be made recursive by simply calling it again from within the body of the function. We can define a simple function to return the first <code class="literal">n</code> numbers of the Fibonacci sequence as shown in <span class="emphasis"><em>Example 1.1</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn fibo
  ([n]
   (fibo [0N 1N] n))
  ([xs n]
   (if (&lt;= n (count xs))
     xs
     (let [x' (+ (last xs)
                 (nth xs (- (count xs) 2)))
           xs' (conj xs x')]
       (fibo xs' n)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.1: A simple recursive function</em></span></p></blockquote></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0003"/>Note</h3><p>The Fibonacci sequence is a series of numbers that can be defined as follows:</p><p>The first element <span class="emphasis"><em>F<sub>0</sub></em></span> is <code class="literal">0</code> and the second element <span class="emphasis"><em>F<sub>1</sub></em></span> is <code class="literal">1</code>.</p><p>The rest of the numbers are the sum of the previous two numbers, that is the nth Fibonacci number <span class="emphasis"><em>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></em></span>.</p></div></div><p>In the previously defined <code class="literal">fibo</code> function, the last two elements of the list are determined using the <code class="literal">nth</code> and <code class="literal">last</code> functions, and the sum of these two elements is appended to the list using the <code class="literal">conj</code> function. This<a class="indexterm" id="id001"/> is done in a recursive manner, and the function terminates when the length of the list, determined by the <code class="literal">count</code> function becomes equal to the supplied value <code class="literal">n</code>. Also, the values <code class="literal">0N</code> and <code class="literal">1N</code>, which represent <code class="literal">BigInteger</code> types, are used instead of the values <code class="literal">0</code> and <code class="literal">1</code>.This is done because using long or integer values for such a computation could result in an arithmetic overflow error. We can try out this function in the REPL shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (fibo 10)</strong></span>
[0N 1N 1N 2N 3N 5N 8N 13N 21N 34N]
<span class="strong"><strong>user&gt; (last (fibo 100))</strong></span>
218922995834555169026N</pre></div><p>The <code class="literal">fibo</code> function returns a vector of the first <code class="literal">n</code> Fibonacci numbers as expected. However, for larger values of <code class="literal">n</code>, this function will cause a stack overflow:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (last (fibo 10000))</strong></span>
StackOverflowError   clojure.lang.Numbers.lt (Numbers.java:219)</pre></div><p>The reason for this error is that there were too many nested function calls. A call to any function requires an additional call stack. With recursion, we reach a point where all of the available stack space in a program is consumed and no more function calls can be performed. A <span class="emphasis"><em>tail call</em></span> can overcome this limitation by using the existing call stack for a recursive call, which removes the need for allocating a new call stack. This is only possible when the return value of a function is the return value of a recursive call made by the function, in which case an additional call stack is not required to store the state of the function that performs the recursive call. This technique is termed as <span class="emphasis"><em>tail call elimination</em></span>. In effect, a tail call optimized function consumes a constant amount of stack space.</p><p>In fact, the <code class="literal">fibo</code> function does indeed make a tail call, as the last expression in the body of the function is a recursive call. Still, it consumes stack space for each recursive call. This is due to the fact that the<a class="indexterm" id="id002"/> underlying virtual machine, the JVM, does not perform tail call elimination. In Clojure, tail call elimination has to be done explicitly using a <code class="literal">recur</code> form to perform a recursive call. The <code class="literal">fibo</code> function we defined earlier can be refined to be <span class="emphasis"><em>tail recursive</em></span> by using a <code class="literal">recur</code> form, as shown in <span class="emphasis"><em>Example 1.2</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn fibo-recur
  ([n]
   (fibo-recur [0N 1N] n))
  ([xs n]
   (if (&lt;= n (count xs))
     xs
     (let [x' (+ (last xs)
                 (nth xs (- (count xs) 2)))
           xs' (conj xs x')]
       (recur xs' n)))))</pre></div><p>Effectively, the <code class="literal">fibo-recur</code> function can perform an infinite number of nested recursive calls. We can observe that this function does not blow up the stack for large values of <code class="literal">n</code>, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (fibo-recur 10)</strong></span>
[0N 1N 1N 2N 3N 5N 8N 13N 21N 34N]
<span class="strong"><strong>user&gt; (last (fibo-recur 10000))</strong></span>
207936...230626N</pre></div><p>We should note that a call to <code class="literal">fibo-recur</code> can take quite a while to terminate for large values of <code class="literal">n</code>. We can measure the time taken for a call to <code class="literal">fibo-recur</code> to complete and return a value, using the <code class="literal">time</code> macro, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (last (fibo-recur 10000)))</strong></span>
"Elapsed time: 1320.050942 msecs"
207936...230626N</pre></div><p>The <code class="literal">fibo-recur</code> function can also be expressed using the <code class="literal">loop</code> and <code class="literal">recur</code> forms. This eliminates the need for using a second function arity to pass the <code class="literal">[0N 1N]</code> value around, as shown in the <code class="literal">fibo-loop</code> function defined in <span class="emphasis"><em>Example 1.3</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn fibo-loop [n]
  (loop [xs [0N 1N]
         n n]
    (if (&lt;= n (count xs))
      xs
      (let [x' (+ (last xs)
                  (nth xs (- (count xs) 2)))
            xs' (conj xs x')]
        (recur xs' n)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.3: A recursive function defined using loop and recur</em></span></p></blockquote></div><p>Note that the <code class="literal">loop</code>
<a class="indexterm" id="id003"/> macro requires a vector of bindings (pairs of names and values) to be passed as its first argument. The second argument to the <code class="literal">loop</code> form must be an expression that uses the <code class="literal">recur</code> form. This nested <code class="literal">recur</code> form calls the surrounding expression recursively by passing in the new values for the declared bindings in the <code class="literal">loop</code> form. The <code class="literal">fibo-loop</code> function returns a value that is equal to that returned by the <code class="literal">fibo-recur</code> function, from <span class="emphasis"><em>Example 1.2</em></span>, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (fibo-loop 10)</strong></span>
[0N 1N 1N 2N 3N 5N 8N 13N 21N 34N]
<span class="strong"><strong>user&gt; (last (fibo-loop 10000))</strong></span>
207936...230626N</pre></div><p>Another way to handle recursion is by using the <code class="literal">trampoline</code> function. The <code class="literal">trampoline</code> function takes a function as its first argument, followed by the values of the parameters to be passed to the supplied function. A <code class="literal">trampoline</code> form expects the supplied function to return another function, and in such a case, the returned function will be invoked. Thus, a <code class="literal">trampoline</code> form manages recursion by obtaining a return value, and invoking the returned value again if it's a function. Thus, the <code class="literal">trampoline</code> function avoids using any stack space. Each time the supplied function is invoked, it returns and the result gets stored in the process heap. For example, consider the function in <span class="emphasis"><em>Example 1.4</em></span> that calculates the first <code class="literal">n</code> numbers of the Fibonacci sequence using a <code class="literal">trampoline</code>:</p><div class="informalexample"><pre class="programlisting">(defn fibo-trampoline [n]
  (letfn [(fibo-fn [xs n]
            (if (&lt;= n (count xs))
              xs
              (let [x' (+ (last xs)
                          (nth xs (- (count xs) 2)))
                    xs' (conj xs x')]
                #(fibo-fn xs' n))))]
    (trampoline fibo-fn [0N 1N] n)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.4: A recursive function defined using trampoline</em></span></p></blockquote></div><p>In the <code class="literal">fib-trampoline</code> function, the internal <code class="literal">fibo-fn</code> function returns either a sequence, denoted by <code class="literal">xs</code>, or a closure that takes no arguments, represented by <code class="literal">#(fibo-fn xs' n)</code>. This function is equivalent to the <code class="literal">fibo-recur</code> function we defined earlier, even in terms of performance, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (fibo-trampoline 10)</strong></span>
[0N 1N 1N 2N 3N 5N 8N 13N 21N 34N]
<span class="strong"><strong>user&gt; (time (last (fibo-trampoline 10000)))</strong></span>
"Elapsed time: 1346.629108 msecs"
207936...230626N</pre></div><p>
<span class="emphasis"><em>Mutual recursion</em></span> can also be handled effectively using a trampoline. In mutual recursion, two functions call each <a class="indexterm" id="id004"/>other in a recursive manner. For example, consider the function that utilizes two mutually recursive functions in <span class="emphasis"><em>Example 1.5</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn sqrt-div2-recur [n]
  (letfn [(sqrt [n]
            (if (&lt; n 1)
              n
              (div2 (Math/sqrt n))))
          (div2 [n]
            (if (&lt; n 1)
              n
              (sqrt (/ n 2))))]
    (sqrt n)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.5: A simple function that uses mutual recursion</em></span></p></blockquote></div><p>The <code class="literal">sqrt-div2-recur</code> function from <span class="emphasis"><em>Example 1.5</em></span> defines two mutually recursive functions internally, namely <code class="literal">sqrt</code> and <code class="literal">div2</code>, that repeatedly square root and halve a given value <code class="literal">n</code> until the calculated value is less than 1. The <code class="literal">sqrt-div2-recur</code> function declares these two functions using a <code class="literal">letfn</code> form and invokes the <code class="literal">sqrt</code> function. We can convert this to use a <code class="literal">trampoline</code> form as shown in <span class="emphasis"><em>Example 1.6</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn sqrt-div2-trampoline [n]
  (letfn [(sqrt [n]
            (if (&lt; n 1)
              n
              #(div2 (Math/sqrt n))))
          (div2 [n]
            (if (&lt; n 1)
              n
              #(sqrt (/ n 2))))]
    (trampoline sqrt n)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.6: A function that uses mutual recursion using trampoline</em></span></p></blockquote></div><p>In the previous <code class="literal">sqrt-div2-trampoline</code> function shown, the functions <code class="literal">sqrt</code> and <code class="literal">div2 </code>return closures instead of calling a function directly. The <code class="literal">trampoline</code> form in the body of the function calls the <code class="literal">sqrt</code> function while supplying the value <code class="literal">n</code>. Both the <code class="literal">sqrt-div2-recur</code> and <code class="literal">sqrt-div2-trampoline</code> functions take about the same time to return a value for the given<a class="indexterm" id="id005"/> value of <code class="literal">n</code>. Hence, using a <code class="literal">trampoline</code> form does not have any additional performance overhead, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (sqrt-div2-recur 10000000000N))</strong></span>
"Elapsed time: 0.327439 msecs"
0.5361105866719398
<span class="strong"><strong>user&gt; (time (sqrt-div2-trampoline 10000000000N))</strong></span>
"Elapsed time: 0.326081 msecs"
0.5361105866719398</pre></div><p>As the preceding examples demonstrate, there are various ways to define recursive functions in Clojure. Recursive functions can be optimized using tail call elimination, by using <code class="literal">recur</code>, and mutual recursion, which is done using the <code class="literal">trampoline</code> function.</p></div></div>
<div class="section" title="Thinking in sequences"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec0013"/>Thinking in sequences</h1></div></div></div><p>A <span class="strong"><strong>sequence</strong></span>, shortened<a class="indexterm" id="id006"/> as a <span class="strong"><strong>seq</strong></span>, is essentially an abstraction of a list. This abstraction provides a unified model or interface to interact with a collection of items. In Clojure, all the primitive data structures, namely strings, lists, vectors, maps, and sets can be treated as sequences. In practice, almost everything that involves iteration can be translated into a sequence of computations. A collection is termed as <span class="strong"><strong>seqable</strong></span> if it<a class="indexterm" id="id007"/> implements the abstraction of a sequence. We will learn everything there is to know about sequences in this section.</p><p>Sequences can also be <span class="emphasis"><em>lazy</em></span>. A lazy sequence <a class="indexterm" id="id008"/>can be thought of as a possibly<a class="indexterm" id="id009"/> infinite series of computed values. The computation of each value is deferred until it is actually needed. We should note that the computation of a recursive function can easily be represented as a lazy sequence. For example, the Fibonacci sequence can be computed by lazily adding the last two elements in the previously computed sequence. This can be implemented as shown in <span class="emphasis"><em>Example 1.7</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0005"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c1/seq.clj</code> of the book's source code.</p></div></div><div class="informalexample"><pre class="programlisting">(defn fibo-lazy [n]
  (-&gt;&gt; [0N 1N]
       (iterate (fn [[a b]] [b (+ a b)]))
       (map first)
       (take n)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.7: A lazy Fibonacci sequence</em></span></p></blockquote></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0006"/>Note</h3><p>The threading macro <code class="literal">-&gt;&gt;</code> is used to pass the result of a given expression as the last argument to the next expression, in a repetitive manner for all expressions in its body. Similarly, the threading macro <code class="literal">-&gt;</code> is used to pass the result of a given expression as the first argument to the subsequent expressions.</p></div></div><p>The <code class="literal">fibo-lazy</code> function from <span class="emphasis"><em>Example 1.7</em></span> uses the <code class="literal">iterate</code>, <code class="literal">map</code>, and <code class="literal">take</code> functions to create a lazy sequence. We will study these functions in more detail later in this section. The <code class="literal">fibo-lazy</code> function takes a single argument <code class="literal">n</code>, which indicates the number of items to be returned by the function. In the <code class="literal">fibo-lazy</code> function, the values <code class="literal">0N</code> and <code class="literal">1N</code> are passed as a vector to the <code class="literal">iterate</code> function, which produces a lazy sequence. The function used for this iteration <a class="indexterm" id="id0010"/>creates a new pair of values <code class="literal">b</code> and <code class="literal">(+ a b)</code> from the initial values <code class="literal">a</code> and <code class="literal">b</code>. </p><p>Next, the <code class="literal">map</code> function applies the <code class="literal">first</code> function to obtain the first element in each resulting vector. A <code class="literal">take</code> form is finally applied to the sequence returned by the <code class="literal">map</code> function to retrieve the first <code class="literal">n</code> values in the sequence. The <code class="literal">fibo-lazy</code> function does not cause any error even when passed relatively large values of <code class="literal">n</code>, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (fibo-lazy 10)</strong></span>
(0N 1N 1N 2N 3N 5N 8N 13N 21N 34N)
<span class="strong"><strong>user&gt; (last (fibo-lazy 10000))</strong></span>
207936...230626N</pre></div><p>Interestingly, the <code class="literal">fibo-lazy</code> function in <span class="emphasis"><em>Example 1.7</em></span> performs significantly better than the recursive functions from <span class="emphasis"><em>Example 1.2</em></span> and <span class="emphasis"><em>Example 1.3</em></span>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (last (fibo-lazy 10000)))</strong></span>
"Elapsed time: 18.593018 msecs"
207936...230626N</pre></div><p>Also, binding the value returned by the <code class="literal">fibo-lazy</code> function to a variable does not really consume any time. This is because this returned value is lazy and not evaluated yet. Also, the type of the return value is <code class="literal">clojure.lang.LazySeq</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (def fibo-xs (fibo-lazy 10000)))</strong></span>
"Elapsed time: 0.191981 msecs"
#'user/fibo-xs
<span class="strong"><strong>user&gt; (type fibo-xs)</strong></span>
clojure.lang.LazySeq</pre></div><p>We can optimize the <code class="literal">fibo-lazy</code> function even further by using <span class="strong"><strong>memoization</strong></span>, which essentially caches the value returned by a function for a given set of inputs. This can be done using the <code class="literal">memoize</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">(def fibo-mem (memoize fibo-lazy))</pre></div><p>The <code class="literal">fibo-mem</code> function is a memoized version of the <code class="literal">fibo-lazy</code> function. Hence, subsequent calls to the <code class="literal">fibo-mem</code> function for the same set of inputs will return values significantly faster, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (last (fibo-mem 10000)))</strong></span>
"Elapsed time: 19.776527 msecs"
207936...230626N
<span class="strong"><strong>user&gt; (time (last (fibo-mem 10000)))</strong></span>
"Elapsed time: 2.82709 msecs"
207936...230626N</pre></div><p>Note that the <code class="literal">memoize</code> function can be applied to any function, and it is not really related to sequences. The function we<a class="indexterm" id="id0011"/> pass to <code class="literal">memoize</code> must be free of side effects, or else any side effects will be invoked only the first time the memoized function is called with a given set of inputs.</p><div class="section" title="Using the seq library"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec0002"/>Using the seq library</h2></div></div></div><p>Sequences are a truly<a class="indexterm" id="id0012"/> ubiquitous abstraction in Clojure. The primary motivation behind using sequences is that any domain with sequence-like data in it can be easily modelled using the standard functions that operate on sequences. This infamous quote from the Lisp world reflects on this design:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"It is better to have 100 functions operate on one data abstraction than 10 functions on 10 data structures."</em></span></p></blockquote></div><p>A sequence can be constructed using the <code class="literal">cons</code> function. We must provide an element and another sequence as arguments to the <code class="literal">cons</code> function. The <code class="literal">first</code> function is used to access the first element in a sequence, and similarly the <code class="literal">rest</code> function is used to obtain the other elements in the sequence, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def xs (cons 0 '(1 2 3)))</strong></span>
#'user/xs
<span class="strong"><strong>user&gt; (first xs)</strong></span>
0
<span class="strong"><strong>user&gt; (rest xs)</strong></span>
(1 2 3)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0007"/>Note</h3><p>The <code class="literal">first</code> and <code class="literal">rest</code> functions in Clojure are equivalent to the <code class="literal">car</code> and <code class="literal">cdr</code> functions, respectively, from traditional Lisps. The <code class="literal">cons</code> function carries on its traditional name.</p></div></div><p>In Clojure, an empty list is<a class="indexterm" id="id0013"/> represented by the literal <code class="literal">()</code>. An empty list is considered as a <span class="emphasis"><em>truthy</em></span> value, and<code class="literal"> </code>does not equate to <code class="literal">nil</code>. This rule is true for any empty collection. An empty list does indeed have a type – it's a list. On the other hand, the <code class="literal">nil</code> literal signifies the absence of a value, of any type, and is not a truthy value. The second argument that is passed to <code class="literal">cons</code> could be empty, in which case the resulting sequence would contain a single element:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cons 0 ())</strong></span>
(0)
<span class="strong"><strong>user&gt; (cons 0 nil)</strong></span>
(0)
<span class="strong"><strong>user&gt; (rest (cons 0 nil))</strong></span>
()</pre></div><p>An interesting quirk is that <code class="literal">nil</code> can be treated as an empty collection, but the converse is not true. We can use the <code class="literal">empty?</code> and <code class="literal">nil?</code> functions to test for an empty collection and a <code class="literal">nil</code> value, respectively. Note that <code class="literal">(empty? nil)</code> returns <code class="literal">true</code>, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (empty? ())</strong></span>
true
<span class="strong"><strong>user&gt; (empty? nil)</strong></span>
true
<span class="strong"><strong>user&gt; (nil? ())</strong></span>
false
<span class="strong"><strong>user&gt; (nil? nil)</strong></span>
true</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0008"/>Note</h3><p>By the <span class="emphasis"><em>truthy</em></span> value, we mean to say a value that will test positive in a conditional expression such as an <code class="literal">if</code> or a <code class="literal">when</code> form.</p></div></div><p>The <code class="literal">rest</code> function <a class="indexterm" id="id0014"/>will return an empty list when supplied an empty list. Thus, the value returned by <code class="literal">rest</code> is always truthy. The <code class="literal">seq</code> function can be used to obtain a sequence from a given collection. It will return <code class="literal">nil</code> for an empty list or collection. Hence, the <code class="literal">head</code>, <code class="literal">rest</code> and <code class="literal">seq</code> functions can be used to iterate over a sequence. The <code class="literal">next</code> function can also be used for iteration, and the expression <code class="literal">(seq (rest coll))</code> is equivalent to <code class="literal">(next coll)</code>, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (= (rest ()) nil)</strong></span>
false
<span class="strong"><strong>user&gt; (= (seq ()) nil)</strong></span>
true
<span class="strong"><strong>user&gt; (= (next ()) nil)</strong></span>
true</pre></div><p>The <code class="literal">sequence</code> function can be used to create a list from a sequence. For example, <code class="literal">nil</code> can be converted into an empty list using the expression <code class="literal">(sequence nil)</code>. In Clojure, the <code class="literal">seq?</code> function is used to check whether a value implements the sequence interface, namely <code class="literal">clojure.lang.ISeq</code>. Only lists implement this interface, and other data structures such as vectors, sets, and maps have to be converted into a sequence by using the <code class="literal">seq</code> function. Hence, <code class="literal">seq?</code> will return <code class="literal">true</code> only for lists. Note that the <code class="literal">list?</code>, <code class="literal">vector?</code>, <code class="literal">map?</code>, and <code class="literal">set?</code> functions can be used to check the concrete type of a given collection. The behavior of the <code class="literal">seq?</code> function with lists and vectors can be described as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (seq? '(1 2 3))</strong></span>
true
<span class="strong"><strong>user&gt; (seq? [1 2 3])</strong></span>
false
<span class="strong"><strong>user&gt; (seq? (seq [1 2 3]))</strong></span>
true</pre></div><p>Only lists and vectors <a class="indexterm" id="id0015"/>provide a guarantee of sequential ordering among elements. In other words, lists and vectors will store their elements in the same order or sequence as they were created. This is in contrast to maps and sets, which can reorder their elements as needed. We can use the <code class="literal">sequential?</code> function to check whether a collection provides sequential ordering:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (sequential? '(1 2 3))</strong></span>
true
<span class="strong"><strong>user&gt; (sequential? [1 2 3])</strong></span>
true
<span class="strong"><strong>user&gt; (sequential? {:a 1 :b 2})</strong></span>
false
<span class="strong"><strong>user&gt; (sequential? #{:a :b})</strong></span>
false</pre></div><p>The <code class="literal">associative?</code> function can be used to determine whether a collection or sequence associates a key with a particular value. Note that this function returns <code class="literal">true</code> only for maps and vectors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (associative? '(1 2 3))</strong></span>
false
<span class="strong"><strong>user&gt; (associative? [1 2 3])</strong></span>
true
<span class="strong"><strong>user&gt; (associative? {:a 1 :b 2})</strong></span>
true
<span class="strong"><strong>user&gt; (associative? #{:a :b})</strong></span>
false</pre></div><p>The behavior of the <code class="literal">associative?</code> function is fairly obvious for a map since a map is essentially a collection of key-value pairs. The fact that a vector is also associative is well justified too, as a vector has an implicit key for a given element, namely the index of the element in the vector. For example, the <code class="literal">[:a :b]</code> vector has two implicit keys, <code class="literal">0</code> and <code class="literal">1</code>, for the elements <code class="literal">:a</code> and <code class="literal">:b</code> respectively. This brings us to an interesting consequence – vectors and maps can be treated as functions that take a single argument, that is a key, and return an associated value, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; ([:a :b] 1)</strong></span>
:b
<span class="strong"><strong>user&gt; ({:a 1 :b 2} :a)</strong></span>
1</pre></div><p>Although they are not associative by nature, sets are also functions. Sets return a value contained in them, or <code class="literal">nil</code>, depending on the argument passed to them, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (#{1 2 3} 1)</strong></span>
1
<span class="strong"><strong>user&gt; (#{1 2 3} 0)</strong></span>
nil</pre></div><p>Now that we have<a class="indexterm" id="id0016"/> familiarized ourselves with the basics of sequences, let's have a look at the many functions that operate over sequences.</p><div class="section" title="Creating sequences"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec0001"/>Creating sequences</h3></div></div></div><p>There are several ways to <a class="indexterm" id="id0017"/>create sequences other than using the <code class="literal">cons</code> function. We have already encountered the <code class="literal">conj</code> function in the earlier examples of this chapter. The <code class="literal">conj</code> function takes a collection as its first argument, followed by any number of arguments to add to the collection. We must note that <code class="literal">conj</code> behaves differently for lists and vectors. When supplied a list, the <code class="literal">conj</code> function adds the other arguments at the head, or start, of the list. In case of a vector, the <code class="literal">conj</code> function will insert the other arguments at the tail, or end, of the vector:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (conj [1 2 3] 4 5 6)</strong></span>
[1 2 3 4 5 6]
<span class="strong"><strong>user&gt; (conj '(1 2 3) 4 5 6)</strong></span>
(6 5 4 1 2 3)</pre></div><p>The <code class="literal">concat</code> function can be used to join or <span class="emphasis"><em>concatenate</em></span> any number of sequences in the order in which they are supplied, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (concat [1 2 3] [])</strong></span>
(1 2 3)
<span class="strong"><strong>user&gt; (concat [] [1 2 3])</strong></span>
(1 2 3)
<span class="strong"><strong>user&gt; (concat [1 2 3] [4 5 6] [7 8 9])</strong></span>
(1 2 3 4 5 6 7 8 9)</pre></div><p>A given sequence can be reversed using the <code class="literal">reverse</code> function, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (reverse [1 2 3 4 5 6])</strong></span>
(6 5 4 3 2 1)
<span class="strong"><strong>user&gt; (reverse (reverse [1 2 3 4 5 6]))</strong></span>
(1 2 3 4 5 6)</pre></div><p>The <code class="literal">range</code> function can be used to generate a sequence of values within a given integer range. The most general form of the <code class="literal">range</code> function takes three arguments—the first argument is the start of the range, the second argument is the end of the range, and the third argument is the step of the range. The step of the range defaults to <code class="literal">1</code>, and the start of the range defaults to <code class="literal">0</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (range 5)</strong></span>
(0 1 2 3 4)
<span class="strong"><strong>user&gt; (range 0 10 3)</strong></span>
(0 3 6 9)
<span class="strong"><strong>user&gt; (range 15 10 -1)</strong></span>
(15 14 13 12 11)</pre></div><p>We must note that the <code class="literal">range</code> function expects the start of the range to be less than the end of the range. If the start of<a class="indexterm" id="id0018"/> the range is greater than the end of the range and the step of the range is positive, the <code class="literal">range</code> function will return an empty list. For example, <code class="literal">(range 15 10)</code> will return <code class="literal">()</code>. Also, the <code class="literal">range</code> function can be called with no arguments, in which case it returns a lazy and infinite sequence starting at <code class="literal">0</code>.</p><p>The <code class="literal">take</code> and <code class="literal">drop</code> functions can be used to take or drop elements in a sequence. Both functions take two arguments, representing the number of elements to take or drop from a sequence, and the sequence itself, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (take 5 (range 10))</strong></span>
(0 1 2 3 4)
<span class="strong"><strong>user&gt; (drop 5 (range 10))</strong></span>
(5 6 7 8 9)</pre></div><p>To obtain an item at a particular position in the sequence, we should use the <code class="literal">nth</code> function. This function takes a sequence as its first argument, followed by the position of the item to be retrieved from the sequence as the second argument:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (nth (range 10) 0)</strong></span>
0
<span class="strong"><strong>user&gt; (nth (range 10) 9)</strong></span>
9</pre></div><p>To repeat a given value, we can use the <code class="literal">repeat</code> function. This function takes two arguments and repeats the second argument the number of times indicated by the first argument:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (repeat 10 0)</strong></span>
(0 0 0 0 0 0 0 0 0 0)
<span class="strong"><strong>user&gt; (repeat 5 :x)</strong></span>
(:x :x :x :x :x)</pre></div><p>The <code class="literal">repeat</code> function will evaluate the expression of the second argument and repeat it. To call a function a number of times, we can use the <code class="literal">repeatedly</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (repeat 5 (rand-int 100))</strong></span>
(75 75 75 75 75)
<span class="strong"><strong>user&gt; (repeatedly 5 #(rand-int 100))</strong></span>
(88 80 17 52 32)</pre></div><p>In this example, the <code class="literal">repeat</code> form first evaluates the <code class="literal">(rand-int 100)</code> form, before repeating it. Hence, a single value will be repeated several times. Note that the <code class="literal">rand-int</code> function simply returns a random integer between <code class="literal">0</code> and the supplied value. On the other hand, the <code class="literal">repeatedly</code> function invokes the supplied function a number of times, thus producing a new value every time the <code class="literal">rand-int</code> function is called.</p><p>A sequence can be<a class="indexterm" id="id0019"/> repeated an infinite number of times using the <code class="literal">cycle</code> function. As you might have guessed, this function returns a lazy sequence to indicate an infinite series of values. The <code class="literal">take</code> function can be used to obtain a limited number of values from the resulting infinite sequence, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (take 5 (cycle [0]))</strong></span>
(0 0 0 0 0)
<span class="strong"><strong>user&gt; (take 5 (cycle (range 3)))</strong></span>
(0 1 2 0 1)</pre></div><p>The <code class="literal">interleave</code> function can be used to combine any number of sequences. This function returns a sequence of the first item in each collection, followed by the second item, and so on. This combination of the supplied sequences is repeated until the shortest sequence is exhausted of values. Hence, we can easily combine a finite sequence with an infinite one to produce another finite sequence using the <code class="literal">interleave</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (interleave [0 1 2] [3 4 5 6] [7 8])</strong></span>
(0 3 7 1 4 8)
<span class="strong"><strong>user&gt; (interleave [1 2 3] (cycle [0]))</strong></span>
(1 0 2 0 3 0)</pre></div><p>Another function that performs a similar operation is the <code class="literal">interpose</code> function. The <code class="literal">interpose</code> function inserts a given element between the adjacent elements of a given sequence:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (interpose 0 [1 2 3])</strong></span>
(1 0 2 0 3)</pre></div><p>The <code class="literal">iterate</code> function can also be used to create an infinite sequence. Note that we have already used the <code class="literal">iterate</code> function to create a lazy sequence in <span class="emphasis"><em>Example 1.7</em></span>. This function takes a function <code class="literal">f</code> and an initial value <code class="literal">x</code> as its arguments. The value returned by the <code class="literal">iterate</code> function will have <code class="literal">(f x)</code> as the first element, <code class="literal">(f (f x))</code> as the second element, and so on. We can use the <code class="literal">iterate</code> function with any other function that takes a single argument, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (take 5 (iterate inc 5))</strong></span>
(5 6 7 8 9)
<span class="strong"><strong>user&gt; (take 5 (iterate #(+ 2 %) 0))</strong></span>
(0 2 4 6 8)</pre></div></div><div class="section" title="Transforming sequences"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec0002"/>Transforming sequences</h3></div></div></div><p>There are also several functions to convert sequences into different representations or values. One of the most versatile of such functions is the <code class="literal">map</code> function. This function <span class="emphasis"><em>maps</em></span> a given function<a class="indexterm" id="id0020"/> over a given sequence, that is, it applies the function to each element in the sequence. Also, the value returned by <code class="literal">map</code> is implicitly lazy. The function to be applied to each element must be the first argument to <code class="literal">map</code>, and the sequence on which the function must be applied is the next argument:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (map inc [0 1 2 3])</strong></span>
(1 2 3 4)
<span class="strong"><strong>user&gt; (map #(* 2 %) [0 1 2 3])</strong></span>
(0 2 4 6)</pre></div><p>Note that <code class="literal">map</code> can accept any number of collections or sequences as its arguments. In this case, the resulting sequence is obtained by passing the first items of the sequences as arguments to the given function, and then passing the second items of the sequences to the given function, and so on until any of the supplied sequences are exhausted. For example, we can sum the corresponding elements of two sequences using the <code class="literal">map</code> and <code class="literal">+</code> functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (map + [0 1 2 3] [4 5 6])</strong></span>
(4 6 8)</pre></div><p>The <code class="literal">mapv</code> function has the same semantics of map, but returns a vector instead of a sequence, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (mapv inc [0 1 2 3])</strong></span>
[1 2 3 4]</pre></div><p>Another variant of the <code class="literal">map</code> function is the <code class="literal">map-indexed</code> function. This function expects that the supplied function will accept two arguments—one for the index of a given element and another for the actual element in the list:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (map-indexed (fn [i x] [i x]) "Hello")</strong></span>
([0 \H] [1 \e] [2 \l] [3 \l] [4 \o])</pre></div><p>In this example, the function supplied to <code class="literal">map-indexed</code> simply returns its arguments as a vector. An interesting point that we can observe from the preceding example is that a string can be treated as a sequence of characters.</p><p>The <code class="literal">mapcat</code> function is a combination of the <code class="literal">map</code> and <code class="literal">concat</code> function. This function maps a given function over a sequence, and applies the <code class="literal">concat</code> function on the resulting sequence:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (require '[clojure.string :as cs])</strong></span>
nil
<span class="strong"><strong>user&gt; (map #(cs/split % #"\d") ["aa1bb" "cc2dd" "ee3ff"])</strong></span>
(["aa" "bb"] ["cc" "dd"] ["ee" "ff"])
<span class="strong"><strong>user&gt; (mapcat #(cs/split % #"\d") ["aa1bb" "cc2dd" "ee3ff"])</strong></span>
("aa" "bb" "cc" "dd" "ee" "ff")</pre></div><p>In this example, we use the <code class="literal">split</code> function from the <code class="literal">clojure.string</code> namespace to split a string using a regular expression, shown as <code class="literal">#"\d"</code>. The <code class="literal">split</code> function will return a vector of strings, and hence the <code class="literal">mapcat</code> function returns a sequence of strings instead of a sequence of vectors like the <code class="literal">map</code> function.</p><p>The <code class="literal">reduce</code> function is used to combine or <span class="emphasis"><em>reduce</em></span> a sequence of items into a single value. The <code class="literal">reduce</code> function requires a function as its first argument and a sequence as its second argument. The function supplied to <code class="literal">reduce</code> must accept two arguments. The supplied function is first applied to the first two elements in the given sequence, and then applied to the previous<a class="indexterm" id="id0021"/> result and the third element in the sequence, and so on until the sequence is exhausted. The <code class="literal">reduce</code> function also has a second arity, which accepts an initial value, and in this case, the supplied function is applied to the initial value and the first element in the sequence as the first step. The <code class="literal">reduce</code> function can be considered equivalent to loop-based iteration in imperative programming languages. For example, we can compute the sum of all elements in a sequence using <code class="literal">reduce</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (reduce + [1 2 3 4 5])</strong></span>
15
<span class="strong"><strong>user&gt; (reduce + [])</strong></span>
0
<span class="strong"><strong>user&gt; (reduce + 1 [])</strong></span>
1</pre></div><p>In this example, when the <code class="literal">reduce</code> function is supplied an empty collection, it returns <code class="literal">0</code>, since <code class="literal">(+)</code> evaluates to <code class="literal">0</code>. When an initial value of <code class="literal">1</code> is supplied to the <code class="literal">reduce</code> function, it returns <code class="literal">1</code>, since <code class="literal">(+ 1)</code> returns <code class="literal">1</code>.</p><p>A <span class="emphasis"><em>list comprehension</em></span> can be created using the <code class="literal">for</code> macro. Note that a <code class="literal">for</code> form will be translated into an<a class="indexterm" id="id0022"/> expression that uses the <code class="literal">map</code> function. The <code class="literal">for</code> macro needs to be supplied a vector of bindings to any number of collections, and an expression in the body. This macro binds the supplied symbol to each element in its corresponding collection and evaluates the body for each element. Note that the <code class="literal">for</code> macro also supports a <code class="literal">:let</code> clause to assign a value to a variable, and also a <code class="literal">:when</code> clause to filter out values:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (for [x (range 3 7)]</strong></span>
<span class="strong"><strong>        (* x x))</strong></span>
(9 16 25 36)
<span class="strong"><strong>user&gt; (for [x [0 1 2 3 4 5]</strong></span>
<span class="strong"><strong>            :let [y (* x 3)]</strong></span>
<span class="strong"><strong>            :when (even? y)]</strong></span>
<span class="strong"><strong>        y)</strong></span>
(0 6 12)</pre></div><p>The <code class="literal">for</code> macro can also be used over a number of collections, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (for [x ['a 'b 'c]</strong></span>
<span class="strong"><strong>            y [1 2 3]]</strong></span>
<span class="strong"><strong>        [x y])</strong></span>
([a 1] [a 2] [a 3] [b 1] [b 2] [b 3] [c 1] [c 2] [c 3])</pre></div><p>The <code class="literal">doseq</code> macro has semantics similar to that of <code class="literal">for</code>, except for the fact that it always returns a <code class="literal">nil</code> value. This macro simply evaluates the body expression for all of the items in the given bindings. This is <a class="indexterm" id="id0023"/>useful in forcing evaluation of an expression with side effects for all the items in a given collection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (doseq [x (range 3 7)]</strong></span>
<span class="strong"><strong>        (* x x))</strong></span>
nil
<span class="strong"><strong>user&gt; (doseq [x (range 3 7)]</strong></span>
<span class="strong"><strong>        (println (* x x)))</strong></span>
9
16
25
36
nil</pre></div><p>As shown in the preceding example, both the first and second <code class="literal">doseq</code> forms return <code class="literal">nil</code>. However, the second form prints the value of the expression <code class="literal">(* x x)</code>, which is a side effect, for all items in the sequence <code class="literal">(range 3 7)</code>.</p><p>The <code class="literal">into</code> function can be used to easily convert between types of collections. This function requires two collections to be supplied to it as arguments, and returns the first collection filled with all the items in the second collection. For example, we can convert a sequence of vectors into a map, and vice versa, using the <code class="literal">into</code> function, shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (into {} [[:a 1] [:c 3] [:b 2]])</strong></span>
{:a 1, :c 3, :b 2}
<span class="strong"><strong>user&gt; (into [] {1 2 3 4})</strong></span>
[[1 2] [3 4]]</pre></div><p>We should note that the <code class="literal">into</code> function is essentially a composition of the <code class="literal">reduce</code> and <code class="literal">conj</code> functions. As <code class="literal">conj</code> is used to fill the first collection, the value returned by the <code class="literal">into</code> function will depend on the type of the first collection. The <code class="literal">into</code> function will behave similar to <code class="literal">conj</code> with respect to lists and vectors, shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (into [1 2 3] '(4 5 6))</strong></span>
[1 2 3 4 5 6]
<span class="strong"><strong>user&gt; (into '(1 2 3) '(4 5 6))</strong></span>
(6 5 4 1 2 3)</pre></div><p>A sequence can be partitioned into smaller ones using the <code class="literal">partition</code>, <code class="literal">partition-all</code> and <code class="literal">partition-by</code> functions. Both the <code class="literal">partition</code> and <code class="literal">partition-all</code> functions take two arguments—one for the number of items <code class="literal">n</code> in the partitioned sequences and another for the sequence to be partitioned. However, the <code class="literal">partition-all</code> function will also return the items from the sequence, which have not been partitioned as a separate sequence, shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (partition 2 (range 11))</strong></span>
((0 1) (2 3) (4 5) (6 7) (8 9))
<span class="strong"><strong>user&gt; (partition-all 2 (range 11))</strong></span>
((0 1) (2 3) (4 5) (6 7) (8 9) (10))</pre></div><p>The <code class="literal">partition</code> and <code class="literal">partition-all</code> functions also accept a step argument, which defaults to the supplied number of items in the partitioned sequences, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (partition 3 2 (range 11))</strong></span>
((0 1 2) (2 3 4) (4 5 6) (6 7 8) (8 9 10))
<span class="strong"><strong>user&gt; (partition-all 3 2 (range 11))</strong></span>
((0 1 2) (2 3 4) (4 5 6) (6 7 8) (8 9 10) (10))</pre></div><p>The <code class="literal">partition</code> function also takes a second sequence as an optional argument, which is used to pad the sequence to be partitioned in case there are items that are not partitioned. This second sequence has to be supplied after the step argument to the <code class="literal">partition</code> function. Note that the<a class="indexterm" id="id0024"/> padding sequence is only used to create a single partition with the items that have not been partitioned, and the rest of the padding sequence is discarded. Also, the padding sequence is only used if there are any items that have not been partitioned. This can be illustrated in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (partition 3 (range 11))</strong></span>
((0 1 2) (3 4 5) (6 7 8))
<span class="strong"><strong>user&gt; (partition 3 3 (range 11 12) (range 11))</strong></span>
((0 1 2) (3 4 5) (6 7 8) (9 10 11))
<span class="strong"><strong>user&gt; (partition 3 3 (range 11 15) (range 11))</strong></span>
((0 1 2) (3 4 5) (6 7 8) (9 10 11))
<span class="strong"><strong>user&gt; (partition 3 4 (range 11 12) (range 11))</strong></span>
((0 1 2) (4 5 6) (8 9 10))</pre></div><p>In this example, we first provide a padding sequence in the second statement as <code class="literal">(range 11 12)</code>, which only comprises of a single element. In the next statement, we supply a larger padding sequence, as <code class="literal">(range 11 15)</code>, but only the first item <code class="literal">11</code> from the padding sequence is actually used. In the last statement, we also supply a padding sequence but it is never used, as the <code class="literal">(range 11)</code> sequence is partitioned into sequences of 3 elements each with a step of <code class="literal">4</code>, which will have no remaining items.</p><p>The <code class="literal">partition-by</code> function requires a higher-order function to be supplied to it as the first argument, and will partition items in the supplied sequence based on the return value of applying the given function to each element in the sequence. The sequence is essentially partitioned by <code class="literal">partition-by</code> whenever the given function returns a new value, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (partition-by #(= 0 %) [-2 -1 0 1 2])</strong></span>
((-2 -1) (0) (1 2))
<span class="strong"><strong>user&gt; (partition-by identity [-2 -1 0 1 2])</strong></span>
((-2) (-1) (0) (1) (2))</pre></div><p>In this example, the second statement partitions the given sequence into sequences that each contain a single item as we have used the <code class="literal">identity</code> function, which simply returns its argument. For the <code class="literal">[-2 -1 0 1 2]</code> sequence, the <code class="literal">identity</code> function returns a new value for each item in the sequence and hence the resulting partitioned sequences all have a single element.</p><p>The <code class="literal">sort</code> function can be used to change the ordering of elements in a sequence. The general form of this function requires a function to compare items and a sequence of items to sort. The supplied function defaults to the <code class="literal">compare</code> function, whose behavior changes depending on the actual type of the items being compared:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (sort [3 1 2 0])</strong></span>
(0 1 2 3)
<span class="strong"><strong>user&gt; (sort &gt; [3 1 2 0])</strong></span>
(3 2 1 0)
<span class="strong"><strong>user&gt; (sort ["Carol" "Alice" "Bob"])</strong></span>
("Alice" "Bob" "Carol")</pre></div><p>If we intend to apply a particular function to each item in a sequence before performing the comparison in a<a class="indexterm" id="id0025"/> <code class="literal">sort</code> form, we should consider using the <code class="literal">sort-by</code> function for a more concise expression. The <code class="literal">sort-by</code> function also accepts a function to perform the actual comparison, similar to the <code class="literal">sort</code> function. The <code class="literal">sort-by</code> function can be demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (sort #(compare (first %1) (first %2)) [[1 1] [2 2] [3 3]])</strong></span>
([1 1] [2 2] [3 3])
<span class="strong"><strong>user&gt; (sort-by first [[1 1] [2 2] [3 3]])</strong></span>
([1 1] [2 2] [3 3])
<span class="strong"><strong>user&gt; (sort-by first &gt; [[1 1] [2 2] [3 3]])</strong></span>
([3 3] [2 2] [1 1])</pre></div><p>In this example, the first and second statements both compare items after applying the <code class="literal">first</code> function to each item in the given sequence. The last statement passes the <code class="literal">&gt;</code> function to the <code class="literal">sort-by</code> function, which returns the reverse of the sequence returned by the first two statements.</p></div><div class="section" title="Filtering sequences"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec0003"/>Filtering sequences</h3></div></div></div><p>Sequences can also be <span class="emphasis"><em>filtered</em></span>, that is transformed by removing some elements from the sequence. There are several standard functions to perform this task. The <code class="literal">keep</code> function can be used to<a class="indexterm" id="id0026"/> remove values from a sequence that produces a <code class="literal">nil</code> value for a given function. The <code class="literal">keep</code> function requires a function and a sequence to be passed to it. The <code class="literal">keep</code> function will apply the given function to each item in the sequence and remove all values that produce <code class="literal">nil</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (keep #(if (odd? %) %) (range 10))</strong></span>
(1 3 5 7 9)
<span class="strong"><strong>user&gt; (keep seq [() [] '(1 2 3) [:a :b] nil])</strong></span>
((1 2 3) (:a :b))</pre></div><p>In this example, the first statement removes all even numbers from the given sequence. In the second statement, the <code class="literal">seq</code> function is used to remove all empty collections from the given sequence.</p><p>A map or a set can also be passed as the first argument to the <code class="literal">keep</code> function since they can be treated as functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (keep {:a 1, :b 2, :c 3} [:a :b :d])</strong></span>
(1 2)
<span class="strong"><strong>user&gt; (keep #{0 1 2 3} #{2 3 4 5})</strong></span>
(3 2)</pre></div><p>The <code class="literal">filter</code> function can also be used to remove some elements from a given sequence. The <code class="literal">filter</code> function expects a predicate function to be passed to it along with the sequence to be<a class="indexterm" id="id0027"/> filtered. The items for which the predicate function does not return a truthy value are removed from the result. The <code class="literal">filterv</code> function is identical to the filter function, except for the fact that it returns a vector instead of a list:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (filter even? (range 10))</strong></span>
(0 2 4 6 8)
<span class="strong"><strong>user&gt; (filterv even? (range 10))</strong></span>
[0 2 4 6 8]</pre></div><p>Both the <code class="literal">filter</code> and <code class="literal">keep</code> functions have similar semantics. However, the primary distinction is that the <code class="literal">filter</code> function returns a subset of the original elements, whereas <code class="literal">keep</code> returns a sequence of non <code class="literal">nil</code> values that are returned by the function supplied to it, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (keep #(if (odd? %) %) (range 10))</strong></span>
(1 3 5 7 9)
<span class="strong"><strong>user&gt; (filter odd? (range 10))</strong></span>
(1 3 5 7 9)</pre></div><p>Note that in this example, if we passed the <code class="literal">odd?</code> function to the <code class="literal">keep</code> form, it would return a list of <code class="literal">true</code> and <code class="literal">false</code> values, as these values are returned by the <code class="literal">odd?</code> function.</p><p>Also, a <code class="literal">for</code> macro with a <code class="literal">:when</code> clause is translated into an expression that uses the <code class="literal">filter</code> function, and hence a <code class="literal">for</code> form can also be used to remove elements from a sequence:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (for [x (range 10) :when (odd? x)] x)</strong></span>
(1 3 5 7 9)</pre></div><p>A vector can be <span class="emphasis"><em>sliced</em></span> using the <code class="literal">subvec</code> function. By sliced, we mean to say that a smaller vector is selected from the original vector depending on the values passed to the <code class="literal">subvec</code> function. The <code class="literal">subvec</code> function takes a vector as its first argument, followed by the index indicating the start of the sliced vector, and finally another optional index that indicates the end of the sliced vector, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (subvec [0 1 2 3 4 5] 3)</strong></span>
[3 4 5]
<span class="strong"><strong>user&gt; (subvec [0 1 2 3 4 5] 3 5)</strong></span>
[3 4]</pre></div><p>Maps can be<a class="indexterm" id="id0028"/> filtered by their keys using the <code class="literal">select-keys</code> function. This function requires a map as the first argument and a vector of keys as a second argument to be passed to it. The vector of keys passed to this function indicates the key-value pairs to be included in the resulting map, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (select-keys {:a 1 :b 2} [:a])</strong></span>
{:a 1}
<span class="strong"><strong>user&gt; (select-keys {:a 1 :b 2 :c 3} [:a :c])</strong></span>
{:c 3, :a 1}</pre></div><p>Another way to select key-value pairs from a map is to use the <code class="literal">find</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (find {:a 1 :b 2} :a)</strong></span>
[:a 1]</pre></div><p>
<code class="literal">take-while</code> and <code class="literal">drop-while</code> are analogous to the <code class="literal">take</code> and <code class="literal">drop</code> functions, and require a predicate to be passed to them, instead of the number of elements to take or drop. The <code class="literal">take-while</code> function takes elements as long as the predicate function returns a truthy value, and similarly the <code class="literal">drop-while</code> function will drop elements for the same condition:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (take-while neg? [-2 -1 0 1 2])</strong></span>
(-2 -1)
<span class="strong"><strong>user&gt; (drop-while neg? [-2 -1 0 1 2])</strong></span>
(0 1 2)</pre></div></div><div class="section" title="Lazy sequences"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec0004"/>Lazy sequences</h3></div></div></div><p>
<code class="literal">lazy-seq</code> and <code class="literal">lazy-cat</code> are the<a class="indexterm" id="id0029"/> most elementary constructs to create lazy sequences. The value<a class="indexterm" id="id0030"/> returned by these functions will always have the type <code class="literal">clojure.lang.LazySeq</code>. The <code class="literal">lazy-seq</code> function is used to wrap a lazily computed expression in a <code class="literal">cons</code> form. This means that the rest of the sequence created by the <code class="literal">cons</code> form is lazily computed. For example, the <code class="literal">lazy-seq</code> function can be used to construct a lazy sequence representing the Fibonacci sequence as shown in <span class="emphasis"><em>Example 1.8</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn fibo-cons [a b]
  (cons a (lazy-seq (fibo-cons b (+ a b)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.8: A lazy sequence created using lazy-seq</em></span></p></blockquote></div><p>The <code class="literal">fibo-cons</code> function requires two initial values, <code class="literal">a</code> and <code class="literal">b</code>, to be passed to it as the initial values, and returns a lazy sequence comprising the first value <code class="literal">a</code> and a lazily computed expression that <a class="indexterm" id="id0031"/>uses the next two values in the sequence, that is, <code class="literal">b</code> and <code class="literal">(+ a b)</code>. In this case, the <code class="literal">cons</code> form will return a lazy sequence, which can be handled using the <code class="literal">take</code> and <code class="literal">last</code> functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def fibo (fibo-cons 0N 1N))</strong></span>
#'user/fibo
<span class="strong"><strong>user&gt; (take 2 fibo)</strong></span>
(0N 1N)
<span class="strong"><strong>user&gt; (take 11 fibo)</strong></span>
(0N 1N 1N 2N 3N 5N 8N 13N 21N 34N 55N)
<span class="strong"><strong>user&gt; (last (take 10000 fibo))</strong></span>
207936...230626N</pre></div><p>Note that the <code class="literal">fibo-cons</code> function from <span class="emphasis"><em>Example 1.8</em></span> recursively calls itself without an explicit <code class="literal">recur</code> form, and yet it does not consume any stack space. This is because the values present in<a class="indexterm" id="id0032"/> a lazy sequence are not stored in a call stack, and all the values are allocated on the process heap.</p><p>Another way to define a lazy Fibonacci sequence is by using the <code class="literal">lazy-cat</code> function. This function essentially concatenates all the sequences it is supplied in a lazy fashion. For example, consider the definition of the Fibonacci sequence in <span class="emphasis"><em>Example 1.9</em></span>:</p><div class="informalexample"><pre class="programlisting">(def fibo-seq
  (lazy-cat [0N 1N] (map + fibo-seq (rest fibo-seq))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.9: A lazy sequence created using lazy-cat</em></span></p></blockquote></div><p>The <code class="literal">fibo-seq</code> variable from <span class="emphasis"><em>Example 1.9</em></span> essentially calculates the Fibonacci sequence using a lazy composition of the <code class="literal">map</code>, <code class="literal">rest,</code> and <code class="literal">+</code> functions. Also, a sequence is required as the initial value, instead of a function as we saw in the definition of <code class="literal">fibo-cons</code> from <span class="emphasis"><em>Example 1.8</em></span>. We can use the <code class="literal">nth</code> function to obtain a number from this sequence as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (first fibo-seq)</strong></span>
0N
<span class="strong"><strong>user&gt; (nth fibo-seq 1)</strong></span>
1N
<span class="strong"><strong>user&gt; (nth fibo-seq 10)</strong></span>
55N
<span class="strong"><strong>user&gt; (nth fibo-seq 9999)</strong></span>
207936...230626N</pre></div><p>As shown previously, <code class="literal">fibo-cons</code> and <code class="literal">fibo-seq</code> are concise and idiomatic representations of the infinite series of numbers in the Fibonacci sequence. Both of these definitions return identical values and do not cause an error due to stack consumption.</p><p>An interesting fact is that most <a class="indexterm" id="id0033"/>of the standard functions that return sequences, such as <code class="literal">map</code> and <code class="literal">filter</code>, are inherently lazy. Any expression that is built using these functions is lazy, and hence<a class="indexterm" id="id0034"/> never evaluated until needed. For example, consider the following expression that uses the <code class="literal">map</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def xs (map println (range 3)))</strong></span>
#'user/xs
<span class="strong"><strong>user&gt; xs</strong></span>
0
1
2
(nil nil nil)</pre></div><p>In this example, the <code class="literal">println</code> function is not called when we define the <code class="literal">xs</code> variable. However, once we try to print it in the REPL, the sequence is evaluated and the numbers are printed out by calling the <code class="literal">println</code> function. Note that <code class="literal">xs</code> evaluates to <code class="literal">(nil nil nil)</code> as the <code class="literal">println</code> function always returns <code class="literal">nil</code>.</p><p>Sometimes, it is necessary to eagerly evaluate a lazy sequence. The <code class="literal">doall</code> and <code class="literal">dorun</code> functions are used for this exact purpose. The <code class="literal">doall</code> function essentially forces evaluation of a lazy sequence along with any side effects of the evaluation. The value returned by <code class="literal">doall</code> is a list of all the elements in the given lazy sequence. For example, let's wrap the <code class="literal">map</code> expression from the previous example in a <code class="literal">doall</code> form, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def xs (doall (map println (range 3))))</strong></span>
0
1
2
#'user/xs
<span class="strong"><strong>user&gt; xs</strong></span>
(nil nil nil)</pre></div><p>Now, the numbers are printed out as soon as <code class="literal">xs</code> is defined, as we force evaluation using the <code class="literal">doall</code> function. The <code class="literal">dorun</code> function has similar semantics as the <code class="literal">doall</code> function, but it always returns <code class="literal">nil</code>. Hence, we can use the <code class="literal">dorun</code> function instead of <code class="literal">doall</code> when we are only interested in the side effects of evaluating the lazy sequence, and not the actual values in it. Another way to call a function with some side effects over all values in a collection is by using the <code class="literal">run!</code> function, which must be passed a function to call and a collection. The <code class="literal">run!</code> function always returns <code class="literal">nil</code>, just like the <code class="literal">dorun</code> form.</p></div></div><div class="section" title="Using zippers"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec0003"/>Using zippers</h2></div></div></div><p>Now that we are well versed with sequences, let's briefly examine <span class="strong"><strong>zippers</strong></span>. Zippers are essentially data structures that <a class="indexterm" id="id0035"/>help in traversing and manipulating <span class="emphasis"><em>trees</em></span>. In Clojure, any collection that contains nested collections is termed as a tree. A zipper can be thought of as a structure that <a class="indexterm" id="id0036"/>contains location information about a tree. Zippers are not an extension of trees, but rather can be used to traverse and realize a tree.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0009"/>Note</h3><p>The following namespaces must be included in your namespace declaration for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.zip :as z]
            [clojure.xml :as xml]))</pre></div><p>The following examples can be found in <code class="literal">src/m_clj/c1/zippers.clj</code> of the book's source code.</p></div></div><p>We can define a simple tree using vector literals, as shown here:</p><div class="informalexample"><pre class="programlisting">(def tree [:a [1 2 3] :b :c])</pre></div><p>The vector <code class="literal">tree</code> is a tree, comprised of the nodes <code class="literal">:a</code>, <code class="literal">[1 2 3]</code>, <code class="literal">:b</code>, and <code class="literal">:c</code>. We can use the <code class="literal">vector-zip</code> function to create a zipper from the vector <code class="literal">tree</code> as follows:</p><div class="informalexample"><pre class="programlisting">(def root (z/vector-zip tree))</pre></div><p>The variable <code class="literal">root</code> defined previously is a zipper and contains location information for traversing the given tree. Note that the <code class="literal">vector-zip</code> function is simply a combination of the standard <code class="literal">seq</code> function and the <code class="literal">seq-zip</code> function from the <code class="literal">clojure.zip</code> namespace. Hence, for trees that are represented as sequences, we should use the <code class="literal">seq-zip</code> function instead. Also, all other functions in the <code class="literal">clojure.zip</code> namespace expect their first argument to be a zipper.</p><p>To traverse the zipper, we must use the <code class="literal">clojure.zip/next</code> function, which returns the next node in the zipper. We can easily iterate over all the nodes in the zipper using a composition of the <code class="literal">iterate</code> and <code class="literal">clojure.zip/next</code> functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def tree-nodes (iterate z/next root))</strong></span>
#'user/tree-nodes
<span class="strong"><strong>user&gt; (nth tree-nodes 0)</strong></span>
[[:a [1 2 3] :b :c] nil]
<span class="strong"><strong>user&gt; (nth tree-nodes 1)</strong></span>
[:a {:l [], :pnodes ... }]
<span class="strong"><strong>user&gt; (nth tree-nodes 2)</strong></span>
[[1 2 3] {:l [:a], :pnodes ... }]
<span class="strong"><strong>user&gt; (nth tree-nodes 3)</strong></span>
[1 {:l [], :pnodes ... }]</pre></div><p>As shown previously, the first node of the zipper represents the original tree itself. Also, the zipper will contain some extra information, other than the value contained in the current node, which is useful in navigating across the given tree. In fact, the return value of the <code class="literal">next</code> function is also a zipper. Once we have completely traversed the given tree, a zipper pointing to the root of the tree will be returned by the <code class="literal">next</code> function. Note that some information in a zipper has been truncated from the preceding REPL output for the sake of readability.</p><p>To navigate to the<a class="indexterm" id="id0037"/> adjacent nodes in a given zipper, we can use the <code class="literal">down</code>, <code class="literal">up</code>, <code class="literal">left</code>, and <code class="literal">right</code> functions. All of these functions return a zipper, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; root z/down)</strong></span>
[:a {:l [], :pnodes ... }]
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right)</strong></span>
[[1 2 3] {:l [:a], :pnodes ... }]
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right z/up)</strong></span>
[[:a [1 2 3] :b :c] nil]
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right z/right)</strong></span>
[:b {:l [:a [1 2 3]], :pnodes ... }]
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right z/left)</strong></span>
[:a {:l [], :pnodes ... }]</pre></div><p>The <code class="literal">down</code>, <code class="literal">up</code>, <code class="literal">left</code>, and <code class="literal">right</code> functions change the location of the <code class="literal">root</code> zipper in the <code class="literal">[:a [1 2 3] :b :c]</code> tree, as shown in the following illustration:</p><div class="mediaobject"><img alt="Using zippers" src="graphics/B05024_01_01.jpg"/></div><p>The preceding diagram shows a zipper at three different locations in the given tree. Initially, the location of the zipper is at the root of the tree, which is the entire vector. The <code class="literal">down</code> function moves the location to the first child node in the tree. The <code class="literal">left</code> and <code class="literal">right</code> functions move<a class="indexterm" id="id0038"/> the location of the zipper to other nodes at the same level or depth in the tree. The <code class="literal">up</code> function moves the zipper to the parent of the node pointed to by the zipper's current location.</p><p>To obtain the node representing the current location of a zipper in a tree, we must use the <code class="literal">node</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right z/right z/node)</strong></span>
:b
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right z/left z/node)</strong></span>
:a</pre></div><p>To navigate to the extreme left or right of a tree, we can use the <code class="literal">leftmost</code> and <code class="literal">rightmost</code> functions, respectively, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; root z/down z/rightmost z/node)</strong></span>
:c
<span class="strong"><strong>user&gt; (-&gt; root z/down z/rightmost z/leftmost z/node)</strong></span>
:a</pre></div><p>The <code class="literal">lefts</code> and <code class="literal">rights</code> functions return the nodes that are present to the left and right, respectively, of a given zipper, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; root z/down z/rights)</strong></span>
([1 2 3] :b :c)
<span class="strong"><strong>user&gt; (-&gt; root z/down z/lefts)</strong></span>
nil</pre></div><p>As the <code class="literal">:a</code> node is the<a class="indexterm" id="id0039"/> leftmost element in the tree, the <code class="literal">rights</code> function will return all of the other nodes in the tree when passed a zipper that has <code class="literal">:a</code> as the current location. Similarly, the <code class="literal">lefts</code> function for the zipper at the <code class="literal">:a</code> node will return an empty value, that is <code class="literal">nil</code>.</p><p>The <code class="literal">root</code> function can be used to obtain the root of a given zipper. It will return the original tree used to construct the zipper, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right z/root)</strong></span>
[:a [1 2 3] :b :c]
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right r/left z/root)</strong></span>
[:a [1 2 3] :b :c]</pre></div><p>The <code class="literal">path</code> function can be used to obtain the path from the root element of a tree to the current location of a given zipper, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def e (-&gt; root z/down z/right z/down))</strong></span>
#'user/e
<span class="strong"><strong>user&gt; (z/node e)</strong></span>
1
<span class="strong"><strong>user&gt; (z/path e)</strong></span>
[[:a [1 2 3] :b :c]
 [1 2 3]]</pre></div><p>In the preceding example, the path of the <code class="literal">1</code> node in <code class="literal">tree</code> is represented by a vector containing the entire tree and the subtree <code class="literal">[1 2 3]</code>. This means that to get to the <code class="literal">1</code> node, we must pass through the root and the subtree <code class="literal">[1 2 3]</code>.</p><p>Now that we have covered the basics of navigating across trees, let's see how we can modify the original tree. The <code class="literal">insert-child</code> function can be used to insert a given element into a tree as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; root (z/insert-child :d) z/root)</strong></span>
[:d :a [1 2 3] :b :c]
<span class="strong"><strong>user&gt; (-&gt; root z/down z/right (z/insert-child 0) z/root)</strong></span>
[:a [0 1 2 3] :b :c]</pre></div><p>We can also remove a node from the zipper using the <code class="literal">remove</code> function. Also, the <code class="literal">replace</code> function can be used to replace a given node in a zipper:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; root z/down z/remove z/root)</strong></span>
[[1 2 3] :b :c]
<span class="strong"><strong>user&gt; (-&gt; root z/down (z/replace :d) z/root)</strong></span>
[:d [1 2 3] :b :c]</pre></div><p>One of the most noteworthy examples of tree-like data is XML. Since zippers are great at handling trees, they also allow us to easily traverse and modify XML content. Note that Clojure already provides the <code class="literal">xml-seq</code> function to convert XML data into a sequence. However, treating an XML document as a sequence has many strange implications. </p><p>One of the main disadvantages of using <code class="literal">xml-seq</code> is that there is no easy way to get to the root of the document from a node if we are iterating over a sequence. Also, <code class="literal">xml-seq</code> only helps us iterate over the XML content; it doesn't deal with modifying it. These limitations can be overcome<a class="indexterm" id="id0040"/> using zippers, as we will see in the upcoming example.</p><p>For example, consider the following XML document:</p><div class="informalexample"><pre class="programlisting">&lt;countries&gt;
  &lt;country name="England"&gt;
    &lt;city&gt;Birmingham&lt;/city&gt;
    &lt;city&gt;Leeds&lt;/city&gt;
    &lt;city capital="true"&gt;London&lt;/city&gt;
  &lt;/country&gt;
  &lt;country name="Germany"&gt;
    &lt;city capital="true"&gt;Berlin&lt;/city&gt;
    &lt;city&gt;Frankfurt&lt;/city&gt;
    &lt;city&gt;Munich&lt;/city&gt;
  &lt;/country&gt;
  &lt;country name="France"&gt;
    &lt;city&gt;Cannes&lt;/city&gt;
    &lt;city&gt;Lyon&lt;/city&gt;
    &lt;city capital="true"&gt;Paris&lt;/city&gt;
  &lt;/country&gt;
&lt;/countries&gt;</pre></div><p>The document shown above contains countries and cities represented as XML nodes. Each country has a number of cities, and a single city as its capital. Some information, such as the name of the country and a flag indicating whether a city is a capital, is encoded in the XML attributes of the nodes.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0011"/>Note</h3><p>The following example expects the XML content shown previously to be present in the <code class="literal">resources/data/sample.xml</code> file, relative to the root of your Leiningen project.</p></div></div><p>Let's define a function to find out all the capital cities in the document, as shown in <span class="emphasis"><em>Example 1.10</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn is-capital-city? [n]
  (and (= (:tag n) :city)
       (= "true" (:capital (:attrs n)))))

(defn find-capitals [file-path]
  (let [xml-root (z/xml-zip (xml/parse file-path))
        xml-seq (iterate z/next (z/next xml-root))]
    (-&gt;&gt; xml-seq
         (take-while #(not= (z/root xml-root) (z/node %)))
         (map z/node)
         (filter is-capital-city?)
         (mapcat :content))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.10: Querying XML with zippers</em></span></p></blockquote></div><p>Firstly, we must note that the <code class="literal">parse</code> function from the <code class="literal">clojure.xml</code> namespace reads an XML document and returns a map representing the document. Each node in this map is another map with the <code class="literal">:tag</code>, <code class="literal">:attrs</code>, and <code class="literal">:content</code> keys associated with the XML node's tag name, attributes, and content respectively.</p><p>In <span class="emphasis"><em>Example 1.10</em></span>, we first define a simple function, <code class="literal">is-capital-city?</code>, to determine whether a given XML node has the <code class="literal">city</code> tag, represented as <code class="literal">:city</code>. The <code class="literal">is-capital-city?</code> function also<a class="indexterm" id="id0041"/> checks whether the XML node contains the <code class="literal">capital</code> attribute, represented as <code class="literal">:capital</code>. If the value of the <code class="literal">capital</code> attribute of a given node is the <code class="literal">"true"</code> string, then the <code class="literal">is-capital-city?</code> function returns <code class="literal">true</code>.</p><p>The <code class="literal">find-capitals</code> function performs most of the heavy lifting in this example. This function first parses XML documents present at the supplied path <code class="literal">file-path</code>, and then converts it into a zipper using the <code class="literal">xml-zip</code> function. We then iterate over the zipper using the <code class="literal">next</code> function until we arrive back at the root node, which is checked by the <code class="literal">take-while</code> function. We then map the <code class="literal">node</code> function over the resulting sequence of zippers using the <code class="literal">map</code> function, and apply the <code class="literal">filter</code> function to find the capital cities among all the nodes. Finally, we use the <code class="literal">mapcat</code> function to obtain the XML content of the filtered nodes and flatten the resulting sequence of vectors into a single list.</p><p>When supplied a file containing the XML content we described earlier, the <code class="literal">find-capitals</code> function returns the names of all capital cities in the document:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (find-capitals "resources/data/sample.xml")</strong></span>
("London" "Berlin" "Paris")</pre></div><p>As demonstrated previously, zippers are apt for dealing with trees and hierarchical data such as XML. More generally, sequences are a great abstraction for collections and several forms of data, and Clojure provides us with a huge toolkit for dealing with sequences. There are several more functions that handle sequences in the Clojure language, and you are <a class="indexterm" id="id0042"/>encouraged to explore them on your own.</p></div></div>
<div class="section" title="Working with pattern matching"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec0015"/>Working with pattern matching</h1></div></div></div><p>In this section, we will examine <span class="emphasis"><em>pattern matching</em></span> in Clojure. Typically, functions that use conditional logic can be defined using the <code class="literal">if</code>, <code class="literal">when</code>, or <code class="literal">cond</code> forms. Pattern matching allows us to define such functions by declaring patterns of the literal values of their parameters. While this idea may appear quite rudimentary, it is a very useful and powerful one, as we <a class="indexterm" id="id0043"/>shall see in the upcoming examples. Pattern matching is also a foundational programming construct in other functional programming languages.</p><p>In Clojure, there is no pattern matching support for functions and forms in the core language. However, it is a common notion among Lisp programmers that we can easily modify or extend the language using macros. Clojure takes this approach as well, and thus pattern matching is made possible using the <code class="literal">match</code> and <code class="literal">defun</code> macros. These macros are<a class="indexterm" id="id0044"/> implemented in the <code class="literal">core.match</code> (<a class="ulink" href="https://github.com/clojure/core.match">https://github.com/clojure/core.match</a>) and <a class="indexterm" id="id0045"/>
<code class="literal">defun</code> (<a class="ulink" href="https://github.com/killme2008/defun">https://github.com/killme2008/defun</a>) community libraries. Both of these libraries are also supported on ClojureScript.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0012"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[org.clojure/core.match "0.2.2"
 :exclusions [org.clojure/tools.analyzer.jvm]]
[defun "0.2.0-RC"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.core.match :as m]
            [defun :as f]))</pre></div><p>The following examples can be found in <code class="literal">src/m_clj/c1/match.clj</code> of the book's source code.</p></div></div><p>Let's consider a simple example that we can model using pattern matching. The XOR logic function returns a true value only when its arguments are exclusive of each other, that is, when they have differing values. In other words, the XOR function will return false when both of its arguments have the same values. We can easily define such a function using the <code class="literal">match</code> macro, as shown in <span class="emphasis"><em>Example 1.11</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn xor [x y]
  (m/match [x y]
           [true true] false
           [false true] true
           [true false] true
           [false false] false))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.11: Pattern matching using the match macro</em></span></p></blockquote></div><p>The <code class="literal">xor</code> function from <span class="emphasis"><em>Example 1.11</em></span> simply matches its arguments, <code class="literal">x</code> and <code class="literal">y</code>, against a given set of patterns, such as <code class="literal">[true true]</code> and <code class="literal">[true false]</code>. If both the arguments are <code class="literal">true</code> or <code class="literal">false</code>, then the function returns <code class="literal">false</code>, or else it returns <code class="literal">true</code>. It's a concise definition that relies on<a class="indexterm" id="id0046"/> the values of the supplied arguments, rather than the use of conditional forms such as <code class="literal">if</code> and <code class="literal">when</code>. The <code class="literal">xor</code> function can be defined alternatively, and even more concisely, by the <code class="literal">defun</code> macro, as shown in <span class="emphasis"><em>Example 1.12</em></span>:</p><div class="informalexample"><pre class="programlisting">(f/defun xor
  ([true true] false)
  ([false true] true)
  ([true false] true)
  ([false false] false))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.12: Pattern match using the defun macro</em></span></p></blockquote></div><p>The definition of the <code class="literal">xor</code> function that uses the <code class="literal">defun</code> macro simply declares the actual values as its arguments. The expression to be returned is thus determined by the values of its inputs. Note that the <code class="literal">defun</code> macro rewrites the definition of the <code class="literal">xor</code> function to use the <code class="literal">match</code> macro. Hence, all patterns supported by the <code class="literal">match</code> macro can also be used with the <code class="literal">defun</code> macro. Both the definitions of the <code class="literal">xor</code> function, from <span class="emphasis"><em>Example 1.11</em></span> and <span class="emphasis"><em>Example 1.12</em></span>, work as expected, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (xor true true)</strong></span>
false
<span class="strong"><strong>user&gt; (xor true false)</strong></span>
true
<span class="strong"><strong>user&gt; (xor false true)</strong></span>
true
<span class="strong"><strong>user&gt; (xor false false)</strong></span>
false</pre></div><p>The <code class="literal">xor</code> function will throw an exception if we try to pass values that have not been declared as a pattern:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (xor 0 0)</strong></span>
IllegalArgumentException No matching clause: [0 0] user/xor ...</pre></div><p>We can define a simple function to compute the <span class="emphasis"><em>n<sup>th</sup></em></span> number of the Fibonacci sequence using the <code class="literal">defun</code> macro, as shown in <span class="emphasis"><em>Example 1.13</em></span>:</p><div class="informalexample"><pre class="programlisting">(f/defun fibo
  ([0] 0N)
  ([1] 1N)
  ([n] (+ (fibo (- n 1))
          (fibo (- n 2)))))</pre></div><p>Note the use of the<a class="indexterm" id="id0047"/> variable <code class="literal">n</code> in the function's pattern rules. This signifies that any value other than <code class="literal">0</code> and <code class="literal">1</code> will match with the pattern definition that uses <code class="literal">n</code>. The <code class="literal">fibo</code> function defined in <span class="emphasis"><em>Example 1.13 </em></span>does indeed calculate the <span class="emphasis"><em>n<sup>th</sup></em></span> Fibonacci sequence, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (fibo 0)</strong></span>
0N
<span class="strong"><strong>user&gt; (fibo 1)</strong></span>
1N
<span class="strong"><strong>user&gt; (fibo 10)</strong></span>
55N</pre></div><p>However, the definition of <code class="literal">fibo</code>, shown in <span class="emphasis"><em>Example 1.13</em></span>, cannot be optimized by tail call elimination. This is due to the fact that the definition of <code class="literal">fibo</code> is tree recursive. By this, we mean to say that the expression <code class="literal">(+ (fibo ...) (fibo ...))</code> requires two recursive calls in order to be evaluated completely. In fact, if we replace the recursive calls to the <code class="literal">fibo</code> function with <code class="literal">recur</code> expressions, the resulting function won't compile. It is fairly simple to convert tree recursion into linear recursion, as shown in <span class="emphasis"><em>Example 1.14</em></span>:</p><div class="informalexample"><pre class="programlisting">(f/defun fibo-recur
  ([a b 0] a)
  ([a b n] (recur b (+ a b) (dec n)))
  ([n] (recur 0N 1N n)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 1.14: A tail recursive function with pattern matching</em></span></p></blockquote></div><p>It is fairly obvious from the definition of the <code class="literal">fibo-recur</code> function, from <span class="emphasis"><em>Example 1.14</em></span>, that it is indeed tail recursive. This function does not consume any stack space, and can be safely called with large values of <code class="literal">n</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (fibo-recur 0)</strong></span>
0N
<span class="strong"><strong>user&gt; (fibo-recur 1)</strong></span>
1N
<span class="strong"><strong>user&gt; (fibo-recur 10)</strong></span>
55N
<span class="strong"><strong>user&gt; (fibo-recur 9999)</strong></span>
207936...230626N</pre></div><p>As the preceding examples show us, pattern matching is a powerful tool in functional programming. Functions that are defined using pattern matching are not only correct and expressive, but <a class="indexterm" id="id0048"/>can also achieve good performance. In this respect, the <code class="literal">core.match</code> and <code class="literal">defun</code> libraries are indispensible tools in the Clojure ecosystem.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec0016"/>Summary</h1></div></div></div><p>In this chapter, we introduced a few programming constructs that can be used in the Clojure language. We've explored recursion using the <code class="literal">recur</code>, <code class="literal">loop</code>, and <code class="literal">trampoline</code> forms. We've also studied the basics of sequences and laziness, while describing the various functions in the Clojure language that are used in creating, transforming, and filtering sequences. Next, we had a look at zippers, and how they can be used to idiomatically handle trees and hierarchical data such as XML. Finally, we briefly explored pattern matching using the <code class="literal">core.match</code> and <code class="literal">defun</code> libraries.</p><p>In the next chapter, we will explore concurrency and parallelism. We will study the various data structures and functions that allow us to leverage these concepts in Clojure in ample detail.</p></div>
<div class="chapter" title="Chapter&#xA0;2.&#xA0;Orchestrating Concurrency and Parallelism"><div class="titlepage"><div><div><h1 class="title"><a id="ch17"/>Chapter 2. Orchestrating Concurrency and Parallelism</h1></div></div></div><p>Let's now examine how concurrent and parallel programming are supported in Clojure. The term<a class="indexterm" id="id0049"/> <span class="emphasis"><em>concurrent programming</em></span> refers to managing more than one task at the same time. <span class="emphasis"><em>Parallel programming</em></span> or <span class="emphasis"><em>parallelism</em></span>, on the other hand, deals with executing multiple tasks at the same time. The distinction between these two terms is that concurrency is <a class="indexterm" id="id0050"/>about how we structure and synchronize multiple tasks, and parallelism is more about running multiple tasks in parallel over multiple cores. The main advantages of using concurrency<a class="indexterm" id="id0051"/> and parallelism can be elaborated as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Concurrent programs can perform multiple tasks simultaneously. For example, a desktop application can have a single task for handling user interaction and another task for handling I/O and network communication. A single processor can be shared among several tasks. Processor utilization is thus more effective in concurrent programs.</li><li class="listitem" style="list-style-type: disc">Parallel programs take advantage of having multiple processor cores. This means that such programs can be made to run faster by executing them on a system with more processor cores. Also, tasks that are computationally expensive can be parallelized to complete in a lesser amount of time.</li></ul></div><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Explore how we can create and synchronize tasks that run concurrently</li><li class="listitem" style="list-style-type: disc">See how to deal with a shared state between concurrent tasks</li><li class="listitem" style="list-style-type: disc">Examine how computations can be parallelized and how we can control the amount of parallelism used to perform these computations</li></ul></div><div class="section" title="Managing concurrent tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec0018"/>Managing concurrent tasks</h1></div></div></div><p>Clojure has a couple of handy constructs that allow us to define concurrent tasks. A <span class="emphasis"><em>thread</em></span> is the most elementary abstraction of a task that runs in the background. In the formal sense, a thread is <a class="indexterm" id="id0052"/>simply a sequence of instructions that can be scheduled for execution. A task that runs in the background of a program is said to execute on a separate thread. Threads will be scheduled for execution on a specific processor by the underlying operating system. Most modern operating systems allow a process to have several threads of execution. The technique of managing multiple threads in a single process is termed as<a class="indexterm" id="id0053"/> <span class="emphasis"><em>multithreading</em></span>.</p><p>While Clojure does support the use of threads, concurrent tasks can be modeled in more elegant ways using other constructs. Let's explore the different ways in which we can define concurrent tasks.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0015"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c2/concurrent.clj</code> of the book's source code.</p></div></div><div class="section" title="Using delays"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec0004"/>Using delays</h2></div></div></div><p>A <span class="emphasis"><em>delay</em></span> can be used to define<a class="indexterm" id="id0054"/> a task whose execution is delayed, or <span class="emphasis"><em>deferred</em></span>, until it is necessary. A delay is only run once, and its result is cached. We<a class="indexterm" id="id0055"/> simply need to wrap the instructions of a given task in a <code class="literal">delay</code> form to define a delay, as shown in <span class="emphasis"><em>Example 2.1</em></span>:</p><div class="informalexample"><pre class="programlisting">(def delayed-1
  (delay
   (Thread/sleep 3000)
   (println "3 seconds later ...")
   1))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.1: A delayed value</em></span></p></blockquote></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0016"/>Note</h3><p>The static <code class="literal">Thread/sleep</code> method<a class="indexterm" id="id0056"/> suspends execution of the current thread of execution for a given number of milliseconds, which is passed as the first argument to this method. We can optionally specify the number of nanoseconds by which the current thread must be suspended as the second argument to the <code class="literal">Thread/sleep</code> method.</p></div></div><p>The <code class="literal">delay</code> form in <span class="emphasis"><em>Example 2.1</em></span> simply sleeps for <code class="literal">3000</code> milliseconds, prints a string and returns the value <code class="literal">1</code>. However, it is not yet <span class="emphasis"><em>realized</em></span>, in the sense that, it is has not been executed yet. The <code class="literal">realized?</code> predicate can be used to check whether a delay has been executed, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (realized? delayed-1)</strong></span>
false
<span class="strong"><strong>user&gt; (realized? delayed-1)           ; after 3 seconds</strong></span>
false</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0017"/>Note</h3><p>We can check whether a value is a delay using the <code class="literal">delay?</code> predicate.</p></div></div><p>The body expressions in a <code class="literal">delay</code> form will not be executed until the value returned by it is actually used. We can obtain the value contained in a delay by dereferencing it using the at-the-rate symbol (<code class="literal">@</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @delayed-1</strong></span>
3 seconds later ...
1
<span class="strong"><strong>user&gt; (realized? delayed-1)</strong></span>
true</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0018"/>Note</h3><p>Using the at-the-rate symbol (<code class="literal">@</code>) to dereference<a class="indexterm" id="id0057"/> a value is the same as using the <code class="literal">deref</code> function. For example, the expression <code class="literal">@x</code> is equivalent to <code class="literal">(deref x)</code>.</p><p>The <code class="literal">deref</code> function <a class="indexterm" id="id0058"/>also has a variant form that accepts three arguments—a value to dereference, the number of milliseconds to wait before timing out, and a value that will be returned in case of a timeout.</p></div></div><p>As shown previously, the expression <code class="literal">@delayed-1</code> returns the value <code class="literal">1</code>, after a pause of 3 seconds. Now, the call to <code class="literal">realized?</code> returns <code class="literal">true</code>. Also, the value returned by the expression <code class="literal">@delayed-1</code> will be cached, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @delayed-1</strong></span>
1</pre></div><p>It is thus evident that the expression <code class="literal">@delayed-1</code> will be blocked for 3 seconds, will print a string, and return a value only once.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0019"/>Note</h3><p>Another way to execute a delay is<a class="indexterm" id="id0059"/> by using the <code class="literal">force</code> function, which takes a delay as an argument. This function executes a given delay if needed, and returns the value of the delay's inner expression.</p></div></div><p>Delays are quite handy for<a class="indexterm" id="id0060"/> representing values or tasks that need not be executed until required. However, a delay will always be executed in the same thread in which it is dereferenced. In other words, delays are <span class="emphasis"><em>synchronous</em></span>. Hence, delays aren't really a solution for representing tasks that run in the background.</p></div><div class="section" title="Using futures and promises"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec0005"/>Using futures and promises</h2></div></div></div><p>As we mentioned earlier, threads are the most elementary way of dealing with background tasks. In<a class="indexterm" id="id0061"/> Clojure, all functions implement the <code class="literal">clojure.lang.IFn</code> interface, which in turn extends the <code class="literal">java.lang.Runnable</code> interface. This <a class="indexterm" id="id0062"/>means that any Clojure function can be<a class="indexterm" id="id0063"/> invoked in a separate thread of execution. For example, consider the<a class="indexterm" id="id0064"/> function in <span class="emphasis"><em>Example 2.2</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn wait-3-seconds []
  (Thread/sleep 3000)
  (println)
  (println "3 seconds later ..."))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.2: A function that waits for 3 seconds</em></span></p></blockquote></div><p>The <code class="literal">wait-3-seconds</code> function in <span class="emphasis"><em>Example 2.2</em></span> waits for <code class="literal">3000</code> milliseconds and prints a new line and a string. We can execute this function on a separate thread by constructing a <code class="literal">java.lang.Thread</code> object from it using the <code class="literal">Thread.</code> constructor. The resulting object can then be scheduled for execution in the background by invoking its <code class="literal">.start</code> method, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (.start (Thread. wait-3-seconds))</strong></span>
nil
user&gt;
3 seconds later ...

user&gt;</pre></div><p>The call to the <code class="literal">.start</code> method returns immediately to the REPL prompt. The <code class="literal">wait-3-seconds</code> function gets executed in the background, and prints to standard output in the REPL after 3 seconds. While using threads does indeed allow execution of tasks in the background, they have a couple shortcomings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is no obvious way to obtain a return value from a function that is executed on a separate thread.</li><li class="listitem" style="list-style-type: disc">Also, using the <code class="literal">Thread.</code> and <code class="literal">.start</code> functions is essentially interop with the underlying JVM. Thus, using these functions in a program's code would mean that the program could be run only on the JVM. We essentially lock our program into a single platform, and the program can't be run on any of the other platforms that Clojure supports.</li></ul></div><p>A <span class="emphasis"><em>future</em></span> is a more idiomatic way to represent a task that is executed in a separate thread. Futures can be concisely defined as values that will be realized in the future. A future represents a task that performs a certain computation and returns the result of the computation. We can create a future using the <code class="literal">future</code> form, as shown in <span class="emphasis"><em>Example 2.3</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn val-as-future [n secs]
  (future
    (Thread/sleep (* secs 1000))
    (println)
    (println (str secs " seconds later ..."))
    n))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.3: A future that sleeps for some time and returns a value</em></span></p></blockquote></div><p>The <code class="literal">val-as-future</code> function defined in <span class="emphasis"><em>Example 2.3</em></span> invokes a future that waits for the number of seconds specified by<a class="indexterm" id="id0065"/> the argument <code class="literal">secs</code>, prints a new line and a string, and finally returns the<a class="indexterm" id="id0066"/> supplied value <code class="literal">n</code>. A call to the <code class="literal">val-as-future</code> function will return a future immediately, and a<a class="indexterm" id="id0067"/> string will be printed after the specified number of seconds, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def future-1 (val-as-future 1 3))</strong></span>
#'user/future-1
user&gt;
3 seconds later ...

user&gt;</pre></div><p>The <code class="literal">realized?</code> and <code class="literal">future-done?</code> predicates can be used to check whether a future has completed, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (realized? future-1)</strong></span>
true
<span class="strong"><strong>user&gt; (future-done? future-1)</strong></span>
true</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0020"/>Note</h3><p>We can check whether a value is a future using the <code class="literal">future?</code> predicate.</p></div></div><p>A future that is being <a class="indexterm" id="id0068"/>executed can be stopped by using the <code class="literal">future-cancel</code> function, which takes a future as its only argument and returns a Boolean value indicating whether the supplied future was cancelled, as depicted here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def future-10 (val-as-future 10 10))</strong></span>
#'user/future-10
<span class="strong"><strong>user&gt; (future-cancel future-10)</strong></span>
true</pre></div><p>We can check whether a future has been cancelled using the <code class="literal">future-cancelled?</code> function. Also, dereferencing a future after it has been cancelled will cause an exception, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (future-cancelled? future-10)</strong></span>
true
<span class="strong"><strong>user&gt; @future-10</strong></span>
CancellationException   java.util.concurrent.FutureTask.report (FutureTask.java:121)</pre></div><p>Now that we are familiar with the notion of representing tasks as futures, let's talk about how multiple futures can be synchronized. Firstly, we can use <span class="emphasis"><em>promises</em></span> to synchronize two or more futures. A promise, created <a class="indexterm" id="id0069"/>using the <code class="literal">promise</code> function, is simply a value that can be set only once. A promise is set, or <span class="emphasis"><em>delivered</em></span>, using the <code class="literal">deliver</code> form. Subsequent calls to<a class="indexterm" id="id0070"/> the <code class="literal">deliver</code> form on a promise that has been delivered will not have any effect, and will return <code class="literal">nil</code>. When a promise is<a class="indexterm" id="id0071"/> not delivered, dereferencing it using the <code class="literal">@</code> symbol or the <code class="literal">deref</code> form will block the current thread of execution. Hence, a promise can be used with a future in<a class="indexterm" id="id0072"/> order to pause the execution of the future until a certain value is available. The <code class="literal">promise</code> and <code class="literal">deliver</code> forms can be quickly demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def p (promise))</strong></span>
#'user/p
<span class="strong"><strong>user&gt; (deliver p 100)</strong></span>
#&lt;core$promise$reify__6363@1792b00: 100&gt;
<span class="strong"><strong>user&gt; (deliver p 200)</strong></span>
nil
<span class="strong"><strong>user&gt; @p</strong></span>
100</pre></div><p>As shown in the preceding output, the first call to the <code class="literal">deliver</code> form using the promise <code class="literal">p</code> sets the value of the promise to <code class="literal">100</code>, and the second call to the <code class="literal">deliver</code> form has no effect.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0021"/>Note</h3><p>The <code class="literal">realized?</code> predicate can be used to check whether a promise instance has been delivered.</p></div></div><p>Another way to synchronize concurrent tasks is by using the <code class="literal">locking</code> form. The <code class="literal">locking</code> form allows only a single task to hold a lock variable, or a <span class="emphasis"><em>monitor</em></span>, at any given point in time. Any value can be treated as a monitor. When a monitor is held, or <span class="emphasis"><em>locked</em></span>, by a certain task, any other concurrent tasks that try to acquire the monitor are blocked until the monitor is available. We can thus use the <code class="literal">locking</code> form to synchronize two or more concurrent futures, as shown in <span class="emphasis"><em>Example 2.4</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn lock-for-2-seconds []
  (let [lock (Object.)
        task-1 (fn []
                 (future
                   (locking lock
                     (Thread/sleep 2000)
                     (println "Task 1 completed"))))
        task-2 (fn []
                 (future
                   (locking lock
                     (Thread/sleep 1000)
                     (println "Task 2 completed"))))]
    (task-1)
    (task-2)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.4: Using the locking form</em></span></p></blockquote></div><p>The <code class="literal">lock-for-2-seconds</code> function in <span class="emphasis"><em>Example 2.4</em></span> creates two functions, <code class="literal">task-1</code> and <code class="literal">task-2</code>, which both invoke futures that try to acquire a monitor, represented by the variable <code class="literal">lock</code>. In this example, we use<a class="indexterm" id="id0073"/> a boring <code class="literal">java.lang.Object</code> instance as a monitor for synchronizing<a class="indexterm" id="id0074"/> two futures. The future invoked by the <code class="literal">task-1</code> function sleeps for two seconds, whereas the future called by the <code class="literal">task-2</code> function sleeps for a single second. The future called by the <code class="literal">task-1</code> function<a class="indexterm" id="id0075"/> is observed to complete first as the future invoked by the <code class="literal">task-2</code> function <a class="indexterm" id="id0076"/>will not be executed until the <code class="literal">locking</code> form in the future obtains the monitor <code class="literal">lock</code>, as shown in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (lock-for-2-seconds)</strong></span>
[#&lt;core$future_call$reify__6320@19ed4e9: :pending&gt;
 #&lt;core$future_call$reify__6320@ac35d5: :pending&gt;]
user&gt;
Task 1 completed
Task 2 completed</pre></div><p>We can thus use the <code class="literal">locking</code> form to synchronize multiple futures. However, the <code class="literal">locking</code> form must be used sparingly as careless use of it could result in a deadlock among concurrent tasks. Concurrent tasks are generally synchronized to pass around a shared state. Clojure allows us to avoid using the <code class="literal">locking</code> form and any possible deadlocks through the use of reference types to represent shared state, as we will examine in the following section.</p></div></div></div>
<div class="section" title="Managing state"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec0019"/>Managing state</h1></div></div></div><p>A program can be <a class="indexterm" id="id0077"/>divided into several parts which can execute concurrently. It is often necessary to share data or state among these concurrently running tasks. Thus, we arrive at the notion of having multiple observers for some data. If the data gets modified, we must ensure that the changes are visible to all observers. For example, suppose there are two threads that read data from a common variable. This data gets modified by one thread, and the change must be propagated to the other thread as soon as possible to avoid inconsistencies.</p><p>Programming languages that support mutability handle this problem by locking over a monitor, as we demonstrated with the <code class="literal">locking</code> form, and maintaining local copies of the data. In such languages, a variable is just a container for data. Whenever a concurrent task accesses a variable that is shared with other tasks, it copies the data from the variable. This is done in order to prevent unwanted overwriting of the variable by other tasks while a task is performing a computation on it. In case the variable is actually modified, a given task will still have its own copy of the shared data. If there are two concurrent tasks that access a given variable, they could simultaneously modify the variable and thus both of the tasks would have an inconsistent view of the data in the given variable. This problem is termed <a class="indexterm" id="id0078"/>as a <span class="emphasis"><em>race condition</em></span>, and must be avoided when dealing with concurrent tasks. For this reason, monitors are used to synchronize access to <a class="indexterm" id="id0079"/>shared data. However, this methodology is not really <span class="emphasis"><em>deterministic</em></span>, in the sense that we cannot easily reason about the actual data contained in a variable at a given point in time. This makes <a class="indexterm" id="id0080"/>developing concurrent programs quite cumbersome in programming languages that use mutability.</p><p>Like other functional programming languages, Clojure tackles this problem using <span class="emphasis"><em>immutability</em></span>—all values are immutable by default and cannot be changed. To model mutable state, there is the notion of <span class="emphasis"><em>identity</em></span>, <span class="emphasis"><em>state</em></span>, and <span class="emphasis"><em>time</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An <span class="emphasis"><em>identity</em></span> is anything that is<a class="indexterm" id="id0081"/> associated with a changing state. At a given point in time, an identity has a single state.</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>State</em></span> is the value<a class="indexterm" id="id0082"/> associated with an identity at a given point in time.</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Time</em></span> defines an ordering between<a class="indexterm" id="id0083"/> the states of an identity.</li></ul></div><p>Programs that actually use state can thus be divided into two layers. One layer is purely functional and has nothing to do with state. The other layer constitutes parts of the program that actually require the use of mutable state. This decomposition allows us to isolate the parts of a program that actually require the use of mutable state.</p><p>There are several ways to<a class="indexterm" id="id0084"/> define mutable state in Clojure, and the data structures used for this purpose are termed as <span class="emphasis"><em>reference types</em></span>. A reference type is essentially a mutable reference to an immutable value. Hence, the reference has to be changed explicitly, and the actual value contained in a reference type cannot be modified in any way. Reference types can be characterized in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The change of state in<a class="indexterm" id="id0085"/> some reference types can<a class="indexterm" id="id0086"/> either be <span class="emphasis"><em>synchronous</em></span> or <span class="emphasis"><em>asynchronous</em></span>. For example, suppose we are <a class="indexterm" id="id0087"/>writing data to a file. A synchronous write operation would block the caller until all data is written to the file. On the other hand, an asynchronous write operation would start off a background task to write all data to the file and return to the caller immediately.</li><li class="listitem" style="list-style-type: disc">Mutation of a reference type can be performed in either a <span class="emphasis"><em>coordinated</em></span> or an <span class="emphasis"><em>independent</em></span> manner. By coordinated, we mean that state can only be modified within transactions that are managed by some underlying system, which is quite similar to the<a class="indexterm" id="id0088"/> way a database works. A reference type that mutates independently, however, can be changed without the explicit use of a transaction.</li><li class="listitem" style="list-style-type: disc">Changes in some state <a class="indexterm" id="id0089"/>can be visible to only the thread in which the change occurs, or they could be visible to all threads in the current <a class="indexterm" id="id0090"/>process.</li></ul></div><p>We will now explore the various reference types that can be used to represent mutable state in Clojure.</p><div class="section" title="Using vars"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec0006"/>Using vars</h2></div></div></div><p>
<span class="emphasis"><em>Vars</em></span> are used to manage<a class="indexterm" id="id0091"/> state that is changed within the scope of a thread. We essentially define vars that can have state, and then bind them to different values. The <a class="indexterm" id="id0092"/>modified value of a var is only visible to the current thread of execution. Hence, vars are a form of the <span class="emphasis"><em>thread-local</em></span> state.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0022"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c2/vars.clj</code> of the book's source code.</p></div></div><p>Dynamic vars are defined using the <code class="literal">def</code> form with the <code class="literal">:dynamic</code> meta keyword. If we omit the <code class="literal">:dynamic</code> metadata, it would be the same as defining an ordinary variable, or a static var, using a <code class="literal">def</code> form. It's a convention that all dynamic var names must start and end with the asterisk character (<code class="literal">*</code>), but this is not mandatory. For example, let's define a dynamic variable shown as follows:</p><div class="informalexample"><pre class="programlisting">(def ^:dynamic *thread-local-state* [1 2 3])</pre></div><p>The <code class="literal">*thread-local-state*</code> variable defined in <span class="emphasis"><em>Example 2.5</em></span> represents a thread-local var that can change dynamically. We have initialized the var <code class="literal">*thread-local-state*</code> with the vector <code class="literal">[1 2 3]</code>, but it's not really required. In case an initial value is not supplied to a <code class="literal">def</code> form, then the resulting variable is termed as an <span class="emphasis"><em>unbound</em></span> var. While the state of a var is confined to the current thread, its <a class="indexterm" id="id0093"/>declaration is global to the current namespace. In other words, a var defined with the <code class="literal">def</code> form will be visible to all threads invoked from the current namespace, but the state of the variable is local to the thread in which it is changed. Thus, vars using the <code class="literal">def</code> form are also termed as <a class="indexterm" id="id0094"/>
<span class="emphasis"><em>global vars</em></span>.</p><p>Normally, the <code class="literal">def</code> form creates a static var, which can only be redefined by using another <code class="literal">def</code> form. Static vars can also be redefined within a scope or context using the <code class="literal">with-redefs</code> and <code class="literal">with-redefs-fn</code> forms. A dynamic var, however, can be set to a new value after it has been defined by using the <code class="literal">binding</code> form, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (binding [*thread-local-state* [10 20]]</strong></span>
<span class="strong"><strong>        (map #(* % %) *thread-local-state*))</strong></span>
(100 400)
<span class="strong"><strong>user&gt; (map #(* % %) *thread-local-state*)</strong></span>
(1 4 9)</pre></div><p>In this example, the <code class="literal">binding</code> form changes the value contained in the <code class="literal">*thread-local-state*</code> var to the vector <code class="literal">[10 20]</code>. This causes the <code class="literal">map</code> form in the example to return a different value when called without a <code class="literal">binding</code> form surrounding it. Thus, the <code class="literal">binding</code> form can be used to temporarily change the state of the vars supplied to it.</p><p>The Clojure namespace<a class="indexterm" id="id0095"/> system will resolve free symbols, or rather variable names, to their values. This process of resolving a variable name to a namespace qualified symbol is<a class="indexterm" id="id0096"/> termed as <span class="emphasis"><em>interning</em></span>. Also, a <code class="literal">def</code> form will first look for an existing global var depending on the <a class="indexterm" id="id0097"/>symbol it is passed, and will create one if it hasn't been defined yet. The <code class="literal">var</code> form can be used to obtain the fully qualified name of a variable, instead of its current value, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; *thread-local-state*</strong></span>
[1 2 3]
<span class="strong"><strong>user&gt; (var *thread-local-state*)</strong></span>
#'user/*thread-local-state*</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0023"/>Note</h3><p>Using the <code class="literal">#'</code> symbol is the same as using the <code class="literal">var</code> form. For example, <code class="literal">#'x</code> is equivalent to <code class="literal">(var x)</code>.</p></div></div><p>The <code class="literal">with-bindings</code> form is another way to rebind vars. This form accepts a map of var and value pairs as its first argument, followed by the body of the form, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (with-bindings {#'*thread-local-state* [10 20]}</strong></span>
<span class="strong"><strong>        (map #(* % %) *thread-local-state*))</strong></span>
(100 400)
<span class="strong"><strong>user&gt; (with-bindings {(var *thread-local-state*) [10 20]}</strong></span>
<span class="strong"><strong>        (map #(* % %) *thread-local-state*))</strong></span>
(100 400)</pre></div><p>We can check if a var is bound to any value in the current thread of execution using the <code class="literal">thread-bound?</code> predicate, which requires a var to be passed as its only argument:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def ^:dynamic *unbound-var*)</strong></span>
#'user/*unbound-var*
<span class="strong"><strong>user&gt; (thread-bound? (var *unbound-var*))</strong></span>
false
<span class="strong"><strong>user&gt; (binding [*unbound-var* 1]</strong></span>
<span class="strong"><strong>        (thread-bound? (var *unbound-var*)))</strong></span>
true</pre></div><p>We can also define vars that are<a class="indexterm" id="id0098"/> not interned, or <span class="emphasis"><em>local vars</em></span>, using the <code class="literal">with-local-vars</code> form. These vars will not be resolved by the namespace system, and have to be accessed manually using the <code class="literal">var-get</code> and <code class="literal">var-set</code> functions. These functions can thus be used to create and access mutable variables, as shown in <span class="emphasis"><em>Example 2.5</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0024"/>Note</h3><p>Using the at-the-rate symbol (<code class="literal">@</code>) with a non-interned var is the same as using the <code class="literal">var-get</code> function. For example, if <code class="literal">x</code> is a non-interned var, <code class="literal">@x</code> is equivalent to <code class="literal">(var-get x)</code>.</p></div></div><div class="informalexample"><pre class="programlisting">(defn factorial [n]
  (with-local-vars [i n acc 1]
    (while (&gt; @i 0)
      (var-set acc (* @acc @i))
      (var-set i (dec @i)))
    (var-get acc)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.5: Mutable variables using the with-local-vars form</em></span></p></blockquote></div><p>The <code class="literal">factorial</code> function defined in <span class="emphasis"><em>Example 2.5</em></span> calculated the factorial of <code class="literal">n</code> using two mutable local vars <code class="literal">i</code> and <code class="literal">acc</code>, which are initialized with the values <code class="literal">n</code> and <code class="literal">1</code> respectively. Note that the code<a class="indexterm" id="id0099"/> in this function exhibits an imperative style of programming, in which the state of the variables <code class="literal">i</code> and <code class="literal">acc</code> is manipulated<a class="indexterm" id="id00100"/> using the <code class="literal">var-get</code> and <code class="literal">var-set</code> functions.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0025"/>Note</h3><p>We can check whether a value has been created through a <code class="literal">with-local-vars</code> form using the <code class="literal">var?</code> predicate.</p></div></div></div><div class="section" title="Using refs"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec0007"/>Using refs</h2></div></div></div><p>A <span class="strong"><strong>Software Transactional Memory</strong></span> (<span class="strong"><strong>STM</strong></span>) system <a class="indexterm" id="id00101"/>can also be used to model mutable state. STM essentially<a class="indexterm" id="id00102"/> treats mutable state as a tiny database that resides in a program's memory. Clojure provides an<a class="indexterm" id="id00103"/> STM implementation through <span class="emphasis"><em>refs</em></span>, and they can only be changed within a transaction. Refs are a reference type that represent <span class="emphasis"><em>synchronous</em></span> and<a class="indexterm" id="id00104"/> <span class="emphasis"><em>coordinated</em></span> state.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0026"/>Note</h3><p>The following <a class="indexterm" id="id00105"/>examples can be found in <code class="literal">src/m_clj/c2/refs.clj</code> of the book's source code.</p></div></div><p>We can create a ref by using the <code class="literal">ref</code> function, which requires a single argument to indicate the initial state of the ref. For example, we can create a ref as follows:</p><div class="informalexample"><pre class="programlisting">(def state (ref 0))</pre></div><p>The variable <code class="literal">state</code> defined here represents a ref with the initial value of <code class="literal">0</code>. We can dereference <code class="literal">state</code> using <code class="literal">@</code> or <code class="literal">deref</code> to obtain the value contained in it.</p><p>In order to modify a ref, we must start a transaction by using the <code class="literal">dosync</code> form. If two concurrent tasks invoke transactions using the <code class="literal">dosync</code> form simultaneously, then the transaction that completes first will update the ref successfully. The transaction which completes later will be retried until it completes successfully. Thus, I/O and other side-effects must be avoided within a <code class="literal">dosync</code> form, as it can be retried. Within a transaction, we can modify the value of a ref using the <code class="literal">ref-set</code> function. This function takes two arguments—a ref and the value that represents the new state of the ref. The <code class="literal">ref-set</code> function can be used to modify a ref as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @state</strong></span>
0
<span class="strong"><strong>user&gt; (dosync (ref-set state 1))</strong></span>
1
<span class="strong"><strong>user&gt; @state</strong></span>
1</pre></div><p>Initially, the expression <code class="literal">@state</code> returns <code class="literal">0</code>, which is the initial state of the ref <code class="literal">state</code>. The value returned by this expression changes after the call to <code class="literal">ref-set</code> within the <code class="literal">dosync</code> form.</p><p>We can obtain the<a class="indexterm" id="id00106"/> latest value contained in a ref by using the <code class="literal">ensure</code> function. This function returns the latest value of a ref, and has to be called within a transaction. For example, the expression <code class="literal">(ensure state)</code>, when called within a transaction initiated by a <code class="literal">dosync</code> form, will return the latest value of the ref <code class="literal">state</code> in the transaction.</p><p>A more idiomatic <a class="indexterm" id="id00107"/>way to modify a given ref is by using the <code class="literal">alter</code> and <code class="literal">commute</code> functions. Both these functions require a ref and a function to be passed to it as arguments. The <code class="literal">alter</code> and <code class="literal">commute</code> functions will apply the supplied function to the value contained in a given ref, and save the resulting value into the ref. We can also specify additional arguments to pass to the supplied function. For example, we can modify the state of the ref <code class="literal">state</code> using <code class="literal">alter</code> and <code class="literal">commute</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @state</strong></span>
1
<span class="strong"><strong>user&gt; (dosync (alter state + 2))</strong></span>
3
<span class="strong"><strong>user&gt; (dosync (commute state + 2))</strong></span>
5</pre></div><p>The preceding transactions with the <code class="literal">alter</code> and <code class="literal">commute</code> forms will save the value <code class="literal">(+ @state 2)</code> into the ref <code class="literal">state</code>. The main difference between <code class="literal">alter</code> and <code class="literal">commute</code> is that a <code class="literal">commute</code> form must be preferred when the supplied function is <span class="emphasis"><em>commutative</em></span>. This means two successive calls of the function supplied to a <code class="literal">commute</code> form must produce the same result regardless of the ordering among the two calls. Using the <code class="literal">commute</code> form is considered an optimization over the <code class="literal">alter</code> form in which we are not concerned with the ordering among concurrent transactions on a given ref.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0027"/>Note</h3><p>The <code class="literal">ref-set</code>, <code class="literal">alter</code>, and <code class="literal">commute</code> functions all return the new value contained in the supplied ref. Also, these functions will throw an error if they are not called within a <code class="literal">dosync</code> form.</p></div></div><p>A mutation <a class="indexterm" id="id00108"/>performed by the <code class="literal">alter</code> and <code class="literal">commute</code> forms can also be validated. This is achieved using the <code class="literal">:validator</code> key option when creating a ref, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def r (ref 1 :validator pos?))</strong></span>
#'user/r
<span class="strong"><strong>user&gt; (dosync (alter r (fn [_] -1)))</strong></span>
IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)
<span class="strong"><strong>user&gt; (dosync (alter r (fn [_] 2)))</strong></span>
2</pre></div><p>As shown <a class="indexterm" id="id00109"/>previously, the ref <code class="literal">r</code> throws an exception when we try to change its state to a negative value. This is because the <code class="literal">pos?</code> function is used to validate the new state of the ref. Note that the <code class="literal">:validator</code> key option can be used with other reference types as well. We can also set the validation function of a ref that was created without a <code class="literal">:validator</code> key option using the <code class="literal">set-validator!</code> function.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0028"/>Note</h3><p>The <code class="literal">:validator</code> key option and the <code class="literal">set-validator!</code> function can be used with <span class="emphasis"><em>all</em></span> reference types. The supplied validation function must return <code class="literal">false</code> or throw an exception to indicate a validation error.</p></div></div><p>The <span class="emphasis"><em>dining philosophers problem</em></span> depicts<a class="indexterm" id="id00110"/> the use of synchronization primitives to share resources. The problem can be defined as follows: five philosophers are seated on a round table to eat spaghetti, and each philosopher requires two forks to eat from his plate of spaghetti. There are five forks on the table, placed in between the five philosophers. A philosopher will first have to pick up a fork from his left side as well as one from his right side before he can eat. When a philosopher cannot obtain the two forks to his left and right side, he must wait until both the forks are available. After a philosopher is done eating his spaghetti, he will think for some time, thereby allowing the other<a class="indexterm" id="id00111"/> philosophers to use the forks that he used. The solution to this problem requires that all philosophers share the forks among them, and none of the philosophers starve due to being unable to get two forks. The five philosophers' plates and forks are placed on the table as illustrated in the following diagram:</p><div class="mediaobject"><img alt="Using refs" src="graphics/B05024_02_01.jpg"/></div><p>A philosopher must obtain exclusive access to the forks on his left and right side before he starts eating. If both the forks are unavailable, the philosopher must wait for some time for either one of the forks to be free, and retry obtaining the forks. This way, each philosopher can access the forks in tandem with the other philosophers and avoid starvation. </p><p>Generally, this solution can be implemented by using synchronization primitives to<a class="indexterm" id="id00112"/> access the available forks. Refs allow us to implement a solution to the dining philosophers problem without the use of any synchronization <a class="indexterm" id="id00113"/>primitives. We will now demonstrate how we can implement and simulate a solution to this problem in Clojure. Firstly, we will have to define the states of a fork and a philosopher as refs, as shown in <span class="emphasis"><em>Example 2.6</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn make-fork []
  (ref true))

(defn make-philosopher [name forks food]
  (ref {:name name
        :forks forks
        :eating? false
        :food food}))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.6: The dining philosophers problem using refs</em></span></p></blockquote></div><p>The <code class="literal">make-fork</code> and <code class="literal">make-philosopher</code> functions create refs to represent the states of a fork and a philosopher, respectively. A fork is simply the state of a Boolean value, indicating whether it is available or not. And a philosopher, created by the <code class="literal">make-philosopher</code> function, is a map encapsulated as a state, which has the following keys:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">:name</code> key contains the name of a philosopher that is a string value.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">:forks</code> key points to the forks on the left and the right side of a philosopher. Each fork will be a ref created by the <code class="literal">make-fork</code> function.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">:eating?</code> key indicates whether a philosopher is eating at the moment. It is a Boolean value.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">:food</code> key represents the amount of food available to a philosopher. For simplicity, we will treat this value as an integer.</li></ul></div><p>Now, let's define some primitive operations to help in handling forks, as shown in <span class="emphasis"><em>Example 2.7</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn has-forks? [p]
  (every? true? (map ensure (:forks @p))))

(defn update-forks [p]
  (doseq [f (:forks @p)]
    (commute f not))
  p)</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.7: The dining philosophers problem using refs (continued)</em></span></p></blockquote></div><p>The <code class="literal">has-forks?</code> function defined previously checks whether both the forks that are placed to the left<a class="indexterm" id="id00114"/> and right of a given philosopher ref <code class="literal">p</code> are available. The <code class="literal">update-forks</code> function will modify the state of both the associated forks of a philosopher ref <code class="literal">p</code> using a <code class="literal">commute</code> form, and returns the ref <code class="literal">p</code>. Obviously, these functions can only be called within a transaction created by the <code class="literal">dosync</code> form, since they use the <code class="literal">ensure</code> and <code class="literal">commute</code> functions. Next, we will have to define some functions to initiate transactions<a class="indexterm" id="id00115"/> and invoke the <code class="literal">has-forks?</code> and <code class="literal">update-forks</code> functions for a given philosopher, as shown in <span class="emphasis"><em>Example 2.8</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn start-eating [p]
  (dosync
   (when (has-forks? p)
     (update-forks p)
     (commute p assoc :eating? true)
     (commute p update-in [:food] dec))))

(defn stop-eating [p]
  (dosync
   (when (:eating? @p)
     (commute p assoc :eating? false)
     (update-forks p))))

(defn dine [p retry-ms max-eat-ms max-think-ms]
  (while (pos? (:food @p))
    (if (start-eating p)
      (do
        (Thread/sleep (rand-int max-eat-ms))
        (stop-eating p)
        (Thread/sleep (rand-int max-think-ms)))
      (Thread/sleep retry-ms))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.8: The dining philosophers problem using refs (continued)</em></span></p></blockquote></div><p>The heart of the solution to the dining philosophers problem is the <code class="literal">start-eating</code> function in <span class="emphasis"><em>Example 2.8</em></span>. This function will check whether both the forks on either side of a philosopher are available, using the <code class="literal">has-forks?</code> function. The <code class="literal">start-eating</code> function will then proceed to update the states of these forks by calling the <code class="literal">update-forks</code> function. The <code class="literal">start-eating</code> function will also change the state of the philosopher ref <code class="literal">p</code> by invoking <code class="literal">commute</code> with the <code class="literal">assoc</code> and <code class="literal">update-in</code> functions, which both return a new map. Since the <code class="literal">start-eating</code> function uses a <code class="literal">when</code> form, it will return <code class="literal">nil</code> when any of the philosophers' forks are unavailable. These few steps are the solution; in a <a class="indexterm" id="id00116"/>nutshell, a philosopher will eat only when both his forks are available.</p><p>The <code class="literal">stop-eating</code> function in <span class="emphasis"><em>Example 2.8</em></span> reverses the state of a given philosopher ref after the <code class="literal">start-eating</code> function has been invoked on it. This function basically sets the <code class="literal">:eating</code> key of the map contained in the supplied philosopher ref <code class="literal">p</code> to <code class="literal">false</code> using a <code class="literal">commute</code> form, and then calls <code class="literal">update-forks</code> to reset the state of the associated forks of the philosopher ref <code class="literal">p</code>.</p><p>The <code class="literal">start-eating</code> and <code class="literal">stop-eating</code> function can be called repeatedly in a loop using a <code class="literal">while</code> form, as long as the <code class="literal">:food</code> key of a philosopher ref <code class="literal">p</code>, or rather the amount of available food, is a<a class="indexterm" id="id00117"/> positive value. This is performed by the <code class="literal">dine</code> function in <span class="emphasis"><em>Example 2.8</em></span>. This function will call the <code class="literal">start-eating</code> function on a philosopher ref <code class="literal">p</code>, and will wait for some time if the philosopher's forks are being used by any other philosophers. The amount of time that a philosopher waits for is indicated by the <code class="literal">retry-ms</code> argument that is passed to the dine function. If a philosopher's forks are available, he eats for a random amount of time, as indicated by the expression <code class="literal">(rand-int max-eat-ms)</code>. Then, the <code class="literal">stop-eating</code> function is called to reset the state of the philosopher ref <code class="literal">p</code> and the forks that it contains. Finally, the <code class="literal">dine</code> function waits for a random amount of time, which is represented by the <code class="literal">(rand-int max-think-ms)</code> expression, to indicate that a philosopher is thinking.</p><p>Let's now define some function and actually create some refs representing philosophers and associated forks, as shown in <span class="emphasis"><em>Example 2.9</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn init-forks [nf]
  (repeatedly nf #(make-fork)))

(defn init-philosophers [np food forks init-fn]
  (let [p-range (range np)
        p-names (map #(str "Philosopher " (inc %))
                     p-range)
        p-forks (map #(vector (nth forks %)
                              (nth forks (-&gt; % inc (mod np))))
                     p-range)
        p-food (cycle [food])]
    (map init-fn p-names p-forks p-food)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.9: The dining philosophers problem using refs (continued)</em></span></p></blockquote></div><p>The <code class="literal">init-forks</code> function from <span class="emphasis"><em>Example 2.9</em></span> will simply invoke the <code class="literal">make-fork</code> function a number of times, as indicated by its argument <code class="literal">nf</code>. The <code class="literal">init-philosophers</code> function will create <code class="literal">np</code> number of philosophers and associate each of them with a vector of two forks and a certain amount of food. This is done by mapping the function <code class="literal">init-fn</code>, which is a function that matches the arity of the <code class="literal">make-philosopher</code> function in <span class="emphasis"><em>Example 2.6</em></span>, over a range of philosopher names <code class="literal">p-names</code> and forks <code class="literal">p-forks</code>, and an infinite range <code class="literal">p-food</code> of the value <code class="literal">food</code>.</p><p>We will now<a class="indexterm" id="id00118"/> define a function to print the collective state of a sequence of philosophers. This can be done in a fairly simple manner using the <code class="literal">doseq</code> function, as<a class="indexterm" id="id00119"/> shown in <span class="emphasis"><em>Example 2.10</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn check-philosophers [philosophers forks]
  (doseq [i (range (count philosophers))]
    (println (str "Fork:\t\t\t available=" @(nth forks i)))
    (if-let [p @(nth philosophers i)]
      (println (str (:name p)
                    ":\t\t eating=" (:eating? p)
                    " food=" (:food p))))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.10: The dining philosophers problem using refs (continued)</em></span></p></blockquote></div><p>The <code class="literal">check-philosophers</code> function in <span class="emphasis"><em>Example 2.10</em></span> iterates through all of its supplied philosopher refs, represented by <code class="literal">philosophers</code>, and associated forks, represented by <code class="literal">forks</code>, and prints their state. The <code class="literal">if-let</code> form is used here to check if a dereferenced ref from the collection <code class="literal">philosophers</code> is not <code class="literal">nil</code>.</p><p>Now, let's define a function to concurrently invoke the <code class="literal">dine</code> function over a collection of philosopher. This function could also pass in values for the <code class="literal">retry-ms</code>, <code class="literal">max-eat-ms</code>, and <code class="literal">max-think-ms</code> arguments of the <code class="literal">dine</code> function. This is implemented in the <code class="literal">dine-philosophers</code> function in <span class="emphasis"><em>Example 2.11</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn dine-philosophers [philosophers]
  (doall (for [p philosophers]
           (future (dine p 10 100 100))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.11: The dining philosophers problem using refs (continued)</em></span></p></blockquote></div><p>Finally, let's define five instances of philosophers and five associated forks for our simulation, using the <code class="literal">init-forks</code>, <code class="literal">init-philosophers</code>, and <code class="literal">make-philosopher</code> functions, as shown in <span class="emphasis"><em>Example 2.12</em></span> as follows:</p><div class="informalexample"><pre class="programlisting">(def all-forks (init-forks 5))

(def all-philosophers
  (init-philosophers 5 1000 all-forks make-philosopher))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.12: The dining philosophers problem using refs (continued)</em></span></p></blockquote></div><p>We can now use<a class="indexterm" id="id00120"/> the <code class="literal">check-philosopher</code> function to print the state of the<a class="indexterm" id="id00121"/> philosopher and fork refs created in <span class="emphasis"><em>Example 2.12</em></span>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (check-philosophers all-philosophers all-forks)</strong></span>
Fork:                         available=true
Philosopher 1:                eating=false food=1000
Fork:                         available=true
Philosopher 2:                eating=false food=1000
Fork:                         available=true
Philosopher 3:                eating=false food=1000
Fork:                         available=true
Philosopher 4:                eating=false food=1000
Fork:                         available=true
Philosopher 5:                eating=false food=1000
nil</pre></div><p>Initially, all of the forks are available and none of the philosophers are eating. To start the simulation, we must call the <code class="literal">dine-philosophers</code> function on the philosopher refs <code class="literal">all-philosophers </code>and the fork refs <code class="literal">all-forks</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def philosophers-futures (dine-philosophers all-philosophers))</strong></span>
#'user/philosophers-futures
<span class="strong"><strong>user&gt; (check-philosophers all-philosophers all-forks)</strong></span>
Fork:                         available=false
Philosopher 1:                eating=true food=978
Fork:                         available=false
Philosopher 2:                eating=false food=979
Fork:                         available=false
Philosopher 3:                eating=true food=977
Fork:                         available=false
Philosopher 4:                eating=false food=980
Fork:                         available=true
Philosopher 5:                eating=false food=980
nil</pre></div><p>After invoking the <code class="literal">dine-philosophers</code> function, each philosopher is observed to consume the allocated food, as shown in the output of the previous <code class="literal">check-philosophers</code> function. At any given point of time, one or two philosophers are observed to be eating, and the other philosophers will wait until they complete using the available forks. Subsequent calls to the <code class="literal">check-philosophers</code> function also indicate the same output, and the <a class="indexterm" id="id00122"/>philosophers will eventually consume all of the allocated food:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (check-philosophers all-philosophers all-forks)</strong></span>
Fork:                         available=true
Philosopher 1:                eating=false food=932
Fork:                         available=true
Philosopher 2:                eating=false food=935
Fork:                         available=true
Philosopher 3:                eating=false food=933
Fork:                         available=true
Philosopher 4:                eating=false food=942
Fork:                         available=true
Philosopher 5:                eating=false food=935
nil</pre></div><p>We can pause the simulation by calling the <code class="literal">future-cancel</code> function, as shown here. Once the simulation is paused, it can be resumed by calling the <code class="literal">dine-philosophers</code> function again, as <code class="literal">(dine-philosophers all-philosophers)</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (map future-cancel philosophers-futures)</strong></span>
(true true true true true)</pre></div><p>To summarize, the<a class="indexterm" id="id00123"/> preceding example is a concise and working implementation of a solution to the dining philosophers problem using Clojure futures and refs.</p></div><div class="section" title="Using atoms"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec0008"/>Using atoms</h2></div></div></div><p>
<span class="emphasis"><em>Atoms</em></span> are used to<a class="indexterm" id="id00124"/> handle state that changes atomically. Once an atom is modified, its new value is reflected in all concurrent threads. In this way, atoms<a class="indexterm" id="id00125"/> represent <span class="emphasis"><em>synchronous</em></span> and <span class="emphasis"><em>independent</em></span> state. Let's quickly explore the functions that can be<a class="indexterm" id="id00126"/> used to handle<a class="indexterm" id="id00127"/> atoms.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0029"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c2/atoms.clj</code> of the book's source code.</p></div></div><p>We can define an atom using the <code class="literal">atom</code> function, which requires the initial state of the atom to be passed to it as the first argument, as shown here:</p><div class="informalexample"><pre class="programlisting">(def state (atom 0))</pre></div><p>The <code class="literal">reset!</code> and <code class="literal">swap!</code> functions can be used to modify the state of an atom. The <code class="literal">reset!</code> function is used to directly set the state of an atom. This function takes two arguments—an atom and the value that represents the new state of the atom, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @state</strong></span>
0
<span class="strong"><strong>user&gt; (reset! state 1)</strong></span>
1
<span class="strong"><strong>user&gt; @state</strong></span>
1</pre></div><p>The <code class="literal">swap!</code> function requires a function and additional arguments to pass to the supplied function as arguments. The supplied function is applied to the value contained in the atom along with the other additional arguments specified to the <code class="literal">swap!</code> function. This function can thus be used to mutate an atom using a supplied function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @state</strong></span>
1
<span class="strong"><strong>user&gt; (swap! state + 2)</strong></span>
3</pre></div><p>The call to the<a class="indexterm" id="id00128"/> preceding <code class="literal">swap!</code> function sets the state of the atom to the result of the expression <code class="literal">(+ @state 2)</code>. The <code class="literal">swap!</code> function may call the function <code class="literal">+</code> multiple<a class="indexterm" id="id00129"/> times due to concurrent calls to the <code class="literal">swap!</code> function on the atom <code class="literal">state</code>. Hence, functions that are passed to the <code class="literal">swap!</code> function must be free of I/O and other side effects.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0030"/>Note</h3><p>The <code class="literal">reset!</code> and <code class="literal">swap!</code> functions both return the new value contained in the supplied atom.</p></div></div><p>We can watch for any change in an atom, and other reference types as well, using the <code class="literal">add-watch</code>
<span class="emphasis"><em> </em></span>function. This function will call a given function whenever the state of an atom is changed. The <code class="literal">add-watch</code> function takes three arguments—a reference, a key and a <span class="emphasis"><em>watch function</em></span>, that is, a <a class="indexterm" id="id00130"/>function that must be called whenever the state of the supplied reference type is changed. The function that is supplied to the <code class="literal">add-watch</code> function must accept four arguments—a key, the reference that was changed, the old value of the reference, and the new value of the reference. The value of the key argument that is passed to the <code class="literal">add-watch</code> function gets passed to the <code class="literal">watch</code> function as its first argument. A <code class="literal">watch</code> function can also be unlinked from a given reference type using the <code class="literal">remove-watch</code> function. The <code class="literal">remove-watch</code> function accepts two arguments—a reference and a key that was specified while adding a <code class="literal">watch</code> function to the reference. <span class="emphasis"><em>Example 2.13</em></span> depicts how we can track the state of an atom using a <code class="literal">watch</code> function:</p><div class="informalexample"><pre class="programlisting">(defn make-state-with-watch []
  (let [state (atom 0)
        state-is-changed? (atom false)
        watch-fn (fn [key r old-value new-value]
                   (swap! state-is-changed? (fn [_] true))]
    (add-watch state nil watch-fn)
    [state
     state-is-changed?]))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.13: Using the add-watch function</em></span></p></blockquote></div><p>The <code class="literal">make-state-with-watch</code> function defined in <span class="emphasis"><em>Example 2.13</em></span> returns a vector of two atoms. The second<a class="indexterm" id="id00131"/> atom in this vector initially contains the value <code class="literal">false</code>. Whenever the state of the first atom in the vector returned by the <code class="literal">make-state-with-watch</code> function is changed, the state of the second atom in this vector is changed to the value <code class="literal">true</code>. This can be verified in the REPL, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def s (make-state-with-watch))</strong></span>
#'user/s
<span class="strong"><strong>user&gt; @(nth s 1)</strong></span>
false
<span class="strong"><strong>user&gt; (swap! (nth s 0) inc)</strong></span>
1
<span class="strong"><strong>user&gt; @(nth s 1)</strong></span>
true</pre></div><p>Thus, watch functions can<a class="indexterm" id="id00132"/> be used with the <code class="literal">add-watch</code> function to track the state of atoms and other reference types.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0031"/>Note</h3><p>The <code class="literal">add-watch</code> function can be used with <span class="emphasis"><em>all</em></span> reference types.</p></div></div></div><div class="section" title="Using agents"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec0009"/>Using agents</h2></div></div></div><p>An <span class="emphasis"><em>agent</em></span> is used to<a class="indexterm" id="id00133"/> represent state that is associated with a queue of actions and a pool of worker threads. Any action that modifies the state of an agent<a class="indexterm" id="id00134"/> must be sent to its queue, and the supplied function will be called by a thread selected from the agent's pool of worker threads. We can send<a class="indexterm" id="id00135"/> actions asynchronously to agents as well. Thus, agents<a class="indexterm" id="id00136"/> represent <span class="emphasis"><em>asynchronous</em></span> and <span class="emphasis"><em>independent</em></span> state.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0032"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c2/agents.clj</code> of the book's source code.</p></div></div><p>An agent is created using the <code class="literal">agent</code> function. For example, we can create an agent with an empty map as its initial value as follows:</p><div class="informalexample"><pre class="programlisting">(def state (agent {}))</pre></div><p>We can modify the state of an agent by using the <code class="literal">send</code> and <code class="literal">send-off</code> functions. The <code class="literal">send</code> and <code class="literal">send-off</code> functions will send a supplied action and its additional arguments to an agent's queue in an asynchronous manner. Both these functions return the agent they are passed immediately. </p><p>The primary difference between the <code class="literal">send</code> and <code class="literal">send-off</code> functions is that the <code class="literal">send</code> function assigns actions to a thread selection from a pool of worker threads, whereas the <code class="literal">send-off</code> function creates a new dedicated thread to execute each action. Blocking actions that are sent to an agent using the <code class="literal">send</code> function could exhaust the agent's pool of threads. Thus, the <code class="literal">send-off</code> function is preferred for sending blocking <a class="indexterm" id="id00137"/>actions to an agent.</p><p>To demonstrate the <code class="literal">send</code> and <code class="literal">send-off</code> functions, let's first define a function that returns a closure that sleeps for a <a class="indexterm" id="id00138"/>certain amount of time, and then, call the <code class="literal">assoc</code> function, as shown in <span class="emphasis"><em>Example 2.14</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn set-value-in-ms [n ms]
  (fn [a]
    (Thread/sleep ms)
    (assoc a :value n)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.14: A function that returns a closure which sleeps and calls assoc</em></span></p></blockquote></div><p>A closure returned by the <code class="literal">set-value-in-ms</code> function, in <span class="emphasis"><em>Example 2.14</em></span>, can be passed as an action to the <code class="literal">send</code> and <code class="literal">send-off</code> functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (send state (set-value-in-ms 5 5000))</strong></span>
#&lt;Agent@7fce18: {}&gt;
<span class="strong"><strong>user&gt; (send-off state (set-value-in-ms 10 5000))</strong></span>
#&lt;Agent@7fce18: {}&gt;
<span class="strong"><strong>user&gt; @state</strong></span>
{}
<span class="strong"><strong>user&gt; @state ; after 5 seconds</strong></span>
{:value 5}
<span class="strong"><strong>user&gt; @state ; after another 5 seconds</strong></span>
{:value 10}</pre></div><p>The calls to the preceding <code class="literal">send</code> and <code class="literal">send-off</code> functions will call the closures returned by the<code class="literal"> set-value-in-ms</code> function, from <span class="emphasis"><em>Example 2.14</em></span>, asynchronously over the agent <code class="literal">state</code>. The agent's state changes over a period of 10 seconds, which is required to execute the closures returned by the <code class="literal">set-value-in-ms</code> function. The new key-value pair <code class="literal">{:value 5}</code> is observed to be saved into the agent <code class="literal">state</code> after five seconds, and the state of the agent again changes to <code class="literal">{:value 10}</code> after another five seconds.</p><p>Any action that is passed to the <code class="literal">send</code> and <code class="literal">send-off</code> functions can use the <code class="literal">*agent*</code> var to access the agent through which the action will be executed.</p><p>The <code class="literal">await</code> function can be used to wait for all actions in an agent's queue to be completed, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (send-off state (set-value-in-ms 100 3000))</strong></span>
#&lt;Agent@af9ac: {:value 10}&gt;
<span class="strong"><strong>user&gt; (await state)  ; will block</strong></span>
nil
<span class="strong"><strong>user&gt; @state</strong></span>
{:value 100}</pre></div><p>The expression <code class="literal">(await state)</code> is observed to be blocked until the previous action that was sent to the agent <code class="literal">state</code> using the <code class="literal">send-off</code> function is completed. The <code class="literal">await-for</code> function is a variant of <code class="literal">await</code>, which waits for a certain number of milliseconds, indicated<a class="indexterm" id="id00139"/> by its first argument, for all the actions on an agent, its second argument, to complete.</p><p>An agent also<a class="indexterm" id="id00140"/> saves any error it encounters while performing the actions in its queue. An agent will throw the error it has encountered on any subsequent calls to the <code class="literal">send</code> and <code class="literal">send-off</code> functions. The error saved by an agent can be accessed using the <code class="literal">agent-error</code> function, and can be cleared using the <code class="literal">clear-agent-errors</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def a (agent 1))</strong></span>
#'user/a
<span class="strong"><strong>user&gt; (send a / 0)</strong></span>
#&lt;Agent@5d29f1: 1&gt;
<span class="strong"><strong>user&gt; (agent-error a)</strong></span>
#&lt;ArithmeticException java.lang.ArithmeticException: Divide by zero&gt;
<span class="strong"><strong>user&gt; (clear-agent-errors a)</strong></span>
1
<span class="strong"><strong>user&gt; (agent-error a)</strong></span>
nil
<span class="strong"><strong>user&gt; @a</strong></span>
1</pre></div><p>An agent that has encountered an error can also be restarted using the <code class="literal">restart-agent</code> function. This function takes an agent as its first argument and the new state of the agent as its second argument. All actions that were sent to an agent while it was failed will be executed once the <code class="literal">restart-agent</code> is called on the agent. We can avoid this behavior by passing the <code class="literal">:clear-actions true</code> optional argument to the <code class="literal">restart-agent</code> function. In this case, any actions held in an agent's queue are discarded before it is restarted. </p><p>To create a pool of threads, or<a class="indexterm" id="id00141"/> a <span class="emphasis"><em>threadpool</em></span>, to use with an agent, we must call the static <code class="literal">newFixedThreadPool</code> method of the <code class="literal">java.util.concurrent.Executors</code> class by passing the desired number of threads in the pool as an argument, as follows:</p><div class="informalexample"><pre class="programlisting">(def pool (java.util.concurrent.Executors/newFixedThreadPool 10))</pre></div><p>The pool of threads defined previously can be used to execute the actions of an agent by using the <code class="literal">send-via</code> function. This function is a variant of the <code class="literal">send</code> function that accepts a pool of threads, such as the <code class="literal">pool</code> defined previously, as its first argument, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (send-via pool state assoc :value 1000)</strong></span>
#&lt;Agent@8efada: {:value 100}&gt;
<span class="strong"><strong>user&gt; @state</strong></span>
{:value 1000}</pre></div><p>We can also specify the thread pools to be used by all agents to execute actions sent to them using the <code class="literal">send</code> and <code class="literal">send-off</code> functions using the <code class="literal">set-agent-send-executor!</code> and <code class="literal">set-agent-send-off-executor!</code> functions respectively. Both of these functions accept a single argument representing a pool of threads.</p><p>All agents in the<a class="indexterm" id="id00142"/> current process can be stopped by invoking the <code class="literal">(shutdown-agents)</code>. The <code class="literal">shutdown-agents</code> function should only be called before exiting a process, as there is no way to restart the agents in a process after calling this function.</p><p>Now, let's try<a class="indexterm" id="id00143"/> implementing the dining philosophers problem using agents. We can reuse most of the functions from the previous implementation of the dining philosophers problem that was based on refs. Let's define some functions to model this problem using agents, as shown in <span class="emphasis"><em>Example 2.15</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn make-philosopher-agent [name forks food]
  (agent {:name name
          :forks forks
          :eating? false
          :food food}))

(defn start-eating [max-eat-ms]
  (dosync (if (has-forks? *agent*)
            (do
              (-&gt; *agent*
                  update-forks
                  (send assoc :eating? true)
                  (send update-in [:food] dec))
              (Thread/sleep (rand-int max-eat-ms))))))

(defn stop-eating [max-think-ms]
  (dosync (-&gt; *agent*
              (send assoc :eating? false)
              update-forks))
  (Thread/sleep (rand-int max-think-ms)))

(def running? (atom true))

(defn dine [p max-eat-ms max-think-ms]
  (when (and p (pos? (:food p)))
    (if-not (:eating? p)
      (start-eating max-eat-ms)
      (stop-eating max-think-ms))
    (if-not @running?
      @*agent*
      @(send-off *agent* dine max-eat-ms max-think-ms))))

(defn dine-philosophers [philosophers]
  (swap! running? (fn [_] true))
  (doall (for [p philosophers]
           (send-off p dine 100 100))))

(defn stop-philosophers []
  (swap! running? (fn [_] false)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.15: The dining philosophers problem using agents</em></span></p></blockquote></div><p>In <span class="emphasis"><em>Example 2.15</em></span>, the <code class="literal">make-philosopher-agent</code> function will create an agent representing a philosopher. The initial state of the resulting agent is a map of the keys <code class="literal">:name</code>, <code class="literal">:forks</code>, <code class="literal">:eating?</code>, and <code class="literal">:food</code>, as described in the previous implementation of the dining philosophers problem. Note that the forks in this implementation are still represented by refs.</p><p>The <code class="literal">start-eating</code> function in <span class="emphasis"><em>Example 2.15</em></span> will start a transaction, check whether the forks placed to the left <a class="indexterm" id="id00144"/>and right sides of a philosopher are available, changes the state of the forks and philosopher agent accordingly, and then suspends the current thread for some time to indicate that a<a class="indexterm" id="id00145"/> philosopher is eating. The <code class="literal">stop-eating</code> function in <span class="emphasis"><em>Example 2.15</em></span> will similarly update the state of a philosopher and the forks he had used, and then suspend the current thread for some time to indicate that a philosopher is thinking. Note that both the <code class="literal">start-eating</code> and <code class="literal">stop-eating</code> functions reuse the <code class="literal">has-forks?</code> and <code class="literal">update-forks</code> functions from <span class="emphasis"><em>Example 2.7</em></span> of the previous implementation of the dining philosophers problem.</p><p>The <code class="literal">start-eating</code> and <code class="literal">stop-eating</code> functions are called by the <code class="literal">dine</code> function in <span class="emphasis"><em>Example 2.15</em></span>. We can assume that this function will be passed as an action to a philosopher agent. This function checks the value of the <code class="literal">:eating?</code> key contained in a philosopher agent to decide whether it must invoke the <code class="literal">start-eating</code> or <code class="literal">stop-eating</code> function in the current call. Next, the <code class="literal">dine</code> function invokes itself again using the <code class="literal">send-off</code> function and dereferencing the agent returned by the <code class="literal">send-off</code> function. The <code class="literal">dine</code> function also checks the state of the atom <code class="literal">running?</code> and does not invoke itself through the <code class="literal">send-off</code> function in case the expression <code class="literal">@running</code> returns <code class="literal">false</code>.</p><p>The <code class="literal">dine-philosophers</code> function in <span class="emphasis"><em>Example 2.15</em></span> starts the simulation by setting the value of the <code class="literal">running?</code> atom to <code class="literal">true</code> and then invoking the <code class="literal">dine</code> function asynchronously through the <code class="literal">send-off</code> function for all the philosopher agents passed to it, represented by <code class="literal">philosophers</code>. The function <code class="literal">stop-philosophers</code> simply sets the value of the <code class="literal">running?</code> atom to <code class="literal">false</code>, thereby stopping the simulation.</p><p>Finally, let's define five<a class="indexterm" id="id00146"/> instances of forks and philosophers using the <code class="literal">init-forks</code> and <code class="literal">init-philosophers</code> functions from <span class="emphasis"><em>Example 2.9</em></span>, shown in <span class="emphasis"><em>Example 2.16</em></span> as follows:</p><div class="informalexample"><pre class="programlisting">(def all-forks (init-forks 5))

(def all-philosophers
  (init-philosophers 5 1000 all-forks make-philosopher-agent))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.16: The dining philosophers problem using agents (continued)</em></span></p></blockquote></div><p>We can now start the <a class="indexterm" id="id00147"/>simulation by calling the <code class="literal">dine-philosophers</code> function. Also, we can print the collective state of the fork and philosopher instances in the simulation using the <code class="literal">check-philosophers</code> function defined in <span class="emphasis"><em>Example 2.10</em></span>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def philosophers-agents (dine-philosophers all-philosophers))</strong></span>
#'user/philosophers-agents
<span class="strong"><strong>user&gt; (check-philosophers all-philosophers all-forks)</strong></span>
Fork:                    available=false
Philosopher 1:           eating=false food=936
Fork:                    available=false
Philosopher 2:           eating=false food=942
Fork:                    available=true
Philosopher 3:           eating=true food=942
Fork:                    available=true
Philosopher 4:           eating=false food=935
Fork:                    available=true
Philosopher 5:           eating=true food=943
nil
<span class="strong"><strong>user&gt; (check-philosophers all-philosophers all-forks)</strong></span>
Fork:                    available=false
Philosopher 1:           eating=true food=743
Fork:                    available=false
Philosopher 2:           eating=false food=747
Fork:                    available=true
Philosopher 3:           eating=false food=751
Fork:                    available=true
Philosopher 4:           eating=false food=741
Fork:                    available=true
Philosopher 5:           eating=false food=760
nil</pre></div><p>As shown in the preceding output, all philosopher agents share the fork instances among themselves. In effect, they work in tandem to ensure that each philosopher eventually consumes all of their allocated food.</p><p>In summary, vars, refs, atoms, and agents can be <a class="indexterm" id="id00148"/>used to represent mutable<a class="indexterm" id="id00149"/> state that is shared among concurrently executing tasks.</p></div></div>
<div class="section" title="Executing tasks in parallel"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec0020"/>Executing tasks in parallel</h1></div></div></div><p>The <a class="indexterm" id="id00150"/>simultaneous execution of several computations is termed as <span class="emphasis"><em>parallelism</em></span>. The use of parallelism tends to<a class="indexterm" id="id00151"/> increase the overall performance of a computation, since the computation can be partitioned to execute on several cores or processors. Clojure has a couple of functions that can be used for the parallelization of a particular computation or task, and we will briefly examine them in this section.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0033"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c2/parallel.clj</code> of the book's source code.</p></div></div><p>Suppose we have a function that pauses the current thread for some time and then returns a computed value, as depicted in <span class="emphasis"><em>Example 2.17</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn square-slowly [x]
  (Thread/sleep 2000)
  (* x x))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.17: A function that pauses the current thread</em></span></p></blockquote></div><p>The function <code class="literal">square-slowly</code> in <span class="emphasis"><em>Example 2.17</em></span> requires a single argument <code class="literal">x</code>. This function pauses the current thread for two seconds and returns the square of its argument <code class="literal">x</code>. If the function <code class="literal">square-slowly</code> is invoked over a collection of three values using the <code class="literal">map</code> function, it takes three times as long to complete, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (doall (map square-slowly (repeat 3 10))))</strong></span>
"Elapsed time: 6000.329702 msecs"
(100 100 100)</pre></div><p>The previously shown <code class="literal">map</code> form returns a lazy sequence, and hence the <code class="literal">doall</code> form is required to realize the value returned by the map form. We could also use the <code class="literal">dorun</code> form to perform this realization of a lazy sequence. The entire expression is evaluated in about six seconds, which is thrice the time taken by the <code class="literal">square-slowly</code> function to complete. We can parallelize the application of the <code class="literal">square-slowly</code> function using the <code class="literal">pmap</code> function instead of <code class="literal">map</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (doall (pmap square-slowly (repeat 3 10))))</strong></span>
"Elapsed time: 2001.543439 msecs"
(100 100 100)</pre></div><p>The entire expression now evaluates in the same amount of time required for a single call to the <code class="literal">square-slowly</code> function. This is due to the <code class="literal">square-slowly</code> function being called in parallel over the supplied collection by the <code class="literal">pmap</code> form. Thus, the <code class="literal">pmap</code> form has the same semantics as that of the <code class="literal">map</code> form, except that it applies the supplied function in parallel.</p><p>The <code class="literal">pvalues</code> and <code class="literal">pcalls</code> forms can also be used to parallelize computations. The <code class="literal">pvalues</code> form <a class="indexterm" id="id00152"/>evaluates the expressions passed to it in parallel, and returns a lazy sequence of the resulting values. Similarly, the <code class="literal">pcalls</code> form invokes all functions passed to it, which must take no arguments, in parallel and returns a lazy sequence of the values<a class="indexterm" id="id00153"/> returned by these functions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (doall (pvalues (square-slowly 10)</strong></span>
<span class="strong"><strong>                            (square-slowly 10)</strong></span>
<span class="strong"><strong>                            (square-slowly 10))))</strong></span>
"Elapsed time: 2007.702703 msecs"
(100 100 100)
<span class="strong"><strong>user&gt; (time (doall (pcalls #(square-slowly 10)</strong></span>
<span class="strong"><strong>                           #(square-slowly 10)</strong></span>
<span class="strong"><strong>                           #(square-slowly 10))))</strong></span>
"Elapsed time: 2005.683279 msecs"
(100 100 100)</pre></div><p>As shown in the preceding output, both expressions that use the <code class="literal">pvalues</code> and <code class="literal">pcalls</code> forms take the same <a class="indexterm" id="id00154"/>amount of time to evaluate as a single call to the <code class="literal">square-slowly</code> function.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0034"/>Note</h3><p>The <code class="literal">pmap</code>, <code class="literal">pvalues</code>, and <code class="literal">pcalls</code> forms <span class="emphasis"><em>all</em></span> return lazy sequences that have to be realized using the <code class="literal">doall</code> or <code class="literal">dorun</code> form.</p></div></div><div class="section" title="Controlling parallelism with thread pools"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec0010"/>Controlling parallelism with thread pools</h2></div></div></div><p>The <code class="literal">pmap</code> form <a class="indexterm" id="id00155"/>schedules parallel execution of the supplied function on the default threadpool. If we wish to configure or tweak the threadpool used<a class="indexterm" id="id00156"/> by <code class="literal">pmap</code>, the <code class="literal">claypoole</code> library (<a class="ulink" href="https://github.com/TheClimateCorporation/claypoole">https://github.com/TheClimateCorporation/claypoole</a>) is a good option. This library provides an<a class="indexterm" id="id00157"/> implementation of the <code class="literal">pmap</code> form that must be passed a configurable threadpool. We will now demonstrate how we can use this library to parallelize a given function.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0035"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[com.climate/claypoole "1.0.0"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [com.climate.claypoole :as cp]
            [com.climate.claypoole.lazy :as cpl]))</pre></div></div></div><p>The <code class="literal">pmap</code> function from the <code class="literal">com.climate.claypoole</code> namespace is essentially a variant of the standard <code class="literal">pmap</code> function to which we supply a threadpool instance to be used in parallelizing a given function. We can also supply the number of threads to be used by this variant of the <code class="literal">pmap</code> function in order to parallelize a given function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (doall (cpl/pmap 2 square-slowly [10 10 10])))</strong></span>
"Elapsed time: 4004.029789 msecs"
(100 100 100)</pre></div><p>As previously shown, the <code class="literal">pmap</code> function from the <code class="literal">claypoole</code> library can be used to parallelize the <code class="literal">square-slowly</code> function that we defined earlier in <span class="emphasis"><em>Example 2.17</em></span> over a collection of three values. These three elements are computed over in two batches, in which each batch will parallely apply the <code class="literal">square-slowly</code> function over two elements in two separate threads. Since the <code class="literal">square-slowly</code> function takes two seconds to complete, the total time taken to compute over the collection of three elements is around four seconds.</p><p>We can create an instance of a pool of threads using the <code class="literal">threadpool</code> function from the <code class="literal">claypoole</code> library. This threadpool instance can then be passed to the <code class="literal">pmap</code> function from the <code class="literal">claypoole</code> library. The <code class="literal">com.climate.claypoole</code> namespace also provides the <code class="literal">ncpus</code> function that returns the number of physical processors available to the current process. We can create a threadpool instance and pass it to this variant of the <code class="literal">pmap</code> function as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def pool (cp/threadpool (cp/ncpus)))</strong></span>
#'user/pool
<span class="strong"><strong>user&gt; (time (doall (cpl/pmap pool square-slowly [10 10 10])))</strong></span>
"Elapsed time: 4002.05885 msecs"
(100 100 100)</pre></div><p>Assuming that we are running the preceding code on a computer system that has two physical processors, the call to the <code class="literal">threadpool</code> function shown previously will create a threadpool of two threads. This threadpool instance can then be passed to the <code class="literal">pmap</code> function as shown in the preceding example.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0037"/>Note</h3><p>We can fall back to the standard behavior of the <code class="literal">pmap</code> function by passing the <code class="literal">:builtin</code> keyword as the first argument to the <code class="literal">com.climate.claypoole/pmap</code> function. Similarly, if the keyword <code class="literal">:serial</code> is passed as the first argument to the <code class="literal">claypoole</code> version of the <code class="literal">pmap</code> function, the function behaves like the standard <code class="literal">map</code> function.</p></div></div><p>The <code class="literal">threadpool</code> function also supports a couple of useful key options. Firstly, we can create a pool of non-daemon threads using the <code class="literal">:daemon false</code> optional argument. Daemon threads are<a class="indexterm" id="id00158"/> killed when the process exits, and all threadpools created by the <code class="literal">threadpool</code> function are pools of daemon threads by default. We can also name a threadpool using the <code class="literal">:name</code> key option of the <code class="literal">threadpool</code> function. The <code class="literal">:thread-priority</code> key option can be used to indicate the priority of the threads in the new threadpool.</p><p>Tasks can also be <a class="indexterm" id="id00159"/>prioritized using the <code class="literal">pmap</code>, <code class="literal">priority-threadpool</code>, and <code class="literal">with-priority</code> forms from the <code class="literal">claypoole</code> library. A priority threadpool is created using the <code class="literal">priority-threadpool</code> function, and this new threadpool can be used along with the <code class="literal">with-priority</code> function to assign a priority to a task that must be parallelized using <code class="literal">pmap</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def pool (cp/priority-threadpool (cp/ncpus))</strong></span>
#'user/pool
<span class="strong"><strong>user&gt; (def task-1 (cp/pmap (cp/with-priority pool 1000)</strong></span>
<span class="strong"><strong>                           square-slowly [10 10 10]))</strong></span>
#'user/task-1
<span class="strong"><strong>user&gt; (def task-2 (cp/pmap (cp/with-priority pool 0)</strong></span>
<span class="strong"><strong>                           square-slowly [5 5 5]))</strong></span>
#'user/task-2</pre></div><p>Tasks with higher priority are assigned to threads first. Hence, the task represented by <code class="literal">task-1</code> will be assigned to a thread of execution before the task represented by <code class="literal">task-2</code> in the previous output.</p><p>To gracefully deallocate a given threadpool, we can call the <code class="literal">shutdown</code> function from the <code class="literal">com.climate.claypoole</code> namespace, which accepts a threadpool instance as its only argument. The <code class="literal">shutdown!</code> function from the same namespace will forcibly shut down the threads in <a class="indexterm" id="id00160"/>a threadpool. The <code class="literal">shutdown!</code> function can also be called using the <code class="literal">with-shutdown!</code> macro. We specify the threadpools to be used for a series of computations as a vector of bindings to the <code class="literal">with-shutdown!</code> macro. This macro will implicitly call the <code class="literal">shutdown!</code> function on all of the threadpools that it has created once all the computations in the body of this macro are completed. For example, we can define a function to create a threadpool, use it for a computation, and finally, shut down the threadpool, using the <code class="literal">with-shutdown!</code> function as shown in <span class="emphasis"><em>Example 2.18</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn square-slowly-with-pool [v]
  (cp/with-shutdown! [pool (cp/threadpool (cp/ncpus))]
    (doall (cp/pmap pool square-slowly v))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 2.18: Using a priority threadpool</em></span></p></blockquote></div><p>The <code class="literal">square-slowly-with-pool</code> function defined in <span class="emphasis"><em>Example 2.18</em></span> will create a new threadpool, represented by <code class="literal">pool</code>, and then use it to call the <code class="literal">pmap</code> function. The <code class="literal">shutdown!</code> function is implicitly called once the <code class="literal">doall</code> form completely evaluates the lazy sequence returned by the <code class="literal">pmap</code> function.</p><p>The <code class="literal">claypoole</code> library also supports <span class="emphasis"><em>unordered parallelism</em></span>, in which results of individual threads of computation are used as soon as they are available in order to minimize latency. The <code class="literal">com.climate.claypoole/upmap</code> function is an unordered parallel version of the <code class="literal">pmap</code> function.</p><p>The <code class="literal">com.climate.claypoole</code> namespace also provides several other functions that use threadpools, as<a class="indexterm" id="id00161"/> described here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">com.climate.claypoole/pvalues</code> function is a threadpool-based implementation of the <code class="literal">pvalues</code> function. It will evaluate its arguments in parallel using a supplied threadpool and return a lazy sequence.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">com.climate.claypoole/pcalls</code> function is a threadpool-based version of the <code class="literal">pcalls</code> function, which invokes several no-argument functions to return a lazy sequence.</li><li class="listitem" style="list-style-type: disc">A future that uses a given threadpool can be created using the <code class="literal">com.climate.claypoole/future</code> function.</li><li class="listitem" style="list-style-type: disc">We can evaluate an expression in a parallel fashion over the items in a given collection using the <code class="literal">com.climate.claypoole/pfor</code> function.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">upvalues</code>, <code class="literal">upcalls</code>, and <code class="literal">upfor</code> functions in the <code class="literal">com.climate.claypoole</code> namespace are unordered parallel versions of the <code class="literal">pvalues</code>, <code class="literal">pcalls</code>, and <code class="literal">pfor</code> functions, respectively, from the same namespace.</li></ul></div><p>It is quite evident<a class="indexterm" id="id00162"/> that the <code class="literal">pmap</code> function from the <code class="literal">com.climate.claypoole</code> namespace will eagerly evaluate the collection it is supplied. This may be undesirable when we intend to call <code class="literal">pmap</code> over an infinite sequence. The <code class="literal">com.climate.claypoole.lazy</code> namespace provides versions of <code class="literal">pmap</code> and other functions from the<code class="literal"> com.climate.claypoole</code> namespace that preserve the laziness of a supplied collection. The lazy version of the <code class="literal">pmap</code> function can be demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def lazy-pmap (cpl/pmap pool square-slowly (range)))</strong></span>
#'user/lazy-pmap
<span class="strong"><strong>user&gt; (time (doall (take 4 lazy-pmap)))</strong></span>
"Elapsed time: 4002.556548 msecs"
(0 1 4 9)</pre></div><p>The previously defined <code class="literal">lazy-pmap</code> sequence is a lazy sequence created by mapping the <code class="literal">square-slowly</code> function over the infinite sequence <code class="literal">(range)</code>. As shown previously, the call to the <code class="literal">pmap</code> function returns immediately, and the first four elements of the resulting lazy sequence are realized in parallel using the <code class="literal">doall</code> and <code class="literal">take</code> functions.</p><p>To summarize, Clojure has<a class="indexterm" id="id00163"/> the <code class="literal">pmap</code>, <code class="literal">pvalues</code>, and <code class="literal">pcalls</code> primitives to deal with parallel computations. If we intend to control the amount of parallelism utilized by these functions, we can use the <code class="literal">claypoole</code> library's implementations of these primitives. The <code class="literal">claypoole</code> library also supports other useful features such as prioritized threadpools and unordered parallelism.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec0021"/>Summary</h1></div></div></div><p>We have explored various constructs that can be used to create concurrent and parallel tasks in Clojure. You learned to handle shared mutable state through the use of reference types, namely vars, refs, atoms and agents. As we described earlier, the dining philosophers problem can be easily implemented using refs and agents. You also studied how tasks can be executed in parallel. Lastly, we explored the <code class="literal">claypoole</code> library, which allows us to control the amount of parallelism used for a given computation.</p><p>In the next chapter, we will continue our exploration of parallelism in Clojure through the use of reducers. </p></div>
<div class="chapter" title="Chapter&#xA0;3.&#xA0;Parallelization Using Reducers"><div class="titlepage"><div><div><h1 class="title"><a id="ch18"/>Chapter 3. Parallelization Using Reducers</h1></div></div></div><p>
<span class="emphasis"><em>Reducers</em></span> are another <a class="indexterm" id="id00164"/>way of looking at collections in Clojure. In this chapter, we will study this particular abstraction of collections, and how it is quite orthogonal to viewing collections as sequences. The motivation behind reducers is to increase the performance of computations over collections. This performance gain is achieved mainly through parallelization of such computations.</p><p>As we have seen in <a class="link" href="ch16.html" title="Chapter 1. Working with Sequences and Patterns">Chapter 1</a>, <span class="emphasis"><em>Working with Sequences and Patterns</em></span>, sequences and laziness are a great way to handle collections. The Clojure standard library provides several functions to handle and manipulate sequences. However, abstracting a collection as a sequence has an unfortunate consequence; any computation performed over all the elements of a sequence is inherently sequential. Also, all of the standard sequence functions create a new collection that is similar to the collection passed to these functions. Interestingly, performing a computation over a collection without creating a similar collection, even as an intermediary result, is quite useful. For example, it is often required to reduce a given collection to a single value through a series of transformations in an iterative manner. This sort of computation does not necessarily require the intermediary results of each transformation to be saved.</p><p>A consequence of iteratively computing values from a collection is that we cannot parallelize it in a straightforward way. Modern<a class="indexterm" id="id00165"/> <span class="emphasis"><em>MapReduce</em></span> frameworks handle this kind of computation by pipelining the elements of a collection through several transformations in parallel, and finally, reducing the results into a single result. Of course, the result could as well be a new collection. A drawback of this methodology is that it produces concrete collections as intermediate results of each transformation, which is rather wasteful. For example, if we wanted to filter out values from a collection, the MapReduce strategy would require creating empty collections to represent values that are left out of the reduction step to produce the final result. </p><p>This incurs unnecessary memory allocation and also creates additional work for the reduction step, which produces the final result. Hence, there's a scope for optimizing these sorts of computations.</p><p>This brings us to the notion of treating computations over collections as <span class="emphasis"><em>reducers</em></span> to attain better performance. Of course, this doesn't mean that<a class="indexterm" id="id00166"/> reducers are a replacement for sequences. Sequences and laziness are great for abstracting computations that create and manipulate collections, while reducers are a specialized high-performance abstraction of collections in which a collection needs to be piped through several transformations, and finally, combined to <a class="indexterm" id="id00167"/>produce the final result. Reducers achieve a performance gain in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reducing the amount of memory allocated to produce the desired result</li><li class="listitem" style="list-style-type: disc">Parallelizing the process of reducing a collection into a single result, which could be an entirely new collection</li></ul></div><p>The <code class="literal">clojure.core.reducers</code> namespace provides several functions to process collections using reducers. Let's now examine how reducers are implemented and a few examples that demonstrate how reducers can be used.</p><div class="section" title="Using reduce to transform collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec0022"/>Using reduce to transform collections</h1></div></div></div><p>Sequences <a class="indexterm" id="id00168"/>and functions that operate on sequences preserve the sequential ordering between elements. Lazy sequences avoid the unnecessary realization of elements in a collection until they are required for a computation, but the<a class="indexterm" id="id00169"/> realization of these values is still performed in a sequential manner. However, this characteristic of sequential ordering may not be desirable for all computations performed over it. For example, it's not possible to map a function over a vector and then lazily realize values in the resulting collection out of order; since the <code class="literal">map</code> function converts the supplied collection into a sequence. Also, functions such as <code class="literal">map</code> and <code class="literal">filter</code> are lazy, but still sequential by nature.</p><div class="section" title="What's wrong with sequences?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec0011"/>What's wrong with sequences?</h2></div></div></div><a class="indexterm" id="id00170"/><p>One of the limitations of sequences is that they are realized in <a class="indexterm" id="id00171"/>
<span class="emphasis"><em>chunks</em></span>. Let's study a simple example to illustrate what this means. Consider a unary function, as shown in <span class="emphasis"><em>Example 3.1</em></span>, which we intend to map over a given vector. The function must compute a value from the one it is supplied, and also perform a side effect so that we can observe its application over the elements in a collection.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0038"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c3/reducers.clj</code> of the book's source code.</p></div></div><div class="informalexample"><pre class="programlisting">(defn square-with-side-effect [x]
  (do
    (println (str "Side-effect: " x))
    (* x x)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.1: A simple unary function</em></span></p></blockquote></div><p>The <code class="literal">square-with-side-effect</code> function simply returns the square of a number <code class="literal">x</code> using the <code class="literal">*</code> function. This function also prints the value of <code class="literal">x</code> using a <code class="literal">println</code> form whenever it is called. Suppose this function is mapped over a given vector. The resulting collection would have to be realized completely if a computation has to be performed over it, even if all the elements from the resulting vector are not required. This can be demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def mapped (map square-with-side-effect [0 1 2 3 4 5]))</strong></span>
#'user/mapped
<span class="strong"><strong>user&gt; (reduce + (take 3 mapped))</strong></span>
Side-effect: 0
Side-effect: 1
Side-effect: 2
Side-effect: 3
Side-effect: 4
Side-effect: 5
5</pre></div><p>As shown previously, the <code class="literal">mapped</code> variable contains the result of mapping the <code class="literal">square-with-side-effect</code> function <a class="indexterm" id="id00172"/>over a vector. If we try to sum the first three values in the resulting collection using the <code class="literal">reduce</code>, <code class="literal">take</code>, and <code class="literal">+</code> functions, all the values in the <code class="literal">[0 1 2 3 4 5]</code> vector are printed as a side effect, as shown in the preceding output. This means that the <code class="literal">square-with-side-effect</code> function was applied to all the elements in the initial vector, despite the<a class="indexterm" id="id00173"/> fact that only the first three elements were actually required by the <code class="literal">reduce</code> form. Of course, this can be solved using the <code class="literal">seq</code> function to convert the vector to a sequence before mapping the <code class="literal">square-with-side-effect</code> function over it. But then, we lose the ability to efficiently access elements in a random order in the resulting collection.</p><p>To understand why this actually happens, we first need to understand how the standard <code class="literal">map</code> function is actually implemented. A simplified definition of the <code class="literal">map</code> function is shown in <span class="emphasis"><em>Example 3.2</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn map [f coll]
  (cons (f (first coll))
        (lazy-seq (map f (rest coll)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.2: A simplified definition of the map function</em></span></p></blockquote></div><p>The definition of <code class="literal">map</code> in <span class="emphasis"><em>Example 3.2</em></span> is a simplified and rather incomplete one, as it doesn't check for an empty collections and cannot be used over multiple collections. That aside, this definition of <code class="literal">map</code> does indeed apply a function <code class="literal">f</code> to all the elements in a collection <code class="literal">coll</code>. This is implemented using a composition of the <code class="literal">cons</code>, <code class="literal">first</code>, <code class="literal">rest</code>, and <code class="literal">lazy-seq</code> forms. </p><p>This implementation can be interpreted as "applying the function <code class="literal">f</code> to the first element in the collection <code class="literal">coll</code>, and then mapping <code class="literal">f</code> over the rest of the collection in a lazy manner". An interesting consequence of this implementation is that the <code class="literal">map</code> function has the following <a class="indexterm" id="id00174"/>characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ordering among elements in the collection <code class="literal">coll</code> is preserved.</li><li class="listitem" style="list-style-type: disc">This computation is performed recursively.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">lazy-seq</code> form is used to perform the computation in a lazy manner.</li><li class="listitem" style="list-style-type: disc">The use of the <code class="literal">first</code> and <code class="literal">rest</code> forms indicate that <code class="literal">coll</code> must be a sequence, and the <code class="literal">cons</code> form will also produce a result that is a sequence. Hence, the <code class="literal">map</code> function accepts a sequence and builds a new one.</li></ul></div><p>However, none of these<a class="indexterm" id="id00175"/> properties of sequences are needed to transform a given collection into a result that is not a sequence. Another<a class="indexterm" id="id00176"/> characteristic of lazy sequences is how they are realized. By the term realized, we mean to say a given lazy sequence is evaluated to produce concrete values. Lazy sequences are realized in <span class="emphasis"><em>chunks</em></span>. Each chunk is comprised of 32 elements, and this is done as an optimization. Sequences that behave this way are termed as<a class="indexterm" id="id00177"/> <span class="emphasis"><em>chunked sequences</em></span>. Of course, not all sequences are chunked, and we can check whether a given sequence is chunked using the <code class="literal">chunked-seq?</code> predicate. The <code class="literal">range</code> function returns a chunked sequence, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (first (map #(do (print \!) %) (range 70)))</strong></span>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
0
<span class="strong"><strong>user&gt; (nth (map #(do (print \!) %) (range 70)) 32)</strong></span>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
32</pre></div><p>Both the statements in the preceding output select a single element from a sequence returned by the <code class="literal">map</code> function. The function passed to the <code class="literal">map</code> function in both the preceding statements prints the<code class="literal">!</code> character and returns the value supplied to it. In the first statement, the first 32 elements of the resulting sequence are realized even though only the first element is required. Similarly, the second statement is observed to realize the first 64 elements of the resulting sequence when the element at the 32nd position is obtained using the <code class="literal">nth</code> function. But again, realizing a collection in chunks isn't required to perform a computation over the elements in the collection.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0039"/>Note</h3><p>Chunked sequences have been an integral part of Clojure since version 1.1.</p></div></div><p>If we are to handle such computations efficiently, we cannot build on functions that return sequences, such as <code class="literal">map</code> and <code class="literal">filter</code>. Incidentally, the <code class="literal">reduce</code> function does not necessarily produce a sequence. It also has a couple of other interesting properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">reduce</code> function actually lets the supplied collection define how it is computed over or reduced. Thus, <code class="literal">reduce</code> is <span class="emphasis"><em>collection independent</em></span>.</li><li class="listitem" style="list-style-type: disc">Also, the <code class="literal">reduce</code> function is versatile enough to build a single value or an entirely new collection as well. For example, using <code class="literal">reduce</code> with the <code class="literal">*</code> or <code class="literal">+</code> functions will create a single valued result, while using it with the <code class="literal">cons</code> or <code class="literal">concat</code> functions can create a new collection as a result. Thus, <code class="literal">reduce</code> can <span class="emphasis"><em>build anything</em></span>.</li></ul></div><p>To summarize, the <code class="literal">reduce</code> function<a class="indexterm" id="id00178"/> can be used as a premise to generalize any computation or transformation that has to be applied on a<a class="indexterm" id="id00179"/> collection.</p></div><div class="section" title="Introducing reducers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec0012"/>Introducing reducers</h2></div></div></div><p>A collection is said to be <span class="emphasis"><em>reducible</em></span> when it defines its behavior with the <code class="literal">reduce</code> function. The binary function<a class="indexterm" id="id00180"/> used by the <code class="literal">reduce</code> function along with a collection is also termed as a <span class="emphasis"><em>reducing function</em></span>. A reducing <a class="indexterm" id="id00181"/>function requires two arguments—one to represent the accumulated result of the reduction, and another to represent an input value that has to be combined into the result. Several reducing functions can be composed into one, which effectively changes how the <code class="literal">reduce</code> function processes a given collection. This<a class="indexterm" id="id00182"/> composition is done using <span class="emphasis"><em>reducing function transformers</em></span>, or simply <span class="emphasis"><em>reducers</em></span>.</p><p>The use of sequences and laziness can be compared to using reducers to perform a given computation by Rich Hickey's infamous pie-maker analogy. Suppose a pie-maker has been supplied a bag of apples, with an intent to <span class="emphasis"><em>reduce</em></span> the apples to a pie. There are a couple transformations needed to perform this task. First, the stickers on all the apples have to be removed, as in we <span class="emphasis"><em>map</em></span> a function to "take the sticker off" over the apples in the collection. Also, all the rotten apples will have to be removed, which is analogous to using the <code class="literal">filter</code> function to remove elements from a collection. Instead of performing this work herself, the pie-maker delegates it to her assistant. The assistant could first take the stickers off of all the apples, thus producing a new collection, and then take out the rotten apples to produce another new collection, which illustrates the use of lazy sequences. But then, the assistant would be doing unnecessary work by removing the stickers from the rotten apples, which will have to be discarded later.</p><p>On the other hand, the assistant could delay this work until the actual reduction of the processed apples into a pie is performed. Once the work is actually needed to be performed, the assistant will compose the two tasks of <span class="emphasis"><em>mapping</em></span> and <span class="emphasis"><em>filtering</em></span> the collection of apples, thus avoiding any unnecessary work. This case depicts the use of reducers to compose and transform the tasks needed to effectively reduce the collection of apples into a pie. Thus, the use of intermediary collections between each transformation is avoided, which is an optimization in terms of memory allocations performed to produce the result.</p><p>Of course, a smart assistant would simply discard the rotten apples first, which is essentially filtering the apples before mapping them. However, not all recipes are that trivial, and moreover, we can achieve a more interesting optimization through the use of reducers—parallelism. By using reducers, we create a <span class="emphasis"><em>recipe</em></span> of tasks to reduce a collection of apples into a pie that can be parallelized. Also, all processing is delayed until the final reduction, instead of dealing with collections as intermediary results of each task. This is the gist of how reducers achieve performance though function composition and parallelization.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0040"/>Note</h3><p>The following namespaces must be included in your namespace declaration for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.core.reducers :as r]))</pre></div><p>The <code class="literal">clojure.core.reducers</code> namespace requires Java 6 with the <code class="literal">jsr166y.jar</code> JAR or Java 7+ for fork/join support.</p></div></div><p>Let's now briefly explore how reducers are actually implemented. Functions that operate on sequences use the <code class="literal">clojure.lang.ISeq</code> interface to abstract the behavior of a collection. In the case of reducers, the common interface that we must build upon is that of a reducing function. As we mentioned earlier, a reducing function is a two-arity function in which the first argument is the accumulated result so far and the second argument is the current input that has to be combined with the first argument. The process of performing a<a class="indexterm" id="id00183"/> computation over a collection and producing some result can be generalized into three distinct cases. They can be described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A new collection with the same number of elements as the collection it is supplied needs to be produced. This <span class="emphasis"><em>one-to-one</em></span> case is analogous to using the <code class="literal">map</code> function.</li><li class="listitem" style="list-style-type: disc">The computation <span class="emphasis"><em>shrinks</em></span> the supplied collection by removing elements from it. This can be done using the <code class="literal">filter</code> function.</li><li class="listitem" style="list-style-type: disc">The computation could also be <span class="emphasis"><em>expansive</em></span>, in which case it produces a new collection that contains an increased number of elements. This is like what the <code class="literal">mapcat</code> function does.</li></ul></div><p>These cases depict the different ways in which a collection can be transformed into the desired result. Any computation, or reduction, over a collection can be thought of as an arbitrary sequence of such transformations. These transformations are represented by <span class="emphasis"><em>transformers</em></span>, which are<a class="indexterm" id="id00184"/> essentially functions that transform a reducing function. They can be implemented as shown in <span class="emphasis"><em>Example 3.3</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn mapping [f]
  (fn [rf]
    (fn [result input]
      (rf result (f input)))))

(defn filtering [p?]
  (fn [rf]
    (fn [result input]
      (if (p? input)
        (rf result input)
        result))))

(defn mapcatting [f]
  (fn [rf]
    (fn [result input]
      (reduce rf result (f input)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.3: Transformers</em></span></p></blockquote></div><p>The <code class="literal">mapping</code>, <code class="literal">filtering</code>, and <code class="literal">mapcatting</code> functions in <span class="emphasis"><em>Example 3.3</em></span> represent the core logic of the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> functions respectively. All of these functions are transformers that take a single argument and return a new function. The returned function transforms a supplied reducing function, represented by <code class="literal">rf</code>, and returns a new reducing function, created using the expression <code class="literal">(fn [result input] ... )</code>. Functions returned by the <code class="literal">mapping</code>, <code class="literal">filtering</code>, and <a class="indexterm" id="id00185"/>
<code class="literal">mapcatting</code> functions are termed as <span class="emphasis"><em>reducing function transformers</em></span>.</p><p>The <code class="literal">mapping</code> function applies the <code class="literal">f</code> function to the current input, represented by the <code class="literal">input</code> variable. The <a class="indexterm" id="id00186"/>value returned by the function <code class="literal">f</code> is then combined with the accumulated result, represented by <code class="literal">result</code>, using the reducing function <code class="literal">rf</code>. This transformer is a frighteningly pure abstraction of the standard <code class="literal">map</code> function that applies a function <code class="literal">f</code> over a collection. The <code class="literal">mapping</code> function makes no assumptions of the structure of the collection it is supplied or how the values returned by the function <code class="literal">f</code> are combined to produce the final result.</p><p>Similarly, the <code class="literal">filtering</code> function uses a predicate <code class="literal">p?</code> to check whether the current input of the reducing function <code class="literal">rf</code> must be combined into the final result, represented by <code class="literal">result</code>. If the predicate is not true, then the reducing function will simply return the value <code class="literal">result</code> without any modification. The <code class="literal">mapcatting</code> function uses the <code class="literal">reduce</code> function to combine the value <code class="literal">result</code> with the result of the expression <code class="literal">(f input)</code>. In this transformer, we can assume that the function <code class="literal">f</code> will return a new collection and the reducing function <code class="literal">rf</code> will somehow combine two collections.</p><p>One of the foundations of the <code class="literal">reducers</code> library is the <code class="literal">CollReduce</code> protocol defined in the <code class="literal">clojure.core.protocols</code> namespace. This protocol abstracts the behavior of a collection when it is passed as an argument to the <code class="literal">reduce</code> function, and is declared as shown in <span class="emphasis"><em>Example 3.4</em></span>:</p><div class="informalexample"><pre class="programlisting">(defprotocol CollReduce
  (coll-reduce [coll rf init]))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.4: The CollReduce protocol</em></span></p></blockquote></div><p>The <code class="literal">clojure.core.reducers</code> namespace defines a <code class="literal">reducer</code> function that creates a reducible collection by dynamically extending the <code class="literal">CollReduce</code> protocol, as shown in <span class="emphasis"><em>Example 3.5</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn reducer
  ([coll xf]
   (reify
     CollReduce
     (coll-reduce [_ rf init]
       (coll-reduce coll (xf rf) init)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.5: The reducer function</em></span></p></blockquote></div><p>The <code class="literal">reducer</code> function combines a collection <code class="literal">coll</code> and a reducing function transformer <code class="literal">xf</code>, which is returned by the <code class="literal">mapping</code>, <code class="literal">filtering</code>, and <code class="literal">mapcatting</code> functions, to produce a new reducible<a class="indexterm" id="id00187"/> collection. When <code class="literal">reduce</code> is invoked on a reducible collection, it will ultimately ask the collection to reduce itself using the reducing function returned by the expression <code class="literal">(xf rf)</code>. Using this mechanism, several reducing functions can be composed into a single computation to be performed over a given collection. Also, the <code class="literal">reducer</code> function needs to be defined only once, and the actual implementation of <code class="literal">coll-reduce</code> is provided by the collection supplied to the <code class="literal">reducer</code> function.</p><p>Now, we can redefine the <code class="literal">reduce</code> function to simply invoke the <code class="literal">coll-reduce</code> function implemented by a given collection, as shown in <span class="emphasis"><em>Example 3.6</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn reduce
  ([rf coll]
   (reduce rf (rf) coll))
  ([rf init coll]
   (coll-reduce coll rf init)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.6: Redefining the reduce function</em></span></p></blockquote></div><p>As shown in <span class="emphasis"><em>Example 3.6</em></span>, the <code class="literal">reduce</code> function delegates the job of reducing a collection to the collection itself using the <code class="literal">coll-reduce</code> function. Also, the <code class="literal">reduce</code> function will use the reducing function <code class="literal">rf</code> to also supply the <code class="literal">init</code> argument when it is not specified. An interesting consequence of this definition of <code class="literal">reduce</code> is that the function <code class="literal">rf</code> must produce an <span class="emphasis"><em>identity value</em></span> when supplied no arguments. The standard <code class="literal">reduce</code> function also uses the <code class="literal">CollReduce</code> protocol to delegate the job of reducing a collection to the collection itself, but will also fall back on the default definition of <code class="literal">reduce</code> in case the supplied collection does not implement the <code class="literal">CollReduce</code> protocol.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0042"/>Note</h3><p>Since Clojure 1.4, the <code class="literal">reduce</code> function allows a collection to define how it reduced using the <code class="literal">clojure.core.CollReduce</code> protocol. Clojure 1.5 introduced the <code class="literal">clojure.core.reducers</code> namespace that extends the use of this protocol.</p></div></div><p>All of the standard <a class="indexterm" id="id00188"/>Clojure collections, namely lists, vectors, sets, and maps, implement the <code class="literal">CollReduce</code> protocol. The <code class="literal">reducer</code> function can be used to build a sequence of transformations to be applied to a collection when it is passed as an argument to the <code class="literal">reduce</code> function. This can be demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (r/reduce + 0 (r/reducer [1 2 3 4] (mapping inc)))</strong></span>
14
<span class="strong"><strong>user&gt; (reduce + 0 (r/reducer [1 2 3 4] (mapping inc)))</strong></span>
14</pre></div><p>In the preceding output, the <code class="literal">mapping</code> function is used with the <code class="literal">inc</code> function to create a reducing function transformer that increments all the elements in a given collection. This transformer is then combined with a vector using the <code class="literal">reducer</code> function to produce a reducible collection. The call to <code class="literal">reduce</code> in both of the preceding statements is transformed into the expression <code class="literal">(reduce + [2 3 4 5])</code>, thus producing the result <code class="literal">14</code>. We can now redefine the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> functions using the <code class="literal">reducer</code> function, as shown in <span class="emphasis"><em>Example 3.7</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn map [f coll]
  (reducer coll (mapping f)))

(defn filter [p? coll]
  (reducer coll (filtering p?)))

(defn mapcat [f coll]
  (reducer coll (mapcatting f)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.7: Redefining the map, filter and mapcat functions using the reducer form</em></span></p></blockquote></div><p>As shown in <span class="emphasis"><em>Example 3.7</em></span>, the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> functions are now simply compositions of the <code class="literal">reducer</code> form with the <code class="literal">mapping</code>, <code class="literal">filtering</code>, and <code class="literal">mapcatting</code> transformers respectively.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0043"/>Note</h3><p>The definitions of <code class="literal">CollReduce</code>, <code class="literal">reducer</code>, <code class="literal">reduce</code>, <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> as shown in this section are simplified versions of their actual definitions in the <code class="literal">clojure.core.reducers</code> namespace.</p></div></div><p>The definitions of the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> functions shown in <span class="emphasis"><em>Example 3.7</em></span> have the same shape as the standard versions of these functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (r/reduce + (r/map inc [1 2 3 4]))</strong></span>
14
<span class="strong"><strong>user&gt; (r/reduce + (r/filter even? [1 2 3 4]))</strong></span>
6
<span class="strong"><strong>user&gt; (r/reduce + (r/mapcat range [1 2 3 4]))</strong></span>
10</pre></div><p>Hence, the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> functions from the <code class="literal">clojure.core.reducers</code> namespace can be used in the same way as the standard versions of these functions. The <code class="literal">reducers</code> library also <a class="indexterm" id="id00189"/>provides a <code class="literal">take</code> function that can be used as a replacement for the standard <code class="literal">take</code> function. We can use this function to reduce the number of calls to the <code class="literal">square-with-side-effect</code> function (from <span class="emphasis"><em>Example 3.1</em></span>) when it is mapped over a given vector, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def mapped (r/map square-with-side-effect [0 1 2 3 4 5]))</strong></span>
#'user/mapped
<span class="strong"><strong>user&gt; (reduce + (r/take 3 mapped))</strong></span>
Side-effect: 0
Side-effect: 1
Side-effect: 2
Side-effect: 3
5</pre></div><p>Thus, using the <code class="literal">map</code> and <code class="literal">take</code> functions from the <code class="literal">clojure.core.reducers</code> namespace as shown here avoids applying the <code class="literal">square-with-side-effect</code> function to all five elements in the vector <code class="literal">[0 1 2 3 4 5]</code> as only the first three are required.</p><p>The <code class="literal">reducers</code> library also provides variants of the standard <code class="literal">take-while</code>, <code class="literal">drop</code>, <code class="literal">flatten</code>, and <code class="literal">remove</code> functions, which are based on reducers. Effectively, functions based on reducers will require a lesser number of allocations than sequence-based functions, thus leading to an improvement in performance. For example, consider the <code class="literal">process</code> and <code class="literal">process-with-reducer</code> functions shown in <span class="emphasis"><em>Example 3.8</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn process [nums]
  (reduce + (map inc (map inc (map inc nums)))))

(defn process-with-reducer [nums]
  (reduce + (r/map inc (r/map inc (r/map inc nums)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.8: Functions to process a collection of numbers using sequences and reducers</em></span></p></blockquote></div><p>The <code class="literal">process</code> function in <span class="emphasis"><em>Example 3.8</em></span> applies the <code class="literal">inc</code> function over a collection of numbers represented by <code class="literal">nums</code> using the <code class="literal">map</code> function. The <code class="literal">process-with-reducer</code> function performs the same action, but uses the reducer variant of the <code class="literal">map</code> function. The <code class="literal">process-with-reducer</code> function will take a lesser amount of time to produce its result from a large vector when compared to the <code class="literal">process</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def nums (vec (range 1000000)))</strong></span>
#'user/nums
<span class="strong"><strong>user&gt; (time (process nums))</strong></span>
"Elapsed time: 471.217086 msecs"
500002500000
<span class="strong"><strong>user&gt; (time (process-with-reducer nums))</strong></span>
"Elapsed time: 356.767024 msecs"
500002500000</pre></div><p>The <code class="literal">process-with-reducer</code> function gets a slight performance boost as it requires a lesser number of memory allocations than the <code class="literal">process</code> function. We should note that the available memory<a class="indexterm" id="id00190"/> should be large enough to load the entire file, or else we could run out of memory. The performance of this computation can be improved by a greater scale if we can somehow parallelize it, and we shall examine how this can be done in the following section.</p></div></div></div>
<div class="section" title="Using fold to parallelize collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec0024"/>Using fold to parallelize collections</h1></div></div></div><p>A collection<a class="indexterm" id="id00191"/> that implements the <code class="literal">CollReduce</code> protocol is still sequential by nature. Using the <code class="literal">reduce</code> function with <code class="literal">CollReduce</code> does have a certain amount of performance gain, but it still processes elements in a collection in a sequential order. The most obvious way to improve the performance of a computation that is <a class="indexterm" id="id00192"/>performed over a collection is parallelization. Such computations can be parallelized if we ignore the ordering of elements in a given collection to produce the result of the computation. In the reducers library, this is implemented based on the <span class="emphasis"><em>fork/join model</em></span> of parallelization from the <code class="literal">java.util.concurrent</code> namespace. The<a class="indexterm" id="id00193"/> fork/join model essentially partitions a collection over which a computation has to be performed into two halves and processes each partition in parallel. This halving of the collection is done in a recursive manner. The granularity of the partitions affects the overall performance of a computation modeled using fork/join. This means that if a fork/join strategy is used to recursively partition a collection into smaller collections that contain a single element each, the overhead of the mechanics of fork/join would actually bring down the overall performance of the computation.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0044"/>Note</h3><p>A fork/join based method of parallelization is actually implemented in the <code class="literal">clojure.core.reducers</code> namespace using the <code class="literal">ForkJoinTask</code> and <code class="literal">ForkJoinPool</code> classes from the <code class="literal">java.util.concurrent</code> namespace in Java 7. In Java 6, it is implemented in the <code class="literal">ForkJoinTask</code> and <code class="literal">ForkJoinPool</code> classes of the <code class="literal">jsr166y</code> namespace. For more information on the Java fork/join<a class="indexterm" id="id00194"/> framework, visit <a class="ulink" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html</a>.</p></div></div><p>The parallelization of such computations using reducers is quite different from how it is handled in MapReduce-based libraries. In case of reducers, the elements are first reduced through a number of transformations into a smaller number of elements and then finally, combined to create the result. This contrasts with how a MapReduce strategy models such a computation, in which the elements of a collection are mapped through several transformations and a final reduction step is used to produce the final result. This distinguishes the MapReduce model of parallel computation with the <span class="emphasis"><em>reduce-combine</em></span> model used by the <code class="literal">reducers</code> library. This methodology of parallelization using a reduce-combine strategy is implemented by the <code class="literal">fold</code> function in the <code class="literal">clojure.core.reducers</code> namespace.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0045"/>Note</h3><p>In Clojure, the <code class="literal">fold</code> function<a class="indexterm" id="id00195"/> refers to a parallelizable computation, which is very different from the traditional fold left (<code class="literal">foldl</code>) and fold right (<code class="literal">foldr</code>) functions in other functional programming languages such as Haskell and Erlang. The <code class="literal">reduce</code> function in Clojure actually has the same sequential nature and semantics as the <code class="literal">foldl</code> function in other languages.</p></div></div><p>The <code class="literal">fold</code> function parallelizes a given computation over a collection using fork/join based threads. It implements the reduce-combine strategy that we previously described and executes the <code class="literal">reduce</code> function in parallel over equally partitioned segments of a given collection. The results produced by these parallel executions of the <code class="literal">reduce</code> function are finally combined using a <a class="indexterm" id="id00196"/>
<span class="emphasis"><em>combining function</em></span>. Of course, if the supplied collection is too small to actually gain any performance through fork/join based parallelization, a <code class="literal">fold</code> form will simply<a class="indexterm" id="id00197"/> call the <code class="literal">reduce</code> function on a single thread of execution. The <code class="literal">fold</code> function thus represents a <span class="emphasis"><em>potentially parallelizable</em></span> computation over a collection. Due to this nature of <code class="literal">fold</code>, we should avoid performing IO and other side effects based on sequential ordering when using the <code class="literal">fold</code> form.</p><p>The <code class="literal">fold</code> function allows a<a class="indexterm" id="id00198"/> collection to define how it is <span class="emphasis"><em>folded</em></span> into the result, which is similar to the semantics of the <code class="literal">reduce</code> function. A collection is said to be <span class="emphasis"><em>foldable</em></span> if it implements the <code class="literal">CollFold</code> protocol from the <code class="literal">clojure.core.reducers</code> namespace. The <code class="literal">reducers</code> library extends the <code class="literal">CollFold</code> protocol for the standard vector and map collection types. The parallelization of these implementations of <code class="literal">CollFold</code> is done using fork/join based parallelism. The definition of the <code class="literal">CollFold</code> protocol is shown in <span class="emphasis"><em>Example 3.9</em></span>:</p><div class="informalexample"><pre class="programlisting">(defprotocol CollFold
  (coll-fold [coll n cf rf]))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.9: The CollFold protocol</em></span></p></blockquote></div><p>The <code class="literal">CollFold</code> protocol defines a <code class="literal">coll-fold</code> function, which requires four arguments—a collection <code class="literal">coll</code>, the number of elements <code class="literal">n</code> in each segment or partition of the collection, a combining function <code class="literal">cf</code>, and a reducing function <code class="literal">rf</code>. A foldable collection must implement this protocol, as well as the <code class="literal">clojure.core.protocols.CollReduce</code> protocol, as a call to <code class="literal">fold</code> on a given collection may fall back to a single-threaded execution of the <code class="literal">reduce</code> function.</p><p>To create a foldable collection from a collection and a reduction function transformer, the reducers library defines a <code class="literal">folder</code> function with similar semantics as the <code class="literal">reducer</code> function. This function is implemented as shown in <span class="emphasis"><em>Example 3.10</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn folder
  ([coll xf]
   (reify
     CollReduce
     (coll-reduce [_ rf init]
       (coll-reduce coll (xf rf) init))
     CollFold
     (coll-fold [_ n cf rf]
       (coll-fold coll n cf (xf rf))))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.10: The folder function</em></span></p></blockquote></div><p>The <code class="literal">folder</code> function creates a new foldable and reducible collection from the collection <code class="literal">coll</code> and the reduction function transformer <code class="literal">xf</code>. This composition of the <code class="literal">xf</code> and <code class="literal">rf</code> functions is analogous<a class="indexterm" id="id00199"/> to that performed by the <code class="literal">reducer</code> function described in <span class="emphasis"><em>Example 3.5</em></span>. Apart from the <code class="literal">xf</code> and <code class="literal">rf</code> functions, the <code class="literal">coll-fold</code> function also requires a combining function <code class="literal">cf</code> with which the results of the potentially parallel executions<a class="indexterm" id="id00200"/> of the <code class="literal">reduce</code> function are combined. Similar to the <code class="literal">reduce</code> function, the <code class="literal">fold</code> function passes on the responsibility of actually folding a given collection to the collections implementation of the <code class="literal">coll-fold</code> function. An implementation of the <code class="literal">fold</code> function is described in <span class="emphasis"><em>Example 3.11</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn fold
  ([rf coll]
   (fold rf rf coll))
  ([cf rf coll]
   (fold 512 cf rf coll))
  ([n cf rf coll]
   (coll-fold coll n cf rf)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.11: The fold function</em></span></p></blockquote></div><p>As shown in <span class="emphasis"><em>Example 3.11</em></span>, the <code class="literal">fold</code> function calls the<code class="literal"> coll-fold</code> function of the collection <code class="literal">coll</code> using the reducing function <code class="literal">rf</code> and the combining function <code class="literal">cf</code>. The <code class="literal">fold</code> function can also specify the number of elements <code class="literal">n</code> in each segment processed by the <code class="literal">reduce</code> function, which defaults to <code class="literal">512</code> elements. We can also avoid specifying the combining function <code class="literal">cf</code> to the <code class="literal">fold</code> function, in which case the reducing function <code class="literal">rf</code> itself will be used as the combining function.</p><p>An interesting aspect of the combining and reducing functions used by the <code class="literal">fold</code> form is that they must be <span class="emphasis"><em>associative</em></span> in nature. This guarantees that the result of the <code class="literal">fold</code> function will be independent of the order in which the elements in a given collection are combined to produce the given result. This allows us to parallelize the execution of the <code class="literal">fold</code> function over segments of a given collection. Also, analogous to the reducing function required by the <code class="literal">reduce</code> form, the <code class="literal">fold</code> function requires the combining and reducing functions to produce<a class="indexterm" id="id00201"/> an <span class="emphasis"><em>identity value</em></span> when invoked with no arguments. In functional programming, a function that is both associative and provides an identity value is termed as a<a class="indexterm" id="id00202"/> <span class="strong"><strong>monoid</strong></span>. The <code class="literal">clojure.core.reducers</code> namespace provides the <code class="literal">monoid</code> function, described in <span class="emphasis"><em>Example 3.12</em></span>, to create such a function that can be used as the combining function or the reducing function supplied to a <code class="literal">fold</code> form:</p><div class="informalexample"><pre class="programlisting">(defn monoid
  [op ctor]
  (fn
    ([] (ctor))
    ([a b] (op a b))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.12: The monoid function</em></span></p></blockquote></div><p>The <code class="literal">monoid</code> function shown in <span class="emphasis"><em>Example 3.12</em></span> produces a function that calls a function <code class="literal">op</code> when supplied with two arguments <code class="literal">a</code> and <code class="literal">b</code>. When the function returned by the <code class="literal">monoid</code> function is called with no arguments, it will produce an identity value of the operation by simply calling the <code class="literal">ctor</code> function<a class="indexterm" id="id00203"/> with no arguments. This function allows us to easily create a combining<a class="indexterm" id="id00204"/> function to be used with the <code class="literal">fold</code> function from any arbitrary functions <code class="literal">ctor</code> and <code class="literal">op</code>.</p><p>We can now redefine the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> operations as compositions of the <code class="literal">folder</code> function and the <code class="literal">mapping</code>, <code class="literal">filtering</code>, and <code class="literal">mapcatting</code> transformers defined in <span class="emphasis"><em>Example 3.3</em></span>, as shown in <span class="emphasis"><em>Example 3.13</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn map [f coll]
  (folder coll (mapping f)))

(defn filter [p? coll]
  (folder coll (filtering p?)))

(defn mapcat [f coll]
  (folder coll (mapcatting f)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.13: Redefining the map, filter and mapcat functions using the folder form</em></span></p></blockquote></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0046"/>Note</h3><p>The definitions of <code class="literal">folder</code>, <code class="literal">fold</code>, <code class="literal">monoid</code>, <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> as shown in this section are simplified versions of their actual definitions in the <code class="literal">clojure.core.reducers</code> namespace.</p></div></div><p>The <code class="literal">reducers</code> library also defines the <code class="literal">foldcat</code> function. This function is a high-performance variant of the <code class="literal">reduce</code> and <code class="literal">conj</code> functions. In other words, the evaluation of the expression <code class="literal">(foldcat coll)</code> will be significantly faster than that of the expression <code class="literal">(reduce conj [] coll)</code>, where <code class="literal">coll</code> is a reducible or foldable collection. Also, the collection returned by the <code class="literal">foldcat</code> function will be a foldable collection.</p><p>Let's now use the <code class="literal">fold</code> and <code class="literal">map</code> functions to improve the performance of the <code class="literal">process</code> and <code class="literal">process-with-reducer</code> functions from <span class="emphasis"><em>Example 3.8</em></span>. We can implement this as shown in <span class="emphasis"><em>Example 3.14</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn process-with-folder [nums]
  (r/fold + (r/map inc (r/map inc (r/map inc nums)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.14: A function to process a collection of numbers using a fold form</em></span></p></blockquote></div><p>The performance of the <code class="literal">process-with-folder</code> function with a large vector can be compared to the <code class="literal">process</code> and <code class="literal">process-with-reducer</code> functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def nums (vec (range 1000000)))</strong></span>
#'user/nums
<span class="strong"><strong>user&gt; (time (process nums))</strong></span>
"Elapsed time: 474.240782 msecs"
500002500000
<span class="strong"><strong>user&gt; (time (process-with-reducer nums))</strong></span>
"Elapsed time: 364.945748 msecs"
500002500000
<span class="strong"><strong>user&gt; (time (process-with-folder nums))</strong></span>
"Elapsed time: 241.057025 msecs"
500002500000</pre></div><p>It is observed from<a class="indexterm" id="id00205"/> the preceding output that the <code class="literal">process-with-folder</code> function performs significantly better than the <code class="literal">process</code> and <code class="literal">process-with-reducer</code> functions due to its inherent use of parallelism. In summary, reducers improve the performance <a class="indexterm" id="id00206"/>of a computation that has to be performed over a collection using fork/join-based parallelism.</p></div>
<div class="section" title="Processing data with reducers"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec0025"/>Processing data with reducers</h1></div></div></div><p>We will now <a class="indexterm" id="id00207"/>study a simple example that depicts the use of<a class="indexterm" id="id00208"/> reducers in efficiently processing large collections. For this example, we will use<a class="indexterm" id="id00209"/> the <code class="literal">iota</code> library (<a class="ulink" href="https://github.com/thebusby/iota">https://github.com/thebusby/iota</a>) to handle large memory-mapped files. The usage of the <code class="literal">iota</code> library with large files is encouraged as an efficient alternative to using concrete collections. For example, loading the records in a 1 GB TSV file as strings into a Clojure vector would consume over 10 GB of memory due to the inefficient storage of Java strings. The <code class="literal">iota</code> library avoids this by efficiently indexing and caching the contents of a large file, and this is done with much lower amount of memory overhead when compared to using concrete collections.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0047"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[iota "1.1.2"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [iota :as i]
            [clojure.string :as cs]
            [clojure.core.reducers :as r]))</pre></div><p>The following examples can be found in <code class="literal">src/m_clj/c3/io.clj</code> of the book's source code.</p></div></div><p>Suppose we have a large TSV file that contains several thousands of records. Each record represents a person, and can be assumed to have five fields, as shown in the following data:</p><div class="informalexample"><pre class="programlisting">brown  brian  :m  :child    :east
smith  bill   :f  :child    :south
jones  jill   :f  :parent   :west</pre></div><p>Each record contains two strings and three keywords. The first two string fields of a record represent the last and first name of a person, the third column is a keyword that indicates the gender <a class="indexterm" id="id00210"/>of a person, and the fourth column is a keyword that identifies a person as a parent or a child. Finally, the fifth column is a keyword that<a class="indexterm" id="id00211"/> represents an arbitrary direction.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0050"/>Note</h3><p>The following example expects the content shown previously to be present in the file <code class="literal">resources/data/sample.tsv</code>, relative to the root of your Leiningen project.</p></div></div><p>The <code class="literal">seq</code> and <code class="literal">vec</code> functions from the <code class="literal">iota</code> library can be used to create a sequence and a vector representation of a memory-mapped file. These objects can then be used to access the file in a performant way. Both of the <code class="literal">seq</code> and <code class="literal">vec</code> functions require a file path to be passed to them as the first argument. The <code class="literal">vec</code> function will index the supplied file in <span class="emphasis"><em>chunks</em></span>, and we can specify the size of each chunk as the second argument to the <code class="literal">vec</code> function. The <code class="literal">seq</code> function performs buffered reads of the supplied file as required, similar to the way a lazy sequence is realized. The size of the buffer used by this resulting sequence can be specified as the second argument to the <code class="literal">seq</code> function. Both the <code class="literal">seq</code> and <code class="literal">vec</code> functions split the contents of a file by a predefined byte-separator into records represented as strings. These functions<a class="indexterm" id="id00212"/> also accept an optional third argument to indicate the byte separator between records in the supplied file. The <code class="literal">vec</code> function is slower than the <code class="literal">seq</code> function as it must index the records in the file, which can be demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (def file-as-seq (i/seq "resources/data/sample.tsv")))</strong></span>
"Elapsed time: 0.905326 msecs"
#'user/file-as-seq
<span class="strong"><strong>user&gt; (time (def file-as-vec (i/vec "resources/data/sample.tsv")))</strong></span>
"Elapsed time: 4.95506 msecs"
#'user/file-as-vec</pre></div><p>Both the statements shown here load the <code class="literal">sample.tsv</code> file into Clojure data structures. As expected, the <code class="literal">vec</code> function takes a bit more time than the <code class="literal">seq</code> function to return a value. The values returned by <code class="literal">seq</code> and <code class="literal">vec</code> can be treated just like any other collection. Naturally, iterating over a vector returned by the <code class="literal">vec</code> function is much faster than using a sequence, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (def first-100-lines (doall (take 100 file-as-seq))))</strong></span>
"Elapsed time: 63.470598 msecs"
#'user/first-100-lines
<span class="strong"><strong>user&gt; (time (def first-100-lines (doall (take 100 file-as-vec))))</strong></span>
"Elapsed time: 0.984128 msecs"
#'user/first-100-lines</pre></div><p>We will now demonstrate a couple of ways to query the data in the <code class="literal">sample.tsv</code> file using reducers and the <code class="literal">iota</code> library. We will need to first define a function that converts a collection of <a class="indexterm" id="id00213"/>records into collections of columnar values from their string-based representations. This can be implemented using the reducer based <code class="literal">map</code> and <code class="literal">filter</code> functions, as shown in the <code class="literal">into-records</code> function in <span class="emphasis"><em>Example 3.15</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn into-records [file]
  (-&gt;&gt; file
       (r/filter identity)
       (r/map #(cs/split % #"[\t]"))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.15: A function to convert a memory-mapped file into a reducible collection</em></span></p></blockquote></div><p>Now, let's say we need to compute the total number of females from the records in the <code class="literal">sample.tsv</code> file. We can implement a function to perform this computation using the <code class="literal">map</code> and <code class="literal">fold</code> functions, as shown in the <code class="literal">count-females</code> function in <span class="emphasis"><em>Example 3.16</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn count-females [coll]
  (-&gt;&gt; coll
       (r/map #(-&gt; (nth % 2)
                   ({":m" 0 ":f" 1})))
       (r/fold +)))</pre></div><p>We can query the total number of females in the <code class="literal">file-as-seq</code> and <code class="literal">file-as-vec</code> collections by composing the <code class="literal">into-records</code> and <code class="literal">count-females</code> functions. This can be done using the <code class="literal">-&gt;</code> threading form, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; file-as-seq into-records count-females)</strong></span>
10090
<span class="strong"><strong>user&gt; (-&gt; file-as-vec into-records count-females)</strong></span>
10090</pre></div><p>Similarly, the reducer-based <code class="literal">map</code> and <code class="literal">filter</code> functions can be used to fetch the first names of all the<a class="indexterm" id="id00214"/> children with the same last name or family in a given collection, as implemented by the <code class="literal">get-children-names-in-family</code> function in <span class="emphasis"><em>Example 3.17</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn get-children-names-in-family [coll family]
  (-&gt;&gt; coll
       (r/filter #(and (= (nth % 0) family)
                       (= (nth % 3) ":child")))
       (r/map #(nth % 1))
       (into [])))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 3.17: A function to get the first names of all children in a collection of persons</em></span></p></blockquote></div><p>The <code class="literal">into-records</code> and <code class="literal">get-children-names-in-family</code> functions can be composed together to query the first names of all children with the last name <code class="literal">"brown"</code> from the available data, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; file-as-seq into-records</strong></span>
<span class="strong"><strong>          (get-children-names-in-family "brown"))</strong></span>
["sue" "walter" ... "jill"]
<span class="strong"><strong>user&gt; (-&gt; file-as-vec into-records</strong></span>
<span class="strong"><strong>          (get-children-names-in-family "brown"))</strong></span>
["sue" "walter" ... "jill"]</pre></div><p>The <code class="literal">iota</code> library<a class="indexterm" id="id00215"/> provides a couple more useful functions to handle large text files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">numbered-vec</code> function will create a vector representing a memory-mapped file in which each string representing a record will be prepended with its position in the given file.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">subvec</code> function of the <code class="literal">iota</code> library can be used to <span class="emphasis"><em>slice</em></span> records from a memory-mapped file returned by the <code class="literal">vec</code> and <code class="literal">numbered-vec</code> functions. Its semantics are identical to the standard <code class="literal">subvec</code> function that operates on vectors.</li></ul></div><p>Reducers and the <code class="literal">iota</code> library<a class="indexterm" id="id00216"/> allow us to idiomatically and efficiently handle text files containing a large number of byte-separated records. There are <a class="indexterm" id="id00217"/>also several other libraries and frameworks in the Clojure ecosystem that use reducers to handle large amounts of data, and the reader is encouraged to explore these libraries and frameworks on their own.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec0026"/>Summary</h1></div></div></div><p>In this chapter, we explored the <code class="literal">clojure.core.reducers</code> library in detail. We had a look at how reducers are implemented and also how we can use reducers to handle large collections of data in an efficient manner. We also briefly studied the <code class="literal">iota</code> library that can be used with reducers to handle large amounts of data stored in text files.</p><p>In the following chapter, we will explore Clojure macros.</p></div>
<div class="chapter" title="Chapter&#xA0;4.&#xA0;Metaprogramming with Macros"><div class="titlepage"><div><div><h1 class="title"><a id="ch19"/>Chapter 4. Metaprogramming with Macros</h1></div></div></div><p>Programmers often stumble into situations where they would like to add features or constructs to their programming language of choice. Generally, if a feature would have to be added to a language, the language's compiler or interpreter would need some modification. Alternatively, Clojure (and other Lisps as well) uses <span class="emphasis"><em>macros</em></span> to solve this problem. The term <a class="indexterm" id="id00218"/>
<span class="emphasis"><em>metaprogramming</em></span> is used to describe the ability to generate or manipulate a program's source code by using another program. Macros are a metaprogramming tool that allow programmers to easily add new features to their programming language.</p><p>Lisps are not the only languages with support for macro-based metaprogramming. For example, in C and C++, macros are handled by the compiler's preprocessor. In these languages, before a program is compiled, all macro calls in the program's source code are replaced by <a class="indexterm" id="id00219"/>their definitions. In this sense, macros are used to generate code through a form of text substitution during the compilation phase of a program. On the other hand, Lisps allow programmers to transform or rewrite code when macros are interpreted or compiled. Macros can thus be used to concisely encapsulate recurring patterns in code. Of course, this can be done in languages without macros, as well, without much hassle. But macros allow us to encapsulate patterns in code in a clean and concise manner. As we will see ahead in this chapter, there's nothing equivalent to Lisp macros in other programming languages in terms of clarity, flexibility, and power. Lisps are truly leaps ahead of other programming languages in terms of metaprogramming capabilities.</p><p>The rabbit hole of macros in Lisps goes deep enough that there are entire books that talk about them. <span class="emphasis"><em>Mastering Clojure Macros</em></span> by <span class="emphasis"><em>Colin Jones</em></span> is one among these, and this publication describes the various patterns in which macros can be used in great detail. In this chapter, we will explore the foundational concepts behind macros and their usage. We will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, have a look at the basics of reading, evaluating, and transforming code in Clojure.</li><li class="listitem" style="list-style-type: disc">Later on, we will examine how macros can be defined and used, and also study several examples based on macros. We will also describe how we can handle platform-specific <a class="indexterm" id="id00220"/>code using <span class="emphasis"><em>reader conditionals</em></span>.</li></ul></div><div class="section" title="Understanding the reader"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec0027"/>Understanding the reader</h1></div></div></div><p>The reader is<a class="indexterm" id="id00221"/> responsible for interpreting Clojure code. It performs several steps to translate source code in textual representation into executable machine code. In this section, we will briefly describe these steps performed by the reader to illustrate how the reader works.</p><p>Clojure and other languages from the Lisp<a class="indexterm" id="id00222"/> family are <span class="strong"><strong>homoiconic</strong></span>. In a homoiconic language, the source code of a program is represented as a plain data structure. This means that all the code written in a Lisp language is simply a bunch of nested lists. Thus, we can manipulate programs' code just like any other list of values. Clojure has a few more data structures, such as vectors and maps in its syntax, but they can be handled just as easily. In languages that are not homoiconic, any expression or statement in a<a class="indexterm" id="id00223"/> program has to be translated into an internal data structure termed as a <span class="emphasis"><em>parse tree</em></span>, or <span class="emphasis"><em>syntax tree</em></span>, when<a class="indexterm" id="id00224"/> the program is compiled or interpreted. In Lisps, however, an expression is already in the form of a syntax tree, since a tree is really just another name for a nested list. In other words, there is no distinction between an expression and the syntax tree it produces. One might also opine that this design tricks programmers into writing code directly as a syntax tree. This distinguishing aspect of Lisps is succinctly captured by the following axiom: <span class="emphasis"><em>Code is Data</em></span>.</p><p>Let's first take a look at the most rudimentary representation of code and data in Lisps—an <span class="strong"><strong>s-expression</strong></span>. Any<a class="indexterm" id="id00225"/> expression comprises of <span class="emphasis"><em>values</em></span> and <span class="emphasis"><em>symbols</em></span>, where the <a class="indexterm" id="id00226"/>symbols represent <a class="indexterm" id="id00227"/>variables being used. A nested list of symbols is known as a<a class="indexterm" id="id00228"/> <span class="emphasis"><em>symbolic expression</em></span>, <span class="emphasis"><em>s-expression</em></span>, or <a class="indexterm" id="id00229"/>
<span class="emphasis"><em>sexp</em></span>. All <a class="indexterm" id="id00230"/>source code in Clojure is represented as s-expressions. A symbolic <a class="indexterm" id="id00231"/>expression is formally defined as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An atom, which refers to a single symbol or literal value.</li><li class="listitem" style="list-style-type: disc">A combination of two s-expressions <code class="literal">x</code> and <code class="literal">y</code>, represented as <code class="literal">(x . y)</code>. Here, the dot (<code class="literal">.</code>) is used to signify a <code class="literal">cons</code> operation.</li></ul></div><p>Using this recursive definition, a list of symbols <code class="literal">(x y z)</code> is represented by the s-expression, <code class="literal">(x . (y . (z . nil)))</code> or <code class="literal">(x . (y . z))</code>. When an s-expression is used to represent source code, the first element of the expression represents the function used, and the rest of the elements are the arguments to the function. Of course, this is just a theoretical representation and not really Clojure code. This representation is also called <span class="emphasis"><em>prefix notation</em></span>. This recursive<a class="indexterm" id="id00232"/> structure of s-expressions is flexible enough to represent both code as well as data. In fact, s-expressions are more-or-less the only form of syntax in Clojure (and other Lisps). For example, if we wanted to add two numbers, we would use an expression with the <code class="literal">+</code> function as the first symbol, followed by the values to be added. Similarly, if we wanted to define a function, we would have to write an expression with <code class="literal">defn</code> or <code class="literal">def</code> as the first symbol in the expression. In Clojure and other Lisps, we also represent data such as lists, vectors, and maps using s-expressions.</p><p>Let's look at a<a class="indexterm" id="id00233"/> simple example that depicts how Clojure code is interpreted. The expression <code class="literal">(-&gt; [0 1 2] first inc)</code> that uses a threading macro (<code class="literal">-&gt;</code>) will be interpreted in three distinct steps. This expression will be read, <span class="emphasis"><em>macroexpanded</em></span>, and <a class="indexterm" id="id00234"/>evaluated to the value <code class="literal">1</code>, as illustrated here:</p><div class="mediaobject"><img alt="Understanding the reader" src="graphics/B05024_04_01.jpg"/></div><p>The reader will first parse textual representations of s-expressions from a Clojure program's source code. Once a program's source code is read into s-expressions, all macro calls in the code are replaced by their definitions. This transformation of macro calls in a program is called <a class="indexterm" id="id00235"/>
<span class="emphasis"><em>macroexpansion</em></span>. Lastly, the resulting s-expressions from the macroexpansion phase are evaluated by the Clojure runtime. In the evaluation phase, bytecode is generated from the supplied expressions, loaded into memory, and executed. In short, code in a program's source code is read, transformed through macros, and finally evaluated. Also, macroexpansion happens immediately after a program's source code is parsed, thus <a class="indexterm" id="id00236"/>allowing the program to internally transform itself before it is evaluated. This transformation of code is exactly what macros are used to achieve.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0051"/>Note</h3><p>In Clojure, the reader only reads code and performs macroexpansion. The generation of bytecode is done by the analyzer and the emitter, and this generated bytecode is evaluated by the JVM.</p></div></div><p>All Clojure code is translated to <span class="emphasis"><em>reader forms</em></span> and <span class="emphasis"><em>special forms</em></span> before it is evaluated. Special forms are constructs, such as <code class="literal">quote</code> and <code class="literal">let*</code>, that are implemented directly as bytecode for the underlying runtime, such as the JVM for Clojure or the Rhino JavaScript runtime for ClojureScript. Interestingly, Clojure source code is composed mostly of reader forms, and these reader forms are implemented in Clojure itself. The reader also transforms certain characters and forms <a class="indexterm" id="id00237"/>called <span class="emphasis"><em>reader macros</em></span> as soon as they are read. There are several reader macros in the Clojure language, as described in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Reader macro</p>
</th><th style="text-align: left" valign="bottom">
<p>Usage</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">\x</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a class="indexterm" id="id00238"/> a character literal.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is used to <a class="indexterm" id="id00239"/>comment. It ignores the rest of the line.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">(.method o)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a class="indexterm" id="id00240"/> a native method call. It is rewritten to a dot (<code class="literal">.</code>) form as <code class="literal">(. o method)</code>. Also, <code class="literal">o</code> must be a native object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@x</code> or <code class="literal">@( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the <a class="indexterm" id="id00241"/>dereference operator. It is used with reference<a class="indexterm" id="id00242"/> types and is rewritten to a <code class="literal">deref</code> form.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">^{ ... }</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the<a class="indexterm" id="id00243"/> metadata map to be used with a form. It is rewritten to a <code class="literal">with-meta</code> form.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">'x</code> or <code class="literal">'( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a class="indexterm" id="id00244"/> quote.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">`x</code> or <code class="literal">`( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a class="indexterm" id="id00245"/> a syntax quote.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">~x</code> or <code class="literal">~( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is used to <a class="indexterm" id="id00246"/>unquote.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">~@x</code> or <code class="literal">~@( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a class="indexterm" id="id00247"/> a splicing unquote.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">#_x</code> or <code class="literal">#_( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This ignores the next form. <code class="literal">#_</code> should be preferred <a class="indexterm" id="id00248"/>over the <code class="literal">comment</code> form to comment out code, since comment actually returns <code class="literal">nil</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">#'x</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a class="indexterm" id="id00249"/> a var quote. It is equivalent to <code class="literal">(var x)</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">#=x</code> or <code class="literal">#=( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This will<a class="indexterm" id="id00250"/> read-evaluate an expression.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">#?( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a class="indexterm" id="id00251"/>reader conditional form.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">#?@( ... )</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a class="indexterm" id="id00252"/> reader conditional splicing form.</p>
</td></tr></tbody></table></div><p>We have<a class="indexterm" id="id00253"/> encountered quite a few of the preceding reader macros in the previous chapters. We will demonstrate the usage of several reader forms that are used with macros in this chapter. </p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0052"/>Note</h3><p>At the time of writing this book, Clojure does not support user-defined reader macros.</p></div></div><p>Now that we have familiarized ourselves with the Clojure reader and how code is interpreted, let's explore the various metaprogramming constructs that help us read and evaluate code.</p></div></div>
<div class="section" title="Reading and evaluating code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec0028"/>Reading and evaluating code</h1></div></div></div><p>Let's<a class="indexterm" id="id00254"/> have a look at<a class="indexterm" id="id00255"/> how code can be parsed and evaluated in Clojure. The most elementary way to convert text into an expression is by using the <code class="literal">read</code> function. This function accepts a <code class="literal">java.io.PushbackReader</code> instance as its first argument, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (read (-&gt; "(list 1 2 3)"</strong></span>
<span class="strong"><strong>                .toCharArray</strong></span>
<span class="strong"><strong>                java.io.CharArrayReader.</strong></span>
<span class="strong"><strong>                java.io.PushbackReader.))</strong></span>
(list 1 2 3)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0053"/>Note</h3><p>These examples can be found in <code class="literal">src/m_clj/c4/read_and_eval.clj</code> of the book's source code.</p></div></div><p>In this example, a string<a class="indexterm" id="id00256"/> containing a valid expression is first converted into an instance of <code class="literal">java.io.PushbackReader</code> and then passed to the <code class="literal">read</code> function. It seems like a lot of unnecessary work to read a string, but it is due to the fact that the <code class="literal">read</code> function deals with streams and readers, and not strings. If no arguments are passed to the <code class="literal">read</code> function, it will create a reader from the standard input and prompt the user to enter an expression to be parsed. The <code class="literal">read</code> function has several other options as well, and you<a class="indexterm" id="id00257"/> are encouraged to explore these options in the REPL on their own.</p><p>A simpler way to read an expression from a string is by using the <code class="literal">read-string</code> function. This function accepts a string as its only argument and converts the supplied string into an expression, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (read-string "(list 1 2 3)")</strong></span>
(list 1 2 3)</pre></div><p>The <code class="literal">read</code> and <code class="literal">read-string</code> forms can only convert strings into valid expressions. If we have to evaluate an expression, we must use the <code class="literal">eval</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (eval '(list 1 2 3))</strong></span>
(1 2 3)
<span class="strong"><strong>user&gt; (eval (list + 1 2 3))</strong></span>
6
<span class="strong"><strong>user&gt; (eval (read-string "(+ 1 2 3)"))</strong></span>
6</pre></div><p>In the first statement in the preceding output, we prevent the expression <code class="literal">(list 1 2 3)</code> from being evaluated before it is passed to the <code class="literal">eval</code> function using the quote operator (<code class="literal">'</code>). This technique is termed as <a class="indexterm" id="id00258"/>
<span class="emphasis"><em>quoting</em></span> and we shall explore more of it later in this chapter. The <code class="literal">eval</code> function evaluates the expression <code class="literal">(list 1 2 3)</code> to the list <code class="literal">(1 2 3)</code>. Similarly, in the second statement, the expression <code class="literal">(list + 1 2 3)</code> is first evaluated as <code class="literal">(+ 1 2 3)</code> by the reader, and then the <code class="literal">eval</code> function evaluates this list to the value <code class="literal">6</code>. In the third statement, the string <code class="literal">"(+ 1 2 3)"</code> is first parsed by the <code class="literal">read-string</code> function and then evaluated by the <code class="literal">eval</code> function.</p><p>The read-evaluate macro (<code class="literal">#=</code>) can be used to force the <code class="literal">read</code> and <code class="literal">read-string</code> functions to evaluate an expression when it is parsed, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (read (-&gt; "#=(list 1 2 3)"</strong></span>
<span class="strong"><strong>                .toCharArray</strong></span>
<span class="strong"><strong>                java.io.CharArrayReader.</strong></span>
<span class="strong"><strong>                java.io.PushbackReader.))</strong></span>
(1 2 3)
<span class="strong"><strong>user&gt; (read-string "#=(list 1 2 3)")</strong></span>
(1 2 3)</pre></div><p>In the preceding output, the <code class="literal">#=</code> reader macro evaluates the expression <code class="literal">(list 1 2 3)</code> when it is read by the <code class="literal">read</code> and <code class="literal">read-string</code> functions. If the <code class="literal">#=</code> macro was not used, both statements would return the expression <code class="literal">(list 1 2 3)</code> in verbatim. We can also use the <code class="literal">#= </code>macro without using <code class="literal">read</code> or <code class="literal">read-string</code>, in which case it would be equivalent to calling the <code class="literal">eval</code> function. Also, the calls to the <code class="literal">#=</code> macro can be nested any number of times, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; #=(list + 1 2 3)</strong></span>
6
<span class="strong"><strong>user&gt; (read-string "#=(list + 1 2 3)")</strong></span>
(+ 1 2 3)
<span class="strong"><strong>user&gt; (read-string "#=#=(list + 1 2 3)")</strong></span>
6</pre></div><p>The <code class="literal">#=</code> macro<a class="indexterm" id="id00259"/> makes it easy to evaluate expressions while they are being read. Oh wait! This is a potential security hazard as the <code class="literal">read</code> and <code class="literal">read-string</code> functions are evaluating arbitrary strings, even if they contain any malicious code. Thus, evaluation of code <a class="indexterm" id="id00260"/>while it is being parsed is deemed unsafe. As a solution to this problem, the <code class="literal">*read-eval*</code> var can be set to <code class="literal">false</code> to prevent usage of the <code class="literal">#=</code> macro, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (binding [*read-eval* false]</strong></span>
<span class="strong"><strong>        (read-string (read-string "#=(list 1 2 3)")))</strong></span>
RuntimeException EvalReader not allowed when *read-eval* is false. clojure.lang.Util.runtimeException (Util.java:221)</pre></div><p>Thus, use of the <code class="literal">#=</code> macro in strings passed to the <code class="literal">read</code> and <code class="literal">read-string</code> functions will throw an error if <code class="literal">*read-eval*</code> is set to <code class="literal">false</code>. Obviously, the default value of this var is <code class="literal">true</code>. For this reason, we must avoid using the <code class="literal">#=</code> macro, or set the <code class="literal">*read-eval*</code> var to <code class="literal">false</code>, while processing the user input.</p><p>Another way to read and evaluate arbitrary strings is by using the <code class="literal">load-string</code> function. This function has the same arity as the <code class="literal">read-string</code> function, and is equivalent to calling the <code class="literal">eval</code> and <code class="literal">read-string</code> forms, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (load-string "(+ 1 2 3)")</strong></span>
6</pre></div><p>There are a couple of semantic differences between using the <code class="literal">load-string</code> form and a composition of the <code class="literal">eval</code> and <code class="literal">read-string</code> forms. Firstly, the behavior of the <code class="literal">load-string</code> function is not affected by the changing <code class="literal">*read-eval*</code> var, and is thus unsafe for use with arbitrary user input. </p><p>A more important difference is that the <code class="literal">read-string</code> function only parses the first expression it encounters in the string that it has passed. The <code class="literal">load-string</code> function will parse and evaluate all expressions passed to it, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (eval (read-string "(println 1) (println 2)"))</strong></span>
1
nil
<span class="strong"><strong>user&gt; (load-string "(println 1) (println 2)")</strong></span>
1
2
nil</pre></div><p>In the preceding output, the <code class="literal">read-string</code> form skips the second <code class="literal">println</code> form in the string that it is passed, thus printing the value <code class="literal">1</code> only. The <code class="literal">load-string</code> form, however, parses and evaluates both the <code class="literal">println</code> forms it is passed as a string, and prints both the values <code class="literal">1</code> and <code class="literal">2</code>.</p><p>The <code class="literal">load-reader</code> function is analogous to the <code class="literal">read</code> function, in the sense that it accepts a <code class="literal">java.io.PushbackReader</code> instance, from which it has to read and evaluate forms, as an argument. Another<a class="indexterm" id="id00261"/> variant of <code class="literal">load-string</code> is the <code class="literal">load-file</code> function, to which we can pass<a class="indexterm" id="id00262"/> the path of a file that contains source code. The <code class="literal">load-file</code> function will parse the file in the path that it is passed and evaluate all forms present in it.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0054"/>Note</h3><p>Note that the <code class="literal">*file*</code> var can be used to obtain the path of the current file being executed.</p></div></div><p>So far, we have seen how code can be parsed and evaluated by the Clojure reader. There are several constructs that can be used to perform these tasks. However, evaluating arbitrary strings is not really a good idea, as the code being evaluated is insecure and may be malicious. In practice, we should always set the <code class="literal">*read-eval*</code> variable to <code class="literal">false</code> in order to prevent the evaluation of arbitrary code by functions such as <code class="literal">read</code> and <code class="literal">read-string</code>. Next, we will explore how <span class="emphasis"><em>quoting</em></span> and <span class="emphasis"><em>unquoting</em></span> can be used to transform expressions.</p></div>
<div class="section" title="Quoting and unquoting code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec0029"/>Quoting and unquoting code</h1></div></div></div><p>We will now explore <span class="emphasis"><em>quoting</em></span> and <span class="emphasis"><em>unquoting</em></span>, which are techniques used to generate expressions based <a class="indexterm" id="id00263"/>on a predefined template for an expression. These techniques are foundational in creating macros, and they help structure the code of a macro to look more<a class="indexterm" id="id00264"/> like its macroexpanded form.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0055"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c4/</code> <code class="literal">quoting.clj</code> of the book's source code.</p></div></div><p>The <code class="literal">quote</code> form simply returns an expression without evaluating it. This may seem trivial, but preventing the evaluation of an expression is actually something that is not possible in all programming languages. The <code class="literal">quote</code> form is abbreviated using the apostrophe character (<code class="literal">'</code>). If we <span class="emphasis"><em>quote</em></span> an expression, it is returned in verbatim, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; 'x</strong></span>
x
<span class="strong"><strong>user&gt; (quote x)</strong></span>
x</pre></div><p>The <code class="literal">quote</code> form is quite historic in Lisp. It is one of the seven primitive operators in the original Lisp language, as described in John McCarthy's paper. Incidentally, <code class="literal">quote</code> is one among the rare special forms that are implemented in Java and not in Clojure itself. The <code class="literal">quote</code> form is used to handle variable names, or <span class="emphasis"><em>symbols</em></span>, as values. In a nutshell, using<a class="indexterm" id="id00265"/> the <code class="literal">quote</code> form, we can treat a given expression as a list of symbols and values. After all, <span class="emphasis"><em>Code is Data</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0056"/>Note</h3><p>An apostrophe (<code class="literal">'</code>) represents a quoted expression only when it appears as the first character in the expression. For example, <code class="literal">x'</code> is just a variable name.</p></div></div><p>A syntax quote, written as a backtick character (<code class="literal">`</code>), will quote an expression and allows <span class="emphasis"><em>unquoting</em></span> to be performed within it. This construct allows us to create expressions just like quoting, but also has the added benefit of letting us interpolate values and execute arbitrary code in a quoted form. This has the effect of treating a predefined expression as a template with some parts left blank to be filled in later. An expression within a syntax quoted form can be unquoted using the tidal character (<code class="literal">~</code>). Unquoting an expression will evaluate it and insert the result into the surrounding syntax quoted form. A <span class="emphasis"><em>splicing unquote</em></span>, written as <code class="literal">~@</code>, can be used to evaluate an expression that returns a list and use the returned list of values as arguments for a form. This is something like what the <code class="literal">apply</code> form does, except that it's within the context of a syntax quote. We must note that both of these unquoting<a class="indexterm" id="id00266"/> operations (<code class="literal">~</code> and <code class="literal">~@</code>) can only be used within a syntax quoted form. We can try out these operations in the REPL, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def a 1)</strong></span>
#'user/a
<span class="strong"><strong>user&gt; `(list ~a 2 3)</strong></span>
(clojure.core/list 1 2 3)
<span class="strong"><strong>user&gt; `(list ~@[1 2 3])</strong></span>
(clojure.core/list 1 2 3)</pre></div><p>As shown here, unquoting the variable <code class="literal">a</code> in the preceding syntax quoted <code class="literal">list</code> form returns the expression <code class="literal">(list 1 2 3)</code>. Similarly, using a splicing unquote with the vector <code class="literal">[1 2 3]</code> returns the same list. On the other hand, unquoting a variable in a quoted form will expand the unquote reader macro (<code class="literal">~</code>) to a <code class="literal">clojure.core/unquote</code> form, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def a 1)</strong></span>
#'user/a
<span class="strong"><strong>user&gt; `(list ~a 2 3)</strong></span>
(clojure.core/list 1 2 3)
<span class="strong"><strong>user&gt; '(list ~a 2 3)</strong></span>
(list (clojure.core/unquote a) 2 3)</pre></div><p>A more interesting difference between using a quote and a syntax quote is that the latter will resolve all variable names to namespace-qualified names. This applies to function names as well. For example, let's look at the following expressions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; `(vector x y z)</strong></span>
(clojure.core/vector user/x user/y user/z)
<span class="strong"><strong>user&gt; `(vector ~'x ~'y ~'z)</strong></span>
(clojure.core/vector x y z)</pre></div><p>As shown in the<a class="indexterm" id="id00267"/> preceding output, the variables <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> are resolved to <code class="literal">user/x</code>, <code class="literal">user/y</code>, and <code class="literal">user/z</code> respectively by the syntax quoted form, since <code class="literal">user</code> is the current namespace. Also, the <code class="literal">vector</code> function is translated to its namespace-qualified name, shown <a class="indexterm" id="id00268"/>as <code class="literal">clojure.core/vector</code>. The unquote and quote operations in succession, shown as <code class="literal">~'</code>, can be used to bypass the resolution of a symbol to a namespace-qualified name.</p><p>Quoting is supported on data structures other than lists, such as vectors, sets, and maps, as well. The effect of a syntax quote is the same on all of the data structures; it allows expressions to be unquoted within it, thus transforming the quoted form. Also, quoted forms can be nested, as in a quoted forms can contain other quoted forms. In such a case, the deepest quoted form is processed first. Consider the following quoted vectors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; `[1 :b ~(+ 1 2)]</strong></span>
[1 :b 3]
<span class="strong"><strong>user&gt; `[1 :b '~(+ 1 2)]</strong></span>
[1 :b (quote 3)]
<span class="strong"><strong>user&gt; `[1 ~'b ~(+ 1 2)]</strong></span>
[1 b 3]</pre></div><p>There are a lot of interesting aspects that can be inferred from the preceding output. Firstly, keywords are apparently not interned to namespace-qualified names such as symbols. In fact, this behavior is exhibited by any value that evaluates to itself, such as keywords, <code class="literal">nil</code>, <code class="literal">true</code>, and <code class="literal">false</code>, when used in a syntax quoted form. Other than that, unquoting followed by quoting an expression in a syntax quote, shown as <code class="literal">'~(+ 1 2)</code>, will evaluate the expression and wrap it in a quote. Conversely, unquoting a quoted symbol, shown as <code class="literal">~'b</code>, will prevent it from being resolved to a namespace-qualified name as we mentioned earlier. Let's take a look at another example that uses nested quoting, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def ops ['first 'second])</strong></span>
#'user/ops
<span class="strong"><strong>user&gt; `{:a (~(nth ops 0) ~'xs)</strong></span>
<span class="strong"><strong>        :b (~(nth ops 1) ~'xs)}</strong></span>
{:b (second xs),
 :a (first xs)}</pre></div><p>In the preceding output, the variables <code class="literal">first</code>, <code class="literal">second</code>, and <code class="literal">xs</code> are prevented from being interned to a namespace-qualified names using the quote (<code class="literal">'</code>) and unquote (<code class="literal">~</code>) operations in tandem. Anyone who's used older Lisps is probably cringing at this point. In practice, usage of the <code class="literal">~'</code> operation<a class="indexterm" id="id00269"/> should actually be avoided. This is because preventing the resolution of a variable to<a class="indexterm" id="id00270"/> a namespace-qualified name isn't really a good idea. In fact, unlike Clojure, some Lisps completely disallow it. It causes a peculiar problem called <span class="emphasis"><em>symbol capture</em></span>, which we will see ahead while we explore macros.</p></div>
<div class="section" title="Transforming code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec0030"/>Transforming code</h1></div></div></div><p>As previously <a class="indexterm" id="id00271"/>described in this chapter, it's trivial to read and evaluate code in Clojure using the <code class="literal">read</code> and <code class="literal">eval</code> functions and their variants. Instead of evaluating code right after it is parsed, we can use macros to first transform code programmatically using quoting and unquoting, and then evaluate it. Thus, macros help us define our own constructs that rewrite and transform expressions passed to them. In this section, we will explore the basics of creating and using macros.</p><div class="section" title="Expanding macros"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec0013"/>Expanding macros</h2></div></div></div><p>Macros need to be <span class="emphasis"><em>expanded</em></span> when they are called. All Clojure code is read, macroexpanded, and evaluated by the reader as we described earlier. Let's now take a look at how<a class="indexterm" id="id00272"/> macroexpansion is performed. As you may have guessed already, this is done using plain Clojure functions. </p><p>Interestingly, the reader of the Clojure runtime also uses these functions to process a program's source code. As an example, we will examine how the <code class="literal">-&gt;</code> threading macro is macroexpanded. The <code class="literal">-&gt;</code> macro can be used as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt; [0 1 2] first inc)</strong></span>
1
<span class="strong"><strong>user&gt; (-&gt; [0 1 2] (-&gt; first inc))</strong></span>
1
<span class="strong"><strong>user&gt; (-&gt; (-&gt; [0 1 2] first) inc)</strong></span>
1</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0057"/>Note</h3><p>These examples can be found in <code class="literal">src/m_clj/c4/macroexpand.clj</code> of the book's source code.</p></div></div><p>All of the three expressions using the <code class="literal">-&gt;</code> macro in the preceding output will be evaluated to the value <code class="literal">1</code>. This is due to the fact that they are all macroexpanded to produce the same final expression. How can we claim that? Well, we can prove it using the <code class="literal">macroexpand-1</code>, <code class="literal">macroexpand</code>, and <code class="literal">clojure.walk/macroexpand-all</code> functions. The <code class="literal">macroexpand</code> function returns the complete macroexpansion of a form, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (macroexpand '(-&gt; [0 1 2] first inc))</strong></span>
(inc (first [0 1 2]))</pre></div><p>The expression using the <code class="literal">-&gt;</code> threading macro is thus transformed to the expression <code class="literal">(inc (first [0 1 2]))</code>, which evaluates to the value <code class="literal">1</code>. In this way, the <code class="literal">macroexpand</code> function allows us to inspect the macroexpanded form of an expression.</p><p>The <code class="literal">macroexpand-1</code> function returns the first expansion of a macro. In fact, the <code class="literal">macroexpand</code> function <a class="indexterm" id="id00273"/>simply applies the <code class="literal">macroexpand-1</code> function repeatedly until no more macroexpansion can be performed. We can inspect how the expression <code class="literal">(-&gt; [0 1 2] (-&gt; first inc))</code> is macroexpanded using these functions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (macroexpand-1 '(-&gt; [0 1 2] (-&gt; first inc)))</strong></span>
(-&gt; [0 1 2] first inc)
<span class="strong"><strong>user&gt; (macroexpand '(-&gt; [0 1 2] (-&gt; first inc)))</strong></span>
(inc (first [0 1 2]))</pre></div><p>The <code class="literal">macroexpand</code> function has a small limitation. It only repeatedly macroexpands an expression until the first form in the expression is a macro. Hence, the <code class="literal">macroexpand</code> function will not completely macroexpand the expression <code class="literal">(-&gt; (-&gt; [0 1 2] first) inc)</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (macroexpand-1 '(-&gt; (-&gt; [0 1 2] first) inc))</strong></span>
(inc (-&gt; [0 1 2] first))
<span class="strong"><strong>user&gt; (macroexpand '(-&gt; (-&gt; [0 1 2] first) inc))</strong></span>
(inc (-&gt; [0 1 2] first))</pre></div><p>As shown in the preceding example, the <code class="literal">macroexpand</code> function will return the same macroexpansion as <code class="literal">macroexpand-1</code>. This is because the second call to the <code class="literal">-&gt;</code> macro is not the first form in the result of the first macroexpansion for the previous expression. In such cases, we can use the <code class="literal">macroexpand-all</code> function from the <code class="literal">clojure.walk</code> namespace to macroexpand a given expression regardless of the positions of macro calls in it, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (clojure.walk/macroexpand-all '(-&gt; (-&gt; [0 1 2] first) inc))</strong></span>
(inc (first [0 1 2]))</pre></div><p>Thus, all three expressions using the <code class="literal">-&gt;</code> macro as examples are macroexpanded to the same expression <code class="literal">(inc (first [0 1 2]))</code>, which is evaluated to the value <code class="literal">1</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0058"/>Note</h3><p>The <code class="literal">macroexpand-1</code>, <code class="literal">macroexpand</code>, and <code class="literal">clojure.walk/macroexpand-all</code> functions will have no effect on an expression that does not contain any macros.</p></div></div><p>The <code class="literal">macroexpand-1</code> and <code class="literal">macroexpand</code> functions are indispensable tools for debugging user-defined macros. Additionally, the <code class="literal">clojure.walk/macroexpand-all</code> function can be used in situations <a class="indexterm" id="id00274"/>where the <code class="literal">macroexpand</code> function does not completely macroexpand a given expression. The Clojure reader also uses these functions for macroexpanding a program's source code.</p></div><div class="section" title="Creating macros"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec0014"/>Creating macros</h2></div></div></div><p>Macros are<a class="indexterm" id="id00275"/> defined using the <code class="literal">defmacro</code> form. A macro name, a vector of arguments for the macro, an optional doc-string, and the body of the macro have to be passed to this form. We can also specify multiple arities for a macro. Its similarity to the <code class="literal">defn</code> form is quite obvious. Unlike a <code class="literal">defn</code> form, however, a macro defined using the <code class="literal">defmacro</code> form will not evaluate the arguments passed to it. In other words, the arguments passed to a macro are implicitly quoted. For example, we can create a couple of macros to rewrite an s-expression in infix and postfix notation, as shown in <span class="emphasis"><em>Example 4.1</em></span>.</p><div class="informalexample"><pre class="programlisting">(defmacro to-infix [expr]
  (interpose (first expr) (rest expr)))

(defmacro to-postfix [expr]
  (concat (rest expr) [(first expr)]))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 4.1: Macros to transform a prefix expression</em></span></p></blockquote></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0059"/>Note</h3><p>These examples can be found in <code class="literal">src/m_clj/c4/defmacro.clj</code> of the book's source code.</p></div></div><p>Each of the macros in <span class="emphasis"><em>Example 4.1</em></span> describes an elegant way to rewrite an expression <code class="literal">expr</code> by treating it as a generic sequence. The function being called in the expression <code class="literal">expr</code> is extracted using the <code class="literal">first</code> form, and its arguments are obtained using the <code class="literal">rest</code> form. To convert the expression to its infix form, we use the <code class="literal">interpose</code> function. Similarly, the <code class="literal">postfix</code> form of the expression <code class="literal">expr</code> is generated using the <code class="literal">concat</code> form. We can use the <code class="literal">macroexpand</code> function to inspect the expression generated by the <code class="literal">to-infix</code> and <code class="literal">to-postfix</code> macros, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (macroexpand '(to-infix (+ 0 1 2)))</strong></span>
(0 + 1 + 2)
<span class="strong"><strong>user&gt; (macroexpand '(to-postfix (+ 0 1 2)))</strong></span>
(0 1 2 +)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0060"/>Note</h3><p>The expression <code class="literal">x + y</code> is said to be<a class="indexterm" id="id00276"/> written in an <span class="emphasis"><em>infix</em></span> notation. The <span class="emphasis"><em>prefix</em></span> notation of this <a class="indexterm" id="id00277"/>expression is <code class="literal">+ x y</code>, and its <span class="emphasis"><em>postfix</em></span> notation is <code class="literal">x y +</code>.</p></div></div><p>In this way, by transforming expressions we can effectively modify the language. It's that simple! The basis of the <code class="literal">to-infix</code> and <code class="literal">to-postfix</code> macros in <span class="emphasis"><em>Example 4.1</em></span> are that we can treat the terms of an expression as a sequence of elements and manipulate them by using sequence functions such as <code class="literal">interpose</code> and <code class="literal">concat</code>. Of course, the preceding example was simple enough such that we could avoid the use of quoting altogether. The <code class="literal">defmacro</code> form<a class="indexterm" id="id00278"/> can also be used in combination with quoting to easily rewrite more complex expressions. The same rule can be applied to <span class="emphasis"><em>any</em></span> form of Clojure code.</p><p>Interestingly, macros are internally represented as functions, and this can be verified by dereferencing the fully qualified name of a macro and using the <code class="literal">fn?</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (fn? @#'to-infix)</strong></span>
true
<span class="strong"><strong>user&gt; (fn? @#'to-postfix)</strong></span>
true</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0061"/>Note</h3><p>At the time of writing this book, ClojureScript only supports macros written in Clojure. Macros have to be referenced using the <code class="literal">:require-macros</code> keyword in a ClojureScript namespace declaration, as shown here:</p><div class="informalexample"><pre class="programlisting">(ns my-cljs-namespace
  (:require-macros [my-clj-macro-namespace :as macro]))</pre></div></div></div><p>The <code class="literal">symbol</code> and <code class="literal">gensym</code> functions can be used to create temporary variables for use within the body of a macro. The <code class="literal">symbol</code> function returns a symbol from a name and an optional namespace, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (symbol 'x)</strong></span>
x
<span class="strong"><strong>user&gt; (symbol "x")</strong></span>
x
<span class="strong"><strong>user&gt; (symbol "my-namespace" "x")</strong></span>
my-namespace/x</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0062"/>Note</h3><p>We can check whether a value is a symbol using the <code class="literal">symbol?</code> predicate.</p></div></div><p>The <code class="literal">gensym</code> function can be used to create a unique symbol name. We can specify a prefix to be used for the returned symbol name to the <code class="literal">gensym</code> function. The prefix is defaulted to a capital <code class="literal">G</code> character followed by two underscores (<code class="literal">G__</code>). The <code class="literal">gensym</code> function can also be<a class="indexterm" id="id00279"/> used to create a new unique keyword. We can try out the <code class="literal">gensym</code> function in the REPL, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (gensym)</strong></span>
G__8090
<span class="strong"><strong>user&gt; (gensym 'x)</strong></span>
x8081
<span class="strong"><strong>user&gt; (gensym "x")</strong></span>
x8084
<span class="strong"><strong>user&gt; (gensym :x)</strong></span>
:x8087</pre></div><p>As shown here, the <code class="literal">gensym</code> function creates a new symbol every time it is called. In a syntax quoted form, we can use an automatic symbol name created from a prefixed name and the <code class="literal">gensym</code> function by using the hash character (<code class="literal">#</code>), shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; `(let [x# 10] x#)</strong></span>
(clojure.core/let [x__8561__auto__ 10]
  x__8561__auto__)
<span class="strong"><strong>user&gt; (macroexpand `(let [x# 10] x#))</strong></span>
(let* [x__8910__auto__ 10]
  x__8910__auto__)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0063"/>Note</h3><p>The <code class="literal">let</code> form is, in fact, a macro defined using the <code class="literal">let*</code> special form.</p></div></div><p>As shown in the preceding expression, all <a class="indexterm" id="id00280"/>occurrences of the <span class="emphasis"><em>auto-gensym</em></span> variable <code class="literal">x#</code> in the syntax quoted form are replaced with an automatically generated symbol name. We should note that only symbols, and not strings or keywords, can be used as a prefix for an auto-gensym symbol.</p><p>By generating unique symbols in this way, we <a class="indexterm" id="id00281"/>can create <span class="emphasis"><em>hygenic macros</em></span>, which avoid<a class="indexterm" id="id00282"/> the possibility of <span class="emphasis"><em>symbol capture</em></span> or <span class="emphasis"><em>variable capture</em></span>, which is <a class="indexterm" id="id00283"/>an interesting problem that arises with the use of dynamically scoped variables and macros. To illustrate this problem, consider the macros defined in <span class="emphasis"><em>Example 4.2</em></span>:</p><div class="informalexample"><pre class="programlisting">(defmacro to-list [x]
  `(list ~x))

(defmacro to-list-with-capture [x]
  `(list ~'x))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 4.2: Macros to depict symbol capture</em></span></p></blockquote></div><p>The macros in <span class="emphasis"><em>Example 4.2</em></span> create a new list using a <code class="literal">list</code> form and the value <code class="literal">x</code>. Of course, we wouldn't really need to use a macro here, but it is only done for the sake of demonstrating symbol capture. The <code class="literal">to-list-with-capture</code> macro <span class="emphasis"><em>captures</em></span> the variable <code class="literal">x</code> from the surrounding scope by the use of the <code class="literal">~'</code> operation. If we use a <code class="literal">let</code> form to bind the variable name <code class="literal">x</code> with a value, we will get different results on calling the <code class="literal">to-list</code> and <code class="literal">to-list-with-capture</code> macros, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (let [x 10]</strong></span>
<span class="strong"><strong>        (to-list 20))</strong></span>
(20)
<span class="strong"><strong>user&gt; (let [x 10]</strong></span>
<span class="strong"><strong>        (to-list-with-capture 20))</strong></span>
(10)</pre></div><p>The <code class="literal">to-list-with-capture</code> function seems to dynamically obtain the value of <code class="literal">x</code> from the surrounding scope, and not from the parameter passed to it. As you may have guessed, this can lead to a number of subtle and bizarre bugs. In Clojure, the solution to this problem is <a class="indexterm" id="id00284"/>simple; a syntax quoted form will resolve all free symbols to namespace-qualified names. This can be verified by macroexpanding the expression that uses the <code class="literal">to-list</code> function in the preceding example.</p><p>Let's say we would like to use a temporary variable using a <code class="literal">let</code> form with a macro that performs the same task as the <code class="literal">to-list</code> macro from <span class="emphasis"><em>Example 4.2</em></span>. This may seem rather unnecessary, but it is only being done to demonstrate how symbols are resolved by a syntax quote. Such a macro can be implemented as shown in <span class="emphasis"><em>Example 4.3</em></span>:</p><div class="informalexample"><pre class="programlisting">(defmacro to-list-with-error [x]
  `(let [y ~x]
     (list y)))</pre></div><p>Calling the <code class="literal">to-list-with-error</code> macro will result in an error due to the use of the free symbol <code class="literal">y</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (to-list-with-error 10)</strong></span>
CompilerException java.lang.RuntimeException:
Can't let qualified name: user/y</pre></div><p>This error can be quite annoying, as we simply intended to use a temporary variable in the body of the <code class="literal">to-list-with-error</code> macro. This error occurred because it is not clear where the variable <code class="literal">y</code> is resolved from. To get around this error, we can declare the variable <code class="literal">y</code> as an auto-gensym variable, as shown in <span class="emphasis"><em>Example 4.4</em></span>:</p><div class="informalexample"><pre class="programlisting">(defmacro to-list-with-gensym [x]
  `(let [y# ~x]
     (list y#)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 4.4: A macro that uses a let form and an auto-gensym variable</em></span></p></blockquote></div><p>The <code class="literal">to-list-with-gensym</code> macro works as expected without any error, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (to-list-with-gensym 10)</strong></span>
(10)</pre></div><p>We can also inspect the expression generated by the <code class="literal">to-list-with-gensym</code> macro using the <code class="literal">macroexpand</code> and <code class="literal">macroexpand-1</code> forms, and the reader is encouraged to try this in the REPL.</p><p>To summarize, macros<a class="indexterm" id="id00285"/> defined using the <code class="literal">defmacro</code> form can be used to rewrite and transform code. Syntax quote and auto-gensym variables can be used to write hygenic macros that avoid certain problems that can arise due the use of dynamic scope.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0064"/>Note</h3><p>Syntax quote can actually be implemented as a user defined macro. Libraries such as<a class="indexterm" id="id00286"/> <code class="literal">syntax-quote</code> (<a class="ulink" href="https://github.com/hiredman/syntax-quote">https://github.com/hiredman/syntax-quote</a>) and<a class="indexterm" id="id00287"/> <code class="literal">backtick</code> (<a class="ulink" href="https://github.com/brandonbloom/backtick">https://github.com/brandonbloom/backtick</a>) demonstrate how syntax quote can be implemented through macros.</p></div></div></div><div class="section" title="Encapsulating patterns in macros"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec0015"/>Encapsulating patterns in macros</h2></div></div></div><p>In Clojure, macros<a class="indexterm" id="id00288"/> can be used to rewrite expressions in terms of functions and special forms. However, in languages such as Java and C#, there is a lot of additional syntax added to the language for handling special forms. For example, consider the <code class="literal">if</code> construct in these languages, which is used to check whether an expression is true or not. This construct does have some special syntax. If a recurring pattern of usage of the <code class="literal">if</code> construct is found in a program written in these languages, there is no obvious way to automate this pattern. Languages such as Java and C# have the concept of <a class="indexterm" id="id00289"/>
<span class="emphasis"><em>design patterns</em></span> that encapsulate these sort of patterns. But without the ability to rewrite expressions, encapsulating patterns in these languages can get a bit incomplete and cumbersome. The more special forms and syntax we add to a language, the harder it gets to programmatically generate code for the language. On the other hand, macros in Clojure and other Lisps can easily rewrite expressions to automate recurring patterns in code. Also, there is more-or-less no special syntax for code in Lisps, as code and data are one and the same. In a way, macros in Lispy languages allow us to concisely encapsulate design patterns by extending the language with our own hand-made constructs.</p><p>Let's explore a few examples that demonstrate how macros can be used to encapsulate patterns. The <code class="literal">-&gt;</code> and <code class="literal">-&gt;&gt;</code> threading macros in Clojure are used to compose several functions together by passing in an initial value. In other words, the initial value is <span class="emphasis"><em>threaded</em></span> through the various forms that are passed as arguments to the <code class="literal">-&gt;</code> and <code class="literal">-&gt;&gt;</code> macros. These macros are defined in the <code class="literal">clojure.core</code> namespace as part of the Clojure language, as shown in <span class="emphasis"><em>Example 4.5</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0065"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c4/threading.clj</code> of the book's source code.</p></div></div><div class="informalexample"><pre class="programlisting">(defmacro -&gt; [x &amp; forms]
  (loop [x x
         forms forms]
    (if forms
      (let [form (first forms)
            threaded (if (seq? form)
                       (with-meta
                         `(~(first form) ~x ~@(next form))
                         (meta form))
                       (list form x))]
        (recur threaded (next forms)))
      x)))

(defmacro -&gt;&gt; [x &amp; forms]
  (loop [x x
         forms forms]
    (if forms
      (let [form (first forms)
            threaded (if (seq? form)
                       (with-meta
                         `(~(first form) ~@(next form) ~x)
                         (meta form))
                       (list form x))]
        (recur threaded (next forms)))
      x)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 4.5: The -&gt; and -&gt;&gt; threading macros</em></span></p></blockquote></div><p>The <code class="literal">-&gt;</code> and <code class="literal">-&gt;&gt;</code> macros in <span class="emphasis"><em>Example 4.5</em></span> use a <code class="literal">loop</code> form to recursively thread a value <code class="literal">x</code> through the<a class="indexterm" id="id00290"/> expressions represented by <code class="literal">forms</code>. The first symbol in a form, that is the function being called, is determined using the <code class="literal">first</code> function. The arguments to be passed in this function, other than <code class="literal">x</code>, are extracted using the <code class="literal">next</code> function. If a form is just a function name without any additional arguments, we create a new form using the expression <code class="literal">(list form x)</code>. The <code class="literal">with-meta</code> form is used to preserve any metadata specified with <code class="literal">form</code>. The <code class="literal">-&gt;</code> macro passes <code class="literal">x</code> as the first argument, whereas <code class="literal">-&gt;&gt;</code> passes <code class="literal">x</code> as the last argument. This is done in a recursive manner for all the forms passed to these macros. Interestingly, syntax quoted forms are used sparingly by both of the <code class="literal">-&gt;</code> and <code class="literal">-&gt;&gt;</code> macros. We can actually refactor out some parts of these macros into functions. This adds a slight advantage as functions can be tested quite easily compared to macros. The <code class="literal">-&gt;</code> and <code class="literal">-&gt;&gt;</code> threading macros can be refactored as shown in <span class="emphasis"><em>Example 4.6</em></span> and<span class="emphasis"><em> Example 4.7</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn thread-form [first? x form]
  (if (seq? form)
    (let [[f &amp; xs] form
          xs (conj (if first? xs (vec xs)) x)]
      (apply list f xs))
    (list form x)))

(defn threading [first? x forms]
  (reduce #(thread-form first? %1 %2)
          x forms))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 4.6: Refactoring the -&gt; and -&gt;&gt; threading macros</em></span></p></blockquote></div><p>The <code class="literal">thread-form</code> function in <span class="emphasis"><em>Example 4.6</em></span> positions the value <code class="literal">x</code> in the expression form using the <code class="literal">conj</code> function. The premise here is that the <code class="literal">conj</code> function will add an element in the head of a list <a class="indexterm" id="id00291"/>and at the end or tail of a vector. The <code class="literal">first?</code> argument is used to indicate whether the value <code class="literal">x</code> has to be passed as the first argument to <code class="literal">form</code>. The <code class="literal">threading</code> function simply applies the <code class="literal">thread-form</code> function to all the expressions passed to it, represented by <code class="literal">forms</code>. The macros <code class="literal">-&gt;</code> and <code class="literal">-&gt;&gt;</code> can now be implemented using the <code class="literal">threading</code> function as shown in <span class="emphasis"><em>Example 4.7</em></span>:</p><div class="informalexample"><pre class="programlisting">(defmacro -&gt; [x &amp; forms]
  (threading true x forms))

(defmacro -&gt;&gt; [x &amp; forms]
  (threading false x forms))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 4.7: Refactoring the -&gt; and -&gt;&gt; threading macros (continued)</em></span></p></blockquote></div><p>The threading macros defined in <span class="emphasis"><em>Example 4.7</em></span> work just as well as the ones in <span class="emphasis"><em>Example 4.5</em></span>, and we can verify this in the REPL. This is left as an exercise for the reader.</p><p>A common pattern of usage of the <code class="literal">let</code> form is to repeatedly rebind a variable to new values by passing it through several functions. This kind of pattern can be encapsulated using the <code class="literal">as-&gt;</code> threading macro, which is defined as shown in <span class="emphasis"><em>Example 4.8</em></span>.</p><div class="informalexample"><pre class="programlisting">(defmacro as-&gt; [expr name &amp; forms]
  `(let [~name ~expr
         ~@(interleave (repeat name) forms)]
     ~name))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 4.8: Refactoring the -&gt; and -&gt;&gt; threading macros</em></span></p></blockquote></div><p>Let's skip past explaining the details of the <code class="literal">as-&gt;</code> macro through words and simply describe the code it generates using the <code class="literal">macroexpand</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (macroexpand '(as-&gt; 1 x (+ 1 x) (+ x 1)))</strong></span>
(let* [x 1
       x (+ 1 x)
       x (+ x 1)]
      x)
<span class="strong"><strong>user&gt; (as-&gt; 1 x (+ 1 x) (+ x 1))</strong></span>
3</pre></div><p>The <code class="literal">as-&gt;</code> macro binds its first argument to a symbol represented by its second argument and generates a <code class="literal">let*</code> form as a result. This allows us to define expressions that have to be threaded over in<a class="indexterm" id="id00292"/> terms of an explicit symbol. One might even say it's a more flexible way to perform the threading of a value through several expressions, as compared to using the <code class="literal">-&gt;</code> and <code class="literal">-&gt;&gt;</code> macros.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0066"/>Note</h3><p>The <code class="literal">as-&gt;</code> form has been introduced in Clojure 1.5 along with several other threading macros.</p></div></div><p>Thus, macros are great tools in automating or encapsulating patterns in code. Several commonly used forms in the Clojure language are actually defined as macros, and we can just as easily define our own macros.</p></div><div class="section" title="Using reader conditionals"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec0016"/>Using reader conditionals</h2></div></div></div><p>It is often necessary to<a class="indexterm" id="id00293"/> interoperate with native objects in Clojure and its dialects such as ClojureScript. We can define platform-specific code using <span class="emphasis"><em>reader conditionals</em></span>. Let's now briefly take a look at how we can use reader conditionals.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0067"/>Note</h3><p>Reader conditionals have been introduced in Clojure 1.7. Prior to version 1.7, platform-specific<a class="indexterm" id="id00294"/> Clojure/ClojureScript code had to be managed using the <code class="literal">cljx</code> library (<a class="ulink" href="https://github.com/lynaghk/cljx">https://github.com/lynaghk/cljx</a>).</p></div></div><p>The <a class="indexterm" id="id00295"/>
<span class="emphasis"><em>reader conditional form</em></span>, written as <code class="literal">#?( ... )</code>, allows us to define platform-specific code using the <code class="literal">:cljs</code>, <code class="literal">:clj</code>, <code class="literal">:clr</code>, and <code class="literal">:default</code> keywords. The<a class="indexterm" id="id00296"/> <span class="emphasis"><em>reader conditional splicing form</em></span>, written as <code class="literal">#?@( ... )</code>, has semantics similar to a reader conditional form. It can be used to splice a list of platform-specific values or expressions into a form. Both these conditional forms are processed when code is read, instead of when it is macroexpanded.</p><p>Since Clojure 1.7, the <code class="literal">read-string</code> function has a second arity in which we can specify a map as an argument. This map can have two keys, <code class="literal">:read-cond</code> and <code class="literal">:features</code>. When a string containing a conditional form is passed to the <code class="literal">read-string</code> function, platform-specific code can be generated by specifying the platform as a set of keywords, represented by <code class="literal">:cljs</code>, <code class="literal">:clj</code>, or <code class="literal">:clr</code>, with the <code class="literal">:features</code> key in the map of options. In this case, the keyword <code class="literal">:allow</code> must be specified for the key <code class="literal">:read-cond</code> in the map passed to the <code class="literal">read-string</code> function, or else an exception will be thrown. We can try out the reader conditional form with the <code class="literal">read-string</code> function in the REPL as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (read-string {:read-cond :allow :features #{:clj}}</strong></span>
<span class="strong"><strong>                   "#?(:cljs \"ClojureScript\" :clj \"Clojure\")")</strong></span>
"Clojure"
<span class="strong"><strong>user&gt; (read-string {:read-cond :allow :features #{:cljs}}</strong></span>
<span class="strong"><strong>                   "#?(:cljs \"ClojureScript\" :clj \"Clojure\")")</strong></span>
"ClojureScript"</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0068"/>Note</h3><p>These examples can be found in <code class="literal">src/m_clj/c4/reader_conditionals.cljc</code> of the book's source code.</p></div></div><p>Similarly, we <a class="indexterm" id="id00297"/>can read a conditional splicing form into an expression with the <code class="literal">read-string</code> function as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (read-string {:read-cond :allow :features #{:clr}}</strong></span>
<span class="strong"><strong>                   "[1 2 #?@(:cljs [3 4] :default [5 6])]")</strong></span>
[1 2 5 6]
<span class="strong"><strong>user&gt; (read-string {:read-cond :allow :features #{:clj}}</strong></span>
<span class="strong"><strong>                   "[1 2 #?@(:cljs [3 4] :default [5 6])]")</strong></span>
[1 2 5 6]
<span class="strong"><strong>user&gt; (read-string {:read-cond :allow :features #{:cljs}}</strong></span>
<span class="strong"><strong>                   "[1 2 #?@(:cljs [3 4] :default [5 6])]")</strong></span>
[1 2 3 4]</pre></div><p>We can also prevent the transformation of conditional forms by specifying the <code class="literal">:preserve</code> keyword with the <code class="literal">:read-cond</code> key in the optional map passed to the <code class="literal">read-string</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (read-string {:read-cond :preserve}</strong></span>
<span class="strong"><strong>                   "[1 2 #?@(:cljs [3 4] :clj [5 6])]")</strong></span>
[1 2 #?@(:cljs [3 4] :clj [5 6])]</pre></div><p>However, wrapping conditional forms in a string is not really something we should be doing in practice. Generally, we should write all platform-specific code as reader conditional forms in source files with the <code class="literal">.cljc</code> extension. Once the top-level forms defined in the <code class="literal">.cljc</code> file are processed by the Clojure reader, we can use them just like any other reader forms. For example, consider the macro written using a reader conditional form in <span class="emphasis"><em>Example 4.9</em></span>:</p><div class="informalexample"><pre class="programlisting">(defmacro get-milliseconds-since-epoch []
  `(.getTime #?(:cljs (js/Date.)
                :clj (java.util.Date.))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 4.9: A macro using a reader conditional</em></span></p></blockquote></div><p>The <code class="literal">get-milliseconds-since-epoch</code> macro in <span class="emphasis"><em>Example 4.9</em></span> calls the <code class="literal">.getTime</code> method on a new <code class="literal">java.util.Date</code> instance when called from the Clojure code. Also, this macro calls the <code class="literal">.getTime</code> method on a new JavaScript <code class="literal">Date</code> object when used in ClojureScript code. We can macroexpand a call to the <code class="literal">get-milliseconds-since-epoch</code> macro from the Clojure REPL to generate JVM-specific code, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (macroexpand '(get-milliseconds-since-epoch))</strong></span>
(. (java.util.Date.) getTime)</pre></div><p>Thus, reader <a class="indexterm" id="id00298"/>conditionals help in encapsulating platform-specific code to be used in code that is agnostic of the underlying platform.</p></div><div class="section" title="Avoiding macros"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec0017"/>Avoiding macros</h2></div></div></div><p>Macros are an extremely<a class="indexterm" id="id00299"/> flexible way of defining our own constructs in Clojure. However, careless use of macros in a program can become complicated and lead to a number of strange bugs that are hidden from plain sight. As described in the book, <span class="emphasis"><em>Programming Clojure</em></span> by <span class="emphasis"><em>Stuart Halloway</em></span> and <span class="emphasis"><em>Aaron Bedra</em></span>, the usage of macros in Clojure has two thumb rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Don't write macros</strong></span>: Anytime <a class="indexterm" id="id00300"/>we try to use a macro, we must think twice whether we could perform the same task using a function.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Write macros if it's the only way to encapsulate a pattern</strong></span>: A macro must be used only if it is easier or more convenient than calling a function.</li></ul></div><p>What's the problem with macros? Well, macros<a class="indexterm" id="id00301"/> complicate a program's code in several ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Macros cannot be composed like functions as they are not really values. It's not possible to pass a macro as an argument to the <code class="literal">map</code> or <code class="literal">apply</code> forms, for example.</li><li class="listitem" style="list-style-type: disc">Macros cannot be tested as easily as functions. Though it can be done programmatically, the only way to test macros is by using macroexpansion functions and quoting.</li><li class="listitem" style="list-style-type: disc">In some cases, code that calls a macro may have been written as a macro itself, thus adding more complexity to our code.</li><li class="listitem" style="list-style-type: disc">Hidden bugs caused by problems such as symbol capture make macros a little tricky. Debugging<a class="indexterm" id="id00302"/> macros isn't really easy either, especially in a large codebase.</li></ul></div><p>For these reasons, macros have to be used carefully and responsibly. In fact, if we can solve a problem using macros as well functions, we should always prefer the solution that uses functions. If the use of a macro is indeed required, we should always strive to refactor out as much code as possible from a macro into a function.</p><p>That aside, macros make programming a lot of fun as they allow us to define our own constructs. They allow a degree of freedom and liberty that is not really possible in other languages. You may hear a lot of seasoned Clojure programmers tell you that macros are evil and you should never use them, but don't let that stop you from exploring what is possible with macros. Once you encounter and tackle some of the problems that arise with the use of<a class="indexterm" id="id00303"/> macros, you will have enough experience to be able to decide when macros can be used appropriately.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec0033"/>Summary</h1></div></div></div><p>We have explored how metaprogramming is possible with Clojure in this chapter. We discussed how code is read, macroexpanded, and evaluated, as well as the various primitive constructs that implement these operations. Macros can be used to encapsulate patterns in code, as we demonstrated in the various examples in this chapter. Toward the end of the chapter, we also talked about reader conditionals and pointed out the various complications that arise with the use of macros.</p><p>In the following chapter, we will explore how transducers can be used to process any data regardless of the source of the data.</p></div>
<div class="chapter" title="Chapter&#xA0;5.&#xA0;Composing Transducers"><div class="titlepage"><div><div><h1 class="title"><a id="ch20"/>Chapter 5. Composing Transducers</h1></div></div></div><p>Let's get back to our journey of performing computations over data in Clojure. We've already discussed how <span class="emphasis"><em>reducers</em></span> can be used to process collections in <a class="link" href="ch18.html" title="Chapter 3. Parallelization Using Reducers">Chapter 3</a>, <span class="emphasis"><em>Parallelization Using Reducers</em></span>. Transducers are, in fact, a generalization of reducers that are independent of the source of data. Also, reducers are more about parallelization, while transducers are more focused on generalizing data transformations without restricting us to any particular source of data. Transducers capture the essence of the standard functions that operate on sequences, such as <code class="literal">map</code> and <code class="literal">filter</code>, for several sources of data. They allow us to define and compose transformations of data regardless of how the data is supplied to us.</p><p>Incidentally, in the context of physics, a transducer is a device that converts a signal from one form of energy into another form. In a way, Clojure transducers can be thought of as ways to capture the <span class="emphasis"><em>energy</em></span> in functions, such as <code class="literal">map</code> and <code class="literal">filter</code>, and convert between different sources of data. These sources include collections, streams, and asynchronous channels. Transducers can also be extended to other sources of data. In this chapter, we will focus on how transducers can be used for sequences and collections, and will reserve discussing transducers with asynchronous channels until we talk about the <code class="literal">core.async</code> library in <a class="link" href="ch23.html" title="Chapter 8. Leveraging Asynchronous Tasks">Chapter 8</a>, <span class="emphasis"><em>Leveraging Asynchronous Tasks</em></span>. Later in this chapter, we will study how transducers are implemented in Clojure.</p><div class="section" title="Understanding transducers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec0034"/>Understanding transducers</h1></div></div></div><p>Transducers are <a class="indexterm" id="id00304"/>essentially a stack of transformations that can be composed and applied to <span class="emphasis"><em>any</em></span> representation of data. They allow us to define transformations that are agnostic of implementation-specific details about the source of the supplied data. Transducers also have a significant performance benefit. This is attributed to the avoidance of unnecessary memory allocations for arbitrary containers, such as sequences or other collections, to store intermediate results between transformations.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0069"/>Note</h3><p>Transducers have been introduced in Clojure 1.7.</p></div></div><p>Transformations can be composed without the use of transducers as well. This can be done using the <code class="literal">comp</code> and <code class="literal">partial</code> forms. We can pass any number of transformations to the <code class="literal">comp</code> function, and<a class="indexterm" id="id00305"/> the transformation returned by the <code class="literal">comp</code> function will be a composition of the supplied transformations in the right-to-left order. In Clojure, a transformation is conventionally denoted as <code class="literal">xf</code> or <code class="literal">xform</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0070"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c5/transduce.clj</code> of the book's source code.</p></div></div><p>For example, the expression <code class="literal">(comp f g)</code> will return a function that applies the function <code class="literal">g</code> to its input and then applies the function <code class="literal">f</code> to the result. The <code class="literal">partial</code> function will bind a function to any number of arguments and return a new function. The <code class="literal">comp</code> function can be used with a <code class="literal">partial</code> form to compose the <code class="literal">map</code> and <code class="literal">filter</code> functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def xf-using-partial (comp</strong></span>
<span class="strong"><strong>                             (partial filter even?)</strong></span>
<span class="strong"><strong>                             (partial map inc)))</strong></span>
#'user/xf-using-partial
<span class="strong"><strong>user&gt; (xf-using-partial (vec (range 10)))</strong></span>
(2 4 6 8 10)</pre></div><p>In the preceding output, the <code class="literal">partial</code> function is used to bind the <code class="literal">inc</code> and <code class="literal">even?</code> functions to the <code class="literal">map</code> and <code class="literal">filter</code> functions respectively. The functions returned by both the <code class="literal">partial</code> forms shown above will expect a collection to be passed to them. Thus, they represent transformations that can be applied to a given collection. These two transformations are then composed with the <code class="literal">comp</code> function to create a new function <code class="literal">xf-using-partial</code>. This function is then applied to a vector of numbers to return a sequence of even numbers. There are a few issues with this code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The filtering of even numbers using the <code class="literal">even?</code> function is performed after applying the <code class="literal">inc</code> function. This proves that the transformations passed to the <code class="literal">comp</code> function are applied in the right-to-left order, which is the reverse of the order in which they are specified. This can be a little inconvenient at times.</li><li class="listitem" style="list-style-type: disc">The value returned by the <code class="literal">xf-using-partial</code> function is a list and not a vector. This is because the <code class="literal">map</code> and <code class="literal">filter</code> function both return lazy sequences, which are ultimately converted into lists. Thus, the use of the <code class="literal">vec</code> function has no effect on the type of collection returned by the <code class="literal">xf-using-partial</code> function.</li><li class="listitem" style="list-style-type: disc">Also, the transformation <code class="literal">(partial map inc)</code> applied by the <code class="literal">xf-using-partial</code> function will create a new sequence. This resulting sequence is then passed to the transformation <code class="literal">(partial filter even?)</code>. The intermediate use of a sequence is both unnecessary and wasteful in terms of memory if we have several transformations that must be composed.</li></ul></div><p>This brings us to transducers, which address the preceding problems related to composing transformations using the <code class="literal">comp</code> and <code class="literal">partial</code> forms. In the formal sense, a transducer is a function that modifies a <span class="emphasis"><em>step function</em></span>. This step function is analogous to a reducing function in the context of reducers. A step function combines an input value with the accumulated result of a given computation. A transducer accepts a step function as an argument and produces a modified version of it. In fact, the <code class="literal">xf</code> and <code class="literal">xform</code> notations are also used to represent a transducer; because a transducer is also a transformation, it transforms a step<a class="indexterm" id="id00306"/> function. While it may be hard to illustrate without any code, this modification of a step function performed by a transducer actually depicts how some input data is consumed by a given computation to produce a result. Several transducers can also be composed together. In this way, transducers can be thought of as a unified model to process data.</p><p>Several of the standard Clojure functions return a transducer when they are called with a single argument. These functions either:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accept a function along with a collection as arguments. Examples of such functions are <code class="literal">map</code>, <code class="literal">filter</code>, <code class="literal">mapcat</code>, and <code class="literal">partition-by</code>.</li><li class="listitem" style="list-style-type: disc">Accept a value indicating the number of elements, usually specified as <code class="literal">n</code>, along with a collection. This category includes functions such as <code class="literal">take</code>, <code class="literal">drop</code>, and <code class="literal">partition-all</code>.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0071"/>Note</h3><p>Visit <a class="ulink" href="http://clojure.org/transducers">http://clojure.org/transducers</a> for the<a class="indexterm" id="id00307"/> complete list of standard functions that implement transducers.</p></div></div></li></ul></div><p>The use of transducers can be aptly depicted by Rich Hickey's baggage loading example. Suppose we intend to load several bags into an airplane. The bags will be supplied in pallets, which can be thought of as collections of bags. There are several steps that have to be performed to load the bags into the airplane. Firstly, the bags must be unbundled from the supplied pallets. Next, we must check whether a bag contains any food, and not process it any further if it does. Finally, all the bags must be weighed and labeled in case they are heavy. Note that these steps needed to load the bags into the airplane do not specify how the pallets are supplied to us, or how the labeled bags from the final step are transported to the plane.</p><p>We can model the process of loading the bags into the plane as shown in the <code class="literal">process-bags</code> function in <span class="emphasis"><em>Example 5.1</em></span>, as follows:</p><div class="informalexample"><pre class="programlisting">(declare unbundle-pallet)
(declare non-food?)
(declare label-heavy)

(def process-bags
  (comp
   (partial map label-heavy)
   (partial filter non-food?)
   (partial mapcat unbundle-pallet)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.1: Loading bags into an airplane</em></span></p></blockquote></div><p>The functions <code class="literal">unbundle-pallet</code>, <code class="literal">non-food?</code>, and <code class="literal">label-heavy</code> in <span class="emphasis"><em>Example 5.1</em></span> represent the three steps of loading bags into an airplane. These functions are applied to a collection of bags using the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> functions. Also, they can be composed using the <code class="literal">comp</code> and <code class="literal">partial</code> functions in a right-to-left order. As we described earlier, the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> functions will all produce sequences on being called, hence creating intermediate collections of bags between the three transformations. This intermediate use of sequences is analogous to putting all the bags on trollies after the step is performed. The <a class="indexterm" id="id00308"/>supplied input and the final result would both be a bag of trollies. The use of trollies not only incurs additional work between the steps of our process, but the steps are now convoluted with the use of trollies. Thus, we would have to redefine these steps if we had to use, say, conveyer belts instead of trollies to transport the baggage. This means that the <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> functions would have to be implemented again if we intend to produce a different type of collection as a final result. Alternatively, we can use transducers to implement the <code class="literal">process-bags</code> function without specifying the type of collection of either the input or the result, as shown in <span class="emphasis"><em>Example 5.2</em></span>:</p><div class="informalexample"><pre class="programlisting">(def process-bags
  (comp
   (mapcat unbundle-pallet)
   (filter non-food?)
   (map label-heavy)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.2: Loading bags into an airplane using transducers</em></span></p></blockquote></div><p>The <code class="literal">process-bags</code> function in <span class="emphasis"><em>Example 5.2</em></span> shows how transducers can be used to compose the <code class="literal">unbundle-pallet</code>, <code class="literal">non-food?</code>, and <code class="literal">label-heavy</code> functions in a left-to-right order. Each of the expressions passed to the <code class="literal">comp</code> function in <span class="emphasis"><em>Example 5.2</em></span> return a transducer. This implementation of the <code class="literal">process-bags</code> function does not create any intermediary collections when it is executed.</p><div class="section" title="Producing results from transducers"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec0018"/>Producing results from transducers</h2></div></div></div><p>Transducers are<a class="indexterm" id="id00309"/> only recipes for computations, and are not capable of performing any actual work on their own. A transducer can produce results when coupled with a source of data. There's also another vital piece of the puzzle, that is, the step function. To combine a transducer, a step function, and a source of data, we must use the <code class="literal">tranduce</code> function.</p><p>The step function passed to <code class="literal">transduce</code> is also used to create the initial value of the result to be produced. This initial value of the result can also be specified as an argument to the <code class="literal">transduce</code> function. For example, the <code class="literal">transduce</code> function can be used with the <code class="literal">conj</code> form is shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def xf (map inc))</strong></span>
#'user/xf
<span class="strong"><strong>user&gt; (transduce xf conj [0 1 2])</strong></span>
[1 2 3]
<span class="strong"><strong>user&gt; (transduce xf conj () [0 1 2])</strong></span>
(3 2 1)</pre></div><p>The <code class="literal">inc</code> function is coupled with the <code class="literal">map</code> function to create a transducer <code class="literal">xf</code>, as shown previously. The <code class="literal">transduce</code> function can be used to produce either a list or a vector from the transducer <code class="literal">xf</code> using the <code class="literal">conj</code> function. The order of elements in the results of both the <code class="literal">transduce</code> forms <a class="indexterm" id="id00310"/>shown previously is different due to the fact that the <code class="literal">conj</code> function will add an element to the head of a list, as opposed to adding it at the end of a vector.</p><p>We can also compose several transducers together using the <code class="literal">comp</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def xf (comp</strong></span>
<span class="strong"><strong>               (map inc)</strong></span>
<span class="strong"><strong>               (filter even?)))</strong></span>
#'user/xf
<span class="strong"><strong>user&gt; (transduce xf conj (range 10))</strong></span>
[2 4 6 8 10]</pre></div><p>The transducer <code class="literal">xf</code> in the preceding output encapsulates the application of the <code class="literal">inc</code> and <code class="literal">even?</code> functions using the <code class="literal">map</code> and <code class="literal">filter</code> forms respectively. This transducer will produce a vector of even numbers when used with the <code class="literal">transduce</code> and <code class="literal">conj</code> forms. Note that the <code class="literal">inc</code> function is indeed applied to the supplied collection <code class="literal">(range 10)</code>, or else the value <code class="literal">10</code> would not show up in the final result. This computation using the transducer <code class="literal">xf</code> can be illustrated as follows:</p><div class="mediaobject"><img alt="Producing results from transducers" src="graphics/B05024_5_01.jpg"/></div><p>The preceding diagram depicts how the transformations <code class="literal">(map inc)</code>, <code class="literal">(filter even?)</code>, and <code class="literal">conj</code> are composed<a class="indexterm" id="id00311"/> in the transformation <code class="literal">xf</code>. The <code class="literal">map</code> form is applied first, followed by the <code class="literal">filter</code> form, and finally the <code class="literal">conj</code> form. In this manner, transducers can be used to compose a series of transformations for any source of data.</p><p>Another way to produce a collection from a transducer is by using the <code class="literal">into</code> function. The result of this function depends on the initial collection supplied to it as the first argument, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (into [] xf (range 10))</strong></span>
[2 4 6 8 10]
<span class="strong"><strong>user&gt; (into () xf (range 10))</strong></span>
(10 8 6 4 2)</pre></div><p>The standard <code class="literal">sequence</code> function can also be used to produce a lazy sequence from a transducer. Of course, the returned lazy sequence will be converted to a list in the REPL, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (sequence xf (range 10))</strong></span>
(2 4 6 8 10)</pre></div><p>So far, we've composed transducers to produce collections with a finite number of elements. An infinite series of values could also be produced by a transducer when used with the <code class="literal">sequence</code> function. The <code class="literal">eduction</code> function can be used to represent this sort of computation. This function will transform a collection, specified as its last argument, to any number of transformations passed to it in right-to-left order. An <code class="literal">eduction</code> form may also require a fewer number of allocations compared to using a sequence.</p><p>For example, if we were to retrieve the 100th element in a sequence using the <code class="literal">nth</code> function, the first 99 elements would have to be realized and also discarded later as they are not needed. On the other hand, an <code class="literal">eduction</code> form can avoid this overhead. Consider the declaration of <code class="literal">simple-eduction</code> in <span class="emphasis"><em>Example 5.3</em></span>:</p><div class="informalexample"><pre class="programlisting">(def simple-eduction (eduction (map inc)
                               (filter even?)
                               (range)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.3: Using the eduction function</em></span></p></blockquote></div><p>The collection <code class="literal">simple-eduction</code> shown in <span class="emphasis"><em>Example 5.3</em></span> will first filter out even values using the <code class="literal">even?</code> predicate from the infinite range <code class="literal">(range)</code> and then increment the resulting values using the <code class="literal">inc</code> function. We can retrieve elements from the collection <code class="literal">simple-eduction</code> using the <code class="literal">nth</code> function. The same computation can also be modeled using lazy sequences, but transducers perform much better, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time (nth simple-eduction 100000))</strong></span>
"Elapsed time: 65.904434 msecs"
200001
<span class="strong"><strong>user&gt; (time (nth (map inc (filter even? (range))) 100000))</strong></span>
"Elapsed time: 159.039363 msecs"
200001</pre></div><p>The <code class="literal">eduction</code> form<a class="indexterm" id="id00312"/> using a transducer performs twice as fast compared to a sequence! From the output shown previously, it is quite clear that transducers perform significantly better than lazy sequences for composing a number of transformations. In summary, transducers created using functions such as <code class="literal">map</code> and <code class="literal">filter</code> can be easily composed to produce collections using functions such as <code class="literal">transduce</code>, <code class="literal">into</code>, and <code class="literal">eduction</code>. We can also use transducers with other sources of data such as streams, asynchronous channels, and observables.</p></div></div></div>
<div class="section" title="Comparing transducers and reducers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl2sec0019"/>Comparing transducers and reducers</h1></div></div></div><p>Both transducers <a class="indexterm" id="id00313"/>and reducers, which were discussed in <a class="link" href="ch18.html" title="Chapter 3. Parallelization Using Reducers">Chapter 3</a>, <span class="emphasis"><em>Parallelization Using Reducers,</em></span> are ways to improve the performance of computations performed over collections. While transducers are a generalization of data processing for multiple data sources, there are a few other subtle differences between<a class="indexterm" id="id00314"/> transducers and reducers, which are described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Transducers are implemented as part of the Clojure language in the <code class="literal">clojure.core</code> namespace. However, reducers must be explicitly included in a program, as they are implemented in the <code class="literal">clojure.core.reducers</code> namespace.</li><li class="listitem" style="list-style-type: disc">Transducers only create a collection when producing the final result of a series of transformations. There are no intermediary collections required to store the results of a transformation that constitutes a transducer. On the other hand, reducers produce intermediate collections to store results, and only avoid the creation of unnecessary empty collections.</li><li class="listitem" style="list-style-type: disc">Transducers deal with efficient composition of a series of transformations. This is quite orthogonal to how reducers squeeze out performance from a computation performed over a collection through the use of parallelization. Transducers perform significantly better than both the <code class="literal">reduce</code> functions from the <code class="literal">clojure.core</code> and <code class="literal">clojure.core.reducers</code> namespaces. Of course, using the <code class="literal">clojure.core.reducers/fold</code> function is still a good way to implement a computation that can be parallelized.</li></ul></div><p>These contrasts between<a class="indexterm" id="id00315"/> transducers and reducers describe how these two methodologies of processing data are different. In practice, the performance of<a class="indexterm" id="id00316"/> these techniques depends on the actual computation being implemented. Generally, if we intend to implement an algorithm to process data in a performant way, we should use transducers. On the other hand, if we are dealing with a lot of data in the memory with no need for I/O and laziness, we should use reducers. The reader is encouraged to compare the performance of the <code class="literal">transduce</code> function with that of the <code class="literal">reduce</code> and <code class="literal">fold</code> functions of the <code class="literal">clojure.core.reducers</code> library for different computations and data sources.</p></div>
<div class="section" title="Transducers in action"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec0036"/>Transducers in action</h1></div></div></div><p>In this section, we<a class="indexterm" id="id00317"/> will examine how transducers are implemented. We will also get a basic idea of how our own <span class="emphasis"><em>transducible</em></span> source of data can be implemented.</p><div class="section" title="Managing volatile references"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec0020"/>Managing volatile references</h2></div></div></div><p>Some transducers<a class="indexterm" id="id00318"/> can internally use state. It turns out that the existing reference types, such as atoms and refs, aren't fast enough for the<a class="indexterm" id="id00319"/> implementation of transducers. To circumvent this problem, transducers also introduce a new <span class="emphasis"><em>volatile</em></span> reference type. A volatile reference represents a mutable variable that will not be copied into the thread-local cache. Also, volatile references are not atomic. They are implemented in Java using the <code class="literal">volatile</code> keyword with a <code class="literal">java.lang.Object</code> type.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0072"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c5/volatile.clj</code> of the book's source code.</p></div></div><p>We can create a new volatile reference using the <code class="literal">volatile!</code> function. The value contained in the volatile state can then be retrieved using the <code class="literal">@</code> reader macro or a <code class="literal">deref</code> form. The <code class="literal">vreset!</code> function can be used to set the state of a volatile reference, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def v (volatile! 0))</strong></span>
#'user/v
<span class="strong"><strong>user&gt; @v</strong></span>
0
<span class="strong"><strong>user&gt; (vreset! v 1)</strong></span>
1</pre></div><p>In the preceding output, we encapsulate the value <code class="literal">0</code> in a volatile state, and then set its state to <code class="literal">1</code> using the <code class="literal">vreset!</code> function. We can also mutate the state contained in a volatile reference using the <code class="literal">vswap!</code> function. We will have to pass a volatile reference and a function to be applied to the value contained in the reference to this function. We can also specify any<a class="indexterm" id="id00320"/> other arguments for the supplied function as additional arguments to the <code class="literal">vswap!</code> function. The <code class="literal">vswap!</code> function can be used to change the state of the volatile reference <code class="literal">v</code> that we previously defined, as <a class="indexterm" id="id00321"/>shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (vswap! v inc)</strong></span>
2
<span class="strong"><strong>user&gt; (vswap! v + 3)</strong></span>
5</pre></div><p>The first call to the <code class="literal">vswap!</code> function in the preceding output uses the <code class="literal">inc</code> function to increment the value stored in the reference <code class="literal">v</code>. Similarly, the subsequent call to the <code class="literal">vswap!</code> function adds the value <code class="literal">3</code> to the new value in the volatile reference <code class="literal">v</code>, thus producing the final value <code class="literal">5</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0073"/>Note</h3><p>We can check whether a value is a volatile using the <code class="literal">volatile?</code> predicate.</p></div></div><p>One may argue that the volatile reference type has the same semantics as that of an atom. The <code class="literal">vreset!</code> and <code class="literal">vswap!</code> functions have the exact same shape as the <code class="literal">reset!</code> and <code class="literal">swap!</code> functions that are used with atoms. However, there is an important difference between a volatile reference and an atom. Unlike an atom, a volatile reference does not guarantee atomicity of operations performed on it. Hence, it's recommended to use volatile references in a single thread.</p></div><div class="section" title="Creating transducers"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec0021"/>Creating transducers</h2></div></div></div><p>As a transducer modifies<a class="indexterm" id="id00322"/> a supplied step function, let's first define what a step function actually does. The following aspects need to be considered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The step function must be able to provide an initial value to the transformation it models. In other words, the step function must have an <span class="emphasis"><em>identity</em></span> form that takes no arguments.</li><li class="listitem" style="list-style-type: disc">Inputs must be combined with the result accumulated so far by the computation. This is analogous to how a reducing function combines an input value with an accumulated result to produce a new result. The arity of this form is also the same as that of a reducing function; it requires two arguments to represent the current input and the accumulated result.</li><li class="listitem" style="list-style-type: disc">The step function must also be able to complete the computation of the modeled process to return something. This can be implemented as a function that accepts a single argument that represents the accumulated result.</li></ul></div><p>Thus, a step function is represented<a class="indexterm" id="id00323"/> as a function with three arities, as described previously. <span class="emphasis"><em>Early termination</em></span> may also be needed by some transducers to abruptly stop a computational process based on certain conditions.</p><p>Now, let's look at how some <a class="indexterm" id="id00324"/>of the standard functions in the <code class="literal">clojure.core</code> namespace are implemented with transducers. The <code class="literal">map</code> function returns a transducer when called with a single argument.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0074"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c5/</code> <code class="literal">implementing_transducers.clj</code> of the book's source code.</p></div></div><p>The following <span class="emphasis"><em>Example 5.4</em></span> describes how the <code class="literal">map</code> function is implemented:</p><div class="informalexample"><pre class="programlisting">(defn map
  ([f]
   (fn [step]
     (fn
       ([] (step))
       ([result] (step result))
       ([result input]
        (step result (f input))))))
  ([f coll]
   (sequence (map f) coll)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.4: The map function</em></span></p></blockquote></div><p>The 1-arity form of the <code class="literal">map</code> function returns a function that accepts a step function, represented by <code class="literal">step</code>, and returns another step function. The returned step function has three different arities, just like we described earlier in this section. The essence of the <code class="literal">map</code> function is described by the expression <code class="literal">(step result (f input))</code>, which translates to "apply the function <code class="literal">f</code> on the current input <code class="literal">input</code> and combine it with the accumulated result <code class="literal">result</code> using the function <code class="literal">step</code>". The returned step function also has two other arities—one that takes no arguments and another that takes one argument. These arities correspond to the other two cases of a step function that we described earlier.</p><p>The second arity of the <code class="literal">map</code> function, which returns a collection and not a transducer, is merely a composition of the <code class="literal">sequence</code> function and the transducer returned by the expression <code class="literal">(map f)</code>. The actual creation of a collection is done by the <code class="literal">sequence</code> function. The 1-arity form of the <code class="literal">map</code> function only describes how the function <code class="literal">f</code> is applied over a transducible context such as a collection.</p><p>Similarly, the <code class="literal">filter</code> function can be implemented using a transducer, as shown in <span class="emphasis"><em>Example 5.5</em></span>, as follows:</p><div class="informalexample"><pre class="programlisting">(defn filter
  ([p?]
   (fn [step]
     (fn
       ([] (step))
       ([result] (step result))
       ([result input]
        (if (p? input)
          (step result input)
          result)))))
  ([p? coll]
   (sequence (filter p?) coll)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.5: The filter function</em></span></p></blockquote></div><p>The premise in the implementation of the <code class="literal">filter</code> function is that a predicate <code class="literal">p?</code> is used to conditionally combine<a class="indexterm" id="id00325"/> the accumulated result and the current input, which are represented by <code class="literal">result</code> and <code class="literal">input</code> respectively. If the expression <code class="literal">(p? input)</code> does not return a truthy value, the accumulated result is returned without any modification. Similar to the map function in <span class="emphasis"><em>Example 5.4</em></span>, the 2-arity form of the filter function is implemented using a <code class="literal">sequence</code> form and a transducer.</p><p>To handle early termination in transducers, we must use the <code class="literal">reduced</code> and <code class="literal">reduced?</code> functions. Calling reduce or a step function on a value that has been wrapped in a <code class="literal">reduced</code> form will simply return the contained value. The <code class="literal">reduced?</code> function checks whether a value is already <span class="emphasis"><em>reduced</em></span>, that is, wrapped in a <code class="literal">reduced</code> form. The <code class="literal">reduced</code> and <code class="literal">reduced?</code> forms both accept a single argument, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def r (reduced 0))</strong></span>
#'user/r
<span class="strong"><strong>user&gt; (reduced? r)</strong></span>
true</pre></div><p>Consider the following function <code class="literal">rf</code> in <span class="emphasis"><em>Example 5.6</em></span> that uses a <code class="literal">reduced</code> form to ensure that the accumulated result is never more than 100 elements:</p><div class="informalexample"><pre class="programlisting">(defn rf [result input]
  (if (&lt; result 100)
    (+ result input)
    (reduced :too-big)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.6: Using the reduced function</em></span></p></blockquote></div><p>The function <code class="literal">rf</code> merely sums up all inputs to produce a result. If the <code class="literal">rf</code> function is passed to the <code class="literal">reduce</code> function along with a sufficiently large collection, the <code class="literal">:too-big</code> value is returned as the final result, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (reduce rf (range 3))</strong></span>
3
<span class="strong"><strong>user&gt; (reduce rf (range 100))</strong></span>
:too-big</pre></div><p>A value wrapped in a <code class="literal">reduced</code> form can be extracted using the <code class="literal">unreduced</code> function or the <code class="literal">@</code> reader macro. Also, the <code class="literal">ensure-reduced</code> function can be used instead of <code class="literal">reduced</code> to avoid re-applying a <code class="literal">reduced</code> form to a value that has already been reduced.</p><p>The standard <code class="literal">take-while</code> function <a class="indexterm" id="id00326"/>can be implemented using a <code class="literal">reduced</code> form and a transducer, as shown in the following <span class="emphasis"><em>Example 5.7</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn take-while [p?]
  (fn [step]
    (fn
      ([] (step))
      ([result] (step result))
      ([result input]
       (if (p? input)
         (step result input)
         (reduced result))))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.7: The take-while function</em></span></p></blockquote></div><p>Note that only the 1-arity form of the <code class="literal">take-while</code> function is described in <span class="emphasis"><em>Example 5.7</em></span>. The step function returned by the <code class="literal">take-while</code> function uses the expression <code class="literal">(p? input)</code> to check if the accumulated result has to be combined with the current input. If the <code class="literal">p?</code> predicate does not return a truthy value, the accumulated result is returned by wrapping it in a <code class="literal">reduced</code> form. This prevents any other transformations, which may be composed with the transformation returned by the <code class="literal">take-while</code> function, from modifying the accumulated result any further. In this way, the <code class="literal">reduced</code> form can be used to wrap the result of a transducer and perform early termination based on some conditional logic.</p><p>Let's look at how a stateful transducer is implemented. The <code class="literal">take</code> function returns a transducer that maintains an internal state. This state is used to keep a track of the number of items that have been processed so far, since the <code class="literal">take</code> function must only return a certain number of items from a collection or any other transducible context by definition. <span class="emphasis"><em>Example 5.8</em></span> describes how the <code class="literal">take</code> function is implemented using a volatile reference to maintain state:</p><div class="informalexample"><pre class="programlisting">(defn take [n]
  (fn [step]
    (let [nv (volatile! n)]
      (fn
        ([] (step))
        ([result] (step result))
        ([result input]
         (let [n @nv
               nn (vswap! nv dec)
               result (if (pos? n)
                        (step result input)
                        result)]
           (if (not (pos? nn))
             (ensure-reduced result)
             result)))))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.8: The take function</em></span></p></blockquote></div><p>The transducer returned by the <code class="literal">take</code> function will first create a volatile reference <code class="literal">nv</code> from the supplied value <code class="literal">n</code> to track the number of items to be processed. The returned step function then decrements the volatile reference <code class="literal">nv</code> and combines the result with the input using the <code class="literal">step</code> function. This is done repeatedly until the value contained in the reference <code class="literal">nv</code> is positive. Once all <code class="literal">n</code> items have been processed, the result is wrapped in an <code class="literal">ensure-reduced</code> form to signal <a class="indexterm" id="id00327"/>early termination. Here, the <code class="literal">ensure-reduced</code> function is used to prevent wrapping the value <code class="literal">result</code> in another <code class="literal">reduced</code> form, since the expression <code class="literal">(step result input)</code> could return a value that is already reduced.</p><p>Finally, let's take a quick look at how the <code class="literal">transduce</code> function is implemented, as shown in <span class="emphasis"><em>Example 5.9</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn transduce
  ([xform f coll] (transduce xform f (f) coll))
  ([xform f init coll]
   (let [xf (xform f)
         ret (if (instance? clojure.lang.IReduceInit coll)
               (.reduce ^clojure.lang.IReduceInit coll xf init)
               (clojure.core.protocols/coll-reduce coll xf init))]
     (xf ret))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 5.9: The transduce function</em></span></p></blockquote></div><p>The <code class="literal">transduce</code> function has two arities. The 4-arity form of the <code class="literal">transduce</code> function calls the <code class="literal">.reduce</code> method of the transducible context <code class="literal">coll</code> if it is an instance of the <code class="literal">clojure.lang.IReduceInit</code> interface. This interface defines a single method <code class="literal">reduce</code> that represents how a data source is reduced using a given function and an initial value. If the variable <code class="literal">coll</code> does not implement this interface, the <code class="literal">transduce</code> function will fall back on the <code class="literal">coll-reduce</code> function to process the data source represented by <code class="literal">coll</code>. In a nutshell, the <code class="literal">transduce</code> function will try to process a transducible context in the fastest possible way. The <code class="literal">clojure.lang.IReduceInit</code> interface must be implemented by all data sources that must support the use of <code class="literal">transduce</code>.</p><p>The 3-arity form of the <code class="literal">transduce</code> function produces the initial value for the transduction by invoking the supplied function <code class="literal">f</code> without any arguments. Thus, this arity of the <code class="literal">transduce</code> function can only be used with functions that provide an identity value.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0075"/>Note</h3><p>The definitions of the <code class="literal">map</code>, <code class="literal">filter</code>, <code class="literal">take</code>, and <code class="literal">take-while</code> functions, as shown in this section, are simplified versions of their actual definitions. However, the <code class="literal">transduce</code> function is shown exactly as it is implemented in the <code class="literal">clojure.core</code> namespace.</p></div></div><p>This depicts how<a class="indexterm" id="id00328"/> transducers and the <code class="literal">transduce</code> function are implemented. If we need to implement our own transducible source of data, the implementations described in this section can be used as a guideline.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec0037"/>Summary</h1></div></div></div><p>So far, we have seen how we can process data using sequences, reducers, and transducers. In this chapter, we described how transducers can be used for performant computations. We also briefly studied how transducers are implemented in the Clojure language.</p><p>In the following chapter, we will explore algebraic data structures, such as functors, applicatives, and monads, in Clojure. These concepts will deepen our understanding of functional composition, which is the keystone of functional programming.</p></div>
<div class="chapter" title="Chapter&#xA0;6.&#xA0;Exploring Category Theory"><div class="titlepage"><div><div><h1 class="title"><a id="ch21"/>Chapter 6. Exploring Category Theory</h1></div></div></div><p>On a journey into functional programming, a programmer will eventually stumble upon <span class="emphasis"><em>category theory</em></span>. First off, let's just say that the study of category theory is not really needed to write better code. It's more prevalent in the internals of pure functional programming languages, such as Haskell and Idris, in which functions are <span class="emphasis"><em>pure</em></span> and more like mathematical functions that do not have implicit side effects such as I/O and mutation. However, category theory helps us reason about a very fundamental and practical aspect of <a class="indexterm" id="id00329"/>computation: <span class="emphasis"><em>composition</em></span>. Functions in Clojure, unlike in pure functional programming languages, are quite different from mathematical functions as they can perform I/O and other side effects. Of course, they can be pure under certain circumstances, and thus concepts from category theory are still useful in Clojure for writing reusable and composable code based on pure functions.</p><p>Category theory can be thought of as a mathematical framework for modeling composition. In this chapter, we will discuss a few concepts from category theory using Clojure. We will also study a few algebraic types, such as functors, monoids, and monads.</p><div class="section" title="Demystifying category theory"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec0038"/>Demystifying category theory</h1></div></div></div><p>Category theory has its<a class="indexterm" id="id00330"/> own share of quirky notations and conventions. Let's start off by exploring some of the terminology used in category theory, in a language understandable by us mortal programmers.</p><p>A <span class="emphasis"><em>category</em></span> is formally defined as a collection <a class="indexterm" id="id00331"/>of <span class="strong"><strong>objects</strong></span> and <span class="strong"><strong>morphisms</strong></span>. In<a class="indexterm" id="id00332"/> simple terms, objects represent abstract types, and morphisms represent functions that convert between these types. A category is thus analogous to a programming language that has a few types and functions, and has two basic properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There exists an <span class="emphasis"><em>identity morphism</em></span> for<a class="indexterm" id="id00333"/> each object in the category. In practice, a single identity function can be used to represent the identity morphism for all given objects, but this is not mandatory.</li><li class="listitem" style="list-style-type: disc">Morphisms in a category can be composed together into a new morphism. In fact, a composition of two or more morphisms is an optimization of applying the individual morphisms one at a time. In this way, the composition of several<a class="indexterm" id="id00334"/> morphisms is said to <span class="emphasis"><em>commute</em></span> with applying the constituting morphisms.</li></ul></div><p>Morphisms in a category can be composed as illustrated by the following diagram:</p><div class="mediaobject"><img alt="Demystifying category theory" src="graphics/B05024_06_01.jpg"/></div><p>In the preceding diagram, the vertices <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>, and <span class="emphasis"><em>C</em></span> are the objects and the arrows are morphisms between these objects. The morphisms <span class="emphasis"><em>I<sub>A</sub></em></span>, <span class="emphasis"><em>I<sub>B</sub></em></span>, and <span class="emphasis"><em>I<sub>C</sub></em></span> are identity morphisms that map the objects <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>B</em></span>, and <span class="emphasis"><em>C</em></span> to themselves. The morphism <span class="emphasis"><em>f</em></span> maps <span class="emphasis"><em>A</em></span> to <span class="emphasis"><em>B</em></span>, and similarly the morphism <span class="emphasis"><em>g</em></span> maps <span class="emphasis"><em>B</em></span> to <span class="emphasis"><em>C</em></span>. These two morphisms can be composed together, as represented by the morphism <span class="inlinemediaobject"><img alt="Demystifying category theory" src="graphics/4900_06_07.jpg"/></span> that maps <span class="emphasis"><em>A</em></span> directly to <span class="emphasis"><em>C</em></span>, and hence the morphism <span class="inlinemediaobject"><img alt="Demystifying category theory" src="graphics/4900_06_07.jpg"/></span> <span class="emphasis"><em>commutes</em></span> with the morphisms <span class="emphasis"><em>f</em></span> and <span class="emphasis"><em>g</em></span>. For this reason, the preceding diagram is termed as a <span class="emphasis"><em>commutative diagram</em></span>. Note that identity morphisms in a commutative diagram are generally not shown, unlike in the preceding diagram.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0076"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c6/</code> <code class="literal">demystifying_cat_theory.clj</code> of the book's source code.</p></div></div><p>Now, let's translate the previous diagram to Clojure. We shall use the built-in string, symbol and keyword types to depict how morphisms, or rather functions, between these types can be composed together using the <code class="literal">comp</code> function:</p><div class="mediaobject"><img alt="Demystifying category theory" src="graphics/B05024_06_02.jpg"/></div><p>As shown in the<a class="indexterm" id="id00335"/> preceding diagram, the <code class="literal">name</code> function converts a keyword to a string, and the <code class="literal">symbol</code> function converts a string to a symbol. These two functions can be composed into a function that converts a keyword directly to a symbol, represented by the <code class="literal">(comp symbol name)</code> function. Also, the identity morphisms for each category translate to the <code class="literal">identity</code> function.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0077"/>Note</h3><p>Internally, the string, symbol, and keyword types are represented by the <code class="literal">java.lang.String</code>, <code class="literal">clojure.lang.Symbol</code> and <code class="literal">clojure.lang.Keyword</code> classes respectively.</p></div></div><p>We can verify that the <code class="literal">name</code> and <code class="literal">symbol</code> functions can be composed together using the <code class="literal">comp</code> form, as shown in the following REPL output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (name :x)</strong></span>
"x"
<span class="strong"><strong>user&gt; (symbol "x")</strong></span>
x
<span class="strong"><strong>user&gt; ((comp symbol name) :x)</strong></span>
x</pre></div><p>This establishes the fact that concepts from category theory have equivalent representations in Clojure, and other programming languages as well. Although it is perfectly valid to think about objects in a category as concrete types like we just described, <span class="emphasis"><em>algebraic structures</em></span> are<a class="indexterm" id="id00336"/> a more practical substitute for objects. Algebraic structures describe abstract properties of types, rather than what data is contained in a type or how data is structured by a type, and are more like abstract types. Thus, category theory is all about composing functions that operate on abstract types with certain properties.</p><p>In Clojure, algebraic structures can be thought of as protocols. Concrete types can implement protocols, and <a class="indexterm" id="id00337"/>hence a type can represent more than one algebraic structure. The <code class="literal">cats</code> library (<a class="ulink" href="https://github.com/funcool/cats">https://github.com/funcool/cats</a>) takes this approach and provides protocol-based definitions of a few interesting algebraic structures. The <code class="literal">cats</code> library also provides<a class="indexterm" id="id00338"/> types that implement these protocols. Additionally, this library extends some of the built-in types through these protocols allowing us to treat them as algebraic structures. Although there are several alternatives, <code class="literal">cats</code> is the only library compatible with ClojureScript.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0078"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[funcool/cats "1.0.0"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [cats.core :as cc]
            [cats.builtin :as cb]
            [cats.applicative.validation :as cav]
            [cats.monad.maybe :as cmm]
            [cats.monad.identity :as cmi]
            [cats.monad.exception :as cme]))</pre></div></div></div><p>Now, let's study some of the algebraic structures from the <code class="literal">cats</code> library.</p></div></div>
<div class="section" title="Using monoids"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec0039"/>Using monoids</h1></div></div></div><p>Let's start by<a class="indexterm" id="id00339"/> exploring <span class="strong"><strong>monoids</strong></span>. In order to define a monoid, we must first understand what a semigroup is.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0080"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c6/</code> <code class="literal">monoids.clj</code> of the book's source code.</p></div></div><p>A <span class="emphasis"><em>semigroup</em></span> is an <a class="indexterm" id="id00340"/>algebraic structure that supports an associative binary operation. A binary operation, say <span class="inlinemediaobject"><img alt="Using monoids" src="graphics/4900_06_08.jpg"/></span>, is termed <a class="indexterm" id="id00341"/>
<span class="emphasis"><em>associative</em></span> if the operation <span class="inlinemediaobject"><img alt="Using monoids" src="graphics/4900_06_09.jpg"/></span> produces the same result as the operation <span class="inlinemediaobject"><img alt="Using monoids" src="graphics/4900_06_10.jpg"/></span>. A monoid is in fact a semigroup with an additional property, as we will see ahead.</p><p>The <code class="literal">mappend</code> function<a class="indexterm" id="id00342"/> from the <code class="literal">cats.core</code> namespace will associatively combine a number of instances of the same type and return a new instance of the given type. If we are dealing with strings or vectors, the <code class="literal">mappend</code> operation is implemented by the standard <code class="literal">concat</code> function. Thus, strings and vectors can be combined using the <code class="literal">mappend</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/mappend "12" "34" "56")</strong></span>
"123456"
<span class="strong"><strong>user&gt; (cc/mappend [1 2] [3 4] [5 6])</strong></span>
[1 2 3 4 5 6]</pre></div><p>As strings and vectors support the associative <code class="literal">mappend</code> operation, they are semigroups. They are also <a class="indexterm" id="id00343"/>
<span class="emphasis"><em>monoids</em></span>, which are simply semigroups that have an <span class="emphasis"><em>identity element</em></span>. It's fairly<a class="indexterm" id="id00344"/> obvious that the identity element for strings is an empty string, and for vectors it's an empty vector.</p><p>This is a good time to introduce a versatile concrete type from the world of functional programming—the <code class="literal">Maybe</code> type. The <code class="literal">Maybe</code> type represents an optional value, and can either be empty or contain a value. It can be thought of as a value in a context or a container. The <code class="literal">just</code> and <code class="literal">nothing</code> functions from the <code class="literal">cats.monads.maybe</code> namespace can be used to construct an instance of the <code class="literal">Maybe</code> type. The <code class="literal">just</code> function constructs an instance with a contained value, and the <code class="literal">nothing</code> function creates an empty <code class="literal">Maybe</code> value. The value contained in a <code class="literal">Maybe</code> instance can be obtained by either passing it to the <code class="literal">cats.monads.maybe/from-maybe</code> function, or dereferencing it (using the <code class="literal">deref</code> form or the <code class="literal">@</code> reader macro).</p><p>Incidentally, the <code class="literal">Maybe</code> type is also a monoid, since an empty <code class="literal">Maybe</code> value, created using the <code class="literal">nothing</code> function, is analogous to an identity element. We can use the <code class="literal">mappend</code> function to combine values of the <code class="literal">Maybe</code> type, just like any other monoid, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @(cc/mappend (cmm/just "123")</strong></span>
<span class="strong"><strong>                   (cmm/just "456"))</strong></span>
"123456"
<span class="strong"><strong>user&gt; @(cc/mappend (cmm/just "123")</strong></span>
<span class="strong"><strong>                   (cmm/nothing)</strong></span>
<span class="strong"><strong>                   (cmm/just "456"))</strong></span>
"123456"</pre></div><p>The <code class="literal">mappend</code> function <a class="indexterm" id="id00345"/>can thus be used to associatively combine any values that are monoids.</p></div>
<div class="section" title="Using functors"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec0040"/>Using functors</h1></div></div></div><p>Next, let's take a look at<a class="indexterm" id="id00346"/> <span class="strong"><strong>functors</strong></span>. A functor is essentially a value in a container or a computational context. The <code class="literal">fmap</code> function must be implemented by a functor. This function applies a supplied function to the value contained in a functor. In object-oriented terminology, a functor can be thought of as a generic type with a single abstract method <code class="literal">fmap</code>. In a way, reference types, such as refs and atoms, can be thought of as functors that save results, as a reference type applies a function to its contained value in order to obtain the new value that should be stored in it.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0081"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c6/</code> <code class="literal">functors.clj</code> of the book's source code.</p></div></div><p>The <code class="literal">fmap</code> function from the <code class="literal">cats.core</code> namespace takes two arguments: a function and a functor. A functor itself defines what happens when an instance of the functor is passed to the <code class="literal">fmap</code> function. The <code class="literal">cats</code> library extends vectors as functors. When a vector is passed to the <code class="literal">fmap</code> function along with a function, the supplied function is applied to all elements in the vector. Wait a minute! Isn't that what the <code class="literal">map</code> function does? Well, yes, but the <code class="literal">map</code> function always returns a lazy sequence. On the other hand, the <code class="literal">fmap</code> function will return a value with the same concrete type as the functor that is passed. The behavior of the <code class="literal">map</code> and <code class="literal">fmap</code> functions can be compared as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (map inc [0 1 2])</strong></span>
(1 2 3)
<span class="strong"><strong>user&gt; (cc/fmap inc [0 1 2])</strong></span>
[1 2 3]</pre></div><p>As shown above, the <code class="literal">map</code> function produces a lazy sequence, which gets realized into a list in the REPL, when it is passed a vector along with the <code class="literal">inc</code> function. The <code class="literal">fmap</code> function, however, produces a vector when passed the same arguments. We should note that the <code class="literal">fmap</code> function is also aliased as <code class="literal">&lt;$&gt;</code>. Lazy sequences and sets can also be treated as functors, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/&lt;$&gt; inc (lazy-seq '(1)))</strong></span>
(2)
<span class="strong"><strong>user&gt; (cc/&lt;$&gt; inc #{1})</strong></span>
#{2}</pre></div><p>The <code class="literal">Maybe</code> type is also a functor. The <code class="literal">fmap</code> function returns a <span class="emphasis"><em>maybe</em></span> when it is passed a <span class="emphasis"><em>maybe</em></span>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/fmap inc (cmm/just 1))</strong></span>
#&lt;Just@ff5df0: 2&gt;
<span class="strong"><strong>user&gt; (cc/fmap inc (cmm/nothing))</strong></span>
#&lt;Nothing@d4fb58: nil&gt;</pre></div><p>The <code class="literal">fmap</code> function <a class="indexterm" id="id00347"/>applies the function <code class="literal">inc</code> to a <code class="literal">Maybe</code> value only when it contains a value. This behavior of the <code class="literal">fmap</code> function can be illustrated by the following diagram:</p><div class="mediaobject"><img alt="Using functors" src="graphics/B05024_06_03.jpg"/></div><p>The preceding diagram depicts how the <code class="literal">fmap</code> function is passed the <code class="literal">inc</code> function and the expression <code class="literal">(cmm/just 1)</code>, and returns a new functor instance. The <code class="literal">fmap</code> function extracts the value from this <code class="literal">Maybe</code> value, applies the <code class="literal">inc</code> function to the value, and creates a new <code class="literal">Maybe</code> value with the result. On the other hand, the <code class="literal">fmap</code> function will simply return an empty <code class="literal">Maybe</code> instance, created using the <code class="literal">nothing</code> function, without touching it, as shown in the following diagram:</p><div class="mediaobject"><img alt="Using functors" src="graphics/B05024_06_04.jpg"/></div><p>This behavior of the <code class="literal">fmap</code> function is defined by the implementation of the <code class="literal">Maybe</code> type. This is because a functor itself gets to define how the <code class="literal">fmap</code> function behaves with it. Of course, implementing the <code class="literal">fmap</code> function is not enough to qualify a type as a functor. There are also<a class="indexterm" id="id00348"/> functor laws that have to be satisfied by any plausible implementation of a functor. The functor laws can be described as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Passing an identity morphism and a functor <span class="emphasis"><em>F</em></span> to <code class="literal">fmap</code> must return the functor <span class="emphasis"><em>F</em></span> without any modification. We can translate this into Clojure using the <code class="literal">identity</code> function, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/&lt;$&gt; identity [0 1 2])</strong></span>
[0 1 2]</pre></div></li><li class="listitem">
Passing a functor <span class="emphasis"><em>F</em></span> and a morphism <span class="emphasis"><em>f</em></span> to <code class="literal">fmap</code>, followed by passing the result and another morphism <span class="emphasis"><em>g</em></span> to <code class="literal">fmap</code>, must be equivalent to calling <code class="literal">fmap</code> with the functor <span class="emphasis"><em>F</em></span> and the composition <span class="inlinemediaobject"><img alt="Using functors" src="graphics/4900_06_07.jpg"/></span>. We can verify this using the <code class="literal">comp</code> function, as shown here:
<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt;&gt; [0 1 2]</strong></span>
<span class="strong"><strong>           (cc/&lt;$&gt; inc)</strong></span>
<span class="strong"><strong>           (cc/&lt;$&gt; (partial + 2)))</strong></span>
[3 4 5]
<span class="strong"><strong>user&gt; (cc/&lt;$&gt; (comp (partial + 2) inc) [0 1 2])</strong></span>
[3 4 5]</pre></div></li></ol></div><p>The first law describes identity morphisms, and the second law upholds the composition of morphisms. These laws can be thought of as optimizations that can be performed by the <code class="literal">fmap</code> function when used with valid functors.</p></div>
<div class="section" title="Using applicative functors"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec0041"/>Using applicative functors</h1></div></div></div><p>Applicative functors are a subset of functors with a few additional requirements imposed on them, thus making<a class="indexterm" id="id00349"/> them a bit more useful. Similar to functors, applicative functors are computational contexts that are capable of applying a function to the value contained in them. The only difference is that the function to be applied to an applicative functor must itself be wrapped in the context of an applicative functor. Applicative functors also have a different interface of functions associated with them. An applicative functor, in <code class="literal">cats</code>, is manipulated using two functions: <code class="literal">fapply</code> and <code class="literal">pure</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0082"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c6/</code> <code class="literal">applicatives.clj</code> of the book's source code.</p></div></div><p>The <code class="literal">fapply</code> function from the <code class="literal">cats.core</code> namespace can be called with an applicative functor, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @(cc/fapply (cmm/just inc)</strong></span>
<span class="strong"><strong>                  (cmm/just 1))</strong></span>
2</pre></div><p>Here, we again use the <code class="literal">Maybe</code> type, this time as an applicative functor. The <code class="literal">fapply</code> function unwraps<a class="indexterm" id="id00350"/> the <code class="literal">inc</code> function and the value <code class="literal">1</code> from the <code class="literal">Maybe</code> values, combines them and returns the result <code class="literal">2</code> in a new <code class="literal">Maybe</code> instance. This can be illustrated with the following diagram:</p><div class="mediaobject"><img alt="Using applicative functors" src="graphics/B05024_06_05.jpg"/></div><p>The <code class="literal">cats.core/pure</code> function is used to create a new instance of an applicative functor. We must pass an implementation-specific context, such as <code class="literal">cats.monads.maybe/context</code>, and a value to the <code class="literal">pure</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/pure cmm/context 1)</strong></span>
#&lt;Just@cefb4d: 1&gt;</pre></div><p>The <code class="literal">cats</code> library provides an <code class="literal">alet</code> form to easily compose applicative functors. Its syntax is similar to that of the <code class="literal">let</code> form, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; @(cc/alet [a (cmm/just [1 2 3])</strong></span>
<span class="strong"><strong>                 b (cmm/just [4 5 6])]</strong></span>
<span class="strong"><strong>         (cc/mappend a b))</strong></span>
[1 2 3 4 5 6]</pre></div><p>The value returned by the body of the <code class="literal">alet</code> form, shown previously, is wrapped in a new applicative functor instance and returned. The surrounding <code class="literal">alet</code> form is dereferenced, and thus the entire expression returns a vector.</p><p>The <code class="literal">&lt;*&gt;</code> function from the <code class="literal">cats.core</code> namespace is a variadic form of the <code class="literal">fapply</code> function. It accepts a value representing an applicative functor followed by any number of functions that produce applicative functors. The <code class="literal">cats</code> library also provides the <code class="literal">Validation</code> applicative functor type for validating properties of a given object. This type can be constructed using the <code class="literal">ok</code> and <code class="literal">fail</code> forms in the <code class="literal">cats.applicative.validation</code> namespace. Let's say we want to validate a map representing a page with some textual content. A page must have a page number and an author. This validation <a class="indexterm" id="id00351"/>can be implemented as shown in <span class="emphasis"><em>Example 6.1</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn validate-page-author [page]
  (if (nil? (:author page))
    (cav/fail {:author "No author"})
    (cav/ok page)))

(defn validate-page-number [page]
  (if (nil? (:number page))
    (cav/fail {:number "No page number"})
    (cav/ok page)))

(defn validate-page [page]
  (cc/alet [a (validate-page-author page)
            b (validate-page-number page)]
    (cc/&lt;*&gt; (cc/pure cav/context page) 
            a b)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 6.1: The cats.applicative.validation type</em></span></p></blockquote></div><p>The <code class="literal">validate-page-author</code> and <code class="literal">validate-page-number</code> functions in <span class="emphasis"><em>Example 6.1</em></span> check whether a map contains the <code class="literal">:author</code> and <code class="literal">:number</code> keys respectively. These functions create an instance of the <code class="literal">Validation</code> type using the <code class="literal">ok</code> function, and similarly use the <code class="literal">fail</code> function to create a <code class="literal">Validation</code> instance that represents a validation failure. Both the <code class="literal">validate-page-author</code> and <code class="literal">validate-page-number</code> functions are composed together using the <code class="literal">&lt;*&gt;</code> function. The first argument passed to <code class="literal">&lt;*&gt;</code> will have to be an instance of the <code class="literal">Validation</code> type created using the <code class="literal">pure</code> function. The <code class="literal">validate-page</code> function can thus validate maps representing pages, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (validate-page {:text "Some text"})</strong></span>
#&lt;Fail@1203b6a: {:author "No author", :number "No page number"}&gt;
<span class="strong"><strong>user&gt; (validate-page {:text "Some text" :author "John" :number 1})</strong></span>
#&lt;Ok@161b2f8: {:text "Some text", :author "John", :number 1}&gt;</pre></div><p>A successful validation will return a <code class="literal">Validation</code> instance containing the page object, and an unsuccessful one will return an instance of the <code class="literal">Validation</code> type with the appropriate validation messages as a map. The concrete types for these two cases are <code class="literal">Ok</code> and <code class="literal">Fail</code>, as shown in the preceding output.</p><p>Applicative functors must themselves define the behavior of the <code class="literal">fapply</code> and <code class="literal">pure</code> functions with them. Of course, there are laws that applicative functors must obey too. In addition to the identity and composition laws of functors, applicative functors also conform to<a class="indexterm" id="id00352"/> the <span class="emphasis"><em>homomorphism</em></span> and <span class="emphasis"><em>interchange</em></span> <a class="indexterm" id="id00353"/>laws. The reader is encouraged to find out more about these laws before implementing their own applicative functors.</p></div>
<div class="section" title="Using monads"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec0042"/>Using monads</h1></div></div></div><p>Finally, let's take a look at an algebraic structure that helps us build and compose a sequence of computations: a <span class="strong"><strong>monad</strong></span>. There are countless tutorials and articles on the web that explain monads and how they can be used. In this section, we will look at monads in our own unique and Clojure-y way.</p><p>In category theory, a <a class="indexterm" id="id00354"/>monad is a morphism between functors. This means that a monad transforms the context of a contained value into another context. In pure functional programming languages, monads are data structures used to represent computations that are defined in steps. Each step is represented by an operation on a monad, and several of these steps can be chained together. Essentially, a monad is a composable abstraction of a step of any computation. A distinct feature of monads is that they allow us to model impure side effects, which may be performed in the various steps of a given computation, using pure functions.</p><p>Monads abstract the way a function binds values to arguments and returns a value. Formally, a monad is an algebraic structure that implements two functions: <code class="literal">bind</code> and <code class="literal">return</code>. The <code class="literal">bind</code> function is used to apply a function to the value contained in a monad, and the <code class="literal">return</code> function can be thought of as a construct for wrapping values in a new monad instance. The type signatures of the <code class="literal">bind</code> and <code class="literal">return</code> functions can be described by the following pseudo code:</p><div class="informalexample"><pre class="programlisting">bind : (Monad A a, [A -&gt; Monad B] f) -&gt; Monad B
return : (A a) -&gt; Monad A</pre></div><p>The type signature of the <code class="literal">bind</code> function states that it accepts a value of type <code class="literal">Monad</code> <code class="literal">A</code> and a function that converts a value of type <code class="literal">A</code> to another value of type <code class="literal">Monad B</code>, which is simply a monad containing a value of type <code class="literal">B</code>. Also, the <code class="literal">bind</code> function returns a type <code class="literal">Monad B</code>. The <code class="literal">return</code> function's type signature shows that it takes a value of type <code class="literal">A</code> and returns a type <code class="literal">Monad A</code>. Implementing these two functions allows a monad to execute any code, defined in its <code class="literal">bind</code> implementation, before the supplied function <code class="literal">f</code> is applied to the value contained in the monad. A monad can also define code to be executed when the supplied function <code class="literal">f</code> returns a value, as defined by the monad's implementation of the <code class="literal">return</code> function.</p><p>Due to the fact that a monad can do more than just call a function over its contained value when passed to the <code class="literal">bind</code> function, a monad is used to indicate side effects in pure functional programming languages. Let's say, we have a function that maps type <code class="literal">A</code> to <code class="literal">B</code>. A function that maps type <code class="literal">A</code> to <code class="literal">Monad B</code> can be used to model the side effects that can occur when a value of type <code class="literal">A</code> is converted to another value of type <code class="literal">B</code>. In this way, monads can be used to represent side effects, such as IO, change of state, exceptions, and transactions.</p><p>Some programmers may<a class="indexterm" id="id00355"/> even argue that monads are unnecessary in a language with macros. This is true in some sense, because macros can encapsulate side effects in them. However, monads help us to be explicit about any side-effects, which is quite useful. In fact, monads are the only way to model side effects in pure functional programming languages. Because monads can represent side effects, they allow us to write imperative-style code, which is all about mutation of state, in a pure functional programming language.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0083"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c6/</code> <code class="literal">monads.clj</code> of the book's source code.</p></div></div><p>Let's now look at how the <code class="literal">Maybe</code> type from the <code class="literal">cats</code> library can take the form of a monad. We can pass a <code class="literal">Maybe</code> value along with a function to the <code class="literal">cats.core/bind</code> function to call the supplied function with the contained value in the monad. This function is aliased as <code class="literal">&gt;&gt;=</code>. The behavior of the <code class="literal">bind</code> function with a <code class="literal">Maybe</code> type is shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/bind (cmm/just 1) inc)</strong></span>
2
<span class="strong"><strong>user&gt; (cc/bind (cmm/nothing) inc)</strong></span>
#&lt;Nothing@24e44b: nil&gt;</pre></div><p>In this way, we can <span class="emphasis"><em>bind</em></span> the <code class="literal">inc</code> function to a <code class="literal">Maybe</code> monad. The expression shown in the preceding output can be depicted by the following diagram:</p><div class="mediaobject"><img alt="Using monads" src="graphics/B05024_06_06.jpg"/></div><p>The <code class="literal">inc</code> function is<a class="indexterm" id="id00356"/> applied to a <code class="literal">Maybe</code> monad only if it contains a value. When a <code class="literal">Maybe</code> monad does contain a value, applying the <code class="literal">inc</code> function to it using the <code class="literal">bind</code> function will simply return <code class="literal">2</code>, and not a monad containing <code class="literal">2</code>. This is because the standard <code class="literal">inc</code> function does not return a monad. On the other hand, an empty <code class="literal">Maybe</code> value is returned untouched. To return a monad in both the preceding cases, we can use the <code class="literal">return</code> function from the <code class="literal">cats.core</code> namespace, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/bind (cmm/just 1) #(-&gt; % inc cc/return))</strong></span>
#&lt;Just@208e3: 1&gt;
<span class="strong"><strong>user&gt; (cc/bind (cmm/nothing) #(-&gt; % inc cc/return))</strong></span>
#&lt;Nothing@1e7075b: nil&gt;</pre></div><p>The <code class="literal">lift-m</code> form can be used to <span class="emphasis"><em>lift</em></span> a function that returns a type <code class="literal">A</code> to return a monad containing a type <code class="literal">A</code>. The concrete type of the return value of a lifted function depends on the monad context passed to it. If we pass a <code class="literal">Maybe</code> monad to a lifted version of <code class="literal">inc</code>, it will return a new instance of the <code class="literal">Maybe</code> monad, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; ((cc/lift-m inc) (cmm/just 1))</strong></span>
#&lt;Just@1eaaab: 2&gt;</pre></div><p>We can also compose several calls to the <code class="literal">bind</code> function, as long as the function passed to the <code class="literal">bind</code> function produces a monad, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/&gt;&gt;= (cc/&gt;&gt;= (cmm/just 1)</strong></span>
<span class="strong"><strong>                      #(-&gt; % inc cmm/just))</strong></span>
<span class="strong"><strong>              #(-&gt; % dec cmm/just))</strong></span>
#&lt;Just@91ea3c: 1&gt;</pre></div><p>Of course, we can also compose calls to the <code class="literal">bind</code> function to change the type of monad. For example, we can map a <code class="literal">Maybe</code> monad to an <code class="literal">Identity</code> monad, which is constructed using the <code class="literal">cats.monads.identity/identity</code> function. We can modify the preceding expression to return an <code class="literal">Identity</code> monad as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/&gt;&gt;= (cc/&gt;&gt;= (cmm/just 1)</strong></span>
<span class="strong"><strong>                      #(-&gt; % inc cmm/just))</strong></span>
<span class="strong"><strong>              #(-&gt; % dec cmi/identity))</strong></span>
#&lt;Identity@dd6793: 1&gt;</pre></div><p>As shown in the<a class="indexterm" id="id00357"/> preceding output, calling the <code class="literal">bind</code> function multiple times can get a bit cumbersome. The <code class="literal">mlet</code> form lets us compose expressions that return monads, as shown in <span class="emphasis"><em>Example 6.2</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="emphasis"><em> </em></span>(defn process-with-maybe [x]
  (cc/mlet [a (if (even? x)
                (cmm/just x)
                (cmm/nothing))
            b (do
                (println (str "Incrementing " a))
                (-&gt; a inc cmm/just))]
    b))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 6.2. The mlet form</em></span></p></blockquote></div><p>In short, the <code class="literal">process-with-maybe</code> function defined in <span class="emphasis"><em>Example 6.2</em></span> checks whether a number is even, then prints a line and increments the number. As we use the <code class="literal">Maybe</code> type, the last two steps of printing a line and incrementing a value are performed only if the input <code class="literal">x</code> is even. In this way, an empty <code class="literal">Maybe</code> monad, created using the <code class="literal">nothing</code> function, can be used to short-circuit a composition of monads. We can verify this behavior of the <code class="literal">process-with-maybe</code> function in the REPL, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (process-with-maybe 2)</strong></span>
Incrementing 2
3
<span class="strong"><strong>user&gt; (process-with-maybe 3)</strong></span>
#&lt;Nothing@1ebd3fe: nil&gt;</pre></div><p>As shown here, the <code class="literal">process-with-maybe</code> function prints a line only when the supplied value <code class="literal">x</code> is an even number. If not, an empty <code class="literal">Maybe</code> monad instance is returned.</p><p>The previous examples describe how we can use the <code class="literal">Maybe</code> monad. The <code class="literal">cats</code> library also provides implementations of the <code class="literal">Either</code> and <code class="literal">Exception</code> monads, in the <code class="literal">cats.monads.either</code> and <code class="literal">cats.monads.exception</code> namespaces respectively. Let's explore a few constructs from the <code class="literal">cats.monads.exception</code> namespace.</p><p>We can create a new <code class="literal">Exception</code> monad instance using the <code class="literal">success</code> and <code class="literal">failure</code> functions. The <code class="literal">success</code> form can be passed any value, and it returns a monad that represents a successful step in a computation. On the other hand, the <code class="literal">failure</code> function must be passed a map containing an <code class="literal">:error</code> key that points to an exception, and returns a monad that represents a failure in a computation. The value or exception contained in an <code class="literal">Exception</code> monad can be obtained by dereferencing it (using the <code class="literal">deref</code> form or the <code class="literal">@</code> reader macro). Another<a class="indexterm" id="id00358"/> way to create an <code class="literal">Exception</code> monad instance is by using the <code class="literal">try-on</code> macro. The following output describes how these constructs can be used to create an instance of the <code class="literal">Exception</code> monad:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cme/success 1)</strong></span>
#&lt;Success@441a312 [1]&gt;
<span class="strong"><strong>user&gt; (cme/failure {:error (Exception.)})</strong></span>
#&lt;Failure@4812b43 [#&lt;java.lang.Exception&gt;]&gt;
<span class="strong"><strong>user&gt; (cme/try-on 1)</strong></span>
#&lt;Success@5141a5 [1]&gt;
<span class="strong"><strong>user&gt; @(cme/try-on 1)</strong></span>
1</pre></div><p>The <code class="literal">try-on</code> macro will return a failure instance of the <code class="literal">Exception</code> monad if the expression passed to it throws an error, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cme/try-on (/ 1 0))</strong></span>
#&lt;Failure@bc1115 [#&lt;java.lang.ArithmeticException&gt;]&gt;
<span class="strong"><strong>user&gt; (cme/try-on (-&gt; 1 (/ 0) inc))</strong></span>
#&lt;Failure@f2d11a [#&lt;java.lang.ArithmeticException&gt;]&gt;</pre></div><p>A failure instance of an <code class="literal">Exception</code> monad can be used to short-circuit a composition of monads. This means that binding an <code class="literal">Exception</code> monad to a function will not call the supplied function if the monad contains an error. This is similar to how exceptions are used to halt computations. We can verify this using the <code class="literal">bind</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cc/bind (cme/try-on (/ 1 1)) #(-&gt; % inc cc/return))</strong></span>
#&lt;Success@116ea43 [2]&gt;
<span class="strong"><strong>user&gt; (cc/bind (cme/try-on (/ 1 0)) #(-&gt; % inc cc/return))</strong></span>
#&lt;Failure@0x1c90acb [#&lt;java.lang.ArithmeticException&gt;]&gt;</pre></div><p>Instances of the <code class="literal">Exception</code> monad can also be created using the <code class="literal">try-or-else</code> and <code class="literal">try-or-recover</code> macros from the <code class="literal">cats.monads.exception</code> namespace. The <code class="literal">try-or-else</code> form must be passed an expression and a default value. If the expression passed to this form throws an exception, the default value is wrapped in an <code class="literal">Exception</code> monad instance and returned. The <code class="literal">try-or-recover</code> form must be passed a 1-arity function in place of the default value. In case an error is encountered, the <code class="literal">try-or-recover</code> macro will invoke the supplied function and relay the value returned by it. The <code class="literal">try-or-else</code> and <code class="literal">try-or-recover</code> f3orms are demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (cme/try-or-else (/ 1 0) 0)</strong></span>
#&lt;Success@bd15e6 [0]&gt;
<span class="strong"><strong>user&gt; (cme/try-or-recover (/ 1 0)</strong></span>
<span class="strong"><strong>                          (fn [e]</strong></span>
<span class="strong"><strong>                            (if (instance? ArithmeticException e)</strong></span>
<span class="strong"><strong>                              0</strong></span>
<span class="strong"><strong>                              :error)))</strong></span>
0</pre></div><p>In this way, monads can be used to model side effects using pure functions. We've demonstrated how we can<a class="indexterm" id="id00359"/> use the <code class="literal">Maybe</code> and <code class="literal">Exception</code> monad types. The <code class="literal">cats</code> library also implements other interesting monad types. There are monad laws as well, and any monad that we implement must conform to these laws. You are encouraged to learn more about the monad laws on your own.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec0043"/>Summary</h1></div></div></div><p>In this chapter, we talked about the notations and terminology used in category theory. We also discussed several algebraic types from category theory. Each of these abstractions have laws that must be satisfied by their implementations, and these laws can be thought of as optimizations for computations that use these algebraic types.</p><p>In the next chapter, we will look at a different paradigm of programming altogether—logic programming.</p></div>
<div class="chapter" title="Chapter&#xA0;7.&#xA0;Programming with Logic"><div class="titlepage"><div><div><h1 class="title"><a id="ch22"/>Chapter 7. Programming with Logic</h1></div></div></div><p>We will now take a step back from the realm of functional programming and explore a completely different paradigm—<span class="strong"><strong>logic programming</strong></span>. Logic programming has its own unique way of solving computational <a class="indexterm" id="id00360"/>problems. Of course, logic programming isn't the only way to solve a problem, but it's interesting to see what kind of problems can be easily solved with it.</p><p>Although logic programming and functional programming are two completely different paradigms, they do have a few commonalities. Firstly, both of these paradigms are forms of <span class="emphasis"><em>declarative programming</em></span>. Studies and papers have also shown that it is possible to implement the semantics of logic programming within a functional programming language. Hence, logic programming operates at a much higher degree of abstraction than functional programming. Logic programming is more suited for problems in which we have a set of rules, and we intend to find all the possible values that conform to these rules.</p><p>In this chapter, we look at logic programming in Clojure through the <code class="literal">core.logic</code> library. We will also study a few computational problems and how we can solve them in a concise and elegant manner using logic programming.</p><div class="section" title="Diving into logic programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec0044"/>Diving into logic programming</h1></div></div></div><p>In Clojure, logic<a class="indexterm" id="id00361"/> programming can be done using the <a class="indexterm" id="id00362"/>
<code class="literal">core.logic</code> library (<a class="ulink" href="https://github.com/clojure/core.logic/">https://github.com/clojure/core.logic/</a>). This library is a port of <span class="strong"><strong>miniKanren</strong></span>, which is a domain-specific language for logic <a class="indexterm" id="id00363"/>programming. miniKanren defines a set of simple constructs for creating logical relations and generating results from them.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0084"/>Note</h3><p>miniKanren was originally<a class="indexterm" id="id00364"/> implemented in the Scheme programming language. You can find out more about miniKanren at <a class="ulink" href="http://minikanren.org/">http://minikanren.org/</a>.</p></div></div><p>A program written using logic programming can be thought of as a set of logical relations. <span class="strong"><strong>Logical relations</strong></span> are the elementary building blocks of logic programming, just as functions are for functional programming. The terms <span class="emphasis"><em>relation</em></span> and <span class="emphasis"><em>constraint</em></span> are used interchangeably to refer to<a class="indexterm" id="id00365"/> a logical relation. The <code class="literal">core.logic</code> library is in fact an implementation of constraint-based logic programming.</p><p>A relation can be thought <a class="indexterm" id="id00366"/>of as a function that returns a goal, and a goal can either be a success or a failure. In the <code class="literal">core.logic</code> library, a goal is represented by the <code class="literal">succeed</code> and <code class="literal">fail</code> constants. Another interesting aspect of relations is that they can return multiple results, or even no results. This is analogous to a function that produces a sequence of values, which could be empty, as a result. Functions such as <code class="literal">keep</code> and <code class="literal">filter</code> fit this description perfectly.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0085"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[org.clojure/core.logic "0.8.10"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.core.logic :as l]
            [clojure.core.logic.fd :as fd]))</pre></div><p>The following examples can be found in <code class="literal">src/m_clj/c7/diving_into_logic.clj</code> of the book's source code.</p></div></div><div class="section" title="Solving logical relations"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec0022"/>Solving logical relations</h2></div></div></div><p>As a convention, relations have their name suffixed with an "o". For example, the <code class="literal">conso</code> construct from the <code class="literal">clojure.core.logic</code> namespace is a relation that represents the behavior of the <code class="literal">cons</code> function. Logical programming constructs that use multiple logical relations, such as <code class="literal">conde</code> and <code class="literal">matche</code>, end with an "e". We will explore these constructs later on in this chapter. Let's now<a class="indexterm" id="id00367"/> focus on how we can<a class="indexterm" id="id00368"/> solve problems with logical relations.</p><p>The <code class="literal">run*</code> macro, from the <code class="literal">clojure.core.logic</code> namespace, processes a number of goals to generate all possible results. The semantics of the <code class="literal">run*</code> form allow us to declare a number of logical variables that can be used in relations to return goals. The <code class="literal">run*</code> form returns a list of possible values for the logical variables it defines. An expression using the <code class="literal">run*</code> form and a set of relations is essentially a way of asking the question "What must the universe look like for these relations to be true?" to a computer and asking it to find the answer.</p><p>An equality test can be performed using the <code class="literal">run*</code> macro in combination with the <code class="literal">clojure.core.logic/==</code> form, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/== x 1))</strong></span>
(1)
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/== 1 0))</strong></span>
()</pre></div><p>Both the statements using the <code class="literal">run*</code> form in the preceding output find all possible values of the logical variable <code class="literal">x</code>. The relation <code class="literal">(l/== x 1)</code> returns a goal that succeeds when the value of <code class="literal">x</code> is equal to <code class="literal">1</code>. Obviously, the only value that <code class="literal">x</code> can have for this relation to succeed is <code class="literal">1</code>. The <code class="literal">run*</code> form evaluates this relation to return <code class="literal">1</code> in a list. On the other hand, the relation <code class="literal">(l/== 1 0)</code> is logically false, and thus produces no results when passed to the <code class="literal">run*</code> form. This means that there are no values of <code class="literal">x</code> for which <code class="literal">1</code> is equal to <code class="literal">0</code>.</p><p>A relation built using the <code class="literal">==</code> form from the <code class="literal">clojure.core.logic</code> namespace is called <span class="emphasis"><em>unification</em></span>. Unification is<a class="indexterm" id="id00369"/> often used in logic programming like variable assignment from other paradigms, as it's used to assign values to variables. Conversely, a <span class="emphasis"><em>disequality</em></span> represents a relation in which a logical variable cannot be equal to <a class="indexterm" id="id00370"/>a given value. The <code class="literal">clojure.core.logic/!=</code> form is used to construct a disequality relation, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/!= 1 1))</strong></span>
()
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/== 1 1))</strong></span>
(_0)</pre></div><p>The first statement in the preceding output produces no results since the relation <code class="literal">(l/!= 1 1)</code> is logically false. An interesting quirk is that the second statement, which has a goal that always succeeds produces a single result <code class="literal">_0</code>, which represents an <span class="emphasis"><em>unbound</em></span> logical variable. As we don't assign a value to <code class="literal">x</code> through unification, its value is said to be unbound. The symbols <code class="literal">_0</code>, <code class="literal">_1</code>, <code class="literal">_2</code>, and so on (also written as <code class="literal">_.0</code>, <code class="literal">_.1</code>, <code class="literal">_.2</code>, and so on) represent unbound logical variables in the context of a <code class="literal">run*</code> form.</p><p>The <code class="literal">clojure.core.logic/conso</code> form is useful in modeling the behavior of the standard <code class="literal">cons</code> function as a relation. It takes three arguments, of which two are the same as the <code class="literal">cons</code> function. The first two arguments passed to a <code class="literal">conso</code> form represent the head and tail of a sequence. </p><p>The third argument is a sequence that is expected to be returned on applying the <code class="literal">cons</code> function on the first two arguments. The <code class="literal">conso</code> relation can be demonstrated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/conso 1 [2 x]</strong></span>
<span class="strong"><strong>                 [1 2 3]))</strong></span>
(3)</pre></div><p>The expression using a <code class="literal">conso</code> relation, in the preceding output, will solve for values of <code class="literal">x</code> that produce the value <code class="literal">[1 2 3]</code> when a <code class="literal">cons</code> form is applied to the values <code class="literal">1</code> and <code class="literal">[2 x]</code>. Obviously, <code class="literal">x</code> must be <code class="literal">3</code> for this relation to be true, and hence the result <code class="literal">3</code> is produced.</p><p>Logical variables can be created without the use of a <code class="literal">run*</code> form using the <code class="literal">lvar</code> function from the <code class="literal">clojure.core.logic</code> namespace. Within a <code class="literal">run*</code> form, we can create local logical variables using the <code class="literal">clojure.core.logic/fresh</code> macro. Variables declared using a <code class="literal">fresh</code> form will not<a class="indexterm" id="id00371"/> be part of the final result<a class="indexterm" id="id00372"/> produced by the surrounding <code class="literal">run*</code> form. For example, consider the expressions using the <code class="literal">run*</code> forms in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x y]</strong></span>
<span class="strong"><strong>        (l/== x y)</strong></span>
<span class="strong"><strong>        (l/== y 1))</strong></span>
([1 1])
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/fresh [y]</strong></span>
<span class="strong"><strong>          (l/== x y)</strong></span>
<span class="strong"><strong>          (l/== y 1)))</strong></span>
(1)</pre></div><p>The first expression shown previously produces the vector <code class="literal">[1 1]</code> as a result, whereas the second expression produces <code class="literal">1</code> as the result. This is because we specify a single logical variable <code class="literal">x</code> and use a <code class="literal">fresh</code> form to internally declare the logical variable <code class="literal">y</code> in the second expression.</p><p>The <code class="literal">run*</code> form searches for results exhaustively from the set of relations provided to it. If we intend to find a limited number of results and avoid performing any additional computation to find any more results, we should use the <code class="literal">run</code> macro from the <code class="literal">clojure.core.logic</code> namespace instead. The <code class="literal">run</code> form has the same semantics of a <code class="literal">run*</code> form, but additionally requires the number of desired results to be passed to it as the first argument.</p><p>The <code class="literal">clojure.core.logic.fd</code> namespace provides us with several constructs to deal with relations that are constrained over a finite range of values. For example, suppose we wanted to find values within the range of <code class="literal">0</code> to <code class="literal">100</code> that are greater than <code class="literal">10</code>. We can easily express this relation using the <code class="literal">&gt;</code>, <code class="literal">in</code>, and <code class="literal">interval</code> forms from the <code class="literal">clojure.core.logic.fd</code> namespace and extract the first five values from it using a <code class="literal">run</code> form, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run 5 [x]</strong></span>
<span class="strong"><strong>        (fd/in x (fd/interval 0 100))</strong></span>
<span class="strong"><strong>        (fd/&gt; x 10))</strong></span>
(11 12 13 14 15)</pre></div><p>The preceding expression uses the <code class="literal">in</code> and <code class="literal">interval</code> forms to constrain the value of the variable <code class="literal">x</code>. The expression using these two forms ensures that <code class="literal">x</code> is within the range of <code class="literal">0</code> and <code class="literal">100</code>. Also, the <code class="literal">clojure.core.logic.fd/&gt;</code> function defines a relation in which <code class="literal">x</code> must be greater than <code class="literal">10</code>. The surrounding <code class="literal">run</code> form simply extracts the first five possible values of <code class="literal">x</code> from the relations supplied to it. There are also several other arithmetic comparison operators, namely <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>, and <code class="literal">&gt;=</code>, implemented in the <code class="literal">clojure.core.logic.fd</code> namespace. Instead of specifying a range of values to the <code class="literal">in</code> macro, we can also enumerate the possible values of a variable by using the <code class="literal">clojure.core.logic.fd/domain</code> form.</p><p>The <code class="literal">firsto</code> form can be <a class="indexterm" id="id00373"/>used to describe a relation in which the value in a given variable must be the first element in a collection. We can try out both the <code class="literal">domain</code> and <code class="literal">firsto</code> forms in the REPL as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run 1 [v a b x]</strong></span>
<span class="strong"><strong>        (l/== v [a b])</strong></span>
<span class="strong"><strong>        (fd/in a b x (fd/domain 0 1 2))</strong></span>
<span class="strong"><strong>        (fd/&lt; a b)</strong></span>
<span class="strong"><strong>        (l/firsto v x))</strong></span>
([[0 1] 0 1 0])</pre></div><p>In the preceding expression, we solve for the first set of values of <code class="literal">v</code>, <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">x</code> that satisfy the following relations. The value of <code class="literal">a</code> must be less than that of <code class="literal">b</code>, which is shown using the <code class="literal">&lt;</code> form, and both <code class="literal">a</code> and <code class="literal">b</code> must constitute the elements of a vector <code class="literal">v</code>, which is shown using the <code class="literal">==</code> form. Also, <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">x</code> must be equal to either <code class="literal">0</code>, <code class="literal">1</code>, or <code class="literal">2</code>, as described by a composition of the <code class="literal">in</code> and <code class="literal">domain</code> forms. Lastly, the first element of the vector <code class="literal">v</code> must be equal to the value <code class="literal">x</code>. These relations generate the vector <code class="literal">[0 1]</code> and the values <code class="literal">0</code>, <code class="literal">1</code>, and <code class="literal">0</code> for <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">x</code> respectively. Note the arity of the <code class="literal">in</code> form in the previous expression that allows multiple logical variables to be passed to it along with a constraint.</p></div><div class="section" title="Combining logical relations"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec0023"/>Combining logical relations</h2></div></div></div><p>The <code class="literal">clojure.core.logic/conde</code> form allows<a class="indexterm" id="id00374"/> us to specify multiple relations, and is a bit similar to the<a class="indexterm" id="id00375"/> standard <code class="literal">cond</code> form. For example, consider the following expression that uses the <code class="literal">conde</code> form:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/conde</strong></span>
<span class="strong"><strong>          ((l/== 'A x) l/succeed)</strong></span>
<span class="strong"><strong>          ((l/== 'B x) l/succeed)</strong></span>
<span class="strong"><strong>          ((l/== 'C x) l/fail)))</strong></span>
(A B)</pre></div><p>The preceding expression, which uses a <code class="literal">conde</code> form, performs equality checks for the symbols <code class="literal">A</code>, <code class="literal">B</code>, and <code class="literal">C</code> against the logical variable <code class="literal">x</code>. Only two of these checks produce a goal that succeeds, which is described using the <code class="literal">succeed</code> and <code class="literal">fail</code> constants in the clauses of the <code class="literal">conde</code> form. This logical branching by the <code class="literal">conde</code> form in the preceding expression can be illustrated through the following diagram:</p><div class="mediaobject"><img alt="Combining logical relations" src="graphics/B05024_07_01.jpg"/></div><p>The <code class="literal">conde</code> form in our<a class="indexterm" id="id00376"/> previous example creates a conditional check for three clauses. Out of these three clauses, only two succeed, and hence the symbols <code class="literal">A</code> and <code class="literal">B</code> are returned as results. We should note that the clauses defined in a <code class="literal">conde</code> form can take any number of relations. Also, the <a class="indexterm" id="id00377"/>use of the <code class="literal">l/succeed</code> constant is implicit, and we only need to use the <code class="literal">l/fail</code> constant to represent a goal that fails.</p><p>Another way to perform equality checks is by pattern matching. This can be done using the <code class="literal">clojure.core.logic/matche</code> form. The <code class="literal">matche</code> form is thus a more idiomatic way to define conditional branches involving logical variables, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/conde</strong></span>
<span class="strong"><strong>          ((l/== 'A x) l/succeed)</strong></span>
<span class="strong"><strong>          ((l/== 'B x) l/succeed)))</strong></span>
(A B)
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/matche [x]</strong></span>
<span class="strong"><strong>          (['A] l/succeed)</strong></span>
<span class="strong"><strong>          (['B] l/succeed)))</strong></span>
(A B)</pre></div><p>Both of the preceding expressions produce the same result. The only difference between these expressions is that the first one uses a <code class="literal">conde</code> form and the second one performs a pattern match using a <code class="literal">matche</code> form. Also, the <code class="literal">l/succeed</code> constant is implicit and does not need to be specified, similar to a <code class="literal">conde</code> form. The <code class="literal">_</code> wildcard is also supported by the <code class="literal">matche</code> form, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/matche [x]</strong></span>
<span class="strong"><strong>          (['A])</strong></span>
<span class="strong"><strong>          ([_] l/fail)))</strong></span>
(A)</pre></div><p>In the preceding expression, we solve for all values of <code class="literal">x</code> that match the pattern <code class="literal">'A</code>. All other cases fail, which<a class="indexterm" id="id00378"/> is described using the <code class="literal">_</code> wildcard and the <code class="literal">l/fail</code> constant. Of course, the pattern using the <code class="literal">_</code> wildcard is implicit and is only shown to describe how it can be used in a <code class="literal">matche</code> form.</p><p>The <code class="literal">matche</code> construct also<a class="indexterm" id="id00379"/> supports destructuring of sequences. A sequence can be destructured by a <code class="literal">matche</code> form using a dot (<code class="literal">.</code>) to delimit the head and tail of the sequence, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (l/fresh [y]</strong></span>
<span class="strong"><strong>          (l/== y [1 2 3])</strong></span>
<span class="strong"><strong>          (l/matche [y]</strong></span>
<span class="strong"><strong>            ([[1 . x]]))))</strong></span>
((2 3))</pre></div><p>In the preceding expression, the logical variable <code class="literal">x</code> must be <code class="literal">(2 3)</code> for the relation defined using the <code class="literal">matche</code> form to succeed. We can define relations using a syntax similar to the <code class="literal">defn</code> form using the <code class="literal">defne</code> macro from the <code class="literal">clojure.core.logic</code> namespace. The <code class="literal">defne</code> form allows us to define relations in pattern matching style. Incidentally, a lot of constructs in the <code class="literal">core.logic</code> library are defined using the <code class="literal">defne</code> form. For example, consider the definition of the <code class="literal">membero</code> relation in <span class="emphasis"><em>Example 7.1</em></span>:</p><div class="informalexample"><pre class="programlisting">(l/defne membero [x xs]
  ([_ [x . ys]])
  ([_ [y . ys]]
   (membero x ys)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 7.1: Defining the membero relation using the defne macro</em></span></p></blockquote></div><p>The <code class="literal">membero</code> relation is used to ensure that a value <code class="literal">x</code> is a member of the collections <code class="literal">xs</code>. The implementation of this relation destructures the collection <code class="literal">xs</code> into its head and tail parts. If the value <code class="literal">x</code> is the head of the collection <code class="literal">xs</code>, the relation succeeds, otherwise the relation is called recursively with the value <code class="literal">x</code> and the tail of the destructured list <code class="literal">ys</code>. We can try out this relation with the <code class="literal">run*</code> form in the REPL, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run* [x]</strong></span>
<span class="strong"><strong>        (membero x (range 5))</strong></span>
<span class="strong"><strong>        (membero x (range 3 10)))</strong></span>
(3 4)</pre></div><p>The preceding expression solves for values of <code class="literal">x</code> that are contained in the range <code class="literal">0</code> to <code class="literal">5</code> as well as in the range <code class="literal">3</code> to <code class="literal">10</code>. The results<a class="indexterm" id="id00380"/> <code class="literal">3</code> and <code class="literal">4</code> are produced from these two relations that use the <code class="literal">membero</code> form.</p><p>While dealing with logical variables, it's important to note that we cannot use standard functions to<a class="indexterm" id="id00381"/> perform any computation with them. In order to extract values from a bunch of logical variables, we have to use the <code class="literal">clojure.core.logic/project</code> form. For example, consider the following statement:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (l/run 2 [x y]</strong></span>
<span class="strong"><strong>        (l/membero x (range 1 10))</strong></span>
<span class="strong"><strong>        (l/membero y (range 1 10))</strong></span>
<span class="strong"><strong>        (l/project [x y]</strong></span>
<span class="strong"><strong>          (l/== (+ x y) 5)))</strong></span>
([1 4] [2 3])</pre></div><p>The preceding statement solves for two values of <code class="literal">x</code> and <code class="literal">y</code> such that they are both in the range <code class="literal">1</code> to <code class="literal">10</code> and their sum is equal to <code class="literal">5</code>. The values <code class="literal">[1 4]</code> and <code class="literal">[2 3]</code> are returned as results. The <code class="literal">project</code> form is used to extract the values of <code class="literal">x</code> and <code class="literal">y</code>, or else the <code class="literal">+</code> function would throw an exception.</p><p>Thus, the <code class="literal">core.logic</code> library provides us with a handful of constructs that can be used to define logical relations, combine them, and generate results from them.</p></div></div></div>
<div class="section" title="Thinking in logical relations"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec0045"/>Thinking in logical relations</h1></div></div></div><p>Now that we are well <a class="indexterm" id="id00382"/>versed with the various constructs from the <code class="literal">core.logic</code> library, let's look at some real world problems that can be solved through logic programming.</p><div class="section" title="Solving the n-queens problem"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec0024"/>Solving the n-queens problem</h2></div></div></div><p>The <span class="strong"><strong>n-queens problem</strong></span> is an<a class="indexterm" id="id00383"/> interesting problem that <a class="indexterm" id="id00384"/>can be implemented using logical relations. The objective of the n-queens problem is to place <span class="emphasis"><em>n</em></span> queens on an <span class="emphasis"><em>n </em></span>
<span class="emphasis"><em>x</em></span>
<span class="emphasis"><em> n</em></span> sized chessboard such that no two queens are a threat to each other. This problem is a generalization of the <span class="emphasis"><em>eight queens problem</em></span> published by Max Bezzel in 1848, which involves eight queens. In fact, we can actually solve the n-queens problem for any number of queens, as long as we are dealing with four or more queens. Traditionally, this problem can be solved using an algorithmic technique called <span class="emphasis"><em>backtracking</em></span>, which is essentially an exhaustive search for all possible solutions to a given problem. However, in this section, we will solve it using logical relations.</p><p>Let's first define how a queen can be used. As we all know, a queen can move as she wishes! A queen can move horizontally, vertically, or diagonally on a chessboard. If any other chess piece is on the<a class="indexterm" id="id00385"/> same path on which a queen can be moved, then the queen is a threat to it. The position of a chess piece on the chessboard can be specified using a pair of integers, just like how<a class="indexterm" id="id00386"/> Cartesian coordinates can be used to represent the position of a point on a plane. Suppose the pairs (<span class="emphasis"><em>x<sub>1</sub>, y<sub>1</sub>) and (x<sub>2</sub>, y<sub>2</sub></em></span>) represent the positions of two queens on the chessboard. As they can threaten each other horizontally, vertically, or diagonally, there are three distinct cases we must avoid:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The queens cannot be on the same vertical path, that is, <span class="emphasis"><em>x<sub>1</sub></em></span> equal to <span class="emphasis"><em>x<sub>2</sub></em></span>.</li><li class="listitem" style="list-style-type: disc">Similarly, the queens cannot be on the same horizontal path, that is, <span class="emphasis"><em>y<sub>1</sub></em></span> equal to <span class="emphasis"><em>y<sub>2</sub>.</em></span></li><li class="listitem" style="list-style-type: disc">The queens cannot be on the same diagonal path, in which case the ratio vertical and horizontal distance between them is either <code class="literal">1</code> or <code class="literal">-1</code>. This is actually a trick from coordinate geometry, and its proof is way out of the scope of our discussion. This case can be concisely represented by the following equations:<div class="mediaobject"><img alt="Solving the n-queens problem" src="graphics/B05024_07_03.jpg"/></div></li></ul></div><p>These are the only rules that determine whether two queens threaten each other. Yet if you think about them from a procedural or object-oriented perspective, implementing them could require a good amount of code. On the contrary, if we think in terms of relations, we can implement these three rules fairly easily using the <code class="literal">core.logic</code> library, as shown in the following <span class="emphasis"><em>Example 7.2</em></span>:</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0088"/>Note</h3><p>The following examples can be<a class="indexterm" id="id00387"/> found in <code class="literal">src/m_clj/c7/nqueens.clj</code> of the book's source code. This example is based on code from <span class="emphasis"><em>n-queens with core.logic </em></span>by Martin Trojer<span class="emphasis"><em> </em></span>(<a class="ulink" href="http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html">http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html</a>).</p></div></div><div class="informalexample"><pre class="programlisting">(l/defne safeo [q qs]
  ([_ ()])
  ([[x1 y1] [[x2 y2] . t]]
     (l/!= x1 x2)
     (l/!= y1 y2)
     (l/project [x1 x2 y1 y2]
       (l/!= (- x2 x1) (- y2 y1))
       (l/!= (- x1 x2) (- y2 y1)))
     (safeo [x1 y1] t)))

(l/defne nqueenso [n qs]
  ([_ ()])
  ([n [[x y] . t]]
     (nqueenso n t)
     (l/membero x (range n))
     (safeo [x y] t)))

(defn solve-nqueens [n]
  (l/run* [qs]
    (l/== qs (map vector (repeatedly l/lvar) (range n)))
    (nqueenso n qs)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 7.2: The n-queens problem</em></span></p></blockquote></div><p>In <span class="emphasis"><em>Example 7.2</em></span>, we define two relations, namely <code class="literal">safeo</code> and <code class="literal">nqueenso</code>, to describe the n-queens problem. Both of these relations must be passed a list <code class="literal">qs</code> as an argument, where <code class="literal">qs</code> contains coordinate <a class="indexterm" id="id00388"/>pairs that represent the positions of queens placed on the chessboard. They are interestingly recursive relations, and the termination is specified by the case in which <code class="literal">qs</code> is <a class="indexterm" id="id00389"/>empty.</p><p>The <code class="literal">safeo</code> relation is an implementation of the three rules that determine whether two queens threaten each other. Note the way this relation uses a <code class="literal">project</code> form to extract the values <code class="literal">x1</code>, <code class="literal">y1</code>, <code class="literal">x2</code>, and <code class="literal">y2</code> to handle the case in which two queens are on the same diagonal path. The <code class="literal">nqueenso</code> relation processes all positions of queens from the list <code class="literal">qs</code> and ensures that each queen is safe. The <code class="literal">solve-queens</code> function initializes <code class="literal">n</code> logical variables using the <code class="literal">clojure.core.logic/lvar</code> form. </p><p>The value <code class="literal">qs</code> is initialized a list of vector pairs that each contain a logical variable and a number within the range of <span class="emphasis"><em>0</em></span> to <span class="emphasis"><em>n</em></span>. In effect, we initialize the <span class="emphasis"><em>y</em></span> coordinates of all pairs, and solve for the <span class="emphasis"><em>x</em></span> coordinates. The reasoning behind this is that as we are solving for <span class="emphasis"><em>n</em></span> queens on a board with <span class="emphasis"><em>n</em></span> columns and <span class="emphasis"><em>n</em></span> rows, and each row will have a queen placed on it.</p><p>The <code class="literal">solve-nqueens</code> function returns a list of solutions that each contain a list of coordinate pairs. We can print this data in a more intuitive representation by using the <code class="literal">partition</code> and <code class="literal">clojure.pprint/pprint</code> functions, as shown in <span class="emphasis"><em>Example 7.3</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn print-nqueens-solution [solution n]
  (let [solution-set (set solution)
        positions (for [x (range n)
                        y (range n)]
                    (if (contains? solution-set [x y]) 1 0))]
    (binding [clojure.pprint/*print-right-margin* (* n n)]
      (clojure.pprint/pprint
       (partition n positions)))))

(defn print-all-nqueens-solutions [solutions n]
  (dorun (for [i (-&gt; solutions count range)
               :let [s (nth solutions i)]]
           (do
             (println (str "\nSolution " (inc i) ":"))
             (print-nqueens-solution s n)))))

(defn solve-and-print-nqueens [n]
  (-&gt; (solve-nqueens n)
      (print-all-nqueens-solutions n)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 7.3: The n-queens problem (continued)</em></span></p></blockquote></div><p>Now, we just need to call the <code class="literal">solve-and-print-nqueens</code> function by passing it the number of queens. Let's try<a class="indexterm" id="id00390"/> to use this function to solve the<a class="indexterm" id="id00391"/> n-queens problem for four queens, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (solve-and-print-nqueens 4)</strong></span>

Solution 1:
((0 1 0 0)
 (0 0 0 1)
 (1 0 0 0)
 (0 0 1 0))

Solution 2:
((0 0 1 0)
 (1 0 0 0)
 (0 0 0 1)
 (0 1 0 0))
nil</pre></div><p>The <code class="literal">solve-and-print-nqueens</code> function prints two solutions for four queens. Each solution is printed as a bunch of nested lists, in which each inner list represents a row on the chessboard. The value <code class="literal">1</code> indicates that a queen is placed on that position on the chessboard. As you can see, none of the four queens threaten each other in either of the two solutions.</p><p>In this way, the <code class="literal">solve-nqueens</code> function uses relations to solve the n-queens problem. We mentioned earlier that the n-queens problem originally involved eight queens. There are totally 92 distinct solutions for eight queens, and the <code class="literal">solve-nqueens</code> function can find every single one of them. You <a class="indexterm" id="id00392"/>are encouraged to try this out by<a class="indexterm" id="id00393"/> passing the value <code class="literal">8</code> to the <code class="literal">solve-and-print-nqueens</code> function and verifying the solutions it prints.</p></div><div class="section" title="Solving a Sudoku puzzle"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec0025"/>Solving a Sudoku puzzle</h2></div></div></div><p>Some of us may already be<a class="indexterm" id="id00394"/> in love with the intuitive and mesmerizing Sudoku puzzles that we find in newspapers and magazines. This is another problem that involves logical rules. A Sudoku board is a <span class="emphasis"><em>9 </em></span>
<span class="emphasis"><em>x</em></span>
<span class="emphasis"><em> 9</em></span> grid on which we can place digits. The grid is divided into nine smaller grids, each of which is further divided into <span class="emphasis"><em>3 </em></span>
<span class="emphasis"><em>x</em></span>
<span class="emphasis"><em> 3</em></span> grids that contain digits. These smaller grids are also called <span class="emphasis"><em>squares</em></span> or <span class="emphasis"><em>boxes</em></span>. Some of the squares will be filled with boxes. The goal is to place digits on all positions on the grid such that <a class="indexterm" id="id00395"/>each row, each column, and each of the smaller grids all contain distinct digits in the range 1 through 9.</p><p>Let's implement the rules of a Sudoku puzzle in this way. We will create a logical variable for every possible position of a digit on a Sudoku board and solve for their values using the rules of the puzzle. The initial values of the digits on a Sudoku board can be provided as a single vector comprising of 81 numbers. In this implementation, we introduce a couple of new constructs that are useful in concisely describing the rules of a Sudoku puzzle. The <code class="literal">everyg</code> function from the <code class="literal">clojure.core.logic</code> namespace can be used to apply a relation over a list of logical variables, thus ensuring that a relation is true for all the supplied logical variables. We must also ensure that the logical variables in a row, column, and <span class="emphasis"><em>3 </em></span>
<span class="emphasis"><em>x</em></span>
<span class="emphasis"><em> 3</em></span> sized grid in a Sudoku puzzle are distinct. This can done by using the <code class="literal">clojure.core.logic.fd/distinct</code> function. An implementation of this design of a Sudoku solver is shown in <span class="emphasis"><em>Example 7.4</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0089"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c7/sudoku.clj</code> of the book's source code.</p></div></div><div class="informalexample"><pre class="programlisting">(l/defne init-sudoku-board [vars puzzle]
  ([[] []])
  ([[_ . vs] [0 . ps]] (init-sudoku-board vs ps))
  ([[n . vs] [n . ps]] (init-sudoku-board vs ps)))

(defn solve-sudoku [puzzle]
  (let [board (repeatedly 81 l/lvar)
        rows (into [] (map vec (partition 9 board)))
        cols (apply map vector rows)
        val-range (range 1 10)
        in-range (fn [x]
                   (fd/in x (apply fd/domain val-range)))
        get-square (fn [x y]
                     (for [x (range x (+ x 3))
                           y (range y (+ y 3))]
                       (get-in rows [x y])))
        squares (for [x (range 0 9 3)
                      y (range 0 9 3)]
                  (get-square x y))]
    (l/run* [q]
      (l/== q board)
      (l/everyg in-range board)
      (init-sudoku-board board puzzle)
      (l/everyg fd/distinct rows)
      (l/everyg fd/distinct cols)
      (l/everyg fd/distinct squares))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 7.4: A Sudoku solver</em></span></p></blockquote></div><p>In <span class="emphasis"><em>Example 7.4</em></span>, the <code class="literal">init-sudoku-board</code> relation initializes the logical variables <code class="literal">vars</code> from the puzzle <code class="literal">puzzle</code>, and the <code class="literal">solve-sudoku</code> function finds all possible solutions of the given puzzle. The <code class="literal">solve-sudoku</code> function creates the logical variables through a composition of the <code class="literal">repeatedly</code> and <code class="literal">clojure.core.logic/lvar</code> forms. These variables are then partitioned into rows, columns, and squares, represented by the variables <code class="literal">rows</code>, <code class="literal">cols</code>, and <a class="indexterm" id="id00396"/>
<code class="literal">squares</code> respectively. The <code class="literal">solve-sudoku</code> function then initializes the logical variables using the <code class="literal">init-sudoku-board</code> form, and uses a composition of the <code class="literal">everyg</code> and <code class="literal">distinct</code> forms to ensure that the rows, columns, and squares of a solution contain distinct values. All the logical variables are also bound to the range <code class="literal">1</code> through <code class="literal">9</code> using<a class="indexterm" id="id00397"/> the internally defined <code class="literal">in-range</code> function.</p><p>The <code class="literal">solve-sudoku</code> function defined in <span class="emphasis"><em>Example 7.4</em></span> takes a vector of values representing the initial state of a Sudoku board as an argument and returns a list of solutions in which each solution is a vector. As a plain vector isn't really an intuitive representation of a Sudoku board, let's define a simple function to find all solutions of a given puzzle and print the solutions, as shown in <span class="emphasis"><em>Example 7.5</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn solve-and-print-sudoku [puzzle]
  (let [solutions (solve-sudoku puzzle)]
    (dorun (for [i (-&gt; solutions count range)
                 :let [s (nth solutions i)]]
             (do
               (println (str "\nSolution " (inc i) ":"))
               (clojure.pprint/pprint
                (partition 9 s)))))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 7.5: A Sudoku solver (continued)</em></span></p></blockquote></div><p>The <code class="literal">solve-and-print-sudoku</code> function in <span class="emphasis"><em>Example 7.5</em></span> calls the <code class="literal">solve-sudoku</code> function to determine all possible solutions to a given Sudoku puzzle and prints the results using the <code class="literal">partition</code> <a class="indexterm" id="id00398"/>and <code class="literal">clojure.pprint/pprint</code> functions. Now, let's define a simple Sudoku puzzle to solve, as shown in <span class="emphasis"><em>Example 7.6</em></span>.</p><div class="informalexample"><pre class="programlisting">(def puzzle-1
  [0 9 0 0 0 0 0 5 0
   6 0 0 0 5 0 0 0 2
   1 0 0 8 0 4 0 0 6
   0 7 0 0 8 0 0 3 0
   8 0 3 0 0 0 2 0 9
   0 5 0 0 3 0 0 7 0
   7 0 0 3 0 2 0 0 5
   3 0 0 0 6 0 0 0 7
   0 1 0 0 0 0 0 4 0])</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 7.6: A Sudoku solver (continued)</em></span></p></blockquote></div><p>Now, let's pass the vector <code class="literal">puzzle-1</code> to the <code class="literal">solve-and-print-sudoku</code> function to print all possible solutions to it, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (solve-and-print-sudoku puzzle-1)</strong></span>

Solution 1:
((4 9 8 6 2 3 7 5 1)
 (6 3 7 9 5 1 4 8 2)
 (1 2 5 8 7 4 3 9 6)
 (9 7 1 2 8 6 5 3 4)
 (8 4 3 5 1 7 2 6 9)
 (2 5 6 4 3 9 1 7 8)
 (7 6 9 3 4 2 8 1 5)
 (3 8 4 1 6 5 9 2 7)
 (5 1 2 7 9 8 6 4 3))
nil</pre></div><p>The <code class="literal">solve-sudoku</code> function<a class="indexterm" id="id00399"/> finds a single solution to the Sudoku puzzle represented by the vector <code class="literal">puzzle-1</code> as shown previously. The puzzle represented by <code class="literal">puzzle-1</code> and its solution are shown on a Sudoku board in the following illustration:</p><div class="mediaobject"><img alt="Solving a Sudoku puzzle" src="graphics/B05024_07_02.jpg"/><div class="caption"><p>Example 7.7: A Sudoku solver (continued)</p></div></div><p>It is very likely that a Sudoku <a class="indexterm" id="id00400"/>puzzle has multiple solutions. For example, the Sudoku puzzle represented by <code class="literal">puzzle-2</code> in <span class="emphasis"><em>Example 7.7</em></span> has eight distinct<a class="indexterm" id="id00401"/> solutions. You're more than welcome to find the solutions to this puzzle using the <code class="literal">solve-and-print-sudoku</code> function:</p><div class="informalexample"><pre class="programlisting">(def puzzle-2
  [0 8 0 0 0 9 7 4 3
   0 5 0 0 0 8 0 1 0
   0 1 0 0 0 0 0 0 0
   8 0 0 0 0 5 0 0 0
   0 0 0 8 0 4 0 0 0
   0 0 0 3 0 0 0 0 6
   0 0 0 0 0 0 0 7 0
   0 3 0 5 0 0 0 8 0
   9 7 2 4 0 0 0 5 0])</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 7.7: A Sudoku solver (continued)</em></span></p></blockquote></div><p>In conclusion, we can implement the rules of a Sudoku puzzle as logical relations using the <code class="literal">core.logic</code> library.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec0046"/>Summary</h1></div></div></div><p>In this chapter, we looked at how Clojure can be used for logic programming. We introduced the <code class="literal">core.logic</code> library by exploring the various constructs provided by this library. We also studied how we can implement solutions to the n-queens problem and a Sudoku puzzle using the <code class="literal">core.logic</code> library.</p><p>In the following chapter, we will get back on our journey through functional programming and talk about handling asynchronous tasks in Clojure.</p></div>
<div class="chapter" title="Chapter&#xA0;8.&#xA0;Leveraging Asynchronous Tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch23"/>Chapter 8. Leveraging Asynchronous Tasks</h1></div></div></div><p>The term <span class="strong"><strong>asynchronous programming</strong></span> refers to defining tasks that are executed <span class="emphasis"><em>asynchronously</em></span> on different<a class="indexterm" id="id00402"/> threads of execution. While this is similar to multithreading, there are a few subtle differences. Firstly, a thread or a future will remain allocated to a single operating system thread until completion. This leads to the fact that is there can only be a limited number of futures that can be executed concurrently, depending on the number of processing cores available. On the other hand, asynchronous tasks are scheduled for execution on threads from a thread pool. This way, a program can have thousands, or even millions of asynchronous tasks running concurrently. An asynchronous task can be suspended at any time, or <span class="emphasis"><em>parked</em></span>, and the underlying thread of execution can be reallocated to another task. Asynchronous programming constructs also allow the definition of an asynchronous task to look like a sequence of synchronous calls, but each call could potentially be executed asynchronously.</p><p>In this chapter, we will explore various libraries and constructs that can be used for asynchronous programming in Clojure. First off, we will take a look at <span class="emphasis"><em>processes</em></span> and <span class="emphasis"><em>channels</em></span> in the <code class="literal">core.async</code> library for asynchronous programming. Later, we will explore <span class="emphasis"><em>actors</em></span> from the <span class="emphasis"><em>Pulsar</em></span> library. Processes and channels are constructs similar to <span class="emphasis"><em>go-routines </em></span>in the Go programming language. On the other hand, actors were first popularized in the Erlang programming language. All of these techniques are different ways of structuring code that executes asynchronously. We must understand that the theory behind these concepts isn't really novel, and more implementations of these theories have been springing up since the rise of distributed and multi-core architectures. With that in mind, let's start off on our journey into asynchronous programming.</p><div class="section" title="Using channels"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec0047"/>Using channels</h1></div></div></div><p>The <a class="indexterm" id="id00403"/>
<code class="literal">core.async</code>
<a class="indexterm" id="id00404"/> library (<a class="ulink" href="https://github.com/clojure/core.async">https://github.com/clojure/core.async</a>) facilitates asynchronous programming in Clojure. Through this library, we can use asynchronous constructs that run on both the JVM and web browsers without dealing with how they are scheduled for execution on low-level threads. This<a class="indexterm" id="id00405"/> library is an implementation of the theory in the paper <span class="strong"><strong>Communicating Sequential Processes</strong></span> (<span class="strong"><strong>CSPs</strong></span>), originally published in the late '70s by C. A. R. Hoare. The bottom line of CSPs is that any system that processes some input and provides an output can be comprised of smaller <a class="indexterm" id="id00406"/>subsystems, and each subsystem can be defined in terms of <span class="emphasis"><em>processes</em></span> and <span class="emphasis"><em>queues</em></span>. A queue simply buffers data, and a process can read from and write to<a class="indexterm" id="id00407"/> several queues. Here, we shouldn't confuse the term <span class="emphasis"><em>process</em></span> with an operating system process. In the context of CSPs, a process is simply a sequence of instructions that interacts with some data stored<a class="indexterm" id="id00408"/> in queues. Several processes may exist in a given system and queues are a means of conveying data between them. A process that takes data from a single queue and outputs data to another queue can be illustrated as follows:</p><div class="mediaobject"><img alt="Using channels" src="graphics/B05024_08_01.jpg"/></div><p>As shown in the preceding diagram, input data goes into a queue, a process manipulates this data through the queue, and finally, writes the output data to another queue. The <code class="literal">core.async</code> library essentially provides first-class support for creating processes and queues. Queues are dubbed as <a class="indexterm" id="id00409"/>
<span class="strong"><strong>channels</strong></span> in the <code class="literal">core.async</code> library, and can be created using the<a class="indexterm" id="id00410"/> <code class="literal">chan</code> function. Processes can be created using <code class="literal">go</code> and <code class="literal">thread</code> macros. Let's dive a bit deeper into the details.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0090"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[org.clojure/core.async " 0.1.346.0-17112a-alpha"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.core.async :as a]))</pre></div></div></div><p>Processes, created using the <code class="literal">thread</code> and <code class="literal">go</code> forms, are scheduled for execution on thread pools. In fact, we can create several thousands of these processes in a program as they do not require their own dedicated thread. On the other hand, creating a large number of threads or futures would result in the excessive jobs being queued for execution. This imposes a practical limit on the number of threads or futures we can run concurrently. Hence, the <code class="literal">core.async</code> library, and CSPs in general, allows us to model a system as a large number of lightweight and concurrent processes.</p><p>Channels can be thought of as data structures for managing the state between processes. The <code class="literal">chan</code> function <a class="indexterm" id="id00411"/>from the <code class="literal">core.async</code> namespace returns a channel that<a class="indexterm" id="id00412"/> can be read from and written to by several concurrent processes. Channels are <span class="emphasis"><em>unbuffered</em></span> by default, which<a class="indexterm" id="id00413"/> means a write operation to a channel will not complete until a read operation is invoked on it concurrently and vice versa. We can also create a <span class="emphasis"><em>buffered</em></span> channel by<a class="indexterm" id="id00414"/> specifying a number to the <code class="literal">chan</code> function to indicate the buffer size. A buffered channel will allow a certain number of values to be written to it without blocking, and the buffered values can then be read. A channel can be closed using the <code class="literal">close!</code> function from the <code class="literal">core.async</code> namespace.</p><p>We can also create a buffered channel by passing a buffer object to the <code class="literal">chan</code> function. A buffer object can be created using the <code class="literal">buffer</code>, <code class="literal">dropping-buffer</code>, or <code class="literal">sliding-buffer</code> functions, and these functions require a number, indicating the size of the buffer, as an argument. Either of the expressions <code class="literal">(a/chan (a/buffer n))</code> or <code class="literal">(a/chan n)</code> can be used to create a channel that can buffer <code class="literal">n</code> values, and the channel will block write operations to it once it is filled with <code class="literal">n</code> values. The<a class="indexterm" id="id00415"/> <code class="literal">dropping-buffer</code> function creates a buffer that drops newly added values once it's full. Conversely, a buffer created using the <a class="indexterm" id="id00416"/>
<code class="literal">sliding-buffer</code> function will drop the oldest values added to it once it is completely filled.</p><p>The <code class="literal">core.async</code> library provides a handful of constructs for reading from and writing to channels, and the values passed to and returned by these constructs conform to a few simple rules. A read operation on a channel returns a value from the channel, or <code class="literal">nil</code> if the channel is closed. A write operation will return <code class="literal">true</code> if it succeeds, or <code class="literal">false</code> if the channel is closed and the write operation couldn't be completed. We can read the buffered data from a closed channel, but once the channel is exhausted of data, a read operation on it will return <code class="literal">nil</code>. The arguments to the read and write operations for channels conform to the following pattern:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first argument to any operation is a channel.</li><li class="listitem">A write operation must be passed a value to put onto a channel in addition to the channel itself.</li></ol></div><p>At this point, we should note that in the context of channels, the terms "write" and "put" can be used interchangeably, and similarly, the terms "read" and "take" refer to the same operation. The <code class="literal">take!</code> and <code class="literal">put!</code> functions take data and put data onto a queue. Both these functions return immediately, and can be passed a callback function as an argument in addition to the usual parameters. Similarly, the <code class="literal">&lt;!!</code> and <code class="literal">&gt;!!</code> functions can be used to read from and write to a channel, respectively. However, the <code class="literal">&lt;!!</code> operation can block the calling thread if there is no data in the supplied channel and the <code class="literal">&gt;!!</code> operation will be blocked if there is no more buffer space available in a given channel. These two operations are meant to be used within a <code class="literal">thread</code> form. Finally, the parking read and write functions, namely <code class="literal">&lt;!</code> and <code class="literal">&gt;!</code>, can be used within a <code class="literal">go</code> form to interact with a channel. Both the <code class="literal">&lt;!</code> and <code class="literal">&gt;!</code> operations will park the state of the task and release the underlying thread of execution if an operation cannot be completed immediately.</p><p>Let's move on to the details of creating processes using the <code class="literal">core.async</code> library. The <code class="literal">core.async/thread</code> macro is used to create a single-threaded process. It is similar to the <code class="literal">future</code> form in<a class="indexterm" id="id00417"/> the sense that the body of a <code class="literal">thread</code> form is executed on a new thread and a call to a <code class="literal">thread</code> form returns immediately. A <code class="literal">thread</code> form returns a channel from which the output of its body can be read. This makes the <code class="literal">thread</code> form a bit more convenient than the standard <code class="literal">future</code> form for interacting with channels, and is thus preferred over a <code class="literal">future</code> form. The <code class="literal">&lt;!!</code> and <code class="literal">&gt;!!</code> functions can be used within a <code class="literal">thread</code> form to interact with a channel.</p><p>To create an asynchronous process that can be parked and scheduled for execution, we must use the <code class="literal">go</code> macro from the <code class="literal">core.async</code> namespace. Similar to the <code class="literal">thread</code> form, it returns a channel from which the output of its body can be read. All channel operations within the body of the <code class="literal">go</code> form will park, rather than blocking the underlying thread of execution. This implies that the executing thread will not be blocked and can be reallocated to another asynchronous process. Thus, the execution of a number of <code class="literal">go</code> forms can be interleaved over a much lesser number of actual threads. We must ensure that no thread-specific operations, such as <code class="literal">Thread/sleep</code>, are made within a <code class="literal">go</code> form, as such operations affect the underlying thread of execution. Within a <code class="literal">go</code> form, we must always use the <code class="literal">&lt;!</code> and <code class="literal">&gt;!</code> parking forms to read from and write to a channel.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0092"/>Note</h3><p>Visit <a class="ulink" href="https://clojure.github.io/core.async/">https://clojure.github.io/core.async/</a> for the complete documentation on all the functions<a class="indexterm" id="id00418"/> and macros in the <code class="literal">core.async</code> library.</p></div></div><p>The <code class="literal">go-loop</code> macro is an asynchronous version of the <code class="literal">loop</code> form, and accepts a vector of bindings as its first argument, followed by any number of forms that must be executed. The body of a <code class="literal">go-loop</code> form will be internally executed within a <code class="literal">go</code> form. The <code class="literal">go-loop</code> construct is often used to create asynchronous event loops that have their own localized state. As an example, let's consider the simple <code class="literal">wait-and-print</code> function that sets off a process that reads from a given channel, as shown in <span class="emphasis"><em>Example 8.1</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0093"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c8/async.clj</code> of the book's source code.</p></div></div><div class="informalexample"><pre class="programlisting">(defn wait-and-print [c]
  (a/go-loop [n 1]
    (let [v (a/&lt;! c)]
      (when v
        (println (str "Got a message: " v))
        (println (str "Got " n " messages so far!"))
        (recur (inc n)))))
  (println "Waiting..."))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.1: A function that asynchronously reads from a channel</em></span></p></blockquote></div><p>The <code class="literal">wait-and-print</code> function shown previously will repeatedly read from the channel <code class="literal">c</code> passed to it. The <code class="literal">when</code> form is used to check if the value read from channel, represented by <code class="literal">v</code>, is not <code class="literal">nil</code>, since <code class="literal">nil</code> could be returned from the <code class="literal">&lt;!</code> form if the channel <code class="literal">c</code> is closed. The <code class="literal">go-loop</code> form in the previous example also counts the number of values read from the channel using the variable <code class="literal">n</code>. On receiving a value from the channel, some information is printed <a class="indexterm" id="id00419"/>and the body is looped over using a <code class="literal">recur</code> form. We can create a channel, pass it to the <code class="literal">wait-and-print</code> function and observe the output of sending values to the channel, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def c (a/chan))</strong></span>
#'user/c
<span class="strong"><strong>user&gt; (wait-and-print c)</strong></span>
Waiting...
nil
<span class="strong"><strong>user&gt; (a/&gt;!! c :foo)</strong></span>
true
Got a message: :foo
Got 1 messages so far!
<span class="strong"><strong>user&gt; (a/&gt;!! c :bar)</strong></span>
true
Got a message: :bar
Got 2 messages so far!</pre></div><p>As shown previously, a call to the <code class="literal">wait-and-print</code> function starts an asynchronous event loop that reads from the channel <code class="literal">c</code>. On sending a value to the channel <code class="literal">c</code> using a <code class="literal">&gt;!!</code> form, the value gets printed along with a total count of values sent to the channel. Also, calls to the <code class="literal">&gt;!!</code> form return the value <code class="literal">true</code> immediately. Now, let's see what happens when we close the channel <code class="literal">c</code> using the <code class="literal">close!</code> function, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (a/close! c)</strong></span>
nil
<span class="strong"><strong>user&gt; (a/&gt;!! c :foo)</strong></span>
false</pre></div><p>After closing the channel <code class="literal">c</code>, the <code class="literal">&gt;!!</code> form returns <code class="literal">false</code> when it is applied to the channel, which implies that the channel <code class="literal">c</code> doesn't allow any more values to be put into it. Also, nothing gets printed, which means that the asynchronous routine that was trying to take values from the channel <code class="literal">c</code> has terminated.</p><p>Another way to send values into a channel is by using the <code class="literal">onto-chan</code> function from the <code class="literal">core.async</code> namespace. This function must be passed a channel and a collection of values to put <span class="emphasis"><em>onto</em></span> the channel, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def c (a/chan 4))</strong></span>
#'user/c
<span class="strong"><strong>user&gt; (a/onto-chan c (range 4))</strong></span>
#&lt;ManyToManyChannel@0x86f03a&gt;
<span class="strong"><strong>user&gt; (repeatedly 4 #(-&gt; c a/&lt;!!))</strong></span>
(0 1 2 3)</pre></div><p>The <code class="literal">onto-chan</code> function will close the channel it has been passed once the supplied collection of values is entirely put onto the channel. To avoid closing the channel, we can specify <code class="literal">false</code> as an additional argument to the <code class="literal">onto-chan</code> function.</p><p>The <code class="literal">alts!</code> and <code class="literal">alts!!</code> functions from the <code class="literal">core.async</code> namespace can be used to wait for completion of <a class="indexterm" id="id00420"/>one of several channel operations. The main distinction between these functions is that the <a class="indexterm" id="id00421"/>
<code class="literal">alts!</code> function is intended for use within a <code class="literal">go</code> form and will park the current thread, unlike the <code class="literal">alts!!</code> function that blocks the current thread <a class="indexterm" id="id00422"/>and must be used in a <code class="literal">thread</code> form. Both these functions must be passed a vector of channels and return a vector of two elements. The first element in the returned vector represents the value for a take operation or a Boolean value for a put operation, and the second one indicates the channel on which the operation completed. We can also specify a default value as a keyword argument with the key <code class="literal">:default</code> to the <code class="literal">alts!</code> and <code class="literal">alts!!</code> functions. The default value will be returned if none of the operations supplied to the <code class="literal">alts!</code> or <code class="literal">alts!!</code> forms have completed.</p><p>The <code class="literal">core.async</code> library provides two versatile macros, namely <code class="literal">alt!</code> and <code class="literal">alt!!</code>, to wait for one among several channel operations to be complete. As you may have already guessed, an <code class="literal">alt!</code> form parks the current task, and an <code class="literal">alt!!</code> form blocks the current thread. Both these forms can also return a default value when used with the <code class="literal">:default</code> keyword argument. We can pass several clauses to the <code class="literal">alt!</code> and <code class="literal">alt!!</code> forms for reading from and writing to several channels. The <code class="literal">alt!</code> form in <span class="emphasis"><em>Example 8.2</em></span> describes the clauses supported by the <code class="literal">alt!</code> and <code class="literal">alt!!</code> macros:</p><div class="informalexample"><pre class="programlisting">(defn process-channels [c0 c1 c2 c3 c4 c5]
  (a/go
    (a/alt!
      ;; read from c0, c1, c2, c3
      c0 :r
      c1 ([v] (str v))
      [c2 c3] ([v c] (str v))
      ;; write to c4, c5
      [[c4 :v1] [c5 :v2]] :w)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.2: An asynchronous process implemented using the alt! form</em></span></p></blockquote></div><p>The preceding <code class="literal">process-channels</code> function takes six channels as its arguments, and uses an <code class="literal">alt!</code> form within a <code class="literal">go</code> form to perform asynchronous operations on these channels. The channels <code class="literal">c0</code>, <code class="literal">c1</code>, <code class="literal">c2</code>, and <code class="literal">c3</code> are read, and the channels <code class="literal">c4</code> and <code class="literal">c5</code> are written to. The <code class="literal">alt!</code> form tries to read from the channel <code class="literal">c0</code> and returns the keyword <code class="literal">:r</code> if the operation completes first. The channel <code class="literal">c1</code> is also read from, but the right hand side of its clause contains a parameterized expression with the argument <code class="literal">v</code>, where <code class="literal">v</code> is the value read from the channel. The channels <code class="literal">c2</code> and <code class="literal">c3</code> are passed as a vector in one of the clauses of the <code class="literal">alt!</code> form shown previously, and this clause uses a parameterized expression with the arguments <code class="literal">v</code> and <code class="literal">c</code>, where <code class="literal">c</code> is the channel on which the read operation completed first and <code class="literal">v</code> is the value read from the channel. Write operations are specified in an <code class="literal">alt!</code> form as a nested vector, where each inner vector contains a channel and a value to put <a class="indexterm" id="id00423"/>onto the channel. The channels <code class="literal">c4</code> and <code class="literal">c5</code> are written to in the previous <code class="literal">alt!</code> form, and the value <code class="literal">:w</code> is returned if either of the two write operations completes. In this way, we can specify clauses to the <code class="literal">alt!</code> and <code class="literal">alt!!</code> forms to read to and write from several channels, and return a value based on which channel operation completes first.</p><p>Another facility that is often required in asynchronous programming is the ability to specify a <span class="emphasis"><em>timeout</em></span> with a <a class="indexterm" id="id00424"/>given operation. By the term <span class="emphasis"><em>timeout</em></span>, we mean a specified amount of time after which the current operation is aborted. The <code class="literal">core.async</code> has an intuitive method for specifying operations with timeouts. This is done using the <code class="literal">core.async/timeout</code> function, which must be supplied a time interval in milliseconds and returns a channel that closes after the specified amount of time. If we intend to perform an operation with a timeout, we use one of the <code class="literal">alt*</code> forms with a channel returned by the <code class="literal">timeout</code> function. </p><p>This way, an operation with a channel returned by a <code class="literal">timeout</code> form will surely complete after the specified amount of time. The <code class="literal">timeout</code> form is also useful in parking or blocking the current thread of execution for a given amount of time. For example, a blocking read operation from a channel returned by a <code class="literal">timeout</code> form will block the current thread for the specified time interval, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (time  (a/&lt;!! (a/timeout 1000)))</strong></span>
"Elapsed time: 1029.502223 msecs"
nil</pre></div><p>We have now covered the basics of processes and channels in the <code class="literal">core.async</code> library.</p><div class="section" title="Customizing channels"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec0026"/>Customizing channels</h2></div></div></div><p>Channels can also be<a class="indexterm" id="id00425"/> programmed to modify or compute values from those put into them. A read operation, for instance, on a channel could invoke a computation using the values buffered in the same channel, or even other channels. The <code class="literal">reduce</code> function from the <code class="literal">core.async</code> namespace can be used to compute values from channels and has more-or-less the same semantics as that of the standard <code class="literal">reduce</code> function. This variant of the <code class="literal">reduce</code> function requires a reducing operation, an initial value for the reduction operation and a channel to be passed to it, and it will return a channel from which the result can be read. Also, this function only produces values once the channel passed to it is closed. For example, consider the following code that computes a string from the values in a channel using the <code class="literal">core.async/reduce</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def c (a/chan 5))</strong></span>
#'user/c
<span class="strong"><strong>user&gt; (a/onto-chan c (range 5))</strong></span>
#&lt;ManyToManyChannel@0x4adadd&gt;
<span class="strong"><strong>user&gt; (def rc (a/reduce #(str %1 %2 " ") "" c))</strong></span>
#'user/rc
<span class="strong"><strong>user&gt; (a/&lt;!! rc)</strong></span>
"0 1 2 3 4 "</pre></div><p>In the preceding example, the sequence generated by the expression <code class="literal">(range 5)</code> is put onto the channel <code class="literal">c</code> using an <code class="literal">onto-chan</code> form, and values from the channel are computed over using the channel-based variant of the <code class="literal">reduce</code> function. A single value is read from the resulting channel <code class="literal">rc</code>, thus producing a string containing all the values from the channel <code class="literal">c</code>. Note that the <code class="literal">reduce</code> form in this example produced a result without explicitly calling the <code class="literal">close!</code> function, as the <code class="literal">onto-chan</code> function closes the supplied channel after it completes putting values onto it.</p><p>A more powerful and intuitive way to compute values from a channel is by using a transducer. We have already discussed transducers in some detail in <a class="link" href="ch20.html" title="Chapter 5. Composing Transducers">Chapter 5</a>, <span class="emphasis"><em>Composing Transducers</em></span>, and we will now have a look at how transducers can be used with channels. Essentially, a channel can be associated with a transducer by specifying the transducer as a second argument to the <code class="literal">core.async/chan</code> function. Let's consider the simple transducer <code class="literal">xform</code> shown in <span class="emphasis"><em>Example 8.3</em></span>.</p><div class="informalexample"><pre class="programlisting">(def xform
  (comp
   (map inc)
   (map #(* % 2))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.3: A simple transducer to use with a channel</em></span></p></blockquote></div><p>The transducer <code class="literal">xform</code> shown is a trivial composition of mapping the functions <code class="literal">inc</code> and <code class="literal">#(* % 2)</code>. It will simply increment all values in a source of data, or rather a channel, and then double all of the results from the previous step. Let's create a channel using this transducer and observe its behavior, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def xc (a/chan 10 xform))</strong></span>
#'user/xc
<span class="strong"><strong>user&gt; (a/onto-chan xc (range 10) false)</strong></span>
#&lt;ManyToManyChannel@0x17d6a37&gt;
<span class="strong"><strong>user&gt; (repeatedly 10 #(-&gt; xc a/&lt;!!))</strong></span>
(2 4 6 8 10 12 14 16 18 20)</pre></div><p>The channel <code class="literal">xc</code> will apply the transducer <code class="literal">xform</code> to each value contained in it. The result of repeatedly taking values from the channel <code class="literal">xc</code> is thus a sequence of even numbers, which is produced by applying the functions <code class="literal">inc</code> and <code class="literal">#(* % 2)</code> to each number in the range <code class="literal">(range 10)</code>. Note that the <code class="literal">onto-chan</code> form in the previous example does not close the channel <code class="literal">xc</code> as we pass <code class="literal">false</code> as its last argument.</p><p>A transducer associated <a class="indexterm" id="id00426"/>with a channel could encounter an exception. To handle errors, we can pass a function as an additional argument to the <code class="literal">chan</code> form. This function must take exactly one argument, and will be passed any exception that is encountered by a transducer while transforming the values in a channel. For example, the expression <code class="literal">(a/chan 10 xform ex-handler)</code> creates a channel with a transducer <code class="literal">xform</code> and an exception handler <code class="literal">ex-handler</code>.</p><p>In this way, the <code class="literal">core.async/reduce</code> form and transducers can be used to perform computations on the values contained in channels.</p></div><div class="section" title="Connecting channels"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec0027"/>Connecting channels</h2></div></div></div><p>Now that we are familiar with the basics of channels and processes in the <code class="literal">core.async</code> library, let's explore the different ways in which channels can be connected together. Connecting two or <a class="indexterm" id="id00427"/>more channels is useful for aggregating and distributing data among them. A connection between two or more channels is called a <span class="emphasis"><em>joint fitting</em></span>, or simply a <span class="emphasis"><em>joint</em></span>. We will use <a class="indexterm" id="id00428"/>diagrams to describe some of the more complex joint<a class="indexterm" id="id00429"/> fittings in this section. Keep in mind that the arrows in these diagrams indicate the direction of the flow of data in a given channel.</p><p>The simplest way to connect two channels is<a class="indexterm" id="id00430"/> by using a <span class="emphasis"><em>pipe</em></span>, which is implemented by the <code class="literal">core.async/pipe</code> function. This function will take values from the first channel provided to it, and supplies these values to the second channel passed to it. In this way, a pipe between channels is similar to UNIX-style pipes between streams. For example, the expression <code class="literal">(a/pipe from to)</code> will take values from the channel <code class="literal">from</code> and put them onto the channel <code class="literal">to</code>. The <code class="literal">pipe</code> function also takes an optional third argument, which indicates whether the destination channel will be closed when the source channel closes, and this argument defaults to <code class="literal">true</code>. We can also connect two channels using a <span class="emphasis"><em>pipeline</em></span>, using the <code class="literal">pipeline</code> function from the <code class="literal">core.async</code> namespace. The <code class="literal">pipeline</code> function will essentially apply a transducer to the values in a channel before they are put into another channel. The supplied transducer will also be invoked in parallel for each element in the supplied channel by the <code class="literal">pipeline</code> function.</p><p>The <code class="literal">merge</code> function from the <code class="literal">core.async</code> namespace can be used to combine several channels. This function must be passed a vector of channels, and returns a channel from which the values from all of the supplied channels can be read. The returned channel is unbuffered by default, and we specify the size of the channel's buffer by passing a number as an additional argument to the <code class="literal">merge</code> function. Also, the channel returned by a <code class="literal">merge</code> form will be closed once all the source channels have been closed. The operation of the <code class="literal">merge</code> function with two channels can be illustrated as follows:</p><div class="mediaobject"><img alt="Connecting channels" src="graphics/B05024_08_02.jpg"/></div><p>A channel can be split into two channels using the <code class="literal">core.async/split</code> function. The <code class="literal">split</code> function must be passed a predicate <code class="literal">p?</code> and a channel <code class="literal">c</code>, and returns a vector of two channels. The predicate <code class="literal">p?</code> is used to decide the channel on which a value from the channel <code class="literal">c</code> must be<a class="indexterm" id="id00431"/> put. All values from the channel <code class="literal">c</code> that return a truthy value when passed to the predicate <code class="literal">p?</code> will be put onto the first channel in the vector returned by the <code class="literal">split</code> function. </p><p>Conversely, the second channel in the returned vector will contain all values that return <code class="literal">false</code> or <code class="literal">nil</code> when <code class="literal">p?</code> is applied to these values. Both the channels returned by this function will be unbuffered by default, and the buffer size of both these channels can be specified as additional arguments to a <code class="literal">split</code> form. The <code class="literal">split</code> function can be depicted by the following illustration:</p><div class="mediaobject"><img alt="Connecting channels" src="graphics/B05024_08_03.jpg"/></div><p>A more dynamic way to combine several channels, compared to the <code class="literal">merge</code> function, is by using the <code class="literal">mix</code>, <code class="literal">admix</code>, and <code class="literal">unmix</code> functions from the <code class="literal">core.async</code> namespace. The <code class="literal">mix</code> function creates a <span class="emphasis"><em>mix</em></span>, to which channels with incoming data can be connected to using the <code class="literal">admix</code> function. The <code class="literal">mix</code> function<a class="indexterm" id="id00432"/> takes a channel as an argument, and the supplied channel will contain values from all the source channels added by the <code class="literal">admix</code> function. A source channel can be removed from a mixer by using the <code class="literal">unmix</code> function. The <code class="literal">admix</code> and <code class="literal">unmix</code> functions both accept a mix, which is returned by the <code class="literal">mix</code> function, and a source channel as arguments. To remove all channels from a mix, we simply pass the mix as an argument to the <code class="literal">unmix-all</code> function. The gist of a mix is that it allows us to dynamically add and remove source channels that send data to a given output channel. A mix, its output channel, and source channels can be illustrated as follows:</p><div class="mediaobject"><img alt="Connecting channels" src="graphics/B05024_08_04.jpg"/></div><p>In the preceding illustration, the channel <code class="literal">c</code> is used as the output channel of the mix <code class="literal">m</code>, and the channels <code class="literal">c0</code> and <code class="literal">c1</code> are added as source channels to the mix <code class="literal">m</code> using the <code class="literal">admix</code> function.</p><p>The <code class="literal">core.async/mult</code> function creates a <span class="emphasis"><em>multiple</em></span> of a given channel. The data from a multiple can be <span class="emphasis"><em>tapped into</em></span> from another channel using the <code class="literal">tap</code> function. The channel supplied to the <code class="literal">tap</code> function will receive copies of all data sent to the source channel of a multiple. The <code class="literal">untap</code>
<a class="indexterm" id="id00433"/> function is used to disconnect a channel from a multiple, and the <code class="literal">untap-all</code> function will disconnect all channels from a multiple. A multiple essentially allows us to dynamically add and remove output channels that read values from a given source channel. The <code class="literal">mult</code> and <code class="literal">tap</code> functions can be described by the following diagram:</p><div class="mediaobject"><img alt="Connecting channels" src="graphics/B05024_08_05.jpg"/></div><p>In the preceding illustration, the channel <code class="literal">c</code> is used as the source channel by the multiple <code class="literal">m</code>, and the channels <code class="literal">c0</code> and <code class="literal">c1</code> are passed to the <code class="literal">tap</code> function so that they effectively receive copies of the data sent to the channel <code class="literal">c</code>.</p><p>The <code class="literal">core.async</code> library also supports a <span class="emphasis"><em>publish-subscribe</em></span> model of transferring data. This can be done using a <a class="indexterm" id="id00434"/>
<span class="emphasis"><em>publication</em></span>, which is created using the <code class="literal">core.async/pub</code> function. This<a class="indexterm" id="id00435"/> function must be supplied a source channel and a function to decide the topic of a given value in the publication. Here, a topic can be any literal value, such as a string or a keyword, which is returned by the function supplied to the <code class="literal">pub</code> form. Channels can subscribe to a publication and a topic via the <code class="literal">sub</code> function, and a channel can unsubscribe from a publication using the <code class="literal">unsub</code> function. The <code class="literal">sub</code> and <code class="literal">unsub</code> functions must be passed a publication, a topic value and a channel. Also, the <code class="literal">unsub-all</code> function can be used to disconnect all channels that have subscribed to a publication. This function can optionally be passed a topic value, and will disconnect all channels that have subscribed to the given topic. A publication with two channels subscribed to it is depicted in following diagram:</p><div class="mediaobject"><img alt="Connecting channels" src="graphics/B05024_08_06.jpg"/></div><p>In the preceding illustration, the publication <code class="literal">p</code> is created using the channel <code class="literal">c</code> and the function <code class="literal">topic-fn</code>. The channel <code class="literal">c0</code> subscribes to the publication <code class="literal">p</code> and the topic <code class="literal">:a</code>, while the channel <code class="literal">c1</code> subscribes to the same publication but for the topic <code class="literal">:b</code>. When a value is received on<a class="indexterm" id="id00436"/> the channel <code class="literal">c</code>, it will either be sent to the channel <code class="literal">c0</code> if the function <code class="literal">topic-fn</code> returns <code class="literal">:a</code> for the given value, or to channel <code class="literal">c1</code> if the function <code class="literal">topic-fn</code> returns <code class="literal">:b</code> for the given value. Note that the values <code class="literal">:a</code> and <code class="literal">:b</code> in the preceding diagram are just arbitrary literals, and we could have used any other literal values just as easily.</p><p>In summary, the <code class="literal">core.async</code> library provides several constructs to create joints between channels. These constructs help in modelling different ways in which data flows from any number of source channels into any number of output channels.</p></div><div class="section" title="Revisiting the dining philosophers problem"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec0028"/>Revisiting the dining philosophers problem</h2></div></div></div><p>Now, let's try to<a class="indexterm" id="id00437"/> implement a solution to the <span class="strong"><strong>dining philosophers problem</strong></span> using the <code class="literal">core.async</code> library. We have already implemented two solutions to the dining philosophers problem in<a class="indexterm" id="id00438"/> <a class="link" href="ch17.html" title="Chapter 2. Orchestrating Concurrency and Parallelism">Chapter 2</a>, <span class="emphasis"><em>Orchestrating Concurrency and Parallelism</em></span> of which one solution used refs and the other one used agents. In this section, we will use channels to implement a solution to the dining philosophers problem.</p><p>The dining philosophers problem can be concisely described as follows. Five philosophers are seated on a table with five forks placed between them. Each philosopher requires two forks to eat. The philosophers must somehow share access to the forks placed in between them to consume the food allocated to them, and none of the philosophers must starve due to being unable to acquire two forks. In this implementation, we <a class="indexterm" id="id00439"/>will use channels to maintain the state of the forks as well as the philosophers on the table.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0094"/>Note</h3><p>The following namespaces must be included in your namespace declaration for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.core.async :as a]
            [m-clj.c2.refs :as c2]))</pre></div><p>The following examples can be found in <code class="literal">src/m_clj/c8/</code> <code class="literal">dining_philosophers_async.clj</code> of the book's source code. Some of these examples are based <a class="indexterm" id="id00440"/>on code from <span class="emphasis"><em>A Dining Philosophers solver</em></span> by Pepijn de Vos (<a class="ulink" href="http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html">http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html</a>).</p></div></div><p>Let's first define a couple of functions to initialize all the philosophers and forks we are dealing with, as shown in <span class="emphasis"><em>Example 8.4</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn make-philosopher [name forks food]
  {:name name
   :forks forks
   :food food})

(defn make-forks [nf]
  (let [forks (repeatedly nf #(a/chan 1))]
    (doseq [f forks]
      (a/&gt;!! f :fork))
    forks))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.4: The dining philosophers problem</em></span></p></blockquote></div><p>The <code class="literal">make-philosopher</code> function defined in <span class="emphasis"><em>Example 8.4</em></span> creates a map representing the state of a philosopher. The argument <code class="literal">name</code> will be a string, the argument <code class="literal">forks</code> will be a vector of two fork channels, and the argument <code class="literal">food</code> will be a number indicating the amount of food served to a philosopher. The two forks represent the forks on the left- and right-hand side of a philosopher. These forks will be allocated and passed to the <code class="literal">make-philosopher</code> function by the <code class="literal">init-philosophers</code> function that we previously defined in <a class="link" href="ch17.html" title="Chapter 2. Orchestrating Concurrency and Parallelism">Chapter 2</a>, Orchestrating Concurrency and Parallelism. The <code class="literal">make-forks</code> function shown previously creates a specified number of channels, puts the value <code class="literal">:fork</code> onto each of them, and finally returns the new channels.</p><p>Next, let's define the routine of a philosopher as a process. A philosopher must try to acquire the forks on his left and right side, eat his food if he acquires both forks, and finally release any forks that he successfully acquired. Also, since the state of all the philosophers in our simulation is captured in a channel, we will have to take a philosopher out of a channel, perform the routine of a philosopher, and then put the philosopher's state back onto<a class="indexterm" id="id00441"/> the channel. This routine is implemented by the <code class="literal">philosopher-process</code> function in <span class="emphasis"><em>Example 8.5</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn philosopher-process [p-chan max-eat-ms max-think-ms]
  (a/go-loop []
    (let [p (a/&lt;! p-chan)
          food (:food p)
          fork-1 ((:forks p) 0)
          fork-2 ((:forks p) 1)
          ;; take forks
          fork-1-result (a/alt!
                          (a/timeout 100) :timeout
                          fork-1 :fork-1)
          fork-2-result (a/alt!
                          (a/timeout 100) :timeout
                          fork-2 :fork-2)]
      (if (and (= fork-1-result :fork-1)
               (= fork-2-result :fork-2))
        (do
          ;; eat
          (a/&lt;! (a/timeout (rand-int max-eat-ms)))
          ;; put down both acquired forks
          (a/&gt;! fork-1 :fork)
          (a/&gt;! fork-2 :fork)
          ;; think
          (a/&lt;! (a/timeout (rand-int max-think-ms)))
          (a/&gt;! p-chan (assoc p :food (dec food))))
        (do
          ;; put down any acquired forks
          (if (= fork-1-result :fork-1)
            (a/&gt;! fork-1 :fork))
          (if (= fork-2-result :fork-2)
            (a/&gt;! fork-2 :fork))
          (a/&gt;! p-chan p)))
      ;; recur
      (when (pos? (dec food)) (recur)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.5: The dining philosophers problem (continued)</em></span></p></blockquote></div><p>The preceding <code class="literal">philosopher-process</code> function starts an asynchronous process using the <code class="literal">go-loop</code> macro. The arguments <code class="literal">p-chan</code>, <code class="literal">max-eat-ms</code>, and <code class="literal">max-think-ms</code> represent the channel containing the state of all philosophers, the maximum amount of time a philosopher can spend eating, and the maximum amount of time a philosopher can think, respectively. The asynchronous task started by the <code class="literal">philosopher-process</code> function will try to take values from the forks <code class="literal">fork-1</code> and <code class="literal">fork-2</code> of a philosopher with a timeout of <code class="literal">100</code> milliseconds. This is done using a combination of the <code class="literal">alt!</code> and <code class="literal">timeout</code> functions. If a philosopher is able to acquire two forks, he will eat for some time, put down or release both forks, spend some time thinking, and repeat the same process. If he is unable to get two forks, the philosopher will release any acquired forks and restart the same process. The state of the<a class="indexterm" id="id00442"/> philosopher is always put back onto the channel <code class="literal">p-chan</code>. This asynchronous process is repeated until a philosopher has any remaining food. Next, let's define a couple of functions to start and print the philosophers in our simulation, as shown in <span class="emphasis"><em>Example 8.6</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn start-philosophers [p-chan philosophers]
  (a/onto-chan p-chan philosophers false)
  (dorun (repeatedly (count philosophers)
                     #(philosopher-process p-chan 100 100)))) 

(defn print-philosophers [p-chan n]
  (let [philosophers (repeatedly n #(a/&lt;!! p-chan))]
    (doseq [p philosophers]
      (println (str (:name p) ":\t food=" (:food p)))
      (a/&gt;!! p-chan p))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.6: The dining philosophers problem (continued)</em></span></p></blockquote></div><p>The preceding <code class="literal">start-philosophers</code> function will put a sequence of philosophers, represented by the argument <code class="literal">philosophers</code>, onto the channel <code class="literal">p-chan</code>, and then call the <code class="literal">philosopher-process</code> function for each philosopher in the sequence <code class="literal">philosophers</code>. The <code class="literal">print-philosophers</code> function uses the blocking channel read and write functions, namely <code class="literal">&lt;!!</code> and <code class="literal">&gt;!!</code>, to read <code class="literal">n</code> philosophers from the channel <code class="literal">p-chan</code> and print the amount of food remaining on each philosopher's plate.</p><p>Finally, let's create some instances of philosophers and associated forks by using the <code class="literal">make-philosopher</code> and <code class="literal">make-forks</code> functions. We will also use the <code class="literal">init-philosophers</code> function from <a class="link" href="ch17.html" title="Chapter 2. Orchestrating Concurrency and Parallelism">Chapter 2</a>, Orchestrating Concurrency and Parallelism, to create philosopher objects, using the <code class="literal">make-philosopher</code> function, and assign two forks to each philosopher. These top-level definitions of the philosophers and forks in our simulation are shown in <span class="emphasis"><em>Example 8.7</em></span>.</p><div class="informalexample"><pre class="programlisting">(def all-forks (make-forks 5))
(def all-philosophers
  (c2/init-philosophers 5 1000 all-forks make-philosopher))

(def philosopher-chan (a/chan 5))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.7: The dining philosophers problem (continued)</em></span></p></blockquote></div><p>As shown here, we define five forks and philosophers, and create a channel to represent the state of all philosophers we have created. Note that the channel we use for the philosophers has a buffer size of <code class="literal">5</code>. The simulation can be started by calling the <code class="literal">start-philosophers</code>
<a class="indexterm" id="id00443"/> function, and the state of the philosophers can be printed using the <code class="literal">print-philosophers</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (start-philosophers philosopher-chan all-philosophers)</strong></span>
nil
<span class="strong"><strong>user&gt; (print-philosophers philosopher-chan 5)</strong></span>
Philosopher 3:   food=937
Philosopher 2:   food=938
Philosopher 1:   food=938
Philosopher 5:   food=938
Philosopher 4:   food=937
nil
<span class="strong"><strong>user&gt; (print-philosophers philosopher-chan 5)</strong></span>
Philosopher 4:   food=729
Philosopher 1:   food=729
Philosopher 2:   food=729
Philosopher 5:   food=730
Philosopher 3:   food=728
nil</pre></div><p>As the preceding output shows us, the five philosophers share access to the forks among themselves and consume their food at the same rate. All philosophers get a chance to eat their food, and thus no one starves. Note that the order of the philosophers printed by the <code class="literal">print-philosophers</code> function may differ from time to time, and some philosophers may also be printed twice by this function.</p><p>In this way, we can solve a given problem using channels and processes from the <code class="literal">core.async</code> library. Also, we can create any number of such processes without bothering about the available number of operating system level threads.</p></div></div></div>
<div class="section" title="Using actors"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec0048"/>Using actors</h1></div></div></div><p>
<span class="strong"><strong>Actors</strong></span> are another way of modeling a system as a large number of concurrently running processes. Each process in <span class="emphasis"><em>the actor model </em></span>is termed as an actor, and this model is based on the philosophy that every <a class="indexterm" id="id00444"/>piece of logic in a system can be represented as an actor. The theory behind actors <a class="indexterm" id="id00445"/>was first published by Carl Hewitt in the early '70s. Before we explore actors, we must note that the core Clojure language and libraries do not provide an implementation of the actor model. In fact, it is a widely accepted notion in the Clojure community that processes and channels are a much better methodology to model concurrently running processes compared to actors. That aside, actors can be used to provide more resilient error handling and recovery, and it is possible to <a class="indexterm" id="id00446"/>use actors in Clojure through the Pulsar library (<a class="ulink" href="https://github.com/puniverse/pulsar">https://github.com/puniverse/pulsar</a>).</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0096"/>Note</h3><p>To find out more about why processes and channels are preferred over actors in Clojure, take a<a class="indexterm" id="id00447"/> look at <span class="emphasis"><em>Clojure core.async Channels</em></span> by Rich Hickey (<a class="ulink" href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels">http://clojure.com/blog/2013/06/28/clojure-core-async-channels</a>).</p></div></div><p>The actor model describes actors as concurrent processes that perform some computation on receiving messages. An actor can also send messages to other actors, create more actors, and change its own behavior depending on the messages it receives. Actors can also have their own internal state. In fact, actors were originally described as independent processors with their <a class="indexterm" id="id00448"/>own local memory that interact with each other through a high-speed communication network. Every actor has its own <span class="emphasis"><em>mailbox</em></span> to receive messages, and messages are the only means of conveying data between actors. The following diagram depicts an actor as an entity<a class="indexterm" id="id00449"/> that receives some input as messages and performs computations to <a class="indexterm" id="id00450"/>produce some output:</p><div class="mediaobject"><img alt="Using actors" src="graphics/B05024_08_07.jpg"/></div><p>The Pulsar library provides a comprehensive implementation of the actor model. In this library, actors are scheduled to<a class="indexterm" id="id00451"/> execute on <span class="strong"><strong>fibers</strong></span>, which are similar to asynchronous tasks created using the <code class="literal">go</code> form from the <code class="literal">core.async</code> library. Fibers are scheduled to run on fork-join thread pools, unlike regular thread pools that are used in the <code class="literal">core.async</code> library. Due to this design, the Pulsar library is available only on the JVM, and not in the browser through ClojureScript.</p><p>Fibers communicate with each<a class="indexterm" id="id00452"/> other through the Pulsar library's own implementation of <span class="emphasis"><em>promises</em></span> and <span class="emphasis"><em>channels</em></span>. Interestingly, the Pulsar library also has several thin wrappers around its<a class="indexterm" id="id00453"/> implementation of channels, to provide an API that is fully compatible with that of the <code class="literal">core.async</code> library. Although we won't discuss fibers, promises, and channels from the Pulsar library any<a class="indexterm" id="id00454"/> further in this section, we must understand that channels are quite relevant to actors, since an actor's mailbox is implemented using a channel. Now, let's explore the basics of actors in the Pulsar library.</p><div class="section" title="Creating actors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec0029"/>Creating actors</h2></div></div></div><p>The <code class="literal">spawn</code> macro, from the <code class="literal">co.paralleluniverse.pulsar.actors</code> namespace, creates a new actor and <a class="indexterm" id="id00455"/>must be passed a function that takes no arguments. We can specify the buffer size of an actor's mailbox using the <code class="literal">:mailbox-size</code> keyword argument of the <code class="literal">spawn</code> macro. There are several other interesting keyword arguments that can be passed to the <code class="literal">spawn</code> form, and you are encouraged to find out more about them on your own.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note0097"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[co.paralleluniverse/quasar-core "0.7.3"]
[co.paralleluniverse/pulsar "0.7.3"]</pre></div><p>Your <code class="literal">project.clj</code> file must also contain the following entries:</p><div class="informalexample"><pre class="programlisting">:java-agents
[[co.paralleluniverse/quasar-core "0.7.3"]]
:jvm-opts
["-Dco.paralleluniverse.pulsar.instrument.auto=all"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [co.paralleluniverse.pulsar.core :as pc]
            [co.paralleluniverse.pulsar.actors :as pa]))</pre></div></div></div><p>The function supplied to the <code class="literal">spawn</code> macro must use the <code class="literal">receive</code> macro, from the <code class="literal">co.paralleluniverse.pulsar.actors</code> namespace, to process messages received by the actor. Within this supplied function, we can use the expression <code class="literal">@self</code> to refer to the actor executing it. The <code class="literal">receive</code> form also supports pattern matching, which is implemented through the <code class="literal">core.match</code> library. We can also call the <code class="literal">receive</code> macro with no arguments, in which case it will return a message from the actor's mailbox. The <code class="literal">receive</code> form will also park the fiber on which it is executed.</p><p>To send messages to <a class="indexterm" id="id00456"/>actors, we can use either the <code class="literal">!</code> or <code class="literal">!!</code> macros from the <code class="literal">co.paralleluniverse.pulsar.actors</code> namespace. Both these macros must be passed an actor and an expression that returns a value, and both of these forms return <code class="literal">nil</code>. The only difference between these two forms is that <code class="literal">!</code> is asynchronous, while <code class="literal">!!</code> is synchronous and may block the current thread of execution if the actor's mailbox is full. An actor may terminate on receiving a particular message, and we can check whether an actor is still active using the <code class="literal">done?</code> function from the <code class="literal">co.paralleluniverse.pulsar.actors</code> namespace. Once an actor terminates, we can obtain the final value returned by the actor using the <code class="literal">join</code> function from the <code class="literal">co.paralleluniverse.pulsar.core</code> namespace. For example, consider the actor created using the <code class="literal">spawn</code> and <code class="literal">receive</code> forms in <span class="emphasis"><em>Example 8.8</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00100"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c8/actors.clj</code> of the book's source code. Some of these examples are based on code from the official Pulsar documentation (<code class="literal">http://docs.paralleluniverse.co/pulsar/</code>).</p></div></div><div class="informalexample"><pre class="programlisting">(def actor (pa/spawn
            #(pa/receive
              :finish (println "Finished")
              m (do
                  (println (str "Received: " m))
                  (recur)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.8: An actor created using the spawn macro</em></span></p></blockquote></div><p>The actor, represented by the preceding variable <code class="literal">actor</code>, will receive a message, print it and loop using a <code class="literal">recur</code> form. If the message <code class="literal">:finish</code> is received, it will print a string and terminate. The following code demonstrates how we can send a message to the actor:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (pa/! actor :foo)</strong></span>
nil
Received: :foo
<span class="strong"><strong>user&gt; (pa/done? actor)</strong></span>
false</pre></div><p>As shown here, sending the value <code class="literal">:foo</code> to the actor returns <code class="literal">nil</code> immediately, and the message gets printed from another thread. As the <code class="literal">done?</code> function returns <code class="literal">false</code> when passed the variable <code class="literal">actor</code>, it is evident that the actor does not terminate on receiving the value <code class="literal">:foo</code> as a message. On the other hand, if we send the value <code class="literal">:finish</code> to the actor, it will terminate, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (pa/! actor :finish)</strong></span>
nil
Finished
<span class="strong"><strong>user&gt; (pa/done? actor)</strong></span>
true</pre></div><p>After being sent the value <code class="literal">:finish</code>, the <code class="literal">done?</code> function returns <code class="literal">true</code> when applied to the actor, which implies that the actor has terminated. The value returned by an actor before termination can be obtained using the <code class="literal">join</code> function from the <code class="literal">co.paralleluniverse.pulsar.core</code> namespace. We must note that the <code class="literal">join</code> function actually returns the<a class="indexterm" id="id00457"/> result of any fiber, and will block the calling thread of execution until the fiber completes or terminates. For example, consider the actor in <span class="emphasis"><em>Example 8.9</em></span> that divides a number by another number:</p><div class="informalexample"><pre class="programlisting">(def divide-actor
  (pa/spawn
   #(loop [c 0]
      (pa/receive
       :result c
       [a b] (recur (/ a b))))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.9: An actor that performs division of a number by another</em></span></p></blockquote></div><p>We can send messages to the actor <code class="literal">divide-actor</code> defined in <span class="emphasis"><em>Example 8.9</em></span>, and obtain the final result from it using the <code class="literal">join</code> function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (pa/! divide-actor 30 10)</strong></span>
nil
<span class="strong"><strong>user&gt; (pa/! divide-actor :result)</strong></span>
nil
<span class="strong"><strong>user&gt; (pc/join divide-actor)</strong></span>
3</pre></div><p>The preceding code shows that we can send two numbers to the actor <code class="literal">divide-actor</code>, and send it the value <code class="literal">:result</code> to terminate it. After termination, we can obtain the result of the actor, that is <code class="literal">3</code>, by passing the actor to the <code class="literal">join</code> function.</p><p>Actors can be registered with meaningful names that can be used to locate them. This is done using the <code class="literal">register!</code> function from the <code class="literal">co.paralleluniverse.pulsar.actors</code> namespace, which must be passed an actor instance and a name to register for the supplied actor. We can then send messages to a registered actor by specifying the actor's name to either the <code class="literal">!</code> or <code class="literal">!!</code> functions. For example, suppose the variable <code class="literal">actor</code> represents an actor instance created using the <code class="literal">spawn</code> macro. After registering the actor with the name <code class="literal">:my-actor</code> by calling <code class="literal">(pa/register! actor :my-actor)</code>, we can send the value <code class="literal">:foo</code> to the actor by calling <code class="literal">(pa/! :my-actor :foo)</code>.</p></div><div class="section" title="Passing messages between actors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec0030"/>Passing messages between actors</h2></div></div></div><p>Now, let's build a simple simulation of a ping pong game with two actors. These two actors will send the <a class="indexterm" id="id00458"/>messages <code class="literal">:ping</code> and <code class="literal">:pong</code> to each other for a specified number of times. The code for this simulation is shown in <span class="emphasis"><em>Example 8.10</em></span> as follows:</p><div class="informalexample"><pre class="programlisting">(defn ping-fn [n pong]
  (if (= n 0)
    (do
      (pa/! pong :finished)
      (println "Ping finished"))
    (do
      (pa/! pong [:ping @pa/self])
      (pa/receive
       :pong (println "Ping received pong"))
      (recur (dec n) pong))))

(defn pong-fn []
  (pa/receive
   :finished (println "Pong finished")
   [:ping ping] (do
                  (println "Pong received ping")
                  (pa/! ping :pong)
                  (recur))))

(defn start-ping-pong [n]
  (let [pong (pa/spawn pong-fn)
        ping (pa/spawn ping-fn n pong)]
    (pc/join pong)
    (pc/join ping)
    :finished))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.10: Two actors playing a game of ping-pong</em></span></p></blockquote></div><p>The <code class="literal">ping-fn</code> and <code class="literal">pong-fn</code> functions shown in <span class="emphasis"><em>Example 8.10</em></span> implement the logic of two actors playing a game of ping pong. The <code class="literal">ping-fn</code> will essentially send a vector containing the keyword <code class="literal">:ping</code> and the current actor instance to the actor represented by the argument <code class="literal">pong</code>. This is done <code class="literal">n</code> times, and finally the message <code class="literal">:finished</code> is sent to the actor <code class="literal">pong</code>. The function <code class="literal">pong-fn</code> will receive the vector <code class="literal">[:ping ping]</code>, where <code class="literal">ping</code> will be the actor sending the message. An actor created with the <code class="literal">pong-fn</code> will terminate once it receives the message <code class="literal">:finished</code>. The <code class="literal">start-ping-pong</code> function simply creates two actors using the functions <code class="literal">ping-fn</code> and <code class="literal">pong-fn</code> and waits until they are both finished using the <code class="literal">join</code> function. We can call the <code class="literal">start-ping-pong</code> function by passing in the number of times each of the two actors must send messages to each other, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (start-ping-pong 3)</strong></span>
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Pong received ping
Ping received pong
Ping finished
Pong finished
:finished</pre></div><p>The two actors created by the <code class="literal">start-ping-pong</code> function pass messages between themselves to simulate<a class="indexterm" id="id00459"/> a game of ping pong, as demonstrated by the preceding output. In conclusion, actors from the Pulsar library can be used to implement concurrently executing processes.</p></div><div class="section" title="Handling errors with actors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec0031"/>Handling errors with actors</h2></div></div></div><p>Actors support some<a class="indexterm" id="id00460"/> interesting methods for error handling. If an actor encounters an error while processing a received message, it will terminate. The exception that was raised within the fiber executing the actor will be saved and thrown again when<a class="indexterm" id="id00461"/> we pass the actor to the <code class="literal">join</code> function. In effect, we don't need to handle exceptions within the function passed to the <code class="literal">spawn</code> macro, and instead we must catch exceptions when the <code class="literal">join</code> function is called.</p><p>This brings us to an interesting consequence of actors. If an actor could encounter an error and fail, we can have another actor that monitors the first actor, and restart it in case of failure. Thus, an actor can be notified when another actor in the system terminates. This principle allows actors to recover from errors in an automated fashion. In the Pulsar library, this sort of error handling is done through the <code class="literal">watch!</code> and <code class="literal">link!</code> functions from the <code class="literal">co.paralleluniverse.pulsar.actors</code> namespace.</p><p>An actor can <span class="emphasis"><em>watch</em></span> or <span class="emphasis"><em>monitor</em></span> another actor by calling the <code class="literal">watch!</code> function from within its body. For example, we must call <code class="literal">(watch! A)</code> within the body of an actor to watch the actor <code class="literal">A</code>. If the actor being watched encounters an exception, the same exception will be thrown from the <code class="literal">receive</code> form of the monitoring actor. The monitoring actor must catch the exception, or else it will be terminated along with the actor from which the exception originated. Also, the monitoring actor could restart the terminated actor by calling the <code class="literal">spawn</code> macro. To stop watching an actor, we must pass the watched actor to the <code class="literal">unwatch!</code> function from within the body of the monitoring actor.</p><p>Two actors could also be <span class="emphasis"><em>linked</em></span> by passing them to the <code class="literal">link!</code> function. If two actors are linked together, an exception encountered in either of the two actors will be caught by the other one. In this way, linking two actors is a symmetrical way of monitoring them for errors. The <code class="literal">link!</code> function can also be called within the function passed to a <code class="literal">spawn</code> form, in which case it must be passed the <a class="indexterm" id="id00462"/>actor to be linked. To unlink two actors, we can use the <code class="literal">unlink!</code> function.</p><p>Thus, the Pulsar library<a class="indexterm" id="id00463"/> provides some interesting ways to watch and link actors to perform error handling and recovery.</p></div><div class="section" title="Managing state with actors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec0032"/>Managing state with actors</h2></div></div></div><p>As we mentioned earlier, actors can have their own internal mutable state. Of course, accessing this state<a class="indexterm" id="id00464"/> from other actors is not allowed, and immutable messages are the only way an actor can communicate with other actors. Another way that an actor can maintain or manage its state is by changing its behavior depending on the <a class="indexterm" id="id00465"/>messages it receives, and this technique is called a <span class="emphasis"><em>selective receive</em></span>.</p><p>Every actor created using the <code class="literal">spawn</code> function can read its internal state using the expression <code class="literal">@state</code>, and can also write to this state using the <code class="literal">set-state!</code> function. The <code class="literal">set-state!</code> function will also return the new state of the actor, as returned by the expression <code class="literal">@state</code>. Note that both of these forms are implemented in the <code class="literal">co.paralleluniverse.pulsar.actors</code> namespace.</p><p>Consider the <code class="literal">add-using-state</code> function in <span class="emphasis"><em>Example 8.11</em></span> that uses an actor to add two numbers. Of course, we would never really need such a function in the real world, and it is only demonstrated here to depict how an actor can change its internal state.</p><div class="informalexample"><pre class="programlisting">(defn add-using-state [a b]
  (let [actor (pa/spawn
               #(do
                  (pa/set-state! 0)
                  (pa/set-state! (+ @pa/state (pa/receive)))
                  (pa/set-state! (+ @pa/state (pa/receive)))))]
    (pa/! actor a)
    (pa/! actor b)
    (pc/join actor)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.11: A function to add two numbers using an actor</em></span></p></blockquote></div><p>The <code class="literal">add-using-state</code> function shown in <span class="emphasis"><em>Example 8.11</em></span> creates an actor that sets its state to <code class="literal">0</code>, and adds the first two messages it receives to its state. The actor will return the latest state of the actor, as returned by the last call to <code class="literal">set-state!</code> in the function passed to the <code class="literal">spawn</code> macro. On calling the <code class="literal">add-using-state</code> function with two numbers, it produces their sum as its output, shown as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (add-using-state 10 20)</strong></span>
30</pre></div><p>Another way in which an actor can modify its state is through a selective receive, in which the actor modifies its behavior on receiving a particular message. This is done by calling a <code class="literal">receive</code> form <a class="indexterm" id="id00466"/>within the body of another <code class="literal">receive</code> form, as shown in <span class="emphasis"><em>Example 8.12</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn add-using-selective-receive [a b]
  (let [actor (pa/spawn
               #(do
                  (pa/set-state! 0)
                  (pa/receive
                   m (pa/receive
                      n (pa/set-state! (+ n m))))))]
    (pa/! actor a)
    (pa/! actor b)
    (pc/join actor)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 8.12: A function to add two numbers using an actor with selective receive</em></span></p></blockquote></div><p>The <code class="literal">add-using-selective-receive</code> function shown previously will set its state to <code class="literal">0</code>, receive the <a class="indexterm" id="id00467"/>messages <code class="literal">m</code> and <code class="literal">n</code> through a selective receive, and add these messages. This function produces identical results as the <code class="literal">add-using-state </code>function from <span class="emphasis"><em>Example 8.11</em></span>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (add-using-selective-receive 10 20)</strong></span>
30</pre></div><p>In this way, actors can change their internal state and behavior based on the messages sent to them.</p></div><div class="section" title="Comparing processes and actors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec0033"/>Comparing processes and actors</h2></div></div></div><p>CSPs and actors are two<a class="indexterm" id="id00468"/> distinct approaches to modeling a system as a large number of concurrent processes that execute and interact asynchronously. The logic of an asynchronous task can<a class="indexterm" id="id00469"/> reside within a process created using a <code class="literal">go</code> block, or within the function passed to the <code class="literal">spawn</code> macro that creates an actor. However, there are some subtle contrasts between these two approaches:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Processes created using the <code class="literal">go</code> and <code class="literal">thread</code> forms encourage us to put all states onto channels. Actors, on the other hand, can have their own internal state, in addition to the state in the form of messages sent to them. Thus, actors are more like objects with encapsulated state, while processes are more like functions that operate on states stored in channels.</li><li class="listitem" style="list-style-type: disc">Tasks created using the <code class="literal">go</code> or <code class="literal">thread</code> macros have no implicit error handling, and we must handle exceptions using the <code class="literal">try</code> and <code class="literal">catch</code> forms in the body of the <code class="literal">go</code> and <code class="literal">thread</code> macros. Of course, channels do support error handlers, but only when combined with a transducer. Actors, however, will save any exception they run into until we apply the <code class="literal">join</code> function on the actor. Also, actors can be linked and monitored to provide a form of automated error<a class="indexterm" id="id00470"/> recovery. In this way, actors are more focused on building fault-tolerant systems.</li></ul></div><p>These distinguishing factors between CSPs and the actor model give us an idea about which approach is<a class="indexterm" id="id00471"/> more suitable for implementing asynchronous tasks in a given problem.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec0051"/>Summary</h1></div></div></div><p>In this chapter, we looked at how we can create concurrent and asynchronous tasks using the <code class="literal">core.async</code> and Pulsar libraries. The <code class="literal">core.async</code> library provides an implementation of CSPs, and is supported in both Clojure and ClojureScript. We studied the various constructs in the <code class="literal">core.async</code> library and also demonstrated how a solution to the dining philosophers problem can be implemented using this library. Later on, we explored actors through the Pulsar library.</p><p>We will explore reactive programming in the following chapter. As we will see ahead, reactive programming can be thought of as an extension of asynchronous programming for handling data and events.</p></div>
<div class="chapter" title="Chapter&#xA0;9.&#xA0;Reactive Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch24"/>Chapter 9. Reactive Programming</h1></div></div></div><p>One of the many interesting applications of programming with asynchronous tasks is <span class="emphasis"><em>reactive programming</em></span>. This methodology<a class="indexterm" id="id00472"/> of programming is all about asynchronously reacting to changes in state. In reactive programming, code is structured in such a way that it <span class="emphasis"><em>reacts</em></span> to changes. Generally, this is implemented using asynchronous data streams, in which data and events are propagated asynchronously through a program. In fact, there are quite a few interesting variants of reactive programming.</p><p>Reactive programming is particularly useful in designing graphical user interfaces in frontend development, where changes in the internal state of an application must asynchronously trickle down to the user interface. A program is thus segregated into events and logic that is executed on those events. For programmers used to imperative and object-oriented programming techniques, the hardest part of reactive programming is thinking in reactive abstractions and letting go of old habits like using the mutable state. However, if you've been paying attention so far and have started thinking with immutability and functions, you'll find reactive programming quite natural. In the JavaScript world, reactive programming<a class="indexterm" id="id00473"/> with <span class="emphasis"><em>observables</em></span> can be thought of as a contrasting alternative to using promises to manage asynchronous events and actions.</p><p>In this chapter, we will explore a few interesting forms of reactive programming through Clojure and ClojureScript libraries. Later on, we will also demonstrate how we can build dynamic user interfaces using reactive programming.</p><div class="section" title="Reactive programming with fibers and dataflow variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec0052"/>Reactive programming with fibers and dataflow variables</h1></div></div></div><p>
<span class="emphasis"><em>Dataflow programming</em></span> is one<a class="indexterm" id="id00474"/> of the simplest forms <a class="indexterm" id="id00475"/>of reactive <a class="indexterm" id="id00476"/>programming. In <a class="indexterm" id="id00477"/>dataflow <a class="indexterm" id="id00478"/>programming, computations are described by composing variables without bothering about when these variables are set to a value. Such variables are also called <a class="indexterm" id="id00479"/>
<span class="strong"><strong>dataflow variables</strong></span>, and they will trigger computations that refer to them once they are set. The<a class="indexterm" id="id00480"/> <span class="emphasis"><em>Pulsar</em></span> library (<a class="ulink" href="https://github.com/puniverse/pulsar">https://github.com/puniverse/pulsar</a>) provides a few useful constructs for dataflow programming. These constructs can also be used with Pulsar <span class="strong"><strong>fibers</strong></span>, which we<a class="indexterm" id="id00481"/> briefly talked about in <a class="link" href="ch23.html" title="Chapter 8. Leveraging Asynchronous Tasks">Chapter 8</a>, <span class="emphasis"><em>Leveraging Asynchronous Tasks</em></span>. In this section, we will explore the basics <a class="indexterm" id="id00482"/>of fibers and dataflow <a class="indexterm" id="id00483"/>variables from the Pulsar library.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00101"/>Note</h3><p>The following library<a class="indexterm" id="id00484"/> dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[co.paralleluniverse/quasar-core "0.7.3"]
[co.paralleluniverse/pulsar "0.7.3"]</pre></div><p>Your <code class="literal">project.clj</code> file must also contain the following entries:</p><div class="informalexample"><pre class="programlisting">:java-agents
[[co.paralleluniverse/quasar-core "0.7.3"]]
:jvm-opts
["-Dco.paralleluniverse.pulsar.instrument.auto=all"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [co.paralleluniverse.pulsar.core :as pc]
            [co.paralleluniverse.pulsar.dataflow
             :as pd]))</pre></div></div></div><p>The elementary abstraction of an asynchronous task in the Pulsar library is a fiber. Fibers are scheduled for <a class="indexterm" id="id00485"/>execution on fork-join based thread pools, and we can create a large number of fibers without bothering about the number of available processing cores. Fibers can be created using the <code class="literal">spawn-fiber</code> and <code class="literal">fiber</code> macros from the <code class="literal">co.paralleluniverse.pulsar.core</code> namespace. The <code class="literal">spawn-fiber</code> macro must be passed a function that takes no arguments, and the <code class="literal">fiber</code> form must be passed a body of expressions. The body of both these forms will be executed on a new fiber. The <code class="literal">join</code> function from the <code class="literal">co.paralleluniverse.pulsar.core</code> namespace can be used to retrieve the value returned by a fiber.</p><p>An important rule we must keep in mind while dealing with fibers is that we must never call methods or functions that manipulate the current thread of execution from within a fiber. Instead, we must use fiber-specific functions from the <code class="literal">co.paralleluniverse.pulsar.core</code> namespace to perform these operations. For example, calling the <code class="literal">java.lang.Thread/sleep</code> method in a fiber must be avoided. Instead, the <code class="literal">sleep</code> function from the <code class="literal">co.paralleluniverse.pulsar.core</code> namespace can be used to suspend<a class="indexterm" id="id00486"/> the current fiber for a given number of milliseconds.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00104"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c9/fibers.clj</code> of the book's source code. Some of these examples are based on code from the official Pulsar <a class="indexterm" id="id00487"/>documentation (<a class="ulink" href="http://docs.paralleluniverse.co/pulsar/">http://docs.paralleluniverse.co/pulsar/</a>).</p></div></div><p>For example, we can add two numbers using a fiber as shown in <span class="emphasis"><em>Example 9.1</em></span>. Of course, using a fiber for such a trivial operation has no practical use, and it is only shown here to demonstrate how <a class="indexterm" id="id00488"/>we can create a fiber and obtain its return value:</p><div class="informalexample"><pre class="programlisting">(defn add-with-fiber [a b]
  (let [f (pc/spawn-fiber
               (fn []
                 (pc/sleep 100)
                 (+ a b)))]
    (pc/join f)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.1: Adding two numbers with a fiber</em></span></p></blockquote></div><p>The preceding <code class="literal">add-with-fiber</code> function creates a fiber <code class="literal">f</code> using the <code class="literal">spawn-fiber</code> macro and fetches<a class="indexterm" id="id00489"/> the return value of the fiber using the <code class="literal">join</code> function. The fiber <code class="literal">f</code> will suspend itself for <code class="literal">100</code> milliseconds using the <code class="literal">sleep</code> function and then return the sum of <code class="literal">a</code> and <code class="literal">b</code>.</p><p>Let's talk a bit about dataflow variables. We can create dataflow variables using the <code class="literal">df-val</code> and <code class="literal">df-var</code> functions from the <code class="literal">co.paralleluniverse.pulsar.dataflow</code> namespace. A dataflow<a class="indexterm" id="id00490"/> variable created using these functions can be set by calling it like a function and passing it a value. Also, the value of a dataflow variable can be obtained by dereferencing it using the <code class="literal">@</code> operator or the <code class="literal">deref</code> form. A dataflow variable declared using the <code class="literal">df-val</code> function can only be set once, whereas one created using the <code class="literal">df-var</code> function can be set several times. </p><p>The <code class="literal">df-var</code> function can also be passed a function that takes no arguments and refers to other dataflow variables in the current scope. This way, the value of such a dataflow variable will be recomputed when the values of referenced variables are changed. For example, two numbers can be added using dataflow variables as shown in the <code class="literal">df-add</code> function defined in <span class="emphasis"><em>Example 9.2</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn df-add [a b]
  (let [x (pd/df-val)
        y (pd/df-val)
        sum (pd/df-var #(+ @x @y))]
    (x a)
    (y b)
    @sum))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.2: Adding two numbers with dataflow variables</em></span></p></blockquote></div><p>The value of the dataflow variable <code class="literal">sum</code>, declared in the preceding <code class="literal">df-add</code> function, will be recalculated when the referenced dataflow variables <code class="literal">x</code> and <code class="literal">y</code> are set to a value. The variables <code class="literal">x</code> and <code class="literal">y</code> are set by calling them like functions. Similarly, we can add a number to each element in a range<a class="indexterm" id="id00491"/> of numbers using the <code class="literal">df-val</code> and <code class="literal">df-var</code> functions as shown in the following <span class="emphasis"><em>Example 9.3</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn df-add-to-range [a r]
  (let [x (pd/df-val)
        y (pd/df-var)
        sum (pd/df-var #(+ @x @y))
        f (pc/fiber
           (for [i r]
             (do
               (y i)
               (pc/sleep 10)
               @sum)))]
    (x a)
    (pc/join f)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.3: Adding a number to a range of number with dataflow variables</em></span></p></blockquote></div><p>The <code class="literal">df-add-to-range</code> function shown previously defines the dataflow variables <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">sum</code>, where <code class="literal">sum</code> is dependent on <code class="literal">x</code> and <code class="literal">y</code>. The function then creates a fiber <code class="literal">f</code> that uses the <code class="literal">for</code> macro to<a class="indexterm" id="id00492"/> return a sequence of values. Within the body of the <code class="literal">for</code> macro, the dataflow variable <code class="literal">y</code> is set to a value from the range <code class="literal">r</code>, and the value <code class="literal">@sum</code> is returned. The fiber thus returns the result of adding <code class="literal">a</code> to all elements in the range <code class="literal">r</code>, as shown in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (df-add-to-range 2 (range 10))</strong></span>
(2 3 4 5 6 7 8 9 10 11)</pre></div><p>In conclusion, we <a class="indexterm" id="id00493"/>can use the <code class="literal">df-val</code> and <code class="literal">df-var</code> functions to define dataflow variables, whose value can be recomputed when its referenced variables are changed. Effectively, changing the state of a dataflow variable may cause other <a class="indexterm" id="id00494"/>dataflow variables to <span class="emphasis"><em>react</em></span> to the change.</p><p>We should note that the Pulsar library also implements channels, which are analogous to channels from the <code class="literal">core.async</code> library. In a nutshell, channels can be used to exchange data with fibers. The Pulsar library also provides constructs for reactive programming with channels, through the <code class="literal">co.paralleluniverse.pulsar.rx</code> namespace. These constructs are termed as <span class="emphasis"><em>reactive extensions</em></span>, and are very similar to transducers, in the sense that they perform some computation on the values in a channel. Reactive extensions are also implemented by the <span class="emphasis"><em>RxClojure</em></span> library. We should note that one of the limitations of both the<a class="indexterm" id="id00495"/> Pulsar and RxClojure libraries is that they are available only on the JVM, and can't be<a class="indexterm" id="id00496"/> used in ClojureScript programs. Thus, using <code class="literal">core.async</code> channels with transducers is a more feasible option in ClojureScript. Nevertheless, we will briefly explore reactive extensions through the RxClojure library in the following section.</p></div></div>
<div class="section" title="Using Reactive Extensions"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec0053"/>Using Reactive Extensions</h1></div></div></div><p>
<span class="strong"><strong>Reactive Extensions</strong></span> (written as <span class="strong"><strong>Rx</strong></span>) are a generalized implementation of reactive programming that can be<a class="indexterm" id="id00497"/> used to model event and data streams. Rx can be thought of as an object-oriented approach to reactive programming, in the sense that an event stream is an object with certain methods and properties. In Rx, asynchronous event streams are<a class="indexterm" id="id00498"/> termed as <span class="emphasis"><em>observables</em></span>. An entity or object that subscribes to events from an observable is called an <span class="emphasis"><em>observer</em></span>. Reactive<a class="indexterm" id="id00499"/> extensions are essentially a library of functions, or methods, to manipulate observables and create objects that conform to the observer-observable pattern. For example, an observable can be transformed using the Rx variants of the <code class="literal">map</code> and <code class="literal">filter</code> functions, as shown in the following illustration:</p><div class="mediaobject"><img alt="Using Reactive Extensions" src="graphics/B05024_09_01.jpg"/></div><p>As shown previously, an observable can be described as a collection of values that vary over a period of time. It's quite evident that observables can be treated as a sequence of values using the Rx-flavored variants of the <code class="literal">map</code> and <code class="literal">filter</code> functions. An observable can also be <a class="indexterm" id="id00500"/>subscribed to by an observer, and the observer will be asynchronously invoked for any value produced by an observable.</p><p>We will now discuss the various constructs of the RxClojure library (<a class="ulink" href="https://github.com/ReactiveX/RxClojure">https://github.com/ReactiveX/RxClojure</a>). There are several implementations of Rx across multiple<a class="indexterm" id="id00501"/> languages, such as C#, Java, and PHP. The Java library for reactive extensions is RxJava, and the RxClojure library provides Clojure bindings to RxJava. As we mentioned earlier, it's important to note that RxClojure can only be used on the JVM. Also, the RxClojure library predates the implementation of transducers in Clojure, and thus channels and transducers are a more portable and generic approach to reactive programming.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00105"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[io.reactivex/rxclojure "1.0.0"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [rx.lang.clojure.core :as rx]
            [rx.lang.clojure.blocking :as rxb]
            [rx.lang.clojure.interop :as rxj]))</pre></div></div></div><p>The <code class="literal">rx.lang.clojure.core</code> namespace contains functions for creating and manipulating observables. Observables are internally represented as collections of values. To extract values from observables, we can use functions from the <code class="literal">rx.lang.clojure.blocking</code> namespace. However, we must note that functions from the <code class="literal">rx.lang.clojure.blocking</code> namespace must be avoided in a program and used only for testing purposes. The <code class="literal">rx.lang.clojure.interop</code> namespace contains functions for performing Java interop with the underlying RxJava library.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00107"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c9/rx.clj</code> of the book's source code.</p></div></div><p>A value can be converted to an observable using the <code class="literal">return</code> function from the <code class="literal">rx.lang.clojure.core</code> namespace. An observable can be converted to a vector of values using the <code class="literal">rx.lang.clojure.blocking/into</code> function, and similarly, we can obtain the first value of an observable using the <code class="literal">rx.lang.clojure.blocking/first</code> function. These functions are demonstrated in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def o (rx/return 0))</strong></span>
#'user/o
<span class="strong"><strong>user&gt; (rxb/into [] o)</strong></span>
[0]
<span class="strong"><strong>user&gt; (rxb/first o)</strong></span>
0</pre></div><p>A sequence of values can be converted to an observable using the <code class="literal">seq-&gt;o</code> function from the <code class="literal">rx.lang.clojure.core</code> namespace. To convert the observable back to a sequence, we pass it to the <code class="literal">o-&gt;seq</code> function from the <code class="literal">rx.lang.clojure.blocking</code> namespace. For example, we<a class="indexterm" id="id00502"/> can convert the vector <code class="literal">[1 2 3]</code> to an observable and back to a sequence, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def o (rx/seq-&gt;o [1 2 3]))</strong></span>
#'user/o
<span class="strong"><strong>user&gt; (rxb/o-&gt;seq o)</strong></span>
(1 2 3)</pre></div><p>Another way of creating an observable is by using the <code class="literal">cons</code> and <code class="literal">empty</code> functions from the <code class="literal">rx.lang.clojure.core</code> namespace. The <code class="literal">empty</code> function creates an observable with no values, and the <code class="literal">cons</code> function adds or combines a value and an observable into a new, observable, similar to the standard <code class="literal">cons</code> function. We can create an observable containing the value <code class="literal">0</code> using the <code class="literal">cons</code> and <code class="literal">empty</code> functions as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def o (rx/cons 0 (rx/empty)))</strong></span>
#'user/o
<span class="strong"><strong>user&gt; (rxb/first o)</strong></span>
0</pre></div><p>As we mentioned earlier, observers can subscribe to events from observables. Observers can be defined by implementing the <code class="literal">rx.lang.clojure.Observer</code> interface. This interface defines three methods, namely <code class="literal">onNext</code>, <code class="literal">onError</code>, and <code class="literal">onCompleted</code>. The <code class="literal">onNext</code> method is called whenever an observable produces a new value, and the <code class="literal">onCompleted</code> method is called when an observable is done producing values. The <code class="literal">onError</code> method will be called in case an exception is encountered. Interestingly, all of these methods will be invoked asynchronously from an observable. For example, we can create an observer using the <code class="literal">reify</code> form to implement the <code class="literal">Observer</code> interface as shown in <span class="emphasis"><em>Example 9.4</em></span>:</p><div class="informalexample"><pre class="programlisting">(def observer
  (reify rx.Observer
    (onNext [this v] (println (str "Got value: " v "!")))
    (onError [this e] (println e))
    (onCompleted [this] (println "Done!"))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.4: Implementing the rx.lang.clojure.Observer interface</em></span></p></blockquote></div><p>An observable can call the methods of all its subscribed observers using the <code class="literal">on-next</code>, <code class="literal">on-error</code> and <code class="literal">on-completed</code> functions from the <code class="literal">rx.lang.clojure.core</code> namespace. We can also define an observable using these functions and the <code class="literal">observable*</code> form from the <code class="literal">rx.lang.clojure.core</code> namespace. The <code class="literal">observable*</code> form must be passed a function that takes a single argument, which represents an observer. For example, we can define a function to <a class="indexterm" id="id00503"/>create an observable of two values using the <code class="literal">observable*</code> form as shown in <span class="emphasis"><em>Example 9.5</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn make-observable []
  (rx/observable* (fn [s]
                    (-&gt; s
                        (rx/on-next :a)
                        (rx/on-next :b)
                        rx/on-completed))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.5: Creating an observable using the observable* form</em></span></p></blockquote></div><p>The function passed to the <code class="literal">observable*</code> form, shown previously, calls the <code class="literal">on-next</code> and <code class="literal">on-completed</code> functions to produce an observable of two values. We can convert this observable into a vector using the <code class="literal">into</code> function from the <code class="literal">rx.lang.clojure.blocking</code> namespace, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def o (make-observable))</strong></span>
#'user/o
<span class="strong"><strong>user&gt; (rxb/into [] o)</strong></span>
[:a :b]</pre></div><p>An observer can also be created using the <code class="literal">subscribe</code> function from the <code class="literal">rx.lang.clojure.core</code> namespace. This function must be passed a function that takes a single value, and an observer will be created by implementing the <code class="literal">onNext</code> method using the supplied function. We can also pass a second argument representing the <code class="literal">onError</code> method, as well as a third argument that represents the <code class="literal">onCompleted</code> method, to the <code class="literal">subscribe</code> function. For example, we can subscribe to an observable using the <code class="literal">subscribe</code> function, and apply a function to all values in the observable using the <code class="literal">rx.lang.clojure.core/map</code> function, as shown in <span class="emphasis"><em>Example 9.6</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn rx-inc [o]
  (rx/subscribe o (fn [v] (println (str "Got value: " v "!"))))
  (rx/map inc o))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.6: Subscribing to an observable using the subscribe function</em></span></p></blockquote></div><p>We can create an observable and pass it to the <code class="literal">rx-inc</code> function defined in <span class="emphasis"><em>Example 9.6</em></span>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def o (rx/seq-&gt;o [0 1 2]))</strong></span>
#'user/o
<span class="strong"><strong>user&gt; (rx-inc o)</strong></span>
Got value: 0!
Got value: 1!
Got value: 2!
#&lt;rx.Observable 0xc3fae8&gt;</pre></div><p>The function passed to the <code class="literal">subscribe</code> form in <span class="emphasis"><em>Example 9.6</em></span> is executed every time the <code class="literal">inc</code> function is applied to a value in the observable <code class="literal">o</code>. We could as well define the <code class="literal">rx-inc</code> function using<a class="indexterm" id="id00504"/> Java interop with RxJava, as shown in <span class="emphasis"><em>Example 9.7</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn rxj-inc [o]
  (.subscribe o (rxj/action [v]
                  (println (str "Got value: " v "!"))))
  (.map o (rxj/fn [v] (inc v))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.7: Subscribing to an observable using the Java interop</em></span></p></blockquote></div><p>It's quite clear that using the RxJava library through Java interop isn't pretty, as we would have to wrap all the functions in the <code class="literal">action</code> and <code class="literal">fn</code> forms from the <code class="literal">rx.lang.clojure.interop</code> namespace. The <code class="literal">action</code> macro is used to represent a function that performs a side-effect, whereas the <code class="literal">fn</code> macro is used to wrap functions that return values. Observables can also be created using the Java interop. This is done using the <code class="literal">from</code> static method from the <code class="literal">rx.lang.clojure.core.Observable</code> class. The following output demonstrates this method as well as the <code class="literal">rxj-inc</code> function defined in <span class="emphasis"><em>Example 9.7</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (def o (rx.Observable/from [0 1 2]))</strong></span>
#'user/o
<span class="strong"><strong>user&gt; (rxj-inc o)</strong></span>
Got value: 0!
Got value: 1!
Got value: 2!
#&lt;rx.Observable 0x16459ef&gt;</pre></div><p>Of course, we should prefer to use functions from the <code class="literal">rx.lang.clojure.core</code> namespace, and we are using Java interop here only to show that it is possible. Similar to the <code class="literal">map</code> function used in <span class="emphasis"><em>Example 9.6</em></span>, there are several other functions in the <code class="literal">rx.lang.clojure.core</code> namespace that allow us to treat observables as sequences. Thus, functions such as <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code> comprise the interface of observables, and describe the many ways in which we can interact with them. For example, the following output demonstrates the Rx variants of the <code class="literal">take</code>, <code class="literal">cycle</code>, and <code class="literal">range</code> functions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (rxb/into [] (-&gt;&gt; (rx/range)</strong></span>
<span class="strong"><strong>                        (rx/take 10)))</strong></span>
[0 1 2 3 4 5 6 7 8 9]
<span class="strong"><strong>user&gt; (rxb/into [] (-&gt;&gt; (rx/cycle (rx/return 1))</strong></span>
<span class="strong"><strong>                        (rx/take 5)))</strong></span>
[1 1 1 1 1]</pre></div><p>The <code class="literal">rx.lang.clojure.core</code> namespace also provides a <code class="literal">filter</code> function that can be used with an observable and a predicate, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (rxb/into [] (-&gt;&gt; (rx/seq-&gt;o [:a :b :c :d :e])</strong></span>
<span class="strong"><strong>                        (rx/filter #{:b :c})))</strong></span>
[:b :c]</pre></div><p>The <code class="literal">group-by</code> and <code class="literal">mapcat</code> functions from the <code class="literal">rx.lang.clojure.core</code> namespace have the same semantics as the standard versions of these functions. For example, let's define a function that<a class="indexterm" id="id00505"/> uses the <code class="literal">group-by</code> and <code class="literal">mapcat</code> functions, as shown in <span class="emphasis"><em>Example 9.8</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn group-maps [ms]
  (-&gt;&gt; ms
       (rx/seq-&gt;o)
       (rx/group-by :k)
       (rx/mapcat (fn [[k vs :as me]]
                    (rx/map #(vector k %) vs)))
       (rxb/into [])))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.8: Using the group-by and mapcat functions</em></span></p></blockquote></div><p>The <code class="literal">group-maps</code> function, defined previously, will transform a number of maps into an observable, group the maps by their values for the key <code class="literal">:k</code>, and create a number of vectors using the <code class="literal">mapcat</code> and <code class="literal">map</code> functions. Of course, we wouldn't really need such a function in practice, and it's only shown here to demonstrate how the <code class="literal">group-by</code> and <code class="literal">mapcat</code> functions can be used. We can pass a vector of maps to the <code class="literal">group-maps</code> function to produce a sequence of vectors, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (group-maps [{:k :a :v 1}</strong></span>
<span class="strong"><strong>                   {:k :b :v 2}</strong></span>
<span class="strong"><strong>                   {:k :a :v 3}</strong></span>
<span class="strong"><strong>                   {:k :c :v 4}])</strong></span>
[[:a {:k :a, :v 1}]
 [:a {:k :a, :v 3}]
 [:b {:k :b, :v 2}]
 [:c {:k :c, :v 4}]]</pre></div><p>Several observables can be combined using the <code class="literal">merge</code> function from the <code class="literal">rx.lang.clojure.core</code> namespace. The <code class="literal">merge</code> function can be passed any number of observables, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (let [o1 (rx/seq-&gt;o (range 5))</strong></span>
<span class="strong"><strong>            o2 (rx/seq-&gt;o (range 5 10))</strong></span>
<span class="strong"><strong>            o (rx/merge o1 o2)]</strong></span>
<span class="strong"><strong>        (rxb/into [] o))</strong></span>
[0 1 2 3 4 5 6 7 8 9]</pre></div><p>An observable can also be split up into two observables using the <code class="literal">split-with</code> function from the <code class="literal">rx.lang.clojure.core</code> namespace. This function must be passed an observable and a predicate function, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (-&gt;&gt; (range 6)</strong></span>
<span class="strong"><strong>           rx/seq-&gt;o</strong></span>
<span class="strong"><strong>           (rx/split-with (partial &gt;= 3))</strong></span>
<span class="strong"><strong>           rxb/first</strong></span>
<span class="strong"><strong>           (map (partial rxb/into [])))</strong></span>
([0 1 2 3] [4 5])</pre></div><p>In summary, the RxClojure library provides us with several constructs for creating and manipulating observables. We can also easily create observers that asynchronously <span class="emphasis"><em>react</em></span> to observables using<a class="indexterm" id="id00506"/> the <code class="literal">subscribe</code> function from this library. Also, the constructs from the <code class="literal">rx.lang.clojure.core</code> namespace have semantics similar to that of standard functions such as <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">mapcat</code>. There are several functions in the<code class="literal"> rx.lang.clojure.core</code> namespace that we haven't talked about in this section, and you're encouraged to explore them on your own.</p></div>
<div class="section" title="Using functional reactive programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec0054"/>Using functional reactive programming</h1></div></div></div><p>A more functional flavor of reactive programming is <span class="strong"><strong>functional reactive programming</strong></span> (abbreviated as <span class="strong"><strong>FRP</strong></span>). FRP was<a class="indexterm" id="id00507"/> first described in the late '90s by Conal Elliott, who was a member of the Microsoft Graphics Research Group at the time, and Paul Hudak, a major contributor to the Haskell programming language. FRP<a class="indexterm" id="id00508"/> was originally described as a bunch of functions to interact with <span class="emphasis"><em>events</em></span> and <span class="emphasis"><em>behaviors</em></span>. Both events and behaviors represent values that change over time. The major difference between these two is that events are values that change discretely over time, whereas behaviors are continuously changing values. There is no mention of an observer-observable pattern in FRP. Also, programs in FRP are written as composable transformations of events <a class="indexterm" id="id00509"/>and behaviors, and are also termed as <span class="strong"><strong>compositional event systems</strong></span> (<span class="strong"><strong>CESs</strong></span>).</p><p>Modern implementations of FRP provide constructs to create and transform asynchronous event streams. Also, any form of state change is represented as an event stream. In this perspective, a click of a button, a request made to a server, and mutating a variable, can all be treated as event<a class="indexterm" id="id00510"/> streams. The <span class="emphasis"><em>Bacon.js</em></span> library (<a class="ulink" href="https://github.com/baconjs/bacon.js/">https://github.com/baconjs/bacon.js/</a>) is a JavaScript implementation of FRP, and the <a class="indexterm" id="id00511"/>
<span class="emphasis"><em>Yolk</em></span> library (<a class="ulink" href="https://github.com/Cicayda/yolk">https://github.com/Cicayda/yolk</a>) provides ClojureScript bindings to the Bacon.js library. In this section, we will briefly study the constructs provided by the Yolk library.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00108"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[yolk "0.9.0"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [yolk.bacon :as y]))</pre></div><p>In addition to the preceding dependencies, the following examples also use the <code class="literal">set-html!</code> and <code class="literal">by-id</code> functions from <code class="literal">src/m_clj/c9/common.cljs</code>. These functions are defined as follows:</p><div class="informalexample"><pre class="programlisting">(defn ^:export by-id [id]
  (.getElementById js/document id))

(defn ^:export set-html! [el s]
  (set! (.-innerHTML el) s))</pre></div><p>Ensure that the code in the following ClojureScript examples is compiled, using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lein cljsbuild once</strong></span>
</pre></div></div></div><p>The <code class="literal">yolk.bacon</code> namespace provides several functions to create event streams, such as the <code class="literal">later</code> and <code class="literal">interval</code> functions. The <code class="literal">later</code> function creates an event stream that produces a single value after a given delay. The <code class="literal">interval</code> function can infinitely repeat a value with a given time<a class="indexterm" id="id00512"/> interval. Both these functions must be passed a number of milliseconds as the first argument and a value to produce as the second argument.</p><p>Event streams in the Yolk library may produce an infinite number of values. We can limit the number of values produced by an event stream by using the <code class="literal">yolk.bacon/sliding-window</code> function, which creates an event stream that drops older values once it's full. This function must be passed an event stream and a number indicating the capacity of the event stream returned by it.</p><p>We can also create an <a class="indexterm" id="id00513"/>
<span class="emphasis"><em>event bus</em></span>, onto which we can arbitrarily push values, using the <code class="literal">bus</code> function from the <code class="literal">yolk.bacon</code> namespace. The <code class="literal">push</code> function puts a value onto an event bus, and the <code class="literal">plug</code> function connects an event bus to another event stream.</p><p>To listen to values produced from event streams, we can use the <code class="literal">on-value</code>, <code class="literal">on-error</code>, and <code class="literal">on-end</code> functions. The <code class="literal">on-value</code> and <code class="literal">on-error</code> functions will call a supplied 1-arity function whenever a given event stream produces a value or an error, respectively. The <code class="literal">on-end</code> function will call a supplied function that takes no arguments whenever a stream ends. This function is often used with the <code class="literal">yolk.bacon/never</code> function, which creates an event stream that ends immediately without producing a value.</p><p>Event streams can also be combined in several ways. The <code class="literal">merge-all</code> function combines a vector of several event streams into a single one. Another function that can collect values from several event streams in this way is the <code class="literal">flat-map</code> function. Alternatively, the <code class="literal">combine-array</code> function can be used to create a single event stream that produces arrays of the values from the supplied streams. The <code class="literal">yolk.bacon/when</code> function can be used to conditionally combine several channels. This function must be passed a number of clauses, similar to the <code class="literal">cond</code> form. Each clause must have two parts—a vector of event streams and an expression that will be invoked when all the supplied event streams produce values.</p><p>The <code class="literal">yolk.bacon</code> namespace also provides event stream based variants of the standard <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">take</code> functions. These functions take an event stream as the first argument, which is a little different from the semantics of the standard versions of these functions.</p><p>Using these functions from the Yolk library, we can implement a simplified ClojureScript based solution to the dining philosophers problem, which we described in the previous chapters. For a detailed explanation of the dining philosophers problem and its solution, refer to <a class="link" href="ch17.html" title="Chapter 2. Orchestrating Concurrency and Parallelism">Chapter 2</a>, <span class="emphasis"><em>Orchestrating Concurrency and Parallelism</em></span> and <a class="link" href="ch23.html" title="Chapter 8. Leveraging Asynchronous Tasks">Chapter 8</a>, <span class="emphasis"><em>Leveraging Asynchronous Tasks</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00112"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c9/yolk/core.cljs</code> of the book's source code. Also, the HTML page for the following ClojureScript examples can be found in <code class="literal">resources/html/yolk.html</code>. The following scripts will be included in this page:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="../js/bacon.js"&gt;
&lt;/script&gt;
&lt;script type="text/javascript" src="../js/out/yolk.js"&gt;
&lt;/script&gt;</pre></div></div></div><p>In this implementation <a class="indexterm" id="id00514"/>of the dining philosophers problem, we will represent the state of the philosophers and the forks on the table using event buses. The event buses can then be combined using the <code class="literal">when</code> function from the Yolk library. We won't maintain much state about the philosophers for the sake of simplicity. Let's first define functions to print the philosophers and represent the routine of a philosopher, as shown in the following <span class="emphasis"><em>Example 9.9</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn render-philosophers [philosophers]
  (apply str
         (for [p (reverse philosophers)]
           (str "&lt;div&gt;" p "&lt;/div&gt;"))))

(defn philosopher-fn [i n forks philosophers wait-ms]
  (let [p (nth philosophers i)
        fork-1 (nth forks i)
        fork-2 (nth forks (-&gt; i inc (mod n)))]
    (fn []
      (js/setTimeout
       (fn []
         (y/push fork-1 :fork)
         (y/push fork-2 :fork)
         (y/push p {}))
       wait-ms)
      (str "Philosopher " (inc i) " ate!"))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.9: Solving the dining philosophers problem with event streams</em></span></p></blockquote></div><p>The preceding <code class="literal">render-philosophers</code> function will wrap each philosopher in a <code class="literal">div</code> tag, which will be displayed on a web page. The <code class="literal">philosopher-fn</code> function returns a function that represents the routine of a philosopher. The function returned by the <code class="literal">philosopher-fn</code> function sets off a task, using the <code class="literal">setTimeout</code> JavaScript function, to push values representing a particular philosopher and his associated forks into the event buses. This function will finally return a string indicating that the given philosopher was able to eat the food supplied to<a class="indexterm" id="id00515"/> him. Using these functions, we can create a simulation of the dining philosophers problem in a web page, as shown in the following <span class="emphasis"><em>Example 9.10</em></span>:</p><div class="informalexample"><pre class="programlisting">(let [out (by-id "ex-9-10-out")
      n 5
      [f1 f2 f3 f4 f5 :as forks] (repeatedly n #(y/bus))
      [p1 p2 p3 p4 p5 :as philosophers] (repeatedly n #(y/bus))
      eat #(philosopher-fn % n forks philosophers 1000)
      events (y/when [p1 f1 f2] (eat 0)
                     [p2 f2 f3] (eat 1)
                     [p3 f3 f4] (eat 2)
                     [p4 f4 f5] (eat 3)
                     [p5 f5 f1] (eat 4))]
  (-&gt; events
      (y/sliding-window n)
      (y/on-value
       #(set-html! out (render-philosophers %))))
  (doseq [f forks]
    (y/push f :fork))
  (doseq [p philosophers]
    (y/push p {})))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.10: Solving the dining philosophers problem with event streams (continued)</em></span></p></blockquote></div><p>In the <code class="literal">let</code> form shown in <span class="emphasis"><em>Example 9.10</em></span>, we created the philosophers and forks in our simulation using the <code class="literal">bus</code> function from the Yolk library. The values produced by these event buses are then combined using a <code class="literal">when</code> form. The <code class="literal">when</code> function in the preceding code will check for events from a philosopher and the forks on his left- and right-hand side. The combinations of philosophers and forks are, in fact, hardcoded into the clauses of the <code class="literal">when</code> form. Of course, we must understand that the clauses of the <code class="literal">when</code> form shown previously could have easily been generated using a macro. Values are then placed onto the event buses representing the philosophers and forks using the <code class="literal">push</code> function, to start the simulation. The last five philosophers who could eat are rendered in the web page, as shown here:</p><div class="mediaobject"><img alt="Using functional reactive programming" src="graphics/B05024_09_02.jpg"/></div><p>In summary, the Yolk library provides several constructs to handle event streams. There are several functions from this library that we haven't discussed, and you should explore them on your own. In the following section, we will provide examples that demonstrate the other functions<a class="indexterm" id="id00516"/> from the Yolk library.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00113"/>Note</h3><p>Some of the<a class="indexterm" id="id00517"/> preceding examples are based on code from <span class="emphasis"><em>Yolk examples</em></span> by Wilkes Joiner (<a class="ulink" href="https://github.com/Cicayda/yolk-examples">https://github.com/Cicayda/yolk-examples</a>).</p></div></div></div>
<div class="section" title="Building reactive user interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec0055"/>Building reactive user interfaces</h1></div></div></div><p>One of the primary applications of reactive programming is frontend development, where we must create user interface components that react asynchronously to changes in state. In this section, we<a class="indexterm" id="id00518"/> will describe a few examples implemented using the <code class="literal">core.async</code> library and the Yolk library. This is meant to give you a comparison between channels and event streams, and also demonstrate how we can design solutions to problems using both these concepts. Note that only the overall design and code for these examples will be described, and you should be able to fill in the details on your own.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00114"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[yolk "0.9.0"]
[org.clojure/core.async "0.1.346.0-17112a-alpha"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [goog.events :as events]
            [goog.events.EventType]
            [goog.style :as style]
            [cljs.core.async :as a]
            [yolk.bacon :as y])
  (:require-macros [cljs.core.async.macros
                    :refer [go go-loop alt!]]))</pre></div><p>In addition to the preceding dependencies, the following examples also use the <code class="literal">set-html!</code> and <code class="literal">by-id</code> functions from <code class="literal">src/m_clj/c9/common.cljs</code>. Ensure that the code in the following ClojureScript examples is compiled, using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lein cljsbuild once</strong></span>
</pre></div></div></div><p>As a first example, let's create three asynchronous tasks that each produce values at different time<a class="indexterm" id="id00519"/> intervals. We must fetch all the values produced by these tasks and render them on a web page in the same order.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00117"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c9/reactive/core.cljs</code> of the book's source code. Also, the HTML page for the following ClojureScript examples can be found in <code class="literal">resources/html/reactive.html</code>. The following scripts will be included in this page:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="../js/bacon.js"&gt;
&lt;/script&gt;
&lt;script type="text/javascript" src="../js/out/reactive.js"&gt;
&lt;/script&gt;</pre></div></div></div><p>We could implement this using processes and channels from the <code class="literal">core.async</code> library. In this case, channels will convey the values produced by three processes, and we will use a <code class="literal">merge</code> operation to combine these channels, as shown in the following <span class="emphasis"><em>Example 9.11</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn render-div [q]
  (apply str
         (for [p (reverse q)]
           (str "&lt;div class='proc-" p "'&gt;Process " p "&lt;/div&gt;"))))

(defn start-process [v t]
  (let [c (a/chan)]
    (go (while true
          (a/&lt;! (a/timeout t))
          (a/&gt;! c v)))
    c))

(let [out (by-id "ex-9-11-out")
      c1 (start-process 1 250)
      c2 (start-process 2 1000)
      c3 (start-process 3 1500)
      c (a/merge [c1 c2 c3])
      firstn (fn [v n]
               (if (&lt;= (count v) n)
                 v
                 (subvec v (- (count v) n))))]
  (go-loop [q []]
    (set-html! out (render-div q))
    (recur (-&gt; (conj q (a/&lt;! c))
               (firstn 10)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.11: Three asynchronous tasks using channels</em></span></p></blockquote></div><p>The preceding <code class="literal">start-process</code> function will create a process that periodically produces values using the <code class="literal">go</code> form, and returns a channel from which the values can be read. The <code class="literal">render-div</code> function<a class="indexterm" id="id00520"/> will generate HTML for the values produced by the three tasks. Only the ten most recent values will be shown. This code will produce the following output:</p><div class="mediaobject"><img alt="Building reactive user interfaces" src="graphics/B05024_09_03.jpg"/></div><p>We could also implement the preceding example using FRP, in which values produced by each of the three tasks are represented as event streams. The <code class="literal">merge-all</code> function from the <code class="literal">yolk.bacon</code> namespace can be used to combine these event streams, and the <code class="literal">sliding-window</code> function can obtain the ten most recent values produced by the resulting stream. The <code class="literal">render-div</code> function from <span class="emphasis"><em>Example 9.11</em></span> can be reused to render the values. This is implemented in <span class="emphasis"><em>Example 9.12</em></span>, and produces the same output as <span class="emphasis"><em>Example 9.11</em></span>:</p><div class="informalexample"><pre class="programlisting">(let [out (by-id "ex-9-12-out")
      events [(y/interval 250 1)
              (y/interval 1000 2)
              (y/interval 1500 3)]]
  (-&gt; events
      y/merge-all
      (y/sliding-window 10)
      (y/on-value
       #(set-html! out (render-div %)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.12: Three asynchronous tasks using FRP</em></span></p></blockquote></div><p>Next, let's try to capture mouse events from a particular <code class="literal">div</code> tag, and display the page offset values of the locations of these events. We can do this with channels, but we would first need a function to convey DOM events onto a channel. We can implement this using the <code class="literal">goog.events/listen</code> and <code class="literal">cljs.core.async/put!</code> functions, as shown in <span class="emphasis"><em>Example 9.13</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn listen
  ([el type] (listen el type nil))
  ([el type f] (listen el type f (a/chan)))
  ([el type f out]
   (events/listen el type
                  (fn [e] (when f (f e)) (a/put! out e)))
   out))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.13: A function to convey events onto a channel</em></span></p></blockquote></div><p>We can now use the <code class="literal">listen</code> function defined previously to listen to the <code class="literal">goog.events.EventType.MOUSEMOVE</code> event type from a particular <code class="literal">div</code> tag. The values will have to be converted to page offsets, and this can be done using the <code class="literal">getPageOffsetLeft</code> and <code class="literal">getPageOffsetTop</code> functions from the <code class="literal">goog.style</code> namespace. This<a class="indexterm" id="id00521"/> implementation is described in <span class="emphasis"><em>Example 9.14</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn offset [el]
  [(style/getPageOffsetLeft el) (style/getPageOffsetTop el)])

(let [el (by-id "ex-9-14")
      out (by-id "ex-9-14-out")
      events-chan (listen el goog.events.EventType.MOUSEMOVE)
      [left top] (offset el)
      location (fn [e]
                 {:x (+ (.-offsetX e) (int left))
                  :y (+ (.-offsetY e) (int top))})]
  (go-loop []
    (if-let [e (a/&lt;! events-chan)]
      (let [loc (location e)]
        (set-html! out (str (:x loc) ", " (:y loc)))
        (recur)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.14: Mouse events using channels</em></span></p></blockquote></div><p>We can also implement a solution to this problem using the <code class="literal">from-event-stream</code> and <code class="literal">map</code> functions from the Yolk library. Interestingly, the events produced by the stream returned by the <code class="literal">from-event-target</code> function will have page offsets of the event stored as the <code class="literal">pageX</code> and <code class="literal">pageY</code> properties. This allows us to have a much simpler implementation, as shown in <span class="emphasis"><em>Example 9.15</em></span>:</p><div class="informalexample"><pre class="programlisting">(let [el (by-id "ex-9-15")
      out (by-id "ex-9-15-out")
      events (y/from-event-target el "mousemove")]
  (-&gt; events
      (y/map (juxt (fn [e] (.-pageX e))
                   (fn [e] (.-pageY e))))
      (y/map (fn [[x y]] (str x ", " y)))
      (y/on-value
       #(set-html! out %))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.15: Mouse events using FRP</em></span></p></blockquote></div><p>Both of the implementations shown in <span class="emphasis"><em>Example 9.14</em></span> and <span class="emphasis"><em>Example 9.15</em></span> work as expected, and produce the following output:</p><div class="mediaobject"><img alt="Building reactive user interfaces" src="graphics/B05024_09_04.jpg"/></div><p>As a final example, we will simulate several search queries being performed and display the results from the first three<a class="indexterm" id="id00522"/> queries that return results. The queries can be described as: two queries for web results, two queries for image results, and two queries for video results. We can implement these simulated queries as shown in <span class="emphasis"><em>Example 9.16</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn chan-search [kind]
  (fn [query]
    (go
      (a/&lt;! (a/timeout (rand-int 100)))
      [kind query])))

(def chan-web1 (chan-search :web1))
(def chan-web2 (chan-search :web2))
(def chan-image1 (chan-search :image1))
(def chan-image2 (chan-search :image2))
(def chan-video1 (chan-search :video1))
(def chan-video2 (chan-search :video2))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.16: Simulating search queries with channels</em></span></p></blockquote></div><p>The <code class="literal">chan-search</code> function returns a function that uses the <code class="literal">cljs.core.async/timeout</code> function to simulate a <a class="indexterm" id="id00523"/>search query by parking the current task for a random number of milliseconds. Using the <code class="literal">chan-search</code> function, we create several queries for the different kinds of results we are interested in. Using these functions, we can implement a function to perform all the queries and return the first three results, as shown in <span class="emphasis"><em>Example 9.17</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn chan-search-all [query &amp; searches]
  (let [cs (for [s searches]
             (s query))]
    (-&gt; cs vec a/merge)))

(defn chan-search-fastest [query]
  (let [t (a/timeout 80)
        c1 (chan-search-all query chan-web1 chan-web2)
        c2 (chan-search-all query chan-image1 chan-image2)
        c3 (chan-search-all query chan-video1 chan-video2)
        c (a/merge [c1 c2 c3])]
    (go (loop [i 0
               ret []]
          (if (= i 3)
            ret
            (recur (inc i)
                   (conj ret (alt!
                               [c t] ([v] v)))))))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.17: Simulating search queries with channels (continued)</em></span></p></blockquote></div><p>As shown in the preceding example, the <code class="literal">merge</code> function can be used to combine channels that produce the results of the search queries. Note that the queries to all three types of results, namely web, images, and videos, are timed out after <code class="literal">80</code> milliseconds. We can bind the <code class="literal">chan-search-fastest</code> function to the click of a mouse button using the <code class="literal">listen</code> function we defined earlier, as shown in <span class="emphasis"><em>Example 9.18</em></span>:</p><div class="informalexample"><pre class="programlisting">(let [out (by-id "ex-9-18-out")
      button (by-id "search-1")
      c (listen button goog.events.EventType.CLICK)]
  (go (while true
        (let [e (a/&lt;! c)
              result (a/&lt;! (chan-search-fastest "channels"))
              s (str result)]
          (set-html! out s)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.18: Simulating search queries with channels (continued)</em></span></p></blockquote></div><p>Clicking on the button bound to the <code class="literal">chan-search-fastest</code> function will show the following output. Note that the <code class="literal">nil</code> value in the following output indicates a timeout of all queries for a particular search result type.</p><div class="mediaobject"><img alt="Building reactive user interfaces" src="graphics/B05024_09_05.jpg"/></div><p>We can just as<a class="indexterm" id="id00524"/> easily implement an FRP version of the simulation of search queries that was previously described. The queries for the various sources of data are defined as shown in the following <span class="emphasis"><em>Example 9.19</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn frp-search [kind]
  (fn [query]
    (y/later (rand-int 100) [kind query])))

(def frp-web1 (frp-search :web1))
(def frp-web2 (frp-search :web2))
(def frp-image1 (frp-search :image1))
(def frp-image2 (frp-search :image2))
(def frp-video1 (frp-search :video1))
(def frp-video2 (frp-search :video2))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.19: Simulating search queries with FRP</em></span></p></blockquote></div><p>The preceding functions all return event streams for search results. The search results produced can be combined with timeouts using the <code class="literal">later</code>, <code class="literal">merge</code>, and <code class="literal">combine-as-array</code> functions from the <code class="literal">yolk.bacon</code> namespace, as shown in <span class="emphasis"><em>Example 9.20</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn frp-search-all [query &amp; searches]
  (let [results (map #(% query) searches)
        events (cons (y/later 80 "nil") results)]
    (-&gt; (apply y/merge events)
        (y/take 1))))

(defn frp-search-fastest [query]
  (y/combine-as-array
   (frp-search-all query frp-web1 frp-web2)
   (frp-search-all query frp-image1 frp-image2)
   (frp-search-all query frp-video1 frp-video2)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.20: Simulating search queries with FRP (continued)</em></span></p></blockquote></div><p>The <code class="literal">frp-search-fastest</code> function can be invoked on clicking a button, as shown in <span class="emphasis"><em>Example 9.21</em></span>:</p><div class="informalexample"><pre class="programlisting">(let [out (by-id "ex-9-21-out")
      button (by-id "search-2")
      events (y/from-event-target button "click")]
  (-&gt; events
      (y/flat-map-latest #(frp-search-fastest "events"))
      (y/on-value
       #(set-html! out %))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.21: Simulating search queries with FRP (continued)</em></span></p></blockquote></div><p>The preceding example produces the following output when the search button is clicked:</p><div class="mediaobject"><img alt="Building reactive user interfaces" src="graphics/B05024_09_06.jpg"/></div><p>In conclusion, we <a class="indexterm" id="id00525"/>can use both channels and event streams to implement interactive interfaces in web pages. Although the FRP implementations of the preceding examples are slightly shorter, we can say that both the <code class="literal">core.async</code> and Yolk libraries have their own elegance.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00118"/>Note</h3><p>The preceding<a class="indexterm" id="id00526"/> examples are based<a class="indexterm" id="id00527"/> on code from <span class="emphasis"><em>Communicating Sequential Processes</em></span> by David Nolen (<a class="ulink" href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/">http://swannodette.github.io/2013/07/12/communicating-sequential-processes/</a>) and <span class="emphasis"><em>CSP vs. FRP</em></span> by Draco Dormiens (<a class="ulink" href="http://potetm.github.io/2014/01/07/frp.html">http://potetm.github.io/2014/01/07/frp.html</a>).</p></div></div></div>
<div class="section" title="Introducing Om"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec0056"/>Introducing Om</h1></div></div></div><p>The <span class="emphasis"><em>Om</em></span> library (<a class="ulink" href="https://github.com/omcljs/om">https://github.com/omcljs/om</a>) is a<a class="indexterm" id="id00528"/> great tool for building dynamic user interfaces in<a class="indexterm" id="id00529"/> ClojureScript. In fact, it's an interface to <span class="emphasis"><em>React.js</em></span> (<a class="ulink" href="http://facebook.github.io/react/">http://facebook.github.io/react/</a>), which is<a class="indexterm" id="id00530"/> a JavaScript library for creating interactive user interface components. Om lets us define a user interface as a hierarchy of components, and<a class="indexterm" id="id00531"/> each component reactively modifies its appearance based on changes to the component's state. In this way, Om components <span class="emphasis"><em>react</em></span> to changes in their state.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00119"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[org.omcljs/om "0.8.8"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [om.core :as om :include-macros true]
            [om.dom :as dom :include-macros true]))</pre></div><p>In addition to the preceding dependencies, the following examples also use the <code class="literal">by-id</code> function from <code class="literal">src/m_clj/c9/common.cljs</code>. Ensure that the code in the following ClojureScript examples is compiled, using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lein cljsbuild once</strong></span>
</pre></div></div></div><p>The Om components are generally defined by implementing the <code class="literal">IRender</code> and <code class="literal">IRenderState</code> protocols from the <code class="literal">om.core</code> namespace. The <code class="literal">IRender</code> protocol declares a single function <code class="literal">render</code>, and similarly the <code class="literal">IRenderState</code> protocol declares the <code class="literal">render-state</code> function. The <code class="literal">render</code> and <code class="literal">render-state</code> functions define how a component that implements either of these protocols is converted to DOM, which can be rendered by a web browser. The implementations of these functions must return a DOM object constructed using functions from the <code class="literal">om.dom</code> namespace. There are also several other protocols in the <code class="literal">om.core</code> namespace that allow us to define a component's behavior. Internally, Om uses React.js to perform batched updates to the DOM for the sake of performance, and uses <span class="emphasis"><em>virtual DOM</em></span> to maintain the state of the DOM to be rendered.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00122"/>Note</h3><p>The following examples can be found in <code class="literal">src/m_clj/c9/om/core.cljs</code> of the book's source code. Also, the HTML page for the following ClojureScript examples can be found in <code class="literal">resources/html/om.html</code>. The following scripts will be included in this page:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="../js/out/om.js"&gt;
&lt;/script&gt;</pre></div></div></div><p>Let's now build a <a class="indexterm" id="id00532"/>simple component using Om. Suppose we want to build a web application. One of the first steps in doing so is creating a login page for our application. As an example, let's create a simple login form with Om. A user will enter their username and password in this form. The only requirement is that the submit button of this form must be enabled only if the user has entered a username and password. Let's start off by defining some functions to create an input field of a form, as shown in <span class="emphasis"><em>Example 9.22</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn update-input-value-fn [owner]
  (fn [e]
    (let [target (.-target e)
          val (.-value target)
          id (keyword (.-id target))]
      (om/set-state! owner id val))))

(defn input-field [text owner attrs]
  (let [handler (update-input-value-fn owner)
        event-attr {:onChange handler}
        js-attrs (-&gt; attrs (merge event-attr) clj-&gt;js)]
    (dom/div
     nil
     (dom/div nil text)
     (dom/input js-attrs))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.22: A login form using Om</em></span></p></blockquote></div><p>The <code class="literal">update-input-value-fn</code> function defined in <span class="emphasis"><em>Example 9.22</em></span> accepts a component <code class="literal">owner</code> as an argument and returns a function that we can bind to a DOM event. The returned function updates the state of the component with the value of the <code class="literal">.-value</code> property using the <code class="literal">set-state!</code> function from the <code class="literal">om.core</code> namespace. The <code class="literal">input-field</code> function returns a DOM object for an input field with some associated properties. The <code class="literal">input-field</code> function also creates an event handler using the <code class="literal">update-input-value-fn</code> function<a class="indexterm" id="id00533"/> and binds it to the <code class="literal">onChange</code> event of the input field.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00123"/>Note</h3><p>Note that a component can change its state or the global application state by using the <code class="literal">set-state!</code>, <code class="literal">update-state!</code>, <code class="literal">update!</code>, or <code class="literal">transact!</code> functions from the <code class="literal">om.core</code> namespace.</p></div></div><p>Next, let's define a form as a component using the <code class="literal">om.core/IRenderState</code> protocol and <code class="literal">input-field</code> function, as shown in <span class="emphasis"><em>Example 9.23</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn form [data owner]
  (reify
    om/IInitState
    (init-state [_]
      {:username "" :password ""})
    om/IRenderState
    (render-state [_ state]
      (dom/form
       nil
       (input-field "Username" owner
                    {:type "text"
                     :id "username"
                     :value (:username state)})
       (input-field "Password" owner
                    {:type "password"
                     :id "password"
                     :value (:password state)})
       (dom/br nil)
       (dom/input
        #js {:type "submit"
             :value "Login"
             :disabled (or (-&gt; state :username empty?)
                           (-&gt; state :password empty?))})))))

(om/root form nil {:target (by-id "ex-9-23")})</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 9.23: A login form using Om (continued)</em></span></p></blockquote></div><p>The preceding <code class="literal">form</code> function<a class="indexterm" id="id00534"/> creates a component by implementing the <code class="literal">render-state</code> function of the <code class="literal">IRenderState</code> protocol. This component also implements the <code class="literal">IInitState</code> protocol to define the initial state of the component. The <code class="literal">form</code> function will render a login form with two input fields, for a username and password, and a login button. The button is enabled only when the username and password are entered. Also, the component is mounted onto a <code class="literal">div</code> using the <code class="literal">om.core/root</code> function. The following output in a web page describes the behavior of the component defined by the <code class="literal">form</code> function:</p><div class="mediaobject"><img alt="Introducing Om" src="graphics/B05024_09_07.jpg"/></div><p>The preceding output describes two states of the login form component defined by the <code class="literal">form</code> function. The login button is observed to be disabled when either the username or password fields are empty, and is enabled only when the user enters values in both of these input fields. In this way, the login form <span class="emphasis"><em>reacts</em></span> to changes in the state of its input fields.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00124"/>Note</h3><p>Visit <a class="ulink" href="https://github.com/omcljs/om/wiki/Documentation">https://github.com/omcljs/om/wiki/Documentation</a> for complete documentation<a class="indexterm" id="id00535"/> on all the protocols, functions, and macros in the Om library.</p></div></div><p>Thus, the Om library<a class="indexterm" id="id00536"/> provides us with several constructs for creating interactive and stateful components.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec0057"/>Summary</h1></div></div></div><p>So far, we have discussed reactive programming through the Pulsar, RxClojure, and Yolk libraries. We have also described several ClojureScript examples that compare channels from the <code class="literal">core.async</code> library to reactive event streams from the Yolk library. We also demonstrated how we can leverage the Om library to build dynamic user interfaces.</p><p>In the following chapter, we will explore how we can test our Clojure programs.</p></div>
<div class="chapter" title="Chapter&#xA0;10.&#xA0;Testing Your Code"><div class="titlepage"><div><div><h1 class="title"><a id="ch25"/>Chapter 10. Testing Your Code</h1></div></div></div><p>Testing is an integral part of developing software. Alongside implementing functionality in our software, it is<a class="indexterm" id="id00537"/> imperative to simultaneously define tests to verify several aspects of it. The Clojure standard library provides several constructs to define tests and mock data. There are also several community libraries that allow us to verify different aspects of the code being tested.</p><p>The main advantage of <a class="indexterm" id="id00538"/>using tests is that they allow us to identify the overall impact of a particular change in a program's code. If we have tests to check the functionality of a program, we can refactor the program with confidence and without the fear of losing any functionality. If there's something that we unavoidably missed while refactoring a program, it will surely be brought to our attention when we run the program's tests. Thus, tests are indispensable tools for keeping code maintainable.</p><p>In this chapter, we will study the different ways in which we can write tests in Clojure. We will also discuss how we can perform type checking in Clojure. Although we describe several libraries for writing tests in this chapter, we must note that there are several more available in the Clojure ecosystem. That aside, the libraries described in this chapter are the most mature and battle-hardened tools for testing our code.</p><div class="section" title="Writing tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec0058"/>Writing tests</h1></div></div></div><p>Being a thoughtfully designed language, Clojure has a built-in unit testing library, namely <code class="literal">clojure.test</code>. Apart from that, there are a couple constructs in the core language that are helpful with regard to testing. Of course, these constructs don't allow us to define and run any tests in the<a class="indexterm" id="id00539"/> formal sense, and the constructs from the <code class="literal">clojure.test</code> namespace must be preferred for that purpose.</p><p>Let's start off by briefly discussing the constructs from the core language that can be used for unit testing. The <a class="indexterm" id="id00540"/>
<code class="literal">assert</code> function checks whether an expression evaluates to a truthy value at runtime. This function will throw an exception if the expression passed to it does not evaluate to a truthy value, and the message of this exception can be optionally specified as a second argument to the <code class="literal">assert</code> form. We can effectively disable all the <code class="literal">assert</code> forms in a given program by using the global <code class="literal">*assert*</code> compile time <code class="literal">var</code>. This variable can only be changed by a top-level <code class="literal">set!</code> form in a given program or namespace.</p><p>Another interesting aspect of testing <a class="indexterm" id="id00541"/>that is easily tackled by the core language is <span class="emphasis"><em>mocking</em></span> and <span class="emphasis"><em>stubbing</em></span>. In a<a class="indexterm" id="id00542"/> nutshell, these techniques allow us to redefine the behavior of certain functions within the context of a test case. This is useful in preventing functions from performing unwanted side effects or using unavailable resources. In the Clojure language, this can be done using the <code class="literal">with-redefs</code> function. This form can be used within tests as well as plain<a class="indexterm" id="id00543"/> functions, but its usage outside of the scope of tests is not really encouraged. Its semantics are similar to that of the standard <code class="literal">let</code> form, and you are encouraged to go through the Clojure docs for examples on the <code class="literal">with-redefs</code> form.</p><p>Now, let's explore how we can actually define tests using constructs from the <code class="literal">clojure.test</code> namespace.</p><div class="section" title="Defining unit tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec0034"/>Defining unit tests</h2></div></div></div><p>Clojure has support for <a class="indexterm" id="id00544"/>defining unit tests baked into it. The <code class="literal">clojure.test</code> namespace, which requires no additional dependencies whatsoever, provides several constructs<a class="indexterm" id="id00545"/> for testing our code. Let's explore a few of them.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00125"/>Note</h3><p>The following namespaces must be included in your namespace declaration for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.test :refer :all]))</pre></div><p>The following examples can be found in <code class="literal">test/m_clj/c10/test.clj</code> of the book's source code.</p></div></div><p>Tests can be defined using the <code class="literal">deftest</code> macro. This form must be passed a symbol, indicating the name of the defined test, and any number of expressions. Generally, <code class="literal">is</code> and <code class="literal">are</code> forms are used within the <code class="literal">deftest</code> macro. The <code class="literal">is</code> form must be passed an expression, and will fail the test if the supplied expression does not return a truthy value. The <code class="literal">are</code> form must be passed a vector of variable names, a condition to test, and values for the defined variables. For example, the standard <code class="literal">*</code> function can be tested as shown in <span class="emphasis"><em>Example 10.1</em></span>:</p><div class="informalexample"><pre class="programlisting">(deftest test-*
  (is (= 6 (* 2 3)))
  (is (= 4 (* 1 4)))
  (is (= 6 (* 3 2))))

(deftest test-*-with-are
  (are [x y] (= 6 (* x y))
    2 3
    1 6
    3 2))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.1: Defining tests using the clojure.test namespace</em></span></p></blockquote></div><p>The preceding code defines two tests using the <code class="literal">is</code> and <code class="literal">are</code> forms. We can run tests using the <code class="literal">run-tests</code> and <code class="literal">run-all-tests</code> functions from the <code class="literal">clojure.test</code> namespace. The <code class="literal">run-tests</code> function can be passed any number of namespaces, and will run all the tests defined in them. Also, this form can be called without passing any arguments, in which case it will run all the tests in the current namespace. The <code class="literal">run-all-tests</code> function will run all the tests in all <a class="indexterm" id="id00546"/>namespaces of the current project. It can optionally be passed a regular expression, and will only run the tests from matching namespaces if this argument is supplied. In fact, an IDE with integrated support for running tests will call these functions. For example, we can run the tests we defined in <span class="emphasis"><em>Example 10.1</em></span> using the <code class="literal">run-tests</code> function shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (run-tests)</strong></span>

Testing ...

Ran 2 tests containing 6 assertions.
0 failures, 0 errors.
{:test 2, :pass 6, :fail 0, :error 0, :type :summary}</pre></div><p>As shown in the preceding output, the <code class="literal">run-tests</code> function executes both the tests, and both of them pass. Let's now define a test that will fail, although we shouldn't really be doing this unless we have a good reason:</p><div class="informalexample"><pre class="programlisting">(deftest test-*-fails
  (is (= 5 (* 2 3))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.2: A test that fails</em></span></p></blockquote></div><p>The test <code class="literal">test-*-fails</code> shown in <span class="emphasis"><em>Example 10.2</em></span> will fail when it is run, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (run-tests)</strong></span>

Testing ...

FAIL in (test-*-fails) (test.clj:24)
expected: (= 5 (* 2 3))
  actual: (not (= 5 6))

Ran 3 tests containing 7 assertions.
1 failures, 0 errors.
{:test 3, :pass 6, :fail 1, :error 0, :type :summary}</pre></div><p>In fact, defining tests that fail should be considered a part and parcel of developing a program. To start a feature or fix a bug in a program, we must first define a test that validates this change (by failing!). We should then proceed to implement the feature or fix, such that all the <a class="indexterm" id="id00547"/>newly defined tests pass. These two steps are then repeated, until all the requirements of our feature or fix are met. This is the essence of<a class="indexterm" id="id00548"/> <span class="strong"><strong>test-driven development</strong></span> (<span class="strong"><strong>TDD</strong></span>).</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00127"/>Note</h3><p>We can also run the tests defined in a given namespace using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lein test my-namespace</strong></span>
</pre></div></div></div><p>The <code class="literal">clojure.test</code> namespace must be used for testing programs written strictly in Clojure. For testing ClojureScript programs<a class="indexterm" id="id00549"/> in the same way, we can use the <span class="emphasis"><em>doo</em></span> library (<a class="ulink" href="https://github.com/bensu/doo">https://github.com/bensu/doo</a>), which provides ClojureScript implementations of the <code class="literal">deftest</code>, <code class="literal">is</code>, and <code class="literal">are</code> constucts.</p></div><div class="section" title="Using top-down testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec0035"/>Using top-down testing</h2></div></div></div><p>A more powerful way to define<a class="indexterm" id="id00550"/> tests in Clojure is by using the <span class="emphasis"><em>Midje</em></span> library (<a class="ulink" href="https://github.com/marick/Midje">https://github.com/marick/Midje</a>). This library provides several<a class="indexterm" id="id00551"/> constructs that allow us to easily define unit tests by describing relationships between <a class="indexterm" id="id00552"/>several functions, rather than describing the implementation of the functions themselves. This approach is also called <span class="emphasis"><em>top-down testing</em></span>, and Midje champions this kind of testing methodology. Let's dive into the details of the Midje library.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00128"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[midje "1.8.2"]</pre></div><p>We must also include the following dependencies in the <code class="literal">:plugins</code> section of your <code class="literal">project.clj</code> file:</p><div class="informalexample"><pre class="programlisting">[lein-midje "3.1.3"]</pre></div><p>Also, the following <a class="indexterm" id="id00553"/>namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [midje.sweet :refer :all]
            [midje.repl :as mr]))</pre></div><p>The following examples can be found in <code class="literal">test/m_clj/c10/midje.clj</code> of the book's source code.</p></div></div><p>Firstly, let's define a simple function that we intend to test, as shown in <span class="emphasis"><em>Example 10.3</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn first-element [sequence default]
  (if (empty? sequence)
    default
    (first sequence)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.3: A simple function to test</em></span></p></blockquote></div><p>We can define tests for the <code class="literal">first-element</code> function using the <code class="literal">facts</code> and <code class="literal">fact</code> constructs from the<a class="indexterm" id="id00554"/> <code class="literal">midje.sweet</code> namespace, as shown in <span class="emphasis"><em>Example 10.4</em></span>.</p><div class="informalexample"><pre class="programlisting">(facts "about first-element"
  (fact "it returns the first element of a collection"
        (first-element [1 2 3] :default) =&gt; 1
        (first-element '(1 2 3) :default) =&gt; 1)

  (fact "it returns the default value for empty collections"
        (first-element [] :default) =&gt; :default
        (first-element '() :default) =&gt; :default
        (first-element nil :default) =&gt; :default
        (first-element
         (filter even? [1 3 5])
         :default) =&gt; :default))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.4: Tests for the first-element function</em></span></p></blockquote></div><p>As shown in the preceding code, the <code class="literal">fact</code> form describes a test, and can be passed any number of clauses. Each clause is comprised of an expression, a <code class="literal">=&gt;</code> symbol, and the expected return value of the supplied expression. The <code class="literal">facts</code> form is simply used to group together several <code class="literal">fact</code> forms. It's quite apparent that instead of checking logical conditions, we use <code class="literal">fact</code> forms to check expressions and the values returned by them.</p><p>The <code class="literal">provided</code> form can be used to mock function calls. The Midje library allows us to use <span class="emphasis"><em>metaconstants</em></span> in our <a class="indexterm" id="id00555"/>tests, and they are often used with the <code class="literal">provided</code> form. Metaconstants can be thought of as generic placeholders for values and functions. All metaconstants should start and end with two or more dots (<code class="literal">.</code>) or hyphens (<code class="literal">-</code>); hyphens are more suitable for metaconstants representing functions. For example, we can test the <code class="literal">first-element</code> function we defined earlier using metaconstants and the <code class="literal">provided</code> form as shown in <span class="emphasis"><em>Example 10.5</em></span>:</p><div class="informalexample"><pre class="programlisting">(fact "first-element returns the first element of a collection"
      (first-element ..seq.. :default) =&gt; :default
      (provided
       (empty? ..seq..) =&gt; true))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.5: Using the provided form and metaconstants</em></span></p></blockquote></div><p>In the test shown previously, the metaconstant <code class="literal">..seq..</code> is used to indicate the first argument passed to the <code class="literal">first-element</code> function, and the <code class="literal">provided</code> form mocks the call to the <code class="literal">empty?</code> function. This way, we can implement tests without completely implementing the functions being tested. Of course, we should avoid mocking or redefining standard functions in the <code class="literal">provided</code> form. For example, suppose we have three partially implemented functions, as shown in <span class="emphasis"><em>Example 10.6</em></span>.</p><div class="informalexample"><pre class="programlisting">(defn is-diesel? [car])

(defn cost-of-car [car])

(defn overall-cost-of-car [car]
  (if (is-diesel? car)
    (* (cost-of-car car) 1.4)
    (cost-of-car car)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.6: Partially implemented functions to test</em></span></p></blockquote></div><p>Notice that only the <code class="literal">overall-cost-of-car</code> function is completely implemented in the preceding code. Nevertheless, we<a class="indexterm" id="id00556"/> can still test the relation between these three functions using the Midje library, as shown in <span class="emphasis"><em>Example 10.7</em></span>.</p><div class="informalexample"><pre class="programlisting">(fact
  (overall-cost-of-car ..car..) =&gt; (* 5000 1.4)
  (provided
    (cost-of-car ..car..) =&gt; 5000
    (is-diesel? ..car..) =&gt; true))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.7: Testing the is-diesel?, cost-of-car and overall-cost-of-car functions</em></span></p></blockquote></div><p>In the test shown previously, the <code class="literal">cost-of-car</code> and <code class="literal">is-diesel?</code> functions are mocked using the <code class="literal">provided</code> form and the <code class="literal">..car..</code> metaconstant, and the value returned by the <code class="literal">overall-cost-of-car</code> function is checked. We can run all of the tests we have defined so far using the <code class="literal">autotest</code> function from the <code class="literal">midje.repl</code> namespace, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (mr/autotest :files "test")</strong></span>

====================================================================
Loading ( ... )
&gt;&gt;&gt; Output from clojure.test tests:

0 failures, 0 errors.
&gt;&gt;&gt; Midje summary:
All checks (8) succeeded.
[Completed at ... ]</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00132"/>Note</h3><p>We can also run the tests defined in a given namespace using the following command. Note that the following command will watch your project for file changes, and will run the tests in any files once they are changed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lein midje :autotest test</strong></span>
</pre></div></div></div><p>In this way, we can use the Midje library to write tests, even for functions that haven't been completely implemented. Midje allows us to describe tests as relations between functions using<a class="indexterm" id="id00557"/> metaconstants. In summary, the <code class="literal">clojure.test</code> and Midje libraries are great tools for defining unit tests.</p></div></div></div>
<div class="section" title="Testing with specs"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec0059"/>Testing with specs</h1></div></div></div><p>We will now take a look at the<a class="indexterm" id="id00558"/> Speclj, pronounced <span class="emphasis"><em>speckle</em></span>, library (<a class="ulink" href="https://github.com/slagyr/speclj">https://github.com/slagyr/speclj</a>), which is used to write <span class="emphasis"><em>specs</em></span>. Specs are similar to unit tests, but<a class="indexterm" id="id00559"/> are focused on the behavior of functions being tested, rather than their internal implementation. In fact, <span class="strong"><strong>behavior-driven development</strong></span> (<span class="strong"><strong>BDD</strong></span>) is centered about writing specs. </p><p>The <a class="indexterm" id="id00560"/>main difference between TDD and BDD is that BDD focuses on the behavior or specifications of functions, rather<a class="indexterm" id="id00561"/> than their implementation. From this perspective, if we change the internal implementation of a function that has been<a class="indexterm" id="id00562"/> previously tested, there is a smaller chance that we have to modify the tests, or rather specs, associated with the function. BDD can also be thought of as a refined approach to TDD, in which the interface and behavior of a function is more important than its internal implementation. Now, let's study the various constructs of the Speclj library.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00133"/>Note</h3><p>The following library dependencies are required for the upcoming examples. We must also include the following dependencies in the <code class="literal">:plugins</code> section of your <code class="literal">project.clj</code> file:</p><div class="informalexample"><pre class="programlisting">[speclj "3.3.1"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [speclj.core :refer :all]))</pre></div></div></div><p>The <code class="literal">describe</code>, <code class="literal">it</code>, and <code class="literal">should</code> forms, from the <code class="literal">speclj.core</code> namespace, are used to define specs for a given function. The <code class="literal">it</code> form represents a single specification for the function being tested, and the <code class="literal">describe</code> form is used to group together several specs together. Assertions within an <code class="literal">it</code> form can be expressed using the <code class="literal">should</code> form and its variants. For example, we can write a spec for the behavior of the standard <code class="literal">*</code> function, as shown in the following <span class="emphasis"><em>Example 10.8</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00135"/>Note</h3><p>The following examples can be found in <code class="literal">spec/m_clj/c10/speclj.clj</code> of the book's source code.</p></div></div><div class="informalexample"><pre class="programlisting">(describe "*"
  (it "2 times 3 is 6"
    (should (= 6 (* 2 3)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.8: A spec for the * function</em></span></p></blockquote></div><p>The spec shown previously checks a single condition using the <code class="literal">should</code> and <code class="literal">=</code> forms. There are several<a class="indexterm" id="id00563"/> variants of the <code class="literal">should</code> form, such as <code class="literal">should=</code>, <code class="literal">should-not</code>, <code class="literal">should-fail</code>, and <code class="literal">should-throw</code>. These forms are pretty much self-explanatory, and you are encouraged to go through the Speclj docs for more details. We can describe some specs for the standard <code class="literal">/</code> function, as shown in <span class="emphasis"><em>Example 10.9</em></span>.</p><div class="informalexample"><pre class="programlisting">(describe "/"
  (it "5 divided by 5 is 1"
    (should= 1 (/ 5 5)))
  (it "5 divided by 5 is not 0"
    (should-not= 0 (/ 5 5)))
  (it "fail if 5 divided by 5 is not 1"
    (if (not= 1 (/ 5 5))
      (should-fail "divide not working")))
  (it "throw an error if 5 is divided by 0"
    (should-throw ArithmeticException
      (/ 5 0))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.9: Specs for the / function using several it forms</em></span></p></blockquote></div><p>Within a <code class="literal">describe</code> form, we can use the <code class="literal">before</code> and <code class="literal">after</code> forms to execute arbitrary code before or after each <code class="literal">it</code> form is checked. Similarly, the <code class="literal">before-all</code> and <code class="literal">after-all</code> forms can specify what to execute before and after all the specs are checked in a <code class="literal">describe</code> form.</p><p>Input and output<a class="indexterm" id="id00564"/> performed by a certain function can be described using specs. This is done using the <code class="literal">with-out-str</code> and <code class="literal">with-in-str</code> forms. The <code class="literal">with-out-str</code> form returns whatever data is sent to standard output by a given expression. Conversely, the <code class="literal">with-in-str</code> form must be passed a string and an expression, and the supplied string will be sent to the standard input once the supplied expression is called. For example, let's say we have a simple function that reads a string and prints it. We can write a spec for such a function using the <code class="literal">with-out-str</code> and <code class="literal">with-in-str</code> forms as shown in <span class="emphasis"><em>Example 10.10</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn echo []
  (let [s (read-line)]
    (println (str "Echo: " s))))

(describe "echo"
  (it "reads a line and prints it"
    (should= "Echo: Hello!\r\n"
      (with-out-str
        (with-in-str "Hello!"
          (echo))))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.10: A spec for a function that reads a string and prints it</em></span></p></blockquote></div><p>We can also mock function calls within an <code class="literal">it</code> form using the standard <code class="literal">with-redefs</code> macro we described earlier. For example, we can write a spec for the <code class="literal">echo</code> function described in <span class="emphasis"><em>Example 10.10</em></span> by mocking the <code class="literal">read-line</code> and <code class="literal">println</code> functions as shown in <span class="emphasis"><em>Example 10.11</em></span>. Obviously, it's not advisable to mock standard functions, and it's only done here to depict the usage of the <code class="literal">with-redefs</code> macro within a spec.</p><div class="informalexample"><pre class="programlisting">(describe "echo"
  (it "reads a line and prints it"
    (with-redefs [read-line (fn [] "Hello!")
                  println (fn [x] x)]
      (should= "Echo: Hello!" (echo)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.11: Using the with-redefs macro within a spec</em></span></p></blockquote></div><p>To run all the <a class="indexterm" id="id00565"/>specs defined in a given project, we can call the <code class="literal">run-specs</code> macro, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (run-specs)</strong></span>
...

Finished in 0.00547 seconds
7 examples, 0 failures
#&lt;speclj.run.standard.StandardRunner 0x10999&gt;</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00136"/>Note</h3><p>We can also run the<a class="indexterm" id="id00566"/> specs defined in a given namespace using the following command. Note that the following command will watch your project for file changes, and will run the specs in any files once they are changed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ lein spec -a</strong></span>
</pre></div></div></div><p>To summarize, the Speclj library provides us with several constructs to define specs for BDD. Specs for a given function should be modified only when the required functionality or behavior of a function must be changed. With specs, there's less of a chance that modifying the underlying implementation of a function will require a change in its associated specs. Of course, the question of whether you should use specs or tests in your project is a subjective one. Some projects do fine with simple tests, and others prefer to use specs.</p></div>
<div class="section" title="Generative testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec0060"/>Generative testing</h1></div></div></div><p>Another form of testing is <span class="strong"><strong>generative testing</strong></span>, in which we define properties of functions that must hold true for all inputs. This is quite different compared to enumerating the expected inputs and outputs <a class="indexterm" id="id00567"/>of functions, which is essentially what unit tests and specs do. In Clojure, generative testing can be done using the <code class="literal">test.check</code> library (<a class="ulink" href="https://github.com/clojure/test.check">https://github.com/clojure/test.check</a>). This library is inspired by Haskell's <a class="indexterm" id="id00568"/>QuickCheck library, and provides similar constructs for testing properties of functions.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00137"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[org.clojure/test.check "0.9.0"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.test.check :as tc]
            [clojure.test.check.generators :as gen]
            [clojure.test.check.properties :as prop]
            [clojure.test.check.clojure-test 
             :refer [defspec]]))</pre></div><p>The following examples can be found in <code class="literal">src/m_clj/c10/check.clj</code> of the book's source code.</p></div></div><p>To define a property to check, we can use the <code class="literal">for-all</code> macro from the <code class="literal">clojure.test.check.properties</code> namespace. This macro must be passed a vector of generator bindings, which can be created using constructs from the <code class="literal">clojure.test.check.generators</code> namespace, along with a property to verify. For example, consider the properties defined in <span class="emphasis"><em>Example 10.12</em></span>:</p><div class="informalexample"><pre class="programlisting">(def commutative-mult-prop
  (prop/for-all [a gen/int
                 b gen/int]
    (= (* a b)
       (* b a))))

(def first-is-min-after-sort-prop
  (prop/for-all [v (gen/not-empty (gen/vector gen/int))]
    (= (apply min v)
       (first (sort v)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.12: Simple properties defined using the test.check library</em></span></p></blockquote></div><p>In the preceding code, we have defined two properties, namely <code class="literal">commutative-mult-prop</code> and <code class="literal">first-is-min-after-sort-prop</code>. The <code class="literal">commutative-mult-prop</code> property asserts that a multiplication operation using the <code class="literal">*</code> function is commutative, and the <code class="literal">first-is-min-after-sort-prop</code> function checks whether the first element of a vector of integers sorted using the <code class="literal">sort</code> function is the smallest value in the vector. Note the use of the <code class="literal">int</code>, <code class="literal">vector</code> and<a class="indexterm" id="id00569"/> <code class="literal">non-empty</code> functions from the <code class="literal">clojure.test.check.generators</code> namespace. We can verify that these properties are true using the <code class="literal">quick-check</code> function from the <code class="literal">clojure.test.check</code> namespace, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (tc/quick-check 100 commutative-mult-prop)</strong></span>
{:result true, :num-tests 100, :seed 1449998010193}
<span class="strong"><strong>user&gt; (tc/quick-check 100 first-is-min-after-sort-prop)</strong></span>
{:result true, :num-tests 100, :seed 1449998014634}</pre></div><p>As shown previously, the <code class="literal">quick-check</code> function must be passed the number of checks to run and a property to verify. This function returns a map describing the checks performed on the supplied properties, in which the value of the <code class="literal">:result</code> key indicates the outcome of the test. It's fairly evident that both of the properties <code class="literal">commutative-mult-prop</code> and <code class="literal">first-is-min-after-sort-prop</code> hold true for the specified type of inputs. Now, let's define a property that is not true, as shown in <span class="emphasis"><em>Example 10.13</em></span>:</p><div class="informalexample"><pre class="programlisting">(def commutative-minus-prop
  (prop/for-all [a gen/int
                 b gen/int]
    (= (- a b)
       (- b a))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.13: A property that won't be true defined using the test.check library</em></span></p></blockquote></div><p>Running the preceding check will obviously fail, as shown in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (tc/quick-check 100 commutative-minus-prop)</strong></span>
{:result false, :seed 1449998165908,
 :failing-size 1, :num-tests 2, :fail [0 -1],
 :shrunk {:total-nodes-visited 1, :depth 0, :result false,
               :smallest [0 -1]}}</pre></div><p>We can also define specs based on generative testing using the <code class="literal">defspec</code> macro from the <code class="literal">clojure.test.check.clojure-test</code> namespace. This form must be passed the number of checks to perform and a property, which is analogous to the <code class="literal">quick-check</code> function. Specs defined using the <code class="literal">defspec</code> form will be checked by the standard <code class="literal">clojure.test</code> runner. For example, we can define the <code class="literal">commutative-mult-prop</code> property as a spec as shown in <span class="emphasis"><em>Example 10.14</em></span>:</p><div class="informalexample"><pre class="programlisting">(defspec commutative-mult 100
  (prop/for-all [a gen/int
                 b gen/int]
    (= (* a b)
       (* b a))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.14: A spec defined using the defspec macro</em></span></p></blockquote></div><p>The spec defined in the preceding code can be verified by calling the <code class="literal">run-tests</code> or <code class="literal">run-all-tests</code> functions from the <code class="literal">clojure.test</code> namespace, or by running the <code class="literal">lein test</code> Leiningen command. In conclusion, generative testing through the <code class="literal">test.check</code> library is yet another way<a class="indexterm" id="id00570"/> to test our code. It focuses on specifying properties of functions rather than describing the expected output of functions for some input.</p></div>
<div class="section" title="Testing with types"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec0061"/>Testing with types</h1></div></div></div><p>
<span class="strong"><strong>Type checking</strong></span> is something<a class="indexterm" id="id00571"/> that is often taken for granted in statically typed languages. With type checking, type errors can be found at compile time, rather than during runtime. In some dynamic languages such as Clojure, type signatures can be declared<a class="indexterm" id="id00572"/> wherever and whenever they are<a class="indexterm" id="id00573"/> required, and this technique is termed as <span class="emphasis"><em>optional typing</em></span>. Type checking can be done using the <code class="literal">core.typed</code> library (<a class="ulink" href="https://github.com/clojure/core.typed">https://github.com/clojure/core.typed</a>). Using <code class="literal">core.typed</code>, the type signature of a var can be checked using <span class="emphasis"><em>type annotations</em></span>. Type annotations can be declared for any var, which includes values<a class="indexterm" id="id00574"/> created using a <code class="literal">def</code> form, a <code class="literal">binding</code> form, or any other construct that creates a var. In this section, we will explore the details of this library.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00140"/>Note</h3><p>The following library dependencies are required for the upcoming examples.</p><div class="informalexample"><pre class="programlisting">[org.clojure/core.typed "0.3.0"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration.</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.core.typed :as t]))</pre></div><p>The following examples can be found in <code class="literal">src/m_clj/c10/typed.clj</code> of the book's source code.</p></div></div><p>Type annotations for vars are declared using the <code class="literal">ann</code> macro from the <code class="literal">clojure.core.typed</code> namespace. This form must be passed an expression to annotate and a vector of types. For example, a type annotation for a function that accepts two numbers as arguments and returns a number is shown in <span class="emphasis"><em>Example 10.15</em></span>.</p><div class="informalexample"><pre class="programlisting">(t/ann add [Number Number -&gt; Number])
(defn add [a b]
  (+ a b))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.15: A type annotation for a function that accepts two numbers and returns a number</em></span></p></blockquote></div><p>To check all the type annotations in the given namespace, we must call the <code class="literal">clojure.core.typed/check-ns</code> function by passing it the namespace to be checked, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/check-ns 'my-namespace)</strong></span>
Start collecting my-namespace
Finished collecting my-namespace
Collected 2 namespaces in 200.965982 msecs
Start checking my-namespace
Checked my-namespace in 447.580402 msecs
Checked 2 namespaces  in 650.979682 msecs
:ok</pre></div><p>As shown <a class="indexterm" id="id00575"/>previously, the <code class="literal">check-ns</code> function prints some information about the namespaces being checked, and returns the keyword <code class="literal">:ok</code> if all type checks in the specified namespace have passed. Now, let's change the definition of the <code class="literal">add</code> function we previously defined as shown in <span class="emphasis"><em>Example 10.16</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn add [a b]
  (str (+ a b)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.16: Redefining the add function</em></span></p></blockquote></div><p>Although the preceding definition is valid, it will not be passed by the type checker, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/check-ns 'my-namespace)</strong></span>
Start collecting my-namespace
Finished collecting my-namespace
Collected 2 namespaces in 215.705251 msecs
Start checking my-namespace
Checked my-namespace in 493.669488 msecs
Checked 2 namespaces  in 711.644548 msecs
Type Error (m_clj/c1/typed.clj:23:3) Type mismatch:

Expected:   Number

Actual:   String
in: (str (clojure.lang.Numbers/add a b))
ExceptionInfo Type Checker: Found 1 error  clojure.core/ex-info (core.clj:4403)</pre></div><p>The <code class="literal">check-ns</code> function throws an error stating that a <code class="literal">String</code> type was found where a <code class="literal">Number</code> type was expected. In this way, the <code class="literal">check-ns</code> function can find type errors in functions that have been annotated with the <code class="literal">ann</code> macro. Functions with multiple arities can be annotated using the <code class="literal">IFn</code> construct from the <code class="literal">clojure.core.typed</code> namespace, as shown in <span class="emphasis"><em>Example 10.17</em></span>:</p><div class="informalexample"><pre class="programlisting">(t/ann add-abc
       (t/IFn [Number Number -&gt; Number]
              [Number Number Number -&gt; Number]))
(defn add-abc
  ([a b]
   (+ a b))
  ([a b c]
   (+ a b c)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.17: Annotating functions with multiple arities</em></span></p></blockquote></div><p>We can also<a class="indexterm" id="id00576"/> annotate functions with variadic arguments using the <code class="literal">*</code> symbol in the vector of types passed to the <code class="literal">ann</code> macro, as shown in <span class="emphasis"><em>Example 10.18</em></span>.</p><div class="informalexample"><pre class="programlisting">(t/ann add-xs [Number * -&gt; Number])
(defn add-xs [&amp; xs]
  (apply + xs))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.18: Annotating functions with variadic arguments</em></span></p></blockquote></div><p>In the REPL, we can determine the inferred type of an expression or a value using the<code class="literal"> cf </code>macro from the <code class="literal">clojure.core.typed</code> namespace. This macro can also be passed the expected type as the second argument. Note that the <code class="literal">cf</code> form is only for experimentation and should not be used in type annotations. The <code class="literal">cf</code> form returns an inferred type, along with a structure called a <span class="emphasis"><em>filter set</em></span>, which is represented as a map. For example, the type and filter sets of the values <code class="literal">nil</code>, <code class="literal">true</code>, and <code class="literal">false</code> can be inferred using the <code class="literal">cf </code>form as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/cf nil)</strong></span>
[nil {:then ff, :else tt}]
<span class="strong"><strong>user&gt; (t/cf true)</strong></span>
[true {:then tt, :else ff}]
<span class="strong"><strong>user&gt; (t/cf false)</strong></span>
[false {:then ff, :else tt}]</pre></div><p>In the preceding output, the second value in each of the vectors returned by the <code class="literal">cf</code> macro represents the filter set derived from the supplied expression. A filter set can be described as a collection of the two filters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">:then</code> filter, which is true if the expression is a truthy value</li><li class="listitem" style="list-style-type: disc">The <code class="literal">:else</code> filter, which is true if the expression is not a truthy value</li></ul></div><p>In the context of filter sets, there are two <span class="emphasis"><em>trivial filters</em></span>, namely <code class="literal">tt</code> and <code class="literal">ff</code>, which can be described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">tt</code>, which translates to trivially true and means the value is truthy.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ff</code>, which translates to <span class="emphasis"><em>forever false</em></span> and means the value is not truthy. This filter is also termed as the <span class="emphasis"><em>impossible filter</em></span>.</li></ul></div><p>In this perspective, the filter set <code class="literal">{:then tt, :else ff}</code> translates into "the expression could be a truthy value, but it is impossible for it to be a non-truthy value". Thus, false values such<a class="indexterm" id="id00577"/> as <code class="literal">nil</code> and <code class="literal">false</code> are never true as inferred by the <code class="literal">cf</code> form, which agrees with the semantics of these values in Clojure. Truthy values will always have<code class="literal"> tt </code>as the <code class="literal">:then</code> filter, as shown in the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/cf "Hello")</strong></span>
[(t/Val "Hello") {:then tt, :else ff}]
<span class="strong"><strong>user&gt; (t/cf 1)</strong></span>
[(t/Val 1) {:then tt, :else ff}]
<span class="strong"><strong>user&gt; (t/cf :key)</strong></span>
[(t/Val :key) {:then tt, :else ff}]</pre></div><p>The <code class="literal">cf</code> macro can also be used to check the type signature of functions, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/cf str)</strong></span>
[t/Any * -&gt; String]
<span class="strong"><strong>user&gt; (t/cf +)</strong></span>
(t/IFn [Long * -&gt; Long]
       [(t/U Double Long) * -&gt; Double]
       [t/AnyInteger * -&gt; t/AnyInteger]
       [Number * -&gt; Number])</pre></div><p>A form or expression can be annotated with an expected type using the <code class="literal">ann-form</code> macro, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/cf (t/ann-form #(inc %) [Number -&gt; Number]))</strong></span>
[[Number -&gt; Number] {:then tt, :else ff}]
<span class="strong"><strong>user&gt; (t/cf (t/ann-form #(str %) [t/Any -&gt; String]))</strong></span>
[[t/Any -&gt; String] {:then tt, :else ff}]</pre></div><p>Aggregate types such as lists and vectors also have types defined for them in the <code class="literal">clojure.core.typed</code> namespace. We can infer the types of these data structures using the <code class="literal">cf</code> macro, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/cf (list 0 1 2))</strong></span>
(PersistentList (t/U (t/Val 1) (t/Val 0) (t/Val 2)))
<span class="strong"><strong>user&gt; (t/cf [0 1 2])</strong></span>
[(t/HVec [(t/Val 0) (t/Val 1) (t/Val 2)]) {:then tt, :else ff}]</pre></div><p>The types <code class="literal">PersistentList</code> and <code class="literal">HVec</code> in the preceding output are concrete types for a list and a vector respectively. We can also pass the expected type as an extra argument to the<code class="literal"> cf </code>form as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/cf (list 0 1 2) (t/List t/Num))</strong></span>
(t/List t/Num)
<span class="strong"><strong>user&gt; (t/cf [0 1 2] (t/Vec t/Num))</strong></span>
(t/Vec t/Num)
<span class="strong"><strong>user&gt; (t/cf {:a 1 :b 2} (t/Map t/Keyword t/Int))</strong></span>
(t/Map t/Keyword t/Int)
<span class="strong"><strong>user&gt; (t/cf #{0 1 2} (t/Set t/Int))</strong></span>
(t/Set t/Int)</pre></div><p>The <code class="literal">core.typed</code> library also supports <span class="emphasis"><em>parameterized types</em></span>, <span class="emphasis"><em>union types</em></span>, and <span class="emphasis"><em>intersection types</em></span>. Union types are <a class="indexterm" id="id00578"/>declared using<a class="indexterm" id="id00579"/> the <code class="literal">U</code> construct, and intersection types are declared using the <code class="literal">I</code> construct. Intersection types<a class="indexterm" id="id00580"/> are meant to be used with protocols, which implies that<a class="indexterm" id="id00581"/> the intersection type <code class="literal">(I A B)</code> must implement both the protocols <code class="literal">A</code> and <code class="literal">B</code>. On the other hand, union types can be defined using concrete types. For example, the <code class="literal">clojure.core.typed</code> namespace defines a parameterized <code class="literal">Option</code> type, which is simply a union of <code class="literal">nil</code> and the parameterized type. In other words, the type <code class="literal">(Option x)</code> is defined as the union type <code class="literal">(U x nil)</code>. Another good example of a union type is the <code class="literal">AnyInteger</code> type, which represents a whole number, and is defined in the <code class="literal">clojure.core.typed</code> namespace as shown in <span class="emphasis"><em>Example 10.19</em></span>.</p><div class="informalexample"><pre class="programlisting">(defalias AnyInteger
  (U Integer Long clojure.lang.BigInt BigInteger Short Byte))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.19: The AnyInteger union type</em></span></p></blockquote></div><p>
<span class="emphasis"><em>Polymorphic types</em></span> are also supported by the <code class="literal">core.typed</code> library, which allow us to specify generalized types. For example, the <code class="literal">identity</code> and <code class="literal">iterate</code> functions have polymorphic type signatures, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (t/cf identity)</strong></span>
(t/All [x] [x -&gt; x :filters ... ])
<span class="strong"><strong>user&gt; (t/cf iterate)</strong></span>
(t/All [x] [[x -&gt; x] x -&gt; (t/ASeq x)])</pre></div><p>We can annotate functions with polymorphic type signatures using the <code class="literal">All</code> construct from the <code class="literal">clojure.core.typed</code> namespace, as shown in <span class="emphasis"><em>Example 10.20</em></span>.</p><div class="informalexample"><pre class="programlisting">(t/ann make-map (t/All [x] [x -&gt; (t/Map t/Keyword x)]))
(defn make-map [a]
  {:x a})</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 10.20: Defining a polymorphic type signature</em></span></p></blockquote></div><p>In conclusion, the <code class="literal">core.typed</code> library provides several constructs to define and verify type signatures of vars. There are also several constructs for determining the type signature of a given expression. Using <code class="literal">core.typed</code>, you can find logical type errors in your code before it is executed at runtime. Type annotations can also be thought of as a form of documentation, which concisely describe the types of functions and vars. Thus, there are several<a class="indexterm" id="id00582"/> benefits of using types through the <code class="literal">core.typed</code> library in Clojure.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec0062"/>Summary</h1></div></div></div><p>So far, we have discussed several libraries that can help us test and verify our code. We talked about the <code class="literal">clojure.test</code> and Midje libraries for defining tests. We also explored how we can define specs in the spirit of BDD using the Speclj library. Generative testing is another approach to testing, and we demonstrated how it can be done using the <code class="literal">test.check</code> library. Lastly, we talked about how we can perform type checking in Clojure using the <code class="literal">core.typed</code> library. Hence, there is a wide array of options for testing our code in Clojure.</p><p>In the next and final chapter, we will talk about how we can troubleshoot our code, as well as some good practices for developing applications in Clojure.</p></div>
<div class="chapter" title="Chapter&#xA0;11.&#xA0;Troubleshooting and Best Practices"><div class="titlepage"><div><div><h1 class="title"><a id="ch26"/>Chapter 11. Troubleshooting and Best Practices</h1></div></div></div><p>By now, you must be aware of all the features and most of the constructs of the Clojure language. Before you start building your own applications and libraries in Clojure, we will briefly discuss a few techniques to troubleshoot your code and some practices that you should incorporate in your projects.</p><div class="section" title="Debugging your code"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec0063"/>Debugging your code</h1></div></div></div><p>Along your journey of <a class="indexterm" id="id00583"/>building applications and libraries in Clojure, you'll surely run into situations where it would be helpful to debug your code. The usual response to such a situation is to use an <span class="strong"><strong>Integrated Development Environment</strong></span> (<span class="strong"><strong>IDE</strong></span>) with a<a class="indexterm" id="id00584"/> debugger. And while<a class="indexterm" id="id00585"/> Clojure IDEs such as <span class="emphasis"><em>CIDER</em></span> (<a class="ulink" href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>) and <span class="emphasis"><em>Counterclockwise</em></span> (<a class="ulink" href="http://doc.ccw-ide.org">http://doc.ccw-ide.org</a>) do support<a class="indexterm" id="id00586"/> debugging, there are a few simpler constructs and tools that we can use to troubleshoot our code. Let's have a look at a few of them.</p><p>One of the easiest ways to<a class="indexterm" id="id00587"/> debug your code is by printing the value of some variables used within a function. We could use the standard <code class="literal">println</code> function for this purpose, but it doesn't always produce the most readable output for complex data types. As a convention, we should use the <code class="literal">clojure.pprint/pprint</code> function to print variables to the console. This function is the standard pretty-printer of the Clojure language.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00143"/>Note</h3><p>Macros can be quite bewildering to <a class="indexterm" id="id00588"/>debug. As we mentioned in <a class="link" href="ch19.html" title="Chapter 4. Metaprogramming with Macros">Chapter 4</a>, <span class="emphasis"><em>Metaprogramming with Macros</em></span>, macros should be used sparingly and we can debug macros using macroexpansion constructs such as <code class="literal">macroexpand</code> and <code class="literal">macroexpand-all</code>.</p></div></div><p>Apart from these built-in constructs, there are a couple of useful libraries that we can add to our debugging toolkit.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00144"/>Note</h3><p>The following <a class="indexterm" id="id00589"/>examples can be found in <code class="literal">test/m_clj/c11/</code> <code class="literal">debugging.clj</code> of the book's source code.</p></div></div><div class="section" title="Using tracing"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec0036"/>Using tracing</h2></div></div></div><p>
<span class="emphasis"><em>Tracing</em></span> can be used to <a class="indexterm" id="id00590"/>determine when and how a form is called. The <code class="literal">tools.trace</code> <a class="indexterm" id="id00591"/>contrib library (<a class="ulink" href="https://github.com/clojure/tools.trace">https://github.com/clojure/tools.trace</a>) provides some handy constructs for tracing our code.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00145"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[org.clojure/tools.trace "0.7.9"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.tools.trace :as tr]))</pre></div></div></div><p>The <code class="literal">trace</code> function, from the <code class="literal">clojure.tools.trace</code> namespace, is the most elementary way to trace an expression. It will simply print the value returned by the expression passed to it. The <code class="literal">trace</code> construct can also be passed a string, with which the trace can be tagged, as an additional argument. For example, suppose we have to trace the function defined in <span class="emphasis"><em>Example 11.1</em></span>:</p><div class="informalexample"><pre class="programlisting">(defn make-vector [x]
  [x])</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 11.1: A simple function to trace</em></span></p></blockquote></div><p>We can trace the expression <code class="literal">(make-vector 0)</code> using the <code class="literal">trace</code> function shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (tr/trace (make-vector 0))</strong></span>
TRACE: [0]
[0]
<span class="strong"><strong>user&gt; (tr/trace "my-tag" (make-vector 0))</strong></span>
TRACE my-tag: [0]
[0]</pre></div><p>We can trace all the functions defined in a namespace by passing the namespace to the <code class="literal">trace-ns</code> macro, which is defined in the <code class="literal">clojure.tools.trace</code> namespace. Similarly, specific functions or vars in a namespace can be traced using the <code class="literal">trace-vars</code> macro. Traces added using these forms can be removed using the <code class="literal">untrace-ns</code> and <code class="literal">untrace-vars</code> marcos. If we want to determine which expression among several ones is failing, we can pass the expressions to the <code class="literal">trace-forms</code> macro, shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (tr/trace-forms (+ 10 20) (* 2 3) (/ 10 0))</strong></span>
ArithmeticException Divide by zero
  Form failed: (/ 10 0)
clojure.lang.Numbers.divide (Numbers.java:158)</pre></div><p>As the preceding<a class="indexterm" id="id00592"/> output shows, the <code class="literal">trace-forms</code> macro will print the form that causes the error. A more informative way to trace a function is by replacing the <code class="literal">defn</code> symbol in its definition by <code class="literal">clojure.tools.trace/deftrace</code>, which simply defines a function whose arguments and return value will be traced. For example, consider the function defined in the following <span class="emphasis"><em>Example 11.2</em></span>:</p><div class="informalexample"><pre class="programlisting">(tr/deftrace add-into-vector [&amp; xs]
  (let [sum (apply + xs)]
    [sum]))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 11.2: Tracing a function using the deftrace macro</em></span></p></blockquote></div><p>On calling the <code class="literal">add-into-vector</code> function defined previously, the following trace will be printed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (add-into-vector 10 20)</strong></span>
TRACE t9083: (add-into-vector 10 20)
TRACE t9083: =&gt; [30]
[30]</pre></div><p>In this way, tracing can be used to find the value returned by an expression during the execution of a program. The tracing constructs from the <code class="literal">tools.trace</code> namespace allow us to determine when a function is called, as well as what its return value and arguments are.</p></div><div class="section" title="Using Spyscope"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec0037"/>Using Spyscope</h2></div></div></div><p>As you may have already been<a class="indexterm" id="id00593"/> thinking, you can easily implement your own debugging constructs using macros. The Spyscope library (<a class="ulink" href="https://github.com/dgrnbrg/spyscope">https://github.com/dgrnbrg/spyscope</a>) takes this approach and implements a few reader macros for <a class="indexterm" id="id00594"/>debugging code. The use of reader macros for debugging is a more favorable approach for languages with the parentheses-flavored <a class="indexterm" id="id00595"/>syntax of Lisps. This is because, in these languages, reader macros that print debugging information can be added more easily to an existing program compared to forms such as <code class="literal">trace</code> and <code class="literal">deftrace</code>. Let's explore the constructs of the Spyscope library to get a clearer idea of the advantage of debugging code with reader macros.</p><p>The Spyscope library provides the <code class="literal">#spy/p</code>, <code class="literal">#spy/d</code>, and <code class="literal">#spy/t</code> reader macros, which can all be used by writing them immediately before expressions that have to be debugged. It is a<a class="indexterm" id="id00596"/> common practice to have these forms made available in the REPL using the <code class="literal">:injections</code>
<a class="indexterm" id="id00597"/> section of the <code class="literal">project.clj</code> file in a Leiningen project.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00147"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[spyscope "0.1.5"]</pre></div><p>We must also include the following forms as a vector in the <code class="literal">:injections</code> section of your <code class="literal">project.clj</code> file:</p><div class="informalexample"><pre class="programlisting">(require 'spyscope.core)</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [spyscope.repl :as sr]))</pre></div></div></div><p>The <code class="literal">#spy/p</code> reader macro can be used to print a value that is used within an expression. An interesting point about this construct is that it is implemented using the <code class="literal">clojure.pprint/pprint</code> function. For example, we can print out the intermediate values produced by a <code class="literal">take</code> form shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (take 5 (repeatedly</strong></span>
<span class="strong"><strong>               #(let [r (rand-int 100)]</strong></span>
<span class="strong"><strong>                  #spy/p r)))</strong></span>
95
36
61
99
73
(95 36 61 99 73)</pre></div><p>To produce more detailed information, such as the call stack and the form that returns a value, we can use the <code class="literal">#spy/d</code> reader macro. For example, we can use this construct to produce the following information:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (take 5 (repeatedly</strong></span>
<span class="strong"><strong>               #(let [r (rand-int 100)]</strong></span>
<span class="strong"><strong>                  #spy/d (/ r 10.0))))</strong></span>
user$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) =&gt; 4.6
user$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) =&gt; 4.4
user$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) =&gt; 5.0
user$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) =&gt; 7.8
user$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) =&gt; 3.1
(4.6 4.4 5.0 7.8 3.1)</pre></div><p>The <code class="literal">#spy/d</code> reader macro also supports several options, which can be passed to it as metadata. The <code class="literal">:fs</code> key of this metadata map specifies the number of stack frames to display. Also, the <code class="literal">:marker</code> key can be used to declare a string tag for a form. We can use these options to display information from the call stack of a form, shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (take 5 (repeat #spy/d ^{:fs 3 :marker "add"}</strong></span>
<span class="strong"><strong>                      (+ 0 1 2)))</strong></span>
----------------------------------------
clojure.lang.Compiler.eval(Compiler.java:6745)
clojure.lang.Compiler.eval(Compiler.java:6782)
user$eval9476.invoke(form-init1..0.clj:1) add (+ 0 1 2) =&gt; 3
(3 3 3 3 3)</pre></div><p>The preceding <a class="indexterm" id="id00598"/>output shows the top three stack frames of a<a class="indexterm" id="id00599"/> call to the <code class="literal">+</code> form. We can also filter out stack frames from the call stack information using the <code class="literal">:nses</code> key with a regular expression, shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (take 5 (repeat #spy/d ^{:fs 3 :nses #"core|user"}</strong></span>
<span class="strong"><strong>                      (+ 0 1 2)))</strong></span>
----------------------------------------
clojure.core$apply.invoke(core.clj:630)
clojure.core$eval.invoke(core.clj:3081)
user$eval9509.invoke(form-init1..0.clj:1) (+ 0 1 2) =&gt; 3
(3 3 3 3 3)</pre></div><p>To skip printing the form being debugged, we can specify the <code class="literal">:form</code> key with a <code class="literal">false</code> value in the metadata map specified to the <code class="literal">#spy/d</code> reader macro, and this key defaults to <code class="literal">true</code>. We can also print out the time at which a form is called using the <code class="literal">:time</code> key. The value for this key can either be <code class="literal">true</code>, in which case the default time format is used, or a string such as <code class="literal">"hh:mm:ss"</code>, which represents the timestamp format with which the time must be displayed.</p><p>The <code class="literal">#spy/t</code> reader macro is used for tracing a form, and this construct supports the same options as the <code class="literal">#spy/d</code> reader macro. The trace is not printed immediately, and can be displayed using the <code class="literal">trace-query</code> function from the <code class="literal">spyscope.repl</code> namespace. For example, consider the function in <span class="emphasis"><em>Example 11.3</em></span> that adds a number of values in a future:</p><div class="informalexample"><pre class="programlisting">(defn add-in-future [&amp; xs]
  (future
    #spy/t (apply + xs)))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 11.3: Tracing a function that adds numbers in a future</em></span></p></blockquote></div><p>Once the <code class="literal">add-in-future</code> function is called, we can display a trace of the call using the <code class="literal">trace-query</code> function, shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (sr/trace-next)</strong></span>
nil
<span class="strong"><strong>user&gt; (def f1 (add-in-future 10 20))</strong></span>
#'user/f1
<span class="strong"><strong>user&gt; (def f2 (add-in-future 20 30))</strong></span>
#'user/f2
<span class="strong"><strong>user&gt; (sr/trace-query)</strong></span>
user$add_in_future$fn_..7.invoke(debugging.clj:66) (apply + xs) =&gt; 30
----------------------------------------
user$add_in_future$fn_..7.invoke(debugging.clj:66) (apply + xs) =&gt; 50
nil</pre></div><p>In the preceding <a class="indexterm" id="id00600"/>output, the <code class="literal">trace-next</code> function is used to start a new <span class="emphasis"><em>generation</em></span> of traces. Traces in the Spyscope library are grouped into generations, and a new generation can be started using the <code class="literal">spyscope.repl/trace-next</code> function. All trace information from all generations can be cleared using the <code class="literal">trace-clear</code> function from the <code class="literal">spyscope.repl</code> namespace. We can also pass an argument to the <code class="literal">trace-query</code> function to filter <a class="indexterm" id="id00601"/>out results. This argument can be either a number, which represents the number of recent generations to show, or a regex to filter traces by their namespaces.</p><p>To summarize, there are several ways to debug your code in Clojure without the use of a debugger. The <code class="literal">tools.trace</code> and Spyscope libraries have several useful and simple constructs for debugging and tracing the execution of Clojure code.</p></div></div></div>
<div class="section" title="Logging errors in your application"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec0065"/>Logging errors in your application</h1></div></div></div><p>Another way to<a class="indexterm" id="id00602"/> analyze what went wrong in an application is by using logs. Logging can be done using the <code class="literal">tools.logging</code> contrib library. This library lets us use multiple logging implementations through an agnostic interface, and<a class="indexterm" id="id00603"/> the implementations to choose from include <code class="literal">slf4j</code>, <code class="literal">log4j</code>, and <code class="literal">logback</code>. Let's quickly skim over how we can add logging to any Clojure program using the <code class="literal">tools.logging</code> library and <code class="literal">logback</code>, which is arguably the most recent and configurable implementation to use with this library.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00150"/>Note</h3><p>The following library dependencies are required for the upcoming examples:</p><div class="informalexample"><pre class="programlisting">[org.clojure/tools.logging "0.3.1"]
[ch.qos.logback/logback-classic "1.1.3"]</pre></div><p>Also, the following namespaces must be included in your namespace declaration:</p><div class="informalexample"><pre class="programlisting">(ns my-namespace
  (:require [clojure.tools.logging :as log]))</pre></div><p>The following examples can be found in <code class="literal">test/m_clj/c11/</code> <code class="literal">logging.clj</code> of the book's source code.</p></div></div><p>All the logging macros<a class="indexterm" id="id00604"/> implemented in the <code class="literal">clojure.tools.logging</code> namespace fall into two categories. The first category of macros require arguments like those which are passed to the <code class="literal">println</code> form. All of these arguments are concatenated and written to the log. The other category of macros must be passed a format string and values to interpolate into the <a class="indexterm" id="id00605"/>specified format. This second category of macros are generally suffixed with an <code class="literal">f</code> character, such as <code class="literal">debugf</code> or <code class="literal">infof</code>. The logging macros in the <code class="literal">tools.logging</code> library can be passed an exception followed by the other usual arguments.</p><p>The macros in the <code class="literal">tools.logging</code> library write log messages at differing log levels. For example, the <code class="literal">debug</code> and <code class="literal">debugf</code> forms write log messages at the <code class="literal">DEBUG</code> level, and similarly, the <code class="literal">error</code> and <code class="literal">errorf</code> macros log at the <code class="literal">ERROR</code> level. In addition, the <code class="literal">spy</code> and <code class="literal">spyf</code> macros will evaluate and return the value of an expression, and may log the result if the current log level is equal to or below the log level specified to it, which defaults to <code class="literal">DEBUG</code>. </p><p>For example, the <code class="literal">divide</code> function, shown in the following <span class="emphasis"><em>Example 11.4</em></span>, logs some information, using the <code class="literal">info</code>, <code class="literal">spyf</code>, and <code class="literal">error</code> macros, while performing integer division:</p><div class="informalexample"><pre class="programlisting">(defn divide [a b]
  (log/info "Dividing" a "by" b)
  (try
    (log/spyf "Result: %s" (/ a b))
    (catch Exception e
      (log/error e "There was an error!"))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 11.4: A function that logs information using the tools.logging library</em></span></p></blockquote></div><p>The following log messages will be written when the <code class="literal">divide</code> function is called:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>user&gt; (divide 10 1)</strong></span>
INFO  - Dividing 10 by 1
DEBUG - Result: 10
10
<span class="strong"><strong>user&gt; (divide 10 0)</strong></span>
INFO  - Dividing 10 by 0
ERROR - There was an error!
java.lang.ArithmeticException: Divide by zero
at clojure.lang.Numbers.divide(Numbers.java:158) ~[clojure-1.7.0.jar:na]
...
at java.lang.Thread.run(Thread.java:744) [na:1.7.0_45]
nil</pre></div><p>As shown previously, the <code class="literal">divide</code> function writes several log messages at different log levels when it is <a class="indexterm" id="id00606"/>called. The logging configuration for <code class="literal">logback</code> must be<a class="indexterm" id="id00607"/> saved in a file named <code class="literal">logback.xml</code>, which can reside in either the <code class="literal">src/</code> or <code class="literal">resources/</code> directories of a Leiningen project. We can specify the default log level and several other options for <code class="literal">logback</code> in this file.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00153"/>Note</h3><p>If you're interested in the logging<a class="indexterm" id="id00608"/> configuration for the previous examples, take a look at the <code class="literal">src/logback.xml</code> file in the book's source code. For detailed configuration options, visit <a class="ulink" href="http://logback.qos.ch/manual/configuration.html">http://logback.qos.ch/manual/configuration.html</a>.</p></div></div><p>It is also handy to have a global exception handler that logs exceptions for all threads in a program. This can be particularly useful for checking errors that are encountered during the execution of <code class="literal">go</code> and <code class="literal">thread</code> macros from the <code class="literal">core.async</code> library. Such a global exception handler can be defined using the <code class="literal">setDefaultUncaughtExceptionHandler</code> method from the <code class="literal">java.lang.Thread</code> class, as shown in <span class="emphasis"><em>Example 11.5</em></span>:</p><div class="informalexample"><pre class="programlisting">(Thread/setDefaultUncaughtExceptionHandler
 (reify Thread$UncaughtExceptionHandler
   (uncaughtException [_ thread ex]
     (log/error ex "Uncaught exception on" (.getName thread)))))</pre></div><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Example 11.5: A global exception handler that logs all errors</em></span></p></blockquote></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note00154"/>Note</h3><p>You can also use<a class="indexterm" id="id00609"/> <span class="emphasis"><em>Timbre</em></span> (<a class="ulink" href="https://github.com/ptaoussanis/timbre">https://github.com/ptaoussanis/timbre</a>) for logging, which can be configured without the use of XML and is also supported on ClojureScript.</p></div></div><p>In conclusion, there are several options for logging available to us through the <code class="literal">tools.logging</code> library. This library also supports several logging implementations that each have their own set of configuration options.</p></div>
<div class="section" title="Thinking in Clojure"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec0066"/>Thinking in Clojure</h1></div></div></div><p>Let's briefly discuss a handful of good practices for building real world applications in Clojure. Of course, these practices are only guidelines, and you should eventually try to establish your own set of rules <a class="indexterm" id="id00610"/>and practices for writing code in Clojure:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Minimize state and use pure functions</strong></span>: Most applications must inevitably use some form of state. You must always strive to reduce the amount of state you're dealing with, and implement most of the heavy lifting in pure functions. State can be <a class="indexterm" id="id00611"/>managed using reference types, channels, or even monads in Clojure, thus giving us a lot of proven options. In this way, we can reduce the number of conditions that can cause any unexpected behavior in a program. Pure functions are also easier to compose and test.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Don't forget about laziness</strong></span>: Laziness can be used as an alternative to solve problems that have solutions based on recursion. Although laziness does tend to simplify several aspects of functional programming, it also incurs additional memory usage<a class="indexterm" id="id00612"/> in certain situations, such as holding on to the head of a lazy sequence. Take a look at <a class="ulink" href="http://clojure.org/reference/lazy#_don_t_hang_onto_your_head">http://clojure.org/reference/lazy#_don_t_hang_onto_your_head</a> for more information on how laziness can increase the memory usage of your program. Most of the standard functions in Clojure return lazy sequences as results, and you must always consider laziness when working with them.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Model your program as transformations of data</strong></span>: It is unavoidable to think in steps as humans, and you must always try to model your code as steps of transforming data. Try to avoid thinking in steps that mutate state, but rather in transformations of data. This leads to a more composable design, which makes combining a handful of transformations very easy.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Use the threading macros -&gt; and -&gt;&gt; to avoid nesting expressions</strong></span>: You must have seen quite a few examples in this book that have used these macros, and have probably started enjoying their presence in your own code as well. The <code class="literal">-&gt;</code> and <code class="literal">-&gt;&gt;</code> macros improve readability greatly, and must be used wherever possible. Don't hesitate to use these macros even if it avoids a couple of levels of nesting. There are several other threading macros, such as <code class="literal">cond-&gt;</code> and <code class="literal">as-&gt;</code>, that can often be useful.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Parallelism is at your fingertips</strong></span>: There are several ways to write programs that benefit through the use of parallelism in Clojure. You can choose between futures, reducers, <code class="literal">core.async</code> processes, and several other constructs to model concurrent and parallel operations. Also, most of the state management constructs, such as atoms, agents, and channels, have been designed with concurrency in mind. So, don't hesitate to use them when you're dealing with concurrent tasks and state.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Live in the REPL</strong></span>: It's an indispensable tool for experimenting with code and prototyping your programs. After writing a function or a macro, the first thing you should do is play with it in the REPL. You can use the <code class="literal">load-file</code> function to quickly reload changes in your source files without ever restarting the REPL. Keep in mind that reloading a source file with the <code class="literal">load-file</code> form will erase any modifications or redefinitions in the namespace of the source file that have been made through the REPL.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Embed a Clojure REPL in your application</strong></span>: It is possible to embed the REPL into an <a class="indexterm" id="id00613"/>application, thus allowing us to connect to it and modify its behavior at runtime as we desire. For more information on how to do this, take a look at the constructs in the <code class="literal">clojure.core.server.repl</code> namespace<a class="indexterm" id="id00614"/> or the <code class="literal">tools.nrepl</code> library (<a class="ulink" href="https://github.com/clojure/tools.nrepl">https://github.com/clojure/tools.nrepl</a>). But, this is a possible security risk, and should be used with caution.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Use the standard coding style with consistency</strong></span>: Maintaining a good coding style is important in any project or programming language. All of the examples in this<a class="indexterm" id="id00615"/> book are formatted in a standard way, as defined by the Clojure style guide (<a class="ulink" href="https://github.com/bbatsov/clojure-style-guide">https://github.com/bbatsov/clojure-style-guide</a>).</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec0067"/>Summary</h1></div></div></div><p>So far, we talked about several ways to troubleshoot our code. The <code class="literal">tools.trace</code> and Spyscope libraries are useful in interactive debugging, while the <code class="literal">tools.logging</code> library can be used to log information in running applications. We also discussed a handful of good practices for developing applications and libraries in Clojure.</p><p>You must be quite anxious by now to write your own applications in Clojure. If you've been paying attention so far, you must have noticed that Clojure is indeed a simple language. Yet, through its simplicity, we are empowered to create elegant and scalable solutions to a lot of interesting problems. On your journey with Clojure ahead, always strive to make things simpler, if they aren't simple enough already. We'll leave you with a few thought provoking quotes as you go onwards to realize the possibilities of this elegant, powerful, and simple programming language.</p><div class="blockquote"><table border="0" cellpadding="0" cellspacing="0" class="blockquote" summary="Block quote" width="100%"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Composing simple components is the way we write robust software."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td align="right" colspan="2" style="text-align: center" valign="top">--<span class="attribution"><span class="emphasis"><em>Rich Hickey</em></span></span></td></tr></table></div><div class="blockquote"><table border="0" cellpadding="0" cellspacing="0" class="blockquote" summary="Block quote" width="100%"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Simplicity is prerequisite for reliability."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td align="right" colspan="2" style="text-align: center" valign="top">--<span class="attribution"><span class="emphasis"><em>Edsger W. Dijkstra</em></span></span></td></tr></table></div><div class="blockquote"><table border="0" cellpadding="0" cellspacing="0" class="blockquote" summary="Block quote" width="100%"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Simplicity is the ultimate sophistication."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td align="right" colspan="2" style="text-align: center" valign="top">--<span class="attribution"><span class="emphasis"><em>Leonardo da Vinci</em></span></span></td></tr></table></div></div>
<div class="appendix" title="Appendix&#xA0;A.&#xA0;References"><div class="titlepage"><div><div><h1 class="title"><a id="appA"/>Appendix A. References</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Anatomy of a Reducer</em></span>, Rich Hickey (2012): <a class="ulink" href="http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html">http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Transducers are Coming</em></span>, Rich Hickey (2014): <a class="ulink" href="http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming">http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Introduction to Logic Programming with Clojure</em></span>, Ambrose Bonnaire-Sergeant (2011): <a class="ulink" href="http://github.com/frenchy64/Logic-Starter/wiki">http://github.com/frenchy64/Logic-Starter/wiki</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>N-Queens with core.logic</em></span>, Martin<a class="indexterm" id="id00616"/> Trojer (2012): <a class="ulink" href="http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html">http://martinsprogrammingblog.blogspot.in/2012/07/n-queens-with-corelogic-take-2.html</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Clojure core.async Channels</em></span>, Rich Hickey (2013): <a class="ulink" href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels">http://clojure.com/blog/2013/06/28/clojure-core-async-channels</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Communicating Sequential Processes</em></span>, C. A. R. Hoare (1978): <a class="ulink" href="http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf">http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Communicating Sequential Processes</em></span>, David Nolen (2013): <a class="ulink" href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/">http://swannodette.github.io/2013/07/12/communicating-sequential-processes/</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>A Dining Philosophers solver</em></span>, Pepijn de Vos (2013): <a class="ulink" href="http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html">http://pepijndevos.nl/2013/07/11/dining-philosophers-in-coreasync.html</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>CSP vs. FRP</em></span>, Draco Dormiens (2014): <a class="ulink" href="http://potetm.github.io/2014/01/07/frp.html">http://potetm.github.io/2014/01/07/frp.html</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Functional Reactive Animation</em></span>, Conal Elliott and Paul Hudak (1997): <a class="ulink" href="http://conal.net/papers/icfp97/icfp97.pdf">http://conal.net/papers/icfp97/icfp97.pdf</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Yolk </em></span><a class="indexterm" id="id00617"/><span class="emphasis"><em>examples</em></span>, Wilkes Joiner (2013): <a class="ulink" href="https://github.com/Cicayda/yolk-examples">https://github.com/Cicayda/yolk-examples</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The </em></span><a class="indexterm" id="id00618"/><span class="emphasis"><em>Clojure docs</em></span>: <a class="ulink" href="http://clojure.org/">http://clojure.org/</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Cats </em></span><a class="indexterm" id="id00619"/><span class="emphasis"><em>Documentation</em></span>: <a class="ulink" href="http://funcool.github.io/cats/latest">http://funcool.github.io/cats/latest</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The</em></span><a class="indexterm" id="id00620"/><span class="emphasis"><em> core.logic wiki</em></span>: <a class="ulink" href="http://github.com/clojure/core.logic/wiki">http://github.com/clojure/core.logic/wiki</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The </em></span><a class="indexterm" id="id00621"/><span class="emphasis"><em>Pulsar docs</em></span>: <a class="ulink" href="http://docs.paralleluniverse.co/pulsar/">http://docs.paralleluniverse.co/pulsar/</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The </em></span><a class="indexterm" id="id00622"/><span class="emphasis"><em>Midje wiki</em></span>: <a class="ulink" href="http://github.com/marick/Midje/wiki">http://github.com/marick/Midje/wiki</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Getting </em></span><a class="indexterm" id="id00623"/><span class="emphasis"><em>Started with Speclj</em></span>: <a class="ulink" href="http://speclj.com/tutorial">http://speclj.com/tutorial</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The</em></span><a class="indexterm" id="id00624"/><span class="emphasis"><em> core.typed </em></span><a class="indexterm" id="id00625"/><span class="emphasis"><em>wiki</em></span>: <a class="ulink" href="http://github.com/clojure/core.typed/wiki">http://github.com/clojure/core.typed/wiki</a></li></ul></div></div></body></html>