- en: Understanding Linking and Using jlink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we've learned about some advanced concepts relating
    to Java modularity, including handling readability and accessibility of module
    relationships, and the powerful concept of services. In this chapter, we'll move
    on to the final step in any application development--building and packaging your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what you''ll learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn about the module resolution process, an important process that
    happens every time you compile or execute a modular Java application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll be introduced to a new phase in the development process--linking. Linking,
    or static linking, is a new step in Java 9 modular development. It sits between
    the familiar compilation and execution phases that you should already be familiar
    with. In this chapter, you'll understand what linking is and the benefits of this
    step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn how to use `jlink`, the new tool built into the platform to facilitate
    the linking phase and help build runtime images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn about some `jlink` plugins that optimize runtime images that are
    created by `jlink`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn how to build a modular JAR file, which is an alternative way to
    distribute your compiled library modules for use in other applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module resolution process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the details of the linking process and what it can do for
    us, let's understand an important step that happens every time you compile and
    execute a modular Java application. This is a step called **module resolution**.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally (pre-Java 9), the Java compiler and Java runtime would to look
    at a set of folders and JAR files that form the **classpath**. The classpath is
    a configurable option that you pass to the compiler during compilation and to
    the runtimes during execution. In order to have any class file be under the purview
    of the compiler or runtime, you'd need to first place it in the classpath. Once
    it's there, every Java type is *available* for the compiler or the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Things are different with modules. We don't have to use the generic classpath
    anymore. Since every module defines its *inputs* and *outputs*, there's now an
    option to know exactly what portion of the code is needed at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following module dependency graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s assume that you have the modules **A**, **B**, **C**, **D**, and **E**
    in the module path. Let''s imagine that you are playing the role of the Java runtime,
    and you want to execute the `main` method in module **C**. What is the minimal
    set of modules that are *required* for this to happen? You''ll obviously need
    module **C**, since that has the `main` method. Next you''ll need its dependencies,
    modules **B** and **D**. Next you''ll need those modules'' dependencies as well,
    which in this case is module **A**, which **B** depends on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using this process, it's safe to say that the minimum set of modules required
    to execute a `main` type in module **C** is **A**, **B**, **C**, and **D**--module
    **E** is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s repeat the exercise, but this time to execute a type in module **E**.
    This time, we''ll just need modules **E** and **D**; all other modules can be
    skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now why are we doing this? What's the advantage of finding this *minimal set
    of modules?* Contrast this with the older classpath model where every type in
    the classpath is a part of the application, and any type could be *in use*. There's
    no way for the compiler and runtime to figure out where a given type exists unless
    it scans the entire classpath. That's not the case anymore! Since both the compiler
    and runtime now have a precise idea about what part of the code base is *needed*
    to execute anything and what part is not, it puts this advantage to good use,
    as we'll soon see. But in order to get this information, the platform runs a process
    of resolving modules, which is, in principle, similar to what we did in the preceding
    example. This process is called the module resolution process.
  prefs: []
  type: TYPE_NORMAL
- en: In graph theory, this process is referred to as finding *transitive closure*.
    Given a graph, the idea is to find a set of nodes that are *reachable* from a
    given node. The graph on which we perform transitive closure should be what's
    called a **directed acyclic graph** (**DAG**). The graph should be **directed**,
    in that the relationships between nodes are directional (with arrows), and **acyclic**,
    in that there shouldn't be cyclical relationships. Does the DAG remind you of
    any graphs you've seen recently? Yes! The Java module graph is a great example
    of a directed acyclic graph!
  prefs: []
  type: TYPE_NORMAL
- en: Module resolution steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the high-level steps that the platform runs through when it resolves
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the root module to the resolved set of modules. Remember that when you execute
    your code, you specify the type containing the main method and the module it belongs
    to. This module is the root module and forms the starting point for the module
    resolution process. Note that this starting point doesn't have to be just one
    module--there could be several modules, as we'll see shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify all the `requires` dependencies of the module(s) added. Here, each
    module's descriptor file is looked up to identify all the modules that it *reads*.
    This includes both `requires` and `requires transitive`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the list from step 2, remove all modules that are already in the resolved
    set of modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the remaining modules to the resolved set of modules. Repeat step 2 for
    this list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can imagine, this is a recursive graph operation that starts with one
    or more modules and ends up with the minimal set of modules that are needed as
    dependencies. Since the platform does this during every compilation and runtime
    phase, it uses this opportunity to check for several different kinds of errors.
    In fact, many of the module errors we''ve encountered so far happen because of
    checks during and around the module resolution process. Here are a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unavailable dependent modules**: This one is obvious. While looking up dependencies,
    if a module isn''t found among the observable modules, the process errors out.
    This, as we''ve seen, is the key to reliable configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple modules**: Not only do all dependent modules have to be available,
    there needs to be only one of each. If there happen to be two modules in the module
    path that have the same name (even if they have entirely different contents),
    the platform catches this right away and throws an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclic dependencies**: If two or more modules depend on each other and form
    a closed loop cycle in the module graph, the platform throws an error, as we''ve
    already seen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Split packages**: The platform assumes that each package is available in
    just one module. The class loaders maintain a map of each package to the module
    it is found in. Thus, if there are multiple modules that contain the same package,
    the process terminates with an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining module resolution in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a new command option added to Java that prints out debug information
    that describes the module resolution process. You can activate it by passing the
    option `--show-module-resolution`. When passed this option, the `java` command
    prints out console messages for each step of the module resolution. You can use
    this to see the process that the runtime goes through to resolve all the modules,
    much like we did in the preceding exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you ran the command-line address book module in the previous chapter,
    without the flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how you run it with the module resolution diagnostics enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The verbose output gives a clear indication of what''s happening here. Things
    start off with the root module `packt.addressbook`, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it finds the dependent modules from the module descriptor. For every
    module it finds, the output lists the name of the module, where it found it (the
    path), and why (which module required it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It also figures out the service providers based on the modules that declared
    themselves as consumers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The runtime continues to look for subsequent dependencies as it traverses the
    nodes of the module graph. After it''s done adding all the necessary modules to
    the resolved set, it then executes the main method and the expected program output
    is printed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that you've understood the process of module resolution and how it benefits
    the process of compile-time and runtime enforcement of reliable configuration,
    let's now look at another problem that it can solve. We briefly introduced the
    problem of the monolithic JDK in [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb),
    *Introducing Java 9 Modularity*. We'll quickly recap the problem and then learn
    how that it is no longer a problem with Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the state of the JDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing
    Java 9 Modularity*, we examined the large size of the JDK, both in terms of the
    file size of `rt.jar` as well as the number of classes that are bundled in it.
    Typically, you wouldn''t think about the JDK when developing Java applications.
    Once you''ve installed the JDK on your development machine, it sits in a remote
    corner of your hard disk at `$JAVA_HOME` and it doesn''t bother you. There are,
    however, a few instances where you would need to worry about the size of the JDK,
    especially when bundling an application executable. Here are a couple of such
    occasions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime bundles for embedded devices**: Java has been known to run on portable
    and embedded devices, such as compact music players, microwaves, and washing machines.
    Many of these are devices with scarce hardware capacities for memory and processing
    power, and for Java to run on those devices, the runtime should obviously be a
    part of the installed application. The size of the Java SE runtime is so prohibitive
    that there is a separate platform (Java ME) for such scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime images for microservices**: A common trend in recent years is to
    deploy lightweight microservices in the cloud. Instead of having one centralized
    web application that does everything, the application is split into separate smaller
    services that run on different machine instances and communicate with each other
    over the network. The runtime image for each instance is a self-sufficient set
    of binaries that include the application classes and the Java runtime. These microservices
    are ideally stateless, scalable, and disposable, so they''d ideally need to be
    lightweight and performant. Bundling a 75 MB runtime that needs to be a part of
    every instance doesn''t really help.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think for a minute about why this problem even exists. Well, it's because of
    the classpath model of previous versions of Java. Any piece of code can potentially
    refer to any other Java type in the classpath, and there's no saying what's required
    and what's not, so we had no choice but to add the whole platform.
  prefs: []
  type: TYPE_NORMAL
- en: This is no longer the case with modular programming! We've seen that with module
    resolution, given a starting point, we can precisely identify which modules are
    required for its execution. This applies equally to both application and platform
    modules, since they both follow the same contract. Thanks to this, we can now
    apply the module resolution process and come up with a unique bare minimum set
    of platform *and* application modules that you'd need to run any application.
    Thus, when distributing an application with runtime, for example, you don't have
    to include the entire platform. Instead, you just include the platform modules
    that are necessary, and we do just that by introducing a whole new step in Java
    application development that we didn't have before--linking.
  prefs: []
  type: TYPE_NORMAL
- en: Linking using jlink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JDK 9 comes bundled with a new tool called `jlink` that lets you build your
    own complete runtime image that contains everything necessary to execute a given
    application. Remember the new structure of the JDK that we looked at in [Chapter
    4](part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb), *Introducing the Modular
    JDK*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With `jlink`, you can create a similar custom image of your own to distribute
    your application. The generated image contains:'
  prefs: []
  type: TYPE_NORMAL
- en: The minimal set of your application and library modules that you've authored
    or added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimal set of platform modules needed for your application to work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This effectively solves the problem of the huge overhead incurred to ship the
    platform along with your application. What you ship is just what the application
    needs--no more, no less. There are further benefits to this process, but before
    we get into that, let's learn how to use `jlink` to create this image.
  prefs: []
  type: TYPE_NORMAL
- en: The jlink command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `jlink` command needs the following inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The module path**: This is where it needs to look for modules. This is the
    directory (or directories) where the compiled modules are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The starting module**: This is the module from which to begin the module
    resolution process. This could be one or many, separated by delimiters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The output directory**: This is the location where it stores the generated
    image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The usage looks something like this, with the command broken into separate
    lines for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this command on our sample codebase and generate an image for the address
    book UI module, we first need to compile the modules in the same way that we usually
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `out` is the location of the compiled modules, and thus, that is the module
    path for `jlink`. The module that serves as the starting point is `packt.addressbook.ui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same directory that we ran the `javac` command, we can now run `jlink`.
    To run the command, either make sure the  `$JAVA_HOME/bin` directory is in your
    operating system''s  path, or use the path to access `jlink` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are missing the platform modules! Note that `java.base` is a core platform
    module and is not available in the module path we've specified in the preceding
    command. Platform modules don't get special treatment; their module location needs
    to be explicitly specified to the `jlink` command!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen that the core Java modules are available in `$JAVA_HOME/jmods`.
    Let''s add that to the `--module-path` parameter. As before, in order to specify
    multiple paths there, we need to separate the paths with the `:` symbol (`;` on
    Windows operating systems):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`jlink` will now get to work and quietly generate the runtime image for us.
    Let''s look at the structure of the image generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This should look familiar now. The structure is very similar to the JDK file
    structure we've already seen. One notable exception is that the `jmods` folder
    isn't here. This makes sense because this is a *runtime* image, and the `jmods`
    format is not designed to be used for runtime. Since this image contains only
    the modules necessary, they are all bundled into a common `modules` file in the
    `lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the image contains the runtime and the compiled application modules,
    it is a self-sufficient bundle. You can deploy this image on a computer that does
    not have the Java runtime installed and execute it without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to execute our module from the runtime image, we need to execute the `java`
    executable that''s available in the `bin` directory of the image, not the one
    in `$PATH`. You also don''t have to specify the `--module-path` this time because
    the module resolution is already done! The generated image is already bundled
    with every module it needs, and thus already knows where to find them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the address book UI application pop up. That''s great, but you
    can probably tell something isn''t right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The names aren''t sorted. Can you guess why? It''s because the sorting modules
    haven''t been bundled in! If you run the `java --list-modules` on the `java` executable
    in the image, you can see all the modules that have been bundled in. Note that
    the sorting service modules aren''t included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the module resolution process traverses the module graph and adds
    modules that have a **direct dependency** using the `requires` clause. Services,
    by definition, are loosely coupled and so are not required by any module. Because
    of this reason, both the service modules--`packt.sort.bubblesort` and `packt.sort.javasort`--haven't
    been included. This behavior of `jlink` is intentional. The bundling of service
    modules needs to be explicitly stated to the command.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `java --list-modules` command displays the observable modules
    that are available in the runtime image on which the command is run. All along,
    we've run the command on the installed JDK, so it listed all (and only) the platform
    modules. This time, we have run the command on the generated runtime image, which
    is a combination of our application modules and a select few platform modules.
    Thus, the output of the command reflects that accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways we can fix our problem. The first way is to add
    the service modules to the list of **starting-point modules** for module resolution
    using the `--add-modules` option. Multiple module names can be specified for this
    option, with the names separated by commas. These modules and their dependencies
    will then also get bundled into the image, since the module resolution process
    will run starting from each of those modules, too, and add them to the resolved
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, running `java --list-modules` in the generated image should show the sorting
    modules. Also, when executing the application, the UI should now show the list
    of contacts sorted by last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another alternative to bundling in services is to use the `--bind-services`
    option of `jlink`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This parameter automatically identifies any services consumed by modules when
    it checks each module through the module resolution process. Then, all observable
    modules that declare that they are providers for those services will be automatically
    bundled in. This is an easier option because you don't have to explicitly mention
    service modules yourself, but there's a chance that you might pull in more modules
    than you really require. Let's say there's some random module in the module path
    that your application doesn't use, but it just happens to implement one of the
    service types you've used. Well, that module gets pulled in with this option!
  prefs: []
  type: TYPE_NORMAL
- en: Link phase optimizations and jlink plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There have always been two steps to get Java code to execute--the compile step
    (using `javac`) and the execution step (using `java`). During the compilation
    step, `javac` doesn't just try to convert Java code into byte code, it also tries
    to perform any optimizations it can and generate the most optimal and efficient
    byte code possible. Over the years, the Java compiler has learned several new
    tricks and strategies to better optimize the resulting byte code. But there has
    always been a challenge--the compiler works on a handful of classes at a time
    and it doesn't have the opportunity to see the big picture by looking at the entire
    application, which could have helped it implement better optimizations. That option
    is available for runtime, but some of the optimizations end up being too expensive
    when done at runtime. With the introduction of the new linking step in between
    the compile and execution phases, an opportunity opens up to do application-level
    optimization for our Java byte code. In fact, one of the goals of the platform
    team for the linking phase is to do **whole-world** optimizations--optimizations
    that span multiple classes and modules across the application, having been given
    the **bigger picture**.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the linking step is optional, of course. We've executed our application
    in the previous chapters without having to use `jlink`, and thereby without doing
    any such optimizations. However, if you were to use `jlink`, there's an opportunity
    to do optimizations--things such as compressing the image, identifying and removing
    unreachable code and types, pre-optimizing code, and methods where the possible
    inputs are constant and known ahead of time. These optimizations can happen when
    running `jlink` and are done using a series of `transformers`, which are built
    as plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an approximation of how `jlink` works to create the runtime image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The process starts with gathering all the necessary resources and running them
    through a series of transformers that can do various tasks and optimizations.
    The `jlink` tool has a plugin API so that anyone can create custom plugins that
    hook into this process and have the opportunity to transform the resulting image.
    After the transformers are done, the image is written to the output directory,
    where, again, plugins can be written to control what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java 9 platform comes with built-in plugins that do several of these optimizations.
    In fact, some of these optimizations are so important and have such a significant
    impact that they have been turned on by default! It''s important to know some
    of these options that are available to you while you generate your runtime image:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Module descriptor optimizations with the** **system-modules plugin**: During
    the initial development of modules in Java, it was noticed that the Java runtime
    ended up spending a significant amount of time and resources examining, parsing,
    and validating the module descriptors (`module-info.class`) of each module in
    the system image. Since the set of modules that are going to be bundled in an
    image is known at link time, the process of scanning and validating all the module
    descriptors can be done at link time too. There is a `jlink` plugin that does
    this bundled with the platform, and is called `system-modules`. This plugin generates
    a pre-processed and pre-validated system module graph so that the runtime doesn''t
    have to. The process results in such significant gains in performance that it''s
    enabled by default whenever you run `jlink`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compressing the image with the** **compress plugin**: This plugin allows
    you to apply compression to the generated image to reduce the size of the output
    runtime image. There are two types of compression that this plugin can perform
    on the generated image. The first identifies all usages of UTF-8 strings and generates
    a global string table so that any common `String` values have to be stored only
    once and can be reused across the application. The second type of compression
    is the ZIP compression of files in the resulting image to shrink its overall size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike system-modules, this plugin is not enabled by default. To use it, you'll
    need to pass the `--compress` option to `jlink`. You can pass three values--`0`,
    which means no compression, `1`, which enables string sharing, and `2`, which
    does ZIP compression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the two levels of compression while generating the address book image
    on our sample code shows the gains in size of the generated images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the sizes of the resulting images shows us how much space the compression
    has saved us. The following table summarizes the folder sizes on my machine after
    running these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compression** | **Address book image size** |'
  prefs: []
  type: TYPE_TB
- en: '| None | 167.5 MB |'
  prefs: []
  type: TYPE_TB
- en: '| Level 1 | 129.4 MB |'
  prefs: []
  type: TYPE_TB
- en: '| Level 2 | 95.9 MB |'
  prefs: []
  type: TYPE_TB
- en: '**Locale information with the** **include-locales plugin**: By default, the
    runtime image bundles in all installed locale information. If you are targeting
    your application runtime only for certain locales, you can use the `--include-locales`
    option and pass the comma-separated list of locales you need. Only those locales
    will be included in the resulting image, thus freeing up more space:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command regenerates the image with full compression, and with
    the English locale included (`--include-locales=en`). On my machine, this resulted
    in further space savings, with the image size at 88.2 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other handy plugins that come bundled in the JDK. To get
    to know what plugins are available, and to learn how to use them, you can run
    `jlink` with the `--list-plugins` option. The complete list of installed plugins
    will be displayed, including the plugins we''ve just learned about and much more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Building a modular JAR file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at creating complete modular runtime images and learned about the
    advantages of the linking process, but sometimes that may not be what you want.
    Suppose you are a library developer and you just want to bundle a single utility
    module as a jar file. When building a jar file from a module, you have an option
    of creating a **modular JAR file**. A modular jar file is just like any other
    jar file, but with the `module-info.class` file in the root directory. You can
    use this to distribute compiled modules as a single file instead of the whole
    module folder. You can drop a modular JAR file in a module path when running the
    `java` command, and it behaves just like the compiled module folders that we've
    been dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, let's replace a couple of modules in the `out` folder of
    the address book application with modular JAR files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to create a modular JAR file is by using the `jar` utility. In order
    to convert the `packt.contact` module into a modular JAR file, we run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `--create` option tells the `jar` utility that it needs to create a JAR
    file. The `-C` option specifies where it can find the classes. The value is of
    the format `<folder> <file>`. In our case, the folder is `out/packt.contact`.
    This is followed by  "`.`"  which indicates that all files in this location need
    to be included. The `--module-version` option specifies a module version for the
    `jar`. Finally, the `--file` option provides the JAR output file name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this command will create a modular JAR file, with the `module-info.class`
    file at the root. There''s also a `META-INF` folder with a manifest file that
    records the version number specified: `Manifest-Version: 1.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even modules with an executable `main` method can be converted to modular jars.
    Here''s how we''d convert the `packt.addressbook.ui` module into a modular JAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Most of the parameters should be familiar here, except for the `--main-class`.
    This option, as the name says, specifies the type with the `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these two modules converted to modular JAR files and placed in the module
    path, you can now delete the corresponding compiled module folders and still execute
    the application. The runtime treats the modular JAR file the same way as the expanded
    module folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The application should still work the same way, although this time, it's executing
    two of the modules from the JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter examined the part of the application development process after
    you are done writing code--building and packaging your application for distribution.
    We started the chapter by examining the module resolution process. We then looked
    at the process of linking, which uses module resolution to build a runtime image
    containing just the modules needed for a given application. We then looked at
    some of the built-in plugins that allow us to optimize and preprocess the generated
    image. Finally, we learned how to generate a modular JAR file to bundle reusable
    library modules for use in other applications.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at a lot of features so far and how they work. In the next chapter,
    we'll start looking at how to work with Java 9 modules in the context of an existing
    legacy Java codebase. You'll learn ways to write code that is interoperable between
    different Java versions. You'll also learn techniques and strategies to migrate
    existing code written using Java 8 or earlier to the new modular application development
    of Java 9\. See you in the next unit!
  prefs: []
  type: TYPE_NORMAL
