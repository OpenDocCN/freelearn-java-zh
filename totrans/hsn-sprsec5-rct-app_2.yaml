- en: Deep Diving into Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a hands-on book, but our first chapter was theoretical (as it should
    be) because it was an introductory chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dive deeply into the technical capabilities of Spring
    Security, specifically authentication and authorization, using code. However,
    before we get into the coding, we will give a brief explanation of the theory.
    We are doing this because it is important to understand the concepts before diving
    into coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two most important aspects of security are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the identity of the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find what resources this user has access to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'authentication is the mechanism by which you find out who a user is, and authorization
    is the mechanism that allows an application to find out what the user can do with
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac322b64-46ba-4e10-8764-c3449f298df3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 01: Fundamental aspects of security—Authentication and Authorization'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the fundamental ways to secure a resource is to make sure that the caller
    is who they claim to be. This process of checking credentials and making sure
    that they are genuine is called **authentication**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the fundamental process Spring Security uses to
    address this core security requirement. The figure is generic and can be used
    to explain all the various authentication methods that the framework supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35829f9b-bc45-453d-b3c9-8d3f78cf8f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 02: Authentication architecture'
  prefs: []
  type: TYPE_NORMAL
- en: As detailed in [Chapter 1](bb1f1c6e-a9a4-4a14-aff4-3510fbfa7d14.xhtml), *Overview
    of Spring 5 and Spring Security 5* (in the *Working of Spring Security* section),
    Spring Security has a series of servlet filters (a filter chain). When a request
    reaches the server, it is intercepted by this series of filters (*Step 1* in the
    preceding diagram).
  prefs: []
  type: TYPE_NORMAL
- en: In the reactive world (with the new Spring WebFlux web application framework),
    filters are written quite differently than traditional filters (such as those
    used in the Spring MVC web application framework). Having said that, the fundamental
    mechanism remains the same for both. We have a dedicated chapter explaining how
    to convert a Spring Security application to Spring MVC and Spring WebFlux where
    we will cover these aspects in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Servlet filter code execution in the filter chain keeps skipping until
    the right filter is reached. Once it reaches the right authentication filter based
    on the authentication mechanism used, it extracts the supplied credentials (most
    commonly a username and password) from the caller. Using the supplied values (here,
    we have a username and password), the filter (`UsernamePasswordAuthenticationFilter`)
    creates an `Authentication` object (in the preceding diagram, `UsernamePasswordAuthenticationToken`
    is created using the username and password supplied in *Step 2*). The `Authentication`
    object created in *Step 2* is then used to call the `authenticate` method in the`AuthenticationManager`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The actual implementation is provided by *ProviderManager*, which has a list
    of configured `AuthenticationProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The request passes through various providers and, in due course, tries to authenticate
    the request. There are a number of `AuthenticationProvider` as part of Spring
    Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the diagram at the start of the chapter, `AuthenticationProvider` requires
    user details (some providers require this, but some don''t), which are provided
    in `UserDetailsService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`UserDetailsService` retrieves `UserDetails` (and implements the `User` interface)
    using the supplied username.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, Spring Security creates a fully populated `Authentication`
    object (authenticate: true, granted authority list and username), which will contain
    various necessary details. The `Authentication` object is stored in the `SecurityContext`
    object by the filter for future use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `authenticate` method in `AuthenticationManager` can return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Authentication` object with `authenticated=true`, if Spring Security can
    validate the supplied user credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `AuthenticationException`, if Spring Security finds that the supplied user
    credentials are invalid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`, if Spring Security cannot decide whether it is true or false (confused
    state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up AuthenticationManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are number of built-in `AuthenticationManager` in Spring Security that
    can be easily used in your application. Spring Security also has a number of helper
    classes, using which you can set up `AuthenticationManager`. One helper class
    is `AuthenticationManagerBuilder`. Using this class, its quite easy to set up
    `UserDetailsService` against a database, in memory, in LDAP, and so on. If the
    need arises, you could also have your own custom `UserDetailsService` (maybe a
    custom single sign-on solution is already there in your organization).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make an `AuthenticationManager` global, so it will be accessible by
    your entire application. It will be available for method security and other `WebSecurityConfigurerAdapter`
    instances. `WebSecurityConfigurerAdapter` is a class that is extended by your
    Spring configuration file, making it quite easy to bring Spring Security into
    your Spring application. This is how you set up a global `AuthenticationManager`
    using the `@Autowired` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create local `AuthenticationManager`, which is only available
    for this particular `WebSecurityConfigurerAdapter`, by overriding the `configure`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to expose the `AuthenticationManager` bean by overriding
    `authenticationManagerBean` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can also expose various `AuthenticationManager`, `AuthenticationProvider`,
    or `UserDetailsService` as beans which will override the default ones.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code examples we have used `AuthenticationManagerBuilder` to
    configure in-memory authentication. More mechanisms of the `AuthenticationManagerBuilder`
    class will be used in the subsequent examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: AuthenticationProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AuthenticationProvider` provides a mechanism for getting user details, with
    which authentication can be performed. Spring Security provides a number of `AuthenticationProvider`
    implementations, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c68b876c-9e2c-4329-b76d-63ebe1a3b376.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 03: Spring Security built-in AuthenticationProvider'
  prefs: []
  type: TYPE_NORMAL
- en: In subsequent chapters, we will go through each of these in detail with more
    code samples.
  prefs: []
  type: TYPE_NORMAL
- en: Custom AuthenticationProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If needs be, we can write a custom `AuthenticationProvider` by implementing
    the `AuthenticationProvider` interface. We will have to implement two methods,
    namely authenticate (`Authentication`) and `supports(Class<?> aClass)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our `authenticate` method is quite simple. We just compare the username and
    password with a static value. We can write any logic here and authenticate the
    user. If there is an error, it throws an exception, `AuthenticationException`.
  prefs: []
  type: TYPE_NORMAL
- en: On the book's GitHub page, navigate to the `jetty-in-memory-basic-custom-authentication`
    project to see the full source code of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple AuthenticationProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security allows you to declare multiple `AuthenticationProvider` in your
    application. They are executed according to the order in which they are declared
    in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jetty-in-memory-basic-custom-authentication` project is modified further,
    and we have used the newly created `CustomAuthenticationProvider` as an `AuthenticationProvider`
    (`Order 1`) and the existing `inMemoryAuthentication` as our second `AuthenticationProvider`
    (`Order 2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the `authenticate` method executes without error, the controls return and
    thereafter configured `AuthenticationProvider`'s doesn't get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's gets our hands dirty by doing some coding. We will start off with the
    most common authentication mechanisms and then get into other authentication mechanisms
    that can be used with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Base project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the actual authentication mechanism, many aspects of the application
    are quite similar. In this section, we will set up the example and then cover
    the specific authentication mechanism in detail.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the default Spring Security DB schema against which we will
    authenticate the user. We will create a fully fledged Spring MVC web application,
    with each component being created from scratch. Creating a sample Spring Security
    application using Spring MVC with the help of Spring Boot is very easy. The application
    will function through many things that are hidden away from developers. But in
    this case, we will be creating this application component by component so that
    you can see the actual code with which a web application that is built on Spring
    MVC can be secured.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default DB schema used by Spring Security is shown in the following diagram.
    However, you can customize it the way you think it is suitable for your application.
    We will be using the **Users** and **Authorities** tables for our setup here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16b57543-4f52-4af7-96a2-95087c1b51c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 04: Spring Security default database schema'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now start developing our sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1—Create a Maven project in IntelliJ IDEA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In IntelliJ, select File | New | Project. This will open up the New Project
    wizard, as shown in the following screenshot. Now select Maven and click the Next
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32266a6a-98b5-4f72-a76d-702c307cbdd1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 05: New Maven project in IntelliJ'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen in the New Project wizard (*Step 2*), enter the GroupId,
    ArtifactId, and Version, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b886993-a053-4200-8076-bb7cf3e78c26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 06: Maven project setup in IntelliJ—Input GroupId, ArtifactId and Version'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen in the New Project wizard (*Step 3*), enter the Project
    name and Project location, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eb9f732-38b0-4d9d-8be6-be901b714012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 07: Maven project setup—Setting Project name and Project location'
  prefs: []
  type: TYPE_NORMAL
- en: 'IntelliJ will prompt you with instructions, as shown in the following screenshot.
    To automatically import projects whenever you make any changes in `pom.xml`, click
    on the Enable Auto-Import link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ea8decb-8174-4daa-88b2-1dcd853587df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 08: Enabling Auto-Import in IntelliJ'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2—pom.xml changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `pom.xml` file and add the following code within the project tag (`<project></project>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Build a setup on `pom.xml` in which we will be using jetty to run the application
    created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Step 3—MySQL database schema setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a default database schema using the following scripts, and insert some
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert data into the preceding tables using the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `password` is one-way hashed using online tool [http://www.devglan.com/online-tools/bcrypt-hash-generator](http://www.devglan.com/online-tools/bcrypt-hash-generator).
    To compare the `password` we will use `PasswordEncoder` (`Bcrypt`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Credentials are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: User = `admin` and password = `admin@password`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User = `user` and password = `user@password`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to note that, even though the role is named `ROLE_ADMIN`, the
    actual name is `ADMIN`, and this is what our code will be using while passing.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4—Setting up MySQL database properties in your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file named `mysqldb.properties` in the `src/main/resources` folder
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Step 5—Spring application configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a Java class named `ApplicationConfig` with the following code in the `com.packtpub.book.ch02.springsecurity.config`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Step 6—Web application configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we are going to use Spring MVC as our web application framework.
    Let''s create the web application configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `@EnableWebMvc` annotation makes sure that your application is based on
    Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7—Spring MVC setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring MVC, the request lands on `DispatcherServlet`. `DispatcherServlet`
    can be declared in `web.xml` or as a Java configuration if your servlet container
    is 3.0+. Please create a dummy `SpringSecurityConfig.java` file. We will be constructing
    this class when we explain the first authentication mechanism, namely, basic authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Step 8—Controller setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a base controller (`HomeController`) for the secured JSP page
    (`home.jsp`). Please note that the return of the mapping method should be a string,
    and it should map to the actual name of the JSP file. In our case, it is `home.jsp`,
    a secured resource that the caller navigates when they log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Step 9—JSP creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our home page is a very simple JSP file, as shown in the following code snippet.
    This JSP just displays a message that we have constructed in our `HomeController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is now the base Spring MVC application, and with this we will try to set
    up various authentication mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explain Spring Security, we will implement basic authentication on the Spring
    MVC project that we created earlier. In [Chapter 3](69913c59-1186-44b2-8707-dceca721e206.xhtml), *Authentication
    Using SAML, LDAP, and OAuth/OIDC*, we will look at implementing other authentication
    mechanisms using Spring Security. To accomplish basic authentication in your application,
    let's perform the additional steps outlined in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1—Spring Security configuration setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now create the all-important Spring Security configuration class and
    make sure that the default filter chain for Spring Security is set up to secure
    all the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In Spring Security configuration, the first thing that we do is tell Spring
    Security that you will have to authenticate the user against a database by using
    a defined user query and checking the user's authority using the defined authority
    query.
  prefs: []
  type: TYPE_NORMAL
- en: We then set up the authentication mechanism to retrieve the user's credentials.
    Here we are using basic authentication as the mechanism to capture user credentials.
    Please note that the role names being used to check doesn't have the prefix `ROLE_`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2—Spring Security setup for a web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that we have to instruct the application to start using Spring Security.
    One easy way is to declare the Spring Security filter in `web.xml`. If you want
    to avoid using XML and perform the actions using Java instead, then create a class
    that extends `AbstractSecurityWebApplicationInitializer`; this will do the trick
    of initializing the filter and setting Spring Security for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have completed all the setup required to see basic authentication
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the project by executing the `mvn jetty:run` command. Once you see the
    log shown in the following screenshot, open a browser and go to `http://localhost:8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a210e9d-0372-4afc-9680-cc9b8c35ba93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 09: Jetty Server running - console log'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you access the URL, the browser prompts with a default basic authentication
    dialog, as shown in the following screenshot. Enter the Username and Password as `admin`/`admin@password` and
    click on Log In:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/855b76d0-f0f3-4dbe-967e-d928a2405f89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: Basic authentication dialog in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your credentials are correct and if the user has either the `ADMIN` or `USER` role,
    you should see the home page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9c599ce-0360-4309-a0a5-a535d7d27a09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: The home page after successful login'
  prefs: []
  type: TYPE_NORMAL
- en: The full project code is available on the book's GitHub page ([https://github.com/PacktPublishing/Hands-On-Spring-Security-5-for-Reactive-Applications](https://github.com/PacktPublishing/Hands-On-Spring-Security-5-for-Reactive-Applications))
    within the `jetty-db-basic-authentication`project.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory user storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, for various testing purposes, it''s better to store the
    user credentials and then authenticate in memory than to use a proper database,
    such as MySQL. For this, just change the Spring Security configuration file (`SpringSecurityConfig.java`)
    by adding the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that the password has a prefix, `{noop}`, attached to
    it. This ensures that when the password is validated, no encoding is carried out.
    This is one way to avoid having password encoding errors when you run the project.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code, as a fully fledged project, can be found on this book's
    GitHub page in the `jetty-in-memory-basic-authentication` project.
  prefs: []
  type: TYPE_NORMAL
- en: Run as Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example can be easily converted to a Spring Boot application by
    following the ensuing additional steps. This process won't cover many of the trivial
    steps that we have done previously. You need to have one more configuration file, `SpringSecurityConfig.java`*,*
    the details of which are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new file, usually named `Run.java`, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a very simple file with an important annotation in it, `@SpringBootApplication`.
    We took away the Spring MVC configuration class and put the following properties
    in the `application.properties` file. This is just another way to avoid creating
    a new Spring MVC configuration file and instead use the properties file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As earlier, everything else is kept intact. For the full project, refer to the
    book's GitHub page in the `spring-boot-in-memory-basic-authentication` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a command prompt and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Open the browser and navigate to `http://localhost:8080`, and you should be
    provided with a basic authentication dialog. After successful login, you should
    be taken to the user home page, as shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the user is validated in terms of who they claim to be, the next aspect,
    what the user has access to, needs to be ascertained. This process of making sure
    what the user is allowed to do within the application is called authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line with authentication architecture, as seen earlier, authorization also
    has a manager, `AccessDecisionManager`. Spring Security has three built-in implementations
    for this: `AffirmativeBased`, `ConsensusBased`, and `UnanimousBased`. `AccessDecisionManager` works
    by delegating to a chain of `AccessDecisionVoter`. Authorization-related Spring
    Security classes/interfaces are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed1850b0-950f-4d1c-ae8f-7bb3d3143455.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: Spring Security Authorization classes/interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Spring Security, authorization to a secured resource is granted by invoking
    voters and then tallying the votes received. The three built-in implementations
    tally the votes received in different manners:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AffirmativeBased**: If at least one voter votes, the user is given access
    to the secured resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConsensusBased**: If a clear consensus is reached between the voters and
    their votes, then the user is given access to the secured resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UnanimousBased**: If all the voters vote, then the user is given access to the
    secured resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Security provides two authorization approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web URL**: Incoming URL (specific URL or regular expression)-based authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: Method signature based on which access is controlled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your serving layer exposes only RESTful endpoints and the data in your application
    is properly categorized as resources (complying with REST principles), using a
    Web URL approach can be considered. If your application just exposes endpoints
    (REST-based, I would call) not really complying with REST principles, you can
    consider using method-based authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Web URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security can be used to set up URL-based authorization. HTTP Security
    configured can be used with Spring Security configuration to achieve the desired
    authorization. In many examples that we have gone through so far, we have seen
    pattern matching authorization. Here is one such example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AntPathRequestMatcher`: Uses an Ant-style pattern for URL matching:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `/rest` URL's basic authentication is disabled,
    and for other URLs (`/rest/movie`, `/rest/ticket` and `/index`), users with the
    `USER` role have access. The snippet also shows single match (using `antMatcher`)
    and multiple matches (using `antMatchers`).
  prefs: []
  type: TYPE_NORMAL
- en: '`MvcRequestMatcher`: This uses Spring MVC to match the path and then extracts
    variables. The matching is relative to the servlet path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegexRequestMatcher`: This uses a regular expression to match the URL. It
    can also be used to match the HTTP method, if needed. The matching is case-sensitive
    and takes the form (`servletPath` + `pathInfo` + `queryString`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Method invocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security allows users to access-control method execution using **aspect-oriented
    programming** (**AOP**) in the background. This can be done using XML configuration
    or using Java configuration. Since we have been following Java configuration throughout
    this book, we will cover Java configuration and annotations here to explain method
    security. The best practice is to choose a particular method invocation authorization
    approach and stick to it for consistency across your application. Choose whichever
    approach is apt for your application, as there isn't anything particular documented
    on when to choose what.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to enable method security in your application, firstly annotate
    the class with `@EnableMethodSecurity`. There are three types of annotation with
    which you can annotate the methods and authorize them. The types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Voting-based** **ann****otations**: the most commonly used annotations in
    Spring Security. Spring Security''s `@Secured` annotation falls into this category.
    To use these annotations, they first have to be enabled, as shown in the following
    code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the usage of annotation is enabled, the `@Secured` annotation can be used,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**JSR-250 security annotations**: This is also called the **Enterprise JavaBeans
    3.0** (**EJB** **3**) security annotation. Again, before using these annotations,
    they have to be enabled using `@EnableGlobalMethodSecurity(jsr250Enabled = true)`.
    The following snippet shows the JSR-250 security annotation in action:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Expression-based annotation**: Annotations based on `@Pre` and `@Post` fall
    into this category. They are enabled using `@EnableGlobalMethodSecurity(prePostEnabled
    = true)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `hasAnyAuthority` is called **Spring Expression Language**
    (**SpEL**). Similar to the example shown, there are many such predefined expressions
    that can be used for security.
  prefs: []
  type: TYPE_NORMAL
- en: Domain instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security provides ways to access control various permissions attached
    to any object. Spring Security **Access Control List** (**ACL**) stores a list
    of permissions associated with a domain object. It also grants these permissions
    to various entities that need to perform different operations on the domain object.
    For Spring Security to work, you need to set up four database tables, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2edbf2b-2268-4cf9-9414-d68a1a2d93df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: Spring Security ACL database schema'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small explanation of the tables in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ACL_CLASS` table: As the name suggests, it stores the domain object''s class
    name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACL_SID` table: **Security Identity** (**SID**) stores either a username (`testuser`)
    or role name (`ROLE_ADMIN`). The `PRINCIPAL` column stores either 0 or 1, 0 if
    the SID is a username and 1 if it is a role name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACL_OBJECT_IDENTITY` table: It is entrusted to store object-related information
    and links other tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACL_ENTRY` table: It stores permission granted to each SID for each `OBJECT_IDENTITY`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order for Spring Security ACL to work, it also requires a cache. One of the
    easiest ones to integrate with Spring is EhCache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security ACL supports the following permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WRITE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CREATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADMINISTRATION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make it work, we have to enable it using `@EnableGlobalMethodSecurity(prePostEnabled
    = true, securedEnabled = true)`. We are now ready to put annotations in place
    to start access controlling domain objects. A code snippet in which Spring ACL
    is used is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After querying for records (post-filtering), the result (a list) is scrutinized,
    and filtering takes place to only return the object to which the user has `READ`
    permission. We can also use `@PostAuthorize` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution of the method (`@Post`), if the user has `READ` access on the
    object, it is returned. Otherwise, it throws an `AccessDeniedException` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Before the method is fired (`@Pre`), it checks whether the user has the `WRITE`
    permission on the object. Here, we use the parameter being passed into the method
    to check for user permission. If the user has permission to `WRITE`, it executes
    the method. Otherwise, it throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We can have a fully fledged example of this, but we are already stretched by
    the number of topics that this book can cover. So I will leave it just here, and
    I am sure you now have enough information to make a complete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common built-in Spring expressions regarding security are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `hasRole([role_name])` | If the current user has `role_name`, it returns
    `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `hasAnyRole([role_name1, role_name2])` | If the current user has any of the
    role names in the list, it returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `hasAuthority([authority])` | If the current user has specified authority,
    it returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `hasAnyAuthority([authority1, authority2])` | If the current user has any
    of the authorities in the specified list, it returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `permitAll` | Always equates to `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `denyAll` | Always equates to `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `isAnonymous()` | If the current user is anonymous, it returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `isRememberMe()` | If the current user has set remember-me, it returns `true`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isAuthenticated()` | If the current user is not anonymous, it returns `true`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isFullyAuthenticated()` | If the current user is not anonymous or remember-me
    user, it returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `hasPermission(Object target, Object permission)` | If the current user has
    permission to target object, it returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `hasPermission(Object targetId, Object targetType, Object permission)` |
    If the current user has permission to target object, it returns `true` |'
  prefs: []
  type: TYPE_TB
- en: Other Spring Security capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security has a number of capabilities apart from core security features,
    authentication and authorization. Some of the most important ones are listed here.
    In [Chapter 7](8fd292f5-44c6-4cfb-b9cb-9a1bdb677624.xhtml), *Spring Security Add-Ons*,
    we will go through each of these in more detail using hands-on coding. We will
    build on the example that we have created in this chapter and explain each of
    these very important Spring Security capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remember-me authentication**: This is also known as persistent-login, and
    it allows websites to remember a user''s identity in between multiple sessions.
    Spring Security provides a couple of implementations (hashed-token-based and persistent-token-based)
    that make this easy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross Site Request Forgery** (**CSRF**): This is a very common security exploit
    employed by hackers to do unethical operations, whereby unauthorized commands
    are sent on behalf of the user. Spring Security allows us to fix this exploit
    easily with configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-Origin Resource Sharing** (**CORS**): This is a mechanism by which
    a web application running on a particular domain can access resources exposed
    in another domain by adding additional HTTP headers. This is one of the security
    mechanisms employed to make sure that only legitimate code can have access to
    resources exposed by a domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session management**: Proper user session management is key to any application''s
    security. Here are some of the important session-related functions that Spring
    Security takes care of easily:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session timeout**: This makes sure that user sessions time out at the configured
    value, and this cannot be hacked.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrent session**: This prevents users from having multiple (configured
    value) sessions active within the server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session fixation**: This is a security attack that allows the attacker to
    hijack a valid user''s session and then start using it for unethical operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the important features that Spring Security brings to the
    table. We will thoroughly explore them after covering additional topics that are
    relevant to Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aimed at introducing two important security concepts, namely authentication
    and authorization, and how they are supported by Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: We started by explaining these concepts in detail and then dived into them with
    the help of a sample application. We have used Spring MVC application as a base
    to help you understand Spring Security concepts. [Chapter 4](5bccc5ce-c067-46ee-a91c-02ee11dd9fc7.xhtml),
    *Authentication Using CAS and JAAS*, is aimed at explaining reactive web application
    framework, Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through other authentication mechanisms supported
    by Spring Security by extending the example that we have built in this chapter.
  prefs: []
  type: TYPE_NORMAL
