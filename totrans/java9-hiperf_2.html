<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 2. Tools for Higher Productivity and Faster Application"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch02" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Chapter 2. Tools for Higher Productivity and Faster Application</h1></div></div></div><p class="calibre11">Since the dawn of programming as a profession, the standing goals of every aspiring coder were to quickly produce applications that perform the assigned tasks with lightning speed. Otherwise, why bother? We could slowly do whatever we were doing for thousands of years. In the book of the last century, we made substantial progress in both aspects, and now, Java 9 makes another step in each of these directions.</p><p class="calibre11">Two new tools were introduced in Java 9, JShell and the <span class="emphasis"><strong class="calibre13">Ahead-of-Time</strong></span> (<span class="emphasis"><strong class="calibre13">AOT</strong></span>) compiler--both were expected for a long time. JShell is a <span class="emphasis"><strong class="calibre13">Read–Eval–Print Loop</strong></span> (<span class="emphasis"><strong class="calibre13">REPL</strong></span>) tool that is well-known for those who program in Scala, Ruby, or Python, for example. It takes a user input, evaluates it, and returns the result immediately. The AOT compiler takes Java bytecode and generates a native (system-dependent) machine code so that the resulting binary file can execute natively.</p><p class="calibre11">These tools will be the focus of this lesson.</p><div class="calibre2" title="The JShell Tool Usage"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch02lvl1sec15" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>The JShell Tool Usage</h1></div></div></div><p class="calibre11">JShell helps a programmer to test fragments (snippets) of code as they are written. It shortens the time for development by avoiding the build-deploy-test part of the development cycle. Programmers can easily copy an expression or even several methods into the JShell session and run-test-modify them multiple times immediately. Such a quick turnaround also helps to understand the library API better before using it and to tune the code to express exactly its purpose, thus facilitating better quality software.</p><p class="calibre11">How often have we guessed what the JavaDoc for a particular API meant and wasted build-deploy-test cycles for figuring it out? Or we want to recall, how exactly the string will be split by <code class="literal">substring(3)</code>? Sometimes, we create a small test application where we run the code we are not sure about, using again the same build-deploy-test cycle. With JShell, we can copy, paste, and run. In this section, we will describe and show how to do it.</p><p class="calibre11">JShell is built on the top of JVM, so it processes the code snippets exactly as JVM does. Only a few constructs that do not make sense for REPL are omitted. For example, you cannot use <code class="literal">package</code> declaration, <code class="literal">static</code>, or <code class="literal">final</code> in JShell (these keywords are going to be ignored). Also, the semicolon <code class="literal">;</code> is allowed but not required at the end of a statement.</p><p class="calibre11">JShell comes with API included in the module <code class="literal">jdk.jshell</code> which can be used for the integration of JShell into other tools (IDE, for example), but it is outside of the scope of this book.</p><div class="calibre2" title="Creating a JShell Session and Setting Context"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch02lvl2sec07" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Creating a JShell Session and Setting Context</h2></div></div></div><p class="calibre11">JShell comes with the JDK installation. You can find it in the <code class="literal">bin</code> directory as <code class="literal">$JAVA_HOME/bin/jshell</code>. Execute it to start the JShell session. Before you get familiar with JShell, we recommend starting the session with the option <code class="literal">-v</code>, which stands for <span class="emphasis"><strong class="calibre13">verbose</strong></span>. This way, the shell will add more details to each of your actions, explaining what has been accomplished with each of them. After launching <code class="literal">jshell</code> in a terminal window, you will see the following output:</p><div class="mediaobject"><img src="Images/02_01.jpg" alt="Creating a JShell Session and Setting Context" class="calibre22"/></div><p class="calibre11">This means that a JShell session is created and can be used for Java code running. Enter the recommended command <code class="literal">/help intro</code> and read the following JShell introduction:</p><div class="mediaobject"><img src="Images/02_02.jpg" alt="Creating a JShell Session and Setting Context" class="calibre23"/></div><p class="calibre11">The introduction tells us the very minimum we need to know in order to get going. So, let's follow the guide. If we enter <code class="literal">/help</code>, we get the list of possible JShell commands with a short description (we will go over every command in more detail later) and the following information:</p><div class="mediaobject"><img src="Images/02_03.jpg" alt="Creating a JShell Session and Setting Context" class="calibre24"/></div><p class="calibre11">Those are important tips to remember. Notice that the <code class="literal">/?</code> and <code class="literal">/help</code> commands produce the same result, so from now on, we will use<code class="literal">/?</code> only. The commands <code class="literal">/i</code>, <code class="literal">/&lt;id&gt;</code> (id is assigned to each snippet automatically and shown to the left of the snippet when listed by the command <code class="literal">/list</code>), and <code class="literal">/-&lt;n&gt;</code> allow re-running of the snippets that have been run previously.</p><p class="calibre11">Subject <code class="literal">intro</code> we saw already. Subject <code class="literal">shortcuts</code> can be viewed by entering the command <code class="literal">/? shortcuts</code>:</p><div class="mediaobject"><img src="Images/02_04.jpg" alt="Creating a JShell Session and Setting Context" class="calibre25"/></div><p class="calibre11">As you can see, the <span class="emphasis"><em class="calibre12">Tab</em></span> key can be used to complete the current entry, while double <span class="emphasis"><em class="calibre12">Tab</em></span> brings up possible completion options or JavaDoc, if available. Do not hesitate to press <span class="emphasis"><em class="calibre12">Tab</em></span> several times after each command. It will help you to find more ways to utilize JShell features to your advantage.</p><p class="calibre11">Press <span class="emphasis"><em class="calibre12">Shift</em></span> + <span class="emphasis"><em class="calibre12">Tab</em></span> and then press <span class="emphasis"><em class="calibre12">V</em></span> to create a variable based on the just completed expression. Here is an example:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Type <code class="literal">2*2</code> on the console and press <span class="emphasis"><em class="calibre12">Enter</em></span>.</li><li class="listitem">Press <span class="emphasis"><em class="calibre12">Shift</em></span> + <span class="emphasis"><em class="calibre12">Tab</em></span> together.</li><li class="listitem">Release the keys and press <span class="emphasis"><em class="calibre12">V</em></span>.</li><li class="listitem">The shell will show <code class="literal">int x = 2*2</code> and position the cursor just in front of <code class="literal">=</code>.</li><li class="listitem">Enter the variable (<code class="literal">x</code>, for example, and press <span class="emphasis"><em class="calibre12">Enter</em></span>). The resulting screen will show the following output:</li></ul></div><div class="mediaobject"><img src="Images/02_05.jpg" alt="Creating a JShell Session and Setting Context" class="calibre26"/></div><p class="calibre11">Press <span class="emphasis"><em class="calibre12">Shift</em></span> + <span class="emphasis"><em class="calibre12">Tab</em></span> and then press <span class="emphasis"><em class="calibre12">I</em></span> after an unresolved identifier requests JShell to provide possible imports based on the content of the classpath. Here is an example:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Type <code class="literal">new Pair</code> and press <span class="emphasis"><em class="calibre12">Enter</em></span>.</li><li class="listitem">Press <span class="emphasis"><em class="calibre12">Shift</em></span> + <span class="emphasis"><em class="calibre12">Tab</em></span> together.</li><li class="listitem">Release the keys and press <span class="emphasis"><em class="calibre12">I</em></span>. The shell will show the following output:<div class="mediaobject1"><img src="Images/02_06.jpg" alt="Creating a JShell Session and Setting Context" class="calibre27"/></div></li><li class="listitem">You will get two options with the values <code class="literal">0</code> and <code class="literal">1</code>, respectively.</li><li class="listitem">In the shell, you will get a statement called <code class="literal">Choice</code>; type <span class="emphasis"><em class="calibre12">1</em></span> and press <span class="emphasis"><em class="calibre12">Enter</em></span>.</li><li class="listitem">Now, the <code class="literal">javafx.util.Pair</code> class is imported.</li><li class="listitem">You can continue entering the code snippet.</li></ul></div><p class="calibre11">JShell was able to provide the suggestion because the JAR file with the compiled <code class="literal">Pair</code> class was on the classpath (set there by default as part of JDK libraries). You can also add to the classpath any other JAR file with the compiled classes you need for your coding. You can do it by setting it at JShell startup by the option <code class="literal">--class-path</code> (can be also used with one dash <code class="literal">-class-path</code>):</p><div class="mediaobject"><img src="Images/02_07.jpg" alt="Creating a JShell Session and Setting Context" class="calibre28"/></div><p class="calibre11">In the earlier example, the JAR file <code class="literal">myclasses.jar</code> is loaded from the folder <code class="literal">mylibrary</code> in the user's home directory. To set several JAR files, you can separate them by a colon<code class="literal">:</code> (for Linux and MacOS) or by a semicolon <code class="literal">;</code> (for Windows).</p><p class="calibre11">The classpath can also be set by the command <code class="literal">/env</code> any time during the JShell session:</p><div class="mediaobject"><img src="Images/02_08.jpg" alt="Creating a JShell Session and Setting Context" class="calibre29"/></div><p class="calibre11">Notice that every time the classpath is set, all the snippets of the current session are reloaded with the new classpath.</p><p class="calibre11">The commands <code class="literal">/reset</code> and <code class="literal">/reload</code> can be used instead of the <code class="literal">/env</code> command to set the classpath too. We will describe the difference between these commands in the next section.</p><p class="calibre11">If you do not want to collect your compiled classes in a JAR file, the option <code class="literal">--class-path</code> (or <code class="literal">-class-path</code>) could point to the directory where the compiled classes are located. Once the classpath is set, the classes associated with it can be imported during a snippet writing using keys <span class="emphasis"><em class="calibre12">Shift</em></span> + <span class="emphasis"><em class="calibre12">Tab</em></span> and then <span class="emphasis"><em class="calibre12">I</em></span> as described earlier.</p><p class="calibre11">Other context options are related to the usage of modules and can be seen after entering the command <code class="literal">/? context</code>:</p><div class="mediaobject"><img src="Images/02_09.jpg" alt="Creating a JShell Session and Setting Context" class="calibre30"/></div><p class="calibre11">There are several more advanced options of running the <code class="literal">jshell</code> tool. To learn about them, refer to the Oracle documentation (for example, <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="https://docs.oracle.com/javase/9/tools/jshell.htm">https://docs.oracle.com/javase/9/tools/jshell.htm</a>).</p><p class="calibre11">The last important command we would like to mention in this section is <code class="literal">/exit</code>. It allows exiting the command mode and closing the JShell session.</p></div><div class="calibre2" title="JShell Commands"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch02lvl2sec08" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>JShell Commands</h2></div></div></div><p class="calibre11">As we mentioned in the previous section, the full list of JShell commands can be obtained by typing the <code class="literal">/?</code> command. Each command comes with a one-line description. There is another way to get the same list but without description, that is by typing <code class="literal">/</code> followed by <span class="emphasis"><em class="calibre12">Tab</em></span>. The screen would show the following content:</p><div class="mediaobject"><img src="Images/02_10.jpg" alt="JShell Commands" class="calibre31"/></div><p class="calibre11">Pressing <span class="emphasis"><em class="calibre12">Tab</em></span> the second time would bring the same list of the commands with a synopsis (one-line description) for each. To make it easier for a user, while typing, a command, subcommand, command argument, or command option can be abbreviated, as long as it remains unique so that the tool can recognize it unambiguously. For example, instead of the previous list of full-name commands, you can use the corresponding list of their abbreviated versions: <code class="literal">/!</code>, <code class="literal">/?</code>, <code class="literal">/d</code>, <code class="literal">/ed</code>, <code class="literal">/en</code>, <code class="literal">/ex</code>, <code class="literal">/he</code>, <code class="literal">/hi</code>, <code class="literal">/i</code>, <code class="literal">/l</code>, <code class="literal">/m</code>, <code class="literal">/o</code>, <code class="literal">/rel</code>, <code class="literal">/res</code>, <code class="literal">/sa</code>, <code class="literal">/se</code>, <code class="literal">/t</code>, <code class="literal">/v</code>. The preceding dash <code class="literal">/</code> is necessary for distinguishing commands from snippets.</p><p class="calibre11">Now, let's review each of these commands. While doing it, we will create a few snippets, variables, and types so that we can demonstrate each command more clearly using specific examples.</p><p class="calibre11">You can start a new JShell session by running <code class="literal">jshell</code> (with option <code class="literal">-v</code>) and enter the following commands:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">/en</code>: To view or change the evaluation context</li><li class="listitem"><code class="literal">/h</code>: To view history of what you have typed</li><li class="listitem"><code class="literal">/l [&lt;name or id&gt;|-all|-start]</code>: To list the source you have typed</li><li class="listitem"><code class="literal">/m [&lt;name or id&gt;|-all|-start]L</code>: To list the declared methods and their signatures</li><li class="listitem"><code class="literal">/t [&lt;name or id&gt;|-all|-start]</code>: To list the declared types</li><li class="listitem"><code class="literal">/v [&lt;name or id&gt;|-all|-start]</code>: To list the declared variables and their values</li></ul></div><p class="calibre11">The result would be like this:</p><div class="mediaobject"><img src="Images/02_11.jpg" alt="JShell Commands" class="calibre32"/></div><p class="calibre11">As you might be expecting, most of these commands yielded no results (except a short history of your typing until that moment) because we have not entered any code snippet yet. The last four commands have the same options:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">&lt;name or id&gt;</code>: This is the name or ID of a specific snippet or method or type or variable (we will see examples later)</li><li class="listitem"><code class="literal">-start</code>: This shows snippets or methods or types or variables loaded at the JShell start (we will see later how to do it)</li><li class="listitem"><code class="literal">-all</code>: This shows snippets or methods or types or variables loaded at the JShell start and entered later during the session</li></ul></div><p class="calibre11">By default, at the startup, several common packages are imported. You can see them by typing the <code class="literal">/l -start</code> or <code class="literal">/l -all</code> command:</p><div class="mediaobject"><img src="Images/02_12.jpg" alt="JShell Commands" class="calibre33"/></div><p class="calibre11">There is no <code class="literal">java.lang</code> package in this list, but it is always imported by default and not listed among the imports.</p><p class="calibre11">In the left column of the previously mentioned list, you can see the ID of each snippet. If you type the <code class="literal">/l s5</code>command, for example, it will retrieve the snippet with ID <code class="literal">s5</code>:</p><div class="mediaobject"><img src="Images/02_13.jpg" alt="JShell Commands" class="calibre34"/></div><p class="calibre11">To customize the startup entries, you can use the command <code class="literal">/sa &lt;file&gt;</code> to save in the specified file all the settings and snippets you have entered in the current session. The next time you would like to continue with the same context, you can start the JShell session with this file <code class="literal">jshell &lt;file&gt;</code>.</p><p class="calibre11">Let's demonstrate this procedure with an example:</p><div class="mediaobject"><img src="Images/02_14.jpg" alt="JShell Commands" class="calibre35"/></div><p class="calibre11">In the previous screenshot, you can see that we have started a JShell session and entered the name of the class <code class="literal">Pair</code> (not imported yet), then pressed <span class="emphasis"><em class="calibre12">Shift</em></span> + <span class="emphasis"><em class="calibre12">Tab</em></span> and <span class="emphasis"><em class="calibre12">I</em></span> and selected option <code class="literal">1</code> (to import the class <code class="literal">Pair</code>). After that, we have finished typing the snippet (created a variable <code class="literal">pair</code>), saved the session entries in the file <code class="literal">mysession.jsh</code> (in the home directory), and closed the session. Let's look in the file <code class="literal">mysession.jsh</code> now:</p><div class="mediaobject"><img src="Images/02_15.jpg" alt="JShell Commands" class="calibre36"/></div><p class="calibre11">As you can see, the file contains only the new entries from the saved session. If we would like to load them into the next session, we will use the command <code class="literal">jshell ~/mysession.jsh</code> and continue working in the same context:</p><div class="mediaobject"><img src="Images/02_16.jpg" alt="JShell Commands" class="calibre37"/></div><p class="calibre11">In the previous screenshot, we started a new session, listed all the new entries (reloaded from the previous session), and got a key from the object <code class="literal">pair</code>. This has created variable <code class="literal">$3</code> automatically.</p><p class="calibre11">We can also create a variable explicitly. Type <code class="literal">pair.getValue()</code> and press <span class="emphasis"><em class="calibre12">Shift</em></span> + <span class="emphasis"><em class="calibre12">Tab</em></span> and then press <span class="emphasis"><em class="calibre12">V</em></span>, which will prompt you to enter the variable name just in front of the sign <code class="literal">String = pair.getValue()</code>. Enter <code class="literal">value</code> and see the result:</p><div class="mediaobject"><img src="Images/02_17.jpg" alt="JShell Commands" class="calibre38"/></div><p class="calibre11">To see all the variables of the current session, type the command <code class="literal">/v</code>:</p><div class="mediaobject"><img src="Images/02_18.jpg" alt="JShell Commands" class="calibre39"/></div><p class="calibre11">Let's now create a method <code class="literal">to2()</code> that multiplies any integer by 2:</p><div class="mediaobject"><img src="Images/02_19.jpg" alt="JShell Commands" class="calibre40"/></div><p class="calibre11">To complete the demonstration of the commands <code class="literal">/l</code>, <code class="literal">/m</code>, <code class="literal">/t</code>, and <code class="literal">/v</code>, let's create a new type:</p><div class="mediaobject"><img src="Images/02_20.jpg" alt="JShell Commands" class="calibre41"/></div><p class="calibre11">Notice that the method <code class="literal">to2()</code> is visible inside a new class, which means that all standalone variables, standalone methods, and code inside classes are executed in the same context. This way, testing of a code fragment becomes easier but may introduce subtle errors and even unexpected behavior if the code's author relies on the encapsulation and behavior isolation in different parts of a more complex system than just a flat code fragment.</p><p class="calibre11">Now, by using the <code class="literal">/l</code> command, we can see everything we have typed:</p><div class="mediaobject"><img src="Images/02_21.jpg" alt="JShell Commands" class="calibre42"/></div><p class="calibre11">All these snippets are available for execution. Here is one example of using them:</p><div class="mediaobject"><img src="Images/02_22.jpg" alt="JShell Commands" class="calibre43"/></div><p class="calibre11">In the previous screenshot, we typed <code class="literal">new Demo</code> and pressed <span class="emphasis"><em class="calibre12">Tab</em></span>. Then, we entered <span class="emphasis"><em class="calibre12">2</em></span> and pressed <span class="emphasis"><em class="calibre12">Tab</em></span> again. We saw the suggestion about pressing <span class="emphasis"><em class="calibre12">Tab</em></span> to see documentation and did it. Well, there was no documentation found (we did not type any JavaDoc while creating the class <code class="literal">DemoClass</code>), so we just added <code class="literal">)</code> and pressed <span class="emphasis"><em class="calibre12">Enter</em></span>. As a result, a new variable <code class="literal">$7</code> was created that held references to the object of the class <code class="literal">DemoClass</code>. We can use this variable now like this, for example:</p><div class="mediaobject"><img src="Images/02_23.jpg" alt="JShell Commands" class="calibre44"/></div><p class="calibre11">In the previous screenshot, we entered <code class="literal">int y = $7.</code> and pressed <span class="emphasis"><em class="calibre12">Tab</em></span>, then pressed <span class="emphasis"><em class="calibre12">Tab</em></span> the second time to see other options. We did it just for demo purposes. Then, we made our selection by typing <code class="literal">getX</code> after <code class="literal">.</code> and pressing <code class="literal">Tab</code>. JShell completed the statement with <code class="literal">()</code> for us and we pressed <span class="emphasis"><em class="calibre12">Enter</em></span>, thus creating a new variable <code class="literal">y</code> (with the current evaluated value of <code class="literal">4</code>).</p><p class="calibre11">Finally, let's try and test the function <code class="literal">substring()</code> to make sure it returns us the substring we need:</p><div class="mediaobject"><img src="Images/02_24.jpg" alt="JShell Commands" class="calibre45"/></div><p class="calibre11">We hope you now have a feel of how you can create and execute snippets.</p><p class="calibre11">Let's review other JShell commands. The command <code class="literal">/i</code> lists the imported packages and classes. In our case, if we use this command we will get the following output:</p><div class="mediaobject"><img src="Images/02_25.jpg" alt="JShell Commands" class="calibre46"/></div><p class="calibre11">You can see that the class <code class="literal">Pair</code> is listed as imported, although we have done it in the previous JShell session and brought it in the new session by using the file <code class="literal">~/mysession.jsh</code>.</p><p class="calibre11">The command <code class="literal">/ed &lt;name or id&gt;</code> allows you to edit any of the entries listed by the command <code class="literal">/l</code>. Let's do it:</p><div class="mediaobject"><img src="Images/02_26.jpg" alt="JShell Commands" class="calibre47"/></div><p class="calibre11">In the previous screenshot, we listed all the snippets and entered <code class="literal">/e 7</code> to edit snippets with ID <code class="literal">7</code>. It turned out that there are several commands starting with <code class="literal">e</code>, so we added <code class="literal">d</code> and got the following editor window:</p><div class="mediaobject"><img src="Images/02_27.jpg" alt="JShell Commands" class="calibre48"/></div><p class="calibre11">In the previous window, we changed <code class="literal">2</code> to <code class="literal">3</code> and clicked the <span class="emphasis"><strong class="calibre13">Accept</strong></span> button. As a result, a new variable <code class="literal">$9</code>was created that holds the reference to the new <code class="literal">DemoClass</code> object. We can now use this new variable too:</p><div class="mediaobject"><img src="Images/02_28.jpg" alt="JShell Commands" class="calibre49"/></div><p class="calibre11">In the previous screenshot, we entered <code class="literal">$9.getX</code> and pressed <span class="emphasis"><em class="calibre12">Tab</em></span>. The JShell completed the statement by adding <code class="literal">()</code>. We press <span class="emphasis"><em class="calibre12">Enter</em></span>, and the new variable <code class="literal">$10</code> (with the current evaluated value <code class="literal">6</code>) was created.</p><p class="calibre11">The command <code class="literal">/d &lt;name or id&gt;</code> drops a snippet referenced by name or ID. Let's use it to delete a snippet with ID <code class="literal">7</code>:</p><div class="mediaobject"><img src="Images/02_29.jpg" alt="JShell Commands" class="calibre50"/></div><p class="calibre11">As you could guess, the expression that assigns a value to the variable <code class="literal">8</code> now cannot be evaluated:</p><div class="mediaobject"><img src="Images/02_30.jpg" alt="JShell Commands" class="calibre51"/></div><p class="calibre11">In the earlier screenshot, we first requested to evaluate the expression that generates a value for variable <code class="literal">10</code> (for demonstration purposes), and it was correctly calculated as <code class="literal">6</code>. Then, we attempted to do the same for variable <code class="literal">8</code> and received an error because its expression was broken after deleting the variable <code class="literal">7</code>. So, we have deleted it now, too (this time by name, to demonstrate how a name can be used).</p><p class="calibre11">The command <code class="literal">/sa [-all|-history|-start] &lt;file&gt;</code> saves a snippet to a file. It is complemented by the command <code class="literal">/o &lt;file&gt;</code> that opens the file as the source input.</p><p class="calibre11">The commands <code class="literal">/en</code>, <code class="literal">/res</code>, and <code class="literal">/rel</code> have an overlapping functionality:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">/en [options]</code>: This allows to view or change the evaluation context</li><li class="listitem"><code class="literal">/res [options]</code>: This discards all entered snippets and restarts the session</li><li class="listitem"><code class="literal">/rel[options]</code>: This reloads the session the same way the command <code class="literal">/en</code> does</li></ul></div><p class="calibre11">See the official Oracle documentation (<a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://docs.oracle.com/javase/9/tools/jshell.htm">http://docs.oracle.com/javase/9/tools/jshell.htm</a>) for more details and possible options.</p><p class="calibre11">The command <code class="literal">[/se [setting]</code> sets configuration information, including the external editor, startup settings, and feedback mode. This command is also used to create a custom feedback mode with customized prompt, format, and truncation values. If no setting is entered, then the current setting for the editor, startup settings, and feedback mode are displayed. The documentation referred to earlier describes all possible settings in all details.</p><p class="calibre11">The JShell is going to be even more helpful when integrated inside of the IDE so that a programmer can evaluate expressions on the fly or, even better, they can be evaluated automatically the same way the compiler today evaluates the syntax.</p></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Ahead-of-Time (AOT)"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch02lvl1sec16" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Ahead-of-Time (AOT)</h1></div></div></div><p class="calibre11">The big claim of Java was write-once-run-anywhere. It was achieved by creating an implementation of <span class="emphasis"><strong class="calibre13">Java Runtime Environment</strong></span> (<span class="emphasis"><strong class="calibre13">JRE</strong></span>) for practically all platforms, so the bytecode generated once from the source by Java compiler (<code class="literal">javac</code> tool) could be executed everywhere where JRE was installed, provided the version of the compiler <code class="literal">javac</code> was compatible with the version of JRE.</p><p class="calibre11">The first releases of JRE were primarily the interpreters of the bytecode and yielded slower performance than some other languages and their compilers, such as C and C++. However, over time, JRE was improved substantially and now produces quite decent results, on a par with many other popular systems. In big part, it is due to the JIT dynamic compiler that converts the bytecodes of the most frequently used methods to the native code. Once generated, the compiled methods (the platform-specific machine code) is executed as needed without any interpretation, thus decreasing the execution time.</p><p class="calibre11">To utilize this approach, JRE needs some time for figuring out which methods of the application are used most often. The people working in this area of programming call them hot methods. This period of discovery, until the peak performance is reached, is often called a JVM's warm-up time. It is bigger for the larger and more complex Java applications and can be just a few seconds for smaller ones. However, even after the peak performance is reached, the application might, because of the particular input, start utilizing an execution path never used before and calling the methods that were not compiled yet, thus suddenly degrading the performance. It can be especially consequential when the code not compiled yet belongs to the complex procedures invoked in some rare critical situations, exactly when the best possible performance is needed.</p><p class="calibre11">The natural solution was to allow the programmer to decide which components of the application have to be precompiled into the native machine code--those that are more often used (thus decreasing the application's warm-up time), and those that are used not often but have to be executed as quickly as possible (in support of the critical situations and stable performance overall). That was the motivation of the <span class="emphasis"><strong class="calibre13">Java Enhancement ProposalJEP 295: Ahead-of-Time Compilation</strong></span>:</p><p class="calibre11">JIT compilers are fast, but Java programs can become so large that it takes a long time for the JIT to warm up completely. Infrequently used Java methods might never be compiled at all, potentially incurring a performance penalty due to repeated interpreted invocations.</p><p class="calibre11">It is worth noticing though that already in JIT compiler, it is possible to decrease the warm-up time by setting the compilation threshold--how many times a method has to be called before it gets compiled into the native code. By default, the number is 1,500. So, if we set it to less than that, the warm-up time will be shorter. It can be done using the option <code class="literal">-XX:CompileThreshold</code> with the <code class="literal">java</code> tool. For example, we can set the threshold to 500 as follows (where <code class="literal">Test</code> is the compiled Java class with the <code class="literal">main()</code> method in it):</p><div class="calibre2"><pre class="programlisting">java -XX:CompileThreshold=500 -XX:-TieredCompilation Test</pre></div><p class="calibre11">The option <code class="literal">-XX:-TieredCompilation</code> was added to disable the tiered compilation because it is enabled by default and does not honor the compilation threshold. The possible drawback is that the 500 threshold might be too low and too many methods will be compiled, thus slowing down the performance and increasing the warm-up time. The best value for this option will vary from application to an application and may even depend on the particular data input with the same application.</p><div class="calibre2" title="Static versus Dynamic Compilation"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch02lvl2sec09" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Static versus Dynamic Compilation</h2></div></div></div><p class="calibre11">Many higher level programming languages such as C or C++ used AOT compilation from the very beginning. They are also called <span class="emphasis"><strong class="calibre13">statically compiled</strong></span> languages. Since AOT (or static) compilers are not constrained by performance requirements (at least not as much as the interpreters at runtime, also called <span class="emphasis"><strong class="calibre13">dynamic compilers</strong></span>), they can afford to spend the time producing complex code optimizations. On the other hand, the static compilers do not have the runtime (profiling) data, which is especially limiting in the case of dynamically typed languages, Java being one of them. Since the ability of dynamic typing in Java--downcasting to the subtype, querying an object for its type, and other type operations--is one of the pillars of object-oriented programming (principle of polymorphism), AOT compilation for Java becomes even more limited. Lambda expressions pause another challenge for static compilation and are currently not supported yet.</p><p class="calibre11">Another advantage of a dynamic compiler is that it can make assumptions and optimize the code accordingly. If the assumption turned out to be wrong, the compiler can try another assumption until the performance goal is achieved. Such a procedure may slow down the application and/or increase the warm-up time, but it may result in a much better performance in the long run. The profile-guided optimization can help a static compiler to move along this path too, but it will always remain limited in its opportunity to optimize by comparison with a dynamic one.</p><p class="calibre11">That said, we should not be surprised that the current AOT implementation in JDK 9 is experimental and limited, so far, to 64-bit Linux-based systems only, with both Parallel or G1 garbage collection and the only supported module being <code class="literal">java.base</code>. Further, AOT compilation should be executed on the same system or a system with the same configuration on which the resulting machine code will be executed. Yet, despite all that, the JEP 295 states:</p><p class="calibre11">Performance testing shows that some applications benefit from AOT-compiled code, while others clearly show regressions.</p><p class="calibre11">It is worth noting that AOT compilation has been long supported in <span class="emphasis"><strong class="calibre13">Java Micro Edition</strong></span> (<span class="emphasis"><strong class="calibre13">ME</strong></span>), but more use cases for AOT in <span class="emphasis"><strong class="calibre13">Java Standard Edition</strong></span> (<span class="emphasis"><strong class="calibre13">SE</strong></span>) are yet to be identified, which was one of the reasons the experimental AOT implementation was released with JDK 9-- in order to facilitate the community to try and tell about the practical needs.</p></div><div class="calibre2" title="The AOT Commands and Procedures"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch02lvl2sec10" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>The AOT Commands and Procedures</h2></div></div></div><p class="calibre11">The underlying AOT compilation in JDK 9 is based on the Oracle project <code class="literal">Graal</code>--an open source compiler introduced with JDK 8 with a goal of improving the performance of the Java dynamic compiler. The AOT group had to modify it, mostly around constants processing and optimization. They have also added probabilistic profiling and a special inlining policy, thus making Grall more suitable for static compilation.</p><p class="calibre11">In addition to the existing compiling tool <code class="literal">javac</code>, a new <code class="literal">jaotc</code> tool is included in the JDK 9 installation. The resulting AOT shared libraries <code class="literal">.so</code> are generated using the <code class="literal">libelf</code> library--the dependency that is going to be removed in the future releases.</p><p class="calibre11">To start AOT compilation, a user has to launch <code class="literal">jaotc</code> and specify classes, JAR files, or modules that have to be compiled. The name of the output library (that holds the generated machine code) can also be passed as the <code class="literal">jaotc</code> parameter. If not specified, the default name of the output will be <code class="literal">unnamed.so</code>. As an example, let's look at how the AOT compiler can work with the class <code class="literal">HelloWorld</code>:</p><div class="calibre2"><pre class="programlisting">public class HelloWorld {
   public static void main(String... args) {
       System.out.println("Hello, World!");
   }
}</pre></div><p class="calibre11">First, we will generate the bytecode and produce <code class="literal">HelloWorld.class</code> using <code class="literal">javac</code>:</p><div class="calibre2"><pre class="programlisting">javac HelloWorld.java</pre></div><p class="calibre11">Then, we will use the bytecode from the file <code class="literal">HelloWorld.class</code> to generate machine code into the library <code class="literal">libHelloWorld.so</code>:</p><div class="calibre2"><pre class="programlisting">jaotc --output libHelloWorld.so HelloWorld.class</pre></div><p class="calibre11">Now, we can execute the generated library (on the platform with the same specification as the one where <code class="literal">jaotc</code>was executed) using the <code class="literal">java</code> tool with an option <code class="literal">-XX:AOTLibrary</code>:</p><div class="calibre2"><pre class="programlisting">java -XX:AOTLibrary=./libHelloWorld.so HelloWorld</pre></div><p class="calibre11">The option <code class="literal">-XX:AOTLibrary</code> allows us to list several AOT libraries separated by commas.</p><p class="calibre11">Notice that the <code class="literal">java</code> tool requires bytecode of all the applications in addition to the native code of some of its components. This fact diminishes the alleged advantage of static compilation, which some AOT enthusiasts claim, that it protects code better from being decompiled. It might be so in the future when bytecode will not be required at runtime if the same class or method is in the AOT library already. However, as of today, it is not the case.</p><p class="calibre11">To see if AOT-compiled methods were used, you can add an option <code class="literal">-XX:+PrintAOT</code>:</p><div class="calibre2"><pre class="programlisting">java -XX:AOTLibrary=./libHelloWorld.so -XX:+PrintAOT HelloWorld</pre></div><p class="calibre11">It will allow you to see the line loaded <code class="literal">./libHelloWorld.so</code> AOT library in the output.</p><p class="calibre11">If the source code of a class was changed but not pushed (through the <code class="literal">jaotc</code> tool) into the AOT library, JVM will notice it at runtime because the fingerprint of each compiled class is stored with its native code in the AOT library. JIT will then ignore the code in the AOT library and use the bytecode instead.</p><p class="calibre11">The <code class="literal">java</code> tool in JDK 9 supports a few other flags and options related to AOT:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">-XX:+/-UseAOT</code> tells the JVM to use or to ignore AOT-compiled files (by default, it is set to use AOT)</li><li class="listitem"><code class="literal">-XX:+/-UseAOTStrictLoading</code> turns on/off the AOT strict loading; if on, it directs JVM to exit if any of the AOT libraries were generated on a platform with a configuration different from the current runtime configuration</li></ul></div><p class="calibre11">The JEP 295 describes the <code class="literal">jaotc</code> tool's command format as follows:</p><div class="calibre2"><pre class="programlisting">jaotc &lt;options&gt; &lt;name or list&gt;</pre></div><p class="calibre11">The <code class="literal">name</code> is a class name or JAR file. The <code class="literal">list</code> is a colon <code class="literal">:</code> separated list of class names, modules, JAR files, or directories that contain class files. The <code class="literal">options</code> is one or many flags from the following list:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">--output &lt;file&gt;</code>: This is the output file name (by default, <code class="literal">unnamed.so</code>)</li><li class="listitem"><code class="literal">--class-name &lt;class names&gt;</code>: This is the list of Java classes to compile</li><li class="listitem"><code class="literal">--jar &lt;jar files&gt;</code>: This is the list of JAR files to compile</li><li class="listitem"><code class="literal">--module &lt;modules&gt;</code>: This is the list of Java modules to compile</li><li class="listitem"><code class="literal">--directory &lt;dirs&gt;</code>: This is the list of directories where you can search for files to compile</li><li class="listitem"><code class="literal">--search-path &lt;dirs&gt;</code>: This is the list of directories where to search for specified files</li><li class="listitem"><code class="literal">--compile-commands &lt;file&gt;</code>: This is the name of the file with compile commands; here is an example:<div class="calibre2"><pre class="programlisting1">
<span class="emphasis"><strong class="calibre13">exclude sun.util.resources..*.TimeZoneNames_.*.getContents\(\)\[\[Ljava/lang/Object;</strong></span>
<span class="emphasis"><strong class="calibre13">exclude sun.security.ssl.*</strong></span>
<span class="emphasis"><strong class="calibre13">compileOnly java.lang.String.*</strong></span>
</pre></div></li></ul></div><p class="calibre11">AOT recognizes two compile commands currently:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">exclude</code>: This excludes the compilation of specified methods</li><li class="listitem"><code class="literal">compileOnly</code>: This compiles only specified methods</li></ul></div><p class="calibre11">Regular expressions are used to specify classes and methods, which are mentioned here:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">--compile-for-tiered</code>: This generates profiling code for tiered compilation (by default, profiling code is not generated)</li><li class="listitem"><code class="literal">--compile-with-assertions</code>: This generates code with Java assertions (by default, assertions code is not generated)</li><li class="listitem"><code class="literal">--compile-threads &lt;number&gt;</code>: This is the number of compilation threads to be used (by default, the smaller value of 16 and number of available CPUs)</li><li class="listitem"><code class="literal">--ignore-errors</code>: This ignores all exceptions thrown during class loading (by default, exits on compilation if class loading throws an exception)</li><li class="listitem"><code class="literal">--exit-on-error</code>: This exits on compilation errors (by default, failed compilation is skipped, while the compilation of other methods continues)</li><li class="listitem"><code class="literal">--info</code>: This prints information about compilation phases</li><li class="listitem"><code class="literal">--verbose</code>: This prints more details about compilation phases</li><li class="listitem"><code class="literal">--debug</code>: This prints even more details</li><li class="listitem"><code class="literal">--help</code>: This prints help information</li><li class="listitem"><code class="literal">--version</code>: This prints version information</li><li class="listitem"><code class="literal">-J&lt;flag&gt;</code>: This passes a flag directly to the JVM runtime system</li></ul></div><p class="calibre11">As we mentioned already, some applications can improve performance using AOT, while others may become slower. Only testing will provide a definite answer to the question about the usefulness of AOT for each application. In any case, one of the ways to improve performance is to compile and use the AOT library of the <code class="literal">java.base</code> module:</p><div class="calibre2"><pre class="programlisting">jaotc --output libjava.base.so --module java.base</pre></div><p class="calibre11">At runtime, the AOT initialization code looks for shared libraries in the <code class="literal">$JAVA_HOME/lib</code> directory or among the libraries listed by the <code class="literal">-XX:AOTLibrary</code> option. If shared libraries are found, they are picked up and used. If no shared libraries can be found, AOT will be turned off.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Summary"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch02lvl1sec17" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Summary</h1></div></div></div><p class="calibre11">In this lesson, we described two new tools that can help a developer be more productive (JShell tool) and help improve Java application performance (<code class="literal">jaotc</code> tool). The examples and steps to use them will help you understand the benefits of their usage and get you started in case you decide to try them.</p><p class="calibre11">In the next lesson, we will discuss how to monitor Java applications programmatically using command-line tools. We will also explore how to improve the application performance via multithreading and how to tune the JVM itself after learning about the bottlenecks through monitoring.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Assessments"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch02lvl1sec18" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Assessments</h1></div></div></div><div class="calibre2"><ol class="orderedlist"><li class="listitem1">The ________ compiler takes Java bytecode and generates a native machine code so that the resulting binary file can execute natively.</li><li class="listitem1">Which of the following commands drops a snippet referenced by a name or on ID?<div class="calibre2"><ol class="orderedlist1"><li class="listitem1"><code class="literal">/d &lt;name or id&gt;</code></li><li class="listitem1"><code class="literal">/drop &lt;name or id&gt;</code></li><li class="listitem1"><code class="literal">/dr &lt;name or id&gt;</code></li><li class="listitem1"><code class="literal">/dp &lt;name or id&gt;</code></li></ol></div></li><li class="listitem1">State whether True or False: Shell is Ahead-of-Time tool that is well-known for those who program in Scala, Ruby. It takes a user input, evaluates it, and returns the result after sometime.</li><li class="listitem1">Which of the following commands is used to list the source you have typed in JShell?<div class="calibre2"><ol class="orderedlist1"><li class="listitem1"><code class="literal">/l [&lt;name or id&gt;|-all|-start]</code></li><li class="listitem1"><code class="literal">/m [&lt;name or id&gt;|-all|-start]L</code></li><li class="listitem1"><code class="literal">/t [&lt;name or id&gt;|-all|-start]</code></li><li class="listitem1"><code class="literal">/v [&lt;name or id&gt;|-all|-start]</code></li></ol></div></li><li class="listitem1">Which of the following regular expressions ignores all exceptions thrown during class loading?<div class="calibre2"><ol class="orderedlist1"><li class="listitem1"><code class="literal">--exit-on-error</code></li><li class="listitem1"><code class="literal">–ignores-errors</code></li><li class="listitem1"><code class="literal">--ignore-errors</code></li><li class="listitem1"><code class="literal">--exits-on-error</code></li></ol></div></li></ol></div></div></div>



  </body></html>