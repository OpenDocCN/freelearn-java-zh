["```java\nclass MethodDefinition {\n  def eq(arg1: String, arg2: Int): Boolean = ! nonEqual(arg1, arg2)\n  private def nonEq(a: String, b: Int) = a != b.toString\n}\n```", "```java\ndef defaultValues(a: String = \"default\")(b: Int = 0, c: String = a)(implicit d: Long = b, e: String = a) = ???\n```", "```java\nscala> def byName(int: => Int) = {\n     | println(int)\n     | println(int)\n     | }\nbyName: (int: => Int)Unit\nscala> byName({ println(\"Calculating\"); 10 * 2 })\nCalculating\n20\nCalculating\n20\n```", "```java\ndef variable(a: String, b: Int*): Unit = {\n  val bs: collection.Seq[Int] = b\n}\n\nvariable(\"vararg\", 1, 2, 3)\nvariable(\"Seq\", Seq(1, 2, 3): _*)\n```", "```java\ndef named(first: Int, second: String, third: Boolean) = s\"$first, $second, $third\"\n\nnamed(third = false, first = 10, second = \"Nice\")\nnamed(10, third = true, second = \"Cool\")\n```", "```java\ndef average(in: Int*): Int = {\n def sum(in: Int*): Int = in.sum\n def count(in: Int*): Int = in.size\n sum(in:_*)/count(in:_*)\n}\n```", "```java\nscala> :type sum\n       ^\n       error: not found: value sum\n\nscala> :type count\n       ^\n       error: not found: value count\n```", "```java\nval items = Seq(1,2,3,4,5)\nval avg = average(items:_*)\n```", "```java\nval items = Seq(1,2,3,4,5)\nval avg = {\n  def sum(in: Int*): Int = in.sum\n  def count(in: Int*): Int = in.size\n  sum(items:_*)/count(items:_*)\n}\n```", "```java\ndef averageNoPassing(in: Int*): Int = {\n  def sum: Int = in.sum\n  def count: Int = in.size\n  sum /count\n}\n```", "```java\nscala> def outerA = {\n     | val free = 5\n     | def innerA = {\n     | val free = 20\n     | def closure(in: Int) = free + in\n     | closure(10)\n     | }\n     | innerA + free\n     | }\nouterA: Int\n\nscala> outerA\nres3: Int = 35\n```", "```java\nscala> def noReference(in: Int) = {\n     | def closure(input: Int) = input + free + in\n     | }\n           def closure(input: Int) = input + free + in\n                                             ^\nOn line 2: error: not found: value free\n\nscala> def forwardReference(in: Int) = {\n     | def closure(input: Int) = input + free + in\n     | val free = 30\n     | }\n           def closure(input: Int) = input + free + in\n                                             ^\nOn line 2: error: forward reference extends over definition of value free\n```", "```java\nscala> object Functions {\n     |   def method(name: String) = {\n     |     def function(in1: Int, in2: String): String = name + in2\n     |     function\n     |   }\n     |   val function = method(\"name\")\n     | }\n           function\n           ^\nOn line 4: error: missing argument list for method function\n       Unapplied methods are only converted to functions when a function type is expected.\n       You can make this conversion explicit by writing `function _` or `function(_,_)` instead of `function`.\n```", "```java\nscala> object Functions {\n     | def method(name: String) = {\n     | def function(in1: Int, in2: String): String = name + in2\n     | function _\n     | }\n     | val function = method(\"name\")\n     | }\ndefined object Functions\n```", "```java\nval next = Math.nextAfter _\nnext(10f, 20f)\nval /\\ = Math.hypot(_, _)\n/\\ (10 , 20)\n```", "```java\ndef four(one: String, two: Int, three: Boolean, four: Long) = ()\nval applyTwo = four(\"one\", _: Int, true, _: Long)\n```", "```java\nscala> :type Functions.applyTwo\n(Int, Long) => Unit\n```", "```java\nval hash: (Int, Boolean, String, Long) => Int = (a, b, c, d) => {\n  val ab = 31 * a.hashCode() + b.hashCode()\n  val abc = 31 * ab + c.hashCode\n  31 * abc + d.hashCode()\n}\n```", "```java\nval hashInferred = (a: Int, b: Boolean, c: String, d: Long) =>\n  // ... same implementation as before\n```", "```java\ndef printHash(hasher: String => Int)(s: String): Unit = \n  println(hasher(s))\n```", "```java\nval hasher1: String => Int = s => s.hashCode\nval hasher2 = (s: String) => s.hashCode\nprintHash(hasher1)(\"Full\")\nprintHash(hasher2)(\"Inferred result type\")\n\n```", "```java\nscala> val hashPlaceholder = \n(_: Int) * 31^4 + (_: Int) * 31^3 + (_: Int) * 31^2 + (_: Int) * 31\n\nscala> :type hashPlaceholder\n(Int, Int, Int, Int) => Int\n\n```", "```java\ndef sum(a: Int, b: Int) = a + b\n```", "```java\ndef sumAB(a: Int)(b: Int) = a + b\n```", "```java\n:type sumAB _\nInt => (Int => Int)\n```", "```java\nscala> val sum6 = (a: Int) => (b: Int) => (c: Int) => (d: Int) => (e: Int) => (f: Int) => a + b + c + d+ e + f\nsum6: Int => (Int => (Int => (Int => (Int => (Int => Int)))))\n```", "```java\nscala> val sum6Placeholder = (_: Int) + (_: Int) + (_: Int) + (_: Int) + (_: Int) + (_: Int)\nsum6Placeholder: (Int, Int, Int, Int, Int, Int) => Int\n```", "```java\nsealed trait Glass[+Contents]\ncase class Full[Contents](c: Contents) extends Glass[Contents]\ncase object EmptyGlass extends Glass[Nothing]\ncase class Water(purity: Int)\n\ndef drink(glass: Glass[Water]): Unit = ???\n\nscala> :type drink _\nGlass[Water] => Unit\n\n```", "```java\ndef drinkAndRefill[C](glass: Glass[C]): Glass[C] = glass\ndrinkAndRefill: [C](glass: Glass[C])Glass[C]\n\nscala> :type drinkAndRefill _\nGlass[Nothing] => Glass[Nothing]\n\nscala> :type drinkAndRefill[Water] _\nGlass[Water] => Glass[Water]\n```", "```java\ndef drinkAndRefillWater[B >: Water, C >: B](glass: Glass[B]): Glass[C] = glass\n\nscala> :type drinkAndRefillWater[Water, Water] _\nGlass[Water] => Glass[Water]\n```", "```java\nscala> def drinkFun[B] = (glass: Glass[B]) => glass\ndrinkFun: [B]=> Glass[B] => Glass[B]\n\nscala> :type drinkFun\nGlass[Nothing] => Glass[Nothing]\n\nscala> drinkFun(Full(Water))\nres17: Glass[Water.type] = Full(Water)\n```", "```java\nscala> def printHash(hasher: String => Int)(s: String): Unit = \n  println(hasher(s))\nprintHash: (hasher: String => Int)(s: String)Unit\n```", "```java\nscala> :type printHash _\n(String => Int) => (String => Unit)\n```", "```java\ndef printHash[A](hasher: A => Int)(s: A): Unit = println(hasher(s))\n```", "```java\ndef printer[A, B, C <: A](f: A => B)(a: C): Unit = println(f(a))\n```", "```java\nscala> printer((_: String).hashCode)(\"HaHa\")\n2240498\nscala> printer((_: Int) / 2)(42)\n21\n```", "```java\ndef printer[A, B, C <: A](a: C)(f: A => B): Unit = println(f(a))\n```", "```java\nscala> printer(\"HoHo\")(_.length)\n4\nscala> printer(42)(identity)\n42\n```", "```java\ndef reverse(s: String): String = {\n  if (s.length < 2) s\n  else reverse(s.tail) + s.head\n}\n```", "```java\nscala> println(reverse(\"Recursive function call\"))\nllac noitcnuf evisruceR\n```", "```java\nscala> println(reverse(\"ABC\" * 100000))\njava.lang.StackOverflowError\n  at scala.collection.StringOps$.slice$extension(StringOps.scala:548)\n  at scala.collection.StringOps$.tail$extension(StringOps.scala:1026)\n  at ch03.Recursion$.reverse(Recursion.scala:7)\n  at ch03.Recursion$.reverse(Recursion.scala:7)\n  at ch03.Recursion$.reverse(Recursion.scala:7)\n  ...\n```", "```java\ndef tailRecReverse(s: String): String = {\n  def reverse(s: String, acc: String): String =\n    if (s.length < 2) s + acc\n    else reverse(s.tail, s.head + acc)\n  reverse(s, \"\")\n}\n```", "```java\nscala> println(inspectReverse(\"Recursive function call\"))\njava.lang.Exception\n  at $line19.$read$$iw$$iw$.reverse$1(<console>:3)\n  at $line19.$read$$iw$$iw$.inspectReverse(<console>:5)\n```", "```java\ndef inspectReverse(s: String): String = {\n  @scala.annotation.tailrec\n  def reverse(s: String, acc: String): String = ...\n}\n```", "```java\nscala> @scala.annotation.tailrec\n     | def reverse(s: String): String = {\n     | if (s.length < 2) s\n     | else reverse(s.tail) + s.head\n     | }\n           else reverse(s.tail) + s.head\n                                ^\nOn line 4: error: could not optimize @tailrec annotated method reverse: it contains a recursive call not in tail position\n```", "```java\ndef F(n:Int): Int = if (n == 0) 1 else n - M(F(n-1))\ndef M(n:Int): Int = if (n == 0) 0 else n - F(M(n-1))\n```", "```java\nval A: (Long, Long) => Long = (m, n) =>\n  if (m == 0) n + 1\n  else if (n == 0) A(m - 1, 1)\n  else A(m - 1, A(m, n - 1))\n```", "```java\nscala> A(4,2)\njava.lang.StackOverflowError\n  at .A(<console>:4)\n  at .A(<console>:4)\n...\n```", "```java\ncase class Done[A](value: A) extends TailRec[A]\ncase class Call[A](rest: () => TailRec[A]) extends TailRec[A]\ncase class Cont[A, B](a: TailRec[A], f: A => TailRec[B]) extends TailRec[B]\n```", "```java\nimport util.control.TailCalls._\n\ndef tailA(m: BigInt, n: BigInt): TailRec[BigInt] = {\n  if (m == 0) done(n + 1)\n  else if (n == 0) tailcall(tailA(m - 1, 1))\n  else tailcall(tailA(m, n - 1)).flatMap(tailA(m - 1, _))\n}\ndef A(m: Int, n: Int): BigInt = tailA(m, n).result\n```", "```java\nscala> Trampolined.A(4,2).toString.length\n\n```", "```java\nval A: Function2[Long, Long, Long] = (m, n) =>\n  if (m == 0) n + 1\n  else if (n == 0) A.apply(m - 1, 1)\n  else A.apply(m - 1, A.apply(m, n - 1))\n```", "```java\ntrait Function2[-T1, -T2, +R] extends AnyRef { self =>\n  def apply(v1: T1, v2: T2): R\n  ...\n}\n```", "```java\nval objectOrientedA: Function2[Long, Long, Long] = \n  new Function2[Long, Long, Long] {\n    def apply(m: Long, n: Long): Long =\n      if (m == 0) n + 1\n      else if (n == 0) objectOrientedA(m - 1, 1)\n      else objectOrientedA(m - 1, objectOrientedA(m, n - 1))\n}\n```", "```java\nscala> objectOrientedA.curried\nres9: Long => (Long => Long)\n```", "```java\ntrait PartialFunction[-A, +B] extends (A => B)\n```", "```java\ndef isDefinedAt(x: A): Boolean\n```", "```java\nval doReverse: PartialFunction[String, String] = {\n  case str if !isPalindrome(str) => str.reverse\n}\nval noReverse: PartialFunction[String, String] = {\n  case str if isPalindrome(str) => str\n}\ndef reverse = noReverse orElse doReverse\n\n```", "```java\nval upper = (_: String).toUpperCase\ndef fill(c: Char) = c.toString * (_: String).length\ndef filter(c: Char) = (_: String).filter(_ == c)\n\nval chain = List(upper, filter('L'), fill('*'))\nval allAtOnce = Function.chain(chain)\n\nscala> allAtOnce(\"List(upper, filter('a'), fill('C'))\")\nres11: String = ****\n```", "```java\nval static = upper andThen filter('a') andThen fill('C')\n```", "```java\nclass Loan[-T <: AutoCloseable, +R](app: T => R) extends (T => R) {\n  override def apply(t: T): R = try app(t) finally t.close()\n}\n```", "```java\nscala> new Loan((_: java.io.BufferedReader).readLine())(Console.in)\nres13: String = Hello\n\nscala> [error] (run-main-0) java.io.IOException: Stream Closed\n[error] java.io.IOException: Stream Closed\n[error] at java.io.FileInputStream.read0(Native Method)\n[error] at java.io.FileInputStream.read(FileInputStream.java:207)\n[error] at jline.internal.NonBlockingInputStream.read(NonBlockingInputStream.java:245)\n...\n```"]