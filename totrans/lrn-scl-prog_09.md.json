["```java\nimport scala.language.higherKinds\ntrait Monad[F[_]] {\n  def unit[A](a: => A): F[A]\n  def flatMap[A, B](a: F[A])(f: A => F[B]): F[B]\n}\n```", "```java\ntrait Monad[F[_]] {\n  def unit[A](a: => A): F[A]\n  def map[A, B](a: F[A])(f: A => B): F[B]\n  def flatten[A](fa: F[F[A]]): F[A]\n}\n```", "```java\ndef map[A, B](a: F[A])(f: A => B): F[B] = \n  flatMap(a)(a => unit(f(a)))\n```", "```java\ndef flatten[A](a: F[F[A]]): F[A] = flatMap(a)(identity)\n```", "```java\ndef apply[A, B](a: F[A])(f: F[A => B]): F[B] =\n  flatMap(f) { fab: (A => B) => map(a) { a: A => fab(a) }}\n```", "```java\ntrait Monad[F[_]] extends ch08.Applicative[F] {\n  def flatMap[A, B](a: F[A])(f: A => F[B]): F[B]\n\n  def flatten[A](a: F[F[A]]): F[A] = flatMap(a)(identity)\n\n  override def unit[A](a: => A): F[A]\n\n  override def map[A, B](a: F[A])(f: A => B): F[B] = \n    flatMap(a)(a => unit(f(a)))\n\n  override def apply[A, B](a: F[A])(f: F[A => B]): F[B] =\n    flatMap(f) { fab: (A => B) => map(a) { a: A => fab(a) }}\n}\n```", "```java\nval leftIdentity = forAll { as: M[A] =>\n  M.flatMap(as)(M.unit(_)) == as\n}\n```", "```java\nval rightIdentity = forAll { (a: A, f: A => M[B]) =>\n  M.flatMap(M.unit(a))(f) == f(a)\n}\n```", "```java\nimport org.scalacheck._\nimport org.scalacheck.Prop._\n\ndef id[A, B, M[_]](implicit M: Monad[M],\n                   arbFA: Arbitrary[M[A]],\n                   arbFB: Arbitrary[M[B]],\n                   arbA: Arbitrary[A],\n                   cogenA: Cogen[A]): Prop = {\n  val leftIdentity = forAll { as: M[A] =>\n    M.flatMap(as)(M.unit(_)) == as\n  }\n  val rightIdentity = forAll { (a: A, f: A => M[B]) =>\n    M.flatMap(M.unit(a))(f) == f(a)\n  }\n  leftIdentity && rightIdentity\n}\n```", "```java\nforAll((a: M[A], f: A => M[B], g: B => M[C]) => {\n  val leftSide = M.flatMap(M.flatMap(a)(f))(g)\n  val rightSide = M.flatMap(a)(a => M.flatMap(f(a))(g))\n  leftSide == rightSide\n})\n```", "```java\ndef monad[A, B, C, M[_]](implicit M: Monad[M], ...): Prop = {\n  id[A, B, M] && associativity[A, B, C, M]\n}\n```", "```java\nimplicit val optionMonad = new Monad[Option] {\n  override def unit[A](a: => A): Option[A] = Some(a)\n\n  override def flatMap[A, B](a: Option[A])(f: A => Option[B]): Option[B] = a match {\n    case Some(value) => f(value)\n    case _ => None\n  }\n}\n```", "```java\nproperty(\"Monad[Option] and Int => String, String => Long\") = {\n  monad[Int, String, Long, Option]\n}\nproperty(\"Monad[Option] and String => Int, Int => Boolean\") = {\n  monad[String, Int, Boolean, Option]\n}\n+ Monad.Monad[Option] and Int => String, String => Long: OK, passed 100 tests.\n+ Monad.Monad[Option] and String => Int, Int => Boolean: OK, passed 100 tests.\n```", "```java\naddCompilerPlugin(\"org.spire-math\" %% \"kind-projector\" % \"0.9.8\")\n```", "```java\nimplicit def eitherMonad[L] = new Monad[Either[L, ?]] {\n  override def unit[A](a: => A): Either[L, A] = Right(a)\n\n  override def flatMap[A, B](a: Either[L, A])(f: A => Either[L, B]): Either[L, B] = a match {\n    case Right(r) => f(r)\n    case Left(l) => Left(l)\n  }\n}\n```", "```java\ntype UnitEither[R] = Either[Unit, R]\n\nproperty(\"Monad[UnitEither[Int]] and Int => String, String => Long\") = {\n  monad[Int, String, Long, UnitEither]\n}\n\nproperty(\"Monad[UnitEither[String]] and String => Int, Int => Boolean\") = {\n  monad[String, Int, Boolean, UnitEither]\n}\n```", "```java\nimplicit val listMonad = new Monad[List] {\n  def unit[A](a: => A) = List(a)\n\n  def flatMap[A,B](as: List[A])(f: A => List[B]): List[B] = as match {\n    case Nil => Nil\n    case a :: as => f(a) ::: flatMap(as)(f)\n  }\n}\n```", "```java\nproperty(\"Monad[List] and Int => String, String => Long\") = {\n  monad[Int, String, Long, List]\n}\nproperty(\"Monad[List] and String => Int, Int => Boolean\") = {\n  monad[String, Int, Boolean, List]\n}\n+ Monad.Monad[List] and Int => String, String => Long: OK, passed 100 tests.\n+ Monad.Monad[List] and String => Int, Int => Boolean: OK, passed 100 tests.\n```", "```java\noverride def flatMap[A,B](as: List[A])(f: A => List[B]): List[B] = {\n  @tailrec\n  def fMap(as: List[A], acc: List[B])(f: A => List[B]): List[B] = as match {\n    case Nil => acc\n    case a :: aas => fMap(aas, acc ::: f(a))(f)\n  }\n  fMap(as, Nil)(f)\n}\n```", "```java\noverride def flatMap[A,B](as: List[A])(f: A => List[B]): List[B] = as.flatMap(f)\n```", "```java\ntype Id[A] = A\n\n```", "```java\nimplicit val idMonad = new Monad[Id] {\n  override def unit[A](a: => A): Id[A] = a\n  override def flatMap[A, B](a: Id[A])(f: A => Id[B]): Id[B] = f(a)\n}\n```", "```java\nproperty(\"Monad[Id] and Int => String, String => Long\") = {\n  monad[Int, String, Long, Id]\n}\nproperty(\"Monad[Id] and String => Int, Int => Boolean\") = {\n  monad[String, Int, Boolean, Id]\n}\n+ Monad.Monad[Id] and Int => String, String => Long: OK, passed 100 tests.\n+ Monad.Monad[Id] and String => Int, Int => Boolean: OK, passed 100 tests.\n```", "```java\nvar globalState = 0\n\ndef incGlobal(count: Int): Int = {\n  globalState += count\n  globalState\n}\n\nval g1 = incGlobal(10) // g1 == 10\nval g2 = incGlobal(10) // g1 == 20\n```", "```java\ndef incLocal(count: Int, global: Int): Int = global + count\n\nval l1 = incLocal(10, 0) // l1 = 10\nval l2 = incLocal(10, 0) // l2 = 10\n```", "```java\nfinal case class State[S, A](run: S => (A, S))\n```", "```java\nobject State {\n  def apply[S, A](a: => A): State[S, A] = State(s => (a, s))\n  def get[S]: State[S, S] = State(s => (s, s))\n  def set[S](s: => S): State[S, Unit] = State(_ => ((), s))\n}\n```", "```java\nfinal case class State[S, A](run: S => (A, S)) {\n  def compose[B](f: A => State[S, B]): State[S, B] = {\n    val composedRuns = (s: S) => {\n      val (a, nextState) = run(s)\n      f(a).run(nextState)\n    }\n    State(composedRuns)\n  }\n}\n```", "```java\nimport ch09._\nimplicit def stateMonad[S] = new Monad[State[S, ?]] {\n  override def unit[A](a: => A): State[S, A] = State(a)\n  override def flatMap[A, B](a: State[S, A])(f: A => State[S, B]): State[S, B] = a.compose(f)\n}\n```", "```java\nState(s => (a, s1)).compose(f) = State(s => {\n  f(a).run(s1) // substituting f(a) with the result of the call\n}) = State(s => {\n  State(s1 => (b, s2)).run(s1)\n}) = State(s => (b, s2))\n```", "```java\nval leftIdentity = forAll { as: M[A] =>\n  M.flatMap(as)(M.unit(_)) == as\n}\n```", "```java\nM.flatMap(as)(M.unit(_)) == as\n```", "```java\nM.flatMap(State(s => (a, s1)))(M.unit(_))\n```", "```java\n def apply[S, A](a: => A): State[S, A] = State(s => (a, s))\n```", "```java\n M.flatMap(State(s => (a, s1)))(b => State(s1 => (b, s1)))\n```", "```java\nState(s => (a, s1)).compose(b => State(s1 => (b, s1)))\n```", "```java\nState(s => (a, s1))\n```", "```java\nforAll((as: M[A], f: A => M[B], g: B => M[C]) => {\n  val leftSide = M.flatMap(M.flatMap(as)(f))(g)\n  val rightSide = M.flatMap(as)(a => M.flatMap(f(a))(g))\n  leftSide == rightSide\n})\n```", "```java\nfinal case class Boat(direction: Double, position: (Double, Double)) {\n  def go(speed: Float, time: Float): Boat = ??? // please see the accompanying code\n  def turn(angle: Double): Boat = ??? // please see the accompanying code\n}\n```", "```java\nscala> import ch09._\nimport ch09._\nscala> val boat = Boat(0, (0d, 0d))\nboat: Boat = Boat(0.0,(0.0,0.0))\nscala> boat.go(10, 5).turn(0.5).go(20, 20).turn(-0.1).go(1,1)\nres1: Boat = Boat(0.4,(401.95408575015193,192.15963378398988))\n```", "```java\ntype FuelState = State[Float, Boat]\n```", "```java\nobject lowPriorityImplicits {\n  implicit class MonadF[A, F[_] : Monad](val value: F[A]) {\n    private val M = implicitly[Monad[F]]\n    def unit(a: A) = M.unit(a)\n    def flatMap[B](fab: A => F[B]): F[B] = M.flatMap(value)(fab)\n    def map[B](fab: A => B): F[B] = M.map(value)(fab)\n  }\n}\n```", "```java\nState[Float, Boat](boat).flatMap((boat: Boat) => State[Float, Boat](???))\n```", "```java\nlazy val consumption = 1f\ndef consume(speed: Float, time: Float) = consumption * time * speed\ndef turn(angle: Double)(boat: Boat): FuelState =\n  State(boat.turn(angle))\ndef go(speed: Float, time: Float)(boat: Boat): FuelState = \n  new State(fuel => {\n    val newFuel = fuel - consume(speed, time)\n    (boat.go(speed, time), newFuel)\n  })\n\n```", "```java\nimport Monad.lowPriorityImplicits._\ndef move(boat: Boat) = State[Float, Boat](boat).\n  flatMap(go(10, 5)).\n  flatMap(turn(0.5)).\n  flatMap(go(20,20)).\n  flatMap(turn(-0.1)).\n  flatMap{b: Boat => go(1,1)(b)}\n```", "```java\ndef move(boat: Boat) = for {\n  a <- State[Float, Boat](boat)\n  b <- go(10,5)(a)\n  c <- turn(0.5)(b)\n  d <- go(20, 20)(c)\n  e <- turn(-0.1)(d)\n  f <- go(1,1)(e)\n} yield f\n```", "```java\nscala> println(move(boat).value.run(1000f))\n(Boat(0.4,(401.95408575015193,192.15963378398988)),549.0)\n```", "```java\ndef logFuelState(f: Float) = println(s\"Current fuel level is $f\")\n\ndef loggingMove(boat: Boat) = for {\n  a <- State[Float, Boat](boat)\n  f1 <- State.get[Float]\n  _ = logFuelState(f1)\n  _ <- State.set(Math.min(700, f1))\n  b <- go(10,5)(a)\n  f2 <- State.get[Float]; _ = logFuelState(f2)\n  c <- turn(0.5)(b)\n  f3 <- State.get[Float]; _ = logFuelState(f3)\n  d <- go(20, 20)(c)\n  f3 <- State.get[Float]; _ = logFuelState(f3)\n  e <- turn(-0.1)(d)\n  f3 <- State.get[Float]; _ = logFuelState(f3)\n  f <- go(1,1)(e)\n} yield f\n```", "```java\n  f1 <- State.get[Float]\n  _ = logFuelState(f1)\n```", "```java\n  _ <- State.set(Math.min(700, f1))\n```", "```java\nscala> println(loggingMove(boat).value.run(1000f))\nCurrent fuel level is 1000.0\nCurrent fuel level is 650.0\nCurrent fuel level is 650.0\nCurrent fuel level is 250.0\nCurrent fuel level is 250.0\n```", "```java\ndef move(\n  go: (Float, Float) => Boat => FuelState, \n  turn: Double => Boat => FuelState\n)(boat: Boat): FuelState\n```", "```java\ndef move[A, M[_]: Monad](\n  go: (Float, Float) => A => M[A], \n  turn: Double => A => M[A]\n)(boat: M[A]): M[A] = for {\n  a <- boat\n  b <- go(10,5)(a)\n  // the rest of the definition is exactly like before\n} yield f\n```", "```java\nimport Boat.{move, boat}\nprintln(move(go, turn)(State(boat)).run(1000f))\n```", "```java\ndef turn[M[_]: Monad]: Double => Boat => M[Boat] =\n  angle => boat => Monad[M].unit(boat.turn(angle))\n```", "```java\nobject Boat {\n  val boat = Boat(0, (0d, 0d))\n  import Monad.lowPriorityImplicits._\n  def go[M[_]: Monad]: (Float, Float) => Boat => M[Boat] =\n    (speed, time) => boat => Monad[M].unit(boat.go(speed, time))\n  def turn[M[_]: Monad]: Double => Boat => M[Boat] =\n    angle => boat => Monad[M].unit(boat.turn(angle))\n  def move[A, M[_]: Monad](go: (Float, Float) => A => M[A], turn: Double => A => M[A])(boat: M[A]): M[A] = // definition as above\n}\n```", "```java\nimport ch09._\nimport Boat.{move => moveB, turn => turnB, boat}\nimport StateExample._\ntype FuelState[B] = State[Float, B]\nprintln(moveBoat(go, turnB[FuelState])(State(boat)).run(1000f))\n```", "```java\nimport Monad.Id\nimport Boat._\nprintln(move(go[Id], turn[Id])(boat))\n```", "```java\nfinal case class Reader[R, A](run: R => A) {\n  def compose[B](f: A => Reader[R, B]): Reader[R, B] = \n    Reader { r: R => \n      f(run(r)).run(r)\n    }\n}\n```", "```java\nobject Reader {\n  def apply[R, A](a: => A): Reader[R, A] = Reader(_ => a)\n}\n```", "```java\nimplicit def readerMonad[R] = new Monad[Reader[R, ?]] {\n  override def unit[A](a: => A): Reader[R, A] = Reader(a)\n  override def flatMap[A, B](a: Reader[R, A])(f: A => Reader[R, B]): Reader[R, B] = a.compose(f)\n}\n```", "```java\nfinal case class Limits(speed: Float, angle: Double)\ntype ReaderLimits[A] = ch09.Reader[Limits, A]\n```", "```java\ndef go(speed: Float, time: Float)(boat: Boat): ReaderLimits[Boat] =\n  ch09.Reader(limits => {\n    val lowSpeed = Math.min(speed, limits.speed)\n    boat.go(lowSpeed, time)\n  })\n\ndef turn(angle: Double)(boat: Boat): ReaderLimits[Boat] =\n  ch09.Reader(limits => {\n    val smallAngle = Math.min(angle, limits.angle)\n    boat.turn(smallAngle)\n  })\n```", "```java\nimport Monad.readerMonad\nimport Boat._\nprintln(move(go, turn)(ch09.Reader(boat)).run(Limits(10f, 0.1)))\nBoat(0.0,(250.00083305560517,19.96668332936563))\n```", "```java\nimport ch07._\nfinal case class Writer[W: Monoid, A](run: (A, W))\n```", "```java\nfinal case class Writer[W: Monoid, A](run: (A, W)) {\n  def compose[B](f: A => Writer[W, B]): Writer[W, B] = Writer {\n    val (a, w) = run\n    val (b, ww) = f(a).run\n    val www = implicitly[Monoid[W]].op(w, ww)\n    (b, www)\n  }\n}\n```", "```java\nobject Writer {\n  def apply[W: Monoid, A](a: => A): Writer[W, A] = Writer((a, implicitly[Monoid[W]].identity))\n}\n```", "```java\nimplicit def writerMonad[W : Monoid] = new Monad[Writer[W, ?]] {\n  override def unit[A](a: => A): Writer[W, A] = Writer(a)\n  override def flatMap[A, B](a: Writer[W, A])(f: A => Writer[W, B]): Writer[W, B] = a.compose(f)\n}\n```", "```java\ntype WriterTracking[A] = Writer[Vector[(Double, Double)], A]\n\ndef go(speed: Float, time: Float)(boat: Boat): WriterTracking[Boat] = new WriterTracking((boat.go(speed, time), Vector(boat.position)))\n```", "```java\nimplicit def vectorMonoid[A]: Monoid[Vector[A]] = \n  new Monoid[Vector[A]] {\n    override def identity: Vector[A] = Vector.empty[A]\n    override def op(l: Vector[A], r: Vector[A]): Vector[A] = l ++ r\n  }\n```", "```java\nimport Monad.writerMonad\nimport Boat.{move, boat, turn}\nprintln(move(go, turn[WriterTracking])(Writer(boat)).run)\n\n(Boat(0.4,(401.95408575015193,192.15963378398988)),Vector((0.0,0.0), (50.0,0.0), (401.0330247561491,191.77021544168122)))\n```", "```java\ntype WriterOption[B] = Writer[Vector[(Double, Double)], Option[Boat]]\n```"]