- en: Chapter 7. Validating Web Service Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have a RESTful Web Service that produces JSON representations
    and is also capable of storing and updating contacts. Before we actually store
    or update a contact's information though, we need to ensure that the provided
    information is valid and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do in order to validate contacts is to define what
    is considered a valid contact. To do so, we will modify the representation class,
    adding constraints to its members in the form of Hibernate Validator annotations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the `Contact` class, instances of which must have a first name, a last
    name, and a phone number in order to be considered valid. Moreover, the length
    of these values must be within specific limits. Let's go through the required
    steps in order to apply these constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Contact` representation class, adding the appropriate annotations
    to its members (import `org.hibernate.validator.constraints.*` first):'
  prefs: []
  type: TYPE_NORMAL
- en: Update the declaration of the `firstName` variable, adding the necessary annotations
    in order to indicate that this is a required property (it should not be blank),
    and its length should be between 2 and 255 characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a similar way, apply the same constraints on the `lastName` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `phone` field should not be longer than 30 digits, so modify the values
    of the relevant annotation accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The declaration of validation constraints is annotation-based. This gives us
    the flexibility of directly adding the validation rules we want to the members
    of our representation class.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate Validator is a part of the `dropwizard-core` module, so we do not
    need to declare any additional dependencies on our `pom.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recommended way of validating objects is using the standard **Bean Validation
    API** (**JSR 303**). For our validation needs, we use **Hibernate Validator**,
    which is a part of the `Dropwizard-core` module, and the reference implementation
    of JSR 303\. Using Hibernate Validator, we can declare field constraints such
    as `@NotBlank` and `@Length`, or even create and use our own custom constraints
    that fit our needs (you may refer to Hibernate Validator's documentation at [http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints](http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints)).
  prefs: []
  type: TYPE_NORMAL
- en: List of constraint annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete list of field constraints is available on the Hibernate Validator
    package navigator at [http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints](http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints).
  prefs: []
  type: TYPE_NORMAL
- en: Performing validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just defined what a valid annotation is. Now, we must modify the code
    of our resource class in order to verify that each POST and PUT request contains
    a valid `Contact` object, based on which a contact is created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see what needs to be modified in our resource class by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to import some classes that will help us with the validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a final member, `validator`, and update the constructor method in order
    to initialize it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `App` class, modify the `#run()` method so as to pass the environment's
    `validator` as a parameter to `ContactResource` during its initialization, along
    with jDBI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the `ContactResource#createContact()` method and check that the contact
    information is valid prior to inserting it in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, update the `ContactResource#updateContact()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the application from the command line in order to do some tests
    with the validation mechanisms we just implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using `curl`, perform an HTTP POST request to `http://localhost:8080/contact/`,
    sending contact information that is going to trigger validation errors, such as
    `firstName` and `lastName` with length less than 2 characters, and an empty value
    for the `phone` field in a JSON string such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/9530OS_07_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You will see that the response is an **HTTP/1.1 400 Bad Request** error, and
    the response payload is a JSON array containing the following error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `ContactResource#createContact()` method, which is mapped to the POST
    requests to `/contact` URI, we used the environment's instance of `javax.validation.Validator`
    to validate the received `contact` object.
  prefs: []
  type: TYPE_NORMAL
- en: The validator's `#validate()` method returns a `Set<ConstraintViolation<Contact>>`
    instance, which contains the validation error that occurred, if any. We check
    the list's size to determine if there are any violations. If there are, we will
    iterate through them, extracting the validation message of each error and adding
    it to an `ArrayList` instance, which we then return as a response along with **HTTP
    Status Code 400 – Bad Request**.
  prefs: []
  type: TYPE_NORMAL
- en: Since our resource class produces a JSON output (already declared with the `@Produces`
    annotation at the class level), the `ArrayList` instance will be transformed to
    a JSON array thanks to Jackson.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw, in order to test and showcase the POST requests to the endpoint
    we created, we need an HTTP client. Apart from cURL, there are some really good
    and useful HTTP client tools available (such as Postman for Google Chrome, available
    at [https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm))
    that can help us with this, and we will also create our own in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The @Valid annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of using a `validator` object to validate the input object, we could
    have just annotated the `contact` object as `@Valid` on the `#createContact` method,
    as seen in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When an object is annotated with `@Valid`, the validation is recursively performed
    on it. This would have the validation triggered as soon as the method was called.
    In case the `contact` object was found invalid, then a default **HTTP 422 – Unprocessable
    entity** response will be generated automatically. While the `validator` object
    is more powerful and customizable, the usage of the `@Valid` annotation is an
    alternative, simple, and straightforward way to validate incoming requests. This
    prevents the need to return a custom, more descriptive validation error message
    to the caller, and sends a generic one instead.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-field validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where validation should be performed on multiple fields (properties)
    of an object. We can achieve this by implementing custom validation annotations
    that also apply class-level constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily enough, there's a much simpler way to achieve this. Dropwizard offers
    the `io.dropwizard.validation.ValidationMethod` annotation, which we can use in
    a `boolean` method of our representation class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the steps needed in order to add cross-field validation to a `contact`
    object. We will check that the contact''s full name is not John Doe:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new method in the `Contact` class named `#isValidPerson()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we need to ensure that the output of this method will never be included
    in the output when it is serialized by Jackson. For this, annotate the `#isValidPerson()`
    method with the `@JsonIgnore` annotation (`com.fasterxml.jackson.annotation.JsonIgnore`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, annotate the same method with `@ValidationMethod` (`io.dropwizard.validation.ValidationMethod`),
    and also provide an error message in case of validation failure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the validation is triggered, the `#isValidPerson()` method is executed
    along with the custom validation code we've put there. If the method returns true,
    that means the constraint implied by it is satisfied. If the method returns false,
    that indicates a constraint violation, and the validation error message will be
    the one we specified along with the `ValidationMethod` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: You can create and have as many cross-field validation methods as you want in
    your classes. However, note that every custom validation method must be of the
    return type `boolean`, and its name must begin with `is`.
  prefs: []
  type: TYPE_NORMAL
