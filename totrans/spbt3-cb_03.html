<html><head></head><body>
		<div id="_idContainer062">
			<h1 class="chapter-number" id="_idParaDest-97"><a id="_idTextAnchor103"/>3</h1>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor104"/>Observability, Monitoring, and Application Management</h1>
			<p>Monitoring and observability are crucial aspects of managing and maintaining the health, performance, and reliability of modern applications. In microservices-oriented applications, with multiple instances of different services running at the same time to deliver a solution, observability and monitoring help in understanding the interactions between these services and <span class="No-Break">identifying issues.</span></p>
			<p>Monitoring plays a crucial role in large environments, enabling resource utilization and performance metrics to be tracked. This, in turn, facilitates dynamically scaling resources to effectively meet the demands of the system. This is especially useful in cloud computing environments, where you pay for the resources used and where you can adapt your application resources to the real demands of your users. Without monitoring, how do you know if your application is running at 100% CPU and the response time is so slow that your users abandon <span class="No-Break">your application?</span></p>
			<p>When you have multiple microservices running in your application and there’s an issue, observability is crucial in identifying the failing component and the context in which <span class="No-Break">errors occur.</span></p>
			<p>Observability and monitoring are also very important for continuous improvement. You can use the insights gained from monitoring to make data-driven decisions, enhance performance, and refine the solution <span class="No-Break">over time.</span></p>
			<p>Spring Boot, through Actuator, provides not only monitoring but also management capabilities that allow you to interact with the application in production environments. This capability not only allows you to detect potential issues in the application but also helps in troubleshooting <span class="No-Break">at runtime.</span></p>
			<p>In this chapter, you will gain insights into activating observability and monitoring features within your Spring Boot applications. We’ll start by providing health checks in your application. Here, you’ll learn how to leverage the data that’s generated by your application through popular open source solutions. This chapter will also cover creating traces within your system, allowing you to correlate activities across different microservices and explore them using Zipkin. Additionally, you will learn how to monitor the exposed metrics of your application using Prometheus and Grafana. Beyond the standard metrics provided by Spring Boot and its associated components, you will generate custom metrics tailored to your application’s specifics and monitor them. Once your application becomes both monitorable and observable, you can also integrate with commercial tools while considering the plethora of powerful monitoring solutions available in the market that are well-suited for production environments. Finally, you will learn how to change application settings at runtime so that you can troubleshoot <span class="No-Break">your application.</span></p>
			<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Adding Actuator to <span class="No-Break">your application</span></li>
				<li>Creating a custom <span class="No-Break">Actuator endpoint</span></li>
				<li>Using probes and creating a custom <span class="No-Break">health check</span></li>
				<li>Implementing <span class="No-Break">distributed tracing</span></li>
				<li>Accessing <span class="No-Break">standard metrics</span></li>
				<li>Creating your <span class="No-Break">own metrics</span></li>
				<li>Integrating your application with Prometheus <span class="No-Break">and Grafana</span></li>
				<li>Changing the settings of a <span class="No-Break">running application</span></li>
			</ul>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor105"/>Technical requirements</h1>
			<p>In this chapter, we’ll need to run different tools, such as Prometheus, Grafana, and Zipkin. As usual, the simplest way to run them on your computer is using Docker. You can get Docker from its product page: <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>. I will explain how to deploy each tool in its <span class="No-Break">corresponding recipe.</span></p>
			<p>All the recipes that will be demonstrated in this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter3"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter3</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor106"/>Adding Actuator to your application</h1>
			<p>So, you plan to develop <a id="_idIndexMarker244"/>a new RESTful API to complete your football-related<a id="_idIndexMarker245"/> suite of services. You are concerned about the responsiveness of your application and our aim to provide a resilient service. For that reason, you are very interested in monitoring your application <span class="No-Break">health properly.</span></p>
			<p>Before you start to monitor your application, your application should be monitorable. For that, you have decided to start using <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Boot Actuator</strong></span><span class="No-Break">.</span></p>
			<p>Spring Boot Actuator comprises a set of production-ready functionalities packaged with the Spring Framework. It incorporates various built-in tools and endpoints that are designed to allow you to monitor, manage, and interact with Spring Boot applications within a production setting. Actuator simplifies the process of comprehending and resolving runtime behaviors in Spring <span class="No-Break">Boot applications.</span></p>
			<p>The Actuator module exposes multiple endpoints, including <strong class="source-inline">health</strong>, <strong class="source-inline">metrics</strong>, <strong class="source-inline">info</strong>, <strong class="source-inline">dump</strong>, and <strong class="source-inline">env</strong>, among others, offering operational insights into the running application. Once this dependency is included, you have a lot of out-of-the-box endpoints available. Customizing and extending these endpoints can easily be achieved and provides flexibility in terms <span class="No-Break">of configuration.</span></p>
			<p>In this recipe, you will learn how to include Spring Boot Actuator in your project and use some of the endpoints that are provided out of <span class="No-Break">the box.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor107"/>Getting ready</h2>
			<p>In this recipe, we’ll create an application using the <em class="italic">Spring Initializr</em> tool. As you did in previous chapters of this book, you can use the tool in your browser by going to <a href="https://start.spring.io">https://start.spring.io</a> or integrating it into your favorite <span class="No-Break">code editor.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor108"/>How to do it…</h2>
			<p>Let’s create a project with Actuator enabled and start exploring the <span class="No-Break">endpoints provided:</span></p>
			<ol>
				<li>Create a project using the <em class="italic">Spring Initializr</em> tool. Open <a href="https://start.spring.io">https://start.spring.io</a> and use the same parameters that you used in the <em class="italic">Creating a RESTful API recipe</em> of <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, except change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">fooballobs</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong> and <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Boot Actuator</strong></span></li></ul></li>
				<li>Download the template that was generated with <em class="italic">Spring Initializr</em> and unzip the content to your <span class="No-Break">working directory.</span></li>
				<li>If you run the application<a id="_idIndexMarker246"/> now, you can access the health<a id="_idIndexMarker247"/> endpoint at <strong class="source-inline">/actuator/health</strong>. Before running the application, we’ll expose some endpoints. For that, create an <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and add the <span class="No-Break">following content:</span><pre class="source-code">
management:
    endpoints:
        web:
            exposure:
                include: <strong class="bold">health,env,metrics,beans,loggers</strong></pre></li>				<li>Now, run the application. You can now access the exposed <span class="No-Break">Actuator endpoints:</span><ul><li><strong class="source-inline">http://localhost:8080/actuator/health</strong>: This endpoint provides health information about your application. It is very useful in containerized environments such as Kubernetes to ensure that your application is up <span class="No-Break">and running.</span></li><li>http://localhost:8080/actuator/env: This endpoint returns the environment variables of <span class="No-Break">the application.</span></li><li><strong class="source-inline">http://localhost:8080/actuator/metrics</strong>: This endpoint returns a list that contains the metrics that have been exposed by the application. You can get the values of any of the metrics that have been exposed by appending the name to the metrics endpoint. For instance, to get <strong class="source-inline">process.cpu.usage</strong>, you can <span class="No-Break">request </span><span class="No-Break">http://localhost:8080/actuator/metrics/process.cpu.usage</span><span class="No-Break">.</span></li><li><strong class="source-inline">http://localhost:8080/actuator/beans</strong>: This endpoint returns a list with the beans registered in the IoC container – that is, a list of beans that can be injected into <span class="No-Break">other beans.</span></li><li><strong class="source-inline">http://localhost:8080/actuator/loggers</strong>: This endpoint returns the list of log levels and loggers of the application. It also allows to modify the log level <span class="No-Break">at runtime.</span></li></ul></li>
				<li>In this recipe, you exposed just some of the available endpoints. You can find the full list<a id="_idIndexMarker248"/> of built-in endpoints <span class="No-Break">at </span><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints"><span class="No-Break">https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints</span></a><span class="No-Break">.</span></li>
			</ol>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor109"/>How it works…</h2>
			<p>When you integrate Actuator<a id="_idIndexMarker249"/> into your application, it provides a set<a id="_idIndexMarker250"/> of endpoints that can be used for monitoring your application and managing its behavior. In addition to the built-in endpoints, it lets you add <span class="No-Break">your own.</span></p>
			<p>Endpoints can be enabled or disabled. By default, all endpoints are enabled except the shutdown endpoint – as its name suggests, you can use it to gracefully shut down the application. Then, the endpoints can be exposed, meaning that they can be accessed remotely using HTTP requests or JMX. By default, only the health endpoint is exposed. In this book, we’ll mostly focus on HTTP as it can be used with standard monitoring tools not specific to the Java ecosystem. HTTP is only available for web applications; if you’re developing another type of application, you will need to <span class="No-Break">use JMX.</span></p>
			<p>Depending on the components you use, more data will be exposed. For instance, when you include Spring Data JPA, the Spring Data metrics become available, so you will have to configure the number of open connections and other relevant metrics for Spring <span class="No-Break">Data monitoring.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor110"/>There’s more…</h2>
			<p>Some of the endpoints provided by Actuator may expose very sensitive information. So, the health endpoint is the only one that’s exposed by default. If your applications can only be accessed inside a virtual network or protected with a firewall, maybe you can keep endpoints open. Whether your application is publicly exposed or you simply want to control who accesses your Actuator endpoint, you may want to protect them, as explained in <a href="B21646_02.xhtml#_idTextAnchor066"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. For instance, a security configuration could look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .authorizeHttpRequests(authorize -&gt;
                      <strong class="bold">authorize.requestMatchers("/actuator/**")</strong>
<strong class="bold">                         .hasRole("ADMIN")</strong>
                         .anyRequest().authenticated())
                .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()))
                .build();
    }
}</pre>			<p>You can refer<a id="_idIndexMarker251"/> to Spring Boot’s official documentation at <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security">https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.security</a> for <span class="No-Break">more details.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor111"/>See also</h2>
			<p>In addition to endpoints provided by Spring Boot and the components used, Actuator provides a flexible implementation that allows you to create your own endpoints. Later in this chapter, you will learn how to create your own Actuator endpoint, metrics, and custom <span class="No-Break">health checks.</span></p>
			<p>See the <em class="italic">Creating a custom Actuator endpoint</em>, <em class="italic">Creating a custom health check</em>, and <em class="italic">Creating your own metrics</em> recipes for <span class="No-Break">more information.</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor112"/>Creating a custom Actuator endpoint</h1>
			<p>In our example, we are developing<a id="_idIndexMarker252"/> a new RESTful API that requires a file to be loaded from blob storage. That file doesn’t change frequently, which means it’s loaded in memory at application startup and is not reloaded again automatically. You need to know which version of the file is loaded, and you want to force a reload when there is a <span class="No-Break">new version.</span></p>
			<p>To implement this feature, you will use a custom Actuator endpoint. This endpoint will have a <strong class="source-inline">GET</strong> operation to return the current file version, and a <strong class="source-inline">POST</strong> method to reload <span class="No-Break">the file.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor113"/>Getting ready</h2>
			<p>In this recipe, you will reuse the application you created in the <em class="italic">Adding Actuator to your application</em> recipe. I’ve prepared a working version in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-2/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor114"/>How to do it…</h2>
			<p>Let’s modify the RESTful API so that it loads a file from a folder and returns some results. Once you’ve done this, you’ll need to create a custom Actuator endpoint that returns the file that’s been loaded. You will also need to configure the endpoint to reload <span class="No-Break">the file:</span></p>
			<ol>
				<li>Start by creating a class that loads a file and keeps the content <span class="No-Break">in memory:</span><ol><li class="upper-roman">Let’s name it <strong class="source-inline">FileLoader</strong> and add the <span class="No-Break">following code:</span></li></ol><pre class="source-code">
public class FileLoader {
    private String fileName;
    private List&lt;String&gt; teams;
    private String folder;
    public FileLoader(String folder) {
        this.folder = folder;
    }
}</pre><ol><li class="upper-roman" value="2">To load the file and keep the content in memory, add the <span class="No-Break">following code:</span></li></ol><pre class="source-code">private void loadFile(String fileName) throws Exception {
       this.fileName = fileName;
       ObjectMapper mapper = new ObjectMapper();
       File file = new File(fileName);
       teams = mapper.readValue(file,
               new TypeReference&lt;List&lt;String&gt;&gt;() {
               });
 }</pre><ol><li class="upper-roman" value="3">Now, add a public method<a id="_idIndexMarker253"/> so that you can load the first file that’s found in the folder that’s passed in <span class="No-Break">the constructor:</span></li></ol><pre class="source-code">public void loadFile() throws IOException {
    Files.list(Paths.get(folder))
         .filter(Files::isRegularFile)
         .findFirst()
         .ifPresent(file -&gt; {
             try {
                  loadFile(file.toString());
             } catch (Exception e) {
                  e.printStackTrace();
             }
        });
}</pre></li>				<li>Next, create a class annotated with <strong class="source-inline">@Endpoint</strong> to define the custom Actuator endpoint. Name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">FootballCustomEndpoint</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">@Endpoint(id = "football")</strong>
public class FootballCustomEndpoint {
    private FileLoader fileLoader;
    FootballCustomEndpoint(FileLoader fileLoader){
        this.fileLoader = fileLoader;
    }
}</pre><p class="list-inset">This class receives a <strong class="source-inline">FileLoader</strong> object in the constructor to perform the <span class="No-Break">necessary actions.</span></p></li>				<li>Now, create the custom<a id="_idIndexMarker254"/> endpoint operations <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">FootballCustomEndpoint</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">Create a method annotated with <strong class="source-inline">@ReadOperation</strong> to retrieve the file version <span class="No-Break">in use:</span></li></ol><pre class="source-code">
<strong class="bold">@ReadOperation</strong>
public String getFileVersion(){
    return fileLoader.getFileName();
}</pre><ol><li class="upper-roman" value="2">Create a method annotated with <strong class="source-inline">@WriteOperation</strong> to refresh <span class="No-Break">the file:</span></li></ol><pre class="source-code"><strong class="bold">@WriteOperation</strong>
public void refreshFile(){
   try {
       fileLoader.loadFile();
   } catch (Exception e) {
       e.printStackTrace();
   }
}</pre></li>				<li>Next, you need to create a bean for both the <strong class="source-inline">FileLoader</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">FootballCustom</strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline">Endpoint</strong></span><span class="No-Break"> classes:</span><ol><li class="upper-roman">Create a class named <strong class="source-inline">FootballConfiguration</strong> and annotate it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Configuration</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
<strong class="bold">@Configuration</strong>
public class FootballConfiguration {
    @Value("${football.folder}")
    private String folder;
}</pre><ol><li class="upper-roman" value="2">Note that there is a field annotated<a id="_idIndexMarker255"/> with <strong class="source-inline">@Value</strong>. It will load the folder path containing the file to load from <span class="No-Break">the configuration.</span></li><li class="upper-roman">Create a method that produces a bean <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">FileLoader</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">@Bean
public FileLoader fileLoader() throws IOException{
    FileLoader fileLoader = new FileLoader(folder);
    return fileLoader;
}</pre><ol><li class="upper-roman" value="4">Now, create a method that <span class="No-Break">produces </span><span class="No-Break"><strong class="source-inline">FootballCustomEndpoint</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">@Bean
public FootballCustomEndpoint footballCustomEndpoint(FileLoader fileLoader){
    return new FootballCustomEndpoint(fileLoader);
}</pre></li>				<li>Since <strong class="source-inline">FileLoader</strong> needs to load<a id="_idIndexMarker256"/> the file by using the <strong class="source-inline">loadFile</strong> method, you will need to create a class that implement an <span class="No-Break"><strong class="source-inline">ApplicationRunner</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
@Component
public class DataInitializer implements ApplicationRunner {
    private FileLoader fileLoader;
    public DataInitializer(FileLoader fileLoader) {
        this.fileLoader = fileLoader;
    }
    @Override
    public void run(ApplicationArguments args) throws Exception {
        fileLoader.loadFile();
    }
}</pre></li>				<li>Modify the <strong class="source-inline">application.yml</strong> file in the <span class="No-Break"><strong class="source-inline">resources</strong></span><span class="No-Break"> folder:</span><ol><li class="upper-roman">Add a setting that provides a path to the folder containing the file <span class="No-Break">to load:</span></li></ol><pre class="source-code">
football:
    folder: teams</pre><ol><li class="upper-roman" value="2">Add the new <span class="No-Break">Actuator endpoint:</span></li></ol><pre class="source-code">management:
    endpoints:
        web:
            exposure:
                include: health,env,metrics,beans,loggers,<strong class="bold">football</strong></pre></li>				<li>Finally, create a folder<a id="_idIndexMarker257"/> named <strong class="source-inline">teams</strong> in the root of the project and a file named <strong class="source-inline">1.0.0.json</strong>. As content, add an array containing teams – for example, <strong class="source-inline">[ "Argentina", "</strong><span class="No-Break"><strong class="source-inline">Australia", "Brazil"]</strong></span><span class="No-Break">.</span></li>
				<li>Create a sample RESTful controller that returns the content that’s loaded in memory by the <span class="No-Break"><strong class="source-inline">FileLoader</strong></span><span class="No-Break"> class:</span><pre class="source-code">
@RestController
@RequestMapping("/football")
public class FootballController {
    private FileLoader fileLoader;
    public FootballController(FileLoader fileLoader){
        this.fileLoader = fileLoader;
    }
    @GetMapping
    public List&lt;String&gt; getTeams(){
        return fileLoader.getTeams();
    }
}</pre></li>				<li>The service is now ready to test. Execute the application and perform the <span class="No-Break">following requests:</span><ol><li class="upper-roman">Get the current file version using the custom Actuator endpoint. For that, open your terminal and execute the following <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> request:</span></li></ol><pre class="source-code">
curl http://localhost:8080/actuator/football</pre><ol><li class="upper-roman" value="2">You will receive the filename as a response – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">teams/1.0.0.json</strong></span><span class="No-Break">.</span></li><li class="upper-roman">Let’s create a new version<a id="_idIndexMarker258"/> of the file. Rename the file <strong class="source-inline">1.0.1.json</strong> and add a new element to the <strong class="source-inline">teams</strong> array, <span class="No-Break">like so:</span></li></ol><pre class="source-code">[ "Senegal", "Argentina", "Australia", "Brazil"]</pre><ol><li class="upper-roman" value="4">Now, use the custom Actuator endpoint to refresh the file in the application. For that, in your terminal, execute the following <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> request:</span></li></ol><pre class="source-code">curl --request POST http://localhost:8080/actuator/football</pre><ol><li class="upper-roman" value="5">Check the current file version again; you will now <span class="No-Break">get </span><span class="No-Break"><strong class="source-inline">teams/1.0.</strong></span><span class="No-Break"><strong class="bold">1</strong></span><span class="No-Break"><strong class="source-inline">.json</strong></span><span class="No-Break">.</span></li><li class="upper-roman">You can also use a RESTful API to validate that the results correspond with the content of <span class="No-Break">the file.</span></li></ol></li>			</ol>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor115"/>How it works…</h2>
			<p>By creating a bean with the <strong class="source-inline">@Endpoint</strong> annotation, Actuator exposes all methods annotated with <strong class="source-inline">@ReadOperation</strong>, <strong class="source-inline">@WriteOperation</strong>, and <strong class="source-inline">@DeleteOperation</strong> over JMX and HTTP. This example is not much different from a regular RESTful endpoint, but the purpose is different as it’s used to manage the application or library you developed. Of course, you can implement your custom Actuator endpoint, but usually, Actuator endpoints are provided as part of a component that is used by others and may require some internal information or behavior to be exposed. For instance, database drivers such as PostgreSQL, database connection pool managers such as HikariCP, and caching systems such as Redis usually provide Actuator endpoints. If you plan to create some kind of system or library that will be used by others and you are interested in exposing some internals to facilitate management in runtime, Actuator endpoints are a <span class="No-Break">great solution.</span></p>
			<p>An <strong class="source-inline">ApplicationRunner</strong> is a component that is executed right after the application starts. When Spring Boot executes, the <strong class="source-inline">ApplicationRunner</strong> isn’t ready to accept requests yet. You can define more than one <strong class="source-inline">ApplicationRunner</strong>. Once all the <strong class="source-inline">ApplicationRunner</strong> components<a id="_idIndexMarker259"/> are executed, the application is ready to <span class="No-Break">accept requests.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor116"/>Using probes and creating a custom health check</h1>
			<p>Your new football trading service<a id="_idIndexMarker260"/> is getting readily<a id="_idIndexMarker261"/> adopted by football fans. This service is used to exchange stickers with football players’ pictures on them between fans. To accelerate the process, the service caches some data in the application’s memory. You need to ensure that the cache is filled before you start <span class="No-Break">serving requests.</span></p>
			<p>Under normal conditions, the football trading service works fine; however, under heavy load, the application instances start degrading and after some instability, they end up being unresponsive. To counteract this, you prepare some stress tests in the lab environment. However, you realize that the application starts degrading because you have issues connecting to the database. At the same time, you realize that those kinds of issues happen when the application has more than 90 pending orders. While you find a definitive solution, you decide to expose when the application is unable to process more requests and create a health check that verifies if it can connect to <span class="No-Break">the database.</span></p>
			<p>Probes are mostly used by container orchestrators, such as Kubernetes, to verify that the application is ready to accept requests and when it is already <a id="_idIndexMarker262"/>working to indicate that it’s alive. In Kubernetes, they are known as readiness and <span class="No-Break">liveness probes.</span></p>
			<p>A health check is a mechanism to verify that the application has everything ready to work – for instance, it’s able to connect to <span class="No-Break">a database.</span></p>
			<p>In this recipe, you will learn how to expose a readiness check, how to change your liveness state, and how to create a custom health check that can be used by the hosting platform or a monitoring system to determine the health of your application instances and when your application is ready to <span class="No-Break">accept requests.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor117"/>Getting ready</h2>
			<p>In this recipe, you will reuse<a id="_idIndexMarker263"/> the application you created<a id="_idIndexMarker264"/> in the <em class="italic">Creating a custom Actuator endpoint</em> recipe. I’ve prepared a working version in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-3/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>In this recipe, you will verify that the application can connect to the application database. We’ll use PostgreSQL as a database. To run PostgreSQL locally, we’ll use Docker. You can download and start the database just by executing the following command in <span class="No-Break">your terminal:</span></p>
			<pre class="console">
docker run -e POSTGRES_USER=packt -e POSTGRES_PASSWORD=packt -p 5432:5432 --name postgresql postgres</pre>			<p>If you created any database in <a href="B21646_05.xhtml#_idTextAnchor203"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, you can reuse it here. This recipe doesn’t perform any real queries – it just verifies it can connect. If you don’t have a database created<a id="_idIndexMarker265"/> in the container, you can create a database using the <strong class="bold">psql</strong> tool. For that, execute the following command in <span class="No-Break">your terminal:</span></p>
			<pre class="console">
psql -h localhost -U packt</pre>			<p>You will be prompted for a password. Specify <strong class="source-inline">packt</strong> and press <strong class="bold">intro</strong>. You will be connected to a PostgreSQL terminal. Execute the following command to create <span class="No-Break">a database:</span></p>
			<pre class="console">
CREATE DATABASE football;</pre>			<p>Now, you can exit the database by executing the <span class="No-Break"><strong class="source-inline">quit;</strong></span><span class="No-Break"> command.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor118"/>How to do it…</h2>
			<p>In this recipe, you’ll configure your application so that it can manage probes and create a custom health check to verify that the application can connect to <span class="No-Break">the database:</span></p>
			<ol>
				<li>Start by updating the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder so that it can enable readiness and liveness probes. For that, include <span class="No-Break">the following:</span><pre class="source-code">
management:
    endpoint:
        health:
            probes:
                enabled: true</pre></li>				<li>Next, create a class<a id="_idIndexMarker266"/> that emulates the football trading<a id="_idIndexMarker267"/> service. Name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">TradingService</strong></span><span class="No-Break">:</span><pre class="source-code">
@Service
public class TradingService {
}</pre><p class="list-inset">This class will manage the trading requests. When trading a request, if it detects that there are more than 90 pending orders, it will notify you that the application cannot manage more requests. For that, it will use <strong class="source-inline">ApplicationEventPublisher</strong>, which will be injected into <span class="No-Break">the constructor:</span></p><pre class="source-code">private ApplicationEventPublisher applicationEventPublisher;
public TradingService(ApplicationEventPublisher applicationEventPublisher) {
    this.applicationEventPublisher = applicationEventPublisher;
}</pre><p class="list-inset">Next, define a method that returns the number of pending orders. We’ll simulate this by returning a random number between 0 <span class="No-Break">and 100:</span></p><pre class="source-code">public int getPendingOrders() {
    Random random = new Random();
    return random.nextInt(100);
}</pre><p class="list-inset">Finally, you can create a method that manages the trading operations. If there are more than 90 pending orders, it will change the state of <span class="No-Break">the application:</span></p><pre class="source-code">public int tradeCards(int orders) {
    if (getPendingOrders() &gt; 90) {
        AvailabilityChangeEvent.publish(applicationEventPublisher, new Exception("There are more than 90 pending orders"), LivenessState.BROKEN);
    } else {
        AvailabilityChangeEvent.publish(applicationEventPublisher, new Exception("working fine"), LivenessState.CORRECT);
    }
    return orders;
}</pre></li>				<li>Now, configure the connection to <span class="No-Break">the database:</span><ol><li class="upper-roman">Add Spring Data JDBC<a id="_idIndexMarker268"/> and PostgreSQL<a id="_idIndexMarker269"/> dependencies. For that, in the <strong class="source-inline">pom.xml</strong> file, add the <span class="No-Break">following dependencies:</span></li></ol><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</pre><ol><li class="upper-roman" value="2">Add the following configuration to the <strong class="source-inline">application.yml</strong> file in the <span class="No-Break"><strong class="source-inline">resources</strong></span><span class="No-Break"> folder:</span></li></ol><pre class="source-code">spring:
    datasource:
        url: jdbc:postgresql://localhost:5432/football
        username: packt
        password: packt</pre></li>				<li>Now, let’s create a <span class="No-Break">health indicator:</span><ol><li class="upper-roman">For that, create<a id="_idIndexMarker270"/> a class named <strong class="source-inline">FootballHealthIndicator</strong> that implements<a id="_idIndexMarker271"/> the <span class="No-Break"><strong class="source-inline">HealthIndicator</strong></span><span class="No-Break"> interface:</span></li></ol><pre class="source-code">
@Component
public class FootballHealthIndicator implements HealthIndicator {
}</pre><ol><li class="upper-roman" value="2">As it will connect to the database, inject <strong class="source-inline">JdbcTemplate</strong> into <span class="No-Break">the constructor:</span></li></ol><pre class="source-code">private JdbcTemplate template;
public FootballHealthIndicator(JdbcTemplate template) {
    this.template = template;
}</pre><ol><li class="upper-roman" value="3">Now, override the health method so that you can perform <span class="No-Break">connectivity checking:</span></li></ol><pre class="source-code">@Override
public Health health() {
    try {
        template.execute("SELECT 1");
        return Health.up().build();
    } catch (DataAccessException e) {
    return Health.down().withDetail("Cannot connect to database", e).build();
    }
}</pre></li>				<li>Before testing<a id="_idIndexMarker272"/> the application, you can modify the <strong class="source-inline">FileLoader</strong> class, simulating<a id="_idIndexMarker273"/> it so that it takes a few seconds to load the file. You can do this by modifying the <strong class="source-inline">loadFile</strong> method by adding the following code. This will make the application wait 10 seconds before it loads <span class="No-Break">the file:</span><pre class="source-code">
try {
    Thread.sleep(10000);
} catch (InterruptedException e) {
    e.printStackTrace();
}</pre></li>				<li>Now, let’s test the <span class="No-Break">application’s readiness:</span><ol><li class="upper-roman">Before running the application, execute the following command in <span class="No-Break">your terminal:</span></li></ol><pre class="source-code">
watch curl http://localhost:8080/actuator/health/readiness</pre><p class="list-inset">This command will execute a request to the readiness probe <span class="No-Break">every second.</span></p><ol><li class="upper-roman" value="2">Start the application. You will see that the output of the <strong class="source-inline">watch</strong> command changes. First, it will appear <span class="No-Break">as </span><span class="No-Break"><strong class="bold">OUT_OF_SERVICE</strong></span><span class="No-Break">:</span></li></ol></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer044">
					<img alt="Figure 3.1: Readiness status set to OUT_OF_SERVICE" src="image/B21646_03_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Readiness status set to OUT_OF_SERVICE</p>
			<ol>
				<li class="upper-roman" value="3">After 10 seconds<a id="_idIndexMarker274"/> or the time you<a id="_idIndexMarker275"/> configured in <em class="italic">Step 5</em>, it will change <span class="No-Break">to </span><span class="No-Break"><strong class="bold">UP</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 3.2: Readiness status changed to UP" src="image/B21646_03_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Readiness status changed to UP</p>
			<ol>
				<li value="7">Now, test the <span class="No-Break">application’s liveness:</span><ol><li class="upper-roman">Again, execute a <strong class="source-inline">watch</strong> command, but this time, make requests to the liveness <span class="No-Break">probe’s endpoint:</span></li></ol><pre class="source-code">
watch curl http://localhost:8080/actuator/health/readiness</pre><p class="list-inset">You will see that the status <span class="No-Break">is </span><span class="No-Break"><strong class="bold">UP</strong></span><span class="No-Break">.</span></p><ol><li class="upper-roman" value="2">Let’s start using the trading endpoint. Run another watcher that executes trading requests. For that, execute the following command in a <span class="No-Break">new terminal:</span></li></ol><pre class="source-code">watch -n 1 -x curl --request POST -H "Content-Type: application/json" --data "1" http://localhost:8080/football</pre><p class="list-inset">Remember that if there are more than 90 pending requests, it will mark itself as failing. Since a random number between 0 and 100 is selected, there’s a 10% possibility it <span class="No-Break">will fail.</span></p><p class="list-inset">You will see that the readiness<a id="_idIndexMarker276"/> endpoint returns <strong class="bold">DOWN</strong> from time<a id="_idIndexMarker277"/> <span class="No-Break">to time.</span></p></li>				<li>Finally, test the health <span class="No-Break">check endpoint:</span><ol><li class="upper-roman">Execute a <strong class="source-inline">watch</strong> command for the Actuator <span class="No-Break">health endpoint:</span></li></ol><pre class="source-code">
watch curl http://localhost:8080/actuator/health</pre><ol><li class="upper-roman" value="2">it will return <strong class="bold">UP</strong> every time. To verify that it detects when it cannot connect to the database, stop the PostgreSQL container. To do so, run the <span class="No-Break">following command:</span></li></ol><pre class="source-code">docker stop postgresql</pre><p class="list-inset">You will see that the Actuator endpoint will take longer to respond and that the response will <span class="No-Break">be </span><span class="No-Break"><strong class="bold">DOWN</strong></span><span class="No-Break">.</span></p></li>			</ol>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor119"/>How it works…</h2>
			<p>Readiness and liveness probes are enabled automatically when Spring Boot detects it’s running on Kubernetes, but you can enable them manually. In this recipe, we enabled them explicitly, but if you run the application on Kubernetes, this will be <span class="No-Break">done automatically.</span></p>
			<p>Readiness and liveness probes should not check any external component. They should verify that the application is ready internally and that it’s capable of responding. On the other hand, health checks should verify that all dependent components <span class="No-Break">are available.</span></p>
			<p>The Spring Boot application life cycle goes through different states, and it generates events every time it changes its state. I won’t explain all possible application states here; instead, I’ll focus on the relevant states during readiness probes. The first state is <strong class="source-inline">starting</strong>. Once Spring Boot initializes the components, it changes to <strong class="source-inline">started</strong>. At this point, it’s not ready yet, so it needs to run all <strong class="source-inline">ApplicationRunner</strong> and <strong class="source-inline">CommandLineRunner</strong> instances defined in the application. Once all of them are executed, it changes to <strong class="source-inline">ready</strong>. In this recipe, we introduced a delay of 10 seconds in the <strong class="source-inline">loadFile</strong> method. During this period, the readiness status was <strong class="bold">OUT_OF_SERVICE</strong>. Once it had loaded the file, it changed <span class="No-Break">to </span><span class="No-Break"><strong class="bold">UP</strong></span><span class="No-Break">.</span></p>
			<p>If you want to learn more, take a look at the following Spring Boot <span class="No-Break">documentation: </span><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners"><span class="No-Break">https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners</span></a><span class="No-Break">.</span></p>
			<p>Be careful while checking other components. First, if it is another service, such as the one we created in this recipe, it will likely also have probes and health checks. Checking this via your service can be redundant. Second, try to make light checks; otherwise, you may generate too much load, which can cause performance issues. In this recipe, the SQL command we used was <strong class="source-inline">SELECT 1</strong>. This command connects to the database but doesn’t require computing<a id="_idIndexMarker278"/> resources from the database<a id="_idIndexMarker279"/> engine out of the <span class="No-Break">connection itself.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor120"/>See also</h2>
			<p>Health checks should not necessarily imply that you check the health of all the dependencies of your application. Rather, you should check if your application has any problems that could be solved by reducing the load or by rebooting. If your application depends on an unresponsive service and you mark your application as unhealthy, the application instance will be restarted. However, if your problem is in another application, the problem won’t disappear, and the application will be restarted again and again without solving the problem. For that kind of scenario, consider implementing a <em class="italic">circuit breaker</em> solution. See <a href="https://spring.io/guides/gs/cloud-circuit-breaker/">https://spring.io/guides/gs/cloud-circuit-breaker/</a> for guidance<a id="_idIndexMarker280"/> on how to implement this using <span class="No-Break">Spring Cloud.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor121"/>Implementing distributed tracing</h1>
			<p>So far, you’ve created a solution<a id="_idIndexMarker281"/> with two microservices, the football trading microservice and the client microservice. Among other features, the trading microservice provides the ranking of players. The client microservice enhances the list of players by adding the ranking that was obtained from the <span class="No-Break">trading microservice.</span></p>
			<p>Distributed tracing emerges as a crucial tool as it offers a systematic approach to monitoring, analyzing, and optimizing the flow of requests between microservices. Distributed tracing is a method of monitoring and visualizing the flow of requests as they propagate through various components of a distributed system, providing insights into performance, latency, and dependencies <span class="No-Break">between services.</span></p>
			<p>In this recipe, you will learn how to enable distributed tracing for your microservices, export the data to Zipkin, and access <span class="No-Break">the results.</span></p>
			<p>Zipkin is an open source distributed tracing<a id="_idIndexMarker282"/> system that helps developers trace, monitor, and visualize the paths of requests as they travel through various microservices in a distributed system, providing valuable insights into performance and dependencies. What you will learn about Zipkin in this recipe can be easily adapted to <span class="No-Break">other tools.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor122"/>Getting ready</h2>
			<p>In this recipe, we’ll visualize the traces using Zipkin. You can deploy it on your computer using Docker. For that, open your terminal and execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
docker run -d -p 9411:9411 openzipkin/zipkin</pre>			<p>The preceding command will download an image with an OpenZipkin server, if you don’t have one already, and start <span class="No-Break">the server.</span></p>
			<p>We’ll reuse the trading service we created in the <em class="italic">Using probes and creating a custom health check</em> recipe. If you haven’t completed it yet, don’t worry – I’ve prepared a working version in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-4/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/>How to do it…</h2>
			<p>Let’s enable distributed tracing in the existing trading service and create the new client service. For the new client service, we’ll need to ensure that distributed tracing is enabled as well. Before starting, ensure that your OpenZipkin server is running, as explained in the <em class="italic">Getting </em><span class="No-Break"><em class="italic">ready</em></span><span class="No-Break"> section:</span></p>
			<ol>
				<li>Start by enabling distributed tracing in the trading microservice you created in the <em class="italic">Using probes and creating a custom health </em><span class="No-Break"><em class="italic">check</em></span><span class="No-Break"> recipe:</span><ol><li class="upper-roman">For that, open the <strong class="source-inline">pom.xml</strong> file and add<a id="_idIndexMarker283"/> the <span class="No-Break">following dependencies:</span></li></ol><pre class="source-code">
&lt;dependency&gt;
   &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
   &lt;artifactId&gt;micrometer-tracing-bridge-otel&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;
   &lt;artifactId&gt;opentelemetry-exporter-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><ol><li class="upper-roman" value="2">The first dependency<a id="_idIndexMarker284"/> is a bridge between <strong class="bold">Micrometer</strong> and <strong class="bold">OpenTelemetry</strong>. The second dependency<a id="_idIndexMarker285"/> is an exporter<a id="_idIndexMarker286"/> from OpenTelemetry to <strong class="bold">Zipkin</strong>. I’ll explain this in more detail in the <em class="italic">How it </em><span class="No-Break"><em class="italic">works…</em></span><span class="No-Break"> section.</span></li><li class="upper-roman">Now the application can send the traces to Zipkin. However, before running the application, you’ll need to make some adjustments. Open the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and add the <span class="No-Break">following setting:</span></li></ol><pre class="source-code">management
    tracing:
        sampling:
            probability: 1.0</pre><ol><li class="upper-roman" value="4">By default, sampling is only set to 10%. This means that only 10% of traces are sent. With this change, you will send 100% of <span class="No-Break">the traces.</span></li><li class="upper-roman">In the same <strong class="source-inline">application.yml</strong> file, add the <span class="No-Break">following configuration:</span></li></ol><pre class="source-code">spring:
    application:
        name: trading-service</pre><p class="list-inset">This change is not mandatory but helps identify the service in <span class="No-Break">distributed tracing.</span></p></li>				<li>Next, create the ranking<a id="_idIndexMarker287"/> endpoint in the football trading microservice that will be consumed by the client microservice. For that, in <strong class="source-inline">FootballController</strong>, create the <span class="No-Break">following method:</span><pre class="source-code">
@GetMapping("ranking/{player}")
public int getRanking(@PathVariable String player) {
    logger.info(«Preparing ranking for player {}», player);
    if (random.nextInt(100) &gt; 97) {
        throw new RuntimeException("It's not possible to get the ranking for player " + player
              + " at this moment. Please try again later.");
    }
    return random.nextInt(1000);
}</pre><p class="list-inset">To simulate random errors, this method throws an exception when a random number from 0 to 99 is greater than 97 – that is, 2% of <span class="No-Break">the time.</span></p></li>				<li>Next, create a new application that will act as the client application. As usual, you can create the template using the <em class="italic">Spring </em><span class="No-Break"><em class="italic">Initializr</em></span><span class="No-Break"> tool:</span><ul><li>Open <a href="https://start.spring.io">https://start.spring.io</a> and use the same parameters that you did in the <em class="italic">Creating a RESTful API</em> recipe of <a href="B21646_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, except change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">fooballclient</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong> and <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Boot Actuator</strong></span></li></ul></li><li>Add dependencies for OpenTelemetry<a id="_idIndexMarker288"/> and Zipkin, as you did for the football trading service application. So, open the <strong class="source-inline">pom.xml</strong> file and add the <span class="No-Break">following dependencies:</span><pre class="source-code">
&lt;dependency&gt;
   &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
   &lt;artifactId&gt;micrometer-tracing-bridge-otel&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;
   &lt;artifactId&gt;opentelemetry-exporter-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li></ul></li>				<li>In the client application, add a <span class="No-Break">RESTful controller:</span><ol><li class="upper-roman">Name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">PlayersController</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
@RestController
@RequestMapping("/players")
public class PlayersController {
}</pre><ol><li class="upper-roman" value="2">This application must call the trading<a id="_idIndexMarker289"/> service. For that, it will use <strong class="source-inline">RestTemplate</strong>. To achieve the correlation between service calls, you should use <strong class="source-inline">RestTemplateBuilder</strong> to create <strong class="source-inline">RestTemplate</strong>. Then, inject <strong class="source-inline">RestTemplateBuilder</strong> into the <span class="No-Break">controller’s constructor:</span></li></ol><pre class="source-code">private RestTemplate restTemplate;
public PlayersController(RestTemplateBuilder restTemplateBuilder) {
   this.restTemplate = <strong class="bold">restTemplateBuilder.build();</strong>
}</pre><ol><li class="upper-roman" value="3">Now, you can create the controller method that calls the trading service of the <span class="No-Break">other application:</span></li></ol><pre class="source-code">@GetMapping
public List&lt;PlayerRanking&gt; getPlayers() {
   String url = "http://localhost:8080/football/ranking";
   List&lt;String&gt; players = List.of("Aitana Bonmatí", "Alexia Putellas", "Andrea Falcón");
   return players.stream().map(player -&gt; {
      int ranking = <strong class="bold">this.restTemplate</strong>.getForObject(url + "/" + player, int.class);
      return new PlayerRanking(player, ranking);
   }).collect(Collectors.toList());
}</pre></li>				<li>Configure client application tracing in the <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
management:
    tracing:
        <strong class="bold">sampling:</strong>
<strong class="bold">            probability: 1.0</strong>
spring:
    application:
        name: football-client</pre><p class="list-inset">As you did in the trading<a id="_idIndexMarker290"/> service, you should set <strong class="source-inline">sampling</strong> to <strong class="source-inline">1.0</strong> so that 100% of the traces will be recorded. To distinguish the client application from the trading service application, set the <strong class="source-inline">spring.application.name</strong> property <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">football-client</strong></span><span class="No-Break">.</span></p></li>				<li>To avoid port conflicts with the trading application, configure the client application so that it uses port <strong class="source-inline">8090</strong>. To do that, add the following parameter to the <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
server:
  port: 8090</pre></li>				<li>Now, you can test the application. Call the client application; it will make multiple calls to the trading service. To make continuous requests to the client application, you can execute the following command in <span class="No-Break">your terminal:</span><pre class="source-code">
watch curl http://localhost:8090/players</pre></li>				<li>Finally, open Zipkin to see the traces. For that, go to <strong class="source-inline">http://localhost:9411/</strong> in <span class="No-Break">your browser:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Figure 3.3: The Zipkin home page" src="image/B21646_03_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: The Zipkin home page</p>
			<p class="list-inset">On the home page, click <strong class="bold">RUN QUERY</strong> to see the traces<a id="_idIndexMarker291"/> that have <span class="No-Break">been generated:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 3.4: Root traces in Zipkin" src="image/B21646_03_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Root traces in Zipkin</p>
			<p class="list-inset">On this page, you will see that the traces from the client application are root traces. Since we introduced a random error, you will see that there are failed and successful traces. If you click the <strong class="bold">SHOW</strong> button for any of these traces, you will see the traces of both RESTful APIs. There will be a main request for the client service and nested requests<a id="_idIndexMarker292"/> for the <span class="No-Break">trading service:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 3.5: Trace details, including nested traces" src="image/B21646_03_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: Trace details, including nested traces</p>
			<p class="list-inset">You can also view the dependencies<a id="_idIndexMarker293"/> between services by clicking on the <strong class="bold">Dependencies</strong> link on the <span class="No-Break">top bar:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer049">
					<img alt="Figure 3.6: Viewing the dependencies between services in Zipkin" src="image/B21646_03_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Viewing the dependencies between services in Zipkin</p>
			<p class="list-inset">Here, you can see the dependencies between the <strong class="source-inline">football-client</strong> application and the <span class="No-Break"><strong class="source-inline">trading-service</strong></span><span class="No-Break"> application.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor124"/>How it works…</h2>
			<p><em class="italic">Micrometer</em> is a library<a id="_idIndexMarker294"/> that allows you to instrument your application without dependencies with specific vendors. This means that your code won’t change if you decide to use another tool, such as <em class="italic">Wavefront</em>, instead <span class="No-Break">of Zipkin.</span></p>
			<p>The <strong class="source-inline">io.micrometer:micrometer-tracing-bridge-otel</strong> dependency creates a bridge between <em class="italic">Micrometer</em> and <em class="italic">OpenTelemetry</em>, after which the <strong class="source-inline">io.opentelemetry: opentelemetry-exporter-zipkin</strong> dependency exports from <em class="italic">OpenTelemetry</em> to <em class="italic">Zipkin</em>. If you want to use another tool to monitor your traces, you just need to change these dependencies, without any additional <span class="No-Break">code changes.</span></p>
			<p>The default address to send traces to Zipkin is <strong class="source-inline">http://localhost:9411</strong>. That’s why we didn’t need to configure it explicitly. In a production environment, you can use the <span class="No-Break"><strong class="source-inline">management.zipkin.tracing.endpoint</strong></span><span class="No-Break"> property.</span></p>
			<p>In this recipe, we used <strong class="source-inline">RestTemplateBuilder</strong>. This is important as it configures <strong class="source-inline">RestTemplate</strong> by adding the tracing headers to the outgoing requests. Then, the target service gathers the tracing headers that can be used to nest the traces in the called application to the root trace from the client application. In reactive applications, you should use <strong class="source-inline">WebClient.Builder</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RestTemplateBuilder</strong></span><span class="No-Break">.</span></p>
			<p>In this recipe, we configured 100% sampling. This means that we send all traces to the tracing server. We did this for learning purposes; normally, you shouldn’t do this in production as you can overload the tracing server by, for example, deploying a server via Zipkin or ingesting a lot of data if you’re using a managed service in the cloud. The amount of data that’s ingested directly affects monitoring systems – that is, the more data you ingest, the more it will cost you. However, even if you deploy your own tracing server, you will need to scale up as well. So, either way, it can increase your overall cost. In a large-scale system, having a sampling rate of 10% is more than enough to detect issues between services as well as understand the dependencies between <span class="No-Break">the components.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor125"/>There’s more…</h2>
			<p>Micrometer tracing creates spans – that is, units<a id="_idIndexMarker295"/> of work or segments of a distributed trace that represent the execution of a specific operation, for each request. Spans capture information about the duration, context, and any associated metadata related to the <span class="No-Break">respective operation.</span></p>
			<p>You can create a span by starting<a id="_idIndexMarker296"/> an observation using the <strong class="source-inline">ObservationRegistry</strong> component. For instance, say <strong class="source-inline">TradingService</strong> has different important parts that you want to trace, such as <em class="italic">Collect data</em> and <em class="italic">Process data</em>. You can create different spans for those in <span class="No-Break">your code.</span></p>
			<p>To implement this, you will need to inject <strong class="source-inline">ObservationRegistry</strong> into your controller using the Spring Boot dependency container. For that, you need to define the <strong class="source-inline">ObservationRegistry</strong> parameter in the <span class="No-Break">controller’s constructor:</span></p>
			<pre class="source-code">
private final ObservationRegistry observationRegistry;
public FootballController(ObservationRegistry observationRegistry) {
        this.observationRegistry = observationRegistry;
}</pre>			<p>Then, you must create the observations in <span class="No-Break">the code:</span></p>
			<pre class="source-code">
@GetMapping("ranking/{player}")
public int getRanking(@PathVariable String player) {
   Observation collectObservation = <strong class="bold">Observation.createNotStarted("collect", observationRegistry);</strong>
<strong class="bold">   collectObservation.lowCardinalityKeyValue("player", player);</strong>
   <strong class="bold">collectObservation.observe</strong>(() -&gt; {
      try {
          logger.info("Simulate a data collection for player {}", player);
          Thread.sleep(random.nextInt(1000));
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
   });
   Observation processObservation = <strong class="bold">Observation.createNotStarted("process", observationRegistry);</strong>
   <strong class="bold">processObservation.lowCardinalityKeyValue("player", player);</strong>
   <strong class="bold">processObservation.observe</strong>(() -&gt; {
            try {
                logger.info("Simulate a data processing for player {}", player);
                Thread.sleep(random.nextInt(1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        return random.nextInt(1000);
    }</pre>			<p>Note that the observations include the player with <strong class="source-inline">lowCardinalityKeyValue</strong> to facilitate finding spans through <span class="No-Break">this data.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some parts of the code have been removed for brevity. You can find the full version in this book’s GitHub repository <span class="No-Break">at </span><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</span><span class="No-Break">.</span></p>
			<p>Now, in Zipkin, you can see the<a id="_idIndexMarker297"/> custom spans nested <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">trading-service</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer050">
					<img alt="Figure 3.7: Custom spans in Zipkin" src="image/B21646_03_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Custom spans in Zipkin</p>
			<p>The <strong class="source-inline">trading-service</strong> span contains two nested spans, and both have a custom tag that specifies the <span class="No-Break">player’s name.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor126"/>Accessing standard metrics</h1>
			<p>Your Football Trading service <a id="_idIndexMarker298"/>continues to grow by being adopted by football fans. You need to understand how it performs better so that you can adapt to demand while optimizing the resources that are used to provide <span class="No-Break">the service.</span></p>
			<p>You can use the standard metrics provided by Spring Boot Actuator and its related components for real-time insights into your application’s behavior. For instance, you can find out how much CPU and memory has been used<a id="_idIndexMarker299"/> by your application or the time spent in <strong class="bold">garbage collection</strong> (<strong class="bold">GC</strong>). These are the basic metrics that give you a general understanding of the performance of <span class="No-Break">the application.</span></p>
			<p>Other metrics are more subtle, such as the metrics provided by the web container, Tomcat – for instance, the number of active sessions, the number of sessions rejected, and the number of sessions that have expired. Similarly, the database connection pool, which is <strong class="source-inline">hikaricp</strong> by default, also exposes some metrics. For instance, you can view the number of active sessions, the number of waiting sessions, or the number of sessions that have been rejected. These types of metrics can be an indicator of problems in your application that aren’t easy to detect just by using classic metrics such as CPU and <span class="No-Break">memory utilization.</span></p>
			<p>In this recipe, you will learn how to access standard metrics<a id="_idIndexMarker300"/> and how to detect some common application issues. You will also learn how to perform a load test using JMeter, but it’s not the main purpose of <span class="No-Break">this recipe.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor127"/>Getting ready</h2>
			<p>In this recipe, you will reuse the applications you created in the <em class="italic">Implementing distributed tracing</em> recipe. If you haven’t completed that recipe yet, I’ve prepared a working version that you can find in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/, in the <strong class="source-inline">chapter3/recipe3-5/start</strong> folder. These applications depend on PostgreSQL and also export activities to Zipkin, as explained in the previous recipe. Both PostgreSQL and Zipkin can be run locally <span class="No-Break">using Docker.</span></p>
			<p>In this recipe, we’ll perform some load tests using JMeter, a popular load-testing tool. You can download JMeter from the project website at <a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a>. Here, you can download a ZIP file containing JMeter binaries and unzip it; no further installation is required. To run JMeter, go to the folder where you unzipped the binaries and open the <strong class="source-inline">bin</strong> folder. Here, you will find different scripts to launch JMeter, depending on your operating system. For Unix-based operating systems, you can run the <strong class="source-inline">jmeter.sh</strong> script, while for Windows, you can run the <span class="No-Break"><strong class="source-inline">jmeter.bat</strong></span><span class="No-Break"> script.</span></p>
			<p>I’ve created two JMeter scripts to create some load against the application. You can find them in this book’s GitHub repository, in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-5/jmeter</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor128"/>How to do it…</h2>
			<p>In this recipe, we’ll use the JMeter<a id="_idIndexMarker301"/> scripts mentioned in the <em class="italic">Getting ready</em> section to generate a workload for the football application. Then, we’ll observe the metrics provided by Spring Boot and its related components. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Before running the first load test, ensure that the trading application is running and the <strong class="source-inline">metrics</strong> endpoint is exposed. As explained in the <em class="italic">Adding Actuator to your application</em> recipe, this can be done by adding the <strong class="source-inline">metrics</strong> value to the <strong class="source-inline">management.endpoints.web.exposure.include</strong> parameter. If you followed the previous recipes or used the working version I’ve prepared, as explained in the <em class="italic">Getting ready</em> section, the <strong class="source-inline">application.yml</strong> file should look <span class="No-Break">like this:</span><pre class="source-code">
management:
    endpoints:
        web:
            exposure:
                include: health,env,<strong class="bold">metrics</strong>,beans,loggers,football</pre></li>				<li>Once the application is running, open JMeter and load the <strong class="source-inline">loadTeams.jmx</strong> script. You can find it in the <strong class="source-inline">chapter3/recipe3-5/jmeter</strong> folder, as explained in the <em class="italic">Getting ready</em> section. This script makes a request to the application’s <strong class="source-inline">/football</strong> path and returns a list of teams. This process is executed by 30 <span class="No-Break">threads infinitely.</span><p class="list-inset">You can adjust some parameters of the load tests depending on the resources of your development computer. For instance, I used 30 threads to overload my computer, but maybe you need more or even fewer threads <span class="No-Break">than that:</span></p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer051">
					<img alt="Figure 3.8: The number of threads in JMeter" src="image/B21646_03_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: The number of threads in JMeter</p>
			<p class="list-inset">If you want to adjust the number of threads, click <strong class="bold">Main Thread Group</strong> and adjust <strong class="bold">Number of </strong><span class="No-Break"><strong class="bold">Threads (users)</strong></span><span class="No-Break">.</span></p>
			<p class="list-inset">Once the application<a id="_idIndexMarker302"/> is ready, you can run the <span class="No-Break">JMeter script.</span></p>
			<ol>
				<li value="3">Let’s observe the metrics of the application. Go to <strong class="source-inline">http://localhost:8080/actuator/metrics</strong> to see the full list of exposed metrics. You can get any of these metrics by appending the metric’s name to the <strong class="source-inline">/actuator/metrics</strong> path. Typically, you will get the CPU and <span class="No-Break">memory-related counters:</span><ul><li>With <strong class="source-inline">http://localhost:8080/actuator/metrics/process.cpu.usage</strong>, you will get the percentage of CPU being used by the <span class="No-Break">application process</span></li><li>With http://localhost:8080/actuator/metrics/system.cpu.usage, you will get the percentage of CPU being used by <span class="No-Break">the system</span></li><li>With <strong class="source-inline">http://localhost:8080/actuator/metrics/jvm.memory.used</strong> you will get the amount of memory being used by <span class="No-Break">your application</span></li></ul><p class="list-inset">As an example, the result of the <strong class="source-inline">process.cpu.usage</strong> metric looks <span class="No-Break">like this:</span></p><pre class="source-code">
{
    "name": "system.cpu.usage",
    "description": "The \"recent cpu usage\" of the system the application is running in",
    "measurements": [
        {
            "statistic": "VALUE",
            <strong class="bold">"value": 0.48494983277591974</strong>
        }
    ],
    "availableTags": []
}</pre></li>				<li>Stop the test – you need to create<a id="_idIndexMarker303"/> a new endpoint to access the database. For that, follow <span class="No-Break">these steps:</span><ol><li class="upper-roman">Create a new <strong class="source-inline">DataService</strong> class and inject <strong class="source-inline">JdbcTemplate</strong> into <span class="No-Break">the constructor:</span></li></ol><pre class="source-code">
@Service
public class DataService {
    private JdbcTemplate jdbcTemplate;
    public DataService(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
}</pre><ol><li class="upper-roman" value="2">Now, create a method that makes a call to the database. To simulate a slow database query, you can use the <strong class="source-inline">pg_sleep</strong> PostgreSQL command. This command waits for a given number of seconds or fraction <span class="No-Break">of seconds:</span></li></ol><pre class="source-code">public String getPlayerStats(String player) {
    Random random = new Random();
    jdbcTemplate.execute("SELECT pg_sleep(" + random.nextDouble(1.0) + ")");
    return "some complex stats for player " + player;
}</pre><p class="list-inset">Since we passed a random number<a id="_idIndexMarker304"/> between <strong class="source-inline">0</strong> and <strong class="source-inline">1.0</strong>, it will wait a fraction of a second in <span class="No-Break">the database.</span></p><ol><li class="upper-roman" value="3">You can inject the new <strong class="source-inline">DataService</strong> into the <strong class="source-inline">FootballController</strong> class and create a method that will use the <span class="No-Break">new service:</span></li></ol><pre class="source-code">@GetMapping("/stats/{player}")
public String getPlayerStats(@PathVariable String player){
    return dataService.getPlayerStats(player);
}</pre><p class="list-inset">Now, you can run <span class="No-Break">the application.</span></p></li>				<li>Finally, run another JMeter script that makes a request to the same <strong class="source-inline">/football</strong> path and returns a list of teams, as well as the new path, <strong class="source-inline">/stats/{player}</strong>, which performs a long request to the database. Again, 30 threads are running these <span class="No-Break">requests infinitely.</span></li>
			</ol>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor129"/>How it works…</h2>
			<p>In the first load test, we can see that there is a bottleneck in the application’s CPU. In a real-world scenario, the CPU metric can be used to scale the application automatically, such as by adding new instances of the application. That’s the kind of bottleneck that we could expect under <span class="No-Break">heavy loads.</span></p>
			<p>In the second load test, there is no physical resource bottleneck, but there’s a query that takes a long time and blocks a connection that cannot be reused for other requests. In a real-world scenario, you could increase the number of available connections in the connection pool, but only up to a certain limit, since this is a very expensive and <span class="No-Break">finite resource.</span></p>
			<p>If you look at <strong class="source-inline">system.cpu.usage</strong> and <strong class="source-inline">process.cpu.usage</strong>, you will see that the values are much lower than <strong class="source-inline">1.0</strong>, which we observed in the previous <span class="No-Break">load test.</span></p>
			<p>You can also look at the metrics related to the database connection pool. The default database connection pool in Spring Data<a id="_idIndexMarker305"/> is HikariCP, and all the metrics related to this component are <strong class="source-inline">hikaricp.*</strong>. Let’s consider the <span class="No-Break">following metrics:</span></p>
			<ul>
				<li><strong class="source-inline">hikaricp.connections.max</strong>: This value specifies the maximum number of real database connections that <strong class="source-inline">hikaricp</strong> will open in the PostgreSQL server. This number won’t change during the execution of the test as the value is static during the application life cycle. By default, it’s set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">hikaricp.connections.active</strong>: This is the number of active connections – that is, the connections that are executing something in the database server. Under light loads, the number will be less than the maximum. Since the database operation is long (up to 1 second), and there are 30 concurrent threads for only 10 maximum connections, this number will be 10 or near 10 during the execution of the <span class="No-Break">JMeter script.</span></li>
				<li><strong class="source-inline">hikaricp.connections.pending</strong>: When there are no available connections in the connection pool, this metric queues the requests. This metric specifies the number of connections waiting for an available connection. This number will be greater than 1 during the JMeter <span class="No-Break">script’s execution.</span></li>
				<li><strong class="source-inline">hikaricp.connections.timeout</strong>: If a request is waiting for more than a given amount of time –30 seconds by default – it will time out. After executing the JMeter script, you will see that this metric will be more <span class="No-Break">than 1.</span></li>
			</ul>
			<p>Opening a physical database connection is an expensive operation. To avoid the overhead of creating<a id="_idIndexMarker306"/> a connection, there is a mechanism known as a database connection pool that keeps some already created connections ready to be used. When a process needs to connect to the database, it gets the connection from the pool and returns it to the pool once the operation is finished. In the second stress test, there were no connections as they took a long time to complete, so they took a long time to return to the pool. When there are no available connections, the connection pool enqueues the connection until one is released. That’s why you saw <strong class="source-inline">pending</strong> connections. After some time, you will see timeout connections. Those are the connections that were enqueued for more than <span class="No-Break">30 seconds.</span></p>
			<p>This situation also impacts the web container. By default, the number of threads to serve HTTP requests is finite and there is also a pool. When there are no more available threads, the web container – in this case, Tomcat – will enqueue the requests. In this kind of situation, when an HTTP request is mostly waiting for a dependency to complete, it appears the Reactive framework. In this case, the application uses special kinds of threads – non-blocking threads – that are intended for I/O operations. These types of threads allow the application to continue processing other tasks while waiting for responses<a id="_idIndexMarker307"/> from <span class="No-Break">external services.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor130"/>See also</h2>
			<p>You can visualize your metrics with standard monitoring tools. In the <em class="italic">Integrating your application with Prometheus and Grafana</em> recipe, you will learn how to integrate application metrics with Prometheus and visualize them with Grafana. These are two popular<a id="_idIndexMarker308"/> open source tools that are part of the <strong class="bold">Cloud Native Computing </strong><span class="No-Break"><strong class="bold">Foundation</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CNCF</strong></span><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor131"/>Creating your own metrics</h1>
			<p>So far, you’ve created a new feature<a id="_idIndexMarker309"/> in your Football Trading service where users can list a card for exchange and another user can bid for the traded card. When a new bid is received, it is queued in memory until it is committed as it requires a bunch of complex validations. There are a lot of expectations for this new feature, and you want to be sure it works well. For that reason, you want to monitor the bids that are received, how many bids are pending to be committed, and the duration of <span class="No-Break">this process.</span></p>
			<p>In this recipe, you will learn<a id="_idIndexMarker310"/> how to create custom metrics using <strong class="bold">Micrometer</strong>. Micrometer is an open source metrics collection library for Java applications that is very well integrated with Spring Boot Actuator. Other libraries can use the telemetry data generated by Micrometer to export to different <span class="No-Break">monitoring systems.</span></p>
			<p>There are different types <span class="No-Break">of metrics:</span></p>
			<ul>
				<li><strong class="bold">Counter</strong>: As the name suggests, it counts <a id="_idIndexMarker311"/>how many times something happened. We can use this type of metric to find out how many bids <span class="No-Break">were received.</span></li>
				<li><strong class="bold">Gauge</strong>: This metric provides a value<a id="_idIndexMarker312"/> in a given moment. We can use it to find out how many bids are waiting to <span class="No-Break">be processed.</span></li>
				<li><strong class="bold">Timer</strong>: This metric measures<a id="_idIndexMarker313"/> the duration of a given operation. We can use it to find out the time spent <span class="No-Break">per bid.</span></li>
			</ul>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor132"/>Getting ready</h2>
			<p>In this recipe, we’ll reuse the projects from the <em class="italic">Accessing standard metrics</em> recipe. I’ve prepared a working version if you haven’t completed that recipe yet. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-6/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>To simulate a workload<a id="_idIndexMarker314"/> for the new feature, I’ve created a JMeter script. You can find it in this book’s GitHub repository, in the <strong class="source-inline">chapter3/recipe3-6/jmeter</strong> folder. You can download<a id="_idIndexMarker315"/> JMeter from the project website at <a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a>. Here, you can download a ZIP file that contains JMeter binaries and unzip it – no further installation is required. To run JMeter, go to the folder where you unzipped the binaries, then open the <strong class="source-inline">bin</strong> folder. Here, you can find different scripts to launch JMeter, depending on your operating system. For Unix, you can run the <strong class="source-inline">jmeter.sh</strong> script, while for Windows, you can run the <span class="No-Break"><strong class="source-inline">jmeter.bat</strong></span><span class="No-Break"> script.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor133"/>How to do it…</h2>
			<p>In this recipe, you’ll incorporate your custom metrics into the football trading application. This enhancement will offer improved insights into your application’s performance <span class="No-Break">during runtime:</span></p>
			<ol>
				<li>Go to your trading application and create a new service class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">AuctionService</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">Inject <strong class="source-inline">MeterRegistry</strong> into the constructor. In the same constructor, create a counter for the bids received, a timer for the duration of the bid to be processed, and a gauge for the bids waiting to be confirmed. The class should look <span class="No-Break">like this:</span></li></ol><pre class="source-code">
@Service
public class AuctionService {
    private Map&lt;String, String&gt; bids = new ConcurrentHashMap&lt;&gt;();
    private Counter bidReceivedCounter;
    private Timer bidDuration;
    Random random = new Random();
    public AuctionService(<strong class="bold">MeterRegistry meterRegistry</strong>) {
        <strong class="bold">meterRegistry.gauge("football.bids.pending", bids, Map::size);</strong>
<strong class="bold">        this.bidReceivedCounter = meterRegistry.counter("football.bids.receieved");</strong>
<strong class="bold">        this.bidDuration = meterRegistry.timer("football.bids.duration");</strong>
    }
}</pre><ol><li class="upper-roman" value="2">Note that <strong class="source-inline">gauge</strong> returns the size<a id="_idIndexMarker316"/> of the map that’s used to keep the bids that have been received <span class="No-Break">in memory.</span></li><li class="upper-roman">Now, create a method to process the bids. In this method, you will use the <strong class="source-inline">bidDuration</strong> timer to measure the duration of the operation and increase the number of bids received <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bidReceivedCounter</strong></span><span class="No-Break">.</span></li><li class="upper-roman">Use the <strong class="source-inline">ordersTradedCounter</strong> and <strong class="source-inline">tradedDuration</strong> metrics in a new method named <strong class="source-inline">tradeCards</strong>. The method should look <span class="No-Break">like this:</span></li></ol><pre class="source-code">public void addBid(String player, String bid) {
    <strong class="bold">bidDuration.record</strong>(() -&gt; {
        bids.put(player, bid);
        <strong class="bold">bidReceivedCounter.increment();</strong>
        try {
            Thread.sleep(random.nextInt(20));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        bids.remove(player);
    });
}</pre></li>				<li>Next, expose this feature<a id="_idIndexMarker317"/> in the <span class="No-Break"><strong class="source-inline">FootballController</strong></span><span class="No-Break"> class:</span><ol><li class="upper-roman">Inject your new <strong class="source-inline">AuctionService</strong> into <span class="No-Break">the constructor:</span></li></ol><pre class="source-code">
private AuctionService auctionService;
public FootballController(AuctionService auctionService) {
   this.auctionService = auctionService;
}</pre><ol><li class="upper-roman" value="2">Note that all the other parameters and fields have been omitted for simplicity. Since we are reusing the same project from previous recipes, you should have more parameters in the constructor, and you should have other fields <span class="No-Break">as well.</span></li><li class="upper-roman">Create a new method that will present bids for players using the <span class="No-Break">new service:</span></li></ol><pre class="source-code">@PostMapping("/bid/{player}")
public void addBid(@PathVariable String player, 
                             @RequestBody String bid) {
      auctionService.addBidAOP(player, bid);
}</pre></li>				<li>Now, you can run the application and start generating some load. To do this, open the <strong class="source-inline">loadBids.jmx</strong> file in JMeter. You can find this file in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/, in the <strong class="source-inline">chapter3/recipe3-6/jmeter</strong> folder. Then, run the script in JMeter and keep it running while you observe <span class="No-Break">the metrics.</span></li>
				<li>Observe the counters<a id="_idIndexMarker318"/> <span class="No-Break">you created:</span><ul><li>If you open the Actuator metrics endpoint at <strong class="source-inline">http://localhost:8080/actuator/metrics</strong>, you will see the new metrics that have been created: <strong class="source-inline">football.bids.duration</strong>, <strong class="source-inline">football.bids.pending</strong>, and <strong class="source-inline">football.bids.receieved</strong>. If you append the names of these metrics to the Actuator metrics endpoint, you will get the values of <span class="No-Break">each metric.</span></li><li>Open <strong class="source-inline">http://localhost:8080/actuator/metrics/football.bids.received</strong> to get the number of bids that have been received. You will see the total number <span class="No-Break">of bids.</span></li><li>Open <strong class="source-inline">http://localhost:8080/actuator/metrics/football.bids.duration</strong> to get the bids <span class="No-Break">processing duration.</span></li><li>Open <strong class="source-inline">http://localhost:8080/actuator/metrics/football.bids.pending</strong> to get the number of bids that <span class="No-Break">are pending.</span></li></ul><p class="list-inset">For counters and duration, normally, the monitoring tools also provide a rate that’s calculated from the total values and based on the frequency of observation. It’s more interesting in terms of performance analysis to know the bid processing rate than the total number. The same goes for <span class="No-Break">the duration.</span></p></li>
				<li>Stop the <span class="No-Break">JMeter script.</span></li>
			</ol>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor134"/>How it works…</h2>
			<p>The <strong class="source-inline">MeterRegistry</strong> class registers the metrics, after which they are automatically exposed in the Actuator <span class="No-Break">metrics endpoint.</span></p>
			<p><strong class="source-inline">gauge</strong> calls the delegate that’s been assigned to the metric. This delegate will be executed according to the observation frequency. In this recipe, we call the endpoint explicitly. If you use a monitoring tool, it will be observed periodically. Keep in mind that this operation should be as lightweight as possible because it will be <span class="No-Break">called frequently.</span></p>
			<p>Timer metrics measure the time spent on the execution of the <span class="No-Break">delegate provided.</span></p>
			<p>A counter metric increments<a id="_idIndexMarker319"/> the value of the counter. If you don’t provide a value when calling the <strong class="source-inline">increment</strong> method, as we did in this recipe, it just increments by 1. You can provide a number as a parameter of method increment, at which point it will increment the counter value by the number provided. This number should always <span class="No-Break">be positive.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor135"/>There’s more…</h2>
			<p>You can create metrics<a id="_idIndexMarker320"/> by using a more declarative approach with <strong class="bold">Aspect Oriented Programming</strong> (<strong class="bold">AOP</strong>) libraries. For this, you should add a dependency to the <em class="italic">AOP starter</em> and configure the <span class="No-Break"><strong class="source-inline">ObservedAspect</strong></span><span class="No-Break"> bean.</span></p>
			<p>To add the dependency to the <em class="italic">AOP starter</em>, include the following in your <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>			<p>To configure the <strong class="source-inline">ObserverAspect</strong> bean, add the following method to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Football</strong></span><strong class="source-inline">
</strong><span class="No-Break"><strong class="source-inline">Configuration</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
@Bean
ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
    return new ObservedAspect(observationRegistry);
}</pre>			<p>At this point, you can use the <strong class="source-inline">@Observed</strong> annotation in your code to generate metrics automatically. For instance, in this recipe, we could annotate the <strong class="source-inline">AuctionService</strong> class <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Observed</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
<strong class="bold">@Observed(name = "football.auction")</strong>
@Service
public class AuctionService {
}</pre>			<p>Then, you can simplify the class<a id="_idIndexMarker321"/> as you don’t need to explicitly create the counters in the constructor. In the <strong class="source-inline">addBidAOP</strong> method, you only need to focus on the <span class="No-Break">application logic:</span></p>
			<pre class="source-code">
public void addBidAOP(String player, String bid) {
    bids.put(bid, player);
    try {
        Thread.sleep(random.nextInt(20));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    bids.remove(bid);
}</pre>			<p>When you run the application and <strong class="source-inline">AuctionService</strong> is used (the metrics are created lazily the first time the methods are used), you will see that there are two new metrics in the<a id="_idIndexMarker322"/> Actuator <span class="No-Break">metrics endpoint:</span></p>
			<ul>
				<li><strong class="source-inline">football.auction</strong>: Provides general counters for the methods defined in your <span class="No-Break">annotated class</span></li>
				<li><strong class="source-inline">football.auction.active</strong>: Provides counters for active executions for the methods defined in your <span class="No-Break">annotated class</span></li>
			</ul>
			<p>The following is a sample<a id="_idIndexMarker323"/> of the <strong class="source-inline">football.auction</strong> metric that was obtained <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">http://localhost:8080/actuator/endpoint/football.auction</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
{
    "name": "football.auction",
    "baseUnit": "seconds",
    "measurements": [
        {
            "statistic": "COUNT",
            "value": 1648870
        },
        {
            "statistic": "TOTAL_TIME",
            "value": 15809.168264051
        },
        {
            "statistic": "MAX",
            "value": 0.02272261
        }
    ],
    "availableTags": [
        {
            <strong class="bold">"tag": "method",</strong>
            "values": [
                "<strong class="bold">addBidAOP</strong>"
            ]
        },
        {
            "tag": "error",
            "values": [
                "none"
            ]
        },
        {
            "tag": "class",
            "values": [
                "com.packt.footballobs.service.AuctionService"
            ]
        }
    ]
}</pre>			<p>You can get metrics <a id="_idIndexMarker324"/>for a specific method using tags. For instance, to get the metrics of the <strong class="source-inline">addBidAOP</strong> method, you can perform the following <span class="No-Break">request: </span><span class="No-Break"><strong class="source-inline">http://localhost:8080/actuator/metrics/football.auction?tag=method:addBidAOP</strong></span><span class="No-Break">.</span></p>
			<p>This service is implemented in this book’s GitHub repository at <strong class="source-inline">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</strong>, in the <strong class="source-inline">chapter3/recipe3-8/end</strong> folder. As mentioned previously, the metric is created lazily, so you should invoke this service to make it available. You can do this by executing the following <strong class="source-inline">curl</strong> request in <span class="No-Break">your terminal:</span></p>
			<pre class="console">
curl http://localhost:8080/football/bid/357669 \
--request POST \
--data "200"</pre>			<h1 id="_idParaDest-130"><a id="_idTextAnchor136"/>Integrating your application with Prometheus and Grafana</h1>
			<p>You have a successful Football Trading<a id="_idIndexMarker325"/> application, and you can observe<a id="_idIndexMarker326"/> it by calling the various Actuator <a id="_idIndexMarker327"/>endpoints. However, this way<a id="_idIndexMarker328"/> of observing the application is too manual. So, you want a system that allows you to automate how your application <span class="No-Break">is monitored.</span></p>
			<p>In this recipe, you will learn how to expose the metrics of your application using a format that can be used by <strong class="bold">Prometheus</strong>, after which you will use the Prometheus data as a source for <strong class="bold">Grafana</strong>. Prometheus is an open source monitoring solution that collects and aggregates metrics as time series data, then stores the events in real time so that the events can be used to monitor your application. Grafana is an open source tool for visualization that allows you to create custom dashboards, graphs, and even alerts. One of the sources Grafana can use is the data collected by Prometheus. The combination of both tools is a very popular choice due to its ease of use, flexibility, <span class="No-Break">and scalability.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor137"/>Getting ready</h2>
			<p>In this recipe, you will reuse the outcome of the <em class="italic">Creating your own metrics</em> recipe. I’ve prepared a working version of this in case you haven’t completed it yet. You can find it in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/, in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-7/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>You will use Prometheus and Grafana servers. As usual, the easiest way to run Prometheus and Grafana on your local computer is by <span class="No-Break">using Docker.</span></p>
			<p>To download and start Prometheus, run the following command in <span class="No-Break">your terminal:</span></p>
			<pre class="console">
docker run -d --name prometheus -p 9090:9090 \
-v prometheus.yml:/etc/prometheus/prometheus.yml \
prom/prometheus</pre>			<p>This command uses the <strong class="source-inline">-v</strong> parameter to mount a volume to a file named <strong class="source-inline">prometheus.yml</strong>. This file contains the configuration for Prometheus. The configuration will be described and created as part of this recipe in the <em class="italic">How to do </em><span class="No-Break"><em class="italic">it…</em></span><span class="No-Break"> section.</span></p>
			<p>To download and start Grafana, run the following command in <span class="No-Break">your terminal:</span></p>
			<pre class="console">
docker run -d --name grafana -p 3000:3000 grafana/grafana</pre>			<p>To simulate a workload for the new feature, I’ve created a JMeter script. You can find it in this book’s GitHub repository, in the <strong class="source-inline">chapter3/recipe3-7/jmeter</strong> folder. You can download JMeter from the project’s website at <a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a>. From here, download a ZIP file containing JMeter binaries and unzip it; no further installation is required. To run JMeter, go to the folder<a id="_idIndexMarker329"/> where you unzipped<a id="_idIndexMarker330"/> the binaries, then open the <strong class="source-inline">bin</strong> folder. Here, you will find different scripts<a id="_idIndexMarker331"/> to launch JMeter, depending<a id="_idIndexMarker332"/> on your operating system. For Unix, you can run the <strong class="source-inline">jmeter</strong> script, while for Windows, you can run the <span class="No-Break"><strong class="source-inline">jmeter.bat</strong></span><span class="No-Break"> script.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor138"/>How to do it…</h2>
			<p>First, we’ll configure our application so that it exposes a Prometheus endpoint. Afterward, we’ll set up Prometheus and Grafana so that we can ingest the data provided by <span class="No-Break">our application:</span></p>
			<ol>
				<li>Let’s start by exposing a Prometheus endpoint to the trading application. For that, two steps <span class="No-Break">are necessary:</span><ol><li class="upper-roman">Add the following dependency to the <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span></li></ol><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><ol><li class="upper-roman" value="2">Expose the Prometheus endpoint. To do so, open the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder and add the following <span class="No-Break">highlighted properties:</span></li></ol><pre class="source-code">management:
    endpoint:
        health:
            probes:
                enabled: true
        <strong class="bold">prometheus:</strong>
<strong class="bold">            enabled: true</strong>
    endpoints:
        web:
            exposure:
                include: health,env,metrics,beans,loggers,football,<strong class="bold">prometheus</strong></pre></li>				<li>You can run the application and open the Prometheus endpoint <span class="No-Break">at </span><span class="No-Break">http://localhost:8080/actuator/prometheus</span><span class="No-Break">.</span></li>
				<li>The next step is running Prometheus<a id="_idIndexMarker333"/> and configuring<a id="_idIndexMarker334"/> it to consume the newly exposed<a id="_idIndexMarker335"/> endpoint. You can configure<a id="_idIndexMarker336"/> Prometheus by creating a <strong class="source-inline">.yaml</strong> configuration file and mounting it on the Prometheus <span class="No-Break">Docker image:</span><ol><li class="upper-roman">Prometheus will be hosted on Docker, while the application will be hosted on your computer, the Docker host. The first task is obtaining the IP address of your computer. On Linux, you can run the following command in <span class="No-Break">your Terminal:</span></li></ol><pre class="source-code">
ip addr show</pre><ol><li class="upper-roman" value="2">On Windows, you can run the following command in <span class="No-Break">your terminal:</span></li></ol><pre class="source-code">ipconfig</pre><ol><li class="upper-roman" value="3">If you run your application in <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>), you should run <strong class="source-inline">ip addr show</strong> in a <span class="No-Break">WSL</span><span class="No-Break"><a id="_idIndexMarker337"/></span><span class="No-Break"> terminal.</span></li><li class="upper-roman">For instance, the IP of my interface is <strong class="source-inline">172.26.109.186</strong> when I run <strong class="source-inline">ip addr show</strong>. I will use this value to configure the Prometheus <span class="No-Break">YAML file.</span></li><li class="upper-roman">Let’s continue by creating<a id="_idIndexMarker338"/> the configuration file<a id="_idIndexMarker339"/> using the IP address we obtained in the previous step. In the project’s root directory, create an application named <strong class="source-inline">prometheus.yml</strong> with the <span class="No-Break">following content:</span></li></ol><pre class="source-code">global:
  scrape_interval: 3s
scrape_configs:
  - job_name: 'football_trading_app'
    metrics_path: '<strong class="bold">/actuator/prometheus</strong>'
    static_configs:
      - targets: [<strong class="bold">'172.26.109.186:8080'</strong>]</pre><ol><li class="upper-roman" value="6">Note that we configured<a id="_idIndexMarker340"/> the metrics path exposed<a id="_idIndexMarker341"/> by our application, and the target is the IP address and port of <span class="No-Break">our application.</span></li><li class="upper-roman">Now, run the Prometheus container using the configuration file. For that, in the same directory you created the configuration file, execute the following command in <span class="No-Break">your terminal:</span></li></ol><pre class="source-code">docker run -d --name prometheus -p 9090:9090 \
<strong class="bold"> -v $(pwd)/prometheus.yml</strong>:/etc/prometheus/prometheus.yml prom/prometheus</pre><ol><li class="upper-roman" value="8">This command runs the <strong class="source-inline">prom/prometheus</strong> image, exposing port <strong class="source-inline">9090</strong> and mounting the <strong class="source-inline">prometheus.yml</strong> file in the container filesystem at <strong class="source-inline">/etc/prometheus/prometheus.yml</strong>. <strong class="source-inline">$(pwd)</strong> is a command substitution in Linux that is used to insert the <span class="No-Break">current directory.</span></li></ol></li>				<li>Now, Prometheus should be working and <em class="italic">scrapping</em> your application to get observability data. To verify it’s working, you can open Prometheus at http://localhost:9090, then open the <strong class="bold">Status</strong> menu and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Targets</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Figure 3.9: Prometheus targets" src="image/B21646_03_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Prometheus targets</p>
			<p class="list-inset">Verify that the status of your target is working. It should <span class="No-Break">be </span><span class="No-Break"><strong class="bold">UP</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">You can use Prometheus<a id="_idIndexMarker342"/> to visualize the data<a id="_idIndexMarker343"/> from your application. Go to the Prometheus<a id="_idIndexMarker344"/> home page, search<a id="_idIndexMarker345"/> for any metric, and click on <strong class="bold">Execute</strong> to see the data. If you select the <strong class="bold">Graph</strong> tab, you will see the data in <span class="No-Break">graphical form:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 3.10: Visualizing data in Prometheus" src="image/B21646_03_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: Visualizing data in Prometheus</p>
			<ol>
				<li value="6">The visualization capabilities<a id="_idIndexMarker346"/> that are available in Prometheus<a id="_idIndexMarker347"/> are a bit limited, but<a id="_idIndexMarker348"/> we can use Grafana<a id="_idIndexMarker349"/> and connect it to Prometheus to achieve <span class="No-Break">better visualization:</span><ol><li class="upper-roman">Ensure that Grafana is running. As explained in the <em class="italic">Getting ready</em> section, you can run Grafana using Docker by executing the following command in <span class="No-Break">your terminal:</span></li></ol><pre class="source-code">
docker run -d --name grafana -p 3000:3000 grafana/grafana</pre><ol><li class="upper-roman" value="2">Now, you can open Grafana by opening the following address in your browser: <strong class="source-inline">http://localhost:3000</strong>. You will be asked for your credentials. You can use the default credentials – that is, user set to <strong class="source-inline">admin</strong> and password set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">admin</strong></span><span class="No-Break">.</span></li></ol></li>				<li>Next, you will need<a id="_idIndexMarker350"/> to connect Prometheus<a id="_idIndexMarker351"/> as a Grafana data <a id="_idIndexMarker352"/>source. At this point, both containers<a id="_idIndexMarker353"/> are running <span class="No-Break">in Docker:</span><ol><li class="upper-roman">First, you will need to obtain the Prometheus IP address in Docker. You can get this information by inspecting the container. Execute the following commands to get the IP address of <span class="No-Break">the container:</span><ul><li>To retrieve the container ID, run the <span class="No-Break">following command:</span></li></ul></li></ol><pre class="source-code">
docker ps</pre><ul><li>My container ID was <strong class="source-inline">5affa2883c43</strong>. Replace this with your container ID when running the <span class="No-Break">following command:</span></li></ul><pre class="source-code">docker inspect 5affa2883c43 | grep IPAddress</pre><p class="list-inset">My terminal looks <span class="No-Break">like this:</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="Figure 3.11: Using docker inspect to get the container’s IP address" src="image/B21646_03_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: Using docker inspect to get the container’s IP address</p>
			<ol>
				<li class="upper-roman" value="2">Now, open the menu on the left and select <strong class="bold">Connections</strong> | <span class="No-Break"><strong class="bold">Data sources</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer055">
					<img alt="Figure 3.12: Opening Data sources" src="image/B21646_03_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12: Opening Data sources</p>
			<p class="list-inset">Click <strong class="bold">Add data source</strong> and select <strong class="bold">Prometheus</strong> as a data<a id="_idIndexMarker354"/> source type. If it doesn’t appear<a id="_idIndexMarker355"/> on the first <a id="_idIndexMarker356"/>page, search<a id="_idIndexMarker357"/> for <strong class="source-inline">Prometheus</strong> in the <span class="No-Break">search bar:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer056">
					<img alt="Figure 3.13: Selecting Prometheus as a data source" src="image/B21646_03_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13: Selecting Prometheus as a data source</p>
			<p class="list-inset">Then, configure<a id="_idIndexMarker358"/> the <strong class="bold">Prometheus server URL</strong> property. You will need<a id="_idIndexMarker359"/> to use the IP<a id="_idIndexMarker360"/> you obtained <a id="_idIndexMarker361"/>previously. In my case, this is <strong class="source-inline">172.17.0.3</strong>, but you likely have another value. The port <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">9090</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer057">
					<img alt="Figure 3.14: Configuring the Prometheus server URL property" src="image/B21646_03_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14: Configuring the Prometheus server URL property</p>
			<p class="list-inset">You can keep the default value for the rest of the parameters. At the bottom of the page, you’ll find the <strong class="bold">Save &amp; Test</strong> button. Click on it. At this point, you can start visualizing data by building <span class="No-Break">a dashboard.</span></p>
			<ol>
				<li value="8">Finally, create<a id="_idIndexMarker362"/> a dashboard<a id="_idIndexMarker363"/> to visualize the number of pending<a id="_idIndexMarker364"/> bids. Go to <strong class="bold">Dashboards</strong>, click <strong class="bold">Create Dasboard</strong>, and then<a id="_idIndexMarker365"/> click <span class="No-Break"><strong class="bold">Add visualization</strong></span><span class="No-Break">.</span><p class="list-inset">For <strong class="bold">Metric</strong>, select <strong class="source-inline">football_bids_pending</strong>, and then click <strong class="bold">Run queries</strong>. Change the time range to the last 30 minutes. Finally, <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Save</strong></span><span class="No-Break">:</span></p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer058">
					<img alt="Figure 3.15: Configuring a panel" src="image/B21646_03_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15: Configuring a panel</p>
			<p class="list-inset">Now, save your dashboard. Name it <span class="No-Break"><strong class="source-inline">Pending Bids</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="9">Run a load test to see<a id="_idIndexMarker366"/> how metrics are visualized<a id="_idIndexMarker367"/> in the panel. You can use<a id="_idIndexMarker368"/> the JMeter script<a id="_idIndexMarker369"/> I created to generate some traffic. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <strong class="source-inline">chapter3/recipe3-7/jmeter</strong> folder. The Grafana panel should look <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer059">
					<img alt="Figure 3.16: Pending bids visualized in Grafana" src="image/B21646_03_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16: Pending bids visualized in Grafana</p>
			<p class="list-inset">With that, you’ve learned how to visualize your metrics in powerful tools such <span class="No-Break">as Grafana.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor139"/>How it works…</h2>
			<p>Prometheus is an extensible<a id="_idIndexMarker370"/> tool that can use<a id="_idIndexMarker371"/> exporters. These exporters are jobs that run in Prometheus<a id="_idIndexMarker372"/> and can get data from external sources<a id="_idIndexMarker373"/> if they’re exposed using the appropriate format. This recipe’s job scrapes the data, meaning that it gets the data from the external source periodically. In this recipe, we configured our application to export the data in a format that Prometheus can understand, after which we configured a target to retrieve <span class="No-Break">that data.</span></p>
			<p>Some of the benefits<a id="_idIndexMarker374"/> of using Prometheus are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>It can take metrics from multiple sources – not only applications but also <span class="No-Break">infrastructure components.</span></li>
				<li>It allows PromQL to be used, a language for querying and aggregating data. You can combine this data from multiple sources to extract relevant information <span class="No-Break">for monitoring.</span></li>
				<li>You can create alerts based on queries and the thresholds you define. For instance, we could use CPU usage thresholds or our pending bids to send <span class="No-Break">an alert.</span></li>
			</ul>
			<p>Grafana can take data from different sources; one of them is Prometheus. This combination is very popular for monitoring solutions. Grafana can be used for advanced visualizations, and it also allows you to create alerts and send notifications. This is very important as it improves the monitoring <span class="No-Break">automation process.</span></p>
			<p>In this recipe, we used these popular open source tools, but the same approach can be used with other commercial tools. Usually, monitoring tools manage tracing, logging, and metrics, adding capabilities for visualization, such as dashboards and alerting by <span class="No-Break">different channels.</span></p>
			<p>An important thing to think about is when you should use traces or metrics for monitoring. Traces are very useful in showing the relationship between services and finding the specific operations using data from the transaction itself. This is very helpful in finding the root cause of an issue. The main issue with traces is that in scenarios with a high volume of operations, the amount of data that’s generated can be huge, and usually, the traces are sampled so that all the data that’s been generated can be processed and the cost can <span class="No-Break">be controlled.</span></p>
			<p>On the other hand, the metrics aggregate the measurements, and they just export those aggregated measurements periodically to create the time series data. Then, the data that’s generated is constant, regardless<a id="_idIndexMarker375"/> of the traffic managed by the target system. The main advantage of metrics<a id="_idIndexMarker376"/> is that they don’t require<a id="_idIndexMarker377"/> sampling and the data that’s generated is quite precise. For that reason, the metrics<a id="_idIndexMarker378"/> are more appropriate for certain types of alerts. However, when you need to find the root cause of an issue, traces are <span class="No-Break">more appropriate.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor140"/>Changing the settings of a running application</h1>
			<p>So far, you’ve added logging<a id="_idIndexMarker379"/> to your successful football trading application, and it receives quite a lot of traffic. The program creates logs in different places. These logs can help you figure out what the program did while it was running. Not every log is equally important. So, the program uses various log levels, ranging from debugging to error logs. Sorting logs by their level prevents an excessive number of logs from being created. However, you want to ensure you can change the minimum level of logs to be processed without restarting or redeploying <span class="No-Break">your application.</span></p>
			<p>Some Spring Boot Actuator endpoints allow you to make changes in runtime, with no need to restart the application. The logging endpoint is one of those endpoints as it allows you to change the minimum level <span class="No-Break">of logging.</span></p>
			<p>In this recipe, you will learn how to change the logging level of a <span class="No-Break">running application.</span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor141"/>Getting ready</h2>
			<p>In this recipe, you will reuse the outcome of the <em class="italic">Integrating your application with Prometheus and Grafana</em> recipe. I’ve prepared a working version in case you haven’t completed it yet. You can find it in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/, in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-8/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor142"/>How to do it…</h2>
			<p>In this recipe, you’ll adapt the football trading application so that it generates logs with different levels of importance. Once you’ve done this you’ll learn how to change the level <span class="No-Break">at runtime:</span></p>
			<ol>
				<li>First, let’s add some logs to the <span class="No-Break"><strong class="source-inline">TradingService</strong></span><span class="No-Break"> class:</span><ol><li class="upper-roman">Create a logger<a id="_idIndexMarker380"/> for the class. You can define a static member for <span class="No-Break">this purpose:</span></li></ol><pre class="source-code">
private static final Logger logger = LoggerFactory.getLogger(TradingService.class);</pre><ol><li class="upper-roman" value="2">Then, add debug and information logging to the <span class="No-Break"><strong class="source-inline">getPendingOrders</strong></span><span class="No-Break"> method:</span></li></ol><pre class="source-code">public int getPendingOrders() {
    <strong class="bold">logger.debug("Ensuring that pending orders can be calculated");</strong>
    Random random = new Random();
    int pendingOrders = random.nextInt(100);
    <strong class="bold">logger.info(pendingOrders + " pending orders found");</strong>
    return pendingOrders;
}</pre><ol><li class="upper-roman" value="3">You can also add some logging for the <span class="No-Break"><strong class="source-inline">tradeCards</strong></span><span class="No-Break"> method:</span></li></ol><pre class="source-code">public int tradeCards(int orders) {
    if (getPendingOrders() &gt; 90) {
        <strong class="bold">logger.warn</strong>("There are more than 90 orders, this can cause the system to crash");
        AvailabilityChangeEvent.publish(applicationEventPublisher, new Exception("There are more than 90 pending orders"), LivenessState.BROKEN);
    } else {
        <strong class="bold">logger.debug</strong>("There are more less than 90 orders, can manage it");
        AvailabilityChangeEvent.publish(applicationEventPublisher, new Exception("working fine"), LivenessState.CORRECT);
        }
    return orders;
}</pre></li>				<li>Now, you can perform some requests<a id="_idIndexMarker381"/> and validate that the information is being logged. You can execute the following command in your terminal to execute a request <span class="No-Break">every second:</span><pre class="source-code">
watch -n 1 -x curl --request POST -H "Content-Type: application/json" --data "1" http://localhost:8080/football</pre><p class="list-inset">You will see that only <strong class="source-inline">INFO</strong> and <strong class="source-inline">WARN</strong> logs <span class="No-Break">are processed:</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 3.17: Only INFO and WARN logs are processed" src="image/B21646_03_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17: Only INFO and WARN logs are processed</p>
			<p class="list-inset">This is because the default level is <strong class="source-inline">INFO</strong>. This means that only <strong class="source-inline">INFO</strong> or higher priority levels <span class="No-Break">are logged.</span></p>
			<ol>
				<li value="3">You can verify the log level by calling the Actuator <strong class="source-inline">loggers</strong> endpoint. Go to http://localhost:8080/actuator/loggers. You will see the available log levels, as well as the loggers that are defined in your application. You will see that there is a logger for your service class, <strong class="source-inline">com.packt.footballobs.service.TradingService</strong>, and that the effective level <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">INFO</strong></span><span class="No-Break">.</span></li>
				<li>Let’s say you’ve detected an issue in the application, and you want to activate the <strong class="source-inline">DEBUG</strong> level. Let’s change it by using the Actuator <strong class="source-inline">loggers</strong> endpoint. For that, you just need to perform the <span class="No-Break">following request:</span><pre class="source-code">
curl --request POST \
-H 'Content-Type: application/json' \
-d '{"configuredLevel": "DEBUG"}' \
http://localhost:8080/actuator/loggers/com.packt.footballobs.service.TradingService</pre><p class="list-inset">You will see that it now generates logs for <strong class="source-inline">DEBUG</strong> <span class="No-Break">as well:</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer061">
					<img alt="Figure 3.18: DEBUG and higher critical logs are generated" src="image/B21646_03_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18: DEBUG and higher critical logs are generated</p>
			<p class="list-inset">If you verify the <strong class="source-inline">loggers</strong> endpoint, as explained in <em class="italic">Step 3</em>, you will see that the <strong class="source-inline">TradingService</strong> class<a id="_idIndexMarker382"/> now has <span class="No-Break">two attributes:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">configuredLevel</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">DEBUG</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">effectiveLevel</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">DEBUG</strong></span></li>
			</ul>
			<ol>
				<li value="5">Now that you’ve verified the logs, you decide to change the log level to <strong class="source-inline">WARN</strong> by running the following command since too much noise is generated by <strong class="source-inline">DEBUG</strong> and <span class="No-Break"><strong class="source-inline">INFO</strong></span><span class="No-Break"> logs:</span><pre class="source-code">
curl --request POST \
-H 'Content-Type: application/json' \
-d '{"configuredLevel": "WARN"}' \
http://localhost:8080/actuator/loggers/com.packt.footballobs.service.TradingService</pre></li>			</ol>
			<p>If you verify the <strong class="source-inline">loggers</strong> endpoint, as explained in <em class="italic">Step 3</em>, you will see that the <strong class="source-inline">TradingService</strong> level is <strong class="source-inline">WARN</strong>. If you continue making requests, you will see that only <strong class="source-inline">WARN</strong> logs <span class="No-Break">are emitted.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor143"/>How it works…</h2>
			<p>As we saw in the <em class="italic">Creating a custom Actuator endpoint</em> recipe, some endpoints implement update and delete operations. The <strong class="source-inline">loggers</strong> endpoint allows you to change the log level. This is a very helpful feature when you need to find issues in production as you no longer need to restart <span class="No-Break">your application.</span></p>
			<p>In an application with high traffic, you will usually want to have a high log level, such as <strong class="source-inline">WARN</strong>. This is the warning level and is typically used to indicate that there is a potential issue or anomaly that should be noted. It signifies a situation that may not necessarily be an error, but it could lead to problems if it’s not addressed. The reason for using higher log levels, such as <strong class="source-inline">WARN</strong>, is that the logs are usually saved by the monitoring system. If the application generates too many logs, it requires more resources to process and retain them, and that can be costly. At the same time, <strong class="source-inline">DEBUG</strong> and <strong class="source-inline">INFO</strong> logs are not critical and they can generate too much information, making it more difficult to find the root cause<a id="_idIndexMarker383"/> of <span class="No-Break">the problems.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor144"/>There’s more…</h2>
			<p>Other standard endpoints are part of Spring Boot that allow you to make changes at runtime. For instance, the <strong class="source-inline">sessions</strong> endpoint allows you to retrieve and delete <span class="No-Break">user sessions.</span></p>
		</div>
	</body></html>