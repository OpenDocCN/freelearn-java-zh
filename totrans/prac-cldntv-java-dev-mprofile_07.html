<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-84"><em class="italic"><a id="_idTextAnchor091"/>Chapter 5</em>: Enhancing Cloud-Native Applications</h1>
			<p>In the previous chapter, <a href="B17377_04_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Developing Cloud-Native Applications,</em> we learned how to build cloud-native applications. However, building cloud-native applications is just the start. The next step is to enhance the applications, by making them configurable, resilient, documentable, and secure. In this chapter, you will learn how to configure your cloud-native applications using MicroProfile Config, make your applications resilient using MicroProfile Fault Tolerance, document their APIs using MicroProfile OpenAPI, and finally, secure your applications using MicroProfile JWT. After this chapter, you should be able to use these technologies to improve the quality of your cloud-native applications. To fully comprehend this chapter, you will need some basic knowledge of Java, Maven, and Gradle.</p>
			<p>We will cover the following topics:</p>
			<ul>
				<li>Configuring cloud-native applications using MicroProfile Config </li>
				<li>Making cloud-native applications resilient using MicroProfile Fault Tolerance </li>
				<li>Documenting cloud-native applications using MicroProfile OpenAPI </li>
				<li>Securing cloud-native applications using MicroProfile JWT </li>
			</ul>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor092"/>Configuring cloud-native applications using MicroProfile Config</h1>
			<p><strong class="bold">MicroProfile Config</strong> (source<a id="_idIndexMarker393"/> code<a id="_idIndexMarker394"/> located <a id="_idIndexMarker395"/>at <a href="https://github.com/eclipse/microprofile-config">https://github.com/eclipse/microprofile-config</a>) is the first specification created by the MicroProfile<a id="_idIndexMarker396"/> community. The concept of configuration has been around for a decade. You may recall in <a href="B17377_01_Final_SB_epub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Cloud-Native Application</em>, we briefly<a id="_idIndexMarker397"/> discussed the <strong class="bold">Twelve-Factor App</strong>, in which the third factor <em class="italic">III.</em> <em class="italic">Config</em> (<a href="https://12factor.net/config">https://12factor.net/config</a>) recommends that a twelve-factor app stores its configuration in an environment that is separate from the application code. This is because any configuration value update will not lead to the application code being rebuilt. But sometimes, it is not realistically possible to store all configs such as security credentials and much more in that environment. It is also common for some configuration to be stored in a database. Since the configuration could be in many different places, a mechanism for obtaining the configuration is required. Quite a few libraries provide this mechanism, such as Apache <em class="italic">DeltaSpike configuration </em>(<a href="http://deltaspike.apache.org/documentation/configuration.html">http://deltaspike.apache.org/documentation/configuration.html</a>), <em class="italic">Apache Tamaya</em> (<a href="http://tamaya.incubator.apache.org/">http://tamaya.incubator.apache.org/</a>), and many more.</p>
			<p>MicroProfile<a id="_idIndexMarker398"/> Config was <a id="_idIndexMarker399"/>created as a standard so you would not need to worry about which library to pull into your applications.</p>
			<p>In this section, we will learn how MicroProfile Config defines how configuration can be stored and retrieved by cloud-native applications.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor093"/>Storing configuration</h2>
			<p>In MicroProfile <a id="_idIndexMarker400"/>Config, the configuration<a id="_idIndexMarker401"/> is stored in <strong class="bold">ConfigSource</strong>. A <strong class="source-inline">ConfigSource</strong> is a place where you can put configuration values. Environment variables, system properties, property files, databases, ZooKeeper, and much more can all be used as config sources. Each <strong class="source-inline">ConfigSource</strong> has an associated ordinal, which is used to indicate the importance of the <strong class="source-inline">ConfigSource</strong>. A <strong class="source-inline">ConfigSource</strong> with a higher ordinal means the configuration values it specifies will override the <strong class="source-inline">ConfigSource</strong> that specifies the same configuration with a lower ordinal.</p>
			<p>For instance, the <strong class="source-inline">customer_name property</strong> is specified in a <strong class="source-inline">ConfigSource</strong> (ordinal = 200) with the value of <strong class="source-inline">Bob</strong>, and the same property is specified with the value of <strong class="source-inline">Alice</strong> in another <strong class="source-inline">ConfigSource</strong> (ordinal =120). Then when a cloud-native application looks up <strong class="source-inline">customer_name</strong>, the value <strong class="source-inline">Bob</strong> should be retrieved. The ordinal of a <em class="italic">ConfigSource</em> can be defined in the corresponding <strong class="source-inline">ConfigSource</strong> via the <strong class="source-inline">config_ordinal</strong> property, which indicates the ranking order of the enclosed config source. If not specified, the default config ordinal is 100.</p>
			<p>There are two types of config sources: <strong class="bold">default config source</strong> and <strong class="bold">custom config source</strong>, which<a id="_idIndexMarker402"/> we discuss in the next subsections.</p>
			<h3>Default config sources</h3>
			<p><strong class="bold">Default config sources</strong> are the<a id="_idIndexMarker403"/> ones mandated <a id="_idIndexMarker404"/>by MicroProfile Config and all MicroProfile Config implementations must provide them out of the box. MicroProfile Config mandates three default config sources to be supported out of the box:</p>
			<ul>
				<li>System properties with a default ordinal value of 400</li>
				<li>Environment variables with a default ordinal value of 300</li>
				<li>The property file <strong class="source-inline">META-INF/microprofile-config.properties</strong> found on the classpath with a default ordinal value of 100</li>
			</ul>
			<p>The ordinal for the default config sources can be overridden by defining the property <strong class="source-inline">config_ordinal</strong> inside the config source. For instance, if you want to set the ordinal number for environment variables to 500, you can simply define an environment variable's <strong class="source-inline">config_ordinal</strong> with the value of <strong class="source-inline">500</strong>. </p>
			<h4>Environment variable mapping rules</h4>
			<p>Some property <a id="_idIndexMarker405"/>names do not qualify as valid environment variables, because in some <strong class="bold">Operating System</strong> (<strong class="bold">OS</strong>), environment<a id="_idIndexMarker406"/> variable names can only consist of uppercase letters, digits, and <em class="italic">_</em> (underscore). MicroProfile Config defines a mapping rule when searching for a given config property (<strong class="source-inline">app.name</strong>) in an environment variable. The search will terminate once a match is found from the following list: </p>
			<ul>
				<li>The exact property name is found, such as <strong class="source-inline">app.name</strong>.</li>
				<li>If the property name contains some characters that are not letters or digits, convert these characters to <em class="italic">_</em> and the transformed property name (<strong class="source-inline">app_name</strong>) will be found.</li>
				<li>If the property name contains some characters that are not letters or digits, convert the characters to <em class="italic">_</em> and then convert all letters to uppercase and the transformed property name (<strong class="source-inline">APP_NAME</strong>) will be found.</li>
			</ul>
			<p>Apart from the out-of-the-box config sources, you can create your own config sources using a file, a database, and much more. These config sources are called Custom Config Sources, which<a id="_idIndexMarker407"/> we discuss next.</p>
			<h3>Custom config source</h3>
			<p><strong class="bold">Custom config source</strong> is a<a id="_idIndexMarker408"/> config source that <a id="_idIndexMarker409"/>you define in your application other than the default config source. To define a custom config source, you can follow these steps:</p>
			<ol>
				<li>Implement the interface <strong class="source-inline">ConfigSource</strong> as follows:<p class="source-code">public interface ConfigSource {</p><p class="source-code">    String CONFIG_ORDINAL = "config_ordinal";</p><p class="source-code">    int DEFAULT_ORDINAL = 100;</p><p class="source-code">    default Map&lt;String, String&gt; getProperties() {</p><p class="source-code">        Map&lt;String, String&gt; props = new HashMap&lt;&gt;();</p><p class="source-code">        getPropertyNames().forEach((prop) -&gt;             props.put(prop, getValue(prop)));</p><p class="source-code">        return props;</p><p class="source-code">    }</p><p class="source-code">    Set&lt;String&gt; getPropertyNames();</p><p class="source-code">    default int getOrdinal() {</p><p class="source-code">        String configOrdinal =             getValue(CONFIG_ORDINAL);</p><p class="source-code">        if (configOrdinal != null) {</p><p class="source-code">            try {</p><p class="source-code">                return Integer.parseInt(configOrdinal);</p><p class="source-code">            } catch (NumberFormatException ignored) {</p><p class="source-code">          }</p><p class="source-code">        }</p><p class="source-code">        return DEFAULT_ORDINAL;</p><p class="source-code">    }</p><p class="source-code">    String getValue(String propertyName);</p><p class="source-code">    String getName();</p><p class="source-code">}</p><p>The <strong class="source-inline">getPropertyNames()</strong>, <strong class="source-inline">getValue(String propertyName)</strong>, and <strong class="source-inline">getName()</strong> methods are the ones to be implemented.</p></li>
				<li>Register<a id="_idIndexMarker410"/> the <a id="_idIndexMarker411"/>implementation of these functions using either of the following methods:<p>a). Create a <strong class="source-inline">META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource</strong> file with the fully qualified class name of the custom implementation.</p><p>b). Add to <strong class="source-inline">ConfigBuilder</strong> programmatically via the following:</p><p class="source-code">ConfigBuider.withSources(ConfigSource… configSource)<strong class="bold"> </strong></p></li>
			</ol>
			<p>Sometimes, you have sensitive configuration, and you need to store it somewhere safe. You might need to<a id="_idIndexMarker412"/> consider using <strong class="bold">HashiCorp Vault</strong> (<a href="https://www.vaultproject.io/">https://www.vaultproject.io/</a>), which manages secrets and stores sensitive data. If you store some secret properties in <em class="italic">Vault</em>, you can add <em class="italic">Vault</em> as a custom config source. Next, we'll look at another way of storing configuration using Kubernetes ConfigMaps and Secrets, which store configurations. </p>
			<h3>Kubernetes ConfigMaps and Secrets</h3>
			<p><strong class="bold">Kubernetes</strong> <strong class="bold">ConfigMaps</strong> and <strong class="bold">Secrets</strong> are <a id="_idIndexMarker413"/>often<a id="_idIndexMarker414"/> used <a id="_idIndexMarker415"/>to store <a id="_idIndexMarker416"/>properties<a id="_idIndexMarker417"/> for <a id="_idIndexMarker418"/>cloud-native applications. You can use the following commands to declare properties as Kubernetes ConfigMaps or Secrets:</p>
			<ul>
				<li>Create a ConfigMap named <strong class="source-inline">app-port</strong>:<p class="source-code"><strong class="bold">kubectl create configmap app-port --from-literal port=9081</strong></p><p>The previous command creates a ConfigMap, <strong class="source-inline">app-port</strong>, in your cluster, and that ConfigMap contains a key called <strong class="source-inline">port</strong> with a value of <strong class="source-inline">9081</strong>. The <strong class="source-inline">–-from-literal</strong> is used to store individual name-value pairs in this ConfigMap.</p></li>
				<li>Create a Secret, <strong class="source-inline">app-credentials</strong>:<p class="source-code"><strong class="bold">kubectl create secret generic app-credentials --from-literal username=Bob --from-literal password=TheBuilder</strong></p><p>This command is similar to creating a ConfigMap. The main difference between a <a id="_idIndexMarker419"/>Secret <a id="_idIndexMarker420"/>and ConfigMap<a id="_idIndexMarker421"/> is that a Secret only shows a Base64-encoded version of the text instead of cleartext.</p></li>
			</ul>
			<p>After specifying a Kubernetes ConfigMap or Secret, you can map the ConfigMap or Secret to environment variables via the <strong class="source-inline">deployment yaml</strong> file:</p>
			<p class="source-code">env:</p>
			<p class="source-code">        - name: PORT</p>
			<p class="source-code">          valueFrom:</p>
			<p class="source-code">            configMapKeyRef:</p>
			<p class="source-code">              name: app-port</p>
			<p class="source-code">              key: port</p>
			<p class="source-code">              optional: true</p>
			<p class="source-code">        - name: APP_USERNAME</p>
			<p class="source-code">          valueFrom:</p>
			<p class="source-code">            secretKeyRef:</p>
			<p class="source-code">              name: app-credentials</p>
			<p class="source-code">              key: username</p>
			<p class="source-code">        - name: APP_PASSWORD</p>
			<p class="source-code">          valueFrom:</p>
			<p class="source-code">            secretKeyRef:</p>
			<p class="source-code">              name: app-credentials</p>
			<p class="source-code">              key: password</p>
			<p>You can then use the following code to look up the properties:</p>
			<p class="source-code">@Inject @ConfigProperty(name="port", defaultValue="9080")   int port;</p>
			<p class="source-code">@Inject @ConfigProperty(name="app.username") String user;</p>
			<p class="source-code">@Inject @ConfigProperty(name="app.password") String pwd;</p>
			<p>Based on<a id="_idIndexMarker422"/> the <a id="_idIndexMarker423"/>defined<a id="_idIndexMarker424"/> mapping <a id="_idIndexMarker425"/>rules<a id="_idIndexMarker426"/> when looking <a id="_idIndexMarker427"/>up properties in the environment variables, <strong class="source-inline">port</strong> will be searched first, followed by <strong class="source-inline">PORT</strong>. Since the ConfigMap property <strong class="source-inline">app_port</strong> is optional, it is not required to be defined in the ConfigMap. If it is not found, the default value <strong class="source-inline">9080</strong> will be assigned to the variable <strong class="source-inline">port</strong>. As for the other property <strong class="source-inline">app.username</strong>, <strong class="source-inline">app.username</strong> is searched first, followed by <strong class="source-inline">app_username</strong>, and then <strong class="source-inline">APP_USERNAME</strong>.</p>
			<p>So far, we have learned where to store property values, but sometimes, you might have to delete a property value. In this next section, we will learn how to erase a property.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor094"/>Removing properties</h2>
			<p>In order to <a id="_idIndexMarker428"/>remove properties, you can simply remove the property entry from a config source. However, you might not be able to update a config source. In such circumstances, you can define a config source with a higher ordinal and define the property with a empty value. This effectively erases the config property. Therefore, any lookup for this property will resolve to an exception.</p>
			<p>We have covered where to specify config properties. When we store the config property values, they are all expressed via strings. You might want to convert the strings to some other types, such as <strong class="bold">int</strong>, <strong class="bold">float</strong>, and so on. To achieve this, we will need some converters.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor095"/>Converters</h2>
			<p>A <strong class="bold">converter</strong> converts <a id="_idIndexMarker429"/>a string to a target type. If a null value is <a id="_idIndexMarker430"/>passed to the <a id="_idIndexMarker431"/>converter, <strong class="bold">NullPointerException</strong> (<strong class="bold">NPE</strong>) will be thrown.</p>
			<p>Just as there is more than one<a id="_idIndexMarker432"/> type of config source, there are a few types of converters: </p>
			<ul>
				<li><strong class="bold">Built-in converters</strong>: They <a id="_idIndexMarker433"/>can convert strings to<a id="_idIndexMarker434"/> primitive and boxed types as well as class types.</li>
				<li><strong class="bold">Array converters</strong>: They <a id="_idIndexMarker435"/>can convert a comma-separated<a id="_idIndexMarker436"/> string to an array. </li>
				<li><strong class="bold">Automatic converters</strong>: An <a id="_idIndexMarker437"/>automatic convertor for<a id="_idIndexMarker438"/> a target type <strong class="source-inline">T</strong> is derived from a class where the class contains one of the following:<p class="source-code">public static T of(String value) </p><p class="source-code">public static T valueOf(String value)</p><p class="source-code">public static T parse(CharSequence value )</p><p class="source-code">public T(String value)</p><p>If more than one method is found, the method appearing at the top of the aforementioned list will be used for conversion.</p></li>
				<li><strong class="bold">Custom converters</strong>: If the<a id="_idIndexMarker439"/> previous converters do not<a id="_idIndexMarker440"/> convert a string to the specified target type, you will have to define your own converter, which is called a custom converter. They can be defined by doing the following:<p>1) Implement the interface <strong class="source-inline">org.eclipse.microprofile.config.spi.Converter</strong>.</p><p>2) Register the converter by creating a <strong class="source-inline">META-INF/services/org.eclipse.microprofile.config.spi.Converter</strong> file with the<a id="_idIndexMarker441"/> fully qualified class name of the custom implementation or adding to <strong class="source-inline">ConfigBuilder</strong> programmatically via one of the following:</p><p class="source-code">ConfigBuider.withConverters(converter) </p><p class="source-code">ConfigBuilder.withConverter (Class&lt;T&gt; type,  int priority, Converter&lt;T&gt; converter</p></li>
			</ul>
			<p>There are several types of converters. There might be multiple converters for a given type. But the question arises, which converter will be used to transform the config string value to the given type? This is determined by converter priority. </p>
			<h3>Converter priority</h3>
			<p><strong class="bold">Converter priority</strong> can be<a id="_idIndexMarker442"/> specified via the <strong class="source-inline">@javax.annotation.Priority</strong> annotation. If absent, the priority for a custom converter will default to 100. A converter with a higher priority overrides one with a lower priority.</p>
			<p>We have covered how to specify the value of a config property with a string and then how to convert a string to a particular type. In the next section, we will learn how to look up config <a id="_idIndexMarker443"/>properties in cloud-native applications.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor096"/>Config lookup</h2>
			<p>We have learned<a id="_idIndexMarker444"/> that config sources contain properties specified in strings and converters can convert strings to a target type. But the question arises, how do you retrieve a config property? This can be done either programmatically or via injection:</p>
			<ul>
				<li><strong class="bold">Retrieving config property via programmatic lookup</strong>: In the following code, the property <strong class="source-inline">customer.age</strong> will be retrieved using the <strong class="source-inline">getValue</strong> method and converted to an integer using programmatic lookup:<p class="source-code">Config = ConfigProvider.getConfig();</p><p class="source-code">int age = config.getValue("customer.age", int.class);</p></li>
				<li><strong class="bold">Retrieving config property via CDI injection</strong>: In the following, we use CDI injection to retrieve the property <strong class="source-inline">customer.age</strong>:<p class="source-code">@Inject @ConfigProperty(name="customer.age") int age;</p></li>
			</ul>
			<p>In your cloud-native applications, sometimes different values are specified during different project stages. For instance, you might use a different database in different project stages. When the project moves through different phases, the values associated with those stages will be injected into the corresponding config properties. This is called a <strong class="bold">config profile</strong>. We will cover this in more detail in the next section.</p>
			<h3>Understanding config profiles </h3>
			<p>Config <a id="_idIndexMarker445"/>profiles <a id="_idIndexMarker446"/>are an important concept that can be used to indicate project phases, such as development, testing, production, and so on. We'll first discuss how to define properties that use config profiles and then learn how to activate a particular profile.</p>
			<h3>Profile-aware properties</h3>
			<p>There are two<a id="_idIndexMarker447"/> ways to define profile-aware properties:</p>
			<ul>
				<li>Using<a id="_idIndexMarker448"/> the naming convention of <em class="italic">%&lt;profile name&gt;.&lt;property name&gt;</em>, for example, defining a property <a id="_idIndexMarker449"/>called <strong class="source-inline">%dev.customer.name</strong> in a config source. </li>
				<li>Defining the properties in a <strong class="source-inline">microprofile-config-&lt;profile name&gt;.properties</strong> file.</li>
			</ul>
			<h3>Activating a profile</h3>
			<p>An active<a id="_idIndexMarker450"/> profile is specified using the property <strong class="source-inline">mp.config.profile</strong>, which can be included in any config sources. If more than one config source specifies this property, the value from the config source with the highest ordinal is used.</p>
			<p>Let's take a look at a few examples. Let's say we have the following config source, containing the following properties:</p>
			<p class="source-code">%dev.discount=0.1</p>
			<p class="source-code">%testing.discount=0.6</p>
			<p class="source-code">%live.discount=0.2</p>
			<p class="source-code">discount=0.15</p>
			<p>If the value of <strong class="source-inline">mp.config.profile</strong> is set to <strong class="source-inline">dev</strong>, the value of the property <strong class="source-inline">discount</strong> will resolve to the value of <strong class="source-inline">%dev.discount</strong>, which is <strong class="source-inline">0.1</strong>. Similarly, the value of the property <strong class="source-inline">discount</strong> will be <strong class="source-inline">0.2</strong> if the active profile is <strong class="source-inline">live</strong>. The value of the property <strong class="source-inline">discount</strong> will be <strong class="source-inline">0.15</strong> if no active profile is defined.</p>
			<p>A config profile also works on the config source file <strong class="source-inline">micorprofile-config.properties</strong>. Consider the following <strong class="source-inline">properties</strong> files provided by your application:</p>
			<p class="source-code">META-INF\microprofile-config.properties</p>
			<p class="source-code">META-INF\microrpofile-config-dev.properties</p>
			<p class="source-code">META-INF\microprofile-config-testing.properties</p>
			<p class="source-code">META-INF\microprofile-config-live.properties</p>
			<p>If the value of <strong class="source-inline">mp.config.profile</strong> is set to <strong class="source-inline">dev</strong>, the config file <strong class="source-inline">META-INF\microrpofile-config-dev.properties</strong> will be activated. Its content will be merged into <strong class="source-inline">META-INF\microrpofile-config.properties</strong> and override the property values for the same properties that exist in both files.</p>
			<p>Sometimes the value of one property refers to another property. We call this a config reference. We<a id="_idIndexMarker451"/> will cover this topic in the next subsection.</p>
			<h3>Config references</h3>
			<p>A property<a id="_idIndexMarker452"/> value might reference a value from another<a id="_idIndexMarker453"/> property, which is called a <strong class="bold">Config Reference</strong>, also known as a property expression. The syntax for a property expression is <em class="italic">${another.property}</em>.</p>
			<p>Consider the following example:</p>
			<p class="source-code">customer.name=${forename}-${surname}</p>
			<p class="source-code">forename = Bob</p>
			<p class="source-code">surname = Johnson</p>
			<p>The value of <strong class="source-inline">customer.name</strong> will be <strong class="source-inline">Bob-Johnson</strong>. A property expression can be nested as well, in the format <em class="italic">${a${n}}</em>. In a nested expression, the inner expression will be resolved first.</p>
			<p>As mentioned previously, a property can be specified in multiple config sources. </p>
			<p>Sometimes you need to identify which config source supplies the value so that you can update the effective value if needed. In the next subsection, we will learn how to find out which config source is the winning config source.</p>
			<h3>Where is my property value from?</h3>
			<p>Sometimes you<a id="_idIndexMarker454"/> might be wondering which config source supplies the value for a particular property, since the same property might exist in multiple config sources. If you need to update the property value, you need to update the value from the winning config source. MicroProfile Config provides an API, <strong class="source-inline">ConfigValue</strong>, that enables you to find the winning config source. There are a couple of ways to obtain an object of <strong class="source-inline">ConfigValue</strong> for a specified property. You can use the following programmatic lookup to look up the config value for the property <strong class="source-inline">host</strong>:</p>
			<p class="source-code">ConfigValue configValueHost=ConfigProvider.getConfig()</p>
			<p class="source-code">.getConfigValue("host");</p>
			<p>Alternatively, you can use CDI to obtain the config value for the <strong class="source-inline">host</strong> property<strong class="source-inline">,</strong> as shown here:</p>
			<p class="source-code">@Inject @ConfigProperty(name="host") ConfigValue   configValueHost;</p>
			<p>Then we can use the following method to retrieve some information about the winning config source and its value:</p>
			<p class="source-code">String configSourceForHost = configValueHost.getSourceName();</p>
			<p class="source-code">String valueOfHost = configValueHost.getValue();</p>
			<p>Commonly, some <a id="_idIndexMarker455"/>properties are related, and they are often looked up together. It would be very useful if these properties were aggregated and mapped to a particular Java type.</p>
			<h3>Aggregate config properties</h3>
			<p>When<a id="_idIndexMarker456"/> looking up several related properties, it can be tedious to repeat the same configuration lookup statements. They might appear in different classes and some of the properties might be dynamic while others might be static, which might lead to an inconsistent state. In this situation, it is best practice to aggregate the related config properties in a CDI bean and annotate the CDI bean with the qualifier <strong class="source-inline">@ConfigProperties</strong> so that the property lookup is performed at the same time.</p>
			<p>Let's take an example to see how <strong class="source-inline">@ConfigProperties</strong> works. The following is a custom <strong class="source-inline">ConfigSource</strong>:</p>
			<p class="source-code">config_ordinal=220</p>
			<p class="source-code">customer.forename=Bob</p>
			<p class="source-code">customer.surname=Builder</p>
			<p>To look up the properties related to a particular customer, we can use <strong class="source-inline">@ConfigProperites,</strong> as shown next:</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">@ConfigProperties(prefix = "customer")</p>
			<p class="source-code">public class ConfigProps {</p>
			<p class="source-code">    private String forename;</p>
			<p class="source-code">    private String surname;</p>
			<p class="source-code">    public String getForename() {</p>
			<p class="source-code">        return forename;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public String getSurname() {</p>
			<p class="source-code">        return surname;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>When looking up the properties, you need to use the annotation <strong class="source-inline">@ConfigProperites(prefix="customer")</strong>. The prefix can be omitted if the prefix value is <a id="_idIndexMarker457"/>the same as the CDI bean prefix. If you specify a different prefix value, the specified prefix value will override the value defined on the CDI bean and the specified prefix will be used for looking up the properties.</p>
			<p>Up till now, the config object has been provided by a Config specification implementation, which loads the available config sources and converters. For some advanced use cases where you need to control which config sources and converters are used, you might want to build the config object yourself. MicroProfile Config also offers flexibility for such a use case.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor097"/>Building a Config instance yourself</h2>
			<p>To build a <a id="_idIndexMarker458"/>Config instance, you will need to provide config sources and converters. MicroProfile Config provides a builder for the config object to be built using the following steps:</p>
			<ol>
				<li value="1">First, we need to create a builder as shown in the following code snippet by creating an instance of <strong class="source-inline">ConfigProviderResolver</strong> and then call the <strong class="source-inline">getBuilder()</strong> method to create an instance of a builder:<p class="source-code">ConfigProviderResolver resolver =   ConfigProviderResolver.instance();</p><p class="source-code">ConfigBuilder builder = resolver.getBuilder();</p></li>
				<li>We then add config sources and converters to the builder and then call the <strong class="source-inline">build()</strong> method to build a <strong class="source-inline">config</strong> object as follows:<p class="source-code">Config = builder.addDefaultSources().withSources(aSource)</p><p class="source-code">  .withConverters(aConverter).build();</p></li>
				<li>Next, we need to register the <strong class="source-inline">config</strong> object so that we can always supply the same <strong class="source-inline">config</strong> object to the same <strong class="source-inline">classloader</strong> object, as shown here:<p class="source-code">//register the config with the specified classloader</p><p class="source-code">resolver.registerConfig(config, classloader);</p></li>
				<li>Finally, when we finish using the <strong class="source-inline">config</strong> object, we will need to release it, as shown here:<p class="source-code">//release this config when no longer needed. </p><p class="source-code">resolver.releaseConfig(config);</p></li>
			</ol>
			<p>If a config object is associated with multiple classloaders, when releasing the config object, all occurrences of it will have to be removed.</p>
			<p>We have covered the most useful features of MicroProfile Config. To use the APIs from MicroProfile Config, you need to specify the Maven or Gradle dependencies. We will cover this in<a id="_idIndexMarker459"/> more detail in the next section.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor098"/>Making the MicroProfile Config API available</h2>
			<p>MicroProfile<a id="_idIndexMarker460"/> Config API JARs can be made available for either Maven and Gradle projects. If you create a Maven project, you can directly add the following to your <strong class="source-inline">pom.xml</strong>:</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">  &lt;groupId&gt;org.eclipse.microprofile.config&lt;/groupId&gt;</p>
			<p class="source-code">  &lt;artifactId&gt;microprofile-config-api&lt;/artifactId&gt;</p>
			<p class="source-code">  &lt;version&gt;2.0&lt;/version&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p>Alternatively, if you create a Gradle project, you need to add the following dependency:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">providedCompile org.eclipse.microprofile.config     :microprofile-config-api:2.0</p>
			<p class="source-code">}</p>
			<p>You have learned how to configure your cloud-native applications. The next step is to make your applications resilient. In the next section, we will cover details on how you can make your applications resilient using MicroProfile Fault Tolerance.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor099"/>Making a cloud application resilient using MicroProfile Fault tolerance </h1>
			<p>Why do<a id="_idIndexMarker461"/> you need to care about<a id="_idIndexMarker462"/> resilience? For mission-critical applications, a very brief downtime might cause you a huge penalty. Besides, your customer satisfaction will decrease if your applications are too fragile and aren't resilient. Therefore, you should consider building resilient applications, which means they will function under all kinds of situations with zero downtime. MicroProfile Fault <a id="_idIndexMarker463"/>Tolerance (source code at <a href="https://github.com/eclipse/microprofile-fault-tolerance">https://github.com/eclipse/microprofile-fault-tolerance</a>) introduces several resilience policies that <a id="_idIndexMarker464"/>can help you build a<a id="_idIndexMarker465"/> resilient application. These policies can be applied to CDI beans. It also provides a way to execute method invocations asynchronously via the annotation <strong class="source-inline">@Asynchronous</strong>.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor100"/>@Asynchronous</h2>
			<p>The <a id="_idIndexMarker466"/>annotation <strong class="source-inline">@Asynchronous</strong> can be placed on a CDI bean <a id="_idIndexMarker467"/>class or the methods of a CDI bean class. If placed on a class, it means all of the methods declared on this class will be executed on a separate thread. Methods annotated with <strong class="source-inline">@Asynchronous</strong> must return a <strong class="source-inline">Future</strong> or a <strong class="source-inline">CompletionStage</strong> value, otherwise, <strong class="source-inline">FaultToleranceDefinitionException</strong> will be thrown. The following is a code snippet to show its usage:</p>
			<p class="source-code">@Asynchronous</p>
			<p class="source-code">public CompletionStage&lt;String&gt; serviceA() {</p>
			<p class="source-code">  return CompletableFuture.completedFuture("service a");</p>
			<p class="source-code">}</p>
			<p>The aforementioned example means the invocation of <strong class="source-inline">serviceA()</strong> will be executed on a different thread and then return with <strong class="source-inline">CompletionStage</strong>. If the method returns <strong class="source-inline">Future</strong>, the method call is always considered successful unless the method throws an exception. If the method returns <strong class="source-inline">CompletionStage</strong>, the method call is considered successful only if <strong class="source-inline">CompletionStage</strong> completes without any exceptions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When using the <strong class="source-inline">@Asynchronous</strong> annotation, it is best practice to return <strong class="source-inline">CompletionStage</strong>, which enables other Fault Tolerance policies to be invoked on an abnormal return.</p>
			<p>But what do you do when you hit a temporary network glitch? The first instinct is to try it again, which<a id="_idIndexMarker468"/> is<a id="_idIndexMarker469"/> what this next annotation helps with.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor101"/>@Retry</h2>
			<p>MicroProfile <a id="_idIndexMarker470"/>Fault<a id="_idIndexMarker471"/> Tolerance offers the retry capability via the annotation <strong class="source-inline">@Retry</strong>. When using this annotation, you can specify the following properties:</p>
			<ul>
				<li><strong class="source-inline">maxRetries</strong>: This indicates the maximum number of retries.</li>
				<li><strong class="source-inline">delay</strong>: This indicates the delays between each retry.</li>
				<li><strong class="source-inline">delayUnit</strong>: This specifies the time unit for the delay. </li>
				<li><strong class="source-inline">maxDuration</strong>: This indicates the maximum duration for the overall retries.</li>
				<li><strong class="source-inline">durationUnit</strong>: This specifies the duration unit.</li>
				<li><strong class="source-inline">jitter</strong>: This indicates the random gap per delay.</li>
				<li><strong class="source-inline">jitterDelayUnit</strong>: This specifies the jitter delay unit.</li>
				<li><strong class="source-inline">retryOn</strong>: This indicates the failures that cause the retries.</li>
				<li><strong class="source-inline">abortOn</strong>: This specifies the failures that skip the retries.</li>
			</ul>
			<p>You can add the annotation <strong class="source-inline">@Retry</strong> on any class or business method (<a href="https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#biz_method">https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#biz_method</a>). Let's take a look at the following example:</p>
			<p class="source-code">@Retry(maxRestries=5, delay=400, maxDuaration=4000,   jitter=200, retryOn=Exception.class, abortOn=</p>
			<p class="source-code">    IllegalArgumentException.class)</p>
			<p class="source-code">public void callService(){</p>
			<p class="source-code">    //do something     doSomething();</p>
			<p class="source-code">}</p>
			<p>In the aforementioned code snippet, the <strong class="source-inline">@Retry</strong> annotation means the following:</p>
			<ul>
				<li>An exception other than <strong class="source-inline">IllegalArgumentException</strong> will trigger the <strong class="source-inline">Retry</strong> operation. </li>
				<li>The maximum number of retries is <strong class="source-inline">5</strong> and the maximum duration is <strong class="source-inline">4000</strong> ms (milliseconds). The <strong class="source-inline">Retry</strong> operation will terminate when either condition is met. </li>
				<li>The delay between the retries is <strong class="source-inline">200</strong> ms (jitter) and <strong class="source-inline">600</strong> ms (delay+jitter).</li>
			</ul>
			<p>Sometimes you may not want to keep on retrying; you might want to fail fast and return to the caller<a id="_idIndexMarker472"/> within a time constraint, for instance, if the caller only assigns a <a id="_idIndexMarker473"/>limited waiting time and can't afford to wait till a request returns. The <strong class="source-inline">@Timeout annotation</strong> was introduced to force the operation to return within the specified period.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor102"/>@Timeout</h2>
			<p>The <a id="_idIndexMarker474"/> <strong class="source-inline">@Timeout</strong> annotation specifies the maximum response time. Without<a id="_idIndexMarker475"/> the specified time out, an indefinite wait might occur. With the <strong class="source-inline">@Timeout</strong> annotation, the affected operation needs to return within the specified time duration otherwise, a <strong class="source-inline">TimeoutException</strong> will be thrown. This annotation can be used on a class or any business method. Let's take a look at the following code example:</p>
			<p class="source-code">@Timeout(700)</p>
			<p class="source-code">public String getServiceName() {</p>
			<p class="source-code">   //retrieve the backend service name</p>
			<p class="source-code">}</p>
			<p>In the aforementioned code snippet, the <strong class="source-inline">getServiceName()</strong> operation will either return within <strong class="source-inline">700</strong> ms or throw a <strong class="source-inline">TimeoutException</strong> if the operation takes more than <strong class="source-inline">700</strong> ms to compute.</p>
			<p>If a service is not working, you might not want to wait for the specified timeout and then get a <strong class="source-inline">TimeoutException</strong> repeatedly. It would be good to fail fast after a certain amount of failure time. Failing fast provides time for the backend to recover and the request can <a id="_idIndexMarker476"/>get <a id="_idIndexMarker477"/>feedback immediately. This is what <strong class="source-inline">@CircuitBreaker</strong> does.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor103"/>@CircuitBreaker</h2>
			<p>The <strong class="bold">Circuit Breaker</strong> pattern <a id="_idIndexMarker478"/>helps an invocation fail fast and <a id="_idIndexMarker479"/>provides time for the backend to recover by preventing requests from reaching the backend. How does the Circuit Breaker pattern work? It is very simple. The circuit in the Circuit Breaker pattern is like an electrical circuit. If the circuit is open, there will be no electricity. A closed circuit means normal service. A circuit breaker has three states:</p>
			<ul>
				<li><strong class="bold">Closed</strong>: In this state, any requests will be routed to the backend. The circuit breaker records the success or failure rate for each request. If the failure ratio reaches the configured <strong class="source-inline">failureRatio</strong> within a number of consecutive requests or rolling window, called <strong class="source-inline">requestVolumeThredshold</strong>, the circuit breaker will trip. The circuit breaker will transition its state from closed to open.</li>
				<li><strong class="bold">Open</strong>: In this state, any calls will be returned immediately with <strong class="source-inline">CircuitBreakerOpenException</strong>. After a specified delay period, the circuit breaker will transition to the half-open state.</li>
				<li><strong class="bold">Half-open</strong>: This is a transit state from open to closed. In this state, many requests are allowed to go through. If the consecutive success number reaches the configured <strong class="source-inline">successThreshold</strong>, the circuit breaker will transition to the <strong class="bold">Closed</strong> state.</li>
			</ul>
			<p>The circuit breaker has the following parameters:</p>
			<ul>
				<li><strong class="source-inline">requestVolumeThreshold</strong> specifies the size of the rolling window where the circuit breaker will be assessed. If the value of <strong class="source-inline">requestVolumeThreshold</strong> is 10, it means the circuit breaker will only be checked after 10 requests.</li>
				<li><strong class="source-inline">failureRatio</strong> controls the failure rate within the rolling window. If the failure rate is equal to or above the <strong class="source-inline">failureRatio</strong> parameter, the circuit breaker will trip open.</li>
				<li><strong class="source-inline">successThreshold</strong> specifies the criteria when the circuit breaker transitions from half-open to closed. If the value of <strong class="source-inline">successThreshold</strong> is <strong class="source-inline">2</strong>, it means after 2 successful requests, the circuit breaker will transition from half-open to closed. </li>
				<li><strong class="source-inline">delay</strong> and <strong class="source-inline">delayUnit</strong> indicate how long the circuit breaker stays open. The circuit breaker will not <a id="_idIndexMarker480"/>stay open forever. </li>
				<li><strong class="source-inline">failOn</strong> specifies<a id="_idIndexMarker481"/> the exceptions that are considered to be failures.</li>
				<li><strong class="source-inline">skipOn</strong> states the exceptions that are excluded from contributing towards the circuit breaker.</li>
			</ul>
			<p>The Circuit Breaker pattern can be specified via the <strong class="source-inline">@CircuitBreaker annotation</strong>. The <strong class="source-inline">@CircuitBreaker</strong> annotation can be placed on a class or a business method to avoid repeated failures. You can configure the parameters on the annotation, as follows:</p>
			<p class="source-code">@CircuitBreaker(requestVolumeThreshold = 10,   failureRatio=0.5, successThreshold = 3, delay = 2,     delayUnit=ChronoUnit.SECONDS, failOn={ExceptionA.class,         ExceptionB.class}, skipOn=ExceptionC.class)</p>
			<p>In the aforementioned code snippet, it means the circuit breaker will trip to open if there are 5 or more (10*0.5) failures among <strong class="source-inline">10</strong> (<strong class="source-inline">requestVolumeThreshold</strong>) consecutive requests. After 2 seconds, specified by the parameters <strong class="source-inline">delay</strong> and <strong class="source-inline">delayUnit</strong>, the circuit will transition to half-open. After 3 (<strong class="source-inline">successThreshold</strong>) consecutive successes, the circuit breaker will transition to close. </p>
			<p>When deciding whether an invocation should be treated as a failure or not, the criteria is that the exception from the invocation must be assignable to <strong class="source-inline">ExceptionA</strong> or <strong class="source-inline">ExceptionB</strong> but not assignable to <strong class="source-inline">ExceptionC</strong>. If an exception is assignable to <strong class="source-inline">ExceptionC</strong>, this execution will be treated not as a failure but as a success when counting towards a circuit breaker.</p>
			<p class="callout-heading">Success in Circuit Breaker </p>
			<p class="callout">The success marked by the annotation <strong class="source-inline">@CircuitBreaker</strong> does not mean the operation returns normally. It only means that the return is treated as a success by Circuit Breaker. For instance, if a returned exception is assignable to any of the <strong class="source-inline">skipOn</strong> exceptions, the exception does not count as a failure but counts as a success instead.</p>
			<p>The scope of <strong class="source-inline">@CircuitBreaker</strong> annotation is per class per method, which means all instances for a particular class share the same circuit breaker for the same method. When applying <strong class="source-inline">@CircuitBreaker</strong> annotation on a CDI bean, it is irrelevant what CDI scope the<a id="_idIndexMarker482"/> bean<a id="_idIndexMarker483"/> has. All invocations for a particular method share the same circuit breaker.</p>
			<p>In a mission-critical service, it is important to ensure that the service has fault isolation capabilities, preventing faults in one part of the system cascading to the entire system. This is known as <strong class="bold">the Bulkhead pattern</strong>.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor104"/>The Bulkhead pattern</h2>
			<p>The Bulkhead <a id="_idIndexMarker484"/>pattern is to prevent one failure from cascading, which then brings down the whole application. The Bulkhead pattern is achieved by limiting the number of concurrent requests accessing a resource. There are two different types of <a id="_idIndexMarker485"/>bulkhead: <strong class="bold">Semaphore</strong> isolation and <strong class="bold">Thread Pool</strong> isolation. </p>
			<h3>Semaphore isolation</h3>
			<p>Semaphore<a id="_idIndexMarker486"/> isolation limits the number of concurrent<a id="_idIndexMarker487"/> requests to a specified number. You can directly use <strong class="source-inline">@Bulkhead(n)</strong> to limit the maximum requests where <strong class="source-inline">n</strong> is the number of concurrent requests. The extra request <strong class="source-inline">n+1</strong> will fail with <strong class="source-inline">BulkheadException</strong>.</p>
			<p>However, sometimes you might want to have a waiting queue for the extra requests to queue. For this requirement, you will need to use Thread Pool isolation.</p>
			<h3>Thread Pool isolation</h3>
			<p>Thread<a id="_idIndexMarker488"/> Pool isolation also limits a certain number of <a id="_idIndexMarker489"/>concurrent requests. It dispatches a new thread for method execution. In addition, it also has a waiting queue to store the extra requests. Only when the waiting queue is full, <strong class="source-inline">BulkheadException</strong> will be thrown.</p>
			<p>To define Thread Pool isolation, you need to use <strong class="source-inline">@Bulkhead</strong> together with <strong class="source-inline">@Asynchronous</strong> as shown here:</p>
			<p class="source-code">@Asynchronous</p>
			<p class="source-code">@Bulkhead(value=5, waitingTaskQueue=6)</p>
			<p class="source-code">public CompletionStage&lt;String&gt; serviceA() {</p>
			<p class="source-code">}</p>
			<p>The aforementioned code snippet means the size of the bulkhead is <strong class="source-inline">5</strong>, which allows 5 concurrent requests accessing the method <strong class="source-inline">serviceA()</strong>. The extra requests will be queued in the waiting queue. When the waiting queue is full, the extra requests will cause <strong class="source-inline">BulkheadException</strong> to be thrown.</p>
			<p>Similar to the <strong class="source-inline">@CircuitBreaker</strong> annotation, the scope of <strong class="source-inline">@Bulkhead</strong> annotation is per class per method, which means all instances for a particular class share the same bulkhead for the same method. When applying a <strong class="source-inline">@Bulkhead</strong> annotation on a CDI bean, it is irrelevant what CDI scope the bean has. All invocations for a particular method share the same bulkhead.</p>
			<p>Apart from Retry, the Fault Tolerance policies we have covered so far are about failing gracefully. However, sometimes, you want to return a reasonable response to your caller. In these circumstances, you should provide an alternative answer. This is what the Fallback policy is for.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor105"/>Fallback</h2>
			<p>The <strong class="bold">Fallback</strong> policy <a id="_idIndexMarker490"/>provides <a id="_idIndexMarker491"/>a way to specify a backup action, which will be executed if the current operation fails. The way to apply the Fallback policy is to apply the <strong class="source-inline">@Fallback</strong> annotation. The <strong class="source-inline">@Fallback</strong> annotation has the following parameters:</p>
			<ul>
				<li><strong class="source-inline">value</strong>: This specifies a class that implements the <strong class="source-inline">FallbackHandler</strong> interface.</li>
				<li><strong class="source-inline">fallbackMethod</strong>: This method specifies the fallback method name. The fallback method must be defined in the same class as the method applying the <strong class="source-inline">@Fallback</strong> annotation.</li>
				<li><strong class="source-inline">applyOn</strong>: This defines the criteria when the Fallback policy should be applied.</li>
				<li><strong class="source-inline">skipOn</strong>: This defines the criteria when the Fallback policy should be skipped.</li>
			</ul>
			<p>The <strong class="source-inline">value</strong> and <strong class="source-inline">fallbackMethod</strong> parameters are mutually exclusive. If you specify both on the <strong class="source-inline">@Fallback</strong>, annotation <strong class="source-inline">FaultToleranceDefinitionException</strong> will be thrown. To specify the backup operation, you need to either define the <strong class="source-inline">fallbackMethod</strong> or <strong class="source-inline">value</strong> parameter.</p>
			<p>The <strong class="source-inline">fallbackMethod</strong> signature<a id="_idIndexMarker492"/> and return type must match the method that defines the Fallback policy. The <strong class="source-inline">value</strong> parameter should be used if you would like to define a handler to handle multiple Fallback policies. </p>
			<p>You can use <strong class="source-inline">skipOn</strong> or <strong class="source-inline">applyOn</strong> to specify what exception should trigger the fallback operation. As the name says, all exceptions and the subclasses listed under <strong class="source-inline">skipOn</strong> will bypass fallback while the exception and their subclasses listed by <strong class="source-inline">applyOn</strong> should trigger the fallback operation. When <strong class="source-inline">skipOn</strong> and <strong class="source-inline">applyOn</strong> are used together, <strong class="source-inline">skipOn</strong> takes precedence.</p>
			<p>Let's look at the following code snippet for an example of the Fallback policy:</p>
			<p class="source-code">@Fallback(fallbackMethod="myFallback", </p>
			<p class="source-code">  applyOn={ExceptionA.class, ExceptionB.class},    skipOn={ExceptionAsub.class})</p>
			<p class="source-code">public String callService() {</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p class="source-code">public String myFallback() {</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p>In the aforementioned code snippet, if the method <strong class="source-inline">callService()</strong> throws an exception and if this exception is assignable to <strong class="source-inline">ExceptionAsub</strong>, the exception will be rethrown and the fallback method <strong class="source-inline">myFallback</strong> will not be executed. However, if the thrown exception is not assignable to <strong class="source-inline">ExceptionAsub</strong> and assignable to <strong class="source-inline">ExceptionA</strong> or <strong class="source-inline">ExceptionB</strong>, the fallback method <strong class="source-inline">myFallback</strong> will be triggered.</p>
			<p>We have covered all of the Fallback policies so far. You might have realized that all of the policies are annotations. Actually, these annotations are CDI interceptor bindings, which means they only work on business method invocations on CDI beans, as explained at  <a href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#biz_method">https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#biz_method</a>. </p>
			<p>CDI interceptors have a priority. In Fault Tolerance, some implementations provide one interceptor for<a id="_idIndexMarker493"/> all the interceptor bindings while others might provide multiple<a id="_idIndexMarker494"/> interceptors. The Fault Tolerance specification declared the base priority to be <strong class="source-inline">Priority.PLATFORM_AFTER (4000)+10</strong>, which is <strong class="source-inline">4010</strong>. If multiple interceptors are provided by an implementation, the priority range should be between base priority and base priority + 40 so that other application interceptors can define their priorities accordingly based on whether they want to be invoked before or after Fault Tolerance interceptors. You can update the base priority via the property <strong class="source-inline">mp.fault.tolerance.interceptor.priority</strong>. </p>
			<p>A method annotated with Fault Tolerance annotations may also specify any other <strong class="bold">Interceptor Bindings</strong>. The <a id="_idIndexMarker495"/>invocation order on the interceptors will be determined by the priority of the interceptors. </p>
			<p>So far, we have covered all Fault Tolerance annotations. You might be wondering whether you could use these annotations together. Yes, of course. We will discuss this in more detail in the next section.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor106"/>Using Fault Tolerance annotations together</h2>
			<p>It is fine to use <a id="_idIndexMarker496"/>annotations together to achieve multiple Fault Tolerance capabilities such as setting up for <strong class="source-inline">Retry</strong> and <strong class="source-inline">Timeout</strong> together. Let's take a look at the following example:</p>
			<p class="source-code">@GET</p>
			<p class="source-code">@Path("/{parameter}")</p>
			<p class="source-code">@Asynchronous</p>
			<p class="source-code">@CircuitBreaker</p>
			<p class="source-code">@Retry</p>
			<p class="source-code">@Bulkhead</p>
			<p class="source-code">@Timeout(200)</p>
			<p class="source-code">@Fallback(fallbackMethod = "myFallback")</p>
			<p class="source-code">public CompletionStage&lt;String&gt; doSomething(@PathParam</p>
			<p class="source-code">  ("parameter") String parameter) {</p>
			<p class="source-code">//do something</p>
			<p class="source-code">}</p>
			<p>The aforementioned code snippet means that the operation <strong class="source-inline">doSomething()</strong> applies all of the Fault Tolerance policies. If this method throws an exception, the following Fault Tolerance policies will be applied in this order:</p>
			<ol>
				<li value="1">Check whether the <strong class="source-inline">CircuitBreaker</strong> is open. </li>
				<li>If it is not open, the timer will start recording the time duration. </li>
				<li>Try to get a slot in <strong class="source-inline">Bulkhead</strong>. </li>
				<li>If there are 10 running tasks already, it will queue up in the waiting queue, which has 10 slots. However, if there is no free slot in the waiting queue, a <strong class="source-inline">BulkheadException</strong> exception will be thrown. If there is a slot in the waiting queue, it will wait to be scheduled. During the waiting, if the timeout duration exceeds <strong class="source-inline">200</strong> milliseconds, <strong class="source-inline">TimeoutException</strong> will be thrown. The thrown exception will be recorded in the <strong class="source-inline">CircuitBreaker</strong> record and then trigger <strong class="source-inline">Retry</strong>. Go back to <em class="italic">step 1</em> for <strong class="source-inline">Retry</strong>.</li>
			</ol>
			<p>After <strong class="source-inline">Retry</strong> has been exhausted, the Fallback policy will be triggered.</p>
			<p>You might have noticed that the parameters on each annotation have default values. You can also<a id="_idIndexMarker497"/> specify values on the annotations. Are you wondering whether the values are configurable? Let's discuss this in the next section!</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor107"/>Fault Tolerance configuration</h2>
			<p>The good <a id="_idIndexMarker498"/>news is that all of the parameters on the annotations are configurable. The values can be overridden either globally or individually. This is achieved via <strong class="bold">MicroProfile Config</strong>. All of the parameters are properties. Their values can be specified in any configured config source.</p>
			<h3>Overriding parameter values</h3>
			<p>To override <a id="_idIndexMarker499"/>individual annotation parameters, you can use method-level configuration, class-level configuration, or global configuration as explained here:</p>
			<ul>
				<li><strong class="bold">Method-level configuration</strong>: It is specified using the format <em class="italic">&lt;fully.qualified.class.name&gt;/&lt;method.name&gt;/&lt;annotation.name&gt;/&lt;parameter.name&gt;</em>. </li>
				<li><strong class="bold">Class-level configuration</strong>: It is specified using the format <em class="italic">&lt;fully.qualified.class.name&gt;/&lt;annotation.name&gt;/&lt;parameter.name&gt;</em>.</li>
				<li><strong class="bold">Global configuration</strong>: It is specified using the format<em class="italic"> &lt;annotation.name&gt;/&lt;parameter.name&gt;</em>.</li>
			</ul>
			<p>Let's take a look at an example to explain further:</p>
			<p class="source-code">package cloudnative.sample.fault.tolerance;</p>
			<p class="source-code">public class FaultToleranceDemo {</p>
			<p class="source-code">    @Timeout(500)</p>
			<p class="source-code">    @Retry(maxRetries = 6)</p>
			<p class="source-code">    @GET</p>
			<p class="source-code">    public String invokeService() {</p>
			<p class="source-code">        //do something</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This code snippet sets the <strong class="source-inline">Timeout</strong> to be <strong class="source-inline">500</strong> milliseconds with at most <strong class="source-inline">6</strong> retries. To set <strong class="source-inline">Timeout</strong> to <strong class="source-inline">300</strong> milliseconds and at most <strong class="source-inline">10</strong> retries, you can specify the following method-level<a id="_idIndexMarker500"/> config properties in any config sources:</p>
			<p class="source-code">cloudnative.sample.fault.tolerance.FaultToleranceDemo/invokeService/Timeout/value=300</p>
			<p class="source-code">cloudnative.sample.fault.tolerance.FaultToleranceDemo/invokeService/Retry/maxRetries=10</p>
			<p>Alternatively, if you would like to update all of the timeout and the maximum of retries for this class, you can just omit the method names, which means the configurations are appliable to all of the methods with the corresponding annotations specified. Then, specify the following class-level configuration in a configured config source:</p>
			<p class="source-code">cloudnative.sample.fault.tolerance.FaultToleranceDemo/Timeout/value=300</p>
			<p class="source-code">cloudnative.sample.fault.tolerance.FaultToleranceDemo/Retry/maxRetries=10</p>
			<p>Sometimes, you might want to specify the same timeout value for all of the classes under one application. It is simple. Just omit the fully qualified class name. Therefore, you can use the following global configuration to achieve that:</p>
			<p class="source-code">Timeout/value=300</p>
			<p class="source-code">Retry/maxRetries=10</p>
			<p>Sometimes, your cloud infrastructure, such as <strong class="bold">Istio</strong>, which we will discuss in <a href="B17377_07_Final_SB_epub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes</em>, provides some Fault Tolerance capabilities. However, cloud infrastructure will not be able to provide fallback capabilities as the infrastructure needs business knowledge. If you prefer to use the Fault Tolerance capabilities provided by Istio, you might want to turn off some MicroProfile Fault Tolerance capabilities. If you don't, you will get both Fault Tolerance functionalities <a id="_idIndexMarker501"/>and they will interfere with each other. </p>
			<h3>Disabling Fault Tolerance policies</h3>
			<p>If you want to <a id="_idIndexMarker502"/>use the Fault Tolerance policies provided by Istio, you can specify the following property to turn off all of Fault Tolerance policies except <strong class="source-inline">Fallback</strong>:</p>
			<p class="source-code">MP_Fault_Tolerance_NonFallback_Enabled=false</p>
			<p>To disable a particular policy on a method, specify the following method-level property:</p>
			<p class="source-code">&lt;fully.qualified.class.name&gt;/&lt;method.name&gt;/&lt;annotation&gt;/enabled=false</p>
			<p>In the previous example, in order to turn off <strong class="source-inline">Timeout</strong> on the method <strong class="source-inline">invokeService()</strong>, specify the following method-level configuration:</p>
			<p class="source-code">cloudnative.sample.fault.tolerance.FaultToleranceDemo/invokeService/Timeout/enabled=false</p>
			<p>Alternatively, in order to turn off <strong class="source-inline">Timeout</strong> on the class, specify the following class-level configuration.</p>
			<p class="source-code">cloudnative.sample.fault.tolerance.FaultToleranceDemo/Timeout/enabled=false</p>
			<p>To disable the <strong class="source-inline">Timeout</strong> capability for your cloud-native application, specify the following property:</p>
			<p class="source-code">Timeout/enabled=false</p>
			<p>If multiple configurations are specified, the configuration specified on the method level has a higher priority, followed by class-level configuration and then global configuration.</p>
			<p>So far, you have learned how to apply Fault Tolerance policies to some operations and configure the policies. However, these policies are there to be triggered under some criteria. It is very possible that none of the policies are utilized. You might be keen to find out whether any Fault Tolerance policies are activated. In response to this need, we have Fault Tolerance metrics. Let's take a look at them in the next section.</p>
			<h3>Fault Tolerance metrics</h3>
			<p>MicroProfile<a id="_idIndexMarker503"/> Fault Tolerance, when used together with MicroProfile Metrics, is able to emit some useful metrics for the Retry, Timeout, CircuitBreaker, Bulkhead, and Fallback policies. In the following tables, I have listed all of the relevant metrics.</p>
			<p>The following table shows the general metrics whenever Fault Tolerance is applied:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Table_5.1_new.jpg" alt="Table 5.1 – Method invocation metrics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.1 – Method invocation metrics</p>
			<p>If <strong class="source-inline">@Retry</strong> is used, the metrics for retry will be provided:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Table_5.2_new.jpg" alt="Table 5.2 – Retry metrics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.2 – Retry metrics</p>
			<p>If <strong class="source-inline">@Timeout</strong> is used, the following metrics will be provided:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Table_5.3_new.jpg" alt="Table 5.3 – Timeout metrics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.3 – Timeout metrics</p>
			<p>If <strong class="source-inline">@CircuitBreaker</strong> is used, you<a id="_idIndexMarker504"/> will see the following metrics:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Table_5.4_new.jpg" alt="Table 5.4 – CircuitBreaker metrics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.4 – CircuitBreaker metrics</p>
			<p>If <strong class="source-inline">@Bulkhead</strong> is used, you will be able to see the following metrics:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Table_5.5_new.jpg" alt="Table 5.5 – Bulkhead metrics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.5 – Bulkhead metrics</p>
			<p>You have<a id="_idIndexMarker505"/> learned about all of the functionalities of Fault Tolerance. You might be wondering how to start using the APIs provided by Fault Tolerance. We will discuss this in the next section.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor108"/>Making the MicroProfile Fault Tolerance API available</h2>
			<p>MicroProfile<a id="_idIndexMarker506"/> Fault Tolerance API JARs can be made available for either Maven and Gradle projects. If you create a Maven project, you can directly add the following to your <strong class="source-inline">pom.xml</strong>:</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">  &lt;groupId&gt;</p>
			<p class="source-code">    org.eclipse.microprofile.fault.tolerance</p>
			<p class="source-code">  &lt;/groupId&gt;</p>
			<p class="source-code">  &lt;artifactId&gt;microprofile-fault-tolerance-api&lt;/artifactId&gt;</p>
			<p class="source-code">  &lt;version&gt;3.0&lt;/version&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p>Alternatively, if you create a Gradle project, you need to add the following dependency:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">providedCompile org.eclipse.microprofile.fault.tolerance:  microprofile-fault-tolerance-api:3.0</p>
			<p class="source-code">}</p>
			<p>You have now<a id="_idIndexMarker507"/> learned how to make your cloud-native applications resilient. The next step is to document your applications. You will learn how to document your applications using MicroProfile OpenAPI in the next section.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor109"/>Documenting cloud native applications using MicroProfile OpenAPI</h1>
			<p>As <a id="_idIndexMarker508"/>mentioned in <a href="B17377_02_Final_SB_epub.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">How Does MicroProfile Fit into Cloud-Native Applications?</em>, you<a id="_idIndexMarker509"/> might have difficulties remembering what functionalities a particular cloud-native application has when you have tens or hundreds of cloud-native applications to manage. You will need to provide documentation for them. With documented endpoints, some clients can discover and invoke them.</p>
			<p><strong class="bold">MicroProfile OpenAPI</strong> (source code at <a href="https://github.com/eclipse/microprofile-open-api/">https://github.com/eclipse/microprofile-open-api/</a>) provides a <a id="_idIndexMarker510"/>set of annotations and programming models that enable you to document cloud-native applications and then produce documents conforming to the <strong class="bold">OpenAPI</strong> v3 specification (<a href="https://github.com/OAI/OpenAPI-Specification">https://github.com/OAI/OpenAPI-Specification</a>). The OpenAPI v3 specification defines a set of interfaces for documenting and exposing RESTful APIs. MicroProfile OpenAPI adopts the OpenAPI Specification and further simplifies the OpenAPI model so that it is much easier for Java developers to document their cloud-native applications. </p>
			<p>MicroProfile<a id="_idIndexMarker511"/> OpenAPI <a id="_idIndexMarker512"/>offers three ways to document cloud-native applications:</p>
			<ul>
				<li>By applying <strong class="bold">MicroProfile OpenAPI</strong> annotations on JAX-RS operations</li>
				<li>Using the programming model from <strong class="bold">MicroProfile OpenAPI</strong> to provide an <strong class="bold">OpenAPI</strong> model tree</li>
				<li>Using pre-generated <strong class="bold">OpenAPI</strong> documents</li>
			</ul>
			<p>In the next section, we will cover these three mechanisms in more detail.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor110"/>Applying MicroProfile OpenAPI annotations on JAX-RS operations</h2>
			<p>The simple <a id="_idIndexMarker513"/>way to<a id="_idIndexMarker514"/> produce documentation for your JAX-RS operations is to add MicroProfile OpenAPI annotations. A few useful and widely used annotations are listed here:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Table_5.6.jpg" alt="Table 5.6 – MicroProfile OpenAPI annotations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.6 – MicroProfile OpenAPI annotations</p>
			<p>The following <a id="_idIndexMarker515"/>is an example<a id="_idIndexMarker516"/> of using OpenAPI annotations to document an operation in the IBM StockTrader app <strong class="bold">Trade-History</strong>:</p>
			<p class="source-code">@APIResponses(value = {</p>
			<p class="source-code">        @APIResponse(</p>
			<p class="source-code">            responseCode = "404",</p>
			<p class="source-code">            description = "The Mongo database cannot be               found. ", content = @Content(                        mediaType = "text/plain")),</p>
			<p class="source-code">        @APIResponse(</p>
			<p class="source-code">            responseCode = "200",</p>
			<p class="source-code">            description = "The latest trade has been               retrieved successfully.",</p>
			<p class="source-code">            content = @Content(mediaType = "application/json",                        schema = @Schema(implementation =                           Quote.class)))})</p>
			<p class="source-code">    @Operation(</p>
			<p class="source-code">        summary = "Shows the latest trade.",</p>
			<p class="source-code">        description = "Retrieve the latest record from the           mongo database."</p>
			<p class="source-code">    )</p>
			<p class="source-code">public String latestBuy() {</p>
			<p class="source-code">. . .</p>
			<p class="source-code">}</p>
			<p>The aforementioned code snippet documents two responses with the annotation <strong class="source-inline">@APIResponse</strong>: <strong class="source-inline">404</strong> and <strong class="source-inline">200</strong>. The annotation <strong class="source-inline">@Operation</strong> documents the purpose<a id="_idIndexMarker517"/> of <a id="_idIndexMarker518"/>the operation. The OpenAPI document generated with the preceding annotations is detailed here:</p>
			<p class="source-code">---</p>
			<p class="source-code">openapi: 3.0.3</p>
			<p class="source-code">info:</p>
			<p class="source-code">  title: Generated API</p>
			<p class="source-code">  version: "1.0"</p>
			<p class="source-code">servers:</p>
			<p class="source-code">- url: http://localhost:9080</p>
			<p class="source-code">- url: https://localhost:9443</p>
			<p class="source-code">paths:</p>
			<p class="source-code">  /data/latestBuy:</p>
			<p class="source-code">    get:</p>
			<p class="source-code">      summary: Shows the latest trade.</p>
			<p class="source-code">      description: Retrieve the latest record from the         mongo database.</p>
			<p class="source-code">      responses:</p>
			<p class="source-code">        "404":</p>
			<p class="source-code">          description: 'The Mongo database cannot be found'</p>
			<p class="source-code">          content:</p>
			<p class="source-code">            text/plain: {}</p>
			<p class="source-code">        "200":</p>
			<p class="source-code">          description: The latest trade has been retrieved             successfully.</p>
			<p class="source-code">          content:</p>
			<p class="source-code">            application/json:</p>
			<p class="source-code">              schema:</p>
			<p class="source-code">                $ref: '#/components/schemas/Quote'</p>
			<p class="source-code">components:</p>
			<p class="source-code">  schemas:</p>
			<p class="source-code">    Quote:</p>
			<p class="source-code">      type: object</p>
			<p class="source-code">      properties:</p>
			<p class="source-code">        date:</p>
			<p class="source-code">          type: string</p>
			<p class="source-code">        price:</p>
			<p class="source-code">          format: double</p>
			<p class="source-code">          type: number</p>
			<p class="source-code">        symbol:</p>
			<p class="source-code">          type: string</p>
			<p class="source-code">        time:</p>
			<p class="source-code">          format: int64</p>
			<p class="source-code">          type: integer</p>
			<p>In the aforementioned document, the endpoint path and the <strong class="source-inline">get</strong> operation description were explained with the information from the annotation <strong class="source-inline">@Operation</strong>. Further on, the responses for <strong class="source-inline">200</strong> and <strong class="source-inline">404</strong> were described from the information provided by the <strong class="source-inline">@APIResponse</strong> annotation. As for the response for the return code <strong class="source-inline">200</strong>, the schema <strong class="source-inline">Quote</strong> was referenced by the annotation <strong class="source-inline">@Schema</strong>, so <strong class="source-inline">$ref: '#/components/schemas/Quote</strong> was displayed as the schema reference. The reference points to the section <strong class="source-inline">components/ schemas/Quote</strong>, which displays the details of the schema <strong class="source-inline">Quote</strong>.</p>
			<p>Without using any MicroProfile OpenAPI annotations, MicroProfile OpenAPI still generates an OpenAPI document for all of the JAX-RS endpoints with minimum information. The <a id="_idIndexMarker519"/>following<a id="_idIndexMarker520"/> is the example for the endpoint <strong class="source-inline">latestBuy</strong> if no OpenAPI annotations are applied. It only lists the minimum information on the successful return code <strong class="source-inline">200</strong>:</p>
			<p class="source-code">---</p>
			<p class="source-code">openapi: 3.0.3</p>
			<p class="source-code">info:</p>
			<p class="source-code">  title: Generated API</p>
			<p class="source-code">  version: "1.0"</p>
			<p class="source-code">servers:</p>
			<p class="source-code">- url: http://localhost:9080</p>
			<p class="source-code">- url: https://localhost:9443</p>
			<p class="source-code">paths:</p>
			<p class="source-code">  /data/latestBuy:</p>
			<p class="source-code">    get:</p>
			<p class="source-code">      responses:</p>
			<p class="source-code">        "200":</p>
			<p class="source-code">          description: OK</p>
			<p class="source-code">          content:</p>
			<p class="source-code">            application/json:</p>
			<p class="source-code">              schema:</p>
			<p class="source-code">                type: string</p>
			<p>Apart from using MicroProfile OpenAPI annotations, you can use a programming model to <a id="_idIndexMarker521"/>generate<a id="_idIndexMarker522"/> documents. We will discuss this in the next section.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor111"/>Using a programming model to generate documentation</h2>
			<p>Sometimes, it <a id="_idIndexMarker523"/>might not be possible to put MicroProfile OpenAPI annotations on JAX-RS operations. In this case, you can provide your own implementation of <strong class="bold">OASModelReader</strong> from MicroProfile OpenAPI. The OASModelReader API provides a way for an OpenAPI document to be built from scratch. Follow the steps mentioned to build an OpenAPI model tree:</p>
			<ol>
				<li value="1">Implement the <strong class="source-inline">org.eclipse.microprofile.openapi.OASModelReader</strong> interface. You can see an example here: <a href="https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples">https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples</a>.</li>
				<li>Register the implementation using the <strong class="source-inline">mp.openapi.model.reader</strong> configuration key and store the configuration in a config source.</li>
				<li>If providing a complete OpenAPI model tree, set the configuration <strong class="source-inline">mp.openap.scan.disabled=true</strong>.</li>
			</ol>
			<p>The link <a href="https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples">https://github.com/eclipse/microprofile-open-api/wiki/OASModelReader-Samples</a> provides an example of implementing <strong class="source-inline">OASModelReader</strong>. In <em class="italic">step 2</em> and <em class="italic">step 3</em>, you can specify the properties under <strong class="source-inline">META-INF/microprofile-config.properties</strong> or as system properties.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor112"/>Using pre-generated OpenAPI documents</h2>
			<p>Sometimes, you<a id="_idIndexMarker524"/> will <a id="_idIndexMarker525"/>write OpenAPI documents first by using an editor such as the Swagger Editor (<a href="https://editor.swagger.io/">https://editor.swagger.io/</a>). Documents must be named <strong class="source-inline">openapi</strong> with a <strong class="source-inline">yml</strong>, <strong class="source-inline">yaml</strong>, or <strong class="source-inline">json</strong> file extension and be placed under the <strong class="source-inline">MEAT-INF</strong> directory. If the document is complete, you can set the property <strong class="source-inline">mp.openap.scan.disabled=true</strong>. Otherwise, the scan operation will be performed to discover any MicroProfile OpenAPI annotations.</p>
			<p>So far, we have briefly introduced the three ways to create OpenAPI documents. The documents can be viewed using the URL <a href="http://host_name/port_number/openapi">http://host_name/port_number/openapi</a>. Open Liberty, which will be discussed in <a href="B17377_07_Final_SB_epub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes</em>, has the Swagger UI integrated, so you can visit <a href="http://host_name/port_number/openapi/ui">http://host_name/port_number/openapi/ui</a> for a GUI view, where you can supply parameters and then directly invoke the individual endpoints. More information on this UI will be covered in <a href="B17377_09_Final_SB_epub.xhtml#_idTextAnchor173"><em class="italic">Chapter 9</em></a>, <em class="italic">Deployment and Day 2 Operations</em>.</p>
			<p>Cloud-native application developers may wish to remove or update certain elements of the OpenAPI document. This is done via a filter, which is invoked once the OpenAPI document is created. We will discuss filters in the next section.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor113"/>Applying filters to the OpenAPI document</h2>
			<p>If you want to<a id="_idIndexMarker526"/> add some information to the OpenAPI document, you can create a filter. The filter needs to implement the OASFilter interface, which provides a way to update an OpenAPI document. Let's look at the following filter:</p>
			<p class="source-code">public class MyOASFilter implements OASFilter {</p>
			<p class="source-code">  @Override</p>
			<p class="source-code">  public void filterOpenAPI(OpenAPI openAPI) {</p>
			<p class="source-code">    openAPI.setInfo(OASFactory.createObject(Info.class)      .title("Stock App").version("1.0").description         ("App for displaying stocks.").license           (OASFactory.createObject(License.class)            .name("Apache License 2.0").url               ("https://www.apache.org/licenses/                LICENSE-2.0"))); //1</p>
			<p class="source-code">    openAPI.addServer(OASFactory.createServer()      .url("http://localhost:{port}").description         ("Open Liberty Server.").variables(Collections           .singletonMap("port",OASFactory             .createServerVariable().defaultValue("9080")              .description("HTTP port.")))); //2   </p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the<a id="_idIndexMarker527"/> aforementioned code snippet, the <strong class="source-inline">filterOpenAPI()</strong> method filters the OpenAPI element. This method is called only once as the last method for a particular filter. It provides the <strong class="source-inline">info</strong> and the <strong class="source-inline">servers</strong> elements of the OpenAPI document.</p>
			<p>After you have created a filter class, the next step is to specify the configuration <strong class="source-inline">mp.openapi.filter=com.acme.MyOASFilter</strong> in a config source, such as<strong class="source-inline"> microprofile-config.properties</strong>.</p>
			<p>A MicroProfile OpenAPI implementation generates the documents in the following sequence:</p>
			<ol>
				<li value="1">The implementation fetches configuration values with the prefix of <strong class="source-inline">mp.openapi</strong>.</li>
				<li>It then invokes <strong class="source-inline">OASModelReader</strong>.</li>
				<li>It fetches static OpenAPI files with the name of <strong class="source-inline">openapi.yml</strong>, <strong class="source-inline">openapi.yaml</strong>, or <strong class="source-inline">openapi.json</strong>.</li>
				<li>It processes MicroProfile OpenAPI annotations.</li>
				<li>Finally, it filters the OpenAPI documentation via <strong class="source-inline">OASFilter</strong>.</li>
			</ol>
			<p>As mentioned in <em class="italic">step 1</em>, several configurations with the prefix of <strong class="source-inline">mp.openapi</strong> can be defined by <a id="_idIndexMarker528"/>MicroProfile OpenAPI. We will go through the configurations in the next section.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor114"/>MicroProfile OpenAPI configuration</h2>
			<p>MicroProfile OpenAPI<a id="_idIndexMarker529"/> provides some flexibility for application developers to configure the process when generating OpenAPI documents. The configurations are listed in the following table:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Table_5.7.jpg" alt="Table 5.7 – MicroProfile OpenAPI configurations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.7 – MicroProfile OpenAPI configurations</p>
			<p>Now we have covered how <strong class="bold">MicroProfile OpenAPI</strong> works. The implementation of MicroProfile <a id="_idIndexMarker530"/>OpenAPI will generate an OpenAPI document based on MicroProfile OpenAPI policies. Where can you view the fully processed OpenAPI document? In the next section, we will discuss where the OpenAPI document can be accessed.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor115"/>Viewing an OpenAPI document</h2>
			<p>The fully processed <a id="_idIndexMarker531"/>OpenAPI document must be available at the root URL <strong class="source-inline">/openapi</strong>, as an HTTP <strong class="source-inline">Get</strong> operation, such as <strong class="source-inline">http://localhost:9080/openapi</strong>. The default format of the document is YAML. Support for the JSON format is required if the response contains a <strong class="source-inline">Content-Type</strong> header with a value of <strong class="source-inline">application/json</strong>. Open Liberty supports the query parameter format, which allows you to specify whether you want YAML or JSON format. For instance, the endpoint <strong class="source-inline">http://localhost:9080/openapi?format=JSON</strong> displays the OpenAPI document in JSON format, while the endpoint <a href="http://localhost:9080/openapi?format=YAML">http://localhost:9080/openapi?format=YAML</a> displays an OpenAPI document in YAML format.</p>
			<p>Open Liberty provides a UI for OpenAPI documents, where you can invoke the endpoints included. The UI is available at the root URL <strong class="source-inline">/openapi/ui</strong>. </p>
			<p>You have learned how MicroProfile OpenAPI works and where to find the OpenAPI documents. Now, you are ready to use MicroProfile OpenAPI. In the next section, we will discuss <a id="_idIndexMarker532"/>how to make the APIs available to your Maven and Gradle projects.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor116"/>Making MicroProfile OpenAPI APIs available</h2>
			<p>To use <a id="_idIndexMarker533"/>MicroProfile OpenAPI APIs, you need to make these APIs available to your application. If you create a Maven project, you can directly add the following to your <strong class="source-inline">pom.xml</strong>:</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">  &lt;groupId&gt;org.eclipse.microprofile.openapi&lt;/groupId&gt;</p>
			<p class="source-code">  &lt;artifactId&gt;microprofile-openapi-api&lt;/artifactId&gt;</p>
			<p class="source-code">  &lt;version&gt;2.0&lt;/version&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p>Alternatively, if you create a Gradle project, you need to add the following dependency:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">providedCompile org.eclipse.microprofile.openapi:</p>
			<p class="source-code">  microprofile-openapi-api:2.0</p>
			<p class="source-code">}</p>
			<p>With this, you have learned how to document your cloud-native application. The next step is to secure your applications. We will learn how to secure your applications with the help of MicroProfile JWT (<a href="https://github.com/eclipse/microprofile-jwt-auth">https://github.com/eclipse/microprofile-jwt-auth</a>).</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor117"/>Securing cloud-native applications using MicroProfile JWT</h1>
			<p>MicroProfile<a id="_idIndexMarker534"/> JWT utilizes <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) with<a id="_idIndexMarker535"/> some <a id="_idIndexMarker536"/>additional claims for role-based access control of an endpoint to help with securing cloud-native applications. Securing cloud-native applications is often the must-have feature. It is often the case that cloud-native applications supply sensitive information, which should only be accessible to a particular group of users. Without securing cloud-native applications, everyone would be able to <a id="_idIndexMarker537"/>access the information. <strong class="bold">Jakarta Security</strong> (source code at <a href="https://github.com/eclipse-ee4j/security-api">https://github.com/eclipse-ee4j/security-api</a>), a specification (<a href="https://jakarta.ee/specifications/security/">https://jakarta.ee/specifications/security/</a>) under Jakarta EE, can be used to secure cloud-native applications.</p>
			<p>In the following example, the method <strong class="source-inline">checkAccount</strong> is secured via the Jakarta Security API <strong class="source-inline">@RolesAllowed</strong>. This method can only be invoked by clients with the access group <strong class="source-inline">StockViewer</strong> or <strong class="source-inline">StockTrader</strong>. All other users are denied as shown here:</p>
			<p class="source-code">@RolesAllowed({ "StockViewer", "StockTrader" })</p>
			<p class="source-code">@GET</p>
			<p class="source-code">public String checkAccount() {</p>
			<p class="source-code">    return "CheckAccount";</p>
			<p class="source-code">}</p>
			<p>Alternatively, you can use <strong class="source-inline">web.xml</strong> configuration to directly secure the end point. In the following code snippet, it defines two roles, <strong class="source-inline">StockViewer</strong> and <strong class="source-inline">StockTrader</strong>, and they can access all <strong class="source-inline">GET</strong> operations, where <strong class="source-inline">StockViewer</strong> can only access read-only operations and <strong class="source-inline">StockTrader</strong> can access all operations:</p>
			<p class="source-code">&lt;security-role&gt;</p>
			<p class="source-code">        &lt;description&gt;Group with read-only access to stock </p>
			<p class="source-code">          portfolios&lt;/description&gt;</p>
			<p class="source-code">        &lt;role-name&gt;StockViewer&lt;/role-name&gt;</p>
			<p class="source-code">    &lt;/security-role&gt;</p>
			<p class="source-code">    &lt;security-role&gt;</p>
			<p class="source-code">        &lt;description&gt;Group with full access to stock </p>
			<p class="source-code">          portfolios&lt;/description&gt;</p>
			<p class="source-code">        &lt;role-name&gt;StockTrader&lt;/role-name&gt;</p>
			<p class="source-code">    &lt;/security-role&gt;</p>
			<p class="source-code">&lt;security-constraint&gt;</p>
			<p class="source-code">        &lt;display-name&gt;Account read-only security&lt;/display-name&gt;</p>
			<p class="source-code">        &lt;web-resource-collection&gt;</p>
			<p class="source-code">            &lt;web-resource-name&gt;Account read-only               methods&lt;/web-resource-name&gt;</p>
			<p class="source-code">            &lt;description&gt;Applies to all paths under the               context root (this service specifies the                 account as a path param)&lt;/description&gt;</p>
			<p class="source-code">            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</p>
			<p class="source-code">            &lt;http-method&gt;GET&lt;/http-method&gt;</p>
			<p class="source-code">        &lt;/web-resource-collection&gt;</p>
			<p class="source-code">        &lt;auth-constraint&gt;</p>
			<p class="source-code">            &lt;description&gt;Roles allowed to access read-only               operations on accounts&lt;/description&gt;</p>
			<p class="source-code">            &lt;role-name&gt;StockViewer&lt;/role-name&gt;</p>
			<p class="source-code">            &lt;role-name&gt;StockTrader&lt;/role-name&gt;</p>
			<p class="source-code">        &lt;/auth-constraint&gt;</p>
			<p class="source-code">    &lt;/security-constraint&gt;</p>
			<p>After the endpoint is secured, we then need to work out how to get the client to invoke the secured backend. To answer this question, we'll first discuss the unique aspect of application security for cloud-native applications.</p>
			<p>Cloud-native application security is different from traditional applications as cloud-native applications are often stateless and the server side might not be able to persist any states on the clients. Besides, there might be different instances of the backend and each subsequent client request might not hit the same backend instance. As you can see, storing client data on the backend is problematic. Therefore, the recommended approach is to pass on the security-related info via each request.</p>
			<p>The backend service will then create a security context for each request and perform both <a id="_idIndexMarker538"/>authentication and authorization<a id="_idIndexMarker539"/> checks. This means that the security-related info needs to include both authentication and authorization details. In the next section, we will look at the technologies used to achieve this goal.</p>
			<h3>What technologies do we use to secure cloud-native applications?</h3>
			<p>The<a id="_idIndexMarker540"/> technologies used for cloud-native application<a id="_idIndexMarker541"/> security are based on <strong class="bold">OAuth2</strong>, <strong class="bold">OpenID Connect</strong>, and <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) standards:</p>
			<ul>
				<li><strong class="bold">OAuth2</strong>: An authorization framework that controls authorization to a protected resource such as a cloud-native application. OAuth2 is about user authorization.</li>
				<li><strong class="bold">OpenID Connect (OIDC)</strong>: An authentication framework that builds on top of the OAuth 2.0 protocol. It allows third-party applications such as Google or Facebook to verify the identification of an end user and to obtain some user information. OIDC is about user authentication.</li>
				<li><strong class="bold">JWT</strong>: A compact, URL-safe way to transfer claims between two parties. It contains a set of claims, represented as a JSON object, which is base64url-encoded, digitally signed (<strong class="bold">JWS</strong>), and optionally encrypted (<strong class="bold">JWE</strong>). </li>
			</ul>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor118"/>JWT format</h2>
			<p>JWT can be <a id="_idIndexMarker542"/>used to propagate ID for authentication and user entitlement for authorization. It is used by both OAuth2 and OpenID Connect. The most important feature of JWT is that the data itself is self-described and verifiable. It provides a tamper-resistant way to pass information around. At JWT creation time, the <strong class="bold">Issuer</strong> signs the JWT with its <strong class="bold">Private Key</strong>. Upon receiving the JWT, <strong class="bold">Receivers</strong> can then use the matching <strong class="bold">Public Key</strong> to verify the JWT to ensure that the JWT has not been tampered with.</p>
			<p>JWT is a general abstract<a id="_idIndexMarker543"/> term. It can be either <strong class="bold">signed JWT</strong> or <strong class="bold">encrypted JWT</strong>. A signed<a id="_idIndexMarker544"/> JWT<a id="_idIndexMarker545"/> is known as a <strong class="bold">JWS</strong> (<strong class="bold">JSON Web Signature</strong>) while an encrypted JWT is <a id="_idIndexMarker546"/>known as <strong class="bold">JWE</strong> (<strong class="bold">JSON Web Encryption</strong>). A <strong class="bold">JSON Web Key</strong> (<strong class="bold">JWK</strong>) is a JSON object that represents a cryptographic key and is used to decrypt a JWE or JWS to validate the signature.</p>
			<p>After a security token – JWT – has been generated, <strong class="bold">Token-Based Authentication</strong> is normally used to allow systems to make authentication and authorization decisions based on a security token. For cloud-native applications, a token-based authentication mechanism offers a lightweight way for security controls and security tokens to propagate user and entitlement info across cloud-native applications. Since the JWT token is used for authentication and authorization purposes, two new claims are introduced to the MicroProfile JWT:</p>
			<ul>
				<li><strong class="bold">upn</strong>: This claim specifies the user principal. </li>
				<li><strong class="bold">groups</strong>: This claim lists the group names. </li>
			</ul>
			<p>There can be many claims included in a JWT. The following claims are required for MicroProfile JWT, while the claim for groups are optional from MicroProfile JWT Propagation version 1.2 onwards:</p>
			<ul>
				<li><strong class="source-inline">iss</strong>: This claim specifies the token issuer.</li>
				<li><strong class="source-inline">iat</strong>: This claim specifies the time when the token was issued.</li>
				<li><strong class="source-inline">exp</strong>: This claim indicates the expiration time of the token.</li>
				<li><strong class="source-inline">upn</strong> (or <strong class="source-inline">preferred_username</strong> or <strong class="source-inline">sub</strong>): This claim specifies the principal name. If <strong class="source-inline">upn</strong> is not present, fall back to <strong class="source-inline">preferred_username</strong>. If <strong class="source-inline">preferred_username</strong> is not present, fall back to <strong class="source-inline">sub</strong>.</li>
			</ul>
			<p>Apart from the aforementioned mandatory claims, there are some optional claims listed here:</p>
			<ul>
				<li><strong class="source-inline">aud</strong>: The endpoint, which can be assessed by JWT.</li>
				<li><strong class="source-inline">jti</strong>: The unique identifier for this JWT</li>
				<li><strong class="source-inline">sub</strong>: The unique identifier of the principal of this JWT.</li>
				<li><strong class="source-inline">preferred_user_name</strong>: The preferred username of this JWT.</li>
			</ul>
			<p>As mentioned<a id="_idIndexMarker547"/> earlier, there are two different types of JWT: JWS and JWE. JWS is very popular. We will discuss it in more detail.</p>
			<h3>JWS in more detail</h3>
			<p>JWS is a prominent <a id="_idIndexMarker548"/>format of JWT. A JWS has three parts, which are separated by a dot. The following is an example of JWS, where you can find the first dot on the first line and the second dot on the seventh line:</p>
			<p class="source-code">eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsImF1ZCI6ImNsb3V kLW5hdGl2ZS1hcHAiLCJqdGkiOiIwZmQwODljYi0xYzQ1LTRjMzAtOWIyMy02YW E0ZmQ1ZTcwYjUiLCJleHAiOjE2MTk2OTk5MDYsImlhdCI6MTYxOTY5OTg3Niwic 3ViIjoiRW1pbHkiLCJ1cG4iOiJFbWlseSIsInByZWZlcnJlZF91c2VybmFtZSI6 bnVsbCwiYm9vayI6IlByYWN0aWNpYWwgTWljcm9Qcm9maWxlIiwiZ3JvdXBzIjp bInVzZXIiLCJwcm90ZWN0ZWQiXX0.d0BF1qTrjlQPnb5tppM4LP1T2QWvs9sh6Q lsXcKbFUsHvdzXGDSXkkZTqZl67EkJcUBPy9-I4i5913r9LTBbLIR_bataTVSL9 AcMsSY6tk_B4IU69IjV1GRohGf_LXHyFu_iWGfSWO7TV3-tX43E5Yszvik5sial OrqgVF9uYUy_UaOOY7TEQynpHv4oCTwNKg48-Nlw15Yfz__i7CaOmiRNROp6_cD Zhn1t_aFndplxv4Q-A-p_j2gPpsEldl5mbnBi73-cQvuImawBxA1srRYQSj6aAK JDCBcCj4wh338Nb93l61_PxET8_blXZywJszmLQllJfi2SeR3WucxJ3w</p>
			<p>The three dot-separated parts are the header, payload, and signature. You can paste the preceding encoded form in https://jwt.io/ to retrieve the three parts in human-readable text. We are going to review the three parts in more detail here:</p>
			<ul>
				<li><strong class="bold">Header</strong>: The header normally contains <strong class="source-inline">alg</strong> (RS256 or ES256), <strong class="source-inline">enc</strong> (a cryptographic algorithm to encrypt the claims), <strong class="source-inline">typ</strong> (JWT), and <strong class="source-inline">kid</strong> (the key that was used to secure the JWT). Here is an example of the header. It means <strong class="source-inline">JWT</strong> as the <strong class="source-inline">typ</strong> and <strong class="source-inline">RS256</strong> as the <strong class="source-inline">alg</strong>:<p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  "typ": "JWT",</strong></p><p class="source-code"><strong class="bold">  "alg": "RS256"</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
				<li><strong class="bold">Payload</strong>: This <a id="_idIndexMarker549"/>contains a number of claims. Here is an example of the payload:<p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  "iss": "https://server.example.com",</strong></p><p class="source-code"><strong class="bold">  "aud": "cloud-native-app",</strong></p><p class="source-code"><strong class="bold">  "jti": "0fd089cb-1c45-4c30-9b23-6aa4fd5e70b5",</strong></p><p class="source-code"><strong class="bold">  "exp": 1619699906,</strong></p><p class="source-code"><strong class="bold">  "iat": 1619699876,</strong></p><p class="source-code"><strong class="bold">  "sub": "Emily",</strong></p><p class="source-code"><strong class="bold">  "upn": "Emily",</strong></p><p class="source-code"><strong class="bold">  "preferred_username": null,</strong></p><p class="source-code"><strong class="bold">  "book": "Practicial MicroProfile",</strong></p><p class="source-code"><strong class="bold">  "groups": [</strong></p><p class="source-code"><strong class="bold">    "user",</strong></p><p class="source-code"><strong class="bold">    "protected"</strong></p><p class="source-code"><strong class="bold">  ]</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
				<li><strong class="bold">Signature</strong>: The signature is used to verify that the messages weren't changed during the transmission. It is created using an encoded header, an encoded payload, a secret, the algorithm specified in the header, and then signed. The following is an example of verifying a signature, which computes the signature based on the header and payloader and then compares it with the passed-in signature. If <a id="_idIndexMarker550"/>they match, it means the token has not been tampered with during transmission: <p class="source-code"><strong class="bold">RSASHA256(</strong></p><p class="source-code"><strong class="bold">  base64UrlEncode(header) + "." +</strong></p><p class="source-code"><strong class="bold">  base64UrlEncode(payload), &lt;paste-public-key&gt;</strong></p><p class="source-code"><strong class="bold">  , &lt;paste-private-key&gt;</strong></p><p class="source-code"><strong class="bold">)</strong></p></li>
			</ul>
			<p>In the next section, we are going to discuss how MicroProfile JWT works.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor119"/>How does MicroProfile JWT work?</h2>
			<p>We have<a id="_idIndexMarker551"/> learned what MicroProfile JWT looks like together with the basic concept of MicroProfile JWT. To use JWT, we need to first create a token.</p>
			<h3>Issuing a MicroProfile JWT token</h3>
			<p>A MicroProfile <a id="_idIndexMarker552"/>JWT token can be issued by runtimes that support the creation of MicroProfile JWT or trusted OpenID Connect providers. MicroProfile JWT can be self-issued by a trusted server, where a set of token-issuing APIs are provided. Open Liberty, Eclipse Vert.x, and other runtimes have such APIs available. The following is an example of using the Open Liberty API to create a JWT token:</p>
			<p class="source-code">import com.ibm.websphere.security.jwt.JwtBuilder;</p>
			<p class="source-code">import com.ibm.websphere.security.jwt.Claims;</p>
			<p class="source-code">private String buildJwt(String userName, Set&lt;String&gt; roles)   throws Exception {</p>
			<p class="source-code">        return JwtBuilder.create("jwtBuilder")</p>
			<p class="source-code">                         .claim(Claims.SUBJECT, userName)</p>
			<p class="source-code">                         .claim("upn", userName)</p>
			<p class="source-code">                         .claim("groups", roles.toArray(new </p>
			<p class="source-code">                           String[roles.size()]))</p>
			<p class="source-code">                         .buildJwt()</p>
			<p class="source-code">                         .compact();</p>
			<p class="source-code">    }</p>
			<p>This JWT token <a id="_idIndexMarker553"/>contains the claims <strong class="source-inline">sub (Claims.SUBJECT)</strong>, <strong class="source-inline">upn</strong>, and <strong class="source-inline">groups</strong>. In production, it is common that MicroProfile JWTs are issued by some trusted OpenID Connect providers such as Auth0, Keycloak, Azure, Okta, and so on.</p>
			<p>The only supported JWT algorithms are RS256 and ES256. The token will be rejected if other algorithms are used.</p>
			<p class="callout-heading">JWT generation</p>
			<p class="callout">Since MicroProfile JWT has two more claims over JWT, these claims need to be manually added as custom claims in the OpenID Connect providers such as Keycloak, Okta, and others.</p>
			<h4>Transferring MicroProfile JWTs from a client to a server</h4>
			<p>MicroProfile<a id="_idIndexMarker554"/> JWTs are transferred over a HTTP request. They can be passed either via an HTTP Authorization header or an HTTP cookie:</p>
			<ul>
				<li><strong class="bold">Passing JWTs as an HTTP Authorization header</strong>: When passing a JWT as an HTTP Authorization header, the configuration <strong class="source-inline">mp.jwt.token.header</strong> can be used to store the JWT in the following format:<p class="source-code"><strong class="bold">mp.jwt.token.header=Bearer as14efgscd31qrewtadg</strong></p></li>
				<li><strong class="bold">Passing JWTs as cookies</strong>: When passing a JWT as a cookie, the configuration <strong class="source-inline">mp.jwt.token.cookie</strong> can be used to store the JWT in the following<a id="_idIndexMarker555"/> format:<p class="source-code"><strong class="bold">mp.jwt.token.cookie=Bearer= as14efgscd31qrewtadg</strong></p></li>
			</ul>
			<h4>Validating MicroProfile JWTs by the server</h4>
			<p>MicroProfile <a id="_idIndexMarker556"/>JWTs must be signed (JWSes). To decode JWSes, the corresponding public key must be specified. The location to the public key can be provided via the property <strong class="source-inline">mp.jwt.verify.publickey.location</strong>. Alternatively, the public key itself can be provided via the property <strong class="source-inline">mp.jwt.verify.publickey</strong>. The two properties are not allowed to be specified together. Otherwise, a <strong class="source-inline">DeploymentException</strong> will be thrown.</p>
			<p>The signed JWTs can be further encrypted (JWE). When the server receives MicroProfile JWTs, it will validate the JWTs. If the JWT is a JWE, it will need to use the corresponding private key to decrypt the JWE. The location of the private key can be specified in the property <strong class="source-inline">mp.jwt.decrypt.key.location</strong>. If this property is present, the received JWTs must be a JWE. Otherwise, the JWTs will be rejected. </p>
			<p>After the signature of a JWT has been verified or the token has been decrypted, some further validations can be performed, such as <strong class="source-inline">iss</strong> and <strong class="source-inline">aud</strong> validation. The <strong class="source-inline">mp.jwt.verify.issuer</strong> property specifies the expected <strong class="source-inline">iss</strong> value while the property <strong class="source-inline">mp.jwt.verify.audiences</strong> specifies the <strong class="source-inline">aud</strong> value.</p>
			<p>After the JWTs have been verified, the object <strong class="source-inline">JsonWebToken</strong> is made available to the cloud-native application as a backend.</p>
			<p>Some MicroProfile JWT implementation might also provide additional validation mechanisms. In Open Liberty, you can specify the following line in your <strong class="source-inline">server.xml</strong> to validate against the <strong class="source-inline">issuer</strong> and <strong class="source-inline">audiences</strong> if the corresponding properties are absent: </p>
			<p class="source-code">&lt;mpJwt id="stockTraderJWT" audiences="${JWT_AUDIENCE}" issuer="${JWT_ISSUER}" keyName="jwtSigner" ignoreApplicationAuthMethod="false" /&gt;</p>
			<p>This mechanism will be used by the <strong class="bold">Stock Trader</strong> application, which will be covered in more detail in <a href="B17377_08_Final_SB_epub.xhtml#_idTextAnchor159"><em class="italic">Chapter 8</em></a>, <em class="italic">Building and Testing Your Cloud-Native Application</em>.</p>
			<p>In the preceding example, when a JWT is received and decoded, its <strong class="source-inline">aud</strong> and <strong class="source-inline">iss</strong>  claim will be compared with audiences defined in <strong class="source-inline">${JWT_AUDIENCE}</strong> and <strong class="source-inline">${JWT_ISSUER}</strong> correspondingly. If they match, the JWT will be accepted and then perform further<a id="_idIndexMarker557"/> authentication and authorization checks.</p>
			<h4>Accessing JsonWebToken</h4>
			<p>Cloud-native <a id="_idIndexMarker558"/>applications can <a id="_idIndexMarker559"/>access <strong class="source-inline">JsonWebToken</strong> via the following ways:</p>
			<ul>
				<li>Access <strong class="source-inline">JsonWebToken</strong> via <strong class="source-inline">SecurityContext</strong>. The following code snippet demonstrates how to retrieve a <strong class="source-inline">JsonWebToken</strong> object from the injected <strong class="source-inline">SecurityContext</strong>:<p class="source-code">    @GET</p><p class="source-code">    @Path("/getAud")</p><p class="source-code">    public Set&lt;String&gt; getAudience(@Context       SecurityContext sec) </p><p class="source-code">        Set&lt;String&gt; auds = null;</p><p class="source-code">        Principal user = sec.getUserPrincipal();</p><p class="source-code">        if (user instanceof JsonWebToken) {</p><p class="source-code">            JsonWebToken jwt = (JsonWebToken) user;</p><p class="source-code">            auds = jwt.getAudience();</p><p class="source-code">        }</p><p class="source-code">        return auds;</p><p class="source-code">    }</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">JsonWebToken</strong> contains all claims. <strong class="source-inline">JsonWebToken</strong> is a subclass of <strong class="source-inline">Principal</strong>. </p></li>
				<li>You can use CDI injection to inject the whole <strong class="source-inline">JsonWebToken</strong>:<p class="source-code">@Inject private JsonWebToken jwt;</p></li>
				<li>You can use CDI injection to inject a particular claim. The following example demonstrates assigning the claim <strong class="source-inline">raw_token</strong> string to the <strong class="source-inline">rawToken variable</strong>:<p class="source-code">@Inject @Claim(standard= Claims.raw_token) private String rawToken; </p><p>This<a id="_idIndexMarker560"/> line<a id="_idIndexMarker561"/> is to inject the claim <strong class="source-inline">iat</strong> with the type of <strong class="source-inline">Long</strong> to the <strong class="source-inline">dupIssuedAt variable</strong>:</p><p class="source-code">@Inject @Claim("iat") private Long dupIssuedAt;</p></li>
				<li>The following line injects the claim <strong class="source-inline">sub</strong> with the type of <strong class="source-inline">ClaimValue</strong> to the <strong class="source-inline">optSubject variable</strong>. This lookup is dynamic:<p class="source-code">@Inject @Claim("sub") private ClaimValue&lt;Optional&lt;String&gt;&gt; optSubject;</p><p class="callout-heading">Note</p><p class="callout">ClaimValue is a representation of a claim in a <strong class="source-inline">JsonWebToken</strong>, which is a wrapper class for the specified claim.</p></li>
			</ul>
			<p>Since the JWT is attached to a particular request, it is expected that the token is bound to a lifecycle of <strong class="source-inline">RequestScoped</strong>. When injecting <strong class="source-inline">JsonWebToken</strong> or <strong class="source-inline">Claims</strong> into a scope with a lifecycle greater than <strong class="source-inline">RequestScoped</strong>, such as <strong class="source-inline">ApplicationScoped</strong>,or <strong class="source-inline">SessionScoped</strong>, you should use the type of <strong class="source-inline">Provider</strong>, <strong class="source-inline">Instance</strong>, or <strong class="source-inline">ClaimValue</strong> as these are wrappers and will always retrieve the JWTs dynamically for the specified request. Generally speaking, you can use the following code snippet to retrieve a specified claim, <strong class="source-inline">a_claim</strong>:</p>
			<p class="source-code">@Inject @Claim("a_claim") &lt;Claim_Type&gt; private myClaim;</p>
			<p><strong class="source-inline">&lt;Claim_Type&gt;</strong> can be <strong class="source-inline">String</strong>, <strong class="source-inline">Long</strong>, <strong class="source-inline">long</strong>, <strong class="source-inline">Boolean</strong>, <strong class="source-inline">Set&lt;String&gt;</strong>, <strong class="source-inline">JsonValue.TRUE</strong>, <strong class="source-inline">JsonValue.FALSE</strong>, <strong class="source-inline">JsonString</strong>, J<strong class="source-inline">sonNumber</strong>, <strong class="source-inline">JsonArray</strong>, or <strong class="source-inline">JsonObject</strong>. It can be optional wrapper of the listed types or <strong class="source-inline">ClaimValue</strong> of the types, including <strong class="source-inline">Optional</strong>.</p>
			<p>MicroProfile JWT can be propagated to downstream services if the invocation is via the MicroProfile Rest Client (MicroProfile Rest Client has been discussed in great detail in <a href="B17377_04_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Developing Cloud-Native Applications</em>.). The propagation will be<a id="_idIndexMarker562"/> automatically handled by setting the following configuration:</p>
			<p class="source-code">org.eclipse.microprofile.rest.client.propagateHeaders=  Authorization/Cookie</p>
			<p>If the JWT is specified as an authorization header, the value will be <strong class="source-inline">Authentication</strong>. If the JWT is specified as a cookie, the value will be <strong class="source-inline">Cookie</strong>.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor120"/>Where to find the public key and private key</h2>
			<p>When it <a id="_idIndexMarker563"/>comes to<a id="_idIndexMarker564"/> security, you will immediately think about keys. There is no exception here. In MicroProfile JWT, you will need a public key to decode a JWS and a private key to decrypt JWE. If you received JWE, you will need to use your private key to decrypt it first. After the decryption, you will get a JWS. Then you will need to use your public key to decode the JWS to verify the signature. MicroProfile JWT provides the following configuration for you to retrieve the keys:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Table_5.8.jpg" alt="Table 5.8 – MicroProfile JWT configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 5.8 – MicroProfile JWT configuration</p>
			<p>If the <strong class="source-inline">mp.jwt.decrypt.key.location</strong> property is set and either <strong class="source-inline">mp.jwt.verify.publickey.location</strong> or <strong class="source-inline">mp.jwt.verify.publickey </strong>are set, only encrypted JWTs can be accepted.</p>
			<p>The<a id="_idIndexMarker565"/> properties <a id="_idIndexMarker566"/>mentioned in the preceding table are regular MicroProfile configurations. They can be specified in any of the config sources, such as <em class="italic">META-INF/microprofile-config.properties</em>, <em class="italic">system properties</em>, <em class="italic">environment variables</em>, or other custom config sources.</p>
			<p>We have covered how MicroProfile JWT works. In the next section, we will discuss how to make the APIs available to your Maven or Gradle projects.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor121"/>How to make MicroProfile JWT available to applications?</h2>
			<p>To use <a id="_idIndexMarker567"/>MicroProfile JWT APIs, you need to make these APIs available to your application. If you create a Maven project, you can directly add the following to your <strong class="source-inline">pom.xml</strong>:</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">    &lt;groupId&gt;org.eclipse.microprofile.jwt&lt;/groupId&gt;</p>
			<p class="source-code">    &lt;artifactId&gt;microprofile-jwt-auth-api&lt;/artifactId&gt;</p>
			<p class="source-code">    &lt;version&gt;1.2&lt;/version&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p>Alternatively, if you <a id="_idIndexMarker568"/>create a Gradle project, you need to add the following dependency:</p>
			<p class="source-code">dependencies {</p>
			<p class="source-code">providedCompile org.eclipse.microprofile.jwt:   microprofile-jwt-auth-api:1.2</p>
			<p class="source-code">}</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor122"/>Summary</h1>
			<p>In this chapter, we have learned about MicroProfile Config, which enables you to externalize your configuration to achieve a flexible and efficient cloud-native architecture, which is also highly recommended by the twelve-factor app.</p>
			<p>We then went forward to explore how to create a resilient cloud-native application using MicroProfile Fault Tolerance so that application developers can concentrate on their business logic, where MicroProfile Fault Tolerance handles possible failures and then performs retries or limits resource consumption, and so on, via simple Fault Tolerance annotations. </p>
			<p>After we covered Fault Tolerance, we then dived into MicroProfile OpenAPI to learn how to document your cloud-native applications using MicroProfile OpenAPI. We discussed a few ways to generate OpenAPI documents. Some MicroProfile OpenAPI implementation, such as Open Liberty, also provides UI integration for you to access endpoints directly via the UI.</p>
			<p>Finally, we learned about the topic of securing cloud-native applications using MicroProfile JWT. We discussed, in general, the unique requirements for securing cloud-native applications and then explained how to use MicroProfile JWT to facilitate securing cloud-native applications in a portable and interoperable way.</p>
			<p>Up to now, you have learned about quite a few technologies you need to develop your cloud-native applications. The next task is to consider how to improve your day 2 operation experience by building a smart and intelligent cloud-native application, which means the application can communicate automatically with cloud infrastructures when it is ready to receive requests and so on. It will also be beneficial if the application can provide some metrics so that day 2 operations can take some precautions before it is too late. We all know faults cannot be eliminated completely. If something goes wrong, day 2 operations will offer an easy and simple diagnosis to identify the failure straightaway. MicroProfile Health, MicroProfile Metrics, and MicroProfile OpenTracing are the technologies to fulfill these requirements.</p>
			<p>In the next chapter, we will discuss why and how you should use MicroProfile Health, MicroProfile Metrics, and MicroProfile OpenTracing to help with day 2 operations.</p>
		</div>
	</body></html>