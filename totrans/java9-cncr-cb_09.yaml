- en: Testing Concurrent Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并发应用程序
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Monitoring a Lock interface
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控锁接口
- en: Monitoring a Phaser class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 Phaser 类
- en: Monitoring an Executor framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 Executor 框架
- en: Monitoring a fork/join pool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 fork/join 池
- en: Monitoring a stream
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控流
- en: Writing effective log messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写有效的日志消息
- en: Analyzing concurrent code with FindBugs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FindBugs 分析并发代码
- en: Configuring Eclipse for debugging concurrency code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Eclipse 以调试并发代码
- en: Configuring NetBeans for debugging concurrency code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 NetBeans 以调试并发代码
- en: Testing concurrency code with MultithreadedTC
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MultithreadedTC 测试并发代码
- en: Monitoring with JConsole
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JConsole 进行监控
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Testing an application is a critical task. Before you make an application ready
    for end users, you have to demonstrate its correctness. You use a test process
    to prove that correctness is achieved and errors are fixed. Testing is a common
    task in any software development and quality assurance process. You can find a
    lot of literature about testing processes and the different approaches you can
    apply to your developments. There are a lot of libraries as well, such as JUnit,
    and applications, such as Apache JMeter, that you can use to test your Java applications
    in an automated way. Testing is even more critical in concurrent application development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序是一个关键任务。在你将应用程序准备好供最终用户使用之前，你必须证明其正确性。你使用测试过程来证明已达到正确性并且错误已被修复。测试是任何软件开发和质量保证过程中的常见任务。你可以找到大量关于测试过程和你可以应用于你的开发的不同的方法的文献。还有很多库，如
    JUnit，以及应用程序，如 Apache JMeter，你可以使用它们以自动化的方式测试你的 Java 应用程序。在并发应用程序开发中，测试甚至更为关键。
- en: The fact that concurrent applications have two or more threads that share data
    structures and interact with each other adds more difficulty to the testing phase.
    The biggest problem you will face when you test concurrent applications is that
    the execution of threads is non-deterministic. You can't guarantee the order of
    the execution of threads, so it's difficult to reproduce errors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序有两个或更多线程共享数据结构并相互交互的事实，给测试阶段增加了更多的难度。你在测试并发应用程序时面临的最大问题是线程执行的不可确定性。你不能保证线程执行的顺序，因此很难重现错误。
- en: Monitoring a Lock interface
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控锁接口
- en: A `Lock` interface is one of the basic mechanisms provided by the Java concurrency
    API to synchronize a block of code. It allows you to define a **critical section**.
    A critical section is a block of code that accesses a shared resource and can't
    be executed by more than one thread at the same time. This mechanism is implemented
    by the `Lock` interface and the `ReentrantLock` class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock` 接口是 Java 并发 API 提供的基本机制之一，用于同步代码块。它允许你定义一个 **临界区**。临界区是一段访问共享资源的代码块，不能同时被多个线程执行。此机制由
    `Lock` 接口和 `ReentrantLock` 类实现。'
- en: In this recipe, you will learn what information you can obtain about a `Lock`
    object and how to obtain that information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将了解你可以从 `Lock` 对象中获得哪些信息以及如何获取这些信息。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `MyLock` that extends the `ReentrantLock` class:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyLock` 的类，该类扩展了 `ReentrantLock` 类：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement `getOwnerName()`. This method returns the name of the thread that
    has control of a lock (if any), using the protected method of the `Lock` class
    called `getOwner()`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `getOwnerName()` 方法。此方法返回控制锁的线程的名称（如果有），使用 `Lock` 类的受保护方法 `getOwner()`：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement `getThreads()`. This method returns a list of threads queued in a
    lock, using the protected method of the `Lock` class called `getQueuedThreads()`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `getThreads()` 方法。此方法返回一个列表，其中包含在锁中排队的线程，使用 `Lock` 类的受保护方法 `getQueuedThreads()`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，实现 `Runnable` 接口：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Declare a private `Lock` attribute named `lock`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `lock` 的私有 `Lock` 属性：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement a constructor of the class to initialize its attribute:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the `run()` method. Create a loop with five steps:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。创建一个包含五个步骤的循环：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Acquire the lock using the `lock()` method and print a message:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lock()`方法获取锁并打印一条消息：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Put the thread to sleep for 500 milliseconds. Free the lock using the `unlock()`
    method and print a message:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线程休眠500毫秒。使用`unlock()`方法释放锁并打印一条消息：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并包含一个`main()`方法来创建示例的主类：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `MyLock` object named `lock`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`lock`的`MyLock`对象：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create an array of five `Thread` objects:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个`Thread`对象的数组：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create and start five threads to execute five `Task` objects:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动五个线程以执行五个`Task`对象：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a loop with 15 steps:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含15个步骤的循环：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Write the name of the owner of the lock in the console:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台写入锁的所有者名称：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Display the number and name of the threads queued for the lock:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示等待获取锁的线程的数量和名称：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Display information about the fairness and status of the `Lock` object:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示`Lock`对象的公平性和状态信息：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Put the thread to sleep for 1 second and close the loop and the class:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线程休眠1秒并关闭循环和类：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, you implemented the `MyLock` class that extends the `ReentrantLock`
    class to return information that wouldn''t have been available otherwise-it''s
    protected data of the `ReentrantLock` class. The methods implemented by the `MyLock`
    class are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你实现了扩展`ReentrantLock`类的`MyLock`类，以返回其他情况下不可用的信息——它是`ReentrantLock`类的受保护数据。`MyLock`类实现的方法如下：
- en: '`getOwnerName()`: Only one thread can execute a critical section protected
    by a `Lock` object. The lock stores the thread that is executing the critical
    section. This thread is returned by the protected `getOwner()` method of the `ReentrantLock`
    class.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOwnerName()`: 只有一个线程可以执行由`Lock`对象保护的临界区。锁存储正在执行临界区的线程。该线程由`ReentrantLock`类的受保护`getOwner()`方法返回。'
- en: '`getThreads()`: When a thread is executing a critical section, other threads
    that try to enter it are put to sleep before they continue executing that critical
    section. The protected method `getQueuedThreads()` of the `ReentrantLock` class
    returns the list of threads that are waiting to execute the critical section.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getThreads()`: 当一个线程正在执行临界区时，其他尝试进入该临界区的线程在继续执行该临界区之前将被休眠。`ReentrantLock`类的受保护方法`getQueuedThreads()`返回正在等待执行临界区的线程列表。'
- en: 'We also used other methods that are implemented in the `ReentrantLock` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`ReentrantLock`类中实现的其他方法：
- en: '`hasQueuedThreads()`: This method returns a `Boolean` value indicating whether
    there are threads waiting to acquire the calling `ReentrantLock`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasQueuedThreads()`: 此方法返回一个`Boolean`值，指示是否有线程正在等待获取调用`ReentrantLock`'
- en: '`getQueueLength()`: This method returns the number of threads that are waiting
    to acquire the calling `ReentrantLock`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueueLength()`: 此方法返回等待获取调用`ReentrantLock`的线程数量'
- en: '`isLocked()`: This method returns a `Boolean` value indicating whether the
    calling `ReentrantLock` is owned by a thread'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLocked()`: 此方法返回一个`Boolean`值，指示调用`ReentrantLock`是否由一个线程拥有'
- en: '`isFair()`: This method returns a `Boolean` value indicating whether the calling
    `ReentrantLock` has fair mode activated'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFair()`: 此方法返回一个`Boolean`值，指示调用`ReentrantLock`是否已激活公平模式'
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'There are other methods in the `ReentrantLock` class that can be used to obtain
    information about a `Lock` object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReentrantLock`类中还有其他可以用来获取`Lock`对象信息的方法：'
- en: '`getHoldCount()`: This returns the number of times the current thread has acquired
    the lock'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getHoldCount()`: 此方法返回当前线程获取锁的次数'
- en: '`isHeldByCurrentThread()`: This returns a `Boolean` value indicating whether
    the lock is owned by the current thread'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isHeldByCurrentThread()`: 此方法返回一个`Boolean`值，指示锁是否由当前线程拥有'
- en: See also
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Synchronizing a block of code with a lock* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736)，*基本线程同步*中的*使用锁同步代码块*配方
- en: The *Implementing a custom Lock class* recipe in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736)，*自定义并发类*中的*实现自定义锁类*配方
- en: Monitoring a Phaser class
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控Phaser类
- en: One of the most complex and powerful functionalities offered by the Java Concurrency
    API is the ability to execute concurrent-phased tasks using the `Phaser` class.
    This mechanism is useful when we have some concurrent tasks divided into steps.
    The `Phaser` class provides the mechanism to synchronize threads at the end of
    each step so no thread starts its second step until all the threads have finished
    the first one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供的最复杂和强大的功能之一是能够使用`Phaser`类执行并发分阶段任务。当我们将一些并发任务分为步骤时，此机制非常有用。`Phaser`类提供了在每个步骤末尾同步线程的机制，这样就没有线程在所有线程完成第一个步骤之前开始第二个步骤。
- en: In this recipe, you will learn what information you can obtain about the status
    of a `Phaser` class and how to obtain that information.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，您将了解有关`Phaser`类状态的信息，以及如何获取这些信息。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例已使用Eclipse IDE实现。如果您使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，实现`Runnable`接口：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Declare a private `int` attribute named `time`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`time`的私有`int`属性：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Declare a private `Phaser` attribute named `phaser`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`phaser`的私有`Phaser`属性：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the `run()` method. First, instruct the `phaser` attribute that the
    task starts its execution with the `arrive()` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。首先，使用`arrive()`方法指示`phaser`属性任务开始执行：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Write a message in the console indicating the start of phase one. Put the thread
    to sleep for the number of seconds specified by the `time` attribute. Write a
    message in the console indicating the end of phase one. And, synchronize with
    the rest of the tasks using the `arriveAndAwaitAdvance()` method of the `phaser`
    attribute:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台写入一条消息，指示第一阶段开始。让线程休眠由`time`属性指定的秒数。在控制台写入一条消息，指示第一阶段结束。然后，使用`phaser`属性的`arriveAndAwaitAdvance()`方法与其他任务同步：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Repeat this behavior in both second and third phases. At the end of the third
    phase, use the `arriveAndDeregister()` method instead of `arriveAndAwaitAdvance()`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段和第三阶段重复此行为。在第三阶段结束时，使用`arriveAndDeregister()`方法而不是`arriveAndAwaitAdvance()`：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并包含一个`main()`方法来实现示例的主要类：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new `Phaser` object named `phaser` with three participants:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`phaser`的新`Phaser`对象，包含三个参与者：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create and launch three threads to execute three task objects:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动三个线程以执行三个任务对象：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a loop with 10 steps to write information about the `phaser` object:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含10个步骤的循环，以写入关于`phaser`对象的信息：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Write information about the registered parties, the phase of the `phaser`,
    the arrived parties, and the unarrived parties:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入有关已注册的参与者、`phaser`的相位、到达的参与者和未到达的参与者的信息：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Put the thread to sleep for 1 second and close the loop and the class:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让线程休眠1秒，并关闭循环和类：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we implemented a phased task in the `Task` class. This phased
    task has three phases and uses a `Phaser` interface to synchronize with other
    `Task` objects. The main class launches three tasks, and when these tasks execute
    their respective phases, it prints information about the status of the `phaser`
    object to the console. We used the following methods to get the status of the
    `phaser` object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，我们在`Task`类中实现了一个分阶段任务。这个分阶段任务有三个阶段，并使用`Phaser`接口与其他`Task`对象同步。主类启动三个任务，当这些任务执行各自的阶段时，它将打印有关`phaser`对象状态的信息到控制台。我们使用了以下方法来获取`phaser`对象的状态：
- en: '`getPhase()`: This method returns the actual phase of a `phaser` object'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPhase()`: 此方法返回`phaser`对象的实际相位'
- en: '`getRegisteredParties()`: This method returns the number of tasks that use
    a `phaser` object as a mechanism of synchronization'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRegisteredParties()`: 此方法返回使用`phaser`对象作为同步机制的任务数量'
- en: '`getArrivedParties()`: This method returns the number of tasks that have arrived
    at the end of the actual phase'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getArrivedParties()`: 此方法返回到达实际阶段末尾的任务数量'
- en: '`getUnarrivedParties()`: This method returns the number of tasks that haven''t
    yet arrived at the end of the actual phase'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUnarrivedParties()`：此方法返回尚未到达实际阶段结束的任务数量'
- en: 'The following screenshot shows part of the output of the program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序的部分输出：
- en: '![](img/00058.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Running concurrent-phased tasks* recipe in [Chapter 3](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Synchronization Utilities*
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736)的*运行并发阶段任务*食谱中，*线程同步工具*
- en: Monitoring an Executor framework
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控Executor框架
- en: The `Executor` framework provides a mechanism that separates the implementation
    of tasks from thread creation and management to execute the tasks. If you use
    an executor, you only have to implement `Runnable` objects and send them to the
    executor. It is the responsibility of an executor to manage threads. When you
    send a task to an executor, it tries to use a pooled thread for executing the
    task in order to avoid the creation of new threads. This mechanism is offered
    by the `Executor` interface and its implementing classes as the `ThreadPoolExecutor`
    class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`框架提供了一个机制，将任务的实现与线程的创建和管理分离，以便执行任务。如果你使用执行器，你只需要实现`Runnable`对象并将它们发送到执行器。管理线程是执行器的责任。当你向执行器发送任务时，它会尝试使用池化的线程来执行任务，以避免创建新的线程。这种机制由`Executor`接口及其实现类`ThreadPoolExecutor`类提供。'
- en: In this recipe, you will learn what information you can obtain about the status
    of a `ThreadPoolExecutor` executor and how to obtain it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习可以获取有关`ThreadPoolExecutor`执行器状态的哪些信息以及如何获取这些信息。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的食谱是用Eclipse IDE实现的。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，该类实现了`Runnable`接口：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Declare a private `long` attribute named `milliseconds`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`milliseconds`的私有`long`属性：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement the `run()` method. Put the thread to sleep for the number of milliseconds
    specified by the `milliseconds` attribute:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接收`milliseconds`属性指定的时间数目的`run()`方法。将线程休眠指定的时间：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并包含一个`main()`方法来实现示例的主类：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new `Executor` object using the `newCachedThreadPool()` method of
    the `Executors` class:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建一个新的`Executor`对象：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create and submit 10 `Task` objects to the executor. Initialize the objects
    with a random number:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并提交10个`Task`对象到执行器。用随机数初始化这些对象：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a loop with five steps. In each step, write information about the executor
    by calling the `showLog()` method and putting the thread to sleep for a second:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个步骤的循环。在每一步中，通过调用`showLog()`方法并将线程休眠一秒钟来记录执行者的信息：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Shut down the executor using the `shutdown()` method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭执行器：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create another loop with five steps. In each step, write information about
    the executor by calling the `showLog()` method and putting the thread to sleep
    for a second:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个包含五个步骤的循环。在每一步中，通过调用`showLog()`方法并将线程休眠一秒钟来记录执行者的信息：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Wait for the finalization of the executor using the `awaitTermination()` method:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待执行器的最终化：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Display a message indicating the end of the program:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一条消息，表明程序结束：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Implement the `showLog()` method that receives `Executor` as a parameter. Write
    information about the size of the pool, the number of tasks, and the status of
    the executor:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接收`Executor`作为参数的`showLog()`方法。记录池的大小、任务的数量和执行器的状态：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, you implemented a task that blocks its execution thread for
    a random number of milliseconds. Then, you sent 10 tasks to an executor, and while
    you were waiting for their finalization, you wrote information about the status
    of the executor to the console. You used the following methods to get the status
    of the `Executor` object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你实现了一个任务，该任务会随机阻塞其执行线程一段时间（毫秒）。然后，你向执行器发送了10个任务，在你等待它们最终完成的同时，你将执行器的状态信息写入控制台。你使用了以下方法来获取`Executor`对象的状态：
- en: '`getCorePoolSize()`: This method returns an `int` number, which refers to the
    core number of threads. It''s the minimum number of threads that will be in the
    internal thread pool when the executor is not executing any task.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCorePoolSize()`: 此方法返回一个`int`类型的数字，表示核心线程数。它是当执行器不执行任何任务时，内部线程池中将存在的最小线程数。'
- en: '`getPoolSize()`: This method returns an `int` value, which refers to the actual
    size of the internal thread pool.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 此方法返回一个`int`类型的值，表示内部线程池的实际大小。'
- en: '`getActiveCount()`: This method returns an `int` number, which refers to the
    number of threads that are currently executing tasks.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveCount()`: 此方法返回一个`int`类型的数字，表示当前正在执行任务的线程数量。'
- en: '`getTaskCount()`: This method returns a `long` number, which refers to the
    number of tasks that have been scheduled for execution.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTaskCount()`: 此方法返回一个`long`类型的数字，表示已安排执行的任务数量。'
- en: '`getCompletedTaskCount()`: This method returns a `long` number, which refers
    to the number of tasks that have been executed by this executor and have finished
    their execution.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCompletedTaskCount()`: 此方法返回一个`long`类型的数字，表示由该执行器执行并已完成执行的任务数量。'
- en: '`isShutdown()`: This method returns a `Boolean` value when the `shutdown()`
    method of an executor is called to finish its execution.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()`: 当调用执行器的`shutdown()`方法以完成其执行时，此方法返回一个`Boolean`值。'
- en: '`isTerminating()`: This method returns a `Boolean` value when the executor
    performs the `shutdown()` operation but hasn''t finished it yet.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminating()`: 当执行器执行`shutdown()`操作但尚未完成时，此方法返回一个`Boolean`值。'
- en: '`isTerminated()`: This method returns a `Boolean` value when the executor finishes
    its execution.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 当执行器完成其执行时，此方法返回一个`Boolean`值。'
- en: See also
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a thread executor and controlling its rejected tasks* recipe in
    [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736), *Thread Executors*
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736)中“创建线程执行器和控制其拒绝的任务”菜谱的*Creating
    a thread executor and controlling its rejected tasks*，*Thread Executors*'
- en: The *Customizing the ThreadPoolExecutor class* and *Implementing a priority-based
    Executor class* recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736)中“自定义ThreadPoolExecutor类”和“实现基于优先级的Executor类”菜谱的*Customizing
    the ThreadPoolExecutor class*和*Implementing a priority-based Executor class*，*Customizing
    Concurrency Classes*'
- en: Monitoring a fork/join pool
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控fork/join池
- en: The Executor framework provides a mechanism that allows you to separate task
    implementation from the creation and management of threads that execute the tasks.
    Java 9 includes an extension of the Executor framework for a specific kind of
    problem that will improve the performance of other solutions (using `Thread` objects
    directly or the Executor framework). It's the fork/join framework.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Executor框架提供了一个机制，允许你将任务实现与创建和管理执行任务的线程分离。Java 9为特定类型的问题扩展了Executor框架，这将提高其他解决方案的性能（直接使用`Thread`对象或Executor框架）。它是fork/join框架。
- en: This framework is designed to solve problems that can be broken down into smaller
    tasks using the `fork()` and `join()` operations. The main class that implements
    this behavior is `ForkJoinPool`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架旨在解决可以使用`fork()`和`join()`操作分解成更小任务的问题。实现此行为的主要类是`ForkJoinPool`。
- en: In this recipe, you will learn what information you can obtain about a `ForkJoinPool`
    class and how to obtain it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解关于`ForkJoinPool`类可以获取哪些信息以及如何获取这些信息。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task` that extends the `RecursiveAction` class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，该类继承自`RecursiveAction`类：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Declare a private `int` array attribute named `array` to store the array of
    elements you want to increment:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `array` 的私有 `int` 数组属性，用于存储您想要增加的元素数组：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Declare two private `int` attributes named `start` and `end` to store the start
    and end positions of the block of elements this task has to process:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为 `start` 和 `end` 的私有 `int` 属性，用于存储此任务需要处理的元素块的开始和结束位置：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the `compute()` method with the main logic of the task. If the task
    has to process more than 100 elements, first divide the elements into two parts,
    create two tasks to execute these parts, start its execution with the `fork()`
    method, and finally, wait for its finalization with the `join()` method:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现具有任务主要逻辑的 `compute()` 方法。如果任务需要处理超过100个元素，首先将元素分成两部分，创建两个任务来执行这些部分，使用 `fork()`
    方法开始其执行，并最终使用 `join()` 方法等待其最终化：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If the task has to process 100 elements or less, increment the elements by
    putting the thread to sleep for 5 milliseconds after each operation:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任务需要处理100个或更少的元素，通过在每个操作后将线程休眠5毫秒来增加元素：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并具有 `main()` 方法来实现示例的主要类：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a `ForkJoinPool` object named `pool`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pool` 的 `ForkJoinPool` 对象：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create an array of integer numbers, named `array`, with 10,000 elements:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含10,000个整数的数组，命名为 `array`：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a new `Task` object to process the whole array:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Task` 对象来处理整个数组：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Send the task for execution to the pool using the `execute()` method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `execute()` 方法将任务发送到池中执行：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If the task doesn''t finish its execution, call the `showLog()` method to write
    information about the status of the `ForkJoinPool` class and put the thread to
    sleep for a second:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任务没有完成其执行，调用 `showLog()` 方法来写入有关 `ForkJoinPool` 类的状态的信息，并将线程休眠一秒：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Shut down the pool using the `shutdown()` method:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `shutdown()` 方法关闭池：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Wait for the finalization of the pool using the `awaitTermination()` method:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `awaitTermination()` 方法等待池的最终化：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Call the `showLog()` method to write information about the status of the `ForkJoinPool`
    class and write a message in the console indicating the end of the program:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `showLog()` 方法来写入有关 `ForkJoinPool` 类的状态的信息，并在控制台写入一条消息，指示程序的结束：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Implement the `showLog()` method. It receives a `ForkJoinPool` object as a
    parameter and writes information about its status and the threads and tasks that
    are being executed:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `showLog()` 方法。它接收一个 `ForkJoinPool` 对象作为参数，并写入有关其状态以及正在执行的和任务的信息：
- en: '[PRE60]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, you implemented a task that increments the elements of an array,
    using a `ForkJoinPool` class, and a `Task` class that extends the `RecursiveAction`
    class. This is one of the tasks you can execute in a `ForkJoinPool` class. When
    the tasks were processing the array, you printed information about the status
    of the `ForkJoinPool` class to the console. You used the following methods to
    get the status of the `ForkJoinPool` class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您实现了一个任务，使用 `ForkJoinPool` 类和扩展了 `RecursiveAction` 类的 `Task` 类来增加数组的元素。这是您可以在
    `ForkJoinPool` 类中执行的任务之一。当任务处理数组时，您将 `ForkJoinPool` 类的状态信息打印到控制台。您使用了以下方法来获取 `ForkJoinPool`
    类的状态：
- en: '`getPoolSize()`: This method returns an `int` value, which is the number of
    worker threads of the internal pool of a `ForkJoinPool` class'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 此方法返回 `ForkJoinPool` 类内部池的工作线程数量的 `int` 值'
- en: '`getParallelism()`: This method returns the desired level of parallelism established
    for a pool'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getParallelism()`: 此方法返回为池建立的期望的并行级别'
- en: '`getActiveThreadCount()`: This method returns the number of threads that are
    currently executing tasks'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveThreadCount()`: 此方法返回当前正在执行任务的线程数量'
- en: '`getRunningThreadCount()`: This method returns the number of working threads
    that are not blocked in any synchronization mechanism'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRunningThreadCount()`: 此方法返回未在任何同步机制中阻塞的工作线程数量'
- en: '`getQueuedSubmissionCount()`: This method returns the number of tasks that
    have been submitted to a pool and haven''t started their execution yet'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueuedSubmissionCount()`: 此方法返回已提交到池中但尚未开始执行的任务数量'
- en: '`getQueuedTaskCount()`: This method returns the number of tasks that have been
    submitted to a pool and have started their execution'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueuedTaskCount()`: 此方法返回已提交到池中并已开始执行的任务数量'
- en: '`hasQueuedSubmissions()`: This method returns a `Boolean` value indicating
    whether the pool has queued tasks that haven''t started their execution yet'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasQueuedSubmissions()`：此方法返回一个 `Boolean` 值，指示池是否已排队等待执行的任务'
- en: '`getStealCount()`: This method returns a `long` value specifying the number
    of times a worker thread has stolen a task from another thread'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStealCount()`：此方法返回一个 `long` 值，指定工作线程从其他线程中窃取任务次数'
- en: '`isTerminated()`: This method returns a `Boolean` value indicating whether
    the fork/join pool has finished its execution'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`：此方法返回一个 `Boolean` 值，指示 fork/join 池是否已完成其执行'
- en: See also
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating a fork/join pool* recipe in [Chapter 5](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736),
    *Fork/Join Framework*
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 5 章](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736) 的 *创建 fork/join
    池* 菜单中，*Fork/Join 框架*
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the fork/join framework* and *Customizing tasks running in the fork/join framework*
    recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 8 章](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736) 的 *实现 ThreadFactory
    接口以生成 fork/join 框架的自定义线程* 和 *自定义 fork/join 框架中运行的任务* 菜单中，*自定义并发类*
- en: Monitoring a stream
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控流
- en: A stream in Java is a sequence of elements that could be processed (mapped,
    filtered, transformed, reduced, and collected) either parallelly or sequentially
    in a pipeline of declarative operations using `lambda` expressions. It was introduced
    in Java 8 to change the way one can process enormous sets of data in a functional
    way, with lambda expressions instead of the traditional imperative way.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的流是一系列可以处理的元素（映射、过滤、转换、归约和收集），这些元素可以并行或顺序地在声明性操作的管道中使用 `lambda` 表达式进行处理。它是在
    Java 8 中引入的，以改变人们以函数式方式处理大量数据的方式，用 `lambda` 表达式代替传统的命令式方式。
- en: The `Stream` interface doesn't provide a lot of methods as other concurrency
    classes to monitor its status. Only the `peek()` method allows you to write log
    information about the elements that are being processed. In this recipe, you will
    learn how to use this method to write information about a stream.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 接口不像其他并发类那样提供很多方法来监控其状态。只有 `peek()` 方法允许你写入正在处理的元素的相关日志信息。在本菜谱中，你将学习如何使用此方法来写入有关流的信息。'
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Main` with a `main()` method. Declare two private variables,
    namely an `AtomicInteger` variable called `counter` and a `Random` object called
    `random`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Main` 的类，并包含一个 `main()` 方法。声明两个私有变量，即一个名为 `counter` 的 `AtomicInteger`
    变量和一个名为 `random` 的 `Random` 对象：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a stream of 1,000 random `double` numbers. The stream created is a sequential
    stream. You have to make it parallel using the `parallel()` method, and use the
    `peek()` method to increment the value of the `counter` variable and write a message
    in the console. Post this, use the `count()` method to count the number of elements
    in the array and store that number in an integer variable. Write the value stored
    in the `counter` variable and the value returned by the `count()` method in the
    console:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 1,000 个随机 `double` 数字的流。创建的流是一个顺序流。你必须使用 `parallel()` 方法将其转换为并行流，并使用
    `peek()` 方法增加 `counter` 变量的值并在控制台写入一条消息。之后，使用 `count()` 方法计算数组中的元素数量并将该数字存储在一个整型变量中。将存储在
    `counter` 变量中的值和 `count()` 方法返回的值写入控制台：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, set the value of the `counter` variable to 0\. Create another stream of
    1,000 random `double` numbers. Then, convert it into a parallel stream using the
    `parallel()` method, and use the `peek()` method to increment the value of the
    `counter` variable and write a message in the console. Finally, use the `forEach()`
    method to write all the numbers and the value of the counter variable in the console:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `counter` 变量的值设置为 0。创建另一个包含 1,000 个随机 `double` 数字的流。然后，使用 `parallel()`
    方法将其转换为并行流，并使用 `peek()` 方法增加 `counter` 变量的值并在控制台写入一条消息。最后，使用 `forEach()` 方法将所有数字和计数器的值写入控制台：
- en: '[PRE63]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we used the `peek()` method in two different situations to
    count the number of elements that pass by this step of the stream and write a
    message in the console.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`peek()`方法在两种不同的情况下来计算通过流这一步骤的元素数量，并在控制台中写入一条消息。
- en: As described in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*, `Stream` has a source, zero or more intermediate
    operations, and a final operation. In the first case, our final operation is the
    `count()` method. This method doesn't need to process the elements to calculate
    the returned value, so the `peek()` method will never be executed. You won't see
    any of the messages of the peek method in the console, and the value of the counter
    variable will be 0.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第6章](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736)中所述，“并行和响应式流”，“Stream”有一个源，零个或多个中间操作，以及一个最终操作。在第一种情况下，我们的最终操作是`count()`方法。这个方法不需要处理元素来计算返回值，所以`peek()`方法永远不会被执行。你不会在控制台中看到任何`peek`方法的日志消息，计数器的值将是0。
- en: The second case is different. The final operation is the `forEach()` method,
    and in this case, all the elements of the stream will be processed. In the console,
    you will see messages of both `peek()` and `forEach()` methods. The final value
    of the `counter` variable will be 1,000.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况不同。最后的操作是`forEach()`方法，在这种情况下，流中的所有元素都将被处理。在控制台中，你会看到`peek()`和`forEach()`方法的消息。`counter`变量的最终值将是1,000。
- en: The `peek()` method is an intermediate operation of a stream. Like with all
    intermediate operations, they are executed lazily, and they only process the necessary
    elements. This is the reason why it's never executed in the first case.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`peek()`方法是一个流的中间操作。像所有中间操作一样，它们是延迟执行的，并且只处理必要的元素。这就是为什么它永远不会在第一种情况下执行的原因。'
- en: See also
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Collecting the elements of a stream* recipes in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736)中的“从不同源创建流”、“减少流元素”和“收集流元素”食谱'
- en: Writing effective log messages
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写有效的日志消息
- en: 'A **log** system is a mechanism that allows you to write information to one
    or more destinations. A **Logger** has the following components:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志**系统是一种允许你将信息写入一个或多个目的地的机制。一个**Logger**具有以下组件：'
- en: '**One or more handlers**: A handler will determine the destination and format
    of the log messages. You can write log messages in the console, a file, or a database.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个或多个处理器**：处理器将确定日志消息的目的地和格式。你可以将日志消息写入控制台、文件或数据库。'
- en: '**A name**: Usually, the name of a Logger used in a class is based on the class
    name and its package name.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个名称**：通常，在类中使用的Logger名称基于类名及其包名。'
- en: '**A level**: Log messages have different levels that indicate their importance.
    A Logger also has a level to decide what messages it is going to write. It only
    writes messages that are as important as, or more important, than its level.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个级别**：日志消息有不同的级别，表示它们的重要性。Logger也有一个级别来决定它将要写入哪些消息。它只写入与其级别相同或更重要的消息。'
- en: 'You should use the log system because of the following two main reasons:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用日志系统，主要有以下两个原因：
- en: Write as much information as you can when an exception is caught. This will
    help you localize the error and resolve it.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当捕获到异常时，尽可能多地编写信息。这将帮助你定位错误并解决它。
- en: Write information about the classes and methods that the program is executing.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写有关程序正在执行哪些类和方法的详细信息。
- en: In this recipe, you will learn how to use the classes provided by the `java.util.logging`
    package to add a log system to your concurrent application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何使用`java.util.logging`包提供的类将日志系统添加到你的并发应用程序中。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或不同的IDE，例如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤实现示例：
- en: 'Create a class named `MyFormatter` that extends the `java.util.logging.Formatter`
    class. Implement the abstract `format()` method. It receives a `LogRecord` object
    as a parameter and returns a `String` object with a log message:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyFormatter` 的类，该类扩展了 `java.util.logging.Formatter` 类。实现抽象的 `format()`
    方法。它接收一个 `LogRecord` 对象作为参数，并返回一个包含日志消息的 `String` 对象：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a class named `MyLoggerFactory`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyLoggerFactory` 的类：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Declare a private static `Handler` attribute named `handler`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `handler` 的私有静态 `Handler` 属性：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement the public static method `getLogger()` to create the `Logger` object
    that you''re going to use to write log messages. It receives a `String` parameter
    called `name`. We synchronize this method with the `synchronized` keyword:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `getLogger()` 的公共静态方法，用于创建你将要用于写入日志消息的 `Logger` 对象。它接收一个名为 `name` 的 `String`
    参数。我们使用 `synchronized` 关键字同步此方法：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Get `java.util.logging.Logger` associated with the name received as a parameter
    using the `getLogger()` method of the `Logger` class:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Logger` 类的 `getLogger()` 方法获取与参数名称关联的 `java.util.logging.Logger`：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Establish the log level to write all the log messages using the `setLevel()`
    method:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `setLevel()` 方法设置日志级别，以便写入所有日志消息：
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If the handler attribute has the null value, create a new `FileHandler` object
    to write log messages in the `recipe8.log` file. Assign a `MyFormatter` object
    to this handler; assign it as a formatter using the `setFormatter()` object:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果处理程序属性具有空值，创建一个新的 `FileHandler` 对象以将日志消息写入 `recipe8.log` 文件。将 `MyFormatter`
    对象分配给此处理程序；使用 `setFormatter()` 对象将其分配为格式化程序：
- en: '[PRE70]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If the `Logger` object does not have a handler associated with it, assign the
    handler using the `addHandler()` method:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `Logger` 对象没有与之关联的处理程序，请使用 `addHandler()` 方法分配处理程序：
- en: '[PRE71]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Return the `Logger` object created:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的 `Logger` 对象：
- en: '[PRE72]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a class named `Task` that implements the `Runnable` interface. It will
    be the task used to test your `Logger` object:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，该类实现了 `Runnable` 接口。它将用于测试你的 `Logger` 对象：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Implement the `run()` method:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法：
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'First, declare a `Logger` object named `logger`. Initialize it using the `getLogger()`
    method of the `MyLogger` class by passing the name of this class as a parameter:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明一个名为 `logger` 的 `Logger` 对象。使用 `MyLogger` 类的 `getLogger()` 方法初始化它，通过传递此类的名称作为参数：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Write a log message indicating the beginning of the execution of the method,
    using the `entering()` method:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `entering()` 方法写入一个日志消息，表明方法执行的开始：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Sleep the thread for two seconds:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让线程休眠两秒钟：
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Write a log message indicating the end of the execution of the method, using
    the `exiting()` method:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `exiting()` 方法写入一个日志消息，表明方法执行的结束：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并包含 `main()` 方法来实现示例的主类：
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Declare a `Logger` object named `logger`. Initialize it using the `getLogger()`
    method of the `MyLogger` class by passing the `Core` string as a parameter:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `logger` 的 `Logger` 对象。使用 `MyLogger` 类的 `getLogger()` 方法通过传递 `Core` 字符串作为参数来初始化它：
- en: '[PRE80]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Write a log message indicating the start of the execution of the main program,
    using the `entering()` method:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `entering()` 方法写入一个日志消息，表明主程序执行的开始：
- en: '[PRE81]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a `Thread` array to store five threads:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于存储五个线程的 `Thread` 数组：
- en: '[PRE82]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create five `Task` objects and five threads to execute them. Write log messages
    to indicate that you''re going to launch a new thread and that you have created
    the thread:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个 `Task` 对象和五个线程来执行它们。写入日志消息以表明你将启动一个新线程，并且已经创建了线程：
- en: '[PRE83]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Write a log message to indicate that you have created the threads:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入一个日志消息以表明你已创建了线程：
- en: '[PRE84]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Wait for the finalization of the five threads using the `join()` method. After
    the finalization of each thread, write a log message indicating that the thread
    has finished:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法等待五个线程的最终化。在每个线程最终化后，写入一个日志消息，表明线程已结束：
- en: '[PRE85]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Write a log message to indicate the end of the execution of the main program,
    using the `exiting()` method:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `exiting()` 方法写入一个日志消息以表明主程序执行的结束：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works...
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'In this recipe, you used the `Logger` class provided by the Java logging API
    to write log messages in a concurrent application. First of all, you implemented
    the `MyFormatter` class to assign a format to the log messages. This class extends
    the `Formatter` class that declares the abstract `format()` method. This method
    receives a `LogRecord` object with all of the information of the log message and
    returns a formatted log message. In your class, you used the following methods
    of the `LogRecord` class to obtain information about the log message:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您使用了Java日志API提供的`Logger`类来在并发应用程序中写入日志消息。首先，您实现了`MyFormatter`类来为日志消息分配格式。此类扩展了声明抽象`format()`方法的`Formatter`类。此方法接收一个包含日志消息所有信息的`LogRecord`对象，并返回一个格式化的日志消息。在您的类中，您使用了以下`LogRecord`类的方法来获取有关日志消息的信息：
- en: '`getLevel()`: Returns the level of a message'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLevel()`: 返回消息的级别'
- en: '`getMillis()`: Returns the date when a message was sent to a `Logger` object'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMillis()`: 返回消息发送到`Logger`对象时的日期'
- en: '`getSourceClassName()`: Returns the name of a class that had sent the message
    to the Logger'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSourceClassName()`: 返回向`Logger`发送消息的类的名称'
- en: '`getSourceMessageName()`: Returns the name of the method that had sent the
    message to the Logger'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSourceMessageName()`: 返回向`Logger`发送消息的方法的名称'
- en: '`getMessage()`: Returns the log message'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMessage()`: 返回日志消息'
- en: The `MyLogger` class implements the static method `getLogger()`. This method
    creates a `Logger` object and assigns a `Handler` object to write log messages
    of the application to the `recipe6.log` file, using the `MyFormatter` formatter.
    You create the `Logger` object with the static method `getLogger()` of the `Logger` class.
    This method returns a different object per name that is passed as a parameter.
    You only created one `Handler` object, so all the `Logger` objects will write
    their log messages in the same file. You also configured the logger to write all
    the log messages, regardless of their level.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyLogger`类实现了静态方法`getLogger()`。此方法创建一个`Logger`对象，并将一个`Handler`对象分配给写入应用程序的日志消息到`recipe6.log`文件，使用`MyFormatter`格式化器。您通过`Logger`类的静态方法`getLogger()`创建`Logger`对象。此方法根据传递的参数名称返回不同的对象。您只创建了一个`Handler`对象，因此所有`Logger`对象都将它们的日志消息写入同一个文件。您还配置了记录器，无论其级别如何，都写入所有日志消息。'
- en: 'Finally, you implemented a `Task` object and a main program that writes different
    log messages in the log file. You used the following methods:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您实现了一个`Task`对象和一个主程序，该程序在日志文件中写入不同的日志消息。您使用了以下方法：
- en: '`entering()`: To write a message with the `FINER` level indicating that a method
    has started its execution'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entering()`: 用于写入一个带有`FINER`级别的消息，表示一个方法已开始其执行'
- en: '`exiting()`: To write a message with the `FINER` level indicating that a method
    has ended its execution'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exiting()`: 用于写入一个带有`FINER`级别的消息，表示一个方法已结束其执行'
- en: '`log()`: To write a message with the specified level'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log()`: 用于写入指定级别的消息'
- en: There's more...
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When you work with a log system, you have to take into consideration two important
    points:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与日志系统一起工作时，您必须考虑两个重要点：
- en: '**Write the necessary information**: If you write too little information, the
    logger won''t be useful because it won''t fulfil its purpose. If you write a lot
    of information, you will generate large unmanageable log files; this will make
    it difficult to get the necessary information.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入必要的信息**：如果您写入的信息太少，记录器将没有用，因为它无法完成其目的。如果您写入大量信息，您将生成大量难以管理的日志文件；这将使获取必要信息变得困难。'
- en: '**Use the adequate level for the messages**: If you write high level information
    messages or low level error messages, you will confuse the user who will look
    at the log files. This will make it more difficult to know what happened in an
    error situation; alternatively, you will have too much of information making it
    difficult to know the main cause of the error.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用适当的消息级别**：如果您写入高级信息消息或低级错误消息，您将使查看日志文件的用户感到困惑。这将使在错误情况下了解发生了什么变得更加困难；或者，您将拥有过多的信息，这使得了解错误的主要原因变得困难。'
- en: There are other libraries that provide a log system that is more complete than
    the `java.util.logging` package, such as the `Log4j` or `slf4j` libraries. But
    the `java.util.logging` package is part of the Java API, and all its methods are
    multithread safe; therefore, we can use it in concurrent applications without
    problems.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using non-blocking thread-safe deques*, *Using blocking thread-safe deques*,
    *Using blocking thread-safe queues ordered by priority*, *Using thread-safe lists
    with delayed elements* and *Using thread-safe navigable maps *recipes in [Chapter
    7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736), *Concurrent Collections*
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing concurrent code with FindBugs
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Static code analysis tools** are a set of tools that analyze the source code
    of an application while looking for potential errors. These tools, such as Checkstyle,
    PMD, or FindBugs, have a set of predefined rules of good practices and parse the
    source code looking for violations of these rules. The objective is to find errors
    or places that cause poor performance at an early stage, before they are executed
    in production. Programming languages usually offer such tools, and Java is not
    an exception. One of the tools that helps analyze Java code is FindBugs. It''s
    an open source tool that includes a series of rules to analyze Java-concurrent
    code.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use this tool to analyze your Java-concurrent
    application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start this recipe, download FindBugs from the project's web page
    ([http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)). You can
    download a standalone application or an Eclipse plugin. In this recipe, I used
    the standalone version.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, the actual version of FindBugs (3.0.1) doesn't
    include support for Java 9\. You can download a preview of the 3.1.0 version with
    support for Java 9 from [https://github.com/findbugsproject/findbugs/releases/tag/3.1.0_preview1](https://github.com/findbugsproject/findbugs/releases/tag/3.1.0_preview1).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` that extends the `Runnable` interface:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Declare a private `ReentrantLock` attribute named `lock`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Implement a constructor of the class:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Implement the `run()` method. Get control of the lock, put the thread to sleep
    for 2 seconds, and free the lock:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Declare and create a `ReentrantLock` object named `lock`:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create 10 `Task` objects and 10 threads to execute the tasks. Start the threads
    by calling the `run()` method:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Export the project as a `.jar` file. Call it `recipe7.jar`. Use the menu option
    of your IDE or the `javac` and `.jar` commands to compile and compress your application.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the FindBugs standalone application by running the `findbugs.bat` command
    in Windows or the `findbugs.sh` command in Linux.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new project by clicking on the New Project option under the File menu
    in the menu bar:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在菜单栏中的文件菜单下点击新建项目选项来创建新项目：
- en: '![](img/00059.jpeg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: 'The *FindBugs* application shows a window to configure the project. In the
    Project name field, type `Recipe07`. In the Classpath for analysis field (jar,
    ear, war, zip, or directory), add the `.jar` file with the project. In the Source
    directories field (optional; classes used when browsing found bugs), add the directory
    with the source code of the example. Refer to the following screenshot:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*FindBugs* 应用程序显示一个窗口来配置项目。在项目名称字段中，输入 `Recipe07`。在分析类路径字段（jar、ear、war、zip
    或目录）中，添加包含项目的 `.jar` 文件。在源代码目录字段（可选；浏览找到的错误时使用的类），添加示例源代码的目录。参考以下截图：'
- en: '![](img/00060.jpeg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: Click on the Analyze button to create the new project and analyze its code.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击分析按钮以创建新项目并分析其代码。
- en: The *FindBugs* application shows the result of the analysis of the code. In
    this case, it has found two bugs.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*FindBugs* 应用程序显示了代码的分析结果。在这种情况下，它找到了两个错误。'
- en: Click on one of the bugs and you'll see the source code of the bug on the right-hand
    side panel and the description of the bug in the panel at the bottom of the screen.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击其中一个错误，你将在右侧面板中看到错误的源代码，并在屏幕底部的面板中看到错误的描述。
- en: How it works...
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the result of the analysis by FindBugs:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了FindBugs分析的结果：
- en: '![](img/00061.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: 'The analysis has detected the following two potential bugs in the application:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 分析检测到应用程序中的以下两个潜在错误：
- en: One of the bugs is detected in the `run()` method of the `Task` class. If an
    `InterruptedExeption` exception is thrown, the task doesn't free the lock because
    it won't execute the `unlock()` method. This will probably cause a deadlock situation
    in the application.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个错误检测到 `Task` 类的 `run()` 方法中。如果抛出 `InterruptedExeption` 异常，任务不会释放锁，因为它不会执行
    `unlock()` 方法。这可能会在应用程序中引起死锁情况。
- en: The other bug is detected in the `main()` method of the `Main` class because
    you called the `run()` method of a thread directly, not the `start()` method to
    begin the execution of the thread.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个错误检测到在 `Main` 类的 `main()` 方法中，因为你直接调用了线程的 `run()` 方法，而不是调用 `start()` 方法来开始线程的执行。
- en: 'If you double-click on one of the two bugs, you will see detailed information
    about it. As you have included the source code reference in the configuration
    of the project, you will also see the source code where the bug was detected.
    The following screenshot shows you an example of this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你双击两个错误之一，你将看到有关它的详细信息。由于你在项目配置中包含了源代码引用，你还将看到检测到错误的源代码。以下截图显示了此示例：
- en: '![](img/00062.jpeg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.jpeg)'
- en: There's more...
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Be aware that FindBugs can only detect some problematic situations (related
    or not to concurrency code). For example, if you delete the `unlock()` call in
    the `run()` method of the `Task` class and repeat the analysis, FindBugs won't
    alert you that
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，FindBugs只能检测到一些问题情况（与并发代码相关或不相关）。例如，如果你在 `Task` 类的 `run()` 方法中删除 `unlock()`
    调用并重复分析，FindBugs 不会警告你
- en: you will get the lock in the task but you will never be able to free it.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在任务中获得锁，但你永远无法释放它。
- en: Use the tools of the static code analysis as a form of assistance to improve
    the quality of your code, but do not expect it to detect all the bugs.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态代码分析工具作为提高代码质量的一种辅助手段使用，但不要期望它能检测到所有错误。
- en: See also
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Configuring NetBeans for debugging concurrency code* recipe in this chapter
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于 *配置NetBeans以调试并发代码* 的配方
- en: Configuring Eclipse for debugging concurrency code
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Eclipse以调试并发代码
- en: 'Nowadays, almost every programmer, regardless of the programming language in
    use, create their applications with an IDE. They provide lots of interesting functionalities
    integrated in the same application, such as:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎每个程序员，无论使用哪种编程语言，都会使用IDE来创建他们的应用程序。它们在同一个应用程序中集成了许多有趣的功能，例如：
- en: Project management
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目管理
- en: Automatic code generation
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动代码生成
- en: Automatic documentation generation
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动文档生成
- en: Integration with control version systems
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与版本控制系统的集成
- en: A debugger to test applications
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试应用程序的调试器
- en: Different wizards to create projects and elements of the applications
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建项目和应用程序元素的不同的向导
- en: One of the most helpful features of an IDE is a debugger. Using it, you can
    execute your application step by step and analyze the values of all the objects
    and variables of your program.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: IDE最有用的功能之一是调试器。使用它，你可以逐步执行你的应用程序并分析程序中所有对象和变量的值。
- en: If you work with Java, Eclipse is one of the most popular IDEs. It has an integrated
    debugger that allows you to test your applications. By default, when you debug
    a concurrent application and the debugger finds a breakpoint, it only stops the
    thread that has the breakpoint while it allows the rest of the threads to continue
    with their execution. In this recipe, you will learn how to change this configuration
    to help you test concurrent applications.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Java，Eclipse是最受欢迎的IDE之一。它集成了调试器，允许你测试你的应用程序。默认情况下，当你调试一个并发应用程序并且调试器发现一个断点时，它只会停止带有断点的线程，同时允许其他线程继续执行。在这个菜谱中，你将学习如何更改此配置以帮助你测试并发应用程序。
- en: Getting ready
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must have installed the Eclipse IDE. Open it and select a project with a
    concurrent application implemented, for example, one of the recipes implemented
    in the book.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须已经安装了Eclipse IDE。打开它，并选择一个实现了并发应用程序的项目，例如，书中实现的一个菜谱。
- en: How to do it...
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Navigate to Window | Preferences.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到窗口 | 首选项。
- en: Expand the Java option in the left-hand side menu.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中展开Java选项。
- en: 'Then, select the Debug option. The following screenshot illustrates the window:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择调试选项。以下截图说明了窗口：
- en: '![](img/00063.jpeg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00063.jpeg)'
- en: Change the value of Default suspend policy for new breakpoints from Suspend
    Thread to Suspend VM (marked in red in the screenshot).
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认挂起策略的值从“挂起线程”更改为“挂起虚拟机”（在截图中被标记为红色）。
- en: Click on the OK button to confirm the change.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”按钮以确认更改。
- en: How it works...
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As mentioned in the introduction of this recipe, by default, when you debug
    a concurrent Java application in Eclipse and the debug process finds a breakpoint,
    it only suspends the thread that hits the breakpoint first, but it allows other
    threads to continue with their execution. The following screenshot shows an example
    of this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如本菜谱介绍中所述，默认情况下，当你使用Eclipse调试并发Java应用程序并且调试过程发现断点时，它只会挂起第一个遇到断点的线程，但允许其他线程继续执行。以下截图展示了这种情况的示例：
- en: '![](img/00064.jpeg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00064.jpeg)'
- en: 'You can see that only worker-21 is suspended (marked in red in the screenshot),
    while the rest of the threads are running. However, while debugging a concurrent
    application, if you change Default suspend policy for new breakpoints to Suspend
    VM, all the threads will suspend their execution and the debug process will hit
    a breakpoint.. The following screenshot shows an example of this situation:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，只有worker-21被挂起（在截图中被标记为红色），而其他线程仍在运行。然而，在调试并发应用程序时，如果你将默认挂起策略更改为“挂起虚拟机”，所有线程将挂起它们的执行，调试过程将遇到断点。以下截图展示了这种情况的示例：
- en: '![](img/00065.jpeg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00065.jpeg)'
- en: With the change, you can see that all the threads are suspended. You can continue
    debugging any thread you want. Choose the suspend policy that best suits your
    needs.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改，你可以看到所有线程都被挂起。你可以继续调试任何你想要的线程。选择最适合你需求的挂起策略。
- en: Configuring NetBeans for debugging concurrency code
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置NetBeans以调试并发代码
- en: Software is necessary to develop applications that work properly, meet the quality
    standards of the company, and could be easily modified in future (in limited time
    and cost as low as possible). To achieve this goal, it is essential to use an
    IDE that can integrate  several tools (compilers and debuggers) that facilitate
    the development of applications under one common interface.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是开发能够正常工作、符合公司质量标准并且可以轻松修改（在尽可能低的时间和成本下）的应用程序所必需的。为了实现这一目标，使用能够集成多个工具（编译器和调试器）以在一个共同界面下简化应用程序开发的IDE是至关重要的。
- en: If you work with Java, NetBeans is one of the most popular IDEs. It has an integrated
    debugger that allows you to test your application.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Java，NetBeans也是最受欢迎的IDE之一。它集成了调试器，允许你测试你的应用程序。
- en: In this recipe, you will learn how to change the configuration of the Netbeans
    debugger to help you test concurrent applications.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何更改NetBeans调试器的配置以帮助你测试并发应用程序。
- en: Getting ready
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have the NetBeans IDE installed. Open it and create a new Java project.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了NetBeans IDE。打开它，并创建一个新的Java项目。
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task1` and specify that it implements the `Runnable`
    interface:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task1` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE94]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Declare two private `Lock` attributes, named `lock1` and `lock2`:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为 `lock1` 和 `lock2` 的私有 `Lock` 属性：
- en: '[PRE95]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE96]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Implement the `run()` method. First, get control of the `lock1` object using
    the `lock()` method and write aa message in the console indicating that you have
    got it:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。首先，使用 `lock()` 方法获取 `lock1` 对象的控制权，并在控制台写入一条消息，表明你已获取它：
- en: '[PRE97]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then, get control of `lock2` using the `lock()` method and write a message
    in the console indicating that you have got it:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `lock()` 方法获取 `lock2` 的控制权，并在控制台写入一条消息，表明你已获取它：
- en: '[PRE98]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Finally, release the two lock objects-first the `lock2` object and then the
    `lock1` object:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，释放两个锁对象——首先释放 `lock2` 对象，然后释放 `lock1` 对象：
- en: '[PRE99]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Create a class named `Task2` and specify that it implements the `Runnable`
    interface:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task2` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE100]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Declare two private `Lock` attributes, named `lock1` and `lock2`:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为 `lock1` 和 `lock2` 的私有 `Lock` 属性：
- en: '[PRE101]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE102]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Implement the `run()` method. First, get control of the `lock2` object using
    the `lock()` method and write a message in the console indicating that you have
    got it:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。首先，使用 `lock()` 方法获取 `lock2` 对象的控制权，并在控制台写入一条消息，表明你已获取它：
- en: '[PRE103]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, get control of `lock1` using the `lock()` method and write a message
    in the console indicating that you have got it:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `lock()` 方法获取 `lock1` 的控制权，并在控制台写入一条消息，表明你已获取它：
- en: '[PRE104]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Finally, release the two lock objects-first `lock1` and then `lock2`:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，释放两个锁对象——首先释放 `lock1`，然后释放 `lock2`：
- en: '[PRE105]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE106]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create two lock objects named `lock1` and `lock2`:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为 `lock1` 和 `lock2` 的锁对象：
- en: '[PRE107]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a `Task1` object named `task1`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `task1` 的 `Task1` 对象：
- en: '[PRE108]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Create a `Task2` object named `task2`:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `task2` 的 `Task2` 对象：
- en: '[PRE109]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Execute both the tasks using two threads:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个线程执行两个任务：
- en: '[PRE110]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'When the two tasks finish their execution, write a message in the console every
    500 milliseconds. Use the `isAlive()` method to check whether a thread has finished
    its execution:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个任务完成执行时，每500毫秒在控制台写入一条消息。使用 `isAlive()` 方法检查线程是否已完成其执行：
- en: '[PRE111]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Add a breakpoint in the first call to the `printf()` method of the `run()` method
    of the `Task1` class.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Task1` 类的 `run()` 方法的 `printf()` 方法第一次调用处添加一个断点。
- en: 'Debug the program. You will see the Debugging window in the top left-hand side
    corner of the main NetBeans window. The next screenshot illustrates the window
    with the thread that executes the `Task1` object. The thread is waiting in the
    breakpoint. The other threads of the application are running:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试程序。你将在主 NetBeans 窗口的左上角看到调试窗口。下一张截图展示了包含执行 `Task1` 对象的线程的窗口。该线程正在断点处等待。应用程序的其他线程正在运行：
- en: '![](img/00066.jpeg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00066.jpeg)'
- en: 'Pause the execution of the main thread. Select the thread, right-click on it,
    and select the Suspend option. The following screenshot shows the new appearance
    of the Debugging window. Refer to the following screenshot:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停主线程的执行。选择线程，右键单击它，并选择“挂起”选项。以下截图显示了调试窗口的新外观。请参考以下截图：
- en: '![](img/00067.jpeg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00067.jpeg)'
- en: Resume the two paused threads. Select each thread, right-click on them, and
    select the Resume option.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复两个暂停的线程。选择每个线程，右键单击它们，并选择“恢复”选项。
- en: How it works...
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While debugging a concurrent application using NetBeans, when the debugger hits
    a breakpoint, it suspends the thread that hit the breakpoint and shows the Debugging
    window in the top left-hand side corner with the threads that are currently running.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 NetBeans 调试并发应用程序时，当调试器遇到断点时，它会挂起遇到断点的线程，并在主窗口的左上角显示包含当前正在运行的线程的调试窗口。
- en: You can use the window to pause or resume the threads that are currently running,
    using the Pause or Resume options. You can also see the values of the variables
    or attributes of the threads using the Variables tab.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用窗口暂停或恢复当前正在运行的线程，使用“暂停”或“恢复”选项。你还可以使用“变量”选项卡查看线程的变量或属性值。
- en: 'NetBeans also includes a deadlock detector. When you select the Check for Deadlock
    option in the Debug menu, NetBeans performs an analysis of the application that
    you''re debugging to determine whether there''s a deadlock situation. This example
    presents a clear deadlock. The first thread gets `lock1` first and then `lock2`.
    The second thread gets the locks in reverse manner. The breakpoint inserted provokes
    the deadlock, but if you use the NetBeans deadlock detector, you''ll not find
    anything. Therefore, this option should be used with caution. Change the locks
    used in both the tasks by the `synchronized` keyword and debug the program again.
    The code of `Task1` is as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans 还包括一个死锁检测器。当你从调试菜单中选择检查死锁选项时，NetBeans 会分析你正在调试的应用程序，以确定是否存在死锁情况。本例展示了一个明显的死锁。第一个线程首先获取
    `lock1`，然后是 `lock2`。第二个线程以相反的顺序获取锁。插入的断点引发了死锁，但如果你使用 NetBeans 死锁检测器，你将找不到任何东西。因此，应谨慎使用此选项。通过
    `synchronized` 关键字更改两个任务中使用的锁，并再次调试程序。`Task1` 的代码如下：
- en: '[PRE112]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The code of the `Task2` class will be analogous to this, but it changes the
    order of the locks. If you debug the example again, you will obtain a deadlock
    one more time. However, in this case, it''s detected by the deadlock detector,
    as you can see in the following screenshot:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task2` 类的代码将与这个类似，但它改变了锁的顺序。如果你再次调试这个示例，你将再次遇到死锁。然而，在这种情况下，它被死锁检测器检测到，如下面的截图所示：'
- en: '![](img/00068.jpeg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: There's more...
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'There are options to control the debugger. Select Options from the Tools menu.
    Then, select the Miscellaneous option and the Java Debugger tab. The following
    screenshot illustrates this window:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 有选项可以控制调试器。从工具菜单中选择选项。然后，选择杂项选项和 Java 调试器选项卡。以下截图说明了此窗口：
- en: '![](img/00069.gif)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.gif)'
- en: 'There are two options in the window that control the behavior described earlier:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口中有两个选项可以控制之前描述的行为：
- en: 'New breakpoints suspend: With this option, you can configure the behavior of
    NetBeans, which finds a breakpoint in a thread. You can suspend only that thread
    that has a breakpoint or all the threads of the application.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新断点挂起：使用此选项，你可以配置 NetBeans 的行为，它在一个线程中找到一个断点。你可以只挂起带有断点的那个线程或应用的所有线程。
- en: 'Steps resume: With this option, you can configure the behavior of NetBeans
    when you resume a thread. You can resume only the current thread or all the threads.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤总结：使用此选项，你可以配置 NetBeans 在恢复线程时的行为。你可以只恢复当前线程或所有线程。
- en: Both the options have been marked in the screenshot presented earlier.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 两个选项都在前面展示的截图中做了标记。
- en: See also
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Configuring Eclipse for debugging concurrency code* recipe in this chapter
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *配置 Eclipse 以调试并发代码* 的配方
- en: Testing concurrency code with MultithreadedTC
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MultithreadedTC 测试并发代码
- en: '`MultithreadedTC` is a Java library for testing concurrent applications. Its
    main objective is to solve the problem of concurrent applications being non-deterministic.
    You can''t control the order of execution of the different threads that form the
    application. For this purpose, it includes an internal **metronome**. These testing
    threads are implemented as methods of a class.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultithreadedTC` 是一个用于测试并发应用的 Java 库。其主要目标是解决并发应用的非确定性问题的解决方案。你无法控制构成应用的不同线程的执行顺序。为此，它包括一个内部
    **节拍器**。这些测试线程作为类的方法实现。'
- en: In this recipe, you will learn how to use the `MultithreadedTC` library to implement
    a test for `LinkedTransferQueue`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将学习如何使用 `MultithreadedTC` 库来实现对 `LinkedTransferQueue` 的测试。
- en: Getting ready
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the MultithreadedTC library from [https://code.google.com/archive/p/multithreadedtc/](https://code.google.com/archive/p/multithreadedtc/)
    and the JUnit library, version 4.10, from [http://junit.org/junit4/](http://junit.org/junit4/).
    Add the `junit-4.10.jar` and `MultithreadedTC-1.01.jar` files to the libraries
    of the project.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://code.google.com/archive/p/multithreadedtc/](https://code.google.com/archive/p/multithreadedtc/)
    下载 MultithreadedTC 库和 JUnit 库，版本 4.10，从 [http://junit.org/junit4/](http://junit.org/junit4/)。将
    `junit-4.10.jar` 和 `MultithreadedTC-1.01.jar` 文件添加到项目的库中。
- en: How to do it...
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `ProducerConsumerTest` that extends the `MultithreadedTestCase`
    class:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ProducerConsumerTest` 的类，该类扩展了 `MultithreadedTestCase` 类：
- en: '[PRE113]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Declare a private `LinkedTransferQueue` attribute parameterized by the `String`
    class named `queue`:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `queue` 的私有 `LinkedTransferQueue` 属性参数，该参数由 `String` 类指定：
- en: '[PRE114]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Implement the `initialize()` method. This method won''t receive any parameters
    and will return no value. It will call the `initialize()` method of its parent
    class and then initialize the queue attribute:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Implement the `thread1()` method. It will implement the logic of the first
    consumer. Call the `take()` method of the queue and then write the returned value
    in the console:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Implement the `thread2()` method. It will implement the logic of the second
    consumer. First wait until the first thread has slept in the `take()` method.
    To put the thread to sleep, use the `waitForTick()` method. Then, call the `take()`
    method of the queue and write the returned value in the console:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Implement the `thread3()` method. It will implement the logic of a producer.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First wait until the two consumers are blocked in the `take()` method; block
    this method using the `waitForTick()` method twice. Then, call the `put()` method
    of the queue to insert two strings in the queue:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Finally, implement the `finish()` method. Write a message in the console to
    indicate that the test has finished its execution. Check that the two events have
    been consumed (so the size of the queue is `0`) using the `assertEquals()` method:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Next, implement the main class of the example by creating a class named `Main`
    with a `main()` method:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Create a `ProducerConsumerTest` object named `test`:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Execute the test using the `runOnce()` method of the `TestFramework` class:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: How it works...
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented a test for the `LinkedTransferQueue` class using
    the `MultithreadedTC` library. You can implement a test in any concurrent application
    or class using this library and its metronome. In the example, you implemented
    the classical producer/consumer problem with two consumers and a producer. You
    wanted to test that the first `String` object introduced in the buffer is consumed
    by the first consumer that arrives at the buffer, and the second `String` object
    introduced in the buffer is consumed by the second consumer that arrives at the
    buffer.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: The `MultithreadedTC` library is based on the JUnit library, which is the most
    often used library to implement unit tests in Java. To implement a basic test
    using the `MultithreadedTC` library, you have to extend the `MultithreadedTestCase`
    class. This class extends the `junit.framework.AssertJUnit` class that includes
    all the methods to check the results of the test. It doesn't extend the `junit.framework.TestCase`
    class, so you can't integrate MultithreadedTC tests with other JUnit tests.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can implement the following methods:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '`initialize()`: The implementation of this method is optional. It''s executed
    when you start the test, so you can use it to initialize objects that are using
    the test.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finish()`: The implementation of this method is optional. It''s executed when
    the test has finished. You can use it to close or release resources used during
    the test or to check the results of the test.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that implement the test: These methods have the main logic of the test
    you implement. They have to start with the `thread` keyword, followed by a string,
    for example, `thread1()`.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To control the order of execution of threads, you used the `waitForTick()` method.
    This method receives an integer value as a parameter and puts the thread that
    is executing the method to sleep until all the threads that are running in the
    test are blocked. When they are blocked, the `MultithreadedTC` library resumes
    the threads that are blocked by a call to the `waitForTick()` method.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: The integer you pass as a parameter of the `waitForTick()` method is used to
    control the order of execution. The metronome of the `MultithreadedTC` library
    has an internal counter. When all the threads are blocked, the library increments
    this counter to the next number specified in the `waitForTick()` calls that are
    blocked.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Internally, when the `MultithreadedTC` library has to execute a test, first
    it executes the `initialize()` method. Then it creates a thread per method that
    starts with the `thread` keyword (in your example, the methods `thread1()`, `thread2()`,
    and `thread3()`). When all the threads have finished their execution, it executes
    the `finish()` method. To execute the test, you used the `runOnce()` method of
    the `TestFramework` class.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the `MultithreadedTC` library detects that all the threads of the test are
    blocked except in the `waitForTick()` method, the test is declared to be in a
    deadlock state and a `java.lang.IllegalStateException` exception is thrown.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Analyzing concurrent code with FindBugs* recipe in this chapter
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring with JConsole
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JConsole** is a monitoring tool that follows the JMX specification that allows
    you to get information about the execution of an application as the number of
    threads, memory use, or class loading. It is included with the JDK and it can
    be used to monitor local or remote applications. In this recipe, you will learn
    how to use this tool to monitor a simple concurrent application.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` and specify the `Runnable` interface. Implement
    the `run()` method to write the message in the console during 100 seconds:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Implement the `Main` class with the `main()` method. Create 10 `Task` objects
    to create 10 threads. Start them and wait for their finalization using the `join()`
    method:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Open a console window and execute the `JConsole` application. It''s included
    in the bin directory of the JDK-9 installation:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we implemented a very simple example: running 10 threads for
    100 seconds. These are threads that write messages in the console.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute JConsole, you will see a window that shows all the Java applications
    that are running in your system. You can choose the one you want to monitor. The
    window will be similar to the following one:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we select our sample app and click on the Connect button. Then,
    you will be asked to establish an insecure connection with the application, with
    a dialog similar to the following one:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Insecure connection button. JConsole will show you information
    about your application using six tabs:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The Overview tab provides an overview of memory use, the number of threads running
    in the application, the number of objects created, and CPU usage of the application.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Memory tab shows the amount of memory used by the application. It has a
    combo where you can select the type of memory you want to monitor (heap, non-heap,
    or pools).
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Threads tab shows you information about the number of threads in the application
    and detailed information about each thread.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Classes tab shows you information about the number of objects loaded in
    the application.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VW Summary tab provides a summary of the JVM running the application.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MBeans tab shows you information about the managed beans of the application.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The threads tab is similar to the following one:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
- en: It has two different parts. In the upper part, you have real-time information
    about the **Peak** number of threads (with a red line) and the number of **Live
    Threads** (with a blue line). In the lower part, we have a list of active threads.
    When you select one of these threads, you will see detailed information about
    that thread, including its status and the actual stack trace.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use other applications to monitor applications that run Java. For example,
    you can use VisualVM included with the JDK. You can obtain necessary information
    about visualvm at [https://visualvm.github.io](https://visualvm.github.io).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Testing concurrency code with MultithreadedTC* recipe in this chapter
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
