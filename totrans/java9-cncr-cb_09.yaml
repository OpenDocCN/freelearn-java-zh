- en: Testing Concurrent Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring a Lock interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Phaser class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring an Executor framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a fork/join pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing effective log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing concurrent code with FindBugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Eclipse for debugging concurrency code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring NetBeans for debugging concurrency code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing concurrency code with MultithreadedTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring with JConsole
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing an application is a critical task. Before you make an application ready
    for end users, you have to demonstrate its correctness. You use a test process
    to prove that correctness is achieved and errors are fixed. Testing is a common
    task in any software development and quality assurance process. You can find a
    lot of literature about testing processes and the different approaches you can
    apply to your developments. There are a lot of libraries as well, such as JUnit,
    and applications, such as Apache JMeter, that you can use to test your Java applications
    in an automated way. Testing is even more critical in concurrent application development.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that concurrent applications have two or more threads that share data
    structures and interact with each other adds more difficulty to the testing phase.
    The biggest problem you will face when you test concurrent applications is that
    the execution of threads is non-deterministic. You can't guarantee the order of
    the execution of threads, so it's difficult to reproduce errors.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring a Lock interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Lock` interface is one of the basic mechanisms provided by the Java concurrency
    API to synchronize a block of code. It allows you to define a **critical section**.
    A critical section is a block of code that accesses a shared resource and can't
    be executed by more than one thread at the same time. This mechanism is implemented
    by the `Lock` interface and the `ReentrantLock` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what information you can obtain about a `Lock`
    object and how to obtain that information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyLock` that extends the `ReentrantLock` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `getOwnerName()`. This method returns the name of the thread that
    has control of a lock (if any), using the protected method of the `Lock` class
    called `getOwner()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `getThreads()`. This method returns a list of threads queued in a
    lock, using the protected method of the `Lock` class called `getQueuedThreads()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Lock` attribute named `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Create a loop with five steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Acquire the lock using the `lock()` method and print a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the thread to sleep for 500 milliseconds. Free the lock using the `unlock()`
    method and print a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyLock` object named `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of five `Thread` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and start five threads to execute five `Task` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a loop with 15 steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the name of the owner of the lock in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the number and name of the threads queued for the lock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Display information about the fairness and status of the `Lock` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the thread to sleep for 1 second and close the loop and the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you implemented the `MyLock` class that extends the `ReentrantLock`
    class to return information that wouldn''t have been available otherwise-it''s
    protected data of the `ReentrantLock` class. The methods implemented by the `MyLock`
    class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getOwnerName()`: Only one thread can execute a critical section protected
    by a `Lock` object. The lock stores the thread that is executing the critical
    section. This thread is returned by the protected `getOwner()` method of the `ReentrantLock`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getThreads()`: When a thread is executing a critical section, other threads
    that try to enter it are put to sleep before they continue executing that critical
    section. The protected method `getQueuedThreads()` of the `ReentrantLock` class
    returns the list of threads that are waiting to execute the critical section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also used other methods that are implemented in the `ReentrantLock` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hasQueuedThreads()`: This method returns a `Boolean` value indicating whether
    there are threads waiting to acquire the calling `ReentrantLock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueueLength()`: This method returns the number of threads that are waiting
    to acquire the calling `ReentrantLock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLocked()`: This method returns a `Boolean` value indicating whether the
    calling `ReentrantLock` is owned by a thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isFair()`: This method returns a `Boolean` value indicating whether the calling
    `ReentrantLock` has fair mode activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are other methods in the `ReentrantLock` class that can be used to obtain
    information about a `Lock` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getHoldCount()`: This returns the number of times the current thread has acquired
    the lock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isHeldByCurrentThread()`: This returns a `Boolean` value indicating whether
    the lock is owned by the current thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing a custom Lock class* recipe in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a Phaser class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most complex and powerful functionalities offered by the Java Concurrency
    API is the ability to execute concurrent-phased tasks using the `Phaser` class.
    This mechanism is useful when we have some concurrent tasks divided into steps.
    The `Phaser` class provides the mechanism to synchronize threads at the end of
    each step so no thread starts its second step until all the threads have finished
    the first one.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what information you can obtain about the status
    of a `Phaser` class and how to obtain that information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `time`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Phaser` attribute named `phaser`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. First, instruct the `phaser` attribute that the
    task starts its execution with the `arrive()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message in the console indicating the start of phase one. Put the thread
    to sleep for the number of seconds specified by the `time` attribute. Write a
    message in the console indicating the end of phase one. And, synchronize with
    the rest of the tasks using the `arriveAndAwaitAdvance()` method of the `phaser`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat this behavior in both second and third phases. At the end of the third
    phase, use the `arriveAndDeregister()` method instead of `arriveAndAwaitAdvance()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Phaser` object named `phaser` with three participants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and launch three threads to execute three task objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a loop with 10 steps to write information about the `phaser` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Write information about the registered parties, the phase of the `phaser`,
    the arrived parties, and the unarrived parties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the thread to sleep for 1 second and close the loop and the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we implemented a phased task in the `Task` class. This phased
    task has three phases and uses a `Phaser` interface to synchronize with other
    `Task` objects. The main class launches three tasks, and when these tasks execute
    their respective phases, it prints information about the status of the `phaser`
    object to the console. We used the following methods to get the status of the
    `phaser` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPhase()`: This method returns the actual phase of a `phaser` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRegisteredParties()`: This method returns the number of tasks that use
    a `phaser` object as a mechanism of synchronization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getArrivedParties()`: This method returns the number of tasks that have arrived
    at the end of the actual phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUnarrivedParties()`: This method returns the number of tasks that haven''t
    yet arrived at the end of the actual phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Running concurrent-phased tasks* recipe in [Chapter 3](part0119.html#3HFIU0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Synchronization Utilities*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring an Executor framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Executor` framework provides a mechanism that separates the implementation
    of tasks from thread creation and management to execute the tasks. If you use
    an executor, you only have to implement `Runnable` objects and send them to the
    executor. It is the responsibility of an executor to manage threads. When you
    send a task to an executor, it tries to use a pooled thread for executing the
    task in order to avoid the creation of new threads. This mechanism is offered
    by the `Executor` interface and its implementing classes as the `ThreadPoolExecutor`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what information you can obtain about the status
    of a `ThreadPoolExecutor` executor and how to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` that implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `long` attribute named `milliseconds`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Put the thread to sleep for the number of milliseconds
    specified by the `milliseconds` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Executor` object using the `newCachedThreadPool()` method of
    the `Executors` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and submit 10 `Task` objects to the executor. Initialize the objects
    with a random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a loop with five steps. In each step, write information about the executor
    by calling the `showLog()` method and putting the thread to sleep for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the executor using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another loop with five steps. In each step, write information about
    the executor by calling the `showLog()` method and putting the thread to sleep
    for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the executor using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Display a message indicating the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `showLog()` method that receives `Executor` as a parameter. Write
    information about the size of the pool, the number of tasks, and the status of
    the executor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you implemented a task that blocks its execution thread for
    a random number of milliseconds. Then, you sent 10 tasks to an executor, and while
    you were waiting for their finalization, you wrote information about the status
    of the executor to the console. You used the following methods to get the status
    of the `Executor` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getCorePoolSize()`: This method returns an `int` number, which refers to the
    core number of threads. It''s the minimum number of threads that will be in the
    internal thread pool when the executor is not executing any task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returns an `int` value, which refers to the actual
    size of the internal thread pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveCount()`: This method returns an `int` number, which refers to the
    number of threads that are currently executing tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getTaskCount()`: This method returns a `long` number, which refers to the
    number of tasks that have been scheduled for execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCompletedTaskCount()`: This method returns a `long` number, which refers
    to the number of tasks that have been executed by this executor and have finished
    their execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isShutdown()`: This method returns a `Boolean` value when the `shutdown()`
    method of an executor is called to finish its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminating()`: This method returns a `Boolean` value when the executor
    performs the `shutdown()` operation but hasn''t finished it yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns a `Boolean` value when the executor finishes
    its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a thread executor and controlling its rejected tasks* recipe in
    [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Customizing the ThreadPoolExecutor class* and *Implementing a priority-based
    Executor class* recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a fork/join pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework provides a mechanism that allows you to separate task
    implementation from the creation and management of threads that execute the tasks.
    Java 9 includes an extension of the Executor framework for a specific kind of
    problem that will improve the performance of other solutions (using `Thread` objects
    directly or the Executor framework). It's the fork/join framework.
  prefs: []
  type: TYPE_NORMAL
- en: This framework is designed to solve problems that can be broken down into smaller
    tasks using the `fork()` and `join()` operations. The main class that implements
    this behavior is `ForkJoinPool`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn what information you can obtain about a `ForkJoinPool`
    class and how to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` that extends the `RecursiveAction` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` array attribute named `array` to store the array of
    elements you want to increment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `int` attributes named `start` and `end` to store the start
    and end positions of the block of elements this task has to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method with the main logic of the task. If the task
    has to process more than 100 elements, first divide the elements into two parts,
    create two tasks to execute these parts, start its execution with the `fork()`
    method, and finally, wait for its finalization with the `join()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If the task has to process 100 elements or less, increment the elements by
    putting the thread to sleep for 5 milliseconds after each operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ForkJoinPool` object named `pool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of integer numbers, named `array`, with 10,000 elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Task` object to process the whole array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the task for execution to the pool using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If the task doesn''t finish its execution, call the `showLog()` method to write
    information about the status of the `ForkJoinPool` class and put the thread to
    sleep for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the pool using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the pool using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `showLog()` method to write information about the status of the `ForkJoinPool`
    class and write a message in the console indicating the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `showLog()` method. It receives a `ForkJoinPool` object as a
    parameter and writes information about its status and the threads and tasks that
    are being executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you implemented a task that increments the elements of an array,
    using a `ForkJoinPool` class, and a `Task` class that extends the `RecursiveAction`
    class. This is one of the tasks you can execute in a `ForkJoinPool` class. When
    the tasks were processing the array, you printed information about the status
    of the `ForkJoinPool` class to the console. You used the following methods to
    get the status of the `ForkJoinPool` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returns an `int` value, which is the number of
    worker threads of the internal pool of a `ForkJoinPool` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getParallelism()`: This method returns the desired level of parallelism established
    for a pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveThreadCount()`: This method returns the number of threads that are
    currently executing tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRunningThreadCount()`: This method returns the number of working threads
    that are not blocked in any synchronization mechanism'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueuedSubmissionCount()`: This method returns the number of tasks that
    have been submitted to a pool and haven''t started their execution yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getQueuedTaskCount()`: This method returns the number of tasks that have been
    submitted to a pool and have started their execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasQueuedSubmissions()`: This method returns a `Boolean` value indicating
    whether the pool has queued tasks that haven''t started their execution yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStealCount()`: This method returns a `long` value specifying the number
    of times a worker thread has stolen a task from another thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns a `Boolean` value indicating whether
    the fork/join pool has finished its execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in [Chapter 5](part0220.html#6HPRO0-69b77957c9a14e36a0bec5f5a1363736),
    *Fork/Join Framework*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the fork/join framework* and *Customizing tasks running in the fork/join framework*
    recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stream in Java is a sequence of elements that could be processed (mapped,
    filtered, transformed, reduced, and collected) either parallelly or sequentially
    in a pipeline of declarative operations using `lambda` expressions. It was introduced
    in Java 8 to change the way one can process enormous sets of data in a functional
    way, with lambda expressions instead of the traditional imperative way.
  prefs: []
  type: TYPE_NORMAL
- en: The `Stream` interface doesn't provide a lot of methods as other concurrency
    classes to monitor its status. Only the `peek()` method allows you to write log
    information about the elements that are being processed. In this recipe, you will
    learn how to use this method to write information about a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Main` with a `main()` method. Declare two private variables,
    namely an `AtomicInteger` variable called `counter` and a `Random` object called
    `random`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a stream of 1,000 random `double` numbers. The stream created is a sequential
    stream. You have to make it parallel using the `parallel()` method, and use the
    `peek()` method to increment the value of the `counter` variable and write a message
    in the console. Post this, use the `count()` method to count the number of elements
    in the array and store that number in an integer variable. Write the value stored
    in the `counter` variable and the value returned by the `count()` method in the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set the value of the `counter` variable to 0\. Create another stream of
    1,000 random `double` numbers. Then, convert it into a parallel stream using the
    `parallel()` method, and use the `peek()` method to increment the value of the
    `counter` variable and write a message in the console. Finally, use the `forEach()`
    method to write all the numbers and the value of the counter variable in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we used the `peek()` method in two different situations to
    count the number of elements that pass by this step of the stream and write a
    message in the console.
  prefs: []
  type: TYPE_NORMAL
- en: As described in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*, `Stream` has a source, zero or more intermediate
    operations, and a final operation. In the first case, our final operation is the
    `count()` method. This method doesn't need to process the elements to calculate
    the returned value, so the `peek()` method will never be executed. You won't see
    any of the messages of the peek method in the console, and the value of the counter
    variable will be 0.
  prefs: []
  type: TYPE_NORMAL
- en: The second case is different. The final operation is the `forEach()` method,
    and in this case, all the elements of the stream will be processed. In the console,
    you will see messages of both `peek()` and `forEach()` methods. The final value
    of the `counter` variable will be 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: The `peek()` method is an intermediate operation of a stream. Like with all
    intermediate operations, they are executed lazily, and they only process the necessary
    elements. This is the reason why it's never executed in the first case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Collecting the elements of a stream* recipes in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing effective log messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **log** system is a mechanism that allows you to write information to one
    or more destinations. A **Logger** has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One or more handlers**: A handler will determine the destination and format
    of the log messages. You can write log messages in the console, a file, or a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A name**: Usually, the name of a Logger used in a class is based on the class
    name and its package name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A level**: Log messages have different levels that indicate their importance.
    A Logger also has a level to decide what messages it is going to write. It only
    writes messages that are as important as, or more important, than its level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should use the log system because of the following two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Write as much information as you can when an exception is caught. This will
    help you localize the error and resolve it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write information about the classes and methods that the program is executing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the classes provided by the `java.util.logging`
    package to add a log system to your concurrent application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyFormatter` that extends the `java.util.logging.Formatter`
    class. Implement the abstract `format()` method. It receives a `LogRecord` object
    as a parameter and returns a `String` object with a log message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `MyLoggerFactory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private static `Handler` attribute named `handler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the public static method `getLogger()` to create the `Logger` object
    that you''re going to use to write log messages. It receives a `String` parameter
    called `name`. We synchronize this method with the `synchronized` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Get `java.util.logging.Logger` associated with the name received as a parameter
    using the `getLogger()` method of the `Logger` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Establish the log level to write all the log messages using the `setLevel()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If the handler attribute has the null value, create a new `FileHandler` object
    to write log messages in the `recipe8.log` file. Assign a `MyFormatter` object
    to this handler; assign it as a formatter using the `setFormatter()` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `Logger` object does not have a handler associated with it, assign the
    handler using the `addHandler()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the `Logger` object created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task` that implements the `Runnable` interface. It will
    be the task used to test your `Logger` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'First, declare a `Logger` object named `logger`. Initialize it using the `getLogger()`
    method of the `MyLogger` class by passing the name of this class as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a log message indicating the beginning of the execution of the method,
    using the `entering()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Sleep the thread for two seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a log message indicating the end of the execution of the method, using
    the `exiting()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `Logger` object named `logger`. Initialize it using the `getLogger()`
    method of the `MyLogger` class by passing the `Core` string as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a log message indicating the start of the execution of the main program,
    using the `entering()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Thread` array to store five threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Create five `Task` objects and five threads to execute them. Write log messages
    to indicate that you''re going to launch a new thread and that you have created
    the thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a log message to indicate that you have created the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the five threads using the `join()` method. After
    the finalization of each thread, write a log message indicating that the thread
    has finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a log message to indicate the end of the execution of the main program,
    using the `exiting()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you used the `Logger` class provided by the Java logging API
    to write log messages in a concurrent application. First of all, you implemented
    the `MyFormatter` class to assign a format to the log messages. This class extends
    the `Formatter` class that declares the abstract `format()` method. This method
    receives a `LogRecord` object with all of the information of the log message and
    returns a formatted log message. In your class, you used the following methods
    of the `LogRecord` class to obtain information about the log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getLevel()`: Returns the level of a message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMillis()`: Returns the date when a message was sent to a `Logger` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSourceClassName()`: Returns the name of a class that had sent the message
    to the Logger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSourceMessageName()`: Returns the name of the method that had sent the
    message to the Logger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMessage()`: Returns the log message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MyLogger` class implements the static method `getLogger()`. This method
    creates a `Logger` object and assigns a `Handler` object to write log messages
    of the application to the `recipe6.log` file, using the `MyFormatter` formatter.
    You create the `Logger` object with the static method `getLogger()` of the `Logger` class.
    This method returns a different object per name that is passed as a parameter.
    You only created one `Handler` object, so all the `Logger` objects will write
    their log messages in the same file. You also configured the logger to write all
    the log messages, regardless of their level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you implemented a `Task` object and a main program that writes different
    log messages in the log file. You used the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`entering()`: To write a message with the `FINER` level indicating that a method
    has started its execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exiting()`: To write a message with the `FINER` level indicating that a method
    has ended its execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log()`: To write a message with the specified level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you work with a log system, you have to take into consideration two important
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write the necessary information**: If you write too little information, the
    logger won''t be useful because it won''t fulfil its purpose. If you write a lot
    of information, you will generate large unmanageable log files; this will make
    it difficult to get the necessary information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the adequate level for the messages**: If you write high level information
    messages or low level error messages, you will confuse the user who will look
    at the log files. This will make it more difficult to know what happened in an
    error situation; alternatively, you will have too much of information making it
    difficult to know the main cause of the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other libraries that provide a log system that is more complete than
    the `java.util.logging` package, such as the `Log4j` or `slf4j` libraries. But
    the `java.util.logging` package is part of the Java API, and all its methods are
    multithread safe; therefore, we can use it in concurrent applications without
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using non-blocking thread-safe deques*, *Using blocking thread-safe deques*,
    *Using blocking thread-safe queues ordered by priority*, *Using thread-safe lists
    with delayed elements* and *Using thread-safe navigable maps *recipes in [Chapter
    7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing concurrent code with FindBugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Static code analysis tools** are a set of tools that analyze the source code
    of an application while looking for potential errors. These tools, such as Checkstyle,
    PMD, or FindBugs, have a set of predefined rules of good practices and parse the
    source code looking for violations of these rules. The objective is to find errors
    or places that cause poor performance at an early stage, before they are executed
    in production. Programming languages usually offer such tools, and Java is not
    an exception. One of the tools that helps analyze Java code is FindBugs. It''s
    an open source tool that includes a series of rules to analyze Java-concurrent
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use this tool to analyze your Java-concurrent
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start this recipe, download FindBugs from the project's web page
    ([http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)). You can
    download a standalone application or an Eclipse plugin. In this recipe, I used
    the standalone version.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, the actual version of FindBugs (3.0.1) doesn't
    include support for Java 9\. You can download a preview of the 3.1.0 version with
    support for Java 9 from [https://github.com/findbugsproject/findbugs/releases/tag/3.1.0_preview1](https://github.com/findbugsproject/findbugs/releases/tag/3.1.0_preview1).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` that extends the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `ReentrantLock` attribute named `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a constructor of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Get control of the lock, put the thread to sleep
    for 2 seconds, and free the lock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare and create a `ReentrantLock` object named `lock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Create 10 `Task` objects and 10 threads to execute the tasks. Start the threads
    by calling the `run()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Export the project as a `.jar` file. Call it `recipe7.jar`. Use the menu option
    of your IDE or the `javac` and `.jar` commands to compile and compress your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the FindBugs standalone application by running the `findbugs.bat` command
    in Windows or the `findbugs.sh` command in Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new project by clicking on the New Project option under the File menu
    in the menu bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The *FindBugs* application shows a window to configure the project. In the
    Project name field, type `Recipe07`. In the Classpath for analysis field (jar,
    ear, war, zip, or directory), add the `.jar` file with the project. In the Source
    directories field (optional; classes used when browsing found bugs), add the directory
    with the source code of the example. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Analyze button to create the new project and analyze its code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *FindBugs* application shows the result of the analysis of the code. In
    this case, it has found two bugs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on one of the bugs and you'll see the source code of the bug on the right-hand
    side panel and the description of the bug in the panel at the bottom of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result of the analysis by FindBugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The analysis has detected the following two potential bugs in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the bugs is detected in the `run()` method of the `Task` class. If an
    `InterruptedExeption` exception is thrown, the task doesn't free the lock because
    it won't execute the `unlock()` method. This will probably cause a deadlock situation
    in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other bug is detected in the `main()` method of the `Main` class because
    you called the `run()` method of a thread directly, not the `start()` method to
    begin the execution of the thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you double-click on one of the two bugs, you will see detailed information
    about it. As you have included the source code reference in the configuration
    of the project, you will also see the source code where the bug was detected.
    The following screenshot shows you an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be aware that FindBugs can only detect some problematic situations (related
    or not to concurrency code). For example, if you delete the `unlock()` call in
    the `run()` method of the `Task` class and repeat the analysis, FindBugs won't
    alert you that
  prefs: []
  type: TYPE_NORMAL
- en: you will get the lock in the task but you will never be able to free it.
  prefs: []
  type: TYPE_NORMAL
- en: Use the tools of the static code analysis as a form of assistance to improve
    the quality of your code, but do not expect it to detect all the bugs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Configuring NetBeans for debugging concurrency code* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Eclipse for debugging concurrency code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nowadays, almost every programmer, regardless of the programming language in
    use, create their applications with an IDE. They provide lots of interesting functionalities
    integrated in the same application, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Project management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic code generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic documentation generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with control version systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A debugger to test applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different wizards to create projects and elements of the applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the most helpful features of an IDE is a debugger. Using it, you can
    execute your application step by step and analyze the values of all the objects
    and variables of your program.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with Java, Eclipse is one of the most popular IDEs. It has an integrated
    debugger that allows you to test your applications. By default, when you debug
    a concurrent application and the debugger finds a breakpoint, it only stops the
    thread that has the breakpoint while it allows the rest of the threads to continue
    with their execution. In this recipe, you will learn how to change this configuration
    to help you test concurrent applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must have installed the Eclipse IDE. Open it and select a project with a
    concurrent application implemented, for example, one of the recipes implemented
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Window | Preferences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the Java option in the left-hand side menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select the Debug option. The following screenshot illustrates the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Change the value of Default suspend policy for new breakpoints from Suspend
    Thread to Suspend VM (marked in red in the screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the OK button to confirm the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the introduction of this recipe, by default, when you debug
    a concurrent Java application in Eclipse and the debug process finds a breakpoint,
    it only suspends the thread that hits the breakpoint first, but it allows other
    threads to continue with their execution. The following screenshot shows an example
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that only worker-21 is suspended (marked in red in the screenshot),
    while the rest of the threads are running. However, while debugging a concurrent
    application, if you change Default suspend policy for new breakpoints to Suspend
    VM, all the threads will suspend their execution and the debug process will hit
    a breakpoint.. The following screenshot shows an example of this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With the change, you can see that all the threads are suspended. You can continue
    debugging any thread you want. Choose the suspend policy that best suits your
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring NetBeans for debugging concurrency code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software is necessary to develop applications that work properly, meet the quality
    standards of the company, and could be easily modified in future (in limited time
    and cost as low as possible). To achieve this goal, it is essential to use an
    IDE that can integrate  several tools (compilers and debuggers) that facilitate
    the development of applications under one common interface.
  prefs: []
  type: TYPE_NORMAL
- en: If you work with Java, NetBeans is one of the most popular IDEs. It has an integrated
    debugger that allows you to test your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to change the configuration of the Netbeans
    debugger to help you test concurrent applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have the NetBeans IDE installed. Open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task1` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `Lock` attributes, named `lock1` and `lock2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. First, get control of the `lock1` object using
    the `lock()` method and write aa message in the console indicating that you have
    got it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, get control of `lock2` using the `lock()` method and write a message
    in the console indicating that you have got it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, release the two lock objects-first the `lock2` object and then the
    `lock1` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task2` and specify that it implements the `Runnable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `Lock` attributes, named `lock1` and `lock2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. First, get control of the `lock2` object using
    the `lock()` method and write a message in the console indicating that you have
    got it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, get control of `lock1` using the `lock()` method and write a message
    in the console indicating that you have got it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, release the two lock objects-first `lock1` and then `lock2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two lock objects named `lock1` and `lock2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Task1` object named `task1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Task2` object named `task2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute both the tasks using two threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'When the two tasks finish their execution, write a message in the console every
    500 milliseconds. Use the `isAlive()` method to check whether a thread has finished
    its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Add a breakpoint in the first call to the `printf()` method of the `run()` method
    of the `Task1` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Debug the program. You will see the Debugging window in the top left-hand side
    corner of the main NetBeans window. The next screenshot illustrates the window
    with the thread that executes the `Task1` object. The thread is waiting in the
    breakpoint. The other threads of the application are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Pause the execution of the main thread. Select the thread, right-click on it,
    and select the Suspend option. The following screenshot shows the new appearance
    of the Debugging window. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Resume the two paused threads. Select each thread, right-click on them, and
    select the Resume option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While debugging a concurrent application using NetBeans, when the debugger hits
    a breakpoint, it suspends the thread that hit the breakpoint and shows the Debugging
    window in the top left-hand side corner with the threads that are currently running.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the window to pause or resume the threads that are currently running,
    using the Pause or Resume options. You can also see the values of the variables
    or attributes of the threads using the Variables tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'NetBeans also includes a deadlock detector. When you select the Check for Deadlock
    option in the Debug menu, NetBeans performs an analysis of the application that
    you''re debugging to determine whether there''s a deadlock situation. This example
    presents a clear deadlock. The first thread gets `lock1` first and then `lock2`.
    The second thread gets the locks in reverse manner. The breakpoint inserted provokes
    the deadlock, but if you use the NetBeans deadlock detector, you''ll not find
    anything. Therefore, this option should be used with caution. Change the locks
    used in both the tasks by the `synchronized` keyword and debug the program again.
    The code of `Task1` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The code of the `Task2` class will be analogous to this, but it changes the
    order of the locks. If you debug the example again, you will obtain a deadlock
    one more time. However, in this case, it''s detected by the deadlock detector,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are options to control the debugger. Select Options from the Tools menu.
    Then, select the Miscellaneous option and the Java Debugger tab. The following
    screenshot illustrates this window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two options in the window that control the behavior described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'New breakpoints suspend: With this option, you can configure the behavior of
    NetBeans, which finds a breakpoint in a thread. You can suspend only that thread
    that has a breakpoint or all the threads of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Steps resume: With this option, you can configure the behavior of NetBeans
    when you resume a thread. You can resume only the current thread or all the threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the options have been marked in the screenshot presented earlier.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Configuring Eclipse for debugging concurrency code* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing concurrency code with MultithreadedTC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MultithreadedTC` is a Java library for testing concurrent applications. Its
    main objective is to solve the problem of concurrent applications being non-deterministic.
    You can''t control the order of execution of the different threads that form the
    application. For this purpose, it includes an internal **metronome**. These testing
    threads are implemented as methods of a class.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `MultithreadedTC` library to implement
    a test for `LinkedTransferQueue`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download the MultithreadedTC library from [https://code.google.com/archive/p/multithreadedtc/](https://code.google.com/archive/p/multithreadedtc/)
    and the JUnit library, version 4.10, from [http://junit.org/junit4/](http://junit.org/junit4/).
    Add the `junit-4.10.jar` and `MultithreadedTC-1.01.jar` files to the libraries
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `ProducerConsumerTest` that extends the `MultithreadedTestCase`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `LinkedTransferQueue` attribute parameterized by the `String`
    class named `queue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `initialize()` method. This method won''t receive any parameters
    and will return no value. It will call the `initialize()` method of its parent
    class and then initialize the queue attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `thread1()` method. It will implement the logic of the first
    consumer. Call the `take()` method of the queue and then write the returned value
    in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `thread2()` method. It will implement the logic of the second
    consumer. First wait until the first thread has slept in the `take()` method.
    To put the thread to sleep, use the `waitForTick()` method. Then, call the `take()`
    method of the queue and write the returned value in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `thread3()` method. It will implement the logic of a producer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First wait until the two consumers are blocked in the `take()` method; block
    this method using the `waitForTick()` method twice. Then, call the `put()` method
    of the queue to insert two strings in the queue:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the `finish()` method. Write a message in the console to
    indicate that the test has finished its execution. Check that the two events have
    been consumed (so the size of the queue is `0`) using the `assertEquals()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the main class of the example by creating a class named `Main`
    with a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ProducerConsumerTest` object named `test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the test using the `runOnce()` method of the `TestFramework` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented a test for the `LinkedTransferQueue` class using
    the `MultithreadedTC` library. You can implement a test in any concurrent application
    or class using this library and its metronome. In the example, you implemented
    the classical producer/consumer problem with two consumers and a producer. You
    wanted to test that the first `String` object introduced in the buffer is consumed
    by the first consumer that arrives at the buffer, and the second `String` object
    introduced in the buffer is consumed by the second consumer that arrives at the
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The `MultithreadedTC` library is based on the JUnit library, which is the most
    often used library to implement unit tests in Java. To implement a basic test
    using the `MultithreadedTC` library, you have to extend the `MultithreadedTestCase`
    class. This class extends the `junit.framework.AssertJUnit` class that includes
    all the methods to check the results of the test. It doesn't extend the `junit.framework.TestCase`
    class, so you can't integrate MultithreadedTC tests with other JUnit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialize()`: The implementation of this method is optional. It''s executed
    when you start the test, so you can use it to initialize objects that are using
    the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finish()`: The implementation of this method is optional. It''s executed when
    the test has finished. You can use it to close or release resources used during
    the test or to check the results of the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that implement the test: These methods have the main logic of the test
    you implement. They have to start with the `thread` keyword, followed by a string,
    for example, `thread1()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To control the order of execution of threads, you used the `waitForTick()` method.
    This method receives an integer value as a parameter and puts the thread that
    is executing the method to sleep until all the threads that are running in the
    test are blocked. When they are blocked, the `MultithreadedTC` library resumes
    the threads that are blocked by a call to the `waitForTick()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The integer you pass as a parameter of the `waitForTick()` method is used to
    control the order of execution. The metronome of the `MultithreadedTC` library
    has an internal counter. When all the threads are blocked, the library increments
    this counter to the next number specified in the `waitForTick()` calls that are
    blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, when the `MultithreadedTC` library has to execute a test, first
    it executes the `initialize()` method. Then it creates a thread per method that
    starts with the `thread` keyword (in your example, the methods `thread1()`, `thread2()`,
    and `thread3()`). When all the threads have finished their execution, it executes
    the `finish()` method. To execute the test, you used the `runOnce()` method of
    the `TestFramework` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the `MultithreadedTC` library detects that all the threads of the test are
    blocked except in the `waitForTick()` method, the test is declared to be in a
    deadlock state and a `java.lang.IllegalStateException` exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Analyzing concurrent code with FindBugs* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring with JConsole
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JConsole** is a monitoring tool that follows the JMX specification that allows
    you to get information about the execution of an application as the number of
    threads, memory use, or class loading. It is included with the JDK and it can
    be used to monitor local or remote applications. In this recipe, you will learn
    how to use this tool to monitor a simple concurrent application.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task` and specify the `Runnable` interface. Implement
    the `run()` method to write the message in the console during 100 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Main` class with the `main()` method. Create 10 `Task` objects
    to create 10 threads. Start them and wait for their finalization using the `join()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a console window and execute the `JConsole` application. It''s included
    in the bin directory of the JDK-9 installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we implemented a very simple example: running 10 threads for
    100 seconds. These are threads that write messages in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute JConsole, you will see a window that shows all the Java applications
    that are running in your system. You can choose the one you want to monitor. The
    window will be similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we select our sample app and click on the Connect button. Then,
    you will be asked to establish an insecure connection with the application, with
    a dialog similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Insecure connection button. JConsole will show you information
    about your application using six tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: The Overview tab provides an overview of memory use, the number of threads running
    in the application, the number of objects created, and CPU usage of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Memory tab shows the amount of memory used by the application. It has a
    combo where you can select the type of memory you want to monitor (heap, non-heap,
    or pools).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Threads tab shows you information about the number of threads in the application
    and detailed information about each thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Classes tab shows you information about the number of objects loaded in
    the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VW Summary tab provides a summary of the JVM running the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MBeans tab shows you information about the managed beans of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The threads tab is similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It has two different parts. In the upper part, you have real-time information
    about the **Peak** number of threads (with a red line) and the number of **Live
    Threads** (with a blue line). In the lower part, we have a list of active threads.
    When you select one of these threads, you will see detailed information about
    that thread, including its status and the actual stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use other applications to monitor applications that run Java. For example,
    you can use VisualVM included with the JDK. You can obtain necessary information
    about visualvm at [https://visualvm.github.io](https://visualvm.github.io).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Testing concurrency code with MultithreadedTC* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
