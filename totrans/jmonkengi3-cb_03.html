<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;World Building"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. World Building</h1></div></div></div><p>In this chapter, we'll go through some of the fundamentals behind generating a code-based world and its lighting before we go beyond the basics and discuss more advanced techniques.</p><p>This chapter contains the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using noise to generate a terrain</li><li class="listitem" style="list-style-type: disc">Lighting your world and providing it with dynamic lights</li><li class="listitem" style="list-style-type: disc">Deforming a terrain in real time</li><li class="listitem" style="list-style-type: disc">Automating trees' distribution</li><li class="listitem" style="list-style-type: disc">Endless worlds and infinite space</li><li class="listitem" style="list-style-type: disc">Flowing water with cellular automata</li><li class="listitem" style="list-style-type: disc">The essentials of a cube-based world</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Introduction</h1></div></div></div><p>In <a class="link" href="ch01.html" title="Chapter 1. SDK Game Development Hub">Chapter 1</a>, <span class="emphasis"><em>SDK Game Development Hub</em></span>, we used Terrain Editor to manually create a heightmap and Scene Composer to put things together into scenes. Those were the two ways of creating worlds in jMonkeyEngine. In this chapter, we'll look into creating worlds using code or procedural generation. This can often be very quickly set up, but getting it right (and performant) can be tricky. To achieve this, we will make use of techniques such as custom meshes and batching. Batching is a method of taking several geometries using the same <code class="literal">Material</code> instance and creating one mesh out of all their meshes. This can significantly improve the performance of the application.</p></div></div>
<div class="section" title="Using noise to generate a terrain"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Using noise to generate a terrain</h1></div></div></div><p>While <a id="id201" class="indexterm"/>noise is<a id="id202" class="indexterm"/> unwanted in many occasions, it is a great tool for procedural generation and has many uses. In this recipe, we'll explore jMonkeyEngine's <code class="literal">FractalSum</code> class and generate an image based on the output. This can be used as a heightmap for a terrain, but we are not limited by that. With some tweaking, we could get a basis to cover a forest or city.</p><div class="mediaobject"><img src="graphics/6478OS_03_01.jpg" alt="Using noise to generate a terrain"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec79"/>Getting ready</h2></div></div></div><p>This<a id="id203" class="indexterm"/> recipe relies on a way to output an image. Either <a id="id204" class="indexterm"/>use your own method to do this or refer to the <span class="emphasis"><em>The ImageGenerator class</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Fragments</em></span>, which provides an example of how to do it.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec80"/>How to do it...</h2></div></div></div><p>To generate <a id="id205" class="indexterm"/>a heightmap, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will start by creating a class called <code class="literal">NoiseMapGenerator</code>.</li><li class="listitem">In its constructor, define a new <code class="literal">FractalSum</code> instance and store it in a field called <code class="literal">fractalSum</code>.</li><li class="listitem">Next, create<a id="id206" class="indexterm"/> a public method called <code class="literal">generateNoiseMap</code> that takes an integer parameter called <code class="literal">size</code>, a float parameter called <code class="literal">frequency</code>, and an integer parameter called <code class="literal">octaves</code> as inputs.</li><li class="listitem">Inside the method, configure <code class="literal">fractalSum</code> with some of the values and set the amplitude to <code class="literal">0.5f</code> as follows:<div class="informalexample"><pre class="programlisting">fractalSum.setFrequency(frequency);
fractalSum.setAmplitude(0.5f);
fractalSum.setOctaves(octaves);</pre></div></li><li class="listitem">Then, define a 2D float array called <code class="literal">terrain</code>. Its dimension should be [size] x [size].</li><li class="listitem">Now, create a double <code class="literal">for</code> loop statement and parse through the size of both dimensions. Inside the loop, we get the value from <code class="literal">fractalSum</code>, which is based on your <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y </em></span>coordinates; add <code class="literal">0.5f</code> to the value. Clamp it to get a value between <code class="literal">0f</code> and <code class="literal">1f</code> and set the value in the terrain array as follows:<div class="informalexample"><pre class="programlisting">for(int y = 0; y &lt; size; y++){
  for(int x = 0; x &lt; size; x++){
    float value = fractalSum.value(x, 0, y) + 0.5f;
    value = FastMath.clamp(value, 0f, 1f);
    terrain[x][y] = value;
  }
}</pre></div></li><li class="listitem">When<a id="id207" class="indexterm"/> you're done, call the <code class="literal">ImageGenerator</code> class to create the PNG image for us as follows:<div class="informalexample"><pre class="programlisting">ImageGenerator.generateImage(terrain);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec81"/>How it works...</h2></div></div></div><p>With<a id="id208" class="indexterm"/> this simple implementation, and by using the supplied <code class="literal">ImageGenerator</code> class, we have the basics for a heightmap. We can see the result in <a id="id209" class="indexterm"/>our <code class="literal">Projects</code> folder under <code class="literal">assets/Textures/heightmap.png</code>. It's an image that shifts smoothly between bright and dark areas; here, bright areas represent a high terrain and dark areas, a low terrain. Bright pixels have values that are close to 1, whereas dark pixels have values close to 0. Normally, noise outputs values between -1 and 1. This is why we change the amplitude to 0.5f so that it yields a range between -0.5 and 0.5, and then we add 0.5 to the result.</p><p>A noticeable problem is that no matter how much we change the speed and frequency of the noise, the same kind of rolling hills landscape will appear, only in different scales. By changing the octaves' value, we will generate noise in several iterations with decreasing amplitude. The value of each pixel for each iteration is multiplied with the previous one. The result is <a id="id210" class="indexterm"/>called fractal noise. Using octaves is a way of adding detail by iterating over the result with different frequencies. For each iteration, the frequency is doubled and the amplitude is halved.</p><p>Frequency<a id="id211" class="indexterm"/> can be thought of as a scale value where a higher frequency will generate more and smaller features. Having a higher frequency on its own will make peaks and valleys occur more frequently.</p><p>A normalization process is not strictly needed for a heightmap, unless we want to save it as an image. Also, if we were generating a large number of heightmaps (for example, during the runtime for a game), we would not want to normalize the terrain based on a particular heightmap's minimum and maximum values or we would end up with very similar and hilly landscapes.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec82"/>There's more...</h2></div></div></div><p>Now that we have generated a heightmap and exported it to an image, we can actually use it as a base in Terrain Editor. The process is similar to the one where we created a terrain for our scene in <a class="link" href="ch01.html" title="Chapter 1. SDK Game Development Hub">Chapter 1</a>, <span class="emphasis"><em>SDK Game Development Hub</em></span>.</p><p>After <a id="id212" class="indexterm"/>creating a new scene (by all means, we can use an<a id="id213" class="indexterm"/> existing scene as well) and opening it, we can right-click on the main node in the <span class="strong"><strong>SceneExplorer</strong></span> window and select <span class="strong"><strong>Add Spatial..</strong></span> and then select <span class="strong"><strong>Terrain..</strong></span>.</p><p>It's important that we select the same total size as that of the pixels of our image. Then, in the <span class="strong"><strong>Heightmap</strong></span> screen, we choose <span class="strong"><strong>Image Based</strong></span> from the <span class="strong"><strong>HeightMap</strong></span> drop-down menu and select our image.</p><p>The <span class="strong"><strong>Roughness</strong></span> slider will <a id="id214" class="indexterm"/>define how much the heightmap will be smoothed out before it is added. A higher smoothness will remove finer details, and this is a must if we want to have characters that will run or drive on top of it.</p><p>The <span class="strong"><strong>Height Scale</strong></span> option<a id="id215" class="indexterm"/> will define the maximum altitude that the heightmap can have and scale it accordingly.</p></div></div>
<div class="section" title="Lighting your world and providing it with dynamic lights"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Lighting your world and providing it with dynamic lights</h1></div></div></div><p>This recipe will mostly be theories on different lighting types, but we'll also explore a way to easily <a id="id216" class="indexterm"/>control the movement of lights.</p><p>The four <a id="id217" class="indexterm"/>main types of lights that we can use to light up our world are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ambient Light</strong></span>: This lights up everything in the scene evenly. It's good for avoiding<a id="id218" class="indexterm"/> anything to be in a pitch-black state, but it <a id="id219" class="indexterm"/>doesn't create any shadows or nuances. Adding a too bright ambient light will give the world a bland look, while giving it a touch of color can set the mood.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Directional Light</strong></span>: This<a id="id220" class="indexterm"/> shines from a particular<a id="id221" class="indexterm"/> direction with perfectly parallel rays and without any falloff. This is usually used to simulate a sun, a bright source of light located far away.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Point Light</strong></span>: This shines equally in every direction but with a falloff, meaning <a id="id222" class="indexterm"/>this will eventually stop illuminating the <a id="id223" class="indexterm"/>surroundings. Usually, this forms most of the light sources in a game scene.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Spot Light</strong></span>: This is exactly as it sounds. This produces a cone-shaped light in a specific <a id="id224" class="indexterm"/>direction from a specific location, and its light<a id="id225" class="indexterm"/> will eventually fall off. It has more settings than its sibling light types. Technically, it is more advanced than point lights and requires additional calculations in the shader to see what it illuminates.</li></ul></div><p>A spotlight with the same <code class="literal">spotInnerAngle</code> and <code class="literal">spotOuterAngle</code> parameters will have a light cone that looks like this:</p><div class="mediaobject"><img src="graphics/6478OS_03_03.jpg" alt="Lighting your world and providing it with dynamic lights"/></div><p>The<a id="id226" class="indexterm"/> <code class="literal">spotInnerAngle</code> and <code class="literal">spotOuterAngle</code> parameters <a id="id227" class="indexterm"/>define the size of the light cone that spotlight <a id="id228" class="indexterm"/>produces and both are set in radians. The <code class="literal">spotInnerAngle</code> parameter defines how far out the cone will shine at its maximum radiance. The <code class="literal">spotOuterAngle</code> parameter then defines how far the total extent of the radiance should be before it's been completely extinguished. Having a greater value for the <code class="literal">spotOuterAngle</code> parameter will produce a softer edge on the spotlight. A spotlight with a small <code class="literal">spotInnerAngle</code> parameter and a high <code class="literal">spotOuterAngle</code> parameter will have softer edges, as shown in the following image:</p><div class="mediaobject"><img src="graphics/6478OS_03_02.jpg" alt="Lighting your world and providing it with dynamic lights"/></div><p>To ensure an object is affected by the lights in a scene, it must have a <code class="literal">Material</code> class that supports it. For most game objects, the default choice is the <span class="strong"><strong>Lighting</strong></span> material. It supports a variety of lighting types from per pixel to lightmaps and vertex lighting. The latter<a id="id229" class="indexterm"/> two are optional but have their uses.</p><p>A lightmap is<a id="id230" class="indexterm"/> essentially an extra texture where lighting has been pre-rendered. Its resolution can rarely match real-time lighting, but from another perspective, it is very fast since lighting doesn't have to be calculated at runtime; also, it can be used for static scenes.</p><p>Normally, lighting is calculated on a per-pixel basis. This means that for each pixel visible on the screen, the processor has to calculate how it is affected by the available light sources. It is fairly expensive and even more so with many light sources, but it produces a more realistic result. Vertex lighting instead means that lighting is calculated for each vertex on<a id="id231" class="indexterm"/> a model. For low poly models, this is much faster although not as detailed. The quality will suffer noticeably when it is near the object, but it can give good enough results for objects some distance away.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec83"/>How to do it...</h2></div></div></div><p>Now that we have the basics covered, let's explore a pattern that allows us to move lights using objects in the scene graph:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create a new <code class="literal">PointLight</code> class called <code class="literal">pointLight</code> and set <code class="literal">radius</code> to <code class="literal">40</code>.</li><li class="listitem">Then, call <code class="literal">rootNode.addLight(pointLight)</code> to add it to the scene graph.</li><li class="listitem">Now, create a new <code class="literal">CameraNode</code> called <code class="literal">camNode</code> and then call <code class="literal">camNode.setControlDir(CameraControl.ControlDirection.CameraToSpatial);</code> before attaching it to the <code class="literal">rootNode</code>.</li><li class="listitem">Next, create a new <code class="literal">LightControl</code> called <code class="literal">lightControl</code>, supplying <code class="literal">pointLight</code> to it to indicate that this is the light to control, as shown in the following code:<div class="informalexample"><pre class="programlisting">LightControl lightControl = new LightControl(pointLight);</pre></div></li><li class="listitem">We set <code class="literal">controlDir</code> to be <code class="literal">LightControl.ControlDirection.SpatialToLight</code>. This means that the Spatial <code class="literal">camNode</code> will control the light's position:<div class="informalexample"><pre class="programlisting">lightControl.setControlDir(LightControl.ControlDirection.SpatialToLight);</pre></div></li><li class="listitem">Finally, we add <code class="literal">lightControl</code> to <code class="literal">camNode</code>.</li><li class="listitem">To test this out, we can load <span class="strong"><strong>Sponza</strong></span> (Models/Sponza/Sponza.j3o) from the jMonkeyEngine's <code class="literal">test-data</code> library and apply the <span class="strong"><strong>Lighting</strong></span> material to it.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec84"/>How it works...</h2></div></div></div><p>Lights<a id="id232" class="indexterm"/> are not <code class="literal">Spatials</code> in the scene graph, and it can be tricky to move them around. It can be added to nodes but then it will only illuminate the node (and its children) that it is added to. The <code class="literal">LightControl</code> class bridges the gap <a id="id233" class="indexterm"/>since it can be added as a control to <code class="literal">Spatial</code>, and it controls the position (and direction of a light). In this recipe, we used it so that the light will follow the camera around using a <code class="literal">CamNode</code>, but it works just as well for any other <code class="literal">spatial</code>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec85"/>There's more…</h2></div></div></div><p>We touched on <span class="strong"><strong>Ambient Light</strong></span> and <span class="strong"><strong>Directional Light</strong></span> in the <span class="emphasis"><em>Adding a sky box and lighting</em></span> recipe from <a class="link" href="ch01.html" title="Chapter 1. SDK Game Development Hub">Chapter 1</a>, <span class="emphasis"><em>SDK Game Development Hub</em></span>. In the <span class="emphasis"><em>Creating a dynamic sky box with a moving sun</em></span> recipe from <a class="link" href="ch09.html" title="Chapter 9. Taking Our Game to the Next Level">Chapter 9</a>, <span class="emphasis"><em>Taking Our Game to the Next Level</em></span>, we create <span class="strong"><strong>Directional Light</strong></span> to simulate a day and night cycle.</p></div></div>
<div class="section" title="Deforming a terrain in real time"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Deforming a terrain in real time</h1></div></div></div><p>A deformable<a id="id234" class="indexterm"/> terrain is something that can have a serious effect on the gameplay, or it can simply be a cosmetic bonus. It can be used for impact craters or games that require excavation.</p><p>We'll base the deformation around the <code class="literal">Control</code> class pattern as this allows us to offset the code<a id="id235" class="indexterm"/> in a manageable and reusable way. The recipe will trigger the deformation based on a mouse click, and it will use a ray to detect the collision point.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec86"/>Getting ready</h2></div></div></div><p>To get up and running quickly, unless there already is an application to apply this to, <code class="literal">TestTerrain.java</code> from the jMonkeyEngine's test cases will provide a good start for what we need. This example will expand on the code provided in that application, but it should work perfectly well with any terrain-based application.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec87"/>How to do it...</h2></div></div></div><p>With a<a id="id236" class="indexterm"/> base application already set up, we can get straight to the creation of the Control pattern:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class called <code class="literal">DeformableControl</code> that extends <code class="literal">AbstractControl</code>. It needs one private terrain field called <code class="literal">terrain</code>.</li><li class="listitem">Override the <code class="literal">setSpatial</code> method and cast <code class="literal">Spatial</code> to fit your terrain field; use <code class="literal">terrain = (Terrain) spatial;</code> to do this.</li><li class="listitem">Create a <a id="id237" class="indexterm"/>method called <code class="literal">deform</code> that takes the 2D location, the radius of the deformation, and the force as an input. Also, declare two lists that we'll use in the <code class="literal">heightPoints</code> and <code class="literal">heightValues</code> methods, as follows:<div class="informalexample"><pre class="programlisting">public void deform(Vector2f location, int radius, float force) {
  List&lt;Vector2f&gt; heightPoints = new ArrayList&lt;Vector2f&gt;();
  List&lt;Float&gt; heightValues = new ArrayList&lt;Float&gt;();</pre></div></li><li class="listitem">Now, we should create a nested <code class="literal">for</code> loop statement where we can iterate from <code class="literal">-radius</code> to <code class="literal">+radius</code> in both <code class="literal">x</code> and <code class="literal">y</code> (<code class="literal">z</code> to be correct). See how far from the center the point is and calculate the height to change at that location. The decrease of the force of the impact will be proportional to how far out it is from the center. Then, save the point in the <code class="literal">heightPoints</code> list and the new height in the <code class="literal">heightValues</code> list as follows:<div class="informalexample"><pre class="programlisting">for(int x = -radius; x &lt; radius; x++){
  for(int y = -radius; y &lt; radius; y++){
    Vector2f terrainPoint = new Vector2f(location.x + x, location.y + y);
    float distance = location.distance(terrainPoint);
    if(distance &lt; radius){
      float impact = force * (1 - distance / radius) ;
      float height = terrain.getHeight(terrainPoint);
      heightPoints.add(terrainPoint);
      heightValues.add(Math.max(-impact, -height));
    }
  }
}</pre></div></li><li class="listitem">To wrap up the method, we need to apply the new heights. First, unlock the terrain and then lock it again as follows:<div class="informalexample"><pre class="programlisting">terrain.setLocked(false);
terrain.adjustHeight(heightPoints, heightValues);
terrain.setLocked(true);</pre></div></li><li class="listitem">Since we<a id="id238" class="indexterm"/> normally work with 3D vectors rather than 2D vectors, it can be a good idea to also create a convenience method called <code class="literal">deform</code>, which takes <code class="literal">Vector3f</code> as the input. It converts this input to <code class="literal">Vector2f</code> and in turn calls the other deform method as follows:<div class="informalexample"><pre class="programlisting">public void deform(Vector3f location, int radius, float force){
  Vector2f pos2D = new Vector2f((int)location.x, (int)location.z);
  deform(pos2D, radius, force);
}</pre></div></li><li class="listitem">Now, trigger the deformation from a method in our application. Firstly, it should create a new <code class="literal">ray</code> instance that originates from the camera, as shown in the following code:<div class="informalexample"><pre class="programlisting">Ray ray = new Ray(cam.getLocation(), cam.getDirection());</pre></div></li><li class="listitem">Next, create a new <code class="literal">CollisionsResults</code> object and check whether the ray intersects<a id="id239" class="indexterm"/> the terrain. If there is a collision, call <code class="literal">deform</code> on the terrain's <code class="literal">DeformableControl</code> object by supplying the <code class="literal">contactPoint</code> parameter of the collision as follows:<div class="informalexample"><pre class="programlisting">CollisionResults cr = new CollisionResults();
terrain.collideWith(ray, cr);
CollisionResult collision = cr.getClosestCollision();
if(collision != null){
  terrain.getControl(DeformableControl.class).deform(coll.getContactPoint(), 30, 30f);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec88"/>How it works...</h2></div></div></div><p>When deforming the terrain, we collect all the points we want to modify and the new heights in lists; then, we collectively update the terrain based on them. There is an <code class="literal">adjustHeight</code> method<a id="id240" class="indexterm"/> to update a single point as well, but it is assumed that it's faster using a list.</p><p>Locking the terrain means faster rendering. Whether to lock the terrain or not depends on the implementation. If it is a terrain that is changed with every frame, it probably doesn't need to be locked. On the other hand, if it changes only occasionally, it should probably be locked.</p><p>The formula <a id="id241" class="indexterm"/>that is used to calculate the change in height is <span class="emphasis"><em>deltaHeight = force * (1 - distance / radius)</em></span>. This means that the change in height will be highest when it is closest to the center; it will then fall off linearly as the distance increases and we get closer to the edge of the radius. A variation worth exploring is to use the root with <span class="emphasis"><em>deltaHeight = force * FastMath.sqrt(1 - distance / radius)</em></span> instead. This will provide a rounder shape to the terrain.</p></div></div>
<div class="section" title="Automating trees' distribution"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Automating trees' distribution</h1></div></div></div><p>Placing <a id="id242" class="indexterm"/>trees and bushes in an editor is fine for many types of games. There are many cases where you need objects to be in a very specific spot. When it comes to large-scale outdoor games, you might want to have a way of placing common objects in an automatic way, at least as a base. An artist or designer might then move items around to suit the needs of the game.</p><p>In this recipe, we'll create one such way that places trees using noise. Once the base is in, we'll take a look at how the pattern can be varied with different settings.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec89"/>How to do it...</h2></div></div></div><p>To produce automatic trees' distribution, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We get right to the center of the things. Create a new class called <code class="literal">TreeControl</code> that extends <code class="literal">AbstractControl</code>.</li><li class="listitem">Add a <code class="literal">TerrainQuad</code> field called <code class="literal">terrain</code>, a <code class="literal">FractalSum</code> field called <code class="literal">fractalSum</code>, a <code class="literal">Spatial</code> field called <code class="literal">treeModel</code>, and a <code class="literal">BatchNode</code> field called <code class="literal">treeNode</code>.</li><li class="listitem">Override the <code class="literal">setSpatial</code> method. Here, we declare <code class="literal">treeNode</code>.</li><li class="listitem">Then, assuming that the supplied <code class="literal">Spatial</code> is a <code class="literal">Node</code> class, parse its children looking for a <code class="literal">Spatial</code> that is an instance of <code class="literal">TerrainQuad</code>. Once found, set it to <code class="literal">terrain</code> as follows:<div class="informalexample"><pre class="programlisting">for(Spatial s: ((Node)spatial).getChildren()){
  if(s instanceof TerrainQuad){
    this.terrain = (TerrainQuad) s;</pre></div></li><li class="listitem">Using terrain's <code class="literal">terrainSize</code>, create a nested <code class="literal">for</code> loop statement that parses from its negative height and width to its positive.</li><li class="listitem">Inside this loop, grab a value from the <code class="literal">fractalSum</code> class based on the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates. Then, look for the corresponding terrain height at that location as follows:<div class="informalexample"><pre class="programlisting">float value = fractalSum.value(x, 0, y);
float terrainHeight = terrain.getHeight(new Vector2f(x, y)); </pre></div></li><li class="listitem">Now, we need to decide how many trees we want. The <code class="literal">FractalSum</code> class generates <a id="id243" class="indexterm"/>a value between -1 and 1. Start by saying that any value above 0.5 should generate a tree and create an <code class="literal">if</code> statement accordingly.</li><li class="listitem">If this is fulfilled, start by cloning <code class="literal">treeModel</code>. Set its <code class="literal">localTranslation</code> to the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates and the current <code class="literal">terrainHeight</code> field before attaching it to the <code class="literal">treeNode</code> field:<div class="informalexample"><pre class="programlisting">Spatial treeClone = treeModel.clone();
Vector3f location = new Vector3f((x), terrainHeight, (y));
treeClone.setLocalTranslation(location);
treeNode.attachChild(treeClone);</pre></div></li><li class="listitem">After <a id="id244" class="indexterm"/>parsing the whole terrain, tell the <code class="literal">treeNode</code> field to batch its contents to optimize the performance and then attach it to the <a id="id245" class="indexterm"/>supplied <code class="literal">Spatial</code>.</li><li class="listitem">Now, create an application class to test this. It's recommended that you use a test case such as <code class="literal">TestTerrainAdvanced</code> to get a start.</li><li class="listitem">Create a new <code class="literal">Node</code> class called <code class="literal">worldNode</code>, which we attach to <code class="literal">rootNode</code> and then attach the terrain to.</li><li class="listitem">Then, create a new <code class="literal">TreeControl</code> class and load and set a suitable model that we can use as <code class="literal">treeModel</code>.</li><li class="listitem">Finally, add the <code class="literal">TreeControl</code> class to <code class="literal">worldNode</code>.</li></ol></div><p>After running the application, we will see trees spread out across the terrain—in valleys as well as on top of the mountains. Depending on the environment, trees might not grow on mountains. If we don't want this, we can add a simple check in the <code class="literal">TreeControl</code> class. By adding a field called <code class="literal">treeLimit</code>, we <a id="id246" class="indexterm"/>can clamp the growth of the tree above a certain height; also, make sure the <code class="literal">terrainHeight</code> field is lower than the value supplied from <code class="literal">fractalSum</code>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec90"/>How it works...</h2></div></div></div><p>In this example, we let the noise do most of the work for us. All we did was parse through the terrain, and at regular intervals, check whether the noise value at that point indicated whether a tree should be placed.</p><p>The noise provides an almost endless amount of variation to our distribution of vegetation and an equally endless amount of tweaking possibilities.</p><p>The drawback of using these automatic generation techniques is that we don't have proper control over<a id="id247" class="indexterm"/> them, and changing a value ever so slightly might have a large impact on the terrain. Also, even if the generation process is cheap and can be repeated deterministically, we will have to start storing the data as soon as we want to modify it in any way.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec91"/>There's more...</h2></div></div></div><p>With the current settings, the example distributes trees across a landscape in a seemingly random pattern. At first glance, it might look natural but trees rarely are so evenly distributed as this. Outside of a forest, you will usually find trees clumped together. We can easily achieve this with noise by changing the frequency. The following examples show how <a id="id248" class="indexterm"/>changing the frequency can change the pattern:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A frequency of 0.5 produces a very noisy and fairly uniform pattern, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/6478OS_03_04.jpg" alt="There's more..."/></div></li><li class="listitem" style="list-style-type: disc">With a frequency of 0.1, we can distinguish different patterns as follows:<div class="mediaobject"><img src="graphics/6478OS_03_05.jpg" alt="There's more..."/></div></li><li class="listitem" style="list-style-type: disc">A frequency of 0.02 yields even less but larger clumps of vegetation as follows:<div class="mediaobject"><img src="graphics/6478OS_03_06.jpg" alt="There's more..."/></div></li></ul></div></div></div>
<div class="section" title="Endless worlds and infinite space"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Endless worlds and infinite space</h1></div></div></div><p>There's really no such thing as endless or infinite in computer-generated worlds. Sooner or later, you're going to hit one limit or the other. However, there are some techniques that will get you further than others. The normal approach when creating a game is to move the player around the game world. Those who have tried to, for example, make a space exploration game in this way have noticed that pretty soon problems with regards to float numbers appear. This is because float values are not evenly spaced. As their values increase, their precision decreases. Using doubles rather than floats will only delay what's inevitable.</p><p>If you can't even have a solar system as a human-scaled game world, how can you then have a whole galaxy? As an old saying goes, "If Mohammed won't come to the mountain, the mountain must come to Mohammed." That is exactly the solution to our first problem! By making the game world move around the player, we ensure that the precision remains high. This is great for large-scale game worlds. The drawback is that it requires a different architecture. Switching how the game world is generated or loaded during the mid-development stage can be a huge task. It's better to decide this during the design phase.</p><p>Another problem is the sheer size of the worlds. You can't simply store all the terrain-based game world of a decent size in the memory at once. We can solve this problem by loading world data on demand and throwing it away when we don't need it any more. This recipe will use a simple method to generate the world on demand, but the principle can be applied to other methods, such as generating a heightmap or loading the world from a storage device.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec92"/>How to do it...</h2></div></div></div><p>Dynamic<a id="id249" class="indexterm"/> world loading can be created with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class called <code class="literal">EndlessWorldControl</code>. It should extend <code class="literal">AbstractControl</code> and implement <code class="literal">ActionListener</code>.</li><li class="listitem">We need to add a couple of fields to it as well. First of all, we need to keep track of the application's camera and store it in a parameter called <code class="literal">cam</code>. The class also requires a <code class="literal">Geometry</code> parameter called <code class="literal">currentTile</code> to represent the currently centered game area. A <code class="literal">Material</code> parameter called <code class="literal">material</code> will be used on the geometries <a id="id250" class="indexterm"/>and a <code class="literal">HashMap&lt;Vector2f, Geometry&gt;</code> parameter called <code class="literal">cachedTiled</code> will store the entire currently active game world.</li><li class="listitem">The class implements <code class="literal">ActionListener</code> and will handle movements based on user input. To do this, add four Booleans as well: <code class="literal">moveForward</code>, <code class="literal">moveBackward</code>, <code class="literal">moveLeft</code>, and <code class="literal">moveRight</code>.</li><li class="listitem">In the<a id="id251" class="indexterm"/> <code class="literal">onAction</code> method, add the following code to set the Booleans based on the input:<div class="informalexample"><pre class="programlisting">if (name.equals("Forward")) moveForward = isPressed;
else if (name.equals("Back")) moveBackward = isPressed;
else if (name.equals("Left")) moveLeft = isPressed;
else if (name.equals("Right")) moveRight = isPressed;</pre></div></li><li class="listitem">In the <code class="literal">controlUpdate</code> method, move the tiles based on the direction of the camera<a id="id252" class="indexterm"/> and the Booleans you just created. First, get the current forward direction of the camera and the direction which is to the left of it. Then, multiply it by <code class="literal">tpf</code> to get an even movement and an arbitrary value to increase the speed of the movement as follows:<div class="informalexample"><pre class="programlisting">Vector3f camDir = cam.getDirection().mult(tpf).multLocal(50);
        Vector3f camLeftDir = cam.getLeft().mult(tpf).multLocal(50);</pre></div></li><li class="listitem">Using this, call a method called <code class="literal">moveTiles</code> if any movement should occur as follows:<div class="informalexample"><pre class="programlisting">if(moveForward) moveTiles(camDir.negate());
else if (moveBackward) moveTiles(camDir);
if(moveLeft) moveTiles(camLeftDir.negate());
else if (moveRight) moveTiles(camLeftDir);</pre></div></li><li class="listitem">Now, add the <code class="literal">moveTiles</code> method that takes a <code class="literal">Vector3f</code> object called <code class="literal">amount</code> as the<a id="id253" class="indexterm"/> input. First, parse through the values of the <code class="literal">cachedTiles</code> map and apply the amount value as follows:<div class="informalexample"><pre class="programlisting">for(Geometry g: cachedTiles.values()){
  g.move(amount);
}</pre></div></li><li class="listitem">Then, create an <code class="literal">Iterator</code> object and iterate through <code class="literal">cachedTiles</code> again; stop if any of the tiles contain <code class="literal">Vector3f.ZERO</code>, which is the location of the camera. This is our new <code class="literal">currentTile</code> object. This can be implemented as follows:<div class="informalexample"><pre class="programlisting">Vector2f newLocation = null;
Iterator&lt;Vector2f&gt; it = cachedTiles.keySet().iterator();
while(it.hasNext() &amp;&amp; newLocation == null){
  Vector2f tileLocation = it.next();
  Geometry g = cachedTiles.get(tileLocation);
  if(currentTile != g &amp;&amp; g.getWorldBound().contains(Vector3f.ZERO.add(0, -15, 0))){
    currentTile = g;
    newLocation = tileLocation;
  }
}</pre></div></li><li class="listitem">The <a id="id254" class="indexterm"/>location of this tile will be used to decide which other tiles should be loaded. Pass this to two new methods: <code class="literal">updateTiles</code> and <code class="literal">deleteTiles</code>.</li><li class="listitem">First, we take a look at the <code class="literal">updateTiles</code> method. It<a id="id255" class="indexterm"/> takes a <code class="literal">Vector2f</code> parameter called <code class="literal">newLocation</code> as the input. Create a nested <code class="literal">for</code> loop that goes from <code class="literal">x-1</code> and <code class="literal">y-1</code> to <code class="literal">x+1</code> and <code class="literal">y+1</code>.</li><li class="listitem">Check whether <code class="literal">cachedTiles</code> already has the tile with <code class="literal">newLocation</code> and <code class="literal">x</code> and <code class="literal">y</code> combined. If it doesn't, we create a new tile and apply <code class="literal">BoundingBox</code> of the same size as the tile:<div class="informalexample"><pre class="programlisting">Vector2f wantedLocation = newLocation.add(new Vector2f(x,y));
if(!cachedTiles.containsKey(wantedLocation)){
  Geometry g = new Geometry(wantedLocation.x + ", " + wantedLocation.y, new Box(tileSize * 0.5f, 1, tileSize * 0.5f));</pre></div></li><li class="listitem">We set location to be the delta distance from <code class="literal">newLocation</code>. If <code class="literal">currentTile</code> is not null, we add its <code class="literal">localTranslation</code> too:<div class="informalexample"><pre class="programlisting">Vector3f location = new Vector3f(x * tileSize, 0, y * tileSize);
if(currentTile != null){
  location.addLocal(currentTile.getLocalTranslation());
}
g.setLocalTranslation(location);</pre></div></li><li class="listitem">Finally, attach <code class="literal">g</code> to the control's spatial and put <code class="literal">g</code> in the <code class="literal">cachedTiles</code> map with <code class="literal">wantedLocation</code> as the key.</li><li class="listitem">Now, for<a id="id256" class="indexterm"/> the <code class="literal">deleteTiles</code> method, it also takes a <code class="literal">Vector2f</code> parameter called <code class="literal">newLocation</code> as the input.</li><li class="listitem">Like the <code class="literal">updateTiles</code> method, iterate through the <code class="literal">cachedTiles</code> map. Look for those tiles that are now more than two tiles away in either direction and add their location to a list called <code class="literal">tilesToDelete</code>:<div class="informalexample"><pre class="programlisting">Iterator&lt;Vector2f&gt; it = cachedTiles.keySet().iterator();
List&lt;Vector2f&gt; tilesToDelete = new ArrayList&lt;Vector2f&gt;();
while(it.hasNext()){
  Vector2f tileLocation = it.next();
  if(tileLocation.x&gt;newLocation.x + 2 || tileLocation.x&lt;newLocation.x - 2 || tileLocation.y&gt;newLocation.y + 2 || tileLocation.y&lt;newLocation.y - 2){
    tilesToDelete.add(tileLocation);
  }
}</pre></div></li><li class="listitem">When you're <a id="id257" class="indexterm"/>done, simply parse through the <code class="literal">tilesToDelete</code> list, remove the tile from <code class="literal">cachedTiles</code>, and detach it from <code class="literal">Spatial</code>.</li><li class="listitem">There is one more thing we need to do before leaving the class. In the <code class="literal">setSpatial</code> method, we<a id="id258" class="indexterm"/> should add a call to <code class="literal">updateTiles</code>, supplying <code class="literal">Vector2f.ZERO</code> to it to initialize the generation of the tile.<p>For a larger implementation, we might want to introduce an <code class="literal">AppState</code> instance to handle this, but here we will manage it with a test application.</p></li><li class="listitem">First of all, we need to disable <code class="literal">flyCam</code> with <code class="literal">flyCam.setEnabled(false)</code> and possibly move the camera to some distance from the ground.</li><li class="listitem">Then, create a <code class="literal">Node</code> class called <code class="literal">worldNode</code> and an <code class="literal">EndlessWorldControl</code> instance called <code class="literal">worldControl</code>. Attach <code class="literal">worldNode</code> to <code class="literal">rootNode</code> and supply the <code class="literal">worldControl</code> object with a material before adding it to <code class="literal">worldNode</code> and setting the camera.</li><li class="listitem">Finally, set up some keys to control the movement and add the <code class="literal">worldControl</code> object as a listener; refer to the following code on how to do this:<div class="informalexample"><pre class="programlisting">inputManager.addMapping("Forward", new KeyTrigger(KeyInput.KEY_UP));
inputManager.addMapping("Back", new KeyTrigger(KeyInput.KEY_DOWN));
inputManager.addMapping("Left", new KeyTrigger(KeyInput.KEY_LEFT));
inputManager.addMapping("Right", new KeyTrigger(KeyInput.KEY_RIGHT));
inputManager.addListener(worldControl, "Forward", "Back", "Left", "Right");</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec93"/>How it works...</h2></div></div></div><p>The<a id="id259" class="indexterm"/> process that we follow is that if a movement occurs, the <code class="literal">moveTiles</code> method will first move all the tiles to <code class="literal">cachedTiles</code>. It then checks to see whether there's a new tile that should be the center or whether it should be <code class="literal">currentTile</code>. If this happens, other tiles must be checked to see which ones should be kept and which ones need to be generated. This happens in the <code class="literal">updateTiles</code> method. Last in the chain<a id="id260" class="indexterm"/> is the <code class="literal">deleteTiles</code> method that checks which tiles should be removed because they are too far away.</p><p>If we print out the translation of the tiles, we can see that they are never very far from the center of their parent node. This happens because when we generate the tiles, we place them relative to <code class="literal">currentTile</code>. Since <code class="literal">currentTile</code> is also based on a relative position, things never move very far. It's almost like a conveyor belt.</p></div></div>
<div class="section" title="Flowing water with cellular automata"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Flowing water with cellular automata</h1></div></div></div><p>Cellular<a id="id261" class="indexterm"/> automata is an n-dimensional set of cells that interact<a id="id262" class="indexterm"/> together with a given set of rules. Over time, these <a id="id263" class="indexterm"/>interactions have given way to patterns, and modifying the rules will modify the pattern. The most famous example is probably Conway's Game of Life where cells based on an extremely simple rule set create the most amazing, evolving patterns. In games, cellular automata is usually found simulating liquids in a tile– or block–based game worlds.</p><p>In this recipe, we'll explore such a liquid system based on a 2D grid. Since it's 2D, there can be no true waterfalls, but it can still be applied to a heightmap (which we'll show) to create natural-looking rivers.</p><p>Performance becomes an issue with large cellular automata, which will become evident as they're scaled up. To counter this, we'll also look at a couple of different techniques to keep the resource consumption down. The following image shows water running down the slope of a mountain:</p><div class="mediaobject"><img src="graphics/6478OS_03_07.jpg" alt="Flowing water with cellular automata"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec94"/>Getting ready</h2></div></div></div><p>This<a id="id264" class="indexterm"/> recipe requires height differences to make it <a id="id265" class="indexterm"/>interesting. A heightmap will work very well.</p><p>The model we'll develop will evolve around cells that are defined by two parameters: the height of the ground it resides on and the amount of water in it. If the height and amount of water combined are higher than a neighboring cell, water will pour out of it and into its neighbor. To make sure the cells are updated simultaneously, all of the water pouring into a cell will be stored in a separate field and applied at the end of the update cycle. This ensures that water can only move one tile through the field in one update. Otherwise, the same unit of water might travel across the whole grid in one update as we loop through the tiles.</p><p>The example mentions a <code class="literal">CellUtil</code> class. The code for this can be found in the <span class="emphasis"><em>The CellUtil class</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, Information Fragments.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec95"/>How it works...</h2></div></div></div><p>The following steps will produce flowing water:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, let us create a class that contains the cell logic. We can call it <code class="literal">WaterCell</code>. It needs a float field called <code class="literal">amount</code>, another float field called <code class="literal">terrainHeight</code>, and one integer field for the current direction of the flow. It should also store any incoming water in a float field called <code class="literal">incomingAmount</code>.</li><li class="listitem">In addition to the normal getter and setter for <code class="literal">amount</code>, add a method called <code class="literal">adjustAmount</code> that takes a float variable called <code class="literal">delta</code> as the input. The <code class="literal">delta</code> variable should be added to <code class="literal">amount</code>.</li><li class="listitem">Create a<a id="id266" class="indexterm"/> method called <code class="literal">compareCells</code> that will move the water between cells. It takes another cell (where the water is coming from) as the input.</li><li class="listitem">The first thing the method does is checks the difference in height between the two cells as follows:<div class="informalexample"><pre class="programlisting">float difference = (otherCell.getTerrainHeight() + otherCell.getAmount()) - (terrainHeight + amount);</pre></div></li><li class="listitem">The <a id="id267" class="indexterm"/>method will only move the water in<a id="id268" class="indexterm"/> one way: from the supplied cell to this cell so it will only act if the difference is positive (and higher than an arbitrary small amount).</li><li class="listitem">If so, it takes half of the difference since this would even out the amount between the two cells. Before applying it, make sure we don't move more water than there already is in the originating cell:<div class="informalexample"><pre class="programlisting">  amountToChange = difference * 0.5f;
  amountToChange = Math.min(amountToChange, otherCell.getAmount());</pre></div></li><li class="listitem">Add the calculated result to the <code class="literal">incomingAmount</code> field (we don't update the amount for this until everything has been calculated).</li><li class="listitem">However, we must deduct the same amount from the originating cell or there would be a never-ending supply of water. It's done like this:<div class="informalexample"><pre class="programlisting">otherCell.adjustAmount(-amountToChange);</pre></div></li><li class="listitem">Finally, return the deducted amount from this method.</li><li class="listitem">We can leave this class for now and focus on creating a control that will use this class. Create a new class called <code class="literal">WaterFieldControl</code> that extends <code class="literal">AbstractControl</code>.</li><li class="listitem">It needs two integer fields to control the width and height of the field as well as a 2D array of <code class="literal">WaterCell</code> called <code class="literal">waterField</code>. To display it, we'll add a <code class="literal">Node</code> class called <code class="literal">water</code> and a <code class="literal">Material</code> class called <code class="literal">material</code>.</li><li class="listitem">The <code class="literal">setSpatial</code> method should be overridden and the <code class="literal">spatial</code> variable passed has to be an instance of <code class="literal">Node</code>. Look for a terrain among its children; once found, populate <code class="literal">waterField</code> with <code class="literal">WaterCells</code>, applying the height of the terrain for each tile as follows:<div class="informalexample"><pre class="programlisting">for(int x = 0; x &lt; width; x++){
  for(int y = 0; y &lt; height; y++){
    WaterCell cell = new WaterCell();cell.setTerrainHeight(((Terrain)s).getHeight(new Vector2f(x, y)));
    waterField[x][y] = cell;
  }
}</pre></div></li><li class="listitem">Now, create a new method called <code class="literal">updateCells</code>. For this example, define a source of water that will never run out right from the beginning by setting the amount of water in one of the middle tiles as 1.</li><li class="listitem">Then, parse through each cell in the <code class="literal">waterField</code> array in a nested <code class="literal">for</code> loop.</li><li class="listitem">If the cell has an amount that is larger than 0, we can go on and check where we should<a id="id269" class="indexterm"/> start moving the water. Start <a id="id270" class="indexterm"/>with the cell's direction, and if there is water left after checking one direction, continue to look through the other seven directions. This is what the implementation might look like:<div class="informalexample"><pre class="programlisting">WaterCell cell = waterField[x][y];
  float cellAmount = cell.getAmount();
  if(cellAmount &gt; 0){
    int direction = cell.getDirection();
    for(int i = 0; i &lt; 8; i++){
      int[] dir = CellUtil.getDirection((direction + i) % 8);</pre></div></li><li class="listitem">For each of these directions, we must first check that it is a valid location within the field. Then, retrieve the neighboring cell and call <code class="literal">compareCells</code> to try to dump water in it. If this try is successful, set the direction of the <code class="literal">neighborCell</code> object to the tested direction to represent the flow of water, as follows:<div class="informalexample"><pre class="programlisting">WaterCell neighborCell = waterField[x+dx][y+dy];
if(cell.getAmount() &gt; 0.01){
  floatadjustAmount = neighborCell.compareCells(cell);
  if(adjustAmount &gt; 0){neighborCell.setDirection(CellUtil.getDirection(dx, dy));
  }
}</pre></div></li><li class="listitem">Before you exit the method, parse through the <code class="literal">waterField</code> array once again. This time add <code class="literal">incomingWater</code> to the current amount of the cell and then set <code class="literal">incomingWater</code> to <code class="literal">0</code>.</li><li class="listitem">To handle the display of the result, create a new method called <code class="literal">createGeometry</code>.</li><li class="listitem">The first thing we need to do is check whether the <code class="literal">Spatial</code> of the control has a child called <span class="strong"><strong>Water</strong></span>. If it does, detach it.</li><li class="listitem">Next, define a new <code class="literal">Node</code> class called <code class="literal">water</code>. Its name should be <code class="literal">Water</code> as this is an identifier in this example:<div class="informalexample"><pre class="programlisting">water = new Node("Water");</pre></div></li><li class="listitem">Again, parse the <code class="literal">waterField</code> array. If any cell's amount is more than 0, you should add a <code class="literal">Geometry</code> object that represents it. </li><li class="listitem">We're going to add some logic to the <code class="literal">getGeometry</code> method to avoid recreating the <code class="literal">Geometry</code> field <a id="id271" class="indexterm"/>unnecessarily. First of all, set <code class="literal">geometry</code> to <code class="literal">null</code> if the <code class="literal">amount</code> value is 0.</li><li class="listitem">Otherwise, if <code class="literal">geometry</code> is null, create a new <code class="literal">geometry</code> instance with a box-like shape <a id="id272" class="indexterm"/>as follows:<div class="informalexample"><pre class="programlisting">geometry = new Geometry("WaterCell", new Box(1f, 1f, 1f));</pre></div></li><li class="listitem">To <a id="id273" class="indexterm"/>adapt it to the amount of water we have, scale the resulting cube by typing the following code:<div class="informalexample"><pre class="programlisting">geometry.setLocalScale(1, 1f + amount, 1);</pre></div></li><li class="listitem">After this, return the <code class="literal">geometry</code> field, which might be null.</li><li class="listitem">Coming back to the <code class="literal">WaterFieldControl</code> class, if the returned <code class="literal">geometry</code> variable is not null, set its location and attach it to the <code class="literal">water</code> node as follows:<div class="informalexample"><pre class="programlisting">g.setLocalTranslation(x, -1f + cell.getTerrainHeight() + cell.getAmount() * 0.5f, y);
water.attachChild(g);</pre></div></li><li class="listitem">Apply the material to the <code class="literal">water</code> node and then batch it to increase the performance before attaching it to the control's <code class="literal">spatial</code>, as follows:<div class="informalexample"><pre class="programlisting">water = GeometryBatchFactory.optimize(water, false);
water.setMaterial(material);
((Node)spatial).attachChild(water);</pre></div></li><li class="listitem">To finish things off, update the <code class="literal">controlUpdate</code> method to call <code class="literal">updateCells</code> and <code class="literal">createGeometry</code>.</li><li class="listitem">Now this can be used with a few lines in the application class. First of all, create a new<a id="id274" class="indexterm"/> <code class="literal">WaterFieldControl</code> class that we'll add to a <code class="literal">Node</code> class that contains a <code class="literal">Terrain</code> instance.</li><li class="listitem">Next, we need to create the material for the water. This can be as simple as creating a <code class="literal">Material</code> instance with <code class="literal">Unshaded</code> <code class="literal">MaterialDefinition</code> and applying a blueish color to it or an advanced custom shader. It is then applied to the <code class="literal">WaterFieldControl</code> class via the <code class="literal">setMaterial</code> method.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec96"/>How it works...</h2></div></div></div><p>The beauty of cellular automata is the simplicity with which they work. Each cell has a very basic set of rules. In this example, each cell wants to even out the water level with a neighboring cell. As we go through iteration, the water moves downhill.</p><p>It's usually fairly easy to get the automation up and running, but it can take a while to get everything right. For example, even if each cell's amount is updated correctly, we will get weird oscillating water effects if the flow's direction doesn't work correctly. The reason is that there would be a preferred direction the water will take in a new cell. This direction might be<a id="id275" class="indexterm"/> the opposite of where it came from, making<a id="id276" class="indexterm"/> it want to move back to the cell it came from. Picking a random direction might work in that case, but it makes it more difficult to predict the behavior. This is why we use the direction of the water in the cell it came from. Naturally, the water will have some momentum and will continue to flow until it is stopped.</p><p>One thing that can be tricky to grasp at first is the reason why we don't update the water amount directly. The reason is that if water moves from cell x to cell x+1, that water would instantly become available for x+1 once the <code class="literal">update</code> method reaches there; also, it could be moved to x+2 and so on. We can't think of the water as real time, and that's why we first perform an outgoing operation on all the cells before we apply the incoming water. We also don't change the amount in the cell we're currently checking for the same reason. Instead, we move any water left in a cell to the <code class="literal">incomingWater</code> field.</p><p>The main challenge with the method is usually related to performance. Calculating can be expensive and rendering even more so. With a system like this, it's ever-changing and we might be forced to recreate the mesh in every frame. Rendering each cell on its own quickly becomes impossible, and we must use batching to create a single mesh. Even this is not enough, and in this example, we store the cell's <code class="literal">geometry</code> field so we don't have to recreate it unless the water level is 0 in a cell. We also scale the cell's <code class="literal">geometry</code> field if the water level changes as this is much quicker than creating a new <code class="literal">Mesh</code> class for it. The drawback is the additional memory that is used by storing it.</p><p>We also made it optional to update the water in every frame. By lowering it to a set amount of updates every second (in practice, its own frame rate), we could severely lessen the impact of the performance. This could also be taken further by only updating parts of the water field with every update, but efforts must be taken to conserve the amount of the water. We could also separate the field into smaller batches and check whether any of these need to be reconstructed.</p><p>There are ways to take this example further for those who wish. One could play around with the amount of water that each cell shares. This will make it more expensive to calculate but might give a smoother result. It's also possible to add pressure as a parameter, making it possible for water to move up the slopes. Evaporation might be a way to<a id="id277" class="indexterm"/> remove <a id="id278" class="indexterm"/>water from the system and clean up any puddles left by the main flow.</p></div></div>
<div class="section" title="The essentials of a cube-based world"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec40"/>The essentials of a cube-based world</h1></div></div></div><p>In this<a id="id279" class="indexterm"/> recipe, we'll build a small framework to generate optimized cube meshes, which can be used to create large-scale worlds. This framework will consist of an <code class="literal">AppState</code> object to handle user actions, a class called <code class="literal">CubeWorld</code> that will store<a id="id280" class="indexterm"/> the terrain data, and a class called <code class="literal">CubeCell</code> that will store the <a id="id281" class="indexterm"/>data for individual cells. In addition, there is a <code class="literal">CubeUtil</code> class<a id="id282" class="indexterm"/> that will help us to generate meshes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec97"/>Getting ready</h2></div></div></div><p>This is an advanced recipe that requires an understanding the generation of a basic terrain, which can be found earlier in the chapter, and the building blocks of meshes and how to create custom meshes.</p><p>Before we begin, we will create a class called <code class="literal">CubeUtil</code> and populate it with some shaped data that we will need later. Since each of the cells is of a box shape, we can borrow some fields from the <code class="literal">Box</code> and <code class="literal">AbstractBox</code> classes and save some time in setting it up. Just copy the <code class="literal">GEOMETRY_INDICES_DATA</code>, <code class="literal">GEOMETRY_NORMALS_DATA</code>, and <code class="literal">GEOMETRY_TEXTURE_DATA</code> fields to the <code class="literal">CubeUtil</code> class.</p><p>At the bottom of the class, there is a method called <code class="literal">doUpdateGeometryVertices</code> that contains a float array. Copy this float array too and call its vertices. This array contains data for the 24 vertices needed to create a cube with normal. It in turn relies on references to eight original vertex positions. We can get these from the <code class="literal">AbstractBox</code> class and the <code class="literal">computeVertices</code> method. The <code class="literal">Vector3f</code> center referenced here can be replaced with <code class="literal">Vector3f.ZERO</code>. The <code class="literal">xExtent</code>, <code class="literal">yExtent</code> , and <code class="literal">zExtent</code> parameters can be replaced with <code class="literal">0.5f</code> to get a square box with <code class="literal">1f</code> sides.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec98"/>How to do it...</h2></div></div></div><p>We start by creating the object that contains the cell data. This will have the following seven steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create a new class called <code class="literal">CubeCell</code>.</li><li class="listitem">It contains a <code class="literal">Mesh</code> field call <code class="literal">mesh</code>, an array of six Booleans called <code class="literal">neighbors</code>, and another Boolean called <code class="literal">refresh</code>.</li><li class="listitem">In addition, there is enum called <code class="literal">Type</code> where we can put names such as <code class="literal">Rock</code>, <code class="literal">Sand</code>, and <code class="literal">Grass</code>. Then, add a <code class="literal">Type</code> field called <code class="literal">type</code>.</li><li class="listitem">Create a<a id="id283" class="indexterm"/> method called <code class="literal">hasNeighbor</code> that takes an integer parameter as an input and return the corresponding Boolean from the array.</li><li class="listitem">Then, add a method called <code class="literal">setNeighbor</code> that takes both an integer parameter called <code class="literal">direction</code> and a Boolean parameter called <code class="literal">neighbor</code> as the input. If the current Boolean at the position of the direction is not the same as that of the neighbor, store the neighbor at that location and set <code class="literal">refresh</code> to <code class="literal">true</code>.</li><li class="listitem">Add a method called <code class="literal">requestRefresh</code> that sets <code class="literal">refresh</code> to <code class="literal">true</code>.</li><li class="listitem">For a mesh, add a <code class="literal">getMesh</code> method, and inside this, call a method called <code class="literal">CubeUtil.createMesh</code> if the mesh is null or refresh it if it is <code class="literal">true</code>. This will also set <code class="literal">refresh</code> to <code class="literal">false</code> as follows:<div class="informalexample"><pre class="programlisting">if(mesh == null || refresh){
  mesh = CubeUtil.createMesh(this);
  refresh = false;
}
return mesh;</pre></div></li></ol></div><p>Now, let's return to the <code class="literal">CubeUtil</code> class where we add some helper methods to generate the world. This section has the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, add a <code class="literal">createMesh</code> method that takes a <code class="literal">CubeCell</code> parameter as the input. This method will create a mesh for the cell, and here you'll use the data we set up in the <span class="emphasis"><em>Getting Ready</em></span> section of this recipe.</li><li class="listitem">First of all, place the vertex data in the mesh with the following line of code:<div class="informalexample"><pre class="programlisting">m.setBuffer(VertexBuffer.Type.Position, 3, BufferUtils.createFloatBuffer(vertices));</pre></div></li><li class="listitem">Add indices to the sides of the mesh that are exposed and check the neighbors to see which ones these are. Then, add six indices (for two triangles) for each mesh to a list using <code class="literal">GEOMETRY_INDICES_DATA</code>, as follows:<div class="informalexample"><pre class="programlisting">List&lt;Integer&gt; indices = new ArrayList&lt;Integer&gt;();
for(intdir = 0; dir &lt; 6; dir++){
  if(!cube.hasNeighbor(dir)){
    for(int j = 0; j &lt; 6; j++){
      indices.add(GEOMETRY_INDICES_DATA[dir * 6 + j]);
    }
  }
}</pre></div></li><li class="listitem">To add these to the mesh, first convert them into an array. Then, set the array as the index buffer, as follows:<div class="informalexample"><pre class="programlisting">m.setBuffer(VertexBuffer.Type.Index, 1, BufferUtils.createIntBuffer(indexArray));</pre></div></li><li class="listitem">For texture coords and vertex normals, simply use the data we have already set up as follows:<div class="informalexample"><pre class="programlisting">m.setBuffer(VertexBuffer.Type.TexCoord, 2, BufferUtils.createFloatBuffer(GEOMETRY_TEXTURE_DATA));
m.setBuffer(VertexBuffer.Type.Normal, 3, GEOMETRY_NORMALS_DATA);</pre></div></li><li class="listitem">Now, return<a id="id284" class="indexterm"/> the mesh to the calling method.</li><li class="listitem">Add one more method called <code class="literal">generateBlock</code> to the <code class="literal">CubeUtil</code> class and create a 3D array of <code class="literal">CubeCell</code> and return it. The principle for it is the same as the heightmap we created in the <span class="emphasis"><em>Using noise to generate a terrain</em></span> recipe, except here we use three dimensions instead of two. The following code with generate a <code class="literal">CubeCell</code> class in a 3D pattern:<div class="informalexample"><pre class="programlisting">CubeCell[][][] terrainBlock = new CubeCell[size][size][size];
for(int y = 0; y &lt; size; y++){
  for(int z = 0; z &lt; size; z++){
    for(int x = 0; x &lt; size; x++){
      double value = fractalSum.value(x, y, z);
      if(value &gt;= 0.0f){
        terrainBlock[x][y][z] = new CubeCell();
      }
    }
  }
}</pre></div></li></ol></div><p>We can now look at how to tie these two classes together and start generating some cubes. This will be performed in the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We turn our attention to the <code class="literal">CubeWorld</code> class that will hold the information about all our cubes. It has a <code class="literal">Node</code> field called <code class="literal">world</code>, an integer file called <code class="literal">batchSize</code>, and array of <code class="literal">Material</code> called <code class="literal">materials</code> and, for this example, a single <code class="literal">CubeCell[][][]</code> array called <code class="literal">terrainBlock</code>.</li><li class="listitem">After initializing the <code class="literal">worldNode</code> class in the constructor, create a public method called <code class="literal">generate</code>. Inside this, call <code class="literal">CubeUtil.generateBlock(4, batchSize)</code> and store it in <code class="literal">terrainBlock</code>.</li><li class="listitem">Then, call and create another method called <code class="literal">generateGeometry</code> that will put all the <code class="literal">CubeCell</code> classes together into a <code class="literal">Node</code> class.</li><li class="listitem">First, check whether the <code class="literal">worldNode</code> class already has a node with a given name. If it does, detach<a id="id285" class="indexterm"/> it. In either case, create a new <code class="literal">BatchNode</code> field with the same name we checked for.</li><li class="listitem">Now, parse through the whole of the <code class="literal">terrainBlock</code> array and all the locations where there is a <code class="literal">CubeCell</code> class; we will check 6 directions (either side of it). For each side, check whether there is a neighbor there; there will be one if the position is not null. In that case, call <code class="literal">setNeighbor</code> on the cell you're checking for and supply the direction of the current as follows:<div class="informalexample"><pre class="programlisting">  for(int y = 0; y &lt; batchSize; y++){
    repeat for x and z
    if(terrainBlock[x][y][z] != null){
      for(inti = 0; i &lt; 6; i++){
        Vector3f coords = CubeUtil.directionToCoords(i);
        if(coords.y + y &gt; -1 &amp;&amp; coords.y + y &lt; batchSize){
          repeat for x and z
          if(terrainBlock[(int)coords.x + x][(int)coords.y y][(int)coords.z + z] != null){terrainBlock[x][y][z].setNeighbor(i, true);
          } else {terrainBlock[x][y][z].setNeighbor(i, false);
          }
        }
      }
    }
  }</pre></div></li><li class="listitem">The next step is to create geometries for the <code class="literal">CubeCell</code> instances. Do this by again parsing through the <code class="literal">terrainBlock</code> field, and where the corresponding <code class="literal">CubeCell</code> is not null, create a new <code class="literal">Geometry</code> class by calling the <code class="literal">CubeCell'sgetMesh'</code> method. Then, move it to the right position using <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> that we're iterating over, and apply a material and attach it to the batch node as follows:<div class="informalexample"><pre class="programlisting">Geometry g = new Geometry("Cube", terrainBlock[x][y][z].getMesh() );
g.setLocalTranslation(x, y, z);
g.setMaterial(materials[0]);
node.attachChild(g);</pre></div></li><li class="listitem">Finally, in the <code class="literal">generateGeometry</code> method, call <code class="literal">node.updateModelBound()</code> and <code class="literal">node.batch()</code> to optimize it before attaching it to <code class="literal">worldNode</code>.</li><li class="listitem">The basic of the generation process is now in place, and you can create a new class called <code class="literal">CubeWorldAppState</code> that extends <code class="literal">AbstractAppState</code>. In this case, add a <code class="literal">CubeWorld</code> field called <code class="literal">cubeWorld</code>.</li><li class="listitem">Override the <code class="literal">initialize</code> method and declare a new <code class="literal">cubeWorld</code> instance.</li><li class="listitem">Then, load a new material based on the <span class="strong"><strong>Lighting</strong></span> material's definition and supply it to <code class="literal">cubeWorld</code>. After this, call <code class="literal">cubeWorld</code> and generate and attach <code class="literal">worldNode</code> through its getter method.</li><li class="listitem">Also, add<a id="id286" class="indexterm"/> a light to see anything since we're using the <span class="strong"><strong>Lighting</strong></span> material.</li><li class="listitem">Now, create an application where we attach this <code class="literal">Appstate</code> instance and we should see our block of <code class="literal">CubeCell</code> in the world. It's static, however, and it's very common to want to change the world.</li></ol></div><p>Let's see how we can add the functionality to pick up and place blocks. The following figure is of a resulting terrain block:</p><div class="mediaobject"><img src="graphics/6478OS_03_08.jpg" alt="How to do it..."/></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Begin in <code class="literal">CubeWorldAppState</code> by implementing <code class="literal">ActionListener</code> to handle user input. Add a <code class="literal">CubeCell</code> field called <code class="literal">takenCube</code> to store a <code class="literal">CubeCell</code> field that has been picked up.</li><li class="listitem">Add mappings to <code class="literal">inputManager</code> to pick up and place a <code class="literal">CubeCell</code> field. Use the left and right mouse button as shown in the following lines of code:<div class="informalexample"><pre class="programlisting">inputManager.addMapping("take", new MouseButtonTrigger(MouseInput.BUTTON_LEFT));
inputManager.addMapping("put", new MouseButtonTrigger(MouseInput.BUTTON_RIGHT));</pre></div></li><li class="listitem">Then, create<a id="id287" class="indexterm"/> a method called <code class="literal">modifyTerrain</code> that takes a Boolean called <code class="literal">pickupCube</code> as the input.</li><li class="listitem">To control what is picked up or aimed at, use a pattern that we have established in the <span class="emphasis"><em>Firing in FPS</em></span> recipe of <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>. Use a ray that originates from the camera and moves toward the camera's direction.</li><li class="listitem">Now, collide<a id="id288" class="indexterm"/> it with the <code class="literal">worldnode</code> class of <code class="literal">cubeWorld</code>. If it collides with something and the distance is lower than two (or some other arbitrary number) and <code class="literal">pickupCube</code> is true, we will pick up a cube. Get the <code class="literal">worldTranslation</code> vector of the geometry that the ray has collided with. Then, call a method called <code class="literal">changeTerrain</code> in <code class="literal">cubeWorld</code>. We'll create the method in a short while. Now, supply it with the coordinates of the geometry it collides with and the currently empty <code class="literal">takenCube</code> field as follows:<div class="informalexample"><pre class="programlisting">if(coll != null &amp;&amp; coll.getDistance() &lt; 2f &amp;&amp; pickupCube){
  Vector3f geomCoords = coll.getGeometry().getWorldTranslation();
  takenCube = cubeWorld.changeTerrain(geomCoords, takenCube);
}</pre></div></li><li class="listitem">If instead, there is no collision or the collision is too far away, and at the same time <code class="literal">pickupCube</code> is <code class="literal">false</code> and <code class="literal">takenCube</code> is not null, try to place <code class="literal">takenCube</code> in the world. Since we don't have a collision point, move some way along the direction of the camera and round it off to the nearest integer. Then, call <code class="literal">cubeWorld.changeTerrain</code> again with the coordinates along with <code class="literal">takenCube</code>, as follows:<div class="informalexample"><pre class="programlisting">Vector3f geomCoords = cam.getLocation().add(cam.getDirection().mult(2f));
geomCoords.set(Math.round(geomCoords.x), Math.round(geomCoords.y), Math.round(geomCoords.z));
takenCube = cubeWorld.changeTerrain(geomCoords, takenCube);</pre></div></li><li class="listitem">In the <code class="literal">onAction</code> method, add the logic for the corresponding key press and call <code class="literal">modifyTerrain</code>, supplying either <code class="literal">true</code> if we're picking up or <code class="literal">false</code> if we're instead trying to place a <code class="literal">CubeCell</code> field.</li><li class="listitem">In the <code class="literal">CubeWorld</code> class, create this <code class="literal">changeTerrain</code> method that takes a <code class="literal">Vector3f</code> parameter called <code class="literal">coords</code> and a <code class="literal">CubeCell</code> parameter called <code class="literal">blockToPlace</code> as the<a id="id289" class="indexterm"/> input. The <code class="literal">Coords</code> parameters represent the location of a <code class="literal">CubeCell</code> instance. The <code class="literal">changeTerrain</code> method returns<a id="id290" class="indexterm"/> a <code class="literal">CubeCell</code> instance.</li><li class="listitem">The first thing we will do is define a <code class="literal">CubeCell</code> field called <code class="literal">changedBlock</code> where we store the incoming <code class="literal">blockToPlace</code>.</li><li class="listitem">Then, do a check to make sure the supplied coordinate is within the bounds of the <code class="literal">terrainBlock</code> array and then check whether <code class="literal">changedBlock</code> is null. If it is, pick up the <code class="literal">CubeCell</code> instance from this location and populate <code class="literal">changedBlock</code> with the <code class="literal">CubeCell</code> instance. Then, set the location's <code class="literal">CubeCell</code> to null as follows:<div class="informalexample"><pre class="programlisting">if(changedBlock == null){
  changedBlock = terrainBlock[x][y][z];
  terrainBlock[x][y][z] = null;
}</pre></div></li><li class="listitem">If instead the <code class="literal">CubeCell</code> instance at this location is null (we already know that <code class="literal">changedBlock</code> is not null), set the <code class="literal">CubeCell</code> instance over here to <code class="literal">changedBlock</code> and <code class="literal">changedBlock</code> to null. Also, call <code class="literal">requestRefresh</code> on the <code class="literal">CubeCell</code> instance to force it to update the mesh, as follows:<div class="informalexample"><pre class="programlisting">else if(terrainBlock[x][y][z] == null){
  terrainBlock[x][y][z] = changedBlock;
  terrainBlock[x][y][z].requestRefresh();
  changedBlock = null;
}</pre></div></li><li class="listitem">Finally, if there has been a change made, call <code class="literal">generateGeometry</code> and return <code class="literal">changedBlock</code> to the calling method.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec99"/>How it works...</h2></div></div></div><p>This<a id="id291" class="indexterm"/> recipe is mostly about creating meshes that are as optimized as possible. Cubes are great building blocks, but each has 12 triangles, and rendering them all for hundreds or thousands will quickly slow down most systems. In the first part of the recipe, we implemented functionalities to create meshes that only had the exposed sides of the cube's generated triangles. We found this out by checking which of the positions next to the cube were occupied by other cubes.</p><p>Once all the cubes were generated, we added them to <code class="literal">BatchNode</code> and batched it to create one mesh for all the cubes. Even if the polygon count is the same, decreasing the number of objects greatly enhances the performance.</p><p>Having a single mesh means we can't change a single object in the mesh without regenerating the whole batch. If we plan to scale this up and generate a whole world, we need to keep the size of the batch to a size where we can regenerate it without creating slowdowns. Exploring a way to generate it on a separate thread might be a good next step.</p></div></div></body></html>