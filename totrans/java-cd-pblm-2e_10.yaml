- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Concurrency – Virtual Threads and Structured Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发 – 虚拟线程和结构化并发
- en: This chapter includes 16 problems that briefly introduce *virtual threads* and
    *structured concurrency*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括16个问题，简要介绍了*虚拟线程*和*结构化并发*。
- en: If you don’t have a background in concurrency in Java, then I strongly recommend
    postponing this chapter until after you have read some good introductory coverage
    on the topic. For instance, you could try out *Chapters 10* an*d 11* from *Java
    Coding Problems*, *First Edition*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有Java并发的背景知识，我强烈建议你在阅读一些关于该主题的良好入门介绍之后再阅读本章。例如，你可以尝试阅读*Java编码问题*第一版的第*10*章和第*11*章。
- en: '*Virtual threads* are one of the most important and astonishing features added
    by Java in the last few years. They have a significant impact on how we will continue
    to write and understand concurrent code from this point forward. In this chapter,
    you’ll learn, step by step, every single detail of this topic and the *structured
    concurrency* paradigm.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟线程*是Java在过去几年中添加的最重要和最令人惊讶的特性之一。它们对我们继续编写和理解并发代码的方式产生了重大影响。在本章中，你将逐步学习这个主题和*结构化并发*范式的每一个细节。'
- en: After this chapter, you’ll be quite knowledgeable in working with virtual threads
    and structured concurrency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将非常熟悉如何使用虚拟线程和结构化并发。
- en: Problems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess in virtual threads
    and structured concurrency in Java. I strongly encourage you to give each problem
    a try before you turn to the solutions and download the example programs:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在Java虚拟线程和结构化并发方面的编程能力。我强烈鼓励你在查看解决方案和下载示例程序之前尝试解决每个问题：
- en: '**Explaining concurrency vs. parallelism**: Provide a brief but meaningful
    explanation of concurrency vs. parallelism.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解释并发与并行**：提供简明但富有意义的并发与并行的解释。'
- en: '**Introducing structured concurrency**: Write an example highlighting the main
    issues of “unstructured” concurrency. Moreover, provide an introduction to the
    structured concurrency paradigm.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍结构化并发**：编写一个示例，突出“非结构化”并发的关键问题。此外，介绍结构化并发范式。'
- en: '**Introducing virtual threads**: Explain and exemplify the main concepts of
    virtual threads.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍虚拟线程**：解释并举例说明虚拟线程的主要概念。'
- en: '**Using the ExecutorService for virtual threads**: Write several examples that
    highlight the *task-per-thread* model via `ExecutorService` and virtual threads.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用ExecutorService进行虚拟线程**：编写几个示例，通过`ExecutorService`和虚拟线程突出“任务-线程”模型。'
- en: '**Explaining how virtual threads work**: Provide comprehensive coverage of
    how virtual threads work internally.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解释虚拟线程的工作原理**：全面介绍虚拟线程的内部工作原理。'
- en: '**Hooking virtual threads and sync code**: Explain and exemplify via a meaningful
    snippet of code how virtual threads and sync code work together.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**虚拟线程和同步代码的挂钩**：通过一段有意义的代码片段解释并举例说明虚拟线程和同步代码是如何协同工作的。'
- en: '**Exemplifying thread context switching**: Write several examples that show
    how *thread context switching* works for virtual threads.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**举例说明线程上下文切换**：编写几个示例，展示虚拟线程的线程上下文切换是如何工作的。'
- en: '**Introducing the ExecutorService invoke all/any for virtual threads – part
    1**: Provide a brief introduction of `ExecutorService` invoke all/any for virtual
    threads.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍ExecutorService invoke all/any对虚拟线程的调用 – 第1部分**：简要介绍`ExecutorService`对虚拟线程的invoke
    all/any调用。'
- en: '**Introducing the ExecutorServiceinvoke all/any for virtual threads – part
    2**: Re-write the example of “unstructured” concurrency from *Problem 210* via
    `ExecutorService` invoke all/any for virtual threads.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍ExecutorService invoke all/any对虚拟线程的调用 – 第2部分**：通过`ExecutorService` invoke
    all/any对虚拟线程重写“问题210”中的“非结构化”并发示例。'
- en: '**Hooking task state**: Explain and exemplify the new `Future#state()` API.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挂钩任务状态**：解释并举例说明新的`Future#state()` API。'
- en: '**Combining new VirtualThreadPerTaskExecutor() and streams**: Write several
    examples that introduce how Java stream pipelines can be combined with the `newVirtualThreadPerTaskExecutor()`
    executor.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结合new VirtualThreadPerTaskExecutor()和流**：编写几个示例，介绍Java流管道如何与`newVirtualThreadPerTaskExecutor()`执行器结合使用。'
- en: '**Introducing a scope object (StructuredTaskScope)**: Provide a brief introduction
    of structured concurrency via the `StructuredTaskScope` API.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍范围对象（StructuredTaskScope）**：通过`StructuredTaskScope` API简要介绍结构化并发。'
- en: '**Introducing ShutdownOnSuccess**: Exemplify the `ShutdownOnSuccess` flavor
    of `StructuredTaskScope`.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍ShutdownOnSuccess**：举例说明`StructuredTaskScope`的`ShutdownOnSuccess`风味。'
- en: '**Introducing ShutdownOnFailure**: Exemplify the `ShutdownOnFailure` flavor
    of `StructuredTaskScope`.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍ShutdownOnFailure**：举例说明`StructuredTaskScope`的`ShutdownOnFailure`版本。'
- en: '**Combining StructuredTaskScope and streams**: Write several examples that
    introduce how Java stream pipelines can be combined with `StructuredTaskScope`.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结合StructuredTaskScope和流**：编写几个示例，介绍如何将Java流管道与`StructuredTaskScope`结合使用。'
- en: '**Observing and monitoring virtual threads**: Exemplify how we can use **JFR**
    (**Java Flight Recorder**), **JMX** (**Java Management Extensions**), and any
    other tool that you like, for observing and monitoring virtual threads.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**观察和监控虚拟线程**：举例说明我们如何使用**JFR**（**Java Flight Recorder**）、**JMX**（**Java Management
    Extensions**）以及您喜欢的任何其他工具来观察和监控虚拟线程。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节描述了前面问题的解决方案。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节，并在此[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10)上的程序进行实验。
- en: 209\. Explaining concurrency vs. parallelism
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 209. 解释并发与并行
- en: Before tackling the main topic of this chapter, *structured concurrency*, let’s
    forget about *structure*, and let’s keep only *concurrency*. Next, let’s put *concurrency*
    against *parallelism*, since these two notions are often a source of confusion.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在着手本章的主要主题——**结构化并发**之前，让我们先忘记**结构**，只保留**并发**。接下来，让我们将**并发**与**并行**进行比较，因为这两个概念常常是混淆的源头。
- en: Both of them, concurrency and parallelism, use *tasks* as the main unit of work.
    However, the way that they handle these tasks makes them very different.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者，并发和并行，都使用**任务**作为主要的工作单元。然而，它们处理这些任务的方式使它们非常不同。
- en: In the case of parallelism, a task is split into subtasks across multiple CPU
    cores. These subtasks are computed in parallel, and each of them represents a
    partial solution for the given task. By joining these partial solutions, we obtain
    the solution. Ideally, solving a task in parallel should result in less wall-clock
    time than in the case of solving the same task sequentially. In a nutshell, in
    parallelism, at least two threads run at the same time, which means that parallelism
    can solve a single task faster.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行的情况下，一个任务被分割成多个CPU核心的子任务。这些子任务并行计算，每个子任务代表给定任务的局部解决方案。通过合并这些局部解决方案，我们得到解决方案。理想情况下，并行解决任务应该比顺序解决相同任务所需的时间更少。简而言之，在并行中，至少有两个线程同时运行，这意味着并行可以更快地解决单个任务。
- en: In the case of concurrency, we try to solve as many tasks as possible via several
    threads that compete with each other, progressing in a time-slicing fashion. This
    means that concurrency can complete multiple tasks faster. This is why concurrency
    is also referred to as virtual parallelism.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发的情况下，我们尝试通过几个相互竞争的线程尽可能多地解决任务，以时间分片的方式推进。这意味着并发可以更快地完成多个任务。这也是为什么并发也被称为虚拟并行。
- en: 'The following figure depicts parallelism vs. concurrency:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了并行与并发的对比：
- en: '![Figure 10.1.png](img/B19665_10_01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.1.png](img/B19665_10_01.png)'
- en: 'Figure 10.1: Concurrency vs. parallelism'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：并发与并行
- en: In parallelism, tasks (subtasks) are part of the implemented solution/algorithm.
    We write the code, set/control the number of tasks, and use them in a context
    that has parallel computational capabilities. On the other hand, in concurrency,
    tasks are part of the problem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行的情况下，任务（子任务）是实施解决方案/算法的一部分。我们编写代码，设置/控制任务数量，并在具有并行计算能力的上下文中使用它们。另一方面，在并发中，任务是问题的一部分。
- en: Typically, we measure parallelism efficiency in *latency* (the amount of time
    needed to complete the task), while the efficiency of concurrency is measured
    in *throughput* (the number of tasks that we can solve).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们通过**延迟**（完成任务所需的时间）来衡量并行效率，而并发的效率则是通过**吞吐量**（我们可以解决的任务数量）来衡量的。
- en: Moreover, in parallelism, tasks control resource allocation (CPU time, I/O operations,
    and so on). On the other hand, in concurrency, multiple threads compete with each
    other to gain as many resources (I/O) as possible. They cannot control resource
    allocation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在并行性中，任务控制资源分配（CPU时间、I/O操作等）。另一方面，在并发中，多个线程相互竞争以获取尽可能多的资源（I/O）。它们无法控制资源分配。
- en: In parallelism, threads operate on CPU cores in such a way that every core is
    busy. In concurrency, threads operate on tasks in such a way that, ideally, each
    thread has a separate task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行性中，线程以这种方式在CPU核心上操作，即每个核心都处于忙碌状态。在并发中，线程以这种方式在任务上操作，理想情况下，每个线程都有一个单独的任务。
- en: 'Commonly, when parallelism and concurrency are compared, somebody comes and
    says: *How about asynchronous methods?*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当比较并行性和并发性时，有人会过来问：*异步方法怎么样？*
- en: It is important to understand that *asynchrony* is a separate concept. Asynchrony
    is about the capability to accomplish non-blocking operations. For instance, an
    application sends an HTTP request, but it doesn’t just wait for the response.
    It goes and solves something else (other tasks) while waiting for the response.
    We do asynchronous tasks every day. For instance, we start the washing machine
    and then go to clean other parts of the house. We don’t just wait by the washing
    machine until it is finished.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 *异步性* 是一个独立的概念。异步性是关于完成非阻塞操作的能力。例如，一个应用程序发送一个HTTP请求，但它不会只是等待响应。它会去做其他事情（其他任务），在等待响应的同时。我们每天都在做异步任务。例如，我们开始启动洗衣机，然后去打扫房子的其他部分。我们不会只是站在洗衣机旁边，直到它完成。
- en: 210\. Introducing structured concurrency
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 210. 介绍结构化并发
- en: If you are as old as I am, then most probably you started programming with a
    language such as BASIC or a similar unstructured programming language. At that
    time, an application was just a sequence of lines that defined a sequential logic/behavior
    via a bunch of GOTO statements, driving the flow by jumping like a kangaroo back
    and forward between the code lines. Well, in Java, the building blocks of a typical
    concurrent code are so primitive that the code looks somewhat like unstructured
    programming because it is hard to follow and understand. Moreover, a thread dump
    of a concurrent task doesn’t provide the needed answers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样大，那么你很可能开始编程时使用的是BASIC或类似的非结构化编程语言。当时，一个应用程序只是一系列定义了顺序逻辑/行为的代码行，通过一串GOTO语句驱动流程，像袋鼠一样在代码行之间跳来跳去。在Java中，典型并发代码的构建块非常原始，因此代码看起来有点像非结构化编程，因为它难以跟踪和理解。此外，并发任务的线程转储并不提供所需的答案。
- en: 'Let’s follow a snippet of Java concurrent code and stop every time we have
    a question (always check the code below the question). The task is to concurrently
    load three testers by ID and team them up in a testing team. First, let’s list
    the server code (we will use this simple code to serve us in this problem and
    subsequent problems):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随一段Java并发代码，每次有问题时都停下来（总是检查问题下面的代码）。任务是并发地通过ID加载三个测试人员并将他们组成一个测试团队。首先，让我们列出服务器代码（我们将使用这段简单的代码来帮助我们解决这个问题和后续的问题）：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, the code that we are especially interested in starts as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们特别感兴趣的代码如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*First stop*: As you can see, `buildTestingTeam()` throws an `InterruptedException`.
    So if the thread executing `buildTestingTeam()` gets interrupted, how can we easily
    interrupt the following threads?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一站*：正如你所见，`buildTestingTeam()` 抛出了 `InterruptedException`。那么如果执行 `buildTestingTeam()`
    的线程被中断，我们如何轻松地中断后续的线程？'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Second stop*: Here, we have three `get()` calls. So the current thread waits
    for other threads to complete. Can we easily observe those threads?'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二站*：这里，我们有三个 `get()` 调用。所以当前线程会等待其他线程完成。我们能否轻松地观察那些线程？'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Third stop:* If an `ExecutionException` is caught, then we know that one of
    these three `Future` instances has failed. Can we easily cancel the remaining
    two, or will they just hang on there? `future1` will probably fail while `future2`
    and `future3` will complete successfully, or maybe `future2` will complete successfully
    while `future3` will just run forever (a so-called *orphan* thread). This can
    lead to serious mismatches in the expected results, memory leaks, and so on:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*第三站*：如果捕获到 `ExecutionException`，那么我们知道这三个 `Future` 实例中的一个失败了。我们能否轻松地取消剩余的两个，或者它们会一直挂在那里？`future1`
    可能会失败，而 `future2` 和 `future3` 可能会成功完成，或者也许 `future2` 会成功完成，而 `future3` 将会永远运行（所谓的
    *孤儿线程*）。这可能导致预期的结果严重不匹配、内存泄漏等问题：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Fourth stop*: The next line of code is used to shut down the `executor`, but
    it is so easy to overlook. Is this the proper place to do this?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*第四个步骤*：下一行代码用于关闭`executor`，但它很容易被忽略。这是正确的操作位置吗？'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Fifth stop*: If you didn’t spot the previous line of code, then it is legitimate
    to ask yourself how/where this executor got shut down:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*第五个步骤*：如果您没有注意到上一行代码，那么您有理由问自己这个执行器是如何/在哪里被关闭的：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We skip the rest of the code, since you can find it in the bundled code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了其余的代码，因为您可以在捆绑的代码中找到它。
- en: Of course, we can implement code answers to each of these questions via error
    handling, task abandons and abortions, `ExecutorService`, and so on, but this
    means a lot of work for the developer. Writing failsafe solutions that carefully
    cover all possible scenarios across multiple tasks/subtasks while tracking their
    progress in a concurrent environment is not an easy job. That’s not to mention
    how hard it is to understand and maintain the resulting code by another developer,
    or even the same developer after 1–2 years or even months.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过错误处理、任务放弃和终止、`ExecutorService`等方式为这些问题实现代码答案，但这意味着开发者需要做大量的工作。在并发环境中跟踪多个任务/子任务的进度，同时仔细覆盖所有可能的场景，编写容错解决方案并非易事。更不用说，其他开发者或甚至是1-2年后或几个月后的同一开发者理解和维护生成的代码有多么困难。
- en: It is time to add some structure to this code, so let’s introduce *structured
    concurrency* (or Project Loom).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给这段代码添加一些结构了，让我们引入*结构化并发*（或Project Loom）。
- en: '*Structured concurrency* relies on several pillars meant to bring lightweight
    concurrency to Java. The fundamental pillar or principle of structured concurrency
    is highlighted next.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化并发*依赖于几个支柱，旨在将轻量级并发引入Java。结构化并发的根本支柱或原则将在下面强调。'
- en: '**Important note**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The fundamental principle of structured concurrency is that when a task has
    to be solved concurrently, then all the threads needed to solve it are spun and
    rejoined in the same block of code. In other words, all these threads’ lifetimes
    are bound to the block’s lexical scope, so we have clear and explicit entry-exit
    points for each concurrent code block.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化并发的根本原则是，当一个任务需要并发解决时，所有解决该任务所需的线程都在同一块代码中启动和重新连接。换句话说，所有这些线程的生命周期都绑定到块的词法作用域，因此我们为每个并发代码块提供了清晰和明确的入口和出口点。
- en: Based on this principle, the thread that initiates a concurrent context is the
    *parent-thread* or the *owner-thread*. All threads started by the parent-thread
    are *children-threads* or *forks*, so between them, these threads are siblings.
    Together, the parent-thread and the child-threads define a *parent-child hierarchy*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个原则，启动并发上下文的线程是*父线程*或*拥有线程*。由父线程启动的所有线程都是*子线程*或*分支*，因此它们之间是兄弟姐妹关系。父线程和子线程共同定义了一个*父子层次结构*。
- en: 'Putting the structured concurrency principle into a diagram will show us the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将结构化并发原则放入图中将展示以下内容：
- en: '![Figure 10.2.png](img/B19665_10_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2.png](img/B19665_10_02.png)'
- en: 'Figure 10.2: Parent-child hierarchy in structured concurrency'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：结构化并发中的父子层次结构
- en: 'In the context of the parent-child hierarchy, we have support for error/exception
    handling with short-circuiting, cancellation propagation, and monitoring/observability:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在父子层次结构的上下文中，我们支持带有短路、取消传播、监控/可观察性的错误/异常处理：
- en: '*Error/exception handling with short-circuiting*: If a child-thread fails,
    then all child-threads are canceled unless they are complete. For instance, if
    `futureTester(1)` fails, then `futureTester(2)` and `futureTester(3)` are automatically
    canceled.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*短路错误/异常处理*：如果一个子线程失败，那么除非它们已经完成，否则所有子线程都会被取消。例如，如果`futureTester(1)`失败，那么`futureTester(2)`和`futureTester(3)`将自动取消。'
- en: '*Cancellation propagation*: If the parent-thread is interrupted until joining
    the child-threads is over, then these forks (the child-threads/subtasks) are canceled
    automatically. For instance, if the thread executing `buildTestingTeam()` gets
    interrupted, then its three forks are automatically canceled.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*取消传播*：如果父线程在加入子线程之前被中断，那么这些分支（子线程/子任务）将自动取消。例如，如果执行`buildTestingTeam()`的线程被中断，那么它的三个分支将自动取消。'
- en: '*Monitoring/observability*: A thread dump reveals a crystal-clear image of
    the entire parent-child hierarchy, no matter how many levels have been spawned.
    Moreover, in structured concurrency, we take advantage of scheduling and the memory
    management of threads.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监控/可观察性*：线程转储揭示了整个父子层次结构的清晰图像，无论产生了多少层级。此外，在结构化并发中，我们利用线程的调度和内存管理。'
- en: 'While these are purely concepts, writing code that respects and follows these
    concepts requires the proper API and the following awesome callout:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些都是纯粹的概念，但编写遵循这些概念的代码需要适当的API和以下令人惊叹的调用：
- en: '![Figure 10.3.png](img/B19665_10_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.3.png](img/B19665_10_03.png)'
- en: 'Figure 10.3: Don’t reuse virtual threads'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：不要重用虚拟线程
- en: 'Cut this out and stick it somewhere so that you see it every day! So in structured
    concurrency, **don’t reuse virtual threads**. I know what you are thinking: *hey
    dude, threads are expensive and limited, so we have to reuse them*. A quick hint:
    we are talking about *virtual threads* (massive throughput), not *classical threads*,
    but the virtual threads topic is covered in the next problem.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将其剪下来贴在某个地方，以便你每天都能看到！所以在结构化并发中，**不要重用虚拟线程**。我知道你在想什么：*嘿，兄弟，线程很贵，而且有限，所以我们必须重用它们*。一个快速提示：我们谈论的是*虚拟线程*（大量吞吐量），而不是*经典线程*，但虚拟线程的话题将在下一个问题中介绍。
- en: 211\. Introducing virtual threads
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 211. 虚拟线程的引入
- en: 'Java allows us to write multithreaded applications via the `java.lang.Thread`
    class. These are classical Java threads that are basically just thin wrappers
    of OS (kernel) threads. As you’ll see, these classical Java threads are referred
    to as *platform threads*, and they have been available for quite a long time (since
    JDK 1.1, as the following diagram reveals):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许我们通过`java.lang.Thread`类编写多线程应用程序。这些是经典的Java线程，基本上只是操作系统（内核）线程的薄包装。正如你将看到的，这些经典Java线程被称为*平台线程*，并且已经存在很长时间了（自从JDK
    1.1以来，如下面的图所示）：
- en: '![Figure 10.4.png](img/B19665_10_04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.4.png](img/B19665_10_04.png)'
- en: 'Figure 10.4: JDK multithreading evolution'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：JDK多线程演变
- en: Next, let’s move on to JDK 19 virtual threads.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续了解JDK 19虚拟线程。
- en: What’s the problem with platform (OS) threads?
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台（操作系统）线程有什么问题？
- en: OS threads are expensive in every single way, or more specifically, they are
    costly in terms of time and space. Creating OS threads is, therefore, a costly
    operation that requires a lot of stack space (around 20 megabytes) to store their
    context, Java call stacks, and additional resources. Moreover, the OS thread scheduler
    is responsible for scheduling Java threads, which is another costly operation
    that requires moving around a significant amount of data. This is referred to
    as *thread context switching.*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统线程在各个方面都很昂贵，或者更具体地说，它们在时间和空间上都很昂贵。因此，创建操作系统线程是一个昂贵的操作，需要大量的堆栈空间（大约20兆字节）来存储它们的上下文、Java调用栈和额外的资源。此外，操作系统线程调度器负责调度Java线程，这是另一个昂贵的操作，需要移动大量的数据。这被称为*线程上下文切换*。
- en: 'In the following figure, you can see the one-to-one relationship between a
    Java thread and an OS thread:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到Java线程和操作系统线程之间的一对一关系：
- en: '![Figure 10.4.png](img/B19665_10_05.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.4.png](img/B19665_10_05.png)'
- en: 'Figure 10.5: JVM to OS threads'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：JVM到操作系统线程
- en: For decades, our multithreaded applications have run in this context. All this
    time and experience taught us that we can create a limited number of Java threads
    (because of low throughput) and that we should reuse them wisely. The number of
    Java threads is a limiting factor that is usually exhausted before other resources,
    such as network connections, CPU, and so on. Java doesn’t differentiate between
    threads that perform intensive computational tasks (i.e., threads that really
    exploit the CPU) or those that just wait for data (i.e., they just hang on the
    CPU).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，我们的多线程应用程序一直在这个环境中运行。所有这些时间和经验教会了我们，我们可以创建有限数量的Java线程（因为吞吐量低），而且我们应该明智地重用它们。Java线程的数量是一个限制因素，通常在诸如网络连接、CPU等其他资源耗尽之前就已经用完。Java不会区分执行密集计算任务（即真正利用CPU的线程）或仅仅等待数据的线程（即它们只是挂载在CPU上）。
- en: Let’s do a quick exercise. Let’s assume that our machine has 8 GB of memory,
    and a single Java thread needs 20 MB. This means that we have room for around
    400 Java threads (8 GB = 8,000 MB / 20 MB = 400 threads). Next, let’s assume that
    these threads perform I/O operations over a network. Each I/O operation needs
    around 100 ms to complete, while the request preparation and response processing
    needs around 500 ns. So a thread works for 1,000 ns (0.001 ms) and then waits
    for 100 ms (100,000,000 ns) for the I/O operation to complete. This means that
    at 8 GB of memory, the 400 threads will use 0.4% of CPU availability (under 1%),
    which is very low. We can conclude that a thread is idle for 99.99% of the time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个快速练习。假设我们的机器有8 GB的内存，而单个Java线程需要20 MB。这意味着我们大约有400个Java线程的空间（8 GB = 8,000
    MB / 20 MB = 400 threads）。接下来，假设这些线程在网络上进行I/O操作。每个I/O操作需要大约100 ms才能完成，而请求准备和响应处理需要大约500
    ns。所以一个线程工作1,000 ns（0.001 ms），然后等待100 ms（100,000,000 ns）以完成I/O操作。这意味着在8 GB的内存中，400个线程将使用0.4%的CPU可用性（低于1%），这非常低。我们可以得出结论，线程有99.99%的时间是空闲的。
- en: Based on this exercise, it is quite obvious that Java threads become a bottleneck
    in throughput that doesn’t allow us to solicit hardware at full capacity. Of course,
    we can sweeten the situation a little bit by using *thread pools* to minimize
    the costs, but it still does not solve the major issues of dealing with resources.
    You have to go for `CompletableFuture`, reactive programming (for instance, Spring
    `Mono` and `Flux`), and so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个练习，很明显，Java线程成为了吞吐量的瓶颈，这不允许我们充分利用硬件。当然，我们可以通过使用*线程池*来最小化成本来改善这种情况，但这仍然不能解决处理资源的主要问题。你必须转向`CompletableFuture`、响应式编程（例如，Spring的`Mono`和`Flux`）等等。
- en: 'However, how many classical Java threads can we create? We can easily find
    out by running a simple snippet of code, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以创建多少个传统的Java线程呢？我们可以通过运行一个简单的代码片段来轻松找出，如下所示：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, if we want to taste from the new concurrent API, we can call
    the new `Thread.ofPlatform()` method, as follows (`OfPlatform` is a `sealed` interface,
    introduced in JDK 19):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想尝试新的并发API，我们可以调用新的`Thread.ofPlatform()`方法，如下所示（`OfPlatform`是一个`sealed`接口，在JDK
    19中引入）：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On my machine, I got an `OutOfMemoryError` after around 40,000 Java threads.
    Depending on your OS and hardware, this number may vary.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我在大约40,000个Java线程后遇到了`OutOfMemoryError`。根据你的操作系统和硬件，这个数字可能会有所不同。
- en: The `Thread.ofPlatform()` method was added in JDK 19 to easily distinguish between
    Java threads (i.e., classical Java threads as we have known them for decades –
    thin wrappers of OS threads) and the new kids in town, virtual threads.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.ofPlatform()`方法是在JDK 19中添加的，以便轻松区分Java线程（即，几十年来我们所知道的经典Java线程——操作系统线程的薄包装）和城中新来的孩子，虚拟线程。'
- en: What are virtual threads?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是虚拟线程？
- en: 'Virtual threads were introduced in JDK 19 as a preview (JEP 425), and they
    became a final feature in JDK 21 (JEP 444). Virtual threads run on top of platform
    threads in a one-to-many relationship, while the platform threads run on top of
    OS threads in a one-to-one relationship, as shown in the following figure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程是在JDK 19中作为预览版（JEP 425）引入的，并在JDK 21中成为最终特性（JEP 444）。虚拟线程在平台线程之上运行，形成一对一的关系，而平台线程在操作系统线程之上运行，形成一对一的关系，如下面的图所示：
- en: '![Figure 10.5.png](img/B19665_10_06.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5.png](img/B19665_10_06.png)'
- en: 'Figure 10.6: Virtual threads architecture'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：虚拟线程架构
- en: If we break this figure down into a few words, then we can say that JDK maps
    a large number of virtual threads to a small number of OS threads.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个概念分解成几个词，那么我们可以这样说，JDK将大量虚拟线程映射到少量操作系统线程。
- en: 'Before creating a virtual thread, let’s see two important notes that will help
    us to quickly understand the fundamentals of virtual threads. First, let’s have
    a quick note about a virtual thread’s memory footprint:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建虚拟线程之前，让我们看看两个重要的注意事项，这将帮助我们快速了解虚拟线程的基本原理。首先，让我们快速了解一下虚拟线程的内存占用：
- en: '**Important note**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要注意事项**'
- en: Virtual threads are not wrappers of OS threads. They are lightweight Java entities
    (they have their own stack memory with a small footprint – only a few hundred
    bytes) that are cheap to create, block, and destroy (creating a virtual thread
    is around 1,000 times cheaper than creating a classical Java thread). There can
    be many of them at the same time (millions) so that they sustain a massive throughput.
    Virtual threads should not be reused (they are disposable) or pooled.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程不是操作系统线程的包装器。它们是轻量级的Java实体（它们有自己的堆栈内存，占用空间很小——只有几百字节），创建、阻塞和销毁成本低（创建虚拟线程的成本大约是创建经典Java线程的1,000倍）。可以同时存在很多虚拟线程（数百万），从而实现巨大的吞吐量。虚拟线程不应重复使用（它们是一次性的）或池化。
- en: When we talk about virtual threads, there are more things that we should unlearn
    than things that we should learn. But where are virtual threads stored, and who’s
    responsible for scheduling them accordingly?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论虚拟线程时，我们应该忘记的东西比应该学习的东西更多。但虚拟线程存储在哪里，谁负责相应地调度它们？
- en: '**Important note**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Virtual threads are stored in the JVM heap (so they take advantage of Garbage
    Collector) instead of the OS stack. Moreover, virtual threads are scheduled by
    the JVM via a *work-stealing* `ForkJoinPool` scheduler. Practically, JVM schedules
    and orchestrates virtual threads to run on platform threads in such a way that
    a platform thread executes only one virtual thread at a time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程存储在JVM堆中（因此它们可以利用垃圾收集器），而不是操作系统堆栈。此外，虚拟线程由JVM通过一个*工作窃取*的`ForkJoinPool`调度器进行调度。实际上，JVM以这种方式调度和编排虚拟线程在平台线程上运行，使得一个平台线程一次只执行一个虚拟线程。
- en: Next, let’s create a virtual thread.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个虚拟线程。
- en: Creating a virtual thread
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟线程
- en: 'From the API perspective, a virtual thread is another flavor of `java.lang.Thread`.
    If we dig a little bit via `getClass()`, we can see that a virtual thread class
    is `java.lang.VirtualThread`, which is a `final` non-public class that extends
    the `BaseVirtualThread` class, which, in turn, is a `sealed abstract` class that
    extends `java.lang.Thread`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从API的角度来看，虚拟线程是`java.lang.Thread`的另一种风味。如果我们通过`getClass()`深入研究，我们可以看到虚拟线程类是`java.lang.VirtualThread`，它是一个`final`的非公开类，继承自`BaseVirtualThread`类，而`BaseVirtualThread`是一个`sealed
    abstract`类，继承自`java.lang.Thread`：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s consider that we have the following task (`Runnable`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下任务（`Runnable`）：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating and starting a virtual thread
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建和启动虚拟线程
- en: 'We can create and start a virtual thread for our task via the `startVirtualThread(Runnable
    task)` method, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`startVirtualThread(Runnable task)`方法创建并启动一个虚拟线程，如下所示：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The returned `vThread` is scheduled for execution by the JVM itself. But we
    can also create and start a virtual thread via `Thread.ofVirtual()`, which returns
    `OfVirtual` (the `sealed` interface introduced in JDK 19), as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`vThread`由JVM本身调度执行。但我们可以通过`Thread.ofVirtual()`创建并启动一个虚拟线程，它返回`OfVirtual`（JDK
    19中引入的`sealed`接口），如下所示：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, `vThread` will solve our `task`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`vThread`将解决我们的`task`。
- en: 'Moreover, we have the `Thread.Builder` interface (and `Thread.Builder.OfVirtual`
    subinterface) that can be used to create a virtual thread, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有`Thread.Builder`接口（以及`Thread.Builder.OfVirtual`子接口），可以用来创建虚拟线程，如下所示：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is another example of creating two virtual threads via `Thread.Builder`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个通过`Thread.Builder`创建两个虚拟线程的示例：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can check out these examples further in the bundled code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中进一步查看这些示例。
- en: Waiting for a virtual task to terminate
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等待虚拟任务终止
- en: 'The given `task` is executed by a virtual thread, while the main thread is
    not blocked. In order to wait for the virtual thread to terminate, we have to
    call one of the `join()` flavors. We have `join()` without arguments that waits
    indefinitely, and a few flavors that wait for a given time (for instance, `join(Duration
    duration)` and `join(long millis)`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的`task`由虚拟线程执行，而主线程不会被阻塞。为了等待虚拟线程终止，我们必须调用`join()`的一个变体。我们有不带参数的`join()`，它会无限期地等待，以及几个等待给定时间的变体（例如，`join(Duration
    duration)`和`join(long millis)`）：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These methods throw an `InterruptedException`, so you have to catch it and handle
    it (or just throw it). Now, because of `join()`, the main thread cannot terminate
    before the virtual thread. It has to wait until the virtual thread completes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法会抛出`InterruptedException`，所以你必须捕获并处理它（或者只是抛出它）。现在，由于`join()`，主线程不能在虚拟线程完成之前终止。它必须等待虚拟线程完成。
- en: Creating an unstarted virtual thread
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建未启动的虚拟线程
- en: 'Creating an unstarted virtual thread can be done via `unstarted(Runnable task)`,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个未启动的虚拟线程可以通过`unstarted(Runnable task)`来完成，如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or via `Thread.Builder` as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过`Thread.Builder`，如下所示：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This time, the thread is not scheduled for execution. It will be scheduled
    for execution only after we explicitly call the `start()` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，线程没有被安排执行。它只有在显式调用`start()`方法后才会被安排执行：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can check if a thread is alive (i.e., it was started but not terminated)
    via the `isAlive()` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`isAlive()`方法检查一个线程是否是活动的（即它已经被启动但尚未终止）：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `unstarted()` method is available for platform threads as well (there is
    also the `Thread.Builder.OfPlatform` subinterface):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`unstarted()`方法也适用于平台线程（还有`Thread.Builder.OfPlatform`子接口）：'
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can start `pThread` by calling the `start()` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`start()`方法来启动`pThread`。
- en: Creating a ThreadFactory for virtual threads
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为虚拟线程创建ThreadFactory
- en: 'You can create a `ThreadFactory` of virtual threads, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个虚拟线程的`ThreadFactory`，如下所示：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or, via `Thread.Builder`, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过`Thread.Builder`，如下所示：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And a `ThreadFactory` for platform threads, as follows (you can use `Thread.Builder`
    as well):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个平台线程的`ThreadFactory`，如下所示（你也可以使用`Thread.Builder`）：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or a `ThreadFactory` that we can use to switch between virtual/platform threads,
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个我们可以用来在虚拟/平台线程之间切换的`ThreadFactory`，如下所示：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we can use any of these factories via the `ThreadFactory.newThread(Runnable
    task)`, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过`ThreadFactory.newThread(Runnable task)`使用这些工厂中的任何一个，如下所示：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the thread factory starts the created thread as well, then there is no need
    to explicitly call the `start()` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程工厂同时启动创建的线程，那么就没有必要显式地调用`start()`方法。
- en: Checking a virtual thread’s details
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查虚拟线程的详细信息
- en: 'Moreover, we can check if a certain thread is a platform thread or a virtual
    thread via `isVirtual()`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过`isVirtual()`方法检查某个线程是否是平台线程或虚拟线程：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Obviously, only `vThread` is a virtual thread.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，只有`vThread`是虚拟线程。
- en: '*A virtual thread always runs as a daemon thread.* The `isDaemon()` method
    returns `true`, and trying to call `setDaemon(false)` will throw an exception.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟线程总是以守护线程的方式运行*。`isDaemon()`方法返回`true`，尝试调用`setDaemon(false)`会抛出异常。'
- en: '*The priority of a virtual thread is always* `NORM_PRIORITY` (calling `getPriority()`
    always returns `5` – constant `int` for `NORM_PRIORITY`). Calling `setPriority()`
    with a different value has no effect.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟线程的优先级总是* `NORM_PRIORITY`（调用`getPriority()`总是返回`5` – `NORM_PRIORITY`的常量`int`）。使用不同的值调用`setPriority()`没有效果。'
- en: '*A virtual thread cannot be part of a thread group* because it already belongs
    to the *VirtualThreads* group. Calling `getThreadGroup().getName()` returns *VirtualThreads*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟线程不能成为线程组的一部分*，因为它已经属于*VirtualThreads*组。调用`getThreadGroup().getName()`会返回*VirtualThreads*。'
- en: A virtual thread has no permission with Security Manager (which is deprecated
    anyway).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程在安全管理器中没有权限（安全管理器已经被弃用）。
- en: Printing a thread (toString())
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打印一个线程（toString()）
- en: 'If we print a virtual thread (calling the `toString()` method), then the output
    will be something like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印一个虚拟线程（调用`toString()`方法），那么输出将类似于以下内容：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In a nutshell, this output can be interpreted as follows: `VirtualThread[#22]`
    indicates that this is a virtual thread that contains the thread identifier (`#22`)
    with no name (in the case of `VirtualThread[#26,vt-0]`, the id is `#26` and the
    name is `vt-0`). Then, we have the `runnable` text, which indicates the state
    of the virtual thread (`runnable` means that the virtual thread is running). Next,
    we have the *carrier thread* of the virtual thread, which is a platform thread;
    `ForkJoinPool-1-worker-1` contains the platform thread name (`worker-1`) of the
    default `ForkJoinPool` (`ForkJoinPool-1`).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个输出可以这样解释：`VirtualThread[#22]`表示这是一个包含线程标识符（`#22`）且没有名称的虚拟线程（在`VirtualThread[#26,vt-0]`的情况下，标识符是`#26`，名称是`vt-0`）。然后，我们有`runnable`文本，它表示虚拟线程的状态（`runnable`表示虚拟线程正在运行）。接下来，我们有虚拟线程的*承载线程*，这是一个平台线程；`ForkJoinPool-1-worker-1`包含了默认`ForkJoinPool`（`ForkJoinPool-1`）的平台线程名称（`worker-1`）。
- en: How many virtual threads we can start
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们可以启动多少个虚拟线程
- en: 'Finally, let’s run code that allows us to see how many virtual threads we can
    create and start:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们运行一些代码，以便我们可以看到我们可以创建和启动多少个虚拟线程：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On my machine, this code started to slow down after around 14,000,000 virtual
    threads. It continues to run slowly while memory becomes available (Garbage Collector
    is in action), but it didn’t crash. So a massive throughput!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，当大约有 14,000,000 个虚拟线程时，这段代码开始变慢。当内存可用时（垃圾收集器正在运行），它继续缓慢运行，但没有崩溃。所以这是一个巨大的吞吐量！
- en: Backward compatibility
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向后兼容性
- en: 'Virtual threads are compatible with:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程与以下兼容：
- en: Synchronized blocks
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步块
- en: Thread-local variables
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程局部变量
- en: '`Thread` and `currentThread()`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread` 和 `currentThread()`'
- en: Thread interruption (`InterruptedException`)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程中断（`InterruptedException``）
- en: Basically, virtual threads work out of the box once you update to at least JDK
    19\. They heavily sustain a clean, readable, and more structured code, being the
    bricks behind the structured concurrency paradigm.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一旦你更新到至少 JDK 19，虚拟线程就会自动工作。它们极大地支持干净、可读和更有结构的代码，是结构化并发范式背后的基石。
- en: Avoiding fake conclusions (potentially myths)
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免错误的结论（可能是神话）
- en: 'There are a few fake conclusions about virtual threads that we should consider
    as follow:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于虚拟线程有一些错误的结论，我们应该将其视为以下：
- en: '*Virtual threads are faster than platform threads (WRONG!)*: There can be a
    lot of virtual threads, but they are not faster than classical (platform) threads.
    They don’t boost in-memory computational capabilities (for that, we have parallel
    streams). Don’t conclude that virtual threads do some magic that makes them faster
    or more optimal to solve a task. So virtual threads can seriously improve throughput
    (since millions of them can wait for jobs), but they cannot improve latency. However,
    virtual threads can be launched much faster than platform threads (a virtual thread
    has a creation time measured in µs and needs space in the order of kB).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚拟线程比平台线程快（错误！）*：虚拟线程的数量可以很多，但它们并不比经典（平台）线程快。它们不会提升内存计算能力（对于这一点，我们有并行流）。不要得出虚拟线程做了某些魔法使其更快或更优化的结论。因此，虚拟线程可以极大地提高吞吐量（因为数百万个虚拟线程可以等待任务），但它们不能提高延迟。然而，虚拟线程的启动速度比平台线程快得多（虚拟线程的创建时间以微秒计，需要大约千字节的空间）。'
- en: '*Virtual threads should be pooled (WRONG!)*: Virtual threads should not be
    part of any thread pool and should never be pooled.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚拟线程应该被池化（错误！）*：虚拟线程不应成为任何线程池的一部分，也不应该被池化。'
- en: '*Virtual threads are expensive (WRONG!)*: Virtual threads are not for free
    (nothing is for free), but they are cheaper to create, block, and destroy than
    platform threads. A virtual thread is 1,000x cheaper than a platform thread.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚拟线程很昂贵（错误！）*：虚拟线程不是免费的（没有什么是免费的），但它们比平台线程更容易创建、阻塞和销毁。虚拟线程比平台线程便宜 1,000 倍。'
- en: '*Virtual threads can release a task (WRONG!)*: This is not true! A virtual
    thread takes a task and will return a result unless it gets interrupted. It cannot
    release the task.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*虚拟线程可以释放任务（错误！）*：这不是真的！虚拟线程接受一个任务，除非它被中断，否则会返回结果。它不能释放任务。'
- en: '*Blocking a virtual thread blocks its carrier thread (WRONG!)*: Blocking a
    virtual thread doesn’t block its carrier thread. The carrier thread can serve
    other virtual threads.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阻塞虚拟线程会阻塞其承载线程（错误！）*：阻塞虚拟线程不会阻塞其承载线程。承载线程可以服务其他虚拟线程。'
- en: 212\. Using the ExecutorService for virtual threads
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 212. 使用 ExecutorService 进行虚拟线程
- en: Virtual threads allow us to write more expressive and straightforward concurrent
    code. Thanks to the massive throughput obtained via virtual threads, we can easily
    adopt the *task-per-thread* model (for an HTTP server, this means a request per
    thread, for a database, this means a transaction per thread, and so on). In other
    words, we can assign a new virtual thread for each concurrent task.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程允许我们编写更易于表达和理解的并发代码。多亏了虚拟线程带来的巨大吞吐量，我们可以轻松采用 *任务-线程* 模型（对于一个 HTTP 服务器，这意味着每个请求一个线程，对于一个数据库，这意味着每个事务一个线程，等等）。换句话说，我们可以为每个并发任务分配一个新的虚拟线程。
- en: Trying to use the *task-per-thread* model with platform threads will result
    in a throughput limited by the number of hardware cores – this is explained by
    Little’s law ([https://en.wikipedia.org/wiki/Little%27s_law](https://en.wikipedia.org/wiki/Little%27s_law)),
    L = λW, or throughput equals average concurrency multiplied by latency.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用平台线程的 *任务-线程* 模型会导致吞吐量受限于硬件核心的数量——这由 Little 定律（[https://en.wikipedia.org/wiki/Little%27s_law](https://en.wikipedia.org/wiki/Little%27s_law)）解释，L
    = λW，即吞吐量等于平均并发乘以延迟。
- en: Whenever possible, it is recommended to avoid interacting with threads directly.
    JDK sustains this via the `ExecutorService`/`Executor` API. More precisely, we
    are used to submitting a task (`Runnable`/`Callable`) to an `ExecutorService`/`Executor`
    and working with the returned `Future`. This pattern is valid for virtual threads
    as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，建议避免直接与线程交互。JDK 通过 `ExecutorService`/`Executor` API 来维持这一点。更确切地说，我们习惯于将任务（`Runnable`/`Callable`）提交给
    `ExecutorService`/`Executor` 并与返回的 `Future` 一起工作。这种模式对虚拟线程同样适用。
- en: So we don’t have to write ourselves all the plumbing code to adopt the *task-per-thread
    model* for virtual threads because, starting with JDK 19, this model is available
    via the `Executors` class. More precisely, it’s via the `newVirtualThreadPerTaskExecutor()`
    method, which creates an `ExecutorService` capable of creating an unbounded number
    of virtual threads that follow the *task-per-thread* model. This `ExecutorService`
    exposes methods that allow us to give tasks such as the `submit()` (as you’ll
    see next) and `invokeAll`/`Any()` (as you’ll see later) methods, returning a `Future`
    containing an exception or a result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要自己编写所有管道代码来为虚拟线程采用 *任务-线程模型*，因为从 JDK 19 开始，这种模型通过 `Executors` 类提供。更确切地说，是通过
    `newVirtualThreadPerTaskExecutor()` 方法，该方法创建一个能够创建无限数量遵循 *任务-线程* 模型的虚拟线程的 `ExecutorService`。这个
    `ExecutorService` 提供了允许我们给出诸如 `submit()`（您将在下面看到）和 `invokeAll`/`Any()`（您将在稍后看到）方法的方法，返回包含异常或结果的
    `Future`。
- en: '**Important note**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Starting with JDK 19, the `ExecutorService` extends the `AutoCloseable` interface.
    In other words, we can use `ExecutorService` in a `try-with-resources` pattern.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 19 开始，`ExecutorService` 扩展了 `AutoCloseable` 接口。换句话说，我们可以在 `try-with-resources`
    模式中使用 `ExecutorService`。
- en: 'Consider the following simple `Runnable` and `Callable`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的 `Runnable` 和 `Callable`：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Executing the `Runnable`/`Callable` can be done as follows (here, we submit
    15 tasks (`NUMBER_OF_TASKS = 15`)):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `Runnable`/`Callable` 可以如下进行（这里我们提交了 15 个任务 `NUMBER_OF_TASKS = 15`）：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of course, in the case of `Runnable`/`Callable`, we can capture a `Future`
    and act accordingly, via the blocking `get()` method or whatever we want to do:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 `Runnable`/`Callable` 的情况下，我们可以捕获一个 `Future` 并相应地操作，通过阻塞的 `get()` 方法或我们想要做的任何事情：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A possible output looks as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下所示：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Check out the virtual threads’ IDs. They range between #22 and #37 without
    repetition. Each task is executed by its own virtual thread.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '查看虚拟线程的 ID。它们在 #22 和 #37 之间，没有重复。每个任务由其自己的虚拟线程执行。'
- en: 'The *task-per-thread* model is also available for classical threads via `newThreadPerTaskExecutor(ThreadFactory
    threadFactory)`. Here is an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务-线程* 模型也适用于经典线程，通过 `newThreadPerTaskExecutor(ThreadFactory threadFactory)`
    实现。以下是一个示例：'
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, `newThreadPerTaskExecutor()` can be used for classic or virtual
    threads. The number of created threads is unbounded. By simply modifying the thread
    factory, we can switch between virtual/classic threads.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`newThreadPerTaskExecutor()` 可以用于经典线程或虚拟线程。创建的线程数量是无限的。通过简单地修改线程工厂，我们可以在虚拟线程和经典线程之间切换。
- en: 'A possible output looks as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下所示：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Check out the threads’ IDs. They range between #75 and #89 without repetition.
    Each task is executed by its own thread.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '查看线程的 ID。它们在 #75 和 #89 之间，没有重复。每个任务由其自己的线程执行。'
- en: 213\. Explaining how virtual threads work
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 213. 解释虚拟线程的工作原理
- en: Now that we know how to create and start a virtual thread, let’s see how they
    actually work.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建和启动虚拟线程，让我们看看它们实际上是如何工作的。
- en: 'Let’s start with a meaningful diagram:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一张有意义的图开始：
- en: '![Figure 10.6.png](img/B19665_10_07.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6.png](img/B19665_10_07.png)'
- en: 'Figure 10.7: How virtual threads work'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：虚拟线程的工作原理
- en: As you can see, *Figure 10.7* is similar to *Figure 10.6*, except that we have
    added a few more elements.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，*图10.7* 与 *图10.6* 类似，只是我们添加了一些更多元素。
- en: First of all, notice that the platform threads run under a `ForkJoinPool` umbrella.
    This is a **First-In-First-Out** (**FIFO**) dedicated fork/join pool, dedicated
    to scheduling and orchestrating the relationships between virtual threads and
    platform threads (detailed coverage of Java’s fork/join framework is available
    in *Java Coding Problems*, *First Edition*, *Chapter 11*).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意平台线程在 `ForkJoinPool` 的伞下运行。这是一个 **先进先出**（**FIFO**）的专用 fork/join 池，专门用于调度和编排虚拟线程与平台线程之间的关系（Java
    的 fork/join 框架的详细内容可在 *Java 编程问题*，第一版，第 11 章中找到）。
- en: '**Important note**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'This dedicated `ForkJoinPool` is controlled by the JVM, and it acts as the
    virtual thread scheduler based on a FIFO queue. Its initial capacity (i.e., the
    number of threads) is equal to the number of available cores, and it can be increased
    to 256\. The default virtual thread scheduler is implemented in the `java.lang.VirtualThread`
    class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个专门的`ForkJoinPool`由JVM控制，并基于FIFO队列作为虚拟线程调度器。它的初始容量（即线程数）等于可用核心数，可以增加到256。默认的虚拟线程调度器在`java.lang.VirtualThread`类中实现：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Do not confuse this `ForkJoinPool` with the one used for parallel streams (the
    Common Fork Join Pool - `ForkJoinPool.commonPool()`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这个`ForkJoinPool`与用于并行流的那个混淆（公共Fork Join Pool - `ForkJoinPool.commonPool()`）。
- en: Between the virtual threads and the platform threads, there is a one-to-many
    association. Nevertheless, the JVM schedules virtual threads to run on platform
    threads in such a way that only one virtual thread runs on a platform thread at
    a time. When the JVM assigns a virtual thread to a platform thread, the so-called
    *stack chunk object* of the virtual thread is copied from the heap memory on the
    platform thread.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟线程和平台线程之间，存在一种一对一的多对多关联。然而，JVM以这种方式调度虚拟线程在平台线程上运行，即一次只有一个虚拟线程在平台线程上运行。当JVM将一个虚拟线程分配给平台线程时，虚拟线程的所谓*栈块对象*会从平台线程的堆内存中复制过来。
- en: If the code running on a virtual thread encounters a blocking (I/O) operation
    that should be handled by the JVM, then the virtual thread is released by copying
    its *stack chunk object* back into the heap (this operation of copying the *stack
    chunk* between the heap memory and platform thread is the cost of blocking a virtual
    thread - this is much cheaper than blocking a platform thread). Meanwhile, the
    platform thread can run other virtual threads. When the blocking (I/O) of the
    released virtual thread is done, JVM reschedules the virtual thread for execution
    on a platform thread. This can be the same platform thread or another one.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在虚拟线程上运行的代码遇到一个应该由JVM处理的阻塞（I/O）操作，那么虚拟线程将通过将其*栈块对象*复制回堆内存来释放。这种在堆内存和平台线程之间复制*栈块*的操作是阻塞虚拟线程的成本（这比阻塞平台线程便宜得多）。同时，平台线程可以运行其他虚拟线程。当释放的虚拟线程的阻塞（I/O）完成时，JVM将重新调度虚拟线程在平台线程上执行。这可能是在同一个平台线程上，也可能是另一个平台线程。
- en: '**Important note**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The operation of assigning a virtual thread to a platform thread is called *mounting*.
    The operation of unassigning a virtual thread from the platform thread is called
    *unmounting*. The platform thread running the assigned virtual thread is called
    a *carrier thread*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将虚拟线程分配给平台线程的操作称为*挂载*。从平台线程取消分配虚拟线程的操作称为*卸载*。运行分配的虚拟线程的平台线程称为*载体线程*。
- en: 'Let’s see an example that reveals how the virtual threads are mounted:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，揭示虚拟线程是如何挂载的：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, we can configure the `ForkJoinPool` via three system properties, as
    follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过三个系统属性来配置`ForkJoinPool`，如下所示：
- en: '`jdk.virtualThreadScheduler.parallelism` – the number of CPU cores'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.virtualThreadScheduler.parallelism` – CPU核心数'
- en: '`jdk.virtualThreadScheduler.maxPoolSize` – the maximum pool size (256)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.virtualThreadScheduler.maxPoolSize` – 最大池大小（256）'
- en: '`jdk.virtualThreadScheduler.minRunnable` – the minimum number of running threads
    (half the pool size)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.virtualThreadScheduler.minRunnable` – 运行线程的最小数量（池大小的一半）'
- en: In a subsequent problem, we will use these properties to better shape *virtual
    thread context switching* (mounting/unmounting) details.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的问题中，我们将使用这些属性来更好地塑造*虚拟线程上下文切换*（挂载/卸载）的细节。
- en: Capturing virtual threads
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获虚拟线程
- en: So far, we have learned that a virtual thread is mounted by the JVM to a platform
    thread, which becomes its carrier thread. Moreover, the carrier thread runs the
    virtual thread until it hits a blocking (I/O) operation. At that point, the virtual
    thread is unmounted from the carrier thread, and it will be rescheduled after
    the blocking (I/O) operation is done.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到，JVM会将一个虚拟线程挂载到一个平台线程上，这个平台线程成为其载体线程。此外，载体线程会运行虚拟线程，直到它遇到一个阻塞（I/O）操作。在那个时刻，虚拟线程会从载体线程上卸载，并在阻塞（I/O）操作完成后重新调度。
- en: 'While this scenario is true for most of the blocking operations, resulting
    in unmounting the virtual threads and freeing the platform thread (and the underlying
    OS thread), there are a few exceptional cases when the virtual threads are not
    unmounted. There are two main causes for this behavior:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种场景对于大多数阻塞操作都是真实的，导致卸载虚拟线程并释放平台线程（以及底层的操作系统线程），但还有一些异常情况，虚拟线程不会被卸载。这种行为的两个主要原因如下：
- en: Limitations on the OS (for instance, a significant number of filesystem operations)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统（例如，大量的文件系统操作）的限制
- en: Limitations on the JDK (for instance, `Object.wait()`)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK（例如，`Object.wait()`）的限制
- en: When the virtual thread cannot be unmounted from its carrier thread, it means
    that the carrier thread and the underlying OS thread are blocked. This may affect
    the scalability of the application, so if the platform threads pool allows it,
    the JVM can decide to add one more platform thread. So for a period of time, the
    number of platform threads may exceed the number of available cores.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当虚拟线程无法从其承载线程卸载时，这意味着承载线程和底层的操作系统线程被阻塞。这可能会影响应用程序的可伸缩性，因此如果平台线程池允许，JVM 可以决定添加一个额外的平台线程。因此，在一段时间内，平台线程的数量可能会超过可用核心的数量。
- en: Pinning virtual threads
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定虚拟线程
- en: 'There are also two other use cases when a virtual thread cannot be unmounted:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种其他情况，虚拟线程无法卸载：
- en: When the virtual thread runs code inside a `synchronized` method/block
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当虚拟线程在 `synchronized` 方法/块中运行代码时
- en: When the virtual thread invokes a foreign function or native method (a topic
    covered in *Chapter 7*)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当虚拟线程调用外部函数或本地方法（这是第 7 章讨论的主题）
- en: In this scenario, we say that the virtual thread is *pinned* to the carrier
    thread. This may affect the scalability of the application, but the JVM will not
    increase the number of platform threads. Instead of this, we should take action
    and refactor the `synchronized` blocks to ensure that the locking code is simple,
    clear, and short. Whenever possible, we should prefer `java.util.concurrent` locks
    instead of `synchronized` blocks. If we manage to avoid long and frequent locking
    periods, then we will not face any significant scalability issues. In future releases,
    the JDK team aims to eliminate the pinning inside `synchronized` blocks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们说虚拟线程被 *固定* 在承载线程上。这可能会影响应用程序的可伸缩性，但 JVM 不会增加平台线程的数量。相反，我们应该采取行动，重构
    `synchronized` 块，以确保锁定代码简单、清晰、简短。尽可能的情况下，我们应该优先选择 `java.util.concurrent` 锁而不是
    `synchronized` 块。如果我们设法避免了长时间和频繁的锁定周期，那么我们就不会面临任何重大的可伸缩性问题。在未来的版本中，JDK 团队旨在消除
    `synchronized` 块内的固定问题。
- en: 214\. Hooking virtual threads and sync code
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 214. 固定虚拟线程和同步代码
- en: The goal of this problem is to highlight how virtual threads interact with synchronous
    code. For this, we use the built-in `java.util.concurrent.SynchronousQueue`. This
    is a built-in blocking queue that allows only one thread to operate at a time.
    More precisely, a thread that wants to insert an element in this queue is blocked
    until another thread attempts to remove an element from it, and vice versa. Basically,
    a thread cannot insert an element unless another thread attempts to remove an
    element.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的目标是突出虚拟线程如何与同步代码交互。为此，我们使用内置的 `java.util.concurrent.SynchronousQueue`。这是一个内置的阻塞队列，一次只允许一个线程操作。更确切地说，一个想要向这个队列中插入元素的线程将被阻塞，直到另一个线程尝试从其中移除元素，反之亦然。基本上，除非另一个线程尝试移除元素，否则线程无法插入元素。
- en: 'Let’s assume that a virtual thread attempts to insert an element into a `SynchronousQueue`,
    while a platform thread attempts to remove an element from this queue. In code
    lines, we have:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个虚拟线程尝试向 `SynchronousQueue` 中插入一个元素，而一个平台线程尝试从该队列中移除一个元素。在代码行中，我们有：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So the virtual thread (`vThread`) waits for 5 seconds before attempting to
    insert an element into the queue. However, it will not successfully insert an
    element until another thread attempts to remove an element from this queue:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虚拟线程 (`vThread`) 在尝试将元素插入队列之前会等待 5 秒。然而，它只有在另一个线程尝试从该队列中移除元素时才能成功插入元素：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, the `Thread.currentThread()` refers to the main thread of the application,
    which is a platform thread not blocked by `vThread`. This thread successfully
    removes from the queue only if another thread attempts to insert (here, `vThread`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Thread.currentThread()` 指的是应用程序的主线程，这是一个平台线程，不会被 `vThread` 阻塞。只有当另一个线程尝试插入（这里，`vThread`）时，该线程才能成功从队列中移除：
- en: 'The output of this code looks as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The virtual thread started its execution (it is in a *runnable* state), but
    the main thread cannot remove an element from the queue until the virtual thread
    inserts an element, so it is blocked by the `queue.take()` operation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程开始执行（它处于*可运行*状态），但主线程不能从队列中移除元素，直到虚拟线程插入元素，因此它被`queue.take()`操作阻塞：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Meanwhile, the virtual thread sleeps for 5 seconds (currently, the main thread
    has nothing to do), and afterward, it inserts an element:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，虚拟线程睡眠5秒钟（目前主线程没有其他事情要做），然后插入一个元素：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The virtual thread has inserted an element into the queue, so the main thread
    can remove this element from it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程已将一个元素插入队列中，因此主线程可以从其中移除该元素：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The virtual thread is also terminated:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程也被终止：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So virtual threads, platform threads, and synchronous code work as expected.
    In the bundled code, you can find an example where the virtual and platform threads
    switch places. So the platform thread attempts to insert elements, and the virtual
    thread attempts to remove them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虚拟线程、平台线程和同步代码按预期工作。在捆绑的代码中，你可以找到一个示例，其中虚拟线程和平台线程交换位置。所以平台线程尝试插入元素，而虚拟线程尝试移除它们。
- en: 215\. Exemplifying thread context switching
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 215. 展示线程上下文切换
- en: Remember that a virtual thread is mounted on a platform thread, and it is executed
    by that platform thread until a blocking operation occurs. At that point, the
    virtual thread is unmounted from the platform thread, and it will be rescheduled
    for execution by the JVM later on after the blocking operation is done. This means
    that, during its lifetime, a virtual thread can be mounted multiple times on a
    different or the same platform thread.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虚拟线程挂载在平台线程上，并且由该平台线程执行，直到发生阻塞操作。在那个时刻，虚拟线程从平台线程卸载，并在阻塞操作完成后，由JVM稍后重新调度执行。这意味着，在其生命周期内，虚拟线程可以在不同的或相同的平台线程上多次挂载。
- en: In this problem, let’s write several snippets of code meant to capture and exemplify
    this behavior.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，让我们编写几个代码片段，以捕捉和展示这种行为。
- en: Example 1
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例1
- en: 'In the first example, let’s consider the following thread factory that we can
    use to easily switch between the platform and virtual threads:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，让我们考虑以下线程工厂，我们可以用它轻松地在平台线程和虚拟线程之间切换：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we try to execute the following task via 10 platform threads:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试通过10个平台线程执行以下任务：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Between the two logging lines, we have a blocking operation (`sleep()`). Next,
    we rely on `newThreadPerTaskExecutor()` to submit 10 tasks that should log their
    details, sleep for 3 seconds, and log again:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在两条日志行之间，有一个阻塞操作（`sleep()`）。接下来，我们依靠`newThreadPerTaskExecutor()`提交10个任务，这些任务应该记录它们的详细信息，睡眠3秒钟，然后再次记录：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Running this code with platform threads reveals the following side-to-side
    output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用平台线程运行此代码会显示以下侧向输出：
- en: '![Figure 10.7.png](img/B19665_10_08.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.7.png](img/B19665_10_08.png)'
- en: 'Figure 10.8: Using platform threads'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：使用平台线程
- en: By carefully inspecting this figure, we can see that there is a fixed association
    between these numbers. For instance, the task with ID 5 is executed by `Thread-5`,
    the task with ID 3 by `Thread-3`, and so on. After sleeping (i.e., a blocking
    operation), these numbers are unchanged. This means that while the tasks sleep,
    the threads just hang and wait there. They have no work to do.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细检查这个图，我们可以看到这些数字之间存在固定的关联。例如，ID为5的任务由`Thread-5`执行，ID为3的任务由`Thread-3`执行，依此类推。在睡眠（即阻塞操作）之后，这些数字保持不变。这意味着当任务睡眠时，线程只是挂起并等待在那里。它们没有工作可做。
- en: 'Let’s switch from platform threads to virtual threads and then run the code
    again:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从平台线程切换到虚拟线程，然后再次运行代码：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, the output is resumed, as shown in the following figure:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出继续，如图所示：
- en: '![Figure 10.8.png](img/B19665_10_09.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.8.png](img/B19665_10_09.png)'
- en: 'Figure 10.9: Using virtual threads'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：使用虚拟线程
- en: This time, we can see that things are more dynamic. For instance, the task with
    ID 5 is started by a virtual thread executed by `worker-6`, but it is finished
    by `worker-4`. The task with ID 3 is started by a virtual thread executed by `worker-4`,
    but it is finished by `worker-6`. This means that, while a task sleeps (a blocking
    operation), the corresponding virtual thread is unmounted, and its worker can
    serve other virtual threads. When the sleeping is over, the JVM schedules the
    virtual thread for execution and is mounted on another (it could also be the same)
    worker. This is also referred to as *thread context switching*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们可以看到事情更加动态。例如，ID为5的任务由`worker-6`执行的虚拟线程启动，但由`worker-4`完成。ID为3的任务由`worker-4`执行的虚拟线程启动，但由`worker-6`完成。这意味着，当一个任务休眠（一个阻塞操作）时，相应的虚拟线程被卸载，其工作者可以为其他虚拟线程提供服务。当休眠结束后，JVM调度虚拟线程执行，并将其挂载在另一个（也可能是同一个）工作者上。这也被称为*线程上下文切换*。
- en: Example 2
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2
- en: 'In this example, let’s start by limiting the parallelism to 1 (which is like
    having a single core and a single virtual thread):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们首先将并行性限制为1（这就像有一个单核和一个虚拟线程）：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, let’s consider that we have a slow task (we call it slow because it sleeps
    for 5 seconds):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑我们有一个慢速任务（我们称它为慢速任务，因为它休眠了5秒）：
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And then, a fast task (similar to the slow task, but it sleeps for only 1 second):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个快速任务（与慢速任务相似，但它只休眠1秒）：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we define two virtual threads to execute these two tasks, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义两个虚拟线程来执行这两个任务，如下所示：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we run this code, then the output will be as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，输出将如下所示：
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we analyze this output, we can see that the execution starts the slow task.
    The fast task cannot be executed, since `worker-1` (the only available worker)
    is busy executing the slow task:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析这个输出，我们可以看到执行开始执行慢速任务。快速任务无法执行，因为`worker-1`（唯一的可用工作者）正忙于执行慢速任务：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`Worker-1` executes the slow task until this task hits the sleeping operation.
    Since this is a blocking operation, the corresponding virtual thread (#22) is
    unmounted from `worker-1`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker-1`执行慢速任务，直到这个任务遇到休眠操作。由于这是一个阻塞操作，相应的虚拟线程（#22）从`worker-1`卸载：'
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The JVM takes advantage of the fact that `worker-1` is available and pushes
    for the execution of the fast task:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: JVM利用`worker-1`可用的事实，推动快速任务的执行：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The fast task also hits a sleeping operation, and its virtual thread (#24)
    is unmounted:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 快速任务也遇到了一个休眠操作，其虚拟线程（#24）被卸载：
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'However, the fast task sleeps for only 1 second, so its blocking operation
    is over before the slow task blocking operation, which is still sleeping. So the
    JVM can schedule the fast task for execution again, and `worker-1` is ready to
    accept it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，快速任务只休眠1秒，所以它的阻塞操作在慢速任务的阻塞操作之前就结束了，而慢速任务的阻塞操作仍在休眠。因此，JVM可以再次调度快速任务执行，`worker-1`准备接受它：
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At this moment, the fast task is done, and `worker-1` is free. But the slow
    task is still sleeping. After these 5 seconds, the JVM schedules the slow task
    for execution, and `worker-1` is there to take it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，快速任务已经完成，`worker-1`空闲。但慢速任务仍在休眠。在这5秒之后，JVM调度慢速任务执行，`worker-1`在那里等待执行它。
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Done!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: Example 3
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例3
- en: 'This example is just a slight modification of Example 2\. This time, let’s
    consider that the slow task contains a non-blocking operation that runs forever.
    In this case, this operation is simulated via an infinite loop:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只是对示例2的微小修改。这次，让我们考虑慢速任务包含一个永远运行的非阻塞操作。在这种情况下，这个操作通过一个无限循环来模拟：
- en: '[PRE60]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We have a single worker (`worker-1`), and the fast task is the same as in Example
    2\. If we run this code, the execution hangs on, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个单独的工作者(`worker-1`)，快速任务与示例2中的相同。如果我们运行此代码，执行将挂起，如下所示：
- en: '[PRE61]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The execution hangs on because the infinite loop is not seen as a blocking operation.
    In other words, the virtual thread of the slow task (#22) is never unmounted.
    Since there is a single worker, the JVM cannot push for the execution of the fast
    task.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 执行挂起是因为无限循环不被视为阻塞操作。换句话说，慢速任务的虚拟线程（#22）永远不会被卸载。由于只有一个工作者，JVM无法推动快速任务的执行。
- en: If we increase the parallelism from 1 to 2, then the fast task will be successfully
    executed by `worker-2`, while `worker-1` (executing the slow task) will simply
    hang on to a partial execution. We can avoid such situations by relying on a timeout
    join, such as `join(Duration duration)`. This way, after the given timeout, the
    slow task will be automatically interrupted. So pay attention to such scenarios.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将并行性从 1 增加到 2，那么快速任务将由 `worker-2` 成功执行，而 `worker-1`（执行慢速任务）将简单地挂起在部分执行上。我们可以通过依赖超时连接，如
    `join(Duration duration)`，来避免这种情况。这样，在给定超时后，慢速任务将被自动中断。所以请注意这种情况。
- en: 216\. Introducing the ExecutorService invoke all/any for virtual threads – part
    1
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 216. 介绍 ExecutorService invoke all/any for virtual threads – 第 1 部分
- en: In this problem, we won’t spend time on the basics and, instead, jump right
    into how to use `invokeAll()` and `invokeAny()`. If you need a primer on the `ExecutorService`
    API’s `invokeAll()`/`invokeAny()` functions, then you could consider *Java Coding
    Problems*, *First Edition*, *Chapter 10*, *Problem 207*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们不会花费时间在基础知识上，而是直接跳到如何使用 `invokeAll()` 和 `invokeAny()`。如果你需要关于 `ExecutorService`
    API 的 `invokeAll()`/`invokeAny()` 函数的入门，那么你可以考虑 *Java Coding Problems*，*第一版*，*第
    10 章*，*问题 207*。
- en: Working with invokeAll()
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 `invokeAll()` 一起工作
- en: 'In a nutshell, `invokeAll()` executes a collection of tasks (`Callable`) and
    returns a `List<Future>` that holds the results/status of each task. The tasks
    can finish naturally or be forced by a given timeout. Each task can finish successfully
    or exceptionally. Upon return, all the tasks that have not been completed yet
    are automatically canceled. We can check out the status of each task via `Future.isDone()`
    and `Future.isCancelled()`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`invokeAll()` 执行一系列任务（`Callable`），并返回一个 `List<Future>`，它包含每个任务的结果/状态。任务可以自然完成或被给定的超时强制完成。每个任务可以成功完成或异常完成。返回后，所有尚未完成的任务都将自动取消。我们可以通过
    `Future.isDone()` 和 `Future.isCancelled()` 检查每个任务的状态：
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using `invokeAll()` with virtual threads via `newVirtualThreadPerTaskExecutor()`
    (or with `newThreadPerTaskExecutor()`) is straightforward. For instance, here
    we have a simple example of executing three `Callable` instances:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `newVirtualThreadPerTaskExecutor()`（或通过 `newThreadPerTaskExecutor()`）使用 `invokeAll()`
    是直接的。例如，这里我们有一个执行三个 `Callable` 实例的简单示例：
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Have you spotted the `f.state()` call? This API was introduced in JDK 19, and
    it computes the state of a future based on the well-known `get()`, `isDone()`,
    and `isCancelled()`. While we will detail this in a subsequent problem, currently,
    the output is as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到了 `f.state()` 调用？此 API 在 JDK 19 中引入，它根据已知的 `get()`、`isDone()` 和 `isCancelled()`
    计算未来的状态。虽然我们将在后续问题中详细说明，但目前的输出如下：
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The three tasks have successfully completed.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 三项任务已成功完成。
- en: Working with invokeAny()
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 `invokeAny()` 一起工作
- en: 'In a nutshell, `invokeAny()` executes a collection of tasks (`Callable`) and
    strives to return a result corresponding to a task that has successfully terminated
    (before the given timeout, if any). All the tasks that have not been completed
    are automatically canceled:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`invokeAny()` 执行一系列任务（`Callable`），并努力返回与成功终止的任务（在给定的超时之前，如果有）相对应的结果。所有未完成的任务都将自动取消：
- en: '[PRE65]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using `invokeAny()` with virtual threads via `newVirtualThreadPerTaskExecutor()`
    is also straightforward (or with `newThreadPerTaskExecutor()`). For instance,
    here we have a simple example of executing three `Callable` instances when we
    are interested in a single result:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `newVirtualThreadPerTaskExecutor()`（或通过 `newThreadPerTaskExecutor()`）使用 `invokeAny()`
    也是直接的。例如，这里我们有一个在关注单个结果时执行三个 `Callable` 实例的简单示例：
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A possible output might be:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出可能是：
- en: '[PRE67]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This output corresponds to the second `Callable`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出对应于第二个 `Callable`。
- en: In the next problem, we will come up with a more realistic example.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们将提供一个更现实的例子。
- en: 217\. Introducing the ExecutorService invoke all/any for virtual threads – part
    2
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 217. 介绍 ExecutorService invoke all/any for virtual threads – 第 2 部分
- en: Earlier, in *Problem 210*, we wrote a piece of “unstructured” concurrency code
    to build a testing team of three testers, served by an external server.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，在 *问题 210* 中，我们编写了一段“非结构化”的并发代码来构建一个由外部服务器服务的三个测试员的测试团队。
- en: 'Now, let’s try to rewrite the `buildTestingTeam()` method via `invokeAll()`/`Any()`
    and `newVirtualThreadPerTaskExecutor()`. If we rely on `invokeAll()`, then the
    application will attempt to load three testers by ID, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过 `invokeAll()`/`Any()` 和 `newVirtualThreadPerTaskExecutor()` 重新编写
    `buildTestingTeam()` 方法。如果我们依赖于 `invokeAll()`，那么应用程序将尝试通过 ID 加载三个测试员，如下所示：
- en: '[PRE68]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We have three testers with IDs 1, 2, and 3\. So the output will be:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个测试员，ID分别为1、2和3。所以输出将是：
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the next problem, we will see how we can make decisions based on task state.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们将看到如何根据任务状态做出决策。
- en: 'If we can handle the testing phase even with a single tester, then we can rely
    on `invokeAny()`, as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以即使只有一个测试员也能处理测试阶段，那么我们可以依赖`invokeAny()`，如下所示：
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This code will return a single result representing one of these three testers.
    If none of them is available, then we will get a `UserNotFoundException`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将返回一个代表这三个测试员之一的单个结果。如果他们中没有人可用，那么我们将得到一个`UserNotFoundException`。
- en: 218\. Hooking task state
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 218. 钩子任务状态
- en: 'Starting with JDK 19, we can rely on `Future.state()`. This method computes
    the state of a `Future` based on the well-known `get()`, `isDone()`, and `isCancelled()`,
    returning a `Future.State` enum entry, as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 19开始，我们可以依赖`Future.state()`。此方法根据已知的`get()`、`isDone()`和`isCancelled()`计算`Future`的状态，返回一个`Future.State`枚举项，如下所示：
- en: '`CANCELLED` – the task was canceled.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CANCELLED` – 任务已被取消。'
- en: '`FAILED` – the task was completed exceptionally (with an exception).'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAILED` – 任务异常完成（带有异常）。'
- en: '`RUNNING` – the task is still running (has not been completed).'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNING` – 任务仍在运行（尚未完成）。'
- en: '`SUCCESS` – the task was completed normally with a result (no exception).'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUCCESS` – 任务正常完成并返回结果（没有异常）。'
- en: 'In the following snippet of code, we analyze the state of loading the testing
    team members and act accordingly:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们分析加载测试团队成员的状态，并据此采取行动：
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We know that when the execution reaches the `switch` block, the `Future` objects
    should be completely normal or exceptional. So if the current `Future` state is
    `RUNNING`, then this is a really weird situation (possibly a bug), and we throw
    an `IllegalStateException`. Next, if the `Future` state is `SUCCESS` (`fetchTester(2)`),
    then we have a result that can be obtained via `resultNow()`. This method was
    added in JDK 19, and it is useful when we know that we have a result. The `resultNow()`
    method returns immediately without waiting (as `get()`). If the state is `FAILED`
    (`fetchTester(Integer.MAX_VALUE)`), then we log the exception via `exceptionNow()`.
    This method was also added in JDK 19, and it returns immediately the underlying
    exception of a failed `Future`. Finally, if the `Future` was canceled, then there
    is nothing to do. We just report it in the log.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道当执行达到`switch`块时，`Future`对象应该是完全正常或异常的。所以如果当前的`Future`状态是`RUNNING`，那么这是一个非常奇怪的情况（可能是错误），我们抛出`IllegalStateException`。接下来，如果`Future`状态是`SUCCESS`（`fetchTester(2)`），那么我们可以通过`resultNow()`获取结果。此方法是在JDK
    19中添加的，当我们知道有结果时很有用。`resultNow()`方法立即返回，不等待（就像`get()`一样）。如果状态是`FAILED`（`fetchTester(Integer.MAX_VALUE)`），那么我们通过`exceptionNow()`记录异常。此方法也是在JDK
    19中添加的，它立即返回失败`Future`的底层异常。最后，如果`Future`被取消，那么就没有什么可做的。我们只需在日志中报告即可。
- en: 219\. Combining newVirtualThreadPerTaskExecutor() and streams
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 219. 结合newVirtualThreadPerTaskExecutor()和Streams
- en: 'Streams and `newVirtualThreadPerTaskExecutor()` is a handy combination. Here
    is an example that relies on `IntStream` to submit 10 simple tasks and collect
    the returned `List` of `Future` instances:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Streams和`newVirtualThreadPerTaskExecutor()`是一个方便的组合。以下是一个示例，它依赖于`IntStream`提交10个简单的任务，并收集返回的`Future`实例的`List`：
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we wait for each `Future` to complete by calling the `get()` method:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用`get()`方法等待每个`Future`完成：
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Moreover, using stream pipelines is quite useful in combination with `invokeAll()`.
    For instance, the following stream pipeline returns a `List` of results (it filters
    all `Future` instances that haven’t completed successfully):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用流管道与`invokeAll()`结合相当有用。例如，以下流管道返回一个结果列表（它过滤了所有未成功完成的`Future`实例）：
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Alternatively, we can write the following solution (without `mapMulti()`):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以编写以下解决方案（不使用`mapMulti()`）：
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Of course, if `List<Object>` is all you need, then you can go straight ahead
    via `Future::resultNow`, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你只需要`List<Object>`，那么你可以直接通过`Future::resultNow`进行，如下所示：
- en: '[PRE76]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'On the other hand, you may need to collect all the `Future` that has been completed
    exceptionally. This can be achieved via `exceptionNow()`, as follows (we intentionally
    sneaked into the given `List<Callable>` a `Callable` that will generate an `StringIndexOutOfBoundsException`,
    `() -> "pass02".substring(50)`):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可能需要收集所有异常完成的`Future`。这可以通过`exceptionNow()`实现，如下所示（我们故意在给定的`List<Callable>`中添加了一个将生成`StringIndexOutOfBoundsException`的`Callable`，`()
    -> "pass02".substring(50)`）：
- en: '[PRE77]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you don’t prefer `mapMulti()`, then rely on the classical approach:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢`mapMulti()`，那么就依靠经典方法：
- en: '[PRE78]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can find all these examples in the bundled code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中找到所有这些示例。
- en: 220\. Introducing a scope object (StructuredTaskScope)
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 220. 介绍范围对象（StructuredTaskScope）
- en: So far, we have covered a bunch of problems that use virtual threads directly
    or indirectly via an `ExecutorService`. We already know that virtual threads are
    cheap to create and block and that an application can run millions of them. We
    don’t need to reuse them, pool them, or do any fancy stuff. *Use and throw* is
    the proper and recommended way to deal with virtual threads. This means that virtual
    threads are very useful for expressing and writing asynchronous code, which is
    commonly based on a lot of threads that are capable of blocking/unblocking several
    times in a short period. On the other hand, we know that OS threads are expensive
    to create, very expensive to block, and are not easy to put into an asynchronous
    context.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了一系列直接或间接通过`ExecutorService`使用虚拟线程的问题。我们已经知道虚拟线程创建成本低，阻塞成本低，并且应用程序可以运行数百万个。我们不需要重用它们，池化它们，或做任何花哨的事情。"使用后丢弃"是处理虚拟线程的正确和推荐方式。这意味着虚拟线程非常适合表达和编写基于大量线程的异步代码，这些线程在短时间内可以多次阻塞/解除阻塞。另一方面，我们知道创建OS线程成本高昂，阻塞成本非常高，并且不容易将其放入异步上下文中。
- en: Before virtual threads (so for many, many years), we had to manage the life
    cycle of OS threads via an `ExecutorService`/`Executor`, and we could write asynchronous
    (or reactive) code via *callbacks* (you can find detailed coverage of asynchronous
    programming in *Java Coding Problems*, *First Edition*, *Chapter 11*).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟线程（所以对于很多人来说，很多年）之前，我们必须通过`ExecutorService`/`Executor`来管理OS线程的生命周期，并且我们可以通过*回调*来编写异步（或响应式）代码（你可以在*Java编码问题*，*第一版*，*第11章*中找到异步编程的详细说明）。
- en: However, asynchronous/reactive code is hard to write/read, very hard to debug
    and profile, and almost deadly hard to unit-test. Nobody wants to read and fix
    your asynchronous code! Moreover, once we start to write an application via asynchronous
    callback, we tend to use this model for all tasks, even for those that shouldn’t
    be asynchronous. We can easily fall into this trap when we need to somehow link
    asynchronous code/results to non-asynchronous code. And the easiest way to do
    it is to go only for asynchronous code.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异步/响应式代码难以编写/阅读，非常难以调试和性能分析，并且几乎难以进行单元测试。没有人愿意阅读和修复你的异步代码！此外，一旦我们开始通过异步回调编写应用程序，我们往往会将此模型用于所有任务，即使对于那些不应该异步的任务也是如此。当我们需要将异步代码/结果与同步代码以某种方式链接时，我们很容易陷入这种陷阱。而实现它的最简单方法就是只使用异步代码。
- en: So is there a better way? Yes, there is! Structured concurrency is the answer.
    Structured concurrency started as an *incubator* project and reached the *preview*
    stage in JDK 21 (JEP 453).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有没有更好的方法呢？是的，有！结构化并发就是答案。结构化并发最初是一个*孵化器*项目，并在JDK 21（JEP 453）中达到了*预览*阶段。
- en: 'And, in this context, we should introduce `StructuredTaskScope`. A `StructuredTaskScope`
    is a virtual thread launcher for `Callable` tasks that returns a `Subtask`. A
    subtask is an extension of the well-known `Supplier<T>` functional interface represented
    by the `StructuredTaskScope.Subtask<T>` interface and forked with `StructuredTaskScope.fork(Callable
    task)`. It follows and works based on the fundamental principle of structured
    concurrency (see *Problem 210*): “*When a task has to be solved concurrently,
    then all the threads needed to solve it are spun and rejoined in the same block
    of code. In other words, all these threads’ lifetimes are bound to the block’s
    scope, so we have clear and explicit entry-exit points for each concurrent code
    block*.” These threads are responsible for running subtasks (`Subtask`) of the
    given task as a single unit of work.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该介绍`StructuredTaskScope`。`StructuredTaskScope`是一个用于`Callable`任务的虚拟线程启动器，它返回一个`Subtask`。子任务是由`StructuredTaskScope.Subtask<T>`接口表示的`Supplier<T>`函数式接口的扩展，并通过`StructuredTaskScope.fork(Callable
    task)`进行分叉。它遵循并基于结构化并发的根本原则（参见*问题210*）："*当任务需要并发解决时，所有解决该任务所需的线程都在同一块代码中启动和重新连接。换句话说，所有这些线程的生命周期都绑定在块的范围内，因此我们为每个并发代码块提供了清晰和明确的入口和出口点*。"这些线程负责以单个工作单元运行给定任务的子任务（`Subtask`）。
- en: 'Let’s look at an example of fetching a single tester (with ID 1) from our web
    server via `StructuredTaskScope`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个通过`StructuredTaskScope`从我们的Web服务器获取单个测试者（ID为1）的示例：
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'First, we create a `StructuredTaskScope` in a `try-with-resources` pattern.
    `StructuredTaskScope` implements `AutoCloseable`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们以`try-with-resources`模式创建一个`StructuredTaskScope`。`StructuredTaskScope`实现了`AutoCloseable`接口：
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `scope` is a wrapper for the virtual threads’ lifetimes. We use the `scope`
    to fork as many virtual threads (subtasks) as needed via the `fork(Callable task)`
    method. Here, we fork only one virtual thread and get back a `Subtask` (forking
    is a non-blocking operation):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`scope`是虚拟线程生命周期的包装器。我们通过`fork(Callable task)`方法使用`scope`来创建所需数量的虚拟线程（子任务）。在这里，我们只创建一个虚拟线程并返回一个`Subtask`（创建是异步操作）：'
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Next, we have to call the `join()` method (or `joinUntil(Instant deadline)`).
    This method waits for all threads (all `Subtask` instances) forked from this `scope`
    (or all threads that have been submitted to this `scope`) to complete, so it is
    a blocking operation. A scope should block only while it waits for its subtasks
    to complete, and this happens via `join()` or `joinUntil()`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须调用`join()`方法（或`joinUntil(Instant deadline)`）。此方法等待从这个`scope`分叉的所有线程（所有`Subtask`实例）以及提交给此`scope`的所有线程完成，因此它是一个阻塞操作。作用域应该只在等待其子任务完成时阻塞，这通过`join()`或`joinUntil()`实现。
- en: '[PRE82]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When the execution passes this line, we know that all threads (all forked `Subtask`)
    forked from this `scope` are complete, with a result or an exception (each subtask
    runs independently, so each of them can complete with a result or an exception).
    Here, we call the non-blocking `get()` method to get the result, but pay attention
    – calling `get()` for a task that did not complete will raise an exception as
    `IllegalStateException(`*"Owner did not join after forking subtask"*`)`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行通过这一行时，我们知道从这个`scope`分叉的所有线程（所有分叉的`Subtask`）都已经完成，无论是以结果还是异常（每个子任务独立运行，因此每个子任务都可以以结果或异常完成）。在这里，我们调用非阻塞的`get()`方法来获取结果，但请注意——对一个未完成的任务调用`get()`将抛出`IllegalStateException(`*"Owner
    did not join after forking subtask"*`)`异常：
- en: '[PRE83]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: On the other hand, we can obtain the exception of a failed task via `exception()`.
    However, if we call `exception()` for a subtask (`Subtask`) that is completed
    with a result, then we will get back an exception as `IllegalStateException(`*"Subtask
    not completed or did not complete with exception"*`)`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以通过`exception()`方法获取失败任务的异常。然而，如果我们对一个以结果完成的子任务调用`exception()`，那么我们将得到一个`IllegalStateException(`*"Subtask
    not completed or did not complete with exception"*`)`异常。
- en: 'So if you are not sure whether your task(s) completed with a result or an exception,
    it is better to call `get()` or `exception()` only after you test the state of
    the corresponding `Subtask`. A state of `SUCCESS` will safely allow you to call
    `get()`, while a state of `FAILED` will safely allow you to call `exception()`.
    So in our case, we may prefer it this way:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你不确定你的任务（们）是否以结果或异常完成，最好是在测试相应的`Subtask`状态之后才调用`get()`或`exception()`。状态为`SUCCESS`将安全地允许你调用`get()`，而状态为`FAILED`将安全地允许你调用`exception()`。因此，在我们的情况下，我们可能更喜欢这种方式：
- en: '[PRE84]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Besides `Subtask.State.SUCCESS` and `Subtask.State.FAILED`, we also have `Subtask.State.UNAVAILABLE`,
    which means that the subtask is not available (for instance, if the subtask is
    still running, then its state is `UNAVAILABLE`, but there could be another cause
    as well).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Subtask.State.SUCCESS`和`Subtask.State.FAILED`之外，我们还有`Subtask.State.UNAVAILABLE`，这意味着子任务不可用（例如，如果子任务仍在运行，则其状态为`UNAVAILABLE`，但也可能有其他原因）。
- en: ExecutorService vs. StructuredTaskScope
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ExecutorService 与 StructuredTaskScope 的比较
- en: The previous code looks like the code that we would write via a classical `ExecutorService`,
    but there are two big differences between these solutions. First of all, an `ExecutorService`
    holds the precious platform threads and allows us to pool them. On the other hand,
    a `StructuredTaskScope` is just a thin launcher for virtual threads that are cheap
    and shouldn’t be pooled. So once we’ve done our job, a `StructuredTaskScope` can
    be destroyed and garbage-collected. Second, an `ExecutorService` holds a single
    queue for all the tasks, and the threads take from this queue whenever they have
    the chance to do so. A `StructuredTaskScope` relies on a fork/join pool, and each
    virtual thread has its own wait queue. However, a virtual thread can steal a task
    from another queue as well. This is known as the *work-stealing* pattern, and
    if you want to read more about it, we covered it in depth in *Java Coding Problem*,
    *First Edition*, *Chapter 11*.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码看起来像是我们会通过经典的`ExecutorService`编写的代码，但这两个解决方案之间有两个很大的区别。首先，`ExecutorService`保留了宝贵的平台线程，并允许我们对其进行池化。另一方面，`StructuredTaskScope`只是一个虚拟线程的薄启动器，虚拟线程便宜且不应进行池化。所以一旦我们完成了工作，`StructuredTaskScope`就可以被销毁并回收垃圾。其次，`ExecutorService`为所有任务保留了一个队列，线程在有机会时从该队列中获取任务。`StructuredTaskScope`依赖于fork/join池，每个虚拟线程都有自己的等待队列。然而，虚拟线程也可以从另一个队列中窃取任务。这被称为*工作窃取*模式，如果你想了解更多关于它的信息，我们已经在*Java编码问题*，*第一版*，*第11章*中进行了深入探讨。
- en: 221\. Introducing ShutdownOnSuccess
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 221. 引入ShutdownOnSuccess
- en: In the previous problem, we introduced `StructuredTaskScope` and used it to
    solve a task via a single virtual thread (a single `Subtask`). Basically, we fetched
    the tester with ID 1 from our server (we had to wait until this one was available).
    Next, let’s assume that we still need a single tester, but not mandatorily the
    one with ID 1\. This time, it could be any of IDs 1, 2, or 3\. We simply take
    the first one that is available from these three, and we cancel the other two
    requests.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个问题中，我们介绍了`StructuredTaskScope`并使用它通过单个虚拟线程（一个`Subtask`）来解决一个任务。基本上，我们从服务器中获取了ID为1的测试者（我们必须等待这个测试者可用）。接下来，假设我们仍然需要一个测试者，但不一定是ID为1的那个。这次，可以是ID为1、2或3中的任何一个。我们只需从这三个中选取第一个可用的，并取消其他两个请求。
- en: 'Especially for such scenarios, we have an extension of `StructuredTaskScope`
    called `StructuredTaskScope.ShutdownOnSuccess`. This scope is capable of returning
    the result of the first task that completes successfully and interrupts the rest
    of the threads. It follows the “invoke any” model and can be used as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在这种场景下，我们有一个`StructuredTaskScope`的扩展，称为`StructuredTaskScope.ShutdownOnSuccess`。这个范围能够返回第一个成功完成的任务的结果，并中断其他线程。它遵循“调用任意”模型，可以使用以下方式：
- en: '[PRE85]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we fork three subtasks (threads) that will compete with each other to
    complete. The first subtask (thread) that completes successfully wins and returns.
    The `result()` method returns this result (if none of the subtasks (threads) complete
    successfully, then it throws an `ExecutionException`).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了三个子任务（线程），它们将相互竞争以完成。第一个成功完成的子任务（线程）获胜并返回。`result()`方法返回这个结果（如果所有子任务（线程）都没有成功完成，则抛出`ExecutionException`）。
- en: 'If we check the state of these three `Subtask`, we can see that one succeeds
    while the other two are unavailable:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查这三个`Subtask`的状态，我们可以看到其中一个成功了，而其他两个不可用：
- en: '[PRE86]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Of course, you don’t need the code that checks/prints the state of each `Subtask`.
    It was added here just to highlight how `ShutdownOnSuccess` works. You don’t even
    need the explicit `Subtask` objects, since we don’t call `get()` or anything else
    from this API. Basically, we can reduce the code to the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不需要检查/打印每个`Subtask`的状态的代码。这里添加它只是为了突出`ShutdownOnSuccess`的工作原理。你甚至不需要显式的`Subtask`对象，因为我们没有从这个API中调用`get()`或其他任何东西。基本上，我们可以将代码简化为以下内容：
- en: '[PRE87]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Done! You just create the scope, fork your subtasks, call `join()`, and collect
    the result. So the scope is really business-focused.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！你只需创建范围，创建子任务，调用`join()`，并收集结果。所以这个范围真的是以业务为中心的。
- en: A task that completes exceptionally under the `ShutdownOnSuccess` umbrella will
    never be chosen to produce a result. However, if all tasks complete exceptionally,
    then we will get an `ExecutionException` that wraps the exception (i.e., the cause)
    of the first completed task.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ShutdownOnSuccess`的范围内异常完成的任务永远不会被选中以产生结果。然而，如果所有任务都异常完成，那么我们将得到一个`ExecutionException`，它封装了第一个完成的任务（即原因）的异常。
- en: 222\. Introducing ShutdownOnFailure
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 222. 引入ShutdownOnFailure
- en: 'As its name suggests, `StructuredTaskScope.ShutdownOnFailure` is capable of
    returning the exception of the first subtask that completes exceptionally and
    interrupts the rest of the subtasks (threads). For instance, we may want to fetch
    the testers with IDs 1, 2, and 3\. Since we need exactly these three testers,
    we want to be informed if any of them are not available and, if so, cancel everything
    (i.e., the remaining threads). The code looks as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`StructuredTaskScope.ShutdownOnFailure`能够返回第一个完成异常的子任务的异常，并中断其余的子任务（线程）。例如，我们可能想要获取ID为1、2和3的测试者。由于我们需要这三个测试者，我们希望得知其中任何一个不可用，如果有的话，取消一切（即剩余的线程）。代码如下：
- en: '[PRE88]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In this example, we intentionally replaced ID 3 with `Integer.MAX_VALUE`. Since
    there is no tester with this ID, the server will throw `UserNotFoundException`.
    This means that the states of the subtasks will reveal that the third subtask
    has failed:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们故意将ID 3替换为`Integer.MAX_VALUE`。由于没有具有此ID的测试者，服务器将抛出`UserNotFoundException`。这意味着子任务的状态将揭示第三个子任务已经失败：
- en: '[PRE89]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Moreover, when we call the `exception()` method, we will get back an `Optional<Throwable>`
    containing this exception (if you’re interested in reading more about this subject,
    in-depth coverage of the `Optional` feature is available in *Java Coding Problems*,
    *First Edition*, *Chapter 12*). If we decide to throw it, then we simply call
    the `throwIfFailed()` method, which wraps the original exception (the cause) in
    an `ExecutionException` and throws it. The message of the exception in our case
    will be:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们调用`exception()`方法时，我们将得到一个包含此异常的`Optional<Throwable>`（如果您对这个主题感兴趣，关于`Optional`功能的深入覆盖可在*Java
    Coding Problems*，第一版，第12章中找到）。如果我们决定抛出它，那么我们只需调用`throwIfFailed()`方法，该方法将原始异常（原因）包装在`ExecutionException`中并抛出。在我们的情况下，异常的消息将是：
- en: '[PRE90]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If we remove the guideline code, then we can compact the previous code, as
    follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除指南代码，那么我们可以将之前的代码压缩如下：
- en: '[PRE91]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If no exception occurs, then `throwIfFailed()` doesn’t do anything, and those
    three testers are available. The result of each `Subtask` is available via the
    non-blocking `Subtask.get()`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生异常，那么`throwIfFailed()`不会做任何事情，这三个测试者都是可用的。每个`Subtask`的结果都可通过非阻塞的`Subtask.get()`获得。
- en: A subtask that completes exceptionally under the `ShutdownOnFailure` umbrella
    will be chosen to produce an exception. However, if all subtasks complete normally,
    then we will not get any exceptions. On the other hand, if no subtasks were completed
    exceptionally but were canceled, then `ShutdownOnFailure` will throw `CancellationException`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ShutdownOnFailure`的覆盖下，一个完成异常的子任务将被选择来产生一个异常。然而，如果所有子任务都正常完成，那么我们将不会得到任何异常。另一方面，如果没有子任务完成异常但被取消，那么`ShutdownOnFailure`将抛出`CancellationException`。
- en: 223\. Combining StructuredTaskScope and streams
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 223. 结合StructuredTaskScope和流
- en: 'If you prefer functional programming, then you’ll be happy to see that streams
    can be used with `StructuredTaskScope` as well. For instance, here we rewrite
    the application from *Problem 221*, using a stream pipeline to fork our tasks:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢函数式编程，那么您会高兴地看到流也可以与`StructuredTaskScope`一起使用。例如，在这里我们重写了*问题221*中的应用程序，使用流管道来分叉我们的任务：
- en: '[PRE92]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Moreover, we can use stream pipelines to collect results and exceptions, as
    follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用流管道来收集结果和异常，如下所示：
- en: '[PRE93]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can find these examples in the bundled code.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑的代码中找到这些示例。
- en: 224\. Observing and monitoring virtual threads
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 224. 观察和监控虚拟线程
- en: Observing and monitoring virtual threads can be done in several ways. First,
    we can use **Java Flight Recorder** (**JFR**) – we introduced this tool in *Chapter
    6*, *Problem 143*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 观察和监控虚拟线程可以通过几种方式完成。首先，我们可以使用**Java Flight Recorder**（**JFR**）——我们在*第6章*，*问题143*中介绍了这个工具。
- en: Using JFR
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JFR
- en: 'Among its reach list of events, JFR can monitor and record the following events
    related to virtual threads:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在其广泛的列表事件中，JFR可以监控和记录以下与虚拟线程相关的事件：
- en: '`jdk.VirtualThreadStart` – this event is recorded when a virtual thread starts
    (by default, it is disabled)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.VirtualThreadStart` – 当虚拟线程开始时（默认情况下，它是禁用的）'
- en: '`jdk.VirtualThreadEnd` – this event is recorded when a virtual thread ends
    (by default, it is disabled)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.VirtualThreadEnd` – 当虚拟线程结束时（默认情况下，它是禁用的）记录此事件'
- en: '`jdk.VirtualThreadPinned` – this event is recorded when a virtual thread is
    parked while pinned (by default, it is enabled with a threshold of 20 ms)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.VirtualThreadPinned` – 当虚拟线程在固定时挂起时（默认情况下，它是启用的，阈值为20毫秒）记录此事件'
- en: '`jdk.VirtualThreadSubmitFailed` – this event is recorded if a virtual thread
    cannot be started or unparked (by default, it is enabled)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.VirtualThreadSubmitFailed` – 如果虚拟线程无法启动或取消挂起（默认情况下是启用的），则记录此事件'
- en: You can find all the JFR events at [https://sap.github.io/SapMachine/jfrevents/](https://sap.github.io/SapMachine/jfrevents/).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://sap.github.io/SapMachine/jfrevents/](https://sap.github.io/SapMachine/jfrevents/)找到所有JFR事件。
- en: 'We start configuring JFR to monitor the virtual threads, by adding to the root
    folder of the application the following `vtEvent.jfc` file:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始配置JFR以监控虚拟线程，通过将以下`vtEvent.jfc`文件添加到应用程序的根目录：
- en: '[PRE94]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, let’s consider the following code (basically, this is the application
    from Problem 216):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑以下代码（基本上，这是问题216的应用程序）：
- en: '[PRE95]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Next, we use `-XX:StartFlightRecording=filename=recording.jfr` to instruct JFR
    to record output in a file named `recording.jfr`, and we continue with `settings=vtEvent.jfc`
    to highlight the configuration file listed previously.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`-XX:StartFlightRecording=filename=recording.jfr`来指示JFR将输出记录到名为`recording.jfr`的文件中，并且我们继续使用`settings=vtEvent.jfc`来突出显示之前列出的配置文件。
- en: 'So the final command is the one from this figure:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 所以最终的命令是来自这个图中的命令：
- en: '![Figure 10.10.png](img/B19665_10_10.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10.png](img/B19665_10_10.png)'
- en: 'Figure 10.10: Running JFR'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：运行JFR
- en: 'JFR has produced a file named `recording.jfr`. We can easily view the content
    of this file via the JFR CLI. The command (`jfr print recording.jfr`) will display
    the content of `recording.jfr`. The content is too large to be listed here (it
    contains three entries for `jdk.VirtualThreadStart` and three for `jdk.VirtualThreadEnd`),
    but here is the event specific to starting a virtual thread:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: JFR生成了一个名为`recording.jfr`的文件。我们可以通过JFR CLI轻松查看此文件的内容。命令(`jfr print recording.jfr`)将显示`recording.jfr`的内容。内容太大，无法在此列出（它包含三个`jdk.VirtualThreadStart`条目和三个`jdk.VirtualThreadEnd`条目），但以下是特定于启动虚拟线程的事件：
- en: '![Figure 10.11.png](img/B19665_10_11.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11.png](img/B19665_10_11.png)'
- en: 'Figure 10.11: JFR event to start a virtual thread'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：启动虚拟线程的JFR事件
- en: 'And, in the next figure, you can see the event recorded to end this virtual
    thread:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个图中，你可以看到记录来结束这个虚拟线程的事件：
- en: '![Figure 10.12.png](img/B19665_10_12.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12.png](img/B19665_10_12.png)'
- en: 'Figure 10.12: JFR event to end a virtual thread'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：结束虚拟线程的JFR事件
- en: Besides the JFR CLI, you can use more powerful tools to consume the virtual
    thread events, such as JDK Mission Control ([https://www.oracle.com/java/technologies/jdk-mission-control.html](https://www.oracle.com/java/technologies/jdk-mission-control.html))
    and the well-known Advanced Management Console ([https://www.oracle.com/java/technologies/advancedmanagementconsole.html](https://www.oracle.com/java/technologies/advancedmanagementconsole.html)).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JFR CLI之外，你还可以使用更强大的工具来消费虚拟线程事件，例如JDK Mission Control ([https://www.oracle.com/java/technologies/jdk-mission-control.html](https://www.oracle.com/java/technologies/jdk-mission-control.html))和知名的Advanced
    Management Console ([https://www.oracle.com/java/technologies/advancedmanagementconsole.html](https://www.oracle.com/java/technologies/advancedmanagementconsole.html))。
- en: To get a stack trace for threads that block while pinned, we can set the system
    property, `jdk.tracePinnedThreads`. A complete (verbose) stack trace is available
    via `-Djdk.tracePinnedThreads=full`, or if all you need is a brief/short stack
    trace, then rely on `-Djdk.tracePinnedThreads=short`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取在固定时阻塞的线程的堆栈跟踪，我们可以设置系统属性`jdk.tracePinnedThreads`。完整的（详细）堆栈跟踪可以通过`-Djdk.tracePinnedThreads=full`获得，或者如果你只需要简短/短的堆栈跟踪，则依靠`-Djdk.tracePinnedThreads=short`。
- en: 'In our example, we can easily get a pinned virtual thread by marking the `fetchTester()`
    method as `synchronized` (remember that a virtual thread cannot be unmounted if
    it runs code inside a `synchronized` method/block):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以通过将`fetchTester()`方法标记为`synchronized`（记住，如果一个虚拟线程在`synchronized`方法/块中运行代码，则无法卸载该虚拟线程）来轻松地获得一个固定的虚拟线程：
- en: '[PRE96]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In this context, JFR will record a pinned virtual thread, as shown in the following
    figure:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，JFR将记录一个固定的虚拟线程，如图所示：
- en: '![Figure 10.12.png](img/B19665_10_13.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12.png](img/B19665_10_13.png)'
- en: 'Figure 10.13: JFR event for a pinned virtual thread'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：固定虚拟线程的JFR事件
- en: 'If we run the application with `-Djdk.tracePinnedThreads=full`, then your IDE
    will print a detailed stack trace that starts as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`-Djdk.tracePinnedThreads=full`运行应用程序，那么你的IDE将打印出以下开始的详细堆栈跟踪：
- en: '[PRE97]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can see the complete output by executing the bundled code. Of course, you
    can get a thread dump and analyze it via several other tools. You may prefer any
    of `jstack`, **Java Mission Control** (**JMC**), `jvisualvm`, or `jcmd`. For instance,
    we can obtain a thread dump in plain text or the JSON format via `jcmd`, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行捆绑的代码来查看完整的输出。当然，您可以使用`jstack`、**Java Mission Control**（**JMC**）、`jvisualvm`或`jcmd`等工具获取线程转储并分析它。您可能更喜欢其中的任何一个。例如，我们可以通过`jcmd`以纯文本或JSON格式获取线程转储，如下所示：
- en: '[PRE98]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Next, let’s play with `jconsole` (JMX) to quickly analyze the performance of
    virtual threads.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`jconsole`（JMX）来快速分析虚拟线程的性能。
- en: Using Java Management Extensions (JMX)
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Java管理扩展（JMX）
- en: Until JDK 20 (inclusive), JMX provided support for monitoring only the platform
    and threads. However, we can still use JMX to observe the performance brought
    by virtual threads in comparison with platform threads.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 直到JDK 20（包括），JMX只提供了监控平台和线程的支持。然而，我们仍然可以使用JMX来观察与平台线程相比虚拟线程带来的性能。
- en: 'For instance, we can use JMX to monitor platform threads at 500 ms each, via
    the following snippet of code:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用JMX以每500毫秒一次的频率监控平台线程，如下面的代码片段所示：
- en: '[PRE99]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We rely on this code in the following three scenarios.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下三种场景中依赖此代码。
- en: Running 10,000 tasks via the cached thread pool executor
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过缓存的线程池执行器运行10,000个任务
- en: '[PRE100]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'On my machine, it took 8,147 ms (8 seconds) to run these 10,000 tasks, using
    at peak 7,729 platform threads. The following screenshot from `jconsole` (JMX)
    reveals this information:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，运行这10,000个任务耗时8,147毫秒（8秒），峰值使用7,729个平台线程。以下`jconsole`（JMX）的截图揭示了这一信息：
- en: '![Figure 10.12.png](img/B19665_10_14.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12.png](img/B19665_10_14.png)'
- en: 'Figure 10.14: Running 10,000 tasks via the cached thread pool executor'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：通过缓存的线程池执行器运行10,000个任务
- en: Next, let’s repeat this test via a fixed thread pool.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过固定线程池重复这个测试。
- en: Running 10,000 tasks via the fixed thread pool executor
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过固定线程池执行器运行10,000个任务
- en: 'Depending on your machine, the previous test may finish successfully, or it
    may result in an `OutOfMemoryError`. We can avoid this unpleasant scenario by
    using a fixed thread pool. For instance, let’s limit the number of platform threads
    to 200 via the following snippet of code:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的机器配置，之前的测试可能成功完成，或者可能导致`OutOfMemoryError`。我们可以通过使用固定线程池来避免这种不愉快的场景。例如，让我们通过以下代码片段将平台线程的数量限制为200：
- en: '[PRE102]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'On my machine, it took 50,190 ms (50 seconds) to run these 10,000 tasks, using
    at peak 216 platform threads. The following screenshot from JMX reveals this information:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，运行这10,000个任务耗时50,190毫秒（50秒），峰值使用216个平台线程。以下JMX的截图揭示了这一信息：
- en: '![Figure 10.13.png](img/B19665_10_15.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13.png](img/B19665_10_15.png)'
- en: 'Figure 10.15: Running 10,000 tasks via the fixed thread pool executor'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：通过固定线程池执行器运行10,000个任务
- en: Obviously, a smaller number of platform threads is reflected in performance.
    If we put 216 workers to do the job of 7,729 workers, of course, it will take
    longer. Next, let’s see how virtual threads will handle this challenge.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，平台线程数量较少会反映在性能上。如果我们用216个工作者来完成7,729个工作者的工作，当然会花费更长的时间。接下来，让我们看看虚拟线程将如何应对这个挑战。
- en: Running 10,000 tasks via the virtual thread per task executor
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过每个任务虚拟线程执行器运行10,000个任务
- en: 'This time, let’s see how the `newVirtualThreadPerTaskExecutor()` can handle
    these 10,000 tasks. The code is straightforward:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们看看`newVirtualThreadPerTaskExecutor()`如何处理这10,000个任务。代码很简单：
- en: '[PRE103]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'On my machine, it took 3,519 ms (3.5 seconds) to run these 10,000 tasks, using
    at peak 25 platform threads. The following screenshot from JMX reveals this information:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，运行这10,000个任务耗时3,519毫秒（3.5秒），峰值使用25个平台线程。以下JMX的截图揭示了这一信息：
- en: '![Figure 10.14.png](img/B19665_10_16.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14.png](img/B19665_10_16.png)'
- en: 'Figure 10.16: Running 10000 tasks via the virtual thread per task executor'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：通过每个任务虚拟线程执行器运行10,000个任务
- en: Wow! How cool is this?! The resulting time is far and away the best in comparison
    with the previous tests, and it uses fewer resources (only 25 platform threads).
    So virtual threads really rock!
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这有多酷？！与之前的测试相比，结果的时间远远是最好的，并且它使用了更少的资源（只有25个平台线程）。所以虚拟线程真的很棒！
- en: 'I also strongly recommend you check out the following benchmark: [https://github.com/colincachia/loom-benchmark/tree/main](https://github.com/colincachia/loom-benchmark/tree/main).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我还强烈推荐您查看以下基准测试：[https://github.com/colincachia/loom-benchmark/tree/main](https://github.com/colincachia/loom-benchmark/tree/main)。
- en: Starting with JDK 21, JMX’s `HotSpotDiagnosticMXBean` was enriched with the
    `dumpThreads(String outputFile, ThreadDumpFormat format)` method. This method
    outputs a thread dump to the given file (`outputFile`) in the given format (`format`).
    The thread dump will contain all platform threads, but it may also contain some
    or all virtual threads.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 21开始，JMX的`HotSpotDiagnosticMXBean`通过`dumpThreads(String outputFile, ThreadDumpFormat
    format)`方法得到了增强。此方法将线程转储输出到指定的文件（`outputFile`），格式为（`format`）。线程转储将包含所有平台线程，但也可能包含一些或所有虚拟线程。
- en: 'In the following code, we attempt to obtain a thread dump for all subtasks
    (threads) of a `StructuredTaskScope`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们尝试获取`StructuredTaskScope`的所有子任务（线程）的线程转储：
- en: '[PRE104]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output file is named `threadDump.json`, and you can find it in the root
    folder of the application. The part of the output that we are interested in is
    partially listed here:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件命名为`threadDump.json`，您可以在应用程序的根目录中找到它。我们感兴趣的部分输出如下所示：
- en: '[PRE105]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'As you can see, we have three virtual threads (#22, #24, and #25) that run
    subtasks of our scope. In the bundled code, you can find the complete output.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有三个虚拟线程（#22、#24和#25）运行我们范围内的子任务。在捆绑的代码中，您可以找到完整的输出。
- en: Summary
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered 16 introductory problems about virtual threads and structured
    concurrency. You can see this chapter as preparation for the next one, which will
    cover more detailed aspects of these two topics.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了关于虚拟线程和结构化并发的16个入门问题。您可以将本章视为下一章的准备，下一章将涵盖这两个主题的更多详细方面。
- en: Join our community on Discord
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ)'
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1139613064111216156.png)'
