- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Concurrency – Virtual Threads and Structured Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发 – 虚拟线程和结构化并发
- en: This chapter includes 16 problems that briefly introduce *virtual threads* and
    *structured concurrency*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括16个问题，简要介绍了*虚拟线程*和*结构化并发*。
- en: If you don’t have a background in concurrency in Java, then I strongly recommend
    postponing this chapter until after you have read some good introductory coverage
    on the topic. For instance, you could try out *Chapters 10* an*d 11* from *Java
    Coding Problems*, *First Edition*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有Java并发的背景知识，我强烈建议你在阅读一些关于该主题的良好入门介绍之后再阅读本章。例如，你可以尝试阅读*Java编码问题*第一版的第*10*章和第*11*章。
- en: '*Virtual threads* are one of the most important and astonishing features added
    by Java in the last few years. They have a significant impact on how we will continue
    to write and understand concurrent code from this point forward. In this chapter,
    you’ll learn, step by step, every single detail of this topic and the *structured
    concurrency* paradigm.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟线程*是Java在过去几年中添加的最重要和最令人惊讶的特性之一。它们对我们继续编写和理解并发代码的方式产生了重大影响。在本章中，你将逐步学习这个主题和*结构化并发*范式的每一个细节。'
- en: After this chapter, you’ll be quite knowledgeable in working with virtual threads
    and structured concurrency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将非常熟悉如何使用虚拟线程和结构化并发。
- en: Problems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess in virtual threads
    and structured concurrency in Java. I strongly encourage you to give each problem
    a try before you turn to the solutions and download the example programs:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在Java虚拟线程和结构化并发方面的编程能力。我强烈鼓励你在查看解决方案和下载示例程序之前尝试解决每个问题：
- en: '**Explaining concurrency vs. parallelism**: Provide a brief but meaningful
    explanation of concurrency vs. parallelism.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解释并发与并行**：提供简明但富有意义的并发与并行的解释。'
- en: '**Introducing structured concurrency**: Write an example highlighting the main
    issues of “unstructured” concurrency. Moreover, provide an introduction to the
    structured concurrency paradigm.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍结构化并发**：编写一个示例，突出“非结构化”并发的关键问题。此外，介绍结构化并发范式。'
- en: '**Introducing virtual threads**: Explain and exemplify the main concepts of
    virtual threads.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍虚拟线程**：解释并举例说明虚拟线程的主要概念。'
- en: '**Using the ExecutorService for virtual threads**: Write several examples that
    highlight the *task-per-thread* model via `ExecutorService` and virtual threads.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用ExecutorService进行虚拟线程**：编写几个示例，通过`ExecutorService`和虚拟线程突出“任务-线程”模型。'
- en: '**Explaining how virtual threads work**: Provide comprehensive coverage of
    how virtual threads work internally.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解释虚拟线程的工作原理**：全面介绍虚拟线程的内部工作原理。'
- en: '**Hooking virtual threads and sync code**: Explain and exemplify via a meaningful
    snippet of code how virtual threads and sync code work together.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**虚拟线程和同步代码的挂钩**：通过一段有意义的代码片段解释并举例说明虚拟线程和同步代码是如何协同工作的。'
- en: '**Exemplifying thread context switching**: Write several examples that show
    how *thread context switching* works for virtual threads.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**举例说明线程上下文切换**：编写几个示例，展示虚拟线程的线程上下文切换是如何工作的。'
- en: '**Introducing the ExecutorService invoke all/any for virtual threads – part
    1**: Provide a brief introduction of `ExecutorService` invoke all/any for virtual
    threads.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍ExecutorService invoke all/any对虚拟线程的调用 – 第1部分**：简要介绍`ExecutorService`对虚拟线程的invoke
    all/any调用。'
- en: '**Introducing the ExecutorServiceinvoke all/any for virtual threads – part
    2**: Re-write the example of “unstructured” concurrency from *Problem 210* via
    `ExecutorService` invoke all/any for virtual threads.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍ExecutorService invoke all/any对虚拟线程的调用 – 第2部分**：通过`ExecutorService` invoke
    all/any对虚拟线程重写“问题210”中的“非结构化”并发示例。'
- en: '**Hooking task state**: Explain and exemplify the new `Future#state()` API.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挂钩任务状态**：解释并举例说明新的`Future#state()` API。'
- en: '**Combining new VirtualThreadPerTaskExecutor() and streams**: Write several
    examples that introduce how Java stream pipelines can be combined with the `newVirtualThreadPerTaskExecutor()`
    executor.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结合new VirtualThreadPerTaskExecutor()和流**：编写几个示例，介绍Java流管道如何与`newVirtualThreadPerTaskExecutor()`执行器结合使用。'
- en: '**Introducing a scope object (StructuredTaskScope)**: Provide a brief introduction
    of structured concurrency via the `StructuredTaskScope` API.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍范围对象（StructuredTaskScope）**：通过`StructuredTaskScope` API简要介绍结构化并发。'
- en: '**Introducing ShutdownOnSuccess**: Exemplify the `ShutdownOnSuccess` flavor
    of `StructuredTaskScope`.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍ShutdownOnSuccess**：举例说明`StructuredTaskScope`的`ShutdownOnSuccess`风味。'
- en: '**Introducing ShutdownOnFailure**: Exemplify the `ShutdownOnFailure` flavor
    of `StructuredTaskScope`.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍ShutdownOnFailure**：举例说明`StructuredTaskScope`的`ShutdownOnFailure`版本。'
- en: '**Combining StructuredTaskScope and streams**: Write several examples that
    introduce how Java stream pipelines can be combined with `StructuredTaskScope`.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结合StructuredTaskScope和流**：编写几个示例，介绍如何将Java流管道与`StructuredTaskScope`结合使用。'
- en: '**Observing and monitoring virtual threads**: Exemplify how we can use **JFR**
    (**Java Flight Recorder**), **JMX** (**Java Management Extensions**), and any
    other tool that you like, for observing and monitoring virtual threads.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**观察和监控虚拟线程**：举例说明我们如何使用**JFR**（**Java Flight Recorder**）、**JMX**（**Java Management
    Extensions**）以及您喜欢的任何其他工具来观察和监控虚拟线程。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节描述了前面问题的解决方案。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节，并在此[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter10)上的程序进行实验。
- en: 209\. Explaining concurrency vs. parallelism
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 209. 解释并发与并行
- en: Before tackling the main topic of this chapter, *structured concurrency*, let’s
    forget about *structure*, and let’s keep only *concurrency*. Next, let’s put *concurrency*
    against *parallelism*, since these two notions are often a source of confusion.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在着手本章的主要主题——**结构化并发**之前，让我们先忘记**结构**，只保留**并发**。接下来，让我们将**并发**与**并行**进行比较，因为这两个概念常常是混淆的源头。
- en: Both of them, concurrency and parallelism, use *tasks* as the main unit of work.
    However, the way that they handle these tasks makes them very different.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者，并发和并行，都使用**任务**作为主要的工作单元。然而，它们处理这些任务的方式使它们非常不同。
- en: In the case of parallelism, a task is split into subtasks across multiple CPU
    cores. These subtasks are computed in parallel, and each of them represents a
    partial solution for the given task. By joining these partial solutions, we obtain
    the solution. Ideally, solving a task in parallel should result in less wall-clock
    time than in the case of solving the same task sequentially. In a nutshell, in
    parallelism, at least two threads run at the same time, which means that parallelism
    can solve a single task faster.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行的情况下，一个任务被分割成多个CPU核心的子任务。这些子任务并行计算，每个子任务代表给定任务的局部解决方案。通过合并这些局部解决方案，我们得到解决方案。理想情况下，并行解决任务应该比顺序解决相同任务所需的时间更少。简而言之，在并行中，至少有两个线程同时运行，这意味着并行可以更快地解决单个任务。
- en: In the case of concurrency, we try to solve as many tasks as possible via several
    threads that compete with each other, progressing in a time-slicing fashion. This
    means that concurrency can complete multiple tasks faster. This is why concurrency
    is also referred to as virtual parallelism.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发的情况下，我们尝试通过几个相互竞争的线程尽可能多地解决任务，以时间分片的方式推进。这意味着并发可以更快地完成多个任务。这也是为什么并发也被称为虚拟并行。
- en: 'The following figure depicts parallelism vs. concurrency:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了并行与并发的对比：
- en: '![Figure 10.1.png](img/B19665_10_01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.1.png](img/B19665_10_01.png)'
- en: 'Figure 10.1: Concurrency vs. parallelism'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：并发与并行
- en: In parallelism, tasks (subtasks) are part of the implemented solution/algorithm.
    We write the code, set/control the number of tasks, and use them in a context
    that has parallel computational capabilities. On the other hand, in concurrency,
    tasks are part of the problem.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行的情况下，任务（子任务）是实施解决方案/算法的一部分。我们编写代码，设置/控制任务数量，并在具有并行计算能力的上下文中使用它们。另一方面，在并发中，任务是问题的一部分。
- en: Typically, we measure parallelism efficiency in *latency* (the amount of time
    needed to complete the task), while the efficiency of concurrency is measured
    in *throughput* (the number of tasks that we can solve).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们通过**延迟**（完成任务所需的时间）来衡量并行效率，而并发的效率则是通过**吞吐量**（我们可以解决的任务数量）来衡量的。
- en: Moreover, in parallelism, tasks control resource allocation (CPU time, I/O operations,
    and so on). On the other hand, in concurrency, multiple threads compete with each
    other to gain as many resources (I/O) as possible. They cannot control resource
    allocation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在并行性中，任务控制资源分配（CPU时间、I/O操作等）。另一方面，在并发中，多个线程相互竞争以获取尽可能多的资源（I/O）。它们无法控制资源分配。
- en: In parallelism, threads operate on CPU cores in such a way that every core is
    busy. In concurrency, threads operate on tasks in such a way that, ideally, each
    thread has a separate task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行性中，线程以这种方式在CPU核心上操作，即每个核心都处于忙碌状态。在并发中，线程以这种方式在任务上操作，理想情况下，每个线程都有一个单独的任务。
- en: 'Commonly, when parallelism and concurrency are compared, somebody comes and
    says: *How about asynchronous methods?*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当比较并行性和并发性时，有人会过来问：*异步方法怎么样？*
- en: It is important to understand that *asynchrony* is a separate concept. Asynchrony
    is about the capability to accomplish non-blocking operations. For instance, an
    application sends an HTTP request, but it doesn’t just wait for the response.
    It goes and solves something else (other tasks) while waiting for the response.
    We do asynchronous tasks every day. For instance, we start the washing machine
    and then go to clean other parts of the house. We don’t just wait by the washing
    machine until it is finished.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 *异步性* 是一个独立的概念。异步性是关于完成非阻塞操作的能力。例如，一个应用程序发送一个HTTP请求，但它不会只是等待响应。它会去做其他事情（其他任务），在等待响应的同时。我们每天都在做异步任务。例如，我们开始启动洗衣机，然后去打扫房子的其他部分。我们不会只是站在洗衣机旁边，直到它完成。
- en: 210\. Introducing structured concurrency
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 210. 介绍结构化并发
- en: If you are as old as I am, then most probably you started programming with a
    language such as BASIC or a similar unstructured programming language. At that
    time, an application was just a sequence of lines that defined a sequential logic/behavior
    via a bunch of GOTO statements, driving the flow by jumping like a kangaroo back
    and forward between the code lines. Well, in Java, the building blocks of a typical
    concurrent code are so primitive that the code looks somewhat like unstructured
    programming because it is hard to follow and understand. Moreover, a thread dump
    of a concurrent task doesn’t provide the needed answers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样大，那么你很可能开始编程时使用的是BASIC或类似的非结构化编程语言。当时，一个应用程序只是一系列定义了顺序逻辑/行为的代码行，通过一串GOTO语句驱动流程，像袋鼠一样在代码行之间跳来跳去。在Java中，典型并发代码的构建块非常原始，因此代码看起来有点像非结构化编程，因为它难以跟踪和理解。此外，并发任务的线程转储并不提供所需的答案。
- en: 'Let’s follow a snippet of Java concurrent code and stop every time we have
    a question (always check the code below the question). The task is to concurrently
    load three testers by ID and team them up in a testing team. First, let’s list
    the server code (we will use this simple code to serve us in this problem and
    subsequent problems):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随一段Java并发代码，每次有问题时都停下来（总是检查问题下面的代码）。任务是并发地通过ID加载三个测试人员并将他们组成一个测试团队。首先，让我们列出服务器代码（我们将使用这段简单的代码来帮助我们解决这个问题和后续的问题）：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, the code that we are especially interested in starts as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们特别感兴趣的代码如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*First stop*: As you can see, `buildTestingTeam()` throws an `InterruptedException`.
    So if the thread executing `buildTestingTeam()` gets interrupted, how can we easily
    interrupt the following threads?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一站*：正如你所见，`buildTestingTeam()` 抛出了 `InterruptedException`。那么如果执行 `buildTestingTeam()`
    的线程被中断，我们如何轻松地中断后续的线程？'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Second stop*: Here, we have three `get()` calls. So the current thread waits
    for other threads to complete. Can we easily observe those threads?'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二站*：这里，我们有三个 `get()` 调用。所以当前线程会等待其他线程完成。我们能否轻松地观察那些线程？'
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Third stop:* If an `ExecutionException` is caught, then we know that one of
    these three `Future` instances has failed. Can we easily cancel the remaining
    two, or will they just hang on there? `future1` will probably fail while `future2`
    and `future3` will complete successfully, or maybe `future2` will complete successfully
    while `future3` will just run forever (a so-called *orphan* thread). This can
    lead to serious mismatches in the expected results, memory leaks, and so on:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*第三站*：如果捕获到 `ExecutionException`，那么我们知道这三个 `Future` 实例中的一个失败了。我们能否轻松地取消剩余的两个，或者它们会一直挂在那里？`future1`
    可能会失败，而 `future2` 和 `future3` 可能会成功完成，或者也许 `future2` 会成功完成，而 `future3` 将会永远运行（所谓的
    *孤儿线程*）。这可能导致预期的结果严重不匹配、内存泄漏等问题：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Fourth stop*: The next line of code is used to shut down the `executor`, but
    it is so easy to overlook. Is this the proper place to do this?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*第四个步骤*：下一行代码用于关闭`executor`，但它很容易被忽略。这是正确的操作位置吗？'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Fifth stop*: If you didn’t spot the previous line of code, then it is legitimate
    to ask yourself how/where this executor got shut down:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*第五个步骤*：如果您没有注意到上一行代码，那么您有理由问自己这个执行器是如何/在哪里被关闭的：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We skip the rest of the code, since you can find it in the bundled code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了其余的代码，因为您可以在捆绑的代码中找到它。
- en: Of course, we can implement code answers to each of these questions via error
    handling, task abandons and abortions, `ExecutorService`, and so on, but this
    means a lot of work for the developer. Writing failsafe solutions that carefully
    cover all possible scenarios across multiple tasks/subtasks while tracking their
    progress in a concurrent environment is not an easy job. That’s not to mention
    how hard it is to understand and maintain the resulting code by another developer,
    or even the same developer after 1–2 years or even months.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过错误处理、任务放弃和终止、`ExecutorService`等方式为这些问题实现代码答案，但这意味着开发者需要做大量的工作。在并发环境中跟踪多个任务/子任务的进度，同时仔细覆盖所有可能的场景，编写容错解决方案并非易事。更不用说，其他开发者或甚至是1-2年后或几个月后的同一开发者理解和维护生成的代码有多么困难。
- en: It is time to add some structure to this code, so let’s introduce *structured
    concurrency* (or Project Loom).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候给这段代码添加一些结构了，让我们引入*结构化并发*（或Project Loom）。
- en: '*Structured concurrency* relies on several pillars meant to bring lightweight
    concurrency to Java. The fundamental pillar or principle of structured concurrency
    is highlighted next.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构化并发*依赖于几个支柱，旨在将轻量级并发引入Java。结构化并发的根本支柱或原则将在下面强调。'
- en: '**Important note**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The fundamental principle of structured concurrency is that when a task has
    to be solved concurrently, then all the threads needed to solve it are spun and
    rejoined in the same block of code. In other words, all these threads’ lifetimes
    are bound to the block’s lexical scope, so we have clear and explicit entry-exit
    points for each concurrent code block.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化并发的根本原则是，当一个任务需要并发解决时，所有解决该任务所需的线程都在同一块代码中启动和重新连接。换句话说，所有这些线程的生命周期都绑定到块的词法作用域，因此我们为每个并发代码块提供了清晰和明确的入口和出口点。
- en: Based on this principle, the thread that initiates a concurrent context is the
    *parent-thread* or the *owner-thread*. All threads started by the parent-thread
    are *children-threads* or *forks*, so between them, these threads are siblings.
    Together, the parent-thread and the child-threads define a *parent-child hierarchy*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个原则，启动并发上下文的线程是*父线程*或*拥有线程*。由父线程启动的所有线程都是*子线程*或*分支*，因此它们之间是兄弟姐妹关系。父线程和子线程共同定义了一个*父子层次结构*。
- en: 'Putting the structured concurrency principle into a diagram will show us the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将结构化并发原则放入图中将展示以下内容：
- en: '![Figure 10.2.png](img/B19665_10_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2.png](img/B19665_10_02.png)'
- en: 'Figure 10.2: Parent-child hierarchy in structured concurrency'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：结构化并发中的父子层次结构
- en: 'In the context of the parent-child hierarchy, we have support for error/exception
    handling with short-circuiting, cancellation propagation, and monitoring/observability:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在父子层次结构的上下文中，我们支持带有短路、取消传播、监控/可观察性的错误/异常处理：
- en: '*Error/exception handling with short-circuiting*: If a child-thread fails,
    then all child-threads are canceled unless they are complete. For instance, if
    `futureTester(1)` fails, then `futureTester(2)` and `futureTester(3)` are automatically
    canceled.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*短路错误/异常处理*：如果一个子线程失败，那么除非它们已经完成，否则所有子线程都会被取消。例如，如果`futureTester(1)`失败，那么`futureTester(2)`和`futureTester(3)`将自动取消。'
- en: '*Cancellation propagation*: If the parent-thread is interrupted until joining
    the child-threads is over, then these forks (the child-threads/subtasks) are canceled
    automatically. For instance, if the thread executing `buildTestingTeam()` gets
    interrupted, then its three forks are automatically canceled.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*取消传播*：如果父线程在加入子线程之前被中断，那么这些分支（子线程/子任务）将自动取消。例如，如果执行`buildTestingTeam()`的线程被中断，那么它的三个分支将自动取消。'
- en: '*Monitoring/observability*: A thread dump reveals a crystal-clear image of
    the entire parent-child hierarchy, no matter how many levels have been spawned.
    Moreover, in structured concurrency, we take advantage of scheduling and the memory
    management of threads.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*监控/可观察性*：线程转储揭示了整个父子层次结构的清晰图像，无论产生了多少层级。此外，在结构化并发中，我们利用线程的调度和内存管理。'
- en: 'While these are purely concepts, writing code that respects and follows these
    concepts requires the proper API and the following awesome callout:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些都是纯粹的概念，但编写遵循这些概念的代码需要适当的API和以下令人惊叹的调用：
- en: '![Figure 10.3.png](img/B19665_10_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.3.png](img/B19665_10_03.png)'
- en: 'Figure 10.3: Don’t reuse virtual threads'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：不要重用虚拟线程
- en: 'Cut this out and stick it somewhere so that you see it every day! So in structured
    concurrency, **don’t reuse virtual threads**. I know what you are thinking: *hey
    dude, threads are expensive and limited, so we have to reuse them*. A quick hint:
    we are talking about *virtual threads* (massive throughput), not *classical threads*,
    but the virtual threads topic is covered in the next problem.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将其剪下来贴在某个地方，以便你每天都能看到！所以在结构化并发中，**不要重用虚拟线程**。我知道你在想什么：*嘿，兄弟，线程很贵，而且有限，所以我们必须重用它们*。一个快速提示：我们谈论的是*虚拟线程*（大量吞吐量），而不是*经典线程*，但虚拟线程的话题将在下一个问题中介绍。
- en: 211\. Introducing virtual threads
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 211. 虚拟线程的引入
- en: 'Java allows us to write multithreaded applications via the `java.lang.Thread`
    class. These are classical Java threads that are basically just thin wrappers
    of OS (kernel) threads. As you’ll see, these classical Java threads are referred
    to as *platform threads*, and they have been available for quite a long time (since
    JDK 1.1, as the following diagram reveals):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许我们通过`java.lang.Thread`类编写多线程应用程序。这些是经典的Java线程，基本上只是操作系统（内核）线程的薄包装。正如你将看到的，这些经典Java线程被称为*平台线程*，并且已经存在很长时间了（自从JDK
    1.1以来，如下面的图所示）：
- en: '![Figure 10.4.png](img/B19665_10_04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.4.png](img/B19665_10_04.png)'
- en: 'Figure 10.4: JDK multithreading evolution'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：JDK多线程演变
- en: Next, let’s move on to JDK 19 virtual threads.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续了解JDK 19虚拟线程。
- en: What’s the problem with platform (OS) threads?
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台（操作系统）线程有什么问题？
- en: OS threads are expensive in every single way, or more specifically, they are
    costly in terms of time and space. Creating OS threads is, therefore, a costly
    operation that requires a lot of stack space (around 20 megabytes) to store their
    context, Java call stacks, and additional resources. Moreover, the OS thread scheduler
    is responsible for scheduling Java threads, which is another costly operation
    that requires moving around a significant amount of data. This is referred to
    as *thread context switching.*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统线程在各个方面都很昂贵，或者更具体地说，它们在时间和空间上都很昂贵。因此，创建操作系统线程是一个昂贵的操作，需要大量的堆栈空间（大约20兆字节）来存储它们的上下文、Java调用栈和额外的资源。此外，操作系统线程调度器负责调度Java线程，这是另一个昂贵的操作，需要移动大量的数据。这被称为*线程上下文切换*。
- en: 'In the following figure, you can see the one-to-one relationship between a
    Java thread and an OS thread:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到Java线程和操作系统线程之间的一对一关系：
- en: '![Figure 10.4.png](img/B19665_10_05.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.4.png](img/B19665_10_05.png)'
- en: 'Figure 10.5: JVM to OS threads'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：JVM到操作系统线程
- en: For decades, our multithreaded applications have run in this context. All this
    time and experience taught us that we can create a limited number of Java threads
    (because of low throughput) and that we should reuse them wisely. The number of
    Java threads is a limiting factor that is usually exhausted before other resources,
    such as network connections, CPU, and so on. Java doesn’t differentiate between
    threads that perform intensive computational tasks (i.e., threads that really
    exploit the CPU) or those that just wait for data (i.e., they just hang on the
    CPU).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，我们的多线程应用程序一直在这个环境中运行。所有这些时间和经验教会了我们，我们可以创建有限数量的Java线程（因为吞吐量低），而且我们应该明智地重用它们。Java线程的数量是一个限制因素，通常在诸如网络连接、CPU等其他资源耗尽之前就已经用完。Java不会区分执行密集计算任务（即真正利用CPU的线程）或仅仅等待数据的线程（即它们只是挂载在CPU上）。
- en: Let’s do a quick exercise. Let’s assume that our machine has 8 GB of memory,
    and a single Java thread needs 20 MB. This means that we have room for around
    400 Java threads (8 GB = 8,000 MB / 20 MB = 400 threads). Next, let’s assume that
    these threads perform I/O operations over a network. Each I/O operation needs
    around 100 ms to complete, while the request preparation and response processing
    needs around 500 ns. So a thread works for 1,000 ns (0.001 ms) and then waits
    for 100 ms (100,000,000 ns) for the I/O operation to complete. This means that
    at 8 GB of memory, the 400 threads will use 0.4% of CPU availability (under 1%),
    which is very low. We can conclude that a thread is idle for 99.99% of the time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个快速练习。假设我们的机器有8 GB的内存，而单个Java线程需要20 MB。这意味着我们大约有400个Java线程的空间（8 GB = 8,000
    MB / 20 MB = 400 threads）。接下来，假设这些线程在网络上进行I/O操作。每个I/O操作需要大约100 ms才能完成，而请求准备和响应处理需要大约500
    ns。所以一个线程工作1,000 ns（0.001 ms），然后等待100 ms（100,000,000 ns）以完成I/O操作。这意味着在8 GB的内存中，400个线程将使用0.4%的CPU可用性（低于1%），这非常低。我们可以得出结论，线程有99.99%的时间是空闲的。
- en: Based on this exercise, it is quite obvious that Java threads become a bottleneck
    in throughput that doesn’t allow us to solicit hardware at full capacity. Of course,
    we can sweeten the situation a little bit by using *thread pools* to minimize
    the costs, but it still does not solve the major issues of dealing with resources.
    You have to go for `CompletableFuture`, reactive programming (for instance, Spring
    `Mono` and `Flux`), and so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个练习，很明显，Java线程成为了吞吐量的瓶颈，这不允许我们充分利用硬件。当然，我们可以通过使用*线程池*来最小化成本来改善这种情况，但这仍然不能解决处理资源的主要问题。你必须转向`CompletableFuture`、响应式编程（例如，Spring的`Mono`和`Flux`）等等。
- en: 'However, how many classical Java threads can we create? We can easily find
    out by running a simple snippet of code, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以创建多少个传统的Java线程呢？我们可以通过运行一个简单的代码片段来轻松找出，如下所示：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, if we want to taste from the new concurrent API, we can call
    the new `Thread.ofPlatform()` method, as follows (`OfPlatform` is a `sealed` interface,
    introduced in JDK 19):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想尝试新的并发API，我们可以调用新的`Thread.ofPlatform()`方法，如下所示（`OfPlatform`是一个`sealed`接口，在JDK
    19中引入）：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: On my machine, I got an `OutOfMemoryError` after around 40,000 Java threads.
    Depending on your OS and hardware, this number may vary.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我在大约40,000个Java线程后遇到了`OutOfMemoryError`。根据你的操作系统和硬件，这个数字可能会有所不同。
- en: The `Thread.ofPlatform()` method was added in JDK 19 to easily distinguish between
    Java threads (i.e., classical Java threads as we have known them for decades –
    thin wrappers of OS threads) and the new kids in town, virtual threads.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.ofPlatform()`方法是在JDK 19中添加的，以便轻松区分Java线程（即，几十年来我们所知道的经典Java线程——操作系统线程的薄包装）和城中新来的孩子，虚拟线程。'
- en: What are virtual threads?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是虚拟线程？
- en: 'Virtual threads were introduced in JDK 19 as a preview (JEP 425), and they
    became a final feature in JDK 21 (JEP 444). Virtual threads run on top of platform
    threads in a one-to-many relationship, while the platform threads run on top of
    OS threads in a one-to-one relationship, as shown in the following figure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程是在JDK 19中作为预览版（JEP 425）引入的，并在JDK 21中成为最终特性（JEP 444）。虚拟线程在平台线程之上运行，形成一对一的关系，而平台线程在操作系统线程之上运行，形成一对一的关系，如下面的图所示：
- en: '![Figure 10.5.png](img/B19665_10_06.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5.png](img/B19665_10_06.png)'
- en: 'Figure 10.6: Virtual threads architecture'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：虚拟线程架构
- en: If we break this figure down into a few words, then we can say that JDK maps
    a large number of virtual threads to a small number of OS threads.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个概念分解成几个词，那么我们可以这样说，JDK将大量虚拟线程映射到少量操作系统线程。
- en: 'Before creating a virtual thread, let’s see two important notes that will help
    us to quickly understand the fundamentals of virtual threads. First, let’s have
    a quick note about a virtual thread’s memory footprint:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建虚拟线程之前，让我们看看两个重要的注意事项，这将帮助我们快速了解虚拟线程的基本原理。首先，让我们快速了解一下虚拟线程的内存占用：
- en: '**Important note**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要注意事项**'
- en: Virtual threads are not wrappers of OS threads. They are lightweight Java entities
    (they have their own stack memory with a small footprint – only a few hundred
    bytes) that are cheap to create, block, and destroy (creating a virtual thread
    is around 1,000 times cheaper than creating a classical Java thread). There can
    be many of them at the same time (millions) so that they sustain a massive throughput.
    Virtual threads should not be reused (they are disposable) or pooled.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程不是操作系统线程的包装器。它们是轻量级的Java实体（它们有自己的堆栈内存，占用空间很小——只有几百字节），创建、阻塞和销毁成本低（创建虚拟线程的成本大约是创建经典Java线程的1,000倍）。可以同时存在很多虚拟线程（数百万），从而实现巨大的吞吐量。虚拟线程不应重复使用（它们是一次性的）或池化。
- en: When we talk about virtual threads, there are more things that we should unlearn
    than things that we should learn. But where are virtual threads stored, and who’s
    responsible for scheduling them accordingly?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论虚拟线程时，我们应该忘记的东西比应该学习的东西更多。但虚拟线程存储在哪里，谁负责相应地调度它们？
- en: '**Important note**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Virtual threads are stored in the JVM heap (so they take advantage of Garbage
    Collector) instead of the OS stack. Moreover, virtual threads are scheduled by
    the JVM via a *work-stealing* `ForkJoinPool` scheduler. Practically, JVM schedules
    and orchestrates virtual threads to run on platform threads in such a way that
    a platform thread executes only one virtual thread at a time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程存储在JVM堆中（因此它们可以利用垃圾收集器），而不是操作系统堆栈。此外，虚拟线程由JVM通过一个*工作窃取*的`ForkJoinPool`调度器进行调度。实际上，JVM以这种方式调度和编排虚拟线程在平台线程上运行，使得一个平台线程一次只执行一个虚拟线程。
- en: Next, let’s create a virtual thread.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个虚拟线程。
- en: Creating a virtual thread
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟线程
- en: 'From the API perspective, a virtual thread is another flavor of `java.lang.Thread`.
    If we dig a little bit via `getClass()`, we can see that a virtual thread class
    is `java.lang.VirtualThread`, which is a `final` non-public class that extends
    the `BaseVirtualThread` class, which, in turn, is a `sealed abstract` class that
    extends `java.lang.Thread`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从API的角度来看，虚拟线程是`java.lang.Thread`的另一种风味。如果我们通过`getClass()`深入研究，我们可以看到虚拟线程类是`java.lang.VirtualThread`，它是一个`final`的非公开类，继承自`BaseVirtualThread`类，而`BaseVirtualThread`是一个`sealed
    abstract`类，继承自`java.lang.Thread`：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s consider that we have the following task (`Runnable`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下任务（`Runnable`）：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating and starting a virtual thread
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建和启动虚拟线程
- en: 'We can create and start a virtual thread for our task via the `startVirtualThread(Runnable
    task)` method, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`startVirtualThread(Runnable task)`方法创建并启动一个虚拟线程，如下所示：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The returned `vThread` is scheduled for execution by the JVM itself. But we
    can also create and start a virtual thread via `Thread.ofVirtual()`, which returns
    `OfVirtual` (the `sealed` interface introduced in JDK 19), as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`vThread`由JVM本身调度执行。但我们可以通过`Thread.ofVirtual()`创建并启动一个虚拟线程，它返回`OfVirtual`（JDK
    19中引入的`sealed`接口），如下所示：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, `vThread` will solve our `task`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`vThread`将解决我们的`task`。
- en: 'Moreover, we have the `Thread.Builder` interface (and `Thread.Builder.OfVirtual`
    subinterface) that can be used to create a virtual thread, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有`Thread.Builder`接口（以及`Thread.Builder.OfVirtual`子接口），可以用来创建虚拟线程，如下所示：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is another example of creating two virtual threads via `Thread.Builder`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个通过`Thread.Builder`创建两个虚拟线程的示例：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can check out these examples further in the bundled code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中进一步查看这些示例。
- en: Waiting for a virtual task to terminate
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等待虚拟任务终止
- en: 'The given `task` is executed by a virtual thread, while the main thread is
    not blocked. In order to wait for the virtual thread to terminate, we have to
    call one of the `join()` flavors. We have `join()` without arguments that waits
    indefinitely, and a few flavors that wait for a given time (for instance, `join(Duration
    duration)` and `join(long millis)`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的`task`由虚拟线程执行，而主线程不会被阻塞。为了等待虚拟线程终止，我们必须调用`join()`的一个变体。我们有不带参数的`join()`，它会无限期地等待，以及几个等待给定时间的变体（例如，`join(Duration
    duration)`和`join(long millis)`）：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These methods throw an `InterruptedException`, so you have to catch it and handle
    it (or just throw it). Now, because of `join()`, the main thread cannot terminate
    before the virtual thread. It has to wait until the virtual thread completes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法会抛出`InterruptedException`，所以你必须捕获并处理它（或者只是抛出它）。现在，由于`join()`，主线程不能在虚拟线程完成之前终止。它必须等待虚拟线程完成。
- en: Creating an unstarted virtual thread
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建未启动的虚拟线程
- en: 'Creating an unstarted virtual thread can be done via `unstarted(Runnable task)`,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个未启动的虚拟线程可以通过`unstarted(Runnable task)`来完成，如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or via `Thread.Builder` as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过`Thread.Builder`，如下所示：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This time, the thread is not scheduled for execution. It will be scheduled
    for execution only after we explicitly call the `start()` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，线程没有被安排执行。它只有在显式调用`start()`方法后才会被安排执行：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can check if a thread is alive (i.e., it was started but not terminated)
    via the `isAlive()` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`isAlive()`方法检查一个线程是否是活动的（即它已经被启动但尚未终止）：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `unstarted()` method is available for platform threads as well (there is
    also the `Thread.Builder.OfPlatform` subinterface):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`unstarted()`方法也适用于平台线程（还有`Thread.Builder.OfPlatform`子接口）：'
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can start `pThread` by calling the `start()` method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`start()`方法来启动`pThread`。
- en: Creating a ThreadFactory for virtual threads
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为虚拟线程创建ThreadFactory
- en: 'You can create a `ThreadFactory` of virtual threads, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个虚拟线程的`ThreadFactory`，如下所示：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or, via `Thread.Builder`, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过`Thread.Builder`，如下所示：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And a `ThreadFactory` for platform threads, as follows (you can use `Thread.Builder`
    as well):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个平台线程的`ThreadFactory`，如下所示（你也可以使用`Thread.Builder`）：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or a `ThreadFactory` that we can use to switch between virtual/platform threads,
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个我们可以用来在虚拟/平台线程之间切换的`ThreadFactory`，如下所示：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we can use any of these factories via the `ThreadFactory.newThread(Runnable
    task)`, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过`ThreadFactory.newThread(Runnable task)`使用这些工厂中的任何一个，如下所示：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the thread factory starts the created thread as well, then there is no need
    to explicitly call the `start()` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程工厂同时启动创建的线程，那么就没有必要显式地调用`start()`方法。
- en: Checking a virtual thread’s details
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查虚拟线程的详细信息
- en: 'Moreover, we can check if a certain thread is a platform thread or a virtual
    thread via `isVirtual()`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过`isVirtual()`方法检查某个线程是否是平台线程或虚拟线程：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Obviously, only `vThread` is a virtual thread.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，只有`vThread`是虚拟线程。
- en: '*A virtual thread always runs as a daemon thread.* The `isDaemon()` method
    returns `true`, and trying to call `setDaemon(false)` will throw an exception.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟线程总是以守护线程的方式运行*。`isDaemon()`方法返回`true`，尝试调用`setDaemon(false)`会抛出异常。'
- en: '*The priority of a virtual thread is always* `NORM_PRIORITY` (calling `getPriority()`
    always returns `5` – constant `int` for `NORM_PRIORITY`). Calling `setPriority()`
    with a different value has no effect.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟线程的优先级总是* `NORM_PRIORITY`（调用`getPriority()`总是返回`5` – `NORM_PRIORITY`的常量`int`）。使用不同的值调用`setPriority()`没有效果。'
- en: '*A virtual thread cannot be part of a thread group* because it already belongs
    to the *VirtualThreads* group. Calling `getThreadGroup().getName()` returns *VirtualThreads*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟线程不能成为线程组的一部分*，因为它已经属于*VirtualThreads*组。调用`getThreadGroup().getName()`会返回*VirtualThreads*。'
- en: A virtual thread has no permission with Security Manager (which is deprecated
    anyway).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程在安全管理器中没有权限（安全管理器已经被弃用）。
- en: Printing a thread (toString())
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打印一个线程（toString()）
- en: 'If we print a virtual thread (calling the `toString()` method), then the output
    will be something like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印一个虚拟线程（调用`toString()`方法），那么输出将类似于以下内容：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In a nutshell, this output can be interpreted as follows: `VirtualThread[#22]`
    indicates that this is a virtual thread that contains the thread identifier (`#22`)
    with no name (in the case of `VirtualThread[#26,vt-0]`, the id is `#26` and the
    name is `vt-0`). Then, we have the `runnable` text, which indicates the state
    of the virtual thread (`runnable` means that the virtual thread is running). Next,
    we have the *carrier thread* of the virtual thread, which is a platform thread;
    `ForkJoinPool-1-worker-1` contains the platform thread name (`worker-1`) of the
    default `ForkJoinPool` (`ForkJoinPool-1`).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个输出可以这样解释：`VirtualThread[#22]`表示这是一个包含线程标识符（`#22`）且没有名称的虚拟线程（在`VirtualThread[#26,vt-0]`的情况下，标识符是`#26`，名称是`vt-0`）。然后，我们有`runnable`文本，它表示虚拟线程的状态（`runnable`表示虚拟线程正在运行）。接下来，我们有虚拟线程的*承载线程*，这是一个平台线程；`ForkJoinPool-1-worker-1`包含了默认`ForkJoinPool`（`ForkJoinPool-1`）的平台线程名称（`worker-1`）。
- en: How many virtual threads we can start
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们可以启动多少个虚拟线程
- en: 'Finally, let’s run code that allows us to see how many virtual threads we can
    create and start:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们运行一些代码，以便我们可以看到我们可以创建和启动多少个虚拟线程：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On my machine, this code started to slow down after around 14,000,000 virtual
    threads. It continues to run slowly while memory becomes available (Garbage Collector
    is in action), but it didn’t crash. So a massive throughput!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Backward compatibility
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Virtual threads are compatible with:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Synchronized blocks
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread-local variables
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread` and `currentThread()`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread interruption (`InterruptedException`)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, virtual threads work out of the box once you update to at least JDK
    19\. They heavily sustain a clean, readable, and more structured code, being the
    bricks behind the structured concurrency paradigm.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding fake conclusions (potentially myths)
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few fake conclusions about virtual threads that we should consider
    as follow:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '*Virtual threads are faster than platform threads (WRONG!)*: There can be a
    lot of virtual threads, but they are not faster than classical (platform) threads.
    They don’t boost in-memory computational capabilities (for that, we have parallel
    streams). Don’t conclude that virtual threads do some magic that makes them faster
    or more optimal to solve a task. So virtual threads can seriously improve throughput
    (since millions of them can wait for jobs), but they cannot improve latency. However,
    virtual threads can be launched much faster than platform threads (a virtual thread
    has a creation time measured in µs and needs space in the order of kB).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Virtual threads should be pooled (WRONG!)*: Virtual threads should not be
    part of any thread pool and should never be pooled.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Virtual threads are expensive (WRONG!)*: Virtual threads are not for free
    (nothing is for free), but they are cheaper to create, block, and destroy than
    platform threads. A virtual thread is 1,000x cheaper than a platform thread.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Virtual threads can release a task (WRONG!)*: This is not true! A virtual
    thread takes a task and will return a result unless it gets interrupted. It cannot
    release the task.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Blocking a virtual thread blocks its carrier thread (WRONG!)*: Blocking a
    virtual thread doesn’t block its carrier thread. The carrier thread can serve
    other virtual threads.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 212\. Using the ExecutorService for virtual threads
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual threads allow us to write more expressive and straightforward concurrent
    code. Thanks to the massive throughput obtained via virtual threads, we can easily
    adopt the *task-per-thread* model (for an HTTP server, this means a request per
    thread, for a database, this means a transaction per thread, and so on). In other
    words, we can assign a new virtual thread for each concurrent task.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Trying to use the *task-per-thread* model with platform threads will result
    in a throughput limited by the number of hardware cores – this is explained by
    Little’s law ([https://en.wikipedia.org/wiki/Little%27s_law](https://en.wikipedia.org/wiki/Little%27s_law)),
    L = λW, or throughput equals average concurrency multiplied by latency.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, it is recommended to avoid interacting with threads directly.
    JDK sustains this via the `ExecutorService`/`Executor` API. More precisely, we
    are used to submitting a task (`Runnable`/`Callable`) to an `ExecutorService`/`Executor`
    and working with the returned `Future`. This pattern is valid for virtual threads
    as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: So we don’t have to write ourselves all the plumbing code to adopt the *task-per-thread
    model* for virtual threads because, starting with JDK 19, this model is available
    via the `Executors` class. More precisely, it’s via the `newVirtualThreadPerTaskExecutor()`
    method, which creates an `ExecutorService` capable of creating an unbounded number
    of virtual threads that follow the *task-per-thread* model. This `ExecutorService`
    exposes methods that allow us to give tasks such as the `submit()` (as you’ll
    see next) and `invokeAll`/`Any()` (as you’ll see later) methods, returning a `Future`
    containing an exception or a result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JDK 19, the `ExecutorService` extends the `AutoCloseable` interface.
    In other words, we can use `ExecutorService` in a `try-with-resources` pattern.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following simple `Runnable` and `Callable`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Executing the `Runnable`/`Callable` can be done as follows (here, we submit
    15 tasks (`NUMBER_OF_TASKS = 15`)):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of course, in the case of `Runnable`/`Callable`, we can capture a `Future`
    and act accordingly, via the blocking `get()` method or whatever we want to do:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A possible output looks as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Check out the virtual threads’ IDs. They range between #22 and #37 without
    repetition. Each task is executed by its own virtual thread.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'The *task-per-thread* model is also available for classical threads via `newThreadPerTaskExecutor(ThreadFactory
    threadFactory)`. Here is an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, `newThreadPerTaskExecutor()` can be used for classic or virtual
    threads. The number of created threads is unbounded. By simply modifying the thread
    factory, we can switch between virtual/classic threads.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible output looks as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Check out the threads’ IDs. They range between #75 and #89 without repetition.
    Each task is executed by its own thread.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 213\. Explaining how virtual threads work
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to create and start a virtual thread, let’s see how they
    actually work.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a meaningful diagram:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6.png](img/B19665_10_07.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: How virtual threads work'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, *Figure 10.7* is similar to *Figure 10.6*, except that we have
    added a few more elements.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: First of all, notice that the platform threads run under a `ForkJoinPool` umbrella.
    This is a **First-In-First-Out** (**FIFO**) dedicated fork/join pool, dedicated
    to scheduling and orchestrating the relationships between virtual threads and
    platform threads (detailed coverage of Java’s fork/join framework is available
    in *Java Coding Problems*, *First Edition*, *Chapter 11*).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'This dedicated `ForkJoinPool` is controlled by the JVM, and it acts as the
    virtual thread scheduler based on a FIFO queue. Its initial capacity (i.e., the
    number of threads) is equal to the number of available cores, and it can be increased
    to 256\. The default virtual thread scheduler is implemented in the `java.lang.VirtualThread`
    class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个专门的`ForkJoinPool`由JVM控制，并基于FIFO队列作为虚拟线程调度器。它的初始容量（即线程数）等于可用核心数，可以增加到256。默认的虚拟线程调度器在`java.lang.VirtualThread`类中实现：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Do not confuse this `ForkJoinPool` with the one used for parallel streams (the
    Common Fork Join Pool - `ForkJoinPool.commonPool()`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这个`ForkJoinPool`与用于并行流的那个混淆（公共Fork Join Pool - `ForkJoinPool.commonPool()`）。
- en: Between the virtual threads and the platform threads, there is a one-to-many
    association. Nevertheless, the JVM schedules virtual threads to run on platform
    threads in such a way that only one virtual thread runs on a platform thread at
    a time. When the JVM assigns a virtual thread to a platform thread, the so-called
    *stack chunk object* of the virtual thread is copied from the heap memory on the
    platform thread.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟线程和平台线程之间，存在一种一对一的多对多关联。然而，JVM以这种方式调度虚拟线程在平台线程上运行，即一次只有一个虚拟线程在平台线程上运行。当JVM将一个虚拟线程分配给平台线程时，虚拟线程的所谓*栈块对象*会从平台线程的堆内存中复制过来。
- en: If the code running on a virtual thread encounters a blocking (I/O) operation
    that should be handled by the JVM, then the virtual thread is released by copying
    its *stack chunk object* back into the heap (this operation of copying the *stack
    chunk* between the heap memory and platform thread is the cost of blocking a virtual
    thread - this is much cheaper than blocking a platform thread). Meanwhile, the
    platform thread can run other virtual threads. When the blocking (I/O) of the
    released virtual thread is done, JVM reschedules the virtual thread for execution
    on a platform thread. This can be the same platform thread or another one.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在虚拟线程上运行的代码遇到一个应该由JVM处理的阻塞（I/O）操作，那么虚拟线程将通过将其*栈块对象*复制回堆内存来释放。这种在堆内存和平台线程之间复制*栈块*的操作是阻塞虚拟线程的成本（这比阻塞平台线程便宜得多）。同时，平台线程可以运行其他虚拟线程。当释放的虚拟线程的阻塞（I/O）完成时，JVM将重新调度虚拟线程在平台线程上执行。这可能是在同一个平台线程上，也可能是另一个平台线程。
- en: '**Important note**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The operation of assigning a virtual thread to a platform thread is called *mounting*.
    The operation of unassigning a virtual thread from the platform thread is called
    *unmounting*. The platform thread running the assigned virtual thread is called
    a *carrier thread*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将虚拟线程分配给平台线程的操作称为*挂载*。从平台线程取消分配虚拟线程的操作称为*卸载*。运行分配的虚拟线程的平台线程称为*载体线程*。
- en: 'Let’s see an example that reveals how the virtual threads are mounted:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，揭示虚拟线程是如何挂载的：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, we can configure the `ForkJoinPool` via three system properties, as
    follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过三个系统属性来配置`ForkJoinPool`，如下所示：
- en: '`jdk.virtualThreadScheduler.parallelism` – the number of CPU cores'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.virtualThreadScheduler.parallelism` – CPU核心数'
- en: '`jdk.virtualThreadScheduler.maxPoolSize` – the maximum pool size (256)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.virtualThreadScheduler.maxPoolSize` – 最大池大小（256）'
- en: '`jdk.virtualThreadScheduler.minRunnable` – the minimum number of running threads
    (half the pool size)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.virtualThreadScheduler.minRunnable` – 运行线程的最小数量（池大小的一半）'
- en: In a subsequent problem, we will use these properties to better shape *virtual
    thread context switching* (mounting/unmounting) details.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的问题中，我们将使用这些属性来更好地塑造*虚拟线程上下文切换*（挂载/卸载）的细节。
- en: Capturing virtual threads
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获虚拟线程
- en: So far, we have learned that a virtual thread is mounted by the JVM to a platform
    thread, which becomes its carrier thread. Moreover, the carrier thread runs the
    virtual thread until it hits a blocking (I/O) operation. At that point, the virtual
    thread is unmounted from the carrier thread, and it will be rescheduled after
    the blocking (I/O) operation is done.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到，JVM会将一个虚拟线程挂载到一个平台线程上，这个平台线程成为其载体线程。此外，载体线程会运行虚拟线程，直到它遇到一个阻塞（I/O）操作。在那个时刻，虚拟线程会从载体线程上卸载，并在阻塞（I/O）操作完成后重新调度。
- en: 'While this scenario is true for most of the blocking operations, resulting
    in unmounting the virtual threads and freeing the platform thread (and the underlying
    OS thread), there are a few exceptional cases when the virtual threads are not
    unmounted. There are two main causes for this behavior:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Limitations on the OS (for instance, a significant number of filesystem operations)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations on the JDK (for instance, `Object.wait()`)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the virtual thread cannot be unmounted from its carrier thread, it means
    that the carrier thread and the underlying OS thread are blocked. This may affect
    the scalability of the application, so if the platform threads pool allows it,
    the JVM can decide to add one more platform thread. So for a period of time, the
    number of platform threads may exceed the number of available cores.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Pinning virtual threads
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are also two other use cases when a virtual thread cannot be unmounted:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: When the virtual thread runs code inside a `synchronized` method/block
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the virtual thread invokes a foreign function or native method (a topic
    covered in *Chapter 7*)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this scenario, we say that the virtual thread is *pinned* to the carrier
    thread. This may affect the scalability of the application, but the JVM will not
    increase the number of platform threads. Instead of this, we should take action
    and refactor the `synchronized` blocks to ensure that the locking code is simple,
    clear, and short. Whenever possible, we should prefer `java.util.concurrent` locks
    instead of `synchronized` blocks. If we manage to avoid long and frequent locking
    periods, then we will not face any significant scalability issues. In future releases,
    the JDK team aims to eliminate the pinning inside `synchronized` blocks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 214\. Hooking virtual threads and sync code
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this problem is to highlight how virtual threads interact with synchronous
    code. For this, we use the built-in `java.util.concurrent.SynchronousQueue`. This
    is a built-in blocking queue that allows only one thread to operate at a time.
    More precisely, a thread that wants to insert an element in this queue is blocked
    until another thread attempts to remove an element from it, and vice versa. Basically,
    a thread cannot insert an element unless another thread attempts to remove an
    element.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that a virtual thread attempts to insert an element into a `SynchronousQueue`,
    while a platform thread attempts to remove an element from this queue. In code
    lines, we have:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So the virtual thread (`vThread`) waits for 5 seconds before attempting to
    insert an element into the queue. However, it will not successfully insert an
    element until another thread attempts to remove an element from this queue:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, the `Thread.currentThread()` refers to the main thread of the application,
    which is a platform thread not blocked by `vThread`. This thread successfully
    removes from the queue only if another thread attempts to insert (here, `vThread`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code looks as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The virtual thread started its execution (it is in a *runnable* state), but
    the main thread cannot remove an element from the queue until the virtual thread
    inserts an element, so it is blocked by the `queue.take()` operation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Meanwhile, the virtual thread sleeps for 5 seconds (currently, the main thread
    has nothing to do), and afterward, it inserts an element:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The virtual thread has inserted an element into the queue, so the main thread
    can remove this element from it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The virtual thread is also terminated:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So virtual threads, platform threads, and synchronous code work as expected.
    In the bundled code, you can find an example where the virtual and platform threads
    switch places. So the platform thread attempts to insert elements, and the virtual
    thread attempts to remove them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 215\. Exemplifying thread context switching
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that a virtual thread is mounted on a platform thread, and it is executed
    by that platform thread until a blocking operation occurs. At that point, the
    virtual thread is unmounted from the platform thread, and it will be rescheduled
    for execution by the JVM later on after the blocking operation is done. This means
    that, during its lifetime, a virtual thread can be mounted multiple times on a
    different or the same platform thread.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In this problem, let’s write several snippets of code meant to capture and exemplify
    this behavior.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Example 1
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first example, let’s consider the following thread factory that we can
    use to easily switch between the platform and virtual threads:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we try to execute the following task via 10 platform threads:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Between the two logging lines, we have a blocking operation (`sleep()`). Next,
    we rely on `newThreadPerTaskExecutor()` to submit 10 tasks that should log their
    details, sleep for 3 seconds, and log again:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Running this code with platform threads reveals the following side-to-side
    output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7.png](img/B19665_10_08.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Using platform threads'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: By carefully inspecting this figure, we can see that there is a fixed association
    between these numbers. For instance, the task with ID 5 is executed by `Thread-5`,
    the task with ID 3 by `Thread-3`, and so on. After sleeping (i.e., a blocking
    operation), these numbers are unchanged. This means that while the tasks sleep,
    the threads just hang and wait there. They have no work to do.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s switch from platform threads to virtual threads and then run the code
    again:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, the output is resumed, as shown in the following figure:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8.png](img/B19665_10_09.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Using virtual threads'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: This time, we can see that things are more dynamic. For instance, the task with
    ID 5 is started by a virtual thread executed by `worker-6`, but it is finished
    by `worker-4`. The task with ID 3 is started by a virtual thread executed by `worker-4`,
    but it is finished by `worker-6`. This means that, while a task sleeps (a blocking
    operation), the corresponding virtual thread is unmounted, and its worker can
    serve other virtual threads. When the sleeping is over, the JVM schedules the
    virtual thread for execution and is mounted on another (it could also be the same)
    worker. This is also referred to as *thread context switching*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Example 2
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, let’s start by limiting the parallelism to 1 (which is like
    having a single core and a single virtual thread):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, let’s consider that we have a slow task (we call it slow because it sleeps
    for 5 seconds):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And then, a fast task (similar to the slow task, but it sleeps for only 1 second):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we define two virtual threads to execute these two tasks, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we run this code, then the output will be as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we analyze this output, we can see that the execution starts the slow task.
    The fast task cannot be executed, since `worker-1` (the only available worker)
    is busy executing the slow task:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`Worker-1` executes the slow task until this task hits the sleeping operation.
    Since this is a blocking operation, the corresponding virtual thread (#22) is
    unmounted from `worker-1`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The JVM takes advantage of the fact that `worker-1` is available and pushes
    for the execution of the fast task:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The fast task also hits a sleeping operation, and its virtual thread (#24)
    is unmounted:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'However, the fast task sleeps for only 1 second, so its blocking operation
    is over before the slow task blocking operation, which is still sleeping. So the
    JVM can schedule the fast task for execution again, and `worker-1` is ready to
    accept it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At this moment, the fast task is done, and `worker-1` is free. But the slow
    task is still sleeping. After these 5 seconds, the JVM schedules the slow task
    for execution, and `worker-1` is there to take it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Done!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Example 3
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example is just a slight modification of Example 2\. This time, let’s
    consider that the slow task contains a non-blocking operation that runs forever.
    In this case, this operation is simulated via an infinite loop:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We have a single worker (`worker-1`), and the fast task is the same as in Example
    2\. If we run this code, the execution hangs on, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The execution hangs on because the infinite loop is not seen as a blocking operation.
    In other words, the virtual thread of the slow task (#22) is never unmounted.
    Since there is a single worker, the JVM cannot push for the execution of the fast
    task.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: If we increase the parallelism from 1 to 2, then the fast task will be successfully
    executed by `worker-2`, while `worker-1` (executing the slow task) will simply
    hang on to a partial execution. We can avoid such situations by relying on a timeout
    join, such as `join(Duration duration)`. This way, after the given timeout, the
    slow task will be automatically interrupted. So pay attention to such scenarios.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 216\. Introducing the ExecutorService invoke all/any for virtual threads – part
    1
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this problem, we won’t spend time on the basics and, instead, jump right
    into how to use `invokeAll()` and `invokeAny()`. If you need a primer on the `ExecutorService`
    API’s `invokeAll()`/`invokeAny()` functions, then you could consider *Java Coding
    Problems*, *First Edition*, *Chapter 10*, *Problem 207*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Working with invokeAll()
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a nutshell, `invokeAll()` executes a collection of tasks (`Callable`) and
    returns a `List<Future>` that holds the results/status of each task. The tasks
    can finish naturally or be forced by a given timeout. Each task can finish successfully
    or exceptionally. Upon return, all the tasks that have not been completed yet
    are automatically canceled. We can check out the status of each task via `Future.isDone()`
    and `Future.isCancelled()`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using `invokeAll()` with virtual threads via `newVirtualThreadPerTaskExecutor()`
    (or with `newThreadPerTaskExecutor()`) is straightforward. For instance, here
    we have a simple example of executing three `Callable` instances:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Have you spotted the `f.state()` call? This API was introduced in JDK 19, and
    it computes the state of a future based on the well-known `get()`, `isDone()`,
    and `isCancelled()`. While we will detail this in a subsequent problem, currently,
    the output is as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The three tasks have successfully completed.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Working with invokeAny()
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a nutshell, `invokeAny()` executes a collection of tasks (`Callable`) and
    strives to return a result corresponding to a task that has successfully terminated
    (before the given timeout, if any). All the tasks that have not been completed
    are automatically canceled:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using `invokeAny()` with virtual threads via `newVirtualThreadPerTaskExecutor()`
    is also straightforward (or with `newThreadPerTaskExecutor()`). For instance,
    here we have a simple example of executing three `Callable` instances when we
    are interested in a single result:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A possible output might be:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This output corresponds to the second `Callable`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: In the next problem, we will come up with a more realistic example.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 217\. Introducing the ExecutorService invoke all/any for virtual threads – part
    2
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, in *Problem 210*, we wrote a piece of “unstructured” concurrency code
    to build a testing team of three testers, served by an external server.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try to rewrite the `buildTestingTeam()` method via `invokeAll()`/`Any()`
    and `newVirtualThreadPerTaskExecutor()`. If we rely on `invokeAll()`, then the
    application will attempt to load three testers by ID, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We have three testers with IDs 1, 2, and 3\. So the output will be:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the next problem, we will see how we can make decisions based on task state.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can handle the testing phase even with a single tester, then we can rely
    on `invokeAny()`, as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This code will return a single result representing one of these three testers.
    If none of them is available, then we will get a `UserNotFoundException`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 218\. Hooking task state
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JDK 19, we can rely on `Future.state()`. This method computes
    the state of a `Future` based on the well-known `get()`, `isDone()`, and `isCancelled()`,
    returning a `Future.State` enum entry, as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '`CANCELLED` – the task was canceled.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FAILED` – the task was completed exceptionally (with an exception).'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNNING` – the task is still running (has not been completed).'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SUCCESS` – the task was completed normally with a result (no exception).'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following snippet of code, we analyze the state of loading the testing
    team members and act accordingly:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We know that when the execution reaches the `switch` block, the `Future` objects
    should be completely normal or exceptional. So if the current `Future` state is
    `RUNNING`, then this is a really weird situation (possibly a bug), and we throw
    an `IllegalStateException`. Next, if the `Future` state is `SUCCESS` (`fetchTester(2)`),
    then we have a result that can be obtained via `resultNow()`. This method was
    added in JDK 19, and it is useful when we know that we have a result. The `resultNow()`
    method returns immediately without waiting (as `get()`). If the state is `FAILED`
    (`fetchTester(Integer.MAX_VALUE)`), then we log the exception via `exceptionNow()`.
    This method was also added in JDK 19, and it returns immediately the underlying
    exception of a failed `Future`. Finally, if the `Future` was canceled, then there
    is nothing to do. We just report it in the log.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 219\. Combining newVirtualThreadPerTaskExecutor() and streams
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Streams and `newVirtualThreadPerTaskExecutor()` is a handy combination. Here
    is an example that relies on `IntStream` to submit 10 simple tasks and collect
    the returned `List` of `Future` instances:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we wait for each `Future` to complete by calling the `get()` method:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Moreover, using stream pipelines is quite useful in combination with `invokeAll()`.
    For instance, the following stream pipeline returns a `List` of results (it filters
    all `Future` instances that haven’t completed successfully):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Alternatively, we can write the following solution (without `mapMulti()`):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Of course, if `List<Object>` is all you need, then you can go straight ahead
    via `Future::resultNow`, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'On the other hand, you may need to collect all the `Future` that has been completed
    exceptionally. This can be achieved via `exceptionNow()`, as follows (we intentionally
    sneaked into the given `List<Callable>` a `Callable` that will generate an `StringIndexOutOfBoundsException`,
    `() -> "pass02".substring(50)`):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you don’t prefer `mapMulti()`, then rely on the classical approach:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can find all these examples in the bundled code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 220\. Introducing a scope object (StructuredTaskScope)
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered a bunch of problems that use virtual threads directly
    or indirectly via an `ExecutorService`. We already know that virtual threads are
    cheap to create and block and that an application can run millions of them. We
    don’t need to reuse them, pool them, or do any fancy stuff. *Use and throw* is
    the proper and recommended way to deal with virtual threads. This means that virtual
    threads are very useful for expressing and writing asynchronous code, which is
    commonly based on a lot of threads that are capable of blocking/unblocking several
    times in a short period. On the other hand, we know that OS threads are expensive
    to create, very expensive to block, and are not easy to put into an asynchronous
    context.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Before virtual threads (so for many, many years), we had to manage the life
    cycle of OS threads via an `ExecutorService`/`Executor`, and we could write asynchronous
    (or reactive) code via *callbacks* (you can find detailed coverage of asynchronous
    programming in *Java Coding Problems*, *First Edition*, *Chapter 11*).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: However, asynchronous/reactive code is hard to write/read, very hard to debug
    and profile, and almost deadly hard to unit-test. Nobody wants to read and fix
    your asynchronous code! Moreover, once we start to write an application via asynchronous
    callback, we tend to use this model for all tasks, even for those that shouldn’t
    be asynchronous. We can easily fall into this trap when we need to somehow link
    asynchronous code/results to non-asynchronous code. And the easiest way to do
    it is to go only for asynchronous code.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: So is there a better way? Yes, there is! Structured concurrency is the answer.
    Structured concurrency started as an *incubator* project and reached the *preview*
    stage in JDK 21 (JEP 453).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'And, in this context, we should introduce `StructuredTaskScope`. A `StructuredTaskScope`
    is a virtual thread launcher for `Callable` tasks that returns a `Subtask`. A
    subtask is an extension of the well-known `Supplier<T>` functional interface represented
    by the `StructuredTaskScope.Subtask<T>` interface and forked with `StructuredTaskScope.fork(Callable
    task)`. It follows and works based on the fundamental principle of structured
    concurrency (see *Problem 210*): “*When a task has to be solved concurrently,
    then all the threads needed to solve it are spun and rejoined in the same block
    of code. In other words, all these threads’ lifetimes are bound to the block’s
    scope, so we have clear and explicit entry-exit points for each concurrent code
    block*.” These threads are responsible for running subtasks (`Subtask`) of the
    given task as a single unit of work.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of fetching a single tester (with ID 1) from our web
    server via `StructuredTaskScope`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'First, we create a `StructuredTaskScope` in a `try-with-resources` pattern.
    `StructuredTaskScope` implements `AutoCloseable`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `scope` is a wrapper for the virtual threads’ lifetimes. We use the `scope`
    to fork as many virtual threads (subtasks) as needed via the `fork(Callable task)`
    method. Here, we fork only one virtual thread and get back a `Subtask` (forking
    is a non-blocking operation):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Next, we have to call the `join()` method (or `joinUntil(Instant deadline)`).
    This method waits for all threads (all `Subtask` instances) forked from this `scope`
    (or all threads that have been submitted to this `scope`) to complete, so it is
    a blocking operation. A scope should block only while it waits for its subtasks
    to complete, and this happens via `join()` or `joinUntil()`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When the execution passes this line, we know that all threads (all forked `Subtask`)
    forked from this `scope` are complete, with a result or an exception (each subtask
    runs independently, so each of them can complete with a result or an exception).
    Here, we call the non-blocking `get()` method to get the result, but pay attention
    – calling `get()` for a task that did not complete will raise an exception as
    `IllegalStateException(`*"Owner did not join after forking subtask"*`)`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: On the other hand, we can obtain the exception of a failed task via `exception()`.
    However, if we call `exception()` for a subtask (`Subtask`) that is completed
    with a result, then we will get back an exception as `IllegalStateException(`*"Subtask
    not completed or did not complete with exception"*`)`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'So if you are not sure whether your task(s) completed with a result or an exception,
    it is better to call `get()` or `exception()` only after you test the state of
    the corresponding `Subtask`. A state of `SUCCESS` will safely allow you to call
    `get()`, while a state of `FAILED` will safely allow you to call `exception()`.
    So in our case, we may prefer it this way:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Besides `Subtask.State.SUCCESS` and `Subtask.State.FAILED`, we also have `Subtask.State.UNAVAILABLE`,
    which means that the subtask is not available (for instance, if the subtask is
    still running, then its state is `UNAVAILABLE`, but there could be another cause
    as well).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: ExecutorService vs. StructuredTaskScope
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous code looks like the code that we would write via a classical `ExecutorService`,
    but there are two big differences between these solutions. First of all, an `ExecutorService`
    holds the precious platform threads and allows us to pool them. On the other hand,
    a `StructuredTaskScope` is just a thin launcher for virtual threads that are cheap
    and shouldn’t be pooled. So once we’ve done our job, a `StructuredTaskScope` can
    be destroyed and garbage-collected. Second, an `ExecutorService` holds a single
    queue for all the tasks, and the threads take from this queue whenever they have
    the chance to do so. A `StructuredTaskScope` relies on a fork/join pool, and each
    virtual thread has its own wait queue. However, a virtual thread can steal a task
    from another queue as well. This is known as the *work-stealing* pattern, and
    if you want to read more about it, we covered it in depth in *Java Coding Problem*,
    *First Edition*, *Chapter 11*.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 221\. Introducing ShutdownOnSuccess
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous problem, we introduced `StructuredTaskScope` and used it to
    solve a task via a single virtual thread (a single `Subtask`). Basically, we fetched
    the tester with ID 1 from our server (we had to wait until this one was available).
    Next, let’s assume that we still need a single tester, but not mandatorily the
    one with ID 1\. This time, it could be any of IDs 1, 2, or 3\. We simply take
    the first one that is available from these three, and we cancel the other two
    requests.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Especially for such scenarios, we have an extension of `StructuredTaskScope`
    called `StructuredTaskScope.ShutdownOnSuccess`. This scope is capable of returning
    the result of the first task that completes successfully and interrupts the rest
    of the threads. It follows the “invoke any” model and can be used as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we fork three subtasks (threads) that will compete with each other to
    complete. The first subtask (thread) that completes successfully wins and returns.
    The `result()` method returns this result (if none of the subtasks (threads) complete
    successfully, then it throws an `ExecutionException`).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check the state of these three `Subtask`, we can see that one succeeds
    while the other two are unavailable:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Of course, you don’t need the code that checks/prints the state of each `Subtask`.
    It was added here just to highlight how `ShutdownOnSuccess` works. You don’t even
    need the explicit `Subtask` objects, since we don’t call `get()` or anything else
    from this API. Basically, we can reduce the code to the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Done! You just create the scope, fork your subtasks, call `join()`, and collect
    the result. So the scope is really business-focused.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: A task that completes exceptionally under the `ShutdownOnSuccess` umbrella will
    never be chosen to produce a result. However, if all tasks complete exceptionally,
    then we will get an `ExecutionException` that wraps the exception (i.e., the cause)
    of the first completed task.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 222\. Introducing ShutdownOnFailure
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As its name suggests, `StructuredTaskScope.ShutdownOnFailure` is capable of
    returning the exception of the first subtask that completes exceptionally and
    interrupts the rest of the subtasks (threads). For instance, we may want to fetch
    the testers with IDs 1, 2, and 3\. Since we need exactly these three testers,
    we want to be informed if any of them are not available and, if so, cancel everything
    (i.e., the remaining threads). The code looks as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In this example, we intentionally replaced ID 3 with `Integer.MAX_VALUE`. Since
    there is no tester with this ID, the server will throw `UserNotFoundException`.
    This means that the states of the subtasks will reveal that the third subtask
    has failed:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Moreover, when we call the `exception()` method, we will get back an `Optional<Throwable>`
    containing this exception (if you’re interested in reading more about this subject,
    in-depth coverage of the `Optional` feature is available in *Java Coding Problems*,
    *First Edition*, *Chapter 12*). If we decide to throw it, then we simply call
    the `throwIfFailed()` method, which wraps the original exception (the cause) in
    an `ExecutionException` and throws it. The message of the exception in our case
    will be:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If we remove the guideline code, then we can compact the previous code, as
    follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If no exception occurs, then `throwIfFailed()` doesn’t do anything, and those
    three testers are available. The result of each `Subtask` is available via the
    non-blocking `Subtask.get()`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: A subtask that completes exceptionally under the `ShutdownOnFailure` umbrella
    will be chosen to produce an exception. However, if all subtasks complete normally,
    then we will not get any exceptions. On the other hand, if no subtasks were completed
    exceptionally but were canceled, then `ShutdownOnFailure` will throw `CancellationException`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 223\. Combining StructuredTaskScope and streams
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you prefer functional programming, then you’ll be happy to see that streams
    can be used with `StructuredTaskScope` as well. For instance, here we rewrite
    the application from *Problem 221*, using a stream pipeline to fork our tasks:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Moreover, we can use stream pipelines to collect results and exceptions, as
    follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can find these examples in the bundled code.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 224\. Observing and monitoring virtual threads
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Observing and monitoring virtual threads can be done in several ways. First,
    we can use **Java Flight Recorder** (**JFR**) – we introduced this tool in *Chapter
    6*, *Problem 143*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Using JFR
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among its reach list of events, JFR can monitor and record the following events
    related to virtual threads:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '`jdk.VirtualThreadStart` – this event is recorded when a virtual thread starts
    (by default, it is disabled)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdk.VirtualThreadEnd` – this event is recorded when a virtual thread ends
    (by default, it is disabled)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdk.VirtualThreadPinned` – this event is recorded when a virtual thread is
    parked while pinned (by default, it is enabled with a threshold of 20 ms)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jdk.VirtualThreadSubmitFailed` – this event is recorded if a virtual thread
    cannot be started or unparked (by default, it is enabled)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find all the JFR events at [https://sap.github.io/SapMachine/jfrevents/](https://sap.github.io/SapMachine/jfrevents/).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'We start configuring JFR to monitor the virtual threads, by adding to the root
    folder of the application the following `vtEvent.jfc` file:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, let’s consider the following code (basically, this is the application
    from Problem 216):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Next, we use `-XX:StartFlightRecording=filename=recording.jfr` to instruct JFR
    to record output in a file named `recording.jfr`, and we continue with `settings=vtEvent.jfc`
    to highlight the configuration file listed previously.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'So the final command is the one from this figure:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10.png](img/B19665_10_10.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Running JFR'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'JFR has produced a file named `recording.jfr`. We can easily view the content
    of this file via the JFR CLI. The command (`jfr print recording.jfr`) will display
    the content of `recording.jfr`. The content is too large to be listed here (it
    contains three entries for `jdk.VirtualThreadStart` and three for `jdk.VirtualThreadEnd`),
    but here is the event specific to starting a virtual thread:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11.png](img/B19665_10_11.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: JFR event to start a virtual thread'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'And, in the next figure, you can see the event recorded to end this virtual
    thread:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12.png](img/B19665_10_12.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: JFR event to end a virtual thread'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Besides the JFR CLI, you can use more powerful tools to consume the virtual
    thread events, such as JDK Mission Control ([https://www.oracle.com/java/technologies/jdk-mission-control.html](https://www.oracle.com/java/technologies/jdk-mission-control.html))
    and the well-known Advanced Management Console ([https://www.oracle.com/java/technologies/advancedmanagementconsole.html](https://www.oracle.com/java/technologies/advancedmanagementconsole.html)).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: To get a stack trace for threads that block while pinned, we can set the system
    property, `jdk.tracePinnedThreads`. A complete (verbose) stack trace is available
    via `-Djdk.tracePinnedThreads=full`, or if all you need is a brief/short stack
    trace, then rely on `-Djdk.tracePinnedThreads=short`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we can easily get a pinned virtual thread by marking the `fetchTester()`
    method as `synchronized` (remember that a virtual thread cannot be unmounted if
    it runs code inside a `synchronized` method/block):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In this context, JFR will record a pinned virtual thread, as shown in the following
    figure:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12.png](img/B19665_10_13.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: JFR event for a pinned virtual thread'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the application with `-Djdk.tracePinnedThreads=full`, then your IDE
    will print a detailed stack trace that starts as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can see the complete output by executing the bundled code. Of course, you
    can get a thread dump and analyze it via several other tools. You may prefer any
    of `jstack`, **Java Mission Control** (**JMC**), `jvisualvm`, or `jcmd`. For instance,
    we can obtain a thread dump in plain text or the JSON format via `jcmd`, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Next, let’s play with `jconsole` (JMX) to quickly analyze the performance of
    virtual threads.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Using Java Management Extensions (JMX)
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until JDK 20 (inclusive), JMX provided support for monitoring only the platform
    and threads. However, we can still use JMX to observe the performance brought
    by virtual threads in comparison with platform threads.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can use JMX to monitor platform threads at 500 ms each, via
    the following snippet of code:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We rely on this code in the following three scenarios.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Running 10,000 tasks via the cached thread pool executor
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'On my machine, it took 8,147 ms (8 seconds) to run these 10,000 tasks, using
    at peak 7,729 platform threads. The following screenshot from `jconsole` (JMX)
    reveals this information:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12.png](img/B19665_10_14.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: Running 10,000 tasks via the cached thread pool executor'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s repeat this test via a fixed thread pool.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Running 10,000 tasks via the fixed thread pool executor
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on your machine, the previous test may finish successfully, or it
    may result in an `OutOfMemoryError`. We can avoid this unpleasant scenario by
    using a fixed thread pool. For instance, let’s limit the number of platform threads
    to 200 via the following snippet of code:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'On my machine, it took 50,190 ms (50 seconds) to run these 10,000 tasks, using
    at peak 216 platform threads. The following screenshot from JMX reveals this information:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13.png](img/B19665_10_15.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.15: Running 10,000 tasks via the fixed thread pool executor'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, a smaller number of platform threads is reflected in performance.
    If we put 216 workers to do the job of 7,729 workers, of course, it will take
    longer. Next, let’s see how virtual threads will handle this challenge.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Running 10,000 tasks via the virtual thread per task executor
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time, let’s see how the `newVirtualThreadPerTaskExecutor()` can handle
    these 10,000 tasks. The code is straightforward:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'On my machine, it took 3,519 ms (3.5 seconds) to run these 10,000 tasks, using
    at peak 25 platform threads. The following screenshot from JMX reveals this information:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14.png](img/B19665_10_16.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.16: Running 10000 tasks via the virtual thread per task executor'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Wow! How cool is this?! The resulting time is far and away the best in comparison
    with the previous tests, and it uses fewer resources (only 25 platform threads).
    So virtual threads really rock!
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'I also strongly recommend you check out the following benchmark: [https://github.com/colincachia/loom-benchmark/tree/main](https://github.com/colincachia/loom-benchmark/tree/main).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Starting with JDK 21, JMX’s `HotSpotDiagnosticMXBean` was enriched with the
    `dumpThreads(String outputFile, ThreadDumpFormat format)` method. This method
    outputs a thread dump to the given file (`outputFile`) in the given format (`format`).
    The thread dump will contain all platform threads, but it may also contain some
    or all virtual threads.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we attempt to obtain a thread dump for all subtasks
    (threads) of a `StructuredTaskScope`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output file is named `threadDump.json`, and you can find it in the root
    folder of the application. The part of the output that we are interested in is
    partially listed here:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'As you can see, we have three virtual threads (#22, #24, and #25) that run
    subtasks of our scope. In the bundled code, you can find the complete output.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered 16 introductory problems about virtual threads and structured
    concurrency. You can see this chapter as preparation for the next one, which will
    cover more detailed aspects of these two topics.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
