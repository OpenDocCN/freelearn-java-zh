- en: '*Chapter 18*: jOOQ SPI (Providers and Listeners)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 18 章*：jOOQ SPI（提供者和监听器）'
- en: jOOQ provides a lot of hooks that allow us to alter its default behavior at
    different levels. Among these hooks, we have lightweight settings and configurations,
    and the heavy-duty, extremely stable **Service Provider Interface** (**SPI**)
    made of generators, providers, listeners, parsers, and so on. So, like any robust
    and mature technology, jOOQ comes with an impressive SPI dedicated to those corner
    cases where the core technology cannot help.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 提供了许多钩子，允许我们在不同级别更改其默认行为。在这些钩子中，我们有轻量级的设置和配置，以及由生成器、提供者、监听器、解析器等组成的重型、极其稳定的
    **服务提供者接口** (**SPI**)。因此，就像任何强大而成熟的技术一样，jOOQ 携带了一个令人印象深刻的 SPI，专门用于核心技术无法帮助的边缘情况。
- en: 'In this chapter, we scratch the surface of each of these hooks in order to
    expose the usage steps and some examples that will help you to understand how
    to develop your own implementations. Our agenda includes the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨每个这些钩子，以揭示使用步骤和一些示例，这将帮助你理解如何开发自己的实现。我们的议程包括以下内容：
- en: jOOQ settings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ 设置
- en: jOOQ configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ 配置
- en: jOOQ providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ 提供者
- en: jOOQ listeners
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ 监听器
- en: Altering the jOOQ code generation process
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 jOOQ 代码生成过程
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter18](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter18).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到 [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter18](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter18)。
- en: jOOQ settings
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ 设置
- en: 'jOOQ comes with a comprehensive list of settings (`org.jooq.conf.Settings`)
    that attempts to cover the most popular use cases related to rendering the SQL
    code. These settings are available declaratively (via `jooq-settings.xml` in the
    classpath) or programmatically via methods such as `setFooSetting()` or `withFooSetting()`,
    which can be chained in a fluent style. To take effect, `Settings` must be part
    of `org.jooq.Configuration`, and this can be done in multiple ways, as you can
    read in the jOOQ manual at [https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/](https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/).
    But most probably, in a Spring Boot application, you''ll prefer one of the following
    approaches:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 携带了一个全面的设置列表 (`org.jooq.conf.Settings`)，旨在涵盖与渲染 SQL 代码相关的最常用用例。这些设置可以通过声明性方式（通过类路径中的
    `jooq-settings.xml`）或通过 `setFooSetting()` 或 `withFooSetting()` 等方法程序化地访问，这些方法可以以流畅的方式链接。为了生效，`Settings`
    必须是 `org.jooq.Configuration` 的一部分，这可以通过多种方式完成，正如你可以在 jOOQ 手册中阅读的那样 [https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/](https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/)。但在
    Spring Boot 应用程序中，你可能会更喜欢以下方法之一：
- en: 'Pass global `Settings` to the default `Configuration` via `jooq-settings.xml`
    in the classpath (the `DSLContext` prepared by Spring Boot will take advantage
    of these settings):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类路径中的 `jooq-settings.xml` 将全局 `Settings` 传递给默认的 `Configuration`（Spring Boot
    准备的 `DSLContext` 将利用这些设置）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Pass global `Settings` to the default `Configuration` via an `@Bean` (the `DSLContext`
    prepared by Spring Boot will take advantage of these settings):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `@Bean` 将全局 `Settings` 传递给默认的 `Configuration`（Spring Boot 准备的 `DSLContext`
    将利用这些设置）：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At some point, set a new global `Settings` that will be applied from this point
    onward (this is a global `Settings` because we use `Configuration#set()`):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，设置一个新的全局 `Settings`，从此时开始应用（这是一个全局 `Settings`，因为我们使用 `Configuration#set()`）：
- en: '[PRE16]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Append new global settings to the current global `Settings`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的全局设置附加到当前的全局 `Settings`：
- en: '[PRE21]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can practice these examples in *GlobalSettings* for MySQL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 MySQL 的 *GlobalSettings* 中练习这些示例。
- en: 'At some point, set a new local `Settings` that will be applied only to the
    current query (this is a local `Settings` because we use `Configuration#derive()`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，设置一个新的局部 `Settings`，它只应用于当前查询（这是一个局部 `Settings`，因为我们使用 `Configuration#derive()`）：
- en: '[PRE24]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or, setting a global/local setting and appends to it more local settings:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，设置全局/局部设置并将其附加到更多局部设置：
- en: '[PRE29]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can practice this example in *LocalSettings* for MySQL. It is highly recommended
    to reserve some time and at least to briefly scroll the entire list of jOOQ-supported
    settings at [https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/conf/Settings.html](https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/conf/Settings.html).
    Next, let's talk about jOOQ `Configuration`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在MySQL的*LocalSettings*中练习这个示例。强烈建议你留出一些时间，至少简要地浏览一下jOOQ支持的设置列表，请参阅[https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/conf/Settings.html](https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/conf/Settings.html)。接下来，让我们谈谈jOOQ的`Configuration`。
- en: jOOQ Configuration
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ配置
- en: '`org.jooq.Configuration` represents the spine of `DSLContext`. `DSLContext`
    needs the precious information provided by `Configuration` for query rendering
    and execution. While `Configuration` takes advantage of `Settings` (as you just
    saw), it also has a lot more other configurations that can be specified as in
    the examples from this section.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.jooq.Configuration`代表了`DSLContext`的骨干。`DSLContext`需要`Configuration`提供的宝贵信息来进行查询渲染和执行。当`Configuration`利用`Settings`（正如你刚才看到的）时，它还有许多其他可以指定的配置，如本节中的示例。'
- en: By default, Spring Boot gives us a `DSLContext` built on the default `Configuration`
    (the `Configuration` accessible via `ctx.configuration()`), and as you know, while
    providing custom settings and configurations, we can alter this `Configuration`
    globally via `set()` or locally by creating a derived one via `derive()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot为我们提供了一个基于默认`Configuration`（可通过`ctx.configuration()`访问的`Configuration`）构建的`DSLContext`，正如你所知，在提供自定义设置和配置时，我们可以通过`set()`全局地更改此`Configuration`，或者通过创建一个派生版本通过`derive()`局部地更改。
- en: But, in some scenarios, for instance, when you build custom providers or listeners,
    you'll prefer to build the `Configuration` to be aware of your artifacts right
    from the start instead of extracting it from `DSLContext`. In other words, when
    `DSLContext` is built, it should use the ready-to-go `Configuration`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在某些场景下，例如，当你构建自定义提供者或监听器时，你更愿意从一开始就构建`Configuration`以了解你的工件，而不是从`DSLContext`中提取它。换句话说，当`DSLContext`构建时，它应该使用现成的`Configuration`。
- en: 'Before Spring Boot 2.5.0, this step required a little bit of effort, as you
    can see here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot 2.5.0之前，这一步需要一点努力，正如你所看到的那样：
- en: '[PRE40]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is a `Configuration` created from scratch (actually from the jOOQ built-in
    `DefaultConfiguration`) that will be used by Spring Boot to create the `DSLContext`.
    At a minimum, we need to specify a `ConnectionProvider` and the SQL dialect. Optionally,
    if we want to use `SpringTransactionProvider` as the default provider for jOOQ
    transactions, then we need to set it as in this code. After this minimum configuration,
    you can continue adding your settings, providers, listeners, and so on. You can
    practice this example in *Before250Config* for MySQL.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从头开始创建的`Configuration`（实际上是从jOOQ内置的`DefaultConfiguration`创建的），Spring Boot将使用它来创建`DSLContext`。至少，我们需要指定一个`ConnectionProvider`和SQL方言。如果我们要使用`SpringTransactionProvider`作为jOOQ事务的默认提供者，那么我们需要像以下代码那样设置它。在完成此最小配置后，你可以继续添加你的设置、提供者、监听器等。你可以在MySQL的*Before250Config*中练习这个示例。
- en: 'Starting with version 2.5.0, Spring Boot facilitates easier customization of
    jOOQ''s `DefaultConfiguration` via a bean that implements a functional interface
    named `DefaultConfigurationCustomizer`. This acts as a callback and can be used
    as in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从2.5.0版本开始，Spring Boot通过一个实现名为`DefaultConfigurationCustomizer`的功能接口的bean简化了对jOOQ的`DefaultConfiguration`的自定义。这充当一个回调，可以像以下示例那样使用：
- en: '[PRE58]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is more practical because we can add only what we need. You can check out
    this example in *After250Config* for MySQL. Next, let's talk about jOOQ providers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这更实用，因为我们只能添加我们需要的。你可以在MySQL的*After250Config*中查看这个示例。接下来，让我们谈谈jOOQ提供者。
- en: jOOQ providers
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ提供者
- en: The jOOQ SPI exposes a suite of providers such as `TransactionProvider`, `RecordMapperProvider`,
    `ConverterProvider`, and so on. Their overall goal is simple—to provide some feature
    that is not provided by the jOOQ default providers. For instance, let's check
    out `TransactionProvider`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ SPI公开了一系列提供者，例如`TransactionProvider`、`RecordMapperProvider`、`ConverterProvider`等。它们的总体目标很简单——提供一些jOOQ默认提供者没有提供的功能。例如，让我们看看`TransactionProvider`。
- en: TransactionProvider
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务提供者
- en: For instance, we know that jOOQ transactions are backed in Spring Boot by a
    transaction provider named `SpringTransactionProvider` (the Spring Boot built-in
    implementation of jOOQ's `TransactionProvider`) that exposes by default a read-write
    transaction with no name (`null`), having the propagation set to `PROPAGATION_NESTED`
    and the isolation level to the default isolation level of the underlying database,
    `ISOLATION_DEFAULT`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们知道jOOQ事务在Spring Boot中由名为`SpringTransactionProvider`的事务提供者支持（这是jOOQ的`TransactionProvider`的Spring
    Boot内置实现），默认情况下暴露一个无名称（`null`）的读写事务，传播行为设置为`PROPAGATION_NESTED`，隔离级别设置为底层数据库的默认隔离级别`ISOLATION_DEFAULT`。
- en: Now, let's assume that we implement a module of our application that serves
    only reports via jOOQ transactions (so we don't use `@Transactional`). In such
    a module, we don't want to allow writing, we want to run each query in a separate/new
    transaction with a timeout of 1 second, and we want to avoid the `PROPAGATION_REQUIRES_NEW`,
    the isolation level set to `ISOLATION_READ_COMMITTED`, and the timeout set to
    1 second.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们实现了一个只通过jOOQ事务（因此我们不使用`@Transactional`）提供报告的应用程序模块。在这样的模块中，我们不希望允许写入，我们希望在单独的新事务中运行每个查询，超时时间为1秒，并避免`PROPAGATION_REQUIRES_NEW`，将隔离级别设置为`ISOLATION_READ_COMMITTED`，并将超时设置为1秒。
- en: 'To obtain such a transaction, we can implement a `TransactionProvider` and
    override the `begin()` method as in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得此类事务，我们可以实现一个`TransactionProvider`并覆盖`begin()`方法，如下面的代码所示：
- en: '[PRE68]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Once we have the transaction provider, we have to configure it in jOOQ. Assuming
    that we are using Spring Boot 2.5.0+, and based on the previous section, this
    can be done as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了事务提供者，我们必须在jOOQ中对其进行配置。假设我们正在使用Spring Boot 2.5.0+，并且根据上一节的内容，可以这样操作：
- en: '[PRE91]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You can practice this example in *A250MyTransactionProvider* for MySQL. When
    you run the application, you''ll notice at the console that the created transaction
    has these coordinates: *Creating new transaction with name [TRANSACTION_1000]:
    PROPAGATION_REQUIRES_NEW, ISOLATION_READ_COMMITTED, timeout_1, readOnly*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*A250MyTransactionProvider*中练习这个例子，适用于MySQL。当你运行应用程序时，你会在控制台注意到创建的事务具有以下坐标：*创建新事务，名称为[TRANSACTION_1000]，传播行为为PROPAGATION_REQUIRES_NEW，隔离级别为ISOLATION_READ_COMMITTED，超时为timeout_1，只读*。
- en: If you are using a Spring Boot version prior to 2.5.0, then check out the application
    named *B250MyTransactionProvider* for MySQL.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是2.5.0之前的Spring Boot版本，那么请查看名为*B250MyTransactionProvider*的应用程序，适用于MySQL。
- en: 'And, of course, you can configure the provider via `DSLContext` as well:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以通过`DSLContext`来配置提供者：
- en: '[PRE103]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Or, you can use the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下方法：
- en: '[PRE105]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Now, let's consider another scenario solved via `ConverterProvider`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个通过`ConverterProvider`解决的问题场景。
- en: ConverterProvider
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConverterProvider
- en: We have to project some JSON functions and map them hierarchically. We already
    know that this is no issue in a Spring Boot + jOOQ combo since jOOQ can fetch
    the JSON and can call Jackson (the default in Spring Boot) to map it accordingly.
    But, we don't want to use Jackson; we want to use Flexjson ([http://flexjson.sourceforge.net/](http://flexjson.sourceforge.net/)).
    jOOQ is not aware of this library (jOOQ can detect only the presence of Jackson
    and Gson), so we need to provide a converter such as `org.jooq.ConverterProvider`
    that uses Flexjson to accomplish this task. Take your time to check the source
    in *{A,B}250ConverterProvider* for MySQL. Finally, let's focus on this scenario
    solved via `RecordMapperProvider`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须投影一些JSON函数并将它们分层映射。我们已经知道，在Spring Boot + jOOQ组合中这没有问题，因为jOOQ可以获取JSON并调用Jackson（Spring
    Boot中的默认选择）来相应地映射它。但是，我们不想使用Jackson；我们想使用Flexjson ([http://flexjson.sourceforge.net/](http://flexjson.sourceforge.net/))。jOOQ不认识这个库（jOOQ只能检测到Jackson和Gson的存在），因此我们需要提供一个转换器，例如`org.jooq.ConverterProvider`，它使用Flexjson来完成这项任务。请花时间检查*A,B}250ConverterProvider*的源代码，适用于MySQL。最后，让我们专注于通过`RecordMapperProvider`解决的问题场景。
- en: RecordMapperProvider
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RecordMapperProvider
- en: We have a ton of legacy POJOs implemented via the `Builder` pattern and we decide
    to write a bunch of jOOQ `RecordMapper` for mapping queries to these POJOs. In
    order to streamline the process of using these `RecordMapper`, we also decide
    to write a `RecordMapperProvider`. Basically, this will be responsible for using
    the proper `RecordMapper` without our explicit intervention. Are you curious about
    how to do it? Then check out the *{A,B}250RecordMapperProvider* and *RecordMapperProvider*
    applications for MySQL. Mainly, these applications are the same, but they use
    different approaches to configure `RecordMapperProvider`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一堆通过 `Builder` 模式实现的遗留 POJO，我们决定为这些 POJO 编写一些 jOOQ `RecordMapper` 以映射查询。为了简化使用这些
    `RecordMapper` 的过程，我们还决定编写一个 `RecordMapperProvider`。基本上，这将负责使用适当的 `RecordMapper`，而无需我们显式干预。你对如何做到这一点好奇吗？那么请查看
    *{A,B}250RecordMapperProvider* 和 *RecordMapperProvider* 应用于 MySQL 的应用。主要，这些应用是相同的，但它们使用不同的方法来配置
    `RecordMapperProvider`。
- en: With `ConverterProvider` and `RecordMapperProvider`, I think it's important
    to mention that these *replace* out-of-the-box behavior, they don't *enhance*
    it. So, custom providers have to make sure to fall back to the default implementations
    if they can't handle a conversion/mapping.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ConverterProvider` 和 `RecordMapperProvider` 中，我认为重要的是要提到，这些 *替换* 了默认行为，它们并不
    *增强* 它。因此，自定义提供者必须确保在无法处理转换/映射时回退到默认实现。
- en: jOOQ listeners
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ 监听器
- en: jOOQ comes with a significant number of listeners that are quite versatile and
    useful in hooking us into jOOQ life cycle management for solving a wide range
    of tasks. Let's "arbitrarily" pick up the mighty `ExecuteListener`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 提供了相当数量的监听器，它们非常灵活且在钩子到 jOOQ 生命周期管理中非常有用，以解决各种任务。让我们“随意”选择强大的 `ExecuteListener`。
- en: ExecuteListener
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ExecuteListener
- en: For instance, one of the listeners that you'll love is `org.jooq.ExecuteListener`.
    This listener comes with a bunch of methods that can hook in the life cycle of
    a `Query`, `Routine`, or `ResultSet` to alter the default rendering, preparing,
    binding, executing, and fetching stage. The most convenient approach to implement
    your own listener is to extend the jOOQ default implementation, `DefaultExecuteListener`.
    This way, you can override only the methods that you want and you keep up with
    the SPI evolution (however, by the time you read this book, it is possible that
    this default listener will have been removed, and all methods are now default
    methods on the interface). Consider applying this technique to any other jOOQ
    listener, since jOOQ provides a default implementation for all (mainly, for `FooListener`,
    there is a `DefaultFooListener`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能会喜欢的一个监听器是 `org.jooq.ExecuteListener`。这个监听器提供了一组方法，可以将 `Query`、`Routine`
    或 `ResultSet` 的生命周期钩子连接到默认的渲染、准备、绑定、执行和检索阶段。实现你自己的监听器的最方便的方法是扩展 jOOQ 默认实现，`DefaultExecuteListener`。这样，你只需覆盖你想要的方法，并保持与
    SPI 进化的同步（然而，在你阅读这本书的时候，这个默认监听器可能已经被移除，并且所有方法现在都是接口上的默认方法）。考虑将此技术应用于任何其他 jOOQ
    监听器，因为 jOOQ 为所有监听器都提供了默认实现（主要，对于 `FooListener`，有一个 `DefaultFooListener`）。
- en: 'For now, let''s write an `ExecuteListener` that alters the rendered SQL that
    is about to be executed. Basically, all we want is to alter every MySQL `SELECT`
    by adding the `/*+ MAX_EXECUTION_TIME(n) */` hint, which allows us to specify
    a query timeout in milliseconds. The jOOQ DSL allows for adding MySQL/Oracle-style
    hints. :) Use `ctx.select(...).hint("/*+ ... */").from(...)`. But only `ExecuteListener`
    can patch multiple queries without modifying the queries themselves. So, `ExecuteListener`
    exposes callbacks such as `renderStart(ExecuteContext)` and `renderEnd(ExecuteContext)`,
    which are called before rendering SQL from `QueryPart` and after rendering SQL
    from `QueryPart`, respectively. Once we are in control, we can rely on `ExecuteContext`,
    which gives us access to the underlying connection (`ExecuteContext.connection()`),
    query (`ExecuteContext.query()`), rendered SQL (`ExecuteContext.sql()`), and so
    on. In this specific case, we are interested in accessing the rendered SQL and
    modifying it, so we override `renderEnd(ExecuteContext)` and call `ExecuteContext.sql()`
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们编写一个 `ExecuteListener`，它将改变即将执行的渲染 SQL。基本上，我们只想通过添加 `/*+ MAX_EXECUTION_TIME(n)
    */` 指令来修改每一个 MySQL `SELECT`，这样我们就可以指定查询的超时时间（以毫秒为单位）。jOOQ DSL 允许添加 MySQL/Oracle
    风格的提示。 :) 使用 `ctx.select(...).hint("/*+ ... */").from(...)`. 但只有 `ExecuteListener`
    可以在不修改查询本身的情况下修补多个查询。因此，`ExecuteListener` 提供了回调函数，如 `renderStart(ExecuteContext)`
    和 `renderEnd(ExecuteContext)`，分别是在从 `QueryPart` 渲染 SQL 之前和之后调用的。一旦我们掌握了控制权，我们就可以依赖
    `ExecuteContext`，它为我们提供了访问底层连接（`ExecuteContext.connection()`）、查询（`ExecuteContext.query()`）、渲染
    SQL（`ExecuteContext.sql()`）等的能力。在这个特定的情况下，我们感兴趣的是访问渲染的 SQL 并对其进行修改，因此我们重写了 `renderEnd(ExecuteContext)`
    并按照以下方式调用 `ExecuteContext.sql()`：
- en: '[PRE107]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The code from inside the decisional block is quite simple: we just capture
    the rendered SQL (the SQL that is about to be executed shortly) and modify it
    accordingly by adding the MySQL hint. But, what is `...data().containsKey("timeout_hint_select")`?
    Mainly, `Configuration` comes with three methods that work together to pass custom
    data through `Configuration`. These methods are `data(Object key, Object value)`,
    which allows us to set some custom data; `data(Object key)`, which allows us to
    get some custom data based on a key; and `data()`, which returns the entire `Map`
    of custom data. So, in our code, we check whether the custom data of the current
    `Configuration` contains a key named `timeout_hint_select` (this is a name we
    have chosen). If such a key exists, it means that we want to add the MySQL hint
    (which was set as the value corresponding to this key) to the current `SELECT`,
    otherwise, we take no action. This piece of custom information was set as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 决策块内的代码相当简单：我们只是捕获即将执行的渲染 SQL（即将不久执行的 SQL）并根据需要通过添加 MySQL 指令来修改它。但是，`...data().containsKey("timeout_hint_select")`
    是什么意思呢？主要的是，`Configuration` 提供了三种方法，它们协同工作，通过 `Configuration` 传递自定义数据。这些方法是 `data(Object
    key, Object value)`，它允许我们设置一些自定义数据；`data(Object key)`，它允许我们根据键获取一些自定义数据；以及 `data()`，它返回整个自定义数据的
    `Map`。因此，在我们的代码中，我们检查当前 `Configuration` 的自定义数据是否包含一个名为 `timeout_hint_select` 的键（这是我们选择的名字）。如果存在这样的键，这意味着我们想要将
    MySQL 指令（设置为与该键对应的值）添加到当前的 `SELECT` 中，否则，我们不做任何操作。这段自定义信息被设置为如下：
- en: '[PRE130]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Once this custom data is set, we can execute a `SELECT` that will be enriched
    with the MySQL hint by our custom `ExecuteListener`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了这段自定义数据，我们就可以执行一个 `SELECT`，它将通过我们的自定义 `ExecuteListener` 被丰富 MySQL 指令：
- en: '[PRE133]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'You can practice this example in *A250ExecuteListener* for MySQL. If you are
    using a Spring Boot version prior to 2.5.0, then go for *B250ExecuteListener*
    for MySQL. There is also an application named *ExecuteListener* for MySQL that
    does the same thing but it "inlines" `ExecuteListener` via `CallbackExecuteListener`
    (this represents `ExecuteListener` – useful if you prefer functional composition):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *A250ExecuteListener* 中练习这个例子，针对 MySQL。如果你使用的是 2.5.0 之前的 Spring Boot 版本，那么选择
    *B250ExecuteListener*。还有一个名为 *ExecuteListener* 的 MySQL 应用程序，它执行相同的功能，但它通过 `CallbackExecuteListener`（这代表
    `ExecuteListener` – 如果你更喜欢函数式组合，这很有用）来“内联” `ExecuteListener`：
- en: '[PRE134]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Most listeners have a functional composition approach as well that can be used
    as in the previous snippet of code. Next, let's talk about a listener named `ParseListener`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数监听器也有一个函数式组合的方法，可以在之前的代码片段中使用。接下来，让我们谈谈一个名为 `ParseListener` 的监听器。
- en: jOOQ SQL parser and ParseListener
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jOOQ SQL 解析器和 ParseListener
- en: '`ParseListener` (SQL Parser Listener) was introduced in jOOQ 3.15, but before
    discussing it, we should discuss the SQL `Parser` (`org.jooq.Parser`).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseListener`（SQL 解析监听器）是在 jOOQ 3.15 版本中引入的，但在讨论它之前，我们应该先讨论 SQL `Parser`（`org.jooq.Parser`）。'
- en: SQL Parser
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL 解析器
- en: jOOQ comes with a powerful and mature `Parser` API that is capable of parsing
    an arbitrary SQL string (or a fragment of it) into different jOOQ API elements.
    For instance, we have `Parser.parseQuery(String sql)`, which returns the `org.jooq.Query`
    type containing a single query that corresponds to the passed `sql`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 携带了一个强大且成熟的 `Parser` API，它能够将任意 SQL 字符串（或其片段）解析为不同的 jOOQ API 元素。例如，我们有
    `Parser.parseQuery(String sql)`，它返回包含单个查询的 `org.jooq.Query` 类型，该查询对应于传递的 `sql`。
- en: 'One of the main functionalities of the `Parser` API is that it can act as a
    translator between two dialects. In other words, we have SQL in dialect *X*, and
    we can programmatically pass it through the SQL `Parser` to obtain the SQL translated/emulated
    for dialect *Y*. For instance, consider a Spring Data JPA application that contains
    a significant number of native queries written for the MySQL dialect like this
    one:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parser` API 的主要功能之一是它可以在两种方言之间充当翻译器。换句话说，我们拥有方言 *X* 中的 SQL，并且可以通过 SQL `Parser`
    程序化地传递它，以获得为方言 *Y* 翻译/模拟的 SQL。例如，考虑一个包含大量为 MySQL 方言编写的原生查询的 Spring Data JPA 应用程序，如下所示：'
- en: '[PRE139]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The idea is that management took the decision to switch to PostgreSQL, so you
    should migrate all these queries to the PostgreSQL dialect and you should do it
    with insignificant downtime. Even if you are familiar with the differences between
    these two dialects and you don''t have a problem expressing both, you are still
    under time pressure. This is a scenario where jOOQ can save you because all you
    have to do is to pass to the jOOQ `Parser` your native queries and jOOQ will translate/emulate
    them for PostgreSQL. Assuming that you are using Spring Data JPA backed by Hibernate,
    then all you need to do is to add a Hibernate interceptor that exposes the SQL
    string that is about to execute:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 管理层决定切换到 PostgreSQL，因此你应该将这些查询迁移到 PostgreSQL 方言，并且你应该在不显著停机的情况下完成迁移。即使你熟悉这两个方言之间的差异，并且没有问题表达它们，你仍然处于时间压力之下。这是一个
    jOOQ 可以帮助你节省时间的场景，因为你只需要将你的原生查询传递给 jOOQ `Parser`，jOOQ 就会为 PostgreSQL 翻译/模拟它们。假设你正在使用由
    Hibernate 支持的 Spring Data JPA，那么你只需要添加一个 Hibernate 拦截器，该拦截器会公开即将执行的 SQL 字符串：
- en: '[PRE147]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Done in 5 minutes! How cool is that?! Obviously, your colleagues will ask you
    what sorcery this was, so you have a good opportunity to introduce them to jOOQ.
    :)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 5 分钟内完成！这有多酷？！显然，你的同事会问这是哪种魔法，所以你有一个很好的机会向他们介绍 jOOQ。 :)
- en: 'If you check out the console output, you''ll see that Hibernate reports the
    following SQL string to be executed against the PostgreSQL database:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看控制台输出，你会看到 Hibernate 报告了以下 SQL 字符串将被用于针对 PostgreSQL 数据库的执行：
- en: '[PRE160]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Of course, you can change the dialect and obtain the SQL for any of the jOOQ-supported
    dialects. Now, you have time to copy the jOOQ output and replace your native queries
    accordingly since the application continues to run as usual. At the end, simply
    decouple this interceptor. You can practice this application in *JPAParser*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以更改方言，并为任何 jOOQ 支持的方言获取 SQL。现在，你有时间复制 jOOQ 输出并相应地替换你的原生查询，因为应用程序仍然像往常一样运行。最后，只需解耦这个拦截器。你可以在
    *JPAParser* 中练习这个应用程序。
- en: Besides `parseQuery()`, we have `parseName(String sql)`, which parses the given
    `sql` into `org.jooq.Name`; `parseField(String sql)`, which parses the given `sql`
    into `org.jooq.Field`; `parseCondition(String sql)`, which parses the given `sql`
    into `org.jooq.Condition`; and so on. Please check out the jOOQ documentation
    to see all the methods and their flavors.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `parseQuery()`，我们还有 `parseName(String sql)`，它将给定的 `sql` 解析为 `org.jooq.Name`；`parseField(String
    sql)`，它将给定的 `sql` 解析为 `org.jooq.Field`；`parseCondition(String sql)`，它将给定的 `sql`
    解析为 `org.jooq.Condition`；等等。请查看 jOOQ 文档以了解所有方法和它们的变体。
- en: 'But jOOQ can do even more via the so-called *parsing connection* feature (available
    for R2DBC as well). Basically, this means that the SQL string is passed through
    the jOOQ `Parser` and the output SQL can become the source of a `java.sql.PreparedStatement`
    or `java.sql.Statement`, which can be executed via these JDBC APIs (`executeQuery(String
    sql)`). This happens as long as the SQL string comes through a JDBC connection
    (`java.sql.Connection`) that is obtained as in this example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但 jOOQ 通过所谓的 *解析连接* 功能（也适用于 R2DBC）可以做得更多。基本上，这意味着 SQL 字符串会通过 jOOQ `Parser` 传递，输出
    SQL 可以成为 `java.sql.PreparedStatement` 或 `java.sql.Statement` 的来源，这些可以通过这些 JDBC
    API（`executeQuery(String sql)`）执行。只要 SQL 字符串是通过 JDBC 连接（`java.sql.Connection`）获得的，就像这个例子中那样，就会发生这种情况：
- en: 'There''s no way from syntax alone to decide which input semantics it could
    be:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 仅从语法上无法决定它可能具有哪种输入语义：
- en: '[PRE168]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: The `sql` passed to the `PreparedStatement` represents any SQL string. For instance,
    it can be produced by `JdbcTemplate`, the Criteria API, `EntityManager`, and so
    on. Gathering the SQL string from the Criteria API and `EntityManager` can be
    a little bit tricky (since it requires a Hibernate `AbstractProducedQuery` action)
    but you can find the complete solution in *JPAParsingConnection* for MySQL.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `PreparedStatement` 的 `sql` 代表任何 SQL 字符串。例如，它可以通过 `JdbcTemplate`、Criteria
    API、`EntityManager` 等生成。从 Criteria API 和 `EntityManager` 中收集 SQL 字符串可能有点棘手（因为它需要
    Hibernate 的 `AbstractProducedQuery` 动作），但你可以在 *JPAParsingConnection* 中找到完整的解决方案（MySQL）。
- en: 'Besides the `Parser` API, jOOQ also exposes a translator between dialects via
    the `Parser` CLI ([https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-cli/](https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-cli/))
    and via this website: . Now, we can talk about `ParseListener`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Parser` API 之外，jOOQ 还通过 `Parser` CLI（[https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-cli/](https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-cli/)）和此网站公开了方言之间的翻译器。现在，我们可以谈谈
    `ParseListener`。
- en: SQL Parser Listener
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL 解析监听器
- en: It is quite easy to intuit that the SQL Parser Listener (`org.jooq.ParseListener`
    introduced in jOOQ 3.15) is responsible for providing hooks that allow altering
    the default behavior of the jOOQ parser.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易直观地看出，SQL 解析监听器（jOOQ 3.15 中引入的 `org.jooq.ParseListener`）负责提供钩子，允许更改 jOOQ
    解析器的默认行为。
- en: 'For instance, let''s consider the following `SELECT`, which uses the SQL `CONCAT_WS(separator,
    str1, str2, ...)` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下 `SELECT` 语句，它使用了 SQL 的 `CONCAT_WS(separator, str1, str2, ...)` 函数：
- en: '[PRE178]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'This variadic function that ignores `NULL` values and uses a string separator/delimiter
    to separate all arguments concatenated in the resulting string is natively supported
    by MySQL, PostgreSQL, and SQL Server but is not supported by Oracle. Moreover,
    jOOQ (at least until version 3.16.4) doesn''t support it either. One way to use
    it in our queries is via plain SQL as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个忽略 `NULL` 值并使用字符串分隔符/定界符来分隔所有连接到结果字符串中的参数的可变函数在 MySQL、PostgreSQL 和 SQL Server
    中是原生支持的，但在 Oracle 中不受支持。此外，jOOQ（至少直到版本 3.16.4）也不支持它。在我们的查询中使用它的方法之一是使用纯 SQL，如下所示：
- en: '[PRE181]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'But, if we try to execute this query against Oracle, it will not work since
    Oracle doesn''t support it and jOOQ doesn''t emulate it in Oracle syntax. A solution
    consists of implementing our own `ParseListener` that can emulate the `CONCAT_WS()`
    effect. For instance, the following `ParseListener` accomplishes this via the
    `NVL2()` function (please read all comments in the code in order to get you familiar
    with this API):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们尝试在 Oracle 上执行此查询，它将不会工作，因为 Oracle 不支持它，并且 jOOQ 也不在 Oracle 语法中模拟它。一个解决方案是实现我们自己的
    `ParseListener` 来模拟 `CONCAT_WS()` 的效果。例如，以下 `ParseListener` 通过 `NVL2()` 函数实现了这一点（请阅读代码中的所有注释，以便熟悉此
    API）：
- en: '[PRE184]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'After parsing, we prepare the Oracle emulation:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解析后，我们准备 Oracle 模拟：
- en: '[PRE196]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: To keep the code simple and short, we have considered some assumptions. Mainly,
    the separator and string literals should be enclosed in single quotes, the separator
    itself is a single character, and it should be at least one argument after the
    separator.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码简单且简短，我们考虑了一些假设。主要的是，分隔符和字符串字面量应该用单引号括起来，分隔符本身是单个字符，并且分隔符之后至少应该有一个参数。
- en: 'This time, when we do this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们这样做时：
- en: '[PRE217]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Our parser (followed by the jOOQ parser) produces this SQL compatible with
    Oracle syntax:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解析器（随后是 jOOQ 解析器）生成与 Oracle 语法兼容的 SQL：
- en: '[PRE224]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: You can practice this example in *A250ParseListener* for Oracle (for Spring
    Boot 2.5.0+), and in *B250ParseListener* for Oracle (for Spring Boot prior 2.5.0).
    Besides parsing fields (`Field`), `ParseListener` can also parse tables (`org.jooq.Table`
    via `parseTable()`) and conditions (`org.jooq.Condition` via `parseCondition()`).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *A250ParseListener* 中练习这个示例（适用于 Spring Boot 2.5.0+ 的 Oracle），以及在 *B250ParseListener*
    中练习这个示例（适用于 Spring Boot 2.5.0 之前的 Oracle）。除了解析字段（`Field`）外，`ParseListener` 还可以解析表（通过
    `parseTable()` 解析 `org.jooq.Table`）和条件（通过 `parseCondition()` 解析 `org.jooq.Condition`）。
- en: If you prefer functional composition, then check out `CallbackParseListener`.
    Next, let's quickly cover other jOOQ listeners.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢函数式组合，那么请查看 `CallbackParseListener`。接下来，让我们快速概述其他 jOOQ 监听器。
- en: RecordListener
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录监听器
- en: Via the jOOQ `RecordListener` implementations, we can add custom behavior during
    `UpdatableRecord` events such as insert, update, delete, store, and refresh (if
    you are not familiar with `UpdatableRecord`, then consider [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过jOOQ `RecordListener`实现，我们可以在`UpdatableRecord`事件（如插入、更新、删除、存储和刷新）期间添加自定义行为（如果您不熟悉`UpdatableRecord`，请考虑[*第3章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ核心概念*)）。
- en: For each *event* listen by `RecordListener` we have an `eventStart()` and `eventEnd()`
    method. `eventStart()` is a callback invoked before the *event* takes place, while
    the `eventEnd()` callback is invoked after the *event* has happened.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RecordListener`监听的每个*事件*，我们都有一个`eventStart()`和`eventEnd()`方法。`eventStart()`是在*事件*发生之前调用的回调，而`eventEnd()`回调是在*事件*发生后调用的。
- en: 'For instance, let''s consider that every time an `EmployeeRecord` is inserted,
    we have an algorithm that generates the primary key, `EMPLOYEE_NUMBER`. Next,
    the `EXTENSION` field is always of type *xEmployee_number* (for instance, if `EMPLOYEE_NUMBER`
    is *9887* then `EXTENSION` is *x9887*). Since we don''t want to let people do
    this task manually, we can easily automate this process via `RecordListener` as
    follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑每次插入`EmployeeRecord`时，我们都有一个生成主键`EMPLOYEE_NUMBER`的算法。接下来，`EXTENSION`字段始终为*xEmployee_number*类型（例如，如果`EMPLOYEE_NUMBER`是*9887*，则`EXTENSION`是*x9887*）。由于我们不希望让人们手动完成这项任务，我们可以通过`RecordListener`轻松自动化此过程，如下所示：
- en: '[PRE232]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Probably worth mentioning, `RecordListener` doesn't apply to ordinary DML statements
    (let alone plain SQL templates). People often think they can add some security
    stuff in there, which is then bypassed. It really only works on `TableRecord`/`UpdatableRecord`
    types. Starting from jOOQ 3.16, a lot of tasks that are currently solved with
    `RecordListener` are probably better solved with `VisitListener`, which will become
    *much* more powerful once the new query object model is in place ([https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/](https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/)).
    In jOOQ 3.16, it won't be ready for this task yet, but it might be in jOOQ 3.17.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可能值得提及的是，`RecordListener`不适用于普通DML语句（更不用说纯SQL模板了）。人们常常认为他们可以在其中添加一些安全内容，然后就会被绕过。它实际上仅适用于`TableRecord`/`UpdatableRecord`类型。从jOOQ
    3.16开始，许多目前使用`RecordListener`解决的问题可能更适合使用`VisitListener`来解决，一旦新的查询对象模型到位，它将变得*更加*强大（[https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/](https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/))。在jOOQ
    3.16中，它可能还没有准备好执行此任务，但可能在jOOQ 3.17中实现。
- en: 'You can practice this application in *{A,B}250RecordListener1* for MySQL. Moreover,
    you can find the *{A,B}250RecordListener2* application for MySQL, which extends
    this one by overriding `insertEnd()` to automatically insert a row in `EMPLOYEE_STATUS`
    based on the inserted `EmployeeRecord`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在MySQL的*{A,B}250RecordListener1*中练习此应用程序。此外，您还可以找到MySQL的*{A,B}250RecordListener2*应用程序，该应用程序通过重写`insertEnd()`来自动在`EMPLOYEE_STATUS`中插入一行，基于插入的`EmployeeRecord`：
- en: '[PRE243]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: If you prefer functional composition, then check out `CallbackRecordListener`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢函数式组合，那么请查看`CallbackRecordListener`。
- en: DiagnosticsListener
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DiagnosticsListener
- en: '`DiagnosticsListener` is available from jOOQ 3.11 and it fits perfectly in
    scenarios where you want to detect inefficiencies in your database interaction.
    This listener can act at different levels, such as jOOQ, JDBC, and SQL levels.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`DiagnosticsListener`从jOOQ 3.11开始提供，并且非常适合您想要检测数据库交互中的低效场景。此监听器可以在不同的级别上操作，例如jOOQ、JDBC和SQL级别。'
- en: Mainly, this listener exposes a suite of callbacks (one callback per problem
    it detects). For instance, we have `repeatedStatements()` for detecting N+1 problems,
    `tooManyColumnsFetched()` for detecting whether `ResultSet` fetches more columns
    than necessary, `tooManyRowsFetched()` for detecting whether `ResultSet` fetches
    more rows than necessary, and so on (you can find all of them in the documentation).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，此监听器公开了一系列回调（每个回调针对它检测到的问题）。例如，我们有`repeatedStatements()`用于检测N+1问题，`tooManyColumnsFetched()`用于检测`ResultSet`是否检索了比必要的更多列，`tooManyRowsFetched()`用于检测`ResultSet`是否检索了比必要的更多行，等等（您可以在文档中找到所有这些）。
- en: 'Let''s assume a Spring Data JPA application that runs the following classical
    N+1 scenario (the `Productline` and `Product` entities are involved in a lazy
    bidirectional `@OneToMany` relationship):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一个运行以下经典N+1场景的Spring Data JPA应用程序（`Productline`和`Product`实体涉及一个懒加载的双向`@OneToMany`关系）：
- en: '[PRE254]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'So, there is a `SELECT` triggered for fetching the product lines, and for each
    product line, there is a `SELECT` for fetching its products. Obviously, in performance
    terms, this is not efficient, and jOOQ can signal this via a custom `DiagnosticsListener`
    as shown next:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Now, the previous N+1 case will be logged, so you have been warned!
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ can diagnose over a `java.sql.Connection` (`diagnosticsConnection()`) or
    a `javax.sql.DataSource` (`diagnosticsDataSource()` wraps a `java.sql.Connection`
    in a `DataSource`). Exactly as in the case of a *parsing connection*, this JDBC
    connection proxies the underlying connection, therefore you have to pass your
    SQL through this proxy. In a Spring Data JPA application, you can quickly improvise
    a diagnose profile that relies on a `SingleConnectionDataSource`, as you can see
    in *JPADiagnosticsListener* for MySQL. The same case is available in *SDJDBCDiagnosticsListener*
    for MySQL, which wraps a Spring Data JDBC application. Also, the jOOQ manual has
    some cool JDBC examples that you should check ([https://www.jooq.org/doc/latest/manual/sql-execution/diagnostics/](https://www.jooq.org/doc/latest/manual/sql-execution/diagnostics/)).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: TransactionListener
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As its name suggests, `TransactionListener` provides hooks for interfering with
    transaction events such as begin, commit, and rollback. For each such *event*,
    there is an `eventBegin()`, called before the *event*, and an `eventEnd()`, called
    after the *event*. Moreover, for functional composition purposes, there is `CallbackTransactionListener`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a scenario that requires us to back up the data after each update
    of `EmployeeRecord`. By "back up," we understand that we need to save an `INSERT`
    containing the data before this update in the file corresponding to the employee
    to be updated.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '`TransactionListener` doesn''t expose information about the underlying SQL,
    therefore we cannot determine whether `EmployeeRecord` is updated or not from
    inside of this listener. But, we can do it from `RecordListener` and the `updateStart()`
    callback. When an `UPDATE` occurs, `updateStart()` is called and we can inspect
    the record type. If it is an `EmployeeRecord`, we can store its original (`original()`)
    state via `data()` as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'Now, you may think that, at the update end (`updateEnd()`), we can write the
    `EmployeeRecord` original state in the proper file. But a transaction can be rolled
    back, and in such a case, we should roll back the entry from the file as well.
    Obviously, this is cumbersome. It will be much easier to alter the file only after
    the transaction commits, so when we are sure that the update succeeded. Here is
    where `TransactionListener` and `commitEnd()` become useful:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Cool, right!? You just saw how to combine two listeners to accomplish a common
    task. Check the source in *{A,B}250RecordTransactionListener* for MySQL.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: VisitListener
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last listener that we'll briefly cover is probably the most complex one,
    `VisitListener`. Mainly, `VisitListener` is a listener that allows us to manipulate
    the jOOQ `QueryPart`) and clauses (`Clause`). So, we can visit `QueryPart` (via
    `visitStart()` and `visitEnd()`) and `Clause` (via `clauseStart()` and `clauseEnd()`).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'A very simple example could be like this: we want to create some views via
    the jOOQ DSL (`ctx.createOrReplaceView("product_view").as(...).execute()`) and
    we also want to add them to the `WITH CHECK OPTION` clause. Since the jOOQ DSL
    doesn''t support this clause, we can do it via `VisitListener` as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'While you can practice this trivial example in *{A,B}250VisitListener* for
    MySQL, I strongly recommend you read these two awesome articles from the jOOQ
    blog as well: [https://blog.jooq.org/implementing-client-side-row-level-security-with-jooq/](https://blog.jooq.org/implementing-client-side-row-level-security-with-jooq/)
    and [https://blog.jooq.org/jooq-internals-pushing-up-sql-fragments/](https://blog.jooq.org/jooq-internals-pushing-up-sql-fragments/).
    You''ll have the chance to learn a lot about the `VisitListener` API. You never
    know when you''ll need it! For instance, you may want to implement your *soft
    deletes* mechanism, add a condition for each query, and so on. In such scenarios,
    `VisitListener` is exactly what are you looking for! Moreover, when this book
    was written, jOOQ started to add a new player, called **Query Object Model** (**QOM**),
    as a public API. This API facilitates an easy, intuitive, and powerful traversal
    of the jOOQ AST. You don''t want to miss this article: [https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/](https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/).'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about altering the jOOQ code generation process.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Altering the jOOQ code generation process
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that jOOQ comes with three Code Generators (for Java, Scala,
    and Kotlin). For Java, we use `org.jooq.codegen.JavaGenerator`, which can be shaped/customized
    declaratively (or, programmatically) via a comprehensive set of configurations
    grouped under `<configuration>` (Maven), `configurations` (Gradle), or `org.jooq.meta.jaxb.Configuration`.
    But, sometimes, we need more control, or in other words, we need a custom generator
    implementation.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom generator
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a scenario where we need a query method and it would be very handy if
    it was provided by the built-in jOOQ DAO. Obviously, the jOOQ goal is to maintain
    a thin DAO layer that avoids a large number of methods caused by different types
    of query combinations (don't expect to see in the default DAO a query method such
    as `fetchByField1AndField2()` since trying to cover all combinations of fields
    (even for only two fields) leads to a heavy DAO layer that most probably will
    not be fully exploited).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: But, we can enrich the generated DAOs via a custom generator. An important aspect
    is the fact that a custom generator requires a separate project (or module) that
    will work as a dependency for the project that is going to use it. This is needed
    because the generator must run at compilation time, so the way to achieve this
    is by adding it as a dependency. Since we use a multi-module Spring Boot application,
    we can easily achieve this by adding the custom generator as a separate module
    of the project. This is very handy since most Spring Boot production apps are
    developed in multi-module style.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking about the effective implementation of a custom generator, we have
    to extend the Java generator, `org.jooq.codegen.JavaGenerator`, and override the
    default-empty method, `generateDaoClassFooter(TableDefinition table, JavaWriter
    out)`. The stub code is listed next:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Based on this stub code, let's generate additional DAO query methods.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Adding a query method to all DAOs
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to add a query method to all the generated DAOs,
    for instance, a method that limits the number of fetched POJOs (records), such
    as `List<POJO> findLimitedTo(Integer value)`, where `value` represents the number
    of POJOs to fetch in the `List`. Check out the code:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Let''s quickly see what is happening here:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: In line 5, we ask jOOQ to give the name of the generated POJO that corresponds
    to the current `table` and that is used in our query method to return a `List<POJO>`.
    For instance, for the `ORDER` table, `getFullJavaClassName()` returns `jooq.generated.tables.pojos.Order`.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line 9, we generate some Javadoc.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In lines 11-17, we generate the method signature and its body. The `getFullJavaIdentifier()`
    used at line 14 gives us the fully qualified name of the current table (for example,
    `jooq.generated.tables.Order.ORDER`).
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ctx()` method used on line 13 and `mapper()` used in line 16 are defined
    in the `org.jooq.impl.DAOImpl` class. Each generated DAO extends `DAOImpl`, and
    therefore has access to these methods.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on this code, the jOOQ generator adds at the end of each generated DAO
    a method as follows (this method is added in `OrderRepository`):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: How about adding methods only in certain DAOs?
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Adding a query method in certain DAOs
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add a query method named `findOrderByStatusAndOrderDate()` only in the
    `OrderRepository` DAO. A simple and quick solution consists of checking the table
    name via the `TableDefinition` argument of the `generateDaoClassFooter()` method.
    For instance, the following code adds the `findOrderByStatusAndOrderDate()` method
    only in the DAO that corresponds to the `ORDER` table:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'This code generates `findOrderByStatusAndOrderDate()` only in `jooq.generated.tables.daos.OrderRepository`:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: Besides `table.getName()`, you can enforce the previous condition for more control
    via `table.getCatalog()`, `table.getQualifiedName()`,`table.getSchema()`, and
    so on.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is available in *AddDAOMethods* for MySQL and Oracle.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, if you need to enrich the jOOQ-generated DAOs with the corresponding
    interfaces, then you need a custom generator as in the application named *InterfacesDao*
    for MySQL and Oracle. If you check out this code, you'll see a so-called *custom
    generator strategy*. Next, let's detail this aspect.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom generator strategy
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already know how to use `<strategy>` (Maven), `strategy {}` (Gradle), or
    `withStrategy()` (programmatic) to inject custom behavior for naming classes,
    methods, members, and so on during the jOOQ code generation process. For instance,
    we have used this technique for renaming our DAO classes in Spring Data JPA style.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'But, overriding naming schemes during code generation can be accomplished via
    a custom generator strategy as well. For instance, this is useful when we want
    to generate certain method names as in our scenario that starts from the following
    query:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: This is a self-join that relies on the `employee()` navigation method. Conforming
    to the default generator strategy, writing a self-join is done via a navigation
    method having the same name as the table itself (for the `EMPLOYEE` table, we
    have the `employee()` method).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'But, if you find `EMPLOYEE.employee()` a little bit confusing, and you prefer
    something more meaningful, such as `EMPLOYEE.reportsTo()` (or something else),
    then you need a custom generator strategy. This can be accomplished by extending
    the jOOQ `DefaultGeneratorStrategy` and overriding the proper methods described
    in the jOOQ manual: [https://www.jooq.org/doc/latest/manual/code-generation/codegen-generatorstrategy/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-generatorstrategy/).'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our case, we need to override `getJavaMethodName()` as follows:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: 'Finally, we have to set this custom generator strategy as follows (here, for
    Maven, but you can easily intuit how to do it for Gradle or programmatically):'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: 'Done! Now, after code generation, you can re-write the previous query as follows
    (notice the `reportsTo()` method instead of `employee()`):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: The jOOQ Java default generator strategy follows the *Pascal* naming strategy,
    which is the most popular in the Java language. But, besides the *Pascal* naming
    strategy, jOOQ also comes with a `KeepNamesGeneratorStrategy` custom generator
    strategy that simply holds names in place. Moreover, you may like to study `JPrefixGeneratorStrategy`,
    respectively the `JVMArgsGeneratorStrategy`. These are just some examples (they
    are not part of the jOOQ Code Generator) that can be found on GitHub at [https://github.com/jOOQ/jOOQ/tree/main/jOOQ-codegen/src/main/java/org/jooq/codegen/example](https://github.com/jOOQ/jOOQ/tree/main/jOOQ-codegen/src/main/java/org/jooq/codegen/example).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have briefly covered the jOOQ SPI. Obviously, the tasks
    solved via an SPI are not daily tasks and require overall solid knowledge about
    the underlying technology. But, since you have read earlier chapters in this book,
    you should have no problems assimilating the knowledge in this chapter as well.
    But, of course, using this SPI to solve real problems requires more study of the
    documentation and more practice.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了jOOQ SPI。显然，通过SPI解决的问题不是日常任务，需要整体上对底层技术有扎实的知识。但是，由于您已经阅读了本书的前几章，您应该没有问题吸收本章中的知识。当然，使用这个SPI来解决实际问题需要更多地研究文档并多加实践。
- en: In the next chapter, we tackle logging and testing jOOQ applications.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨jOOQ应用的日志记录和测试。
