- en: '*Chapter 18*: jOOQ SPI (Providers and Listeners)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ provides a lot of hooks that allow us to alter its default behavior at
    different levels. Among these hooks, we have lightweight settings and configurations,
    and the heavy-duty, extremely stable **Service Provider Interface** (**SPI**)
    made of generators, providers, listeners, parsers, and so on. So, like any robust
    and mature technology, jOOQ comes with an impressive SPI dedicated to those corner
    cases where the core technology cannot help.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we scratch the surface of each of these hooks in order to
    expose the usage steps and some examples that will help you to understand how
    to develop your own implementations. Our agenda includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jOOQ configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jOOQ providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jOOQ listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering the jOOQ code generation process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter18](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter18).
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'jOOQ comes with a comprehensive list of settings (`org.jooq.conf.Settings`)
    that attempts to cover the most popular use cases related to rendering the SQL
    code. These settings are available declaratively (via `jooq-settings.xml` in the
    classpath) or programmatically via methods such as `setFooSetting()` or `withFooSetting()`,
    which can be chained in a fluent style. To take effect, `Settings` must be part
    of `org.jooq.Configuration`, and this can be done in multiple ways, as you can
    read in the jOOQ manual at [https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/](https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/).
    But most probably, in a Spring Boot application, you''ll prefer one of the following
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass global `Settings` to the default `Configuration` via `jooq-settings.xml`
    in the classpath (the `DSLContext` prepared by Spring Boot will take advantage
    of these settings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass global `Settings` to the default `Configuration` via an `@Bean` (the `DSLContext`
    prepared by Spring Boot will take advantage of these settings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'At some point, set a new global `Settings` that will be applied from this point
    onward (this is a global `Settings` because we use `Configuration#set()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Append new global settings to the current global `Settings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *GlobalSettings* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'At some point, set a new local `Settings` that will be applied only to the
    current query (this is a local `Settings` because we use `Configuration#derive()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, setting a global/local setting and appends to it more local settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *LocalSettings* for MySQL. It is highly recommended
    to reserve some time and at least to briefly scroll the entire list of jOOQ-supported
    settings at [https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/conf/Settings.html](https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/conf/Settings.html).
    Next, let's talk about jOOQ `Configuration`.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`org.jooq.Configuration` represents the spine of `DSLContext`. `DSLContext`
    needs the precious information provided by `Configuration` for query rendering
    and execution. While `Configuration` takes advantage of `Settings` (as you just
    saw), it also has a lot more other configurations that can be specified as in
    the examples from this section.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring Boot gives us a `DSLContext` built on the default `Configuration`
    (the `Configuration` accessible via `ctx.configuration()`), and as you know, while
    providing custom settings and configurations, we can alter this `Configuration`
    globally via `set()` or locally by creating a derived one via `derive()`.
  prefs: []
  type: TYPE_NORMAL
- en: But, in some scenarios, for instance, when you build custom providers or listeners,
    you'll prefer to build the `Configuration` to be aware of your artifacts right
    from the start instead of extracting it from `DSLContext`. In other words, when
    `DSLContext` is built, it should use the ready-to-go `Configuration`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Spring Boot 2.5.0, this step required a little bit of effort, as you
    can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is a `Configuration` created from scratch (actually from the jOOQ built-in
    `DefaultConfiguration`) that will be used by Spring Boot to create the `DSLContext`.
    At a minimum, we need to specify a `ConnectionProvider` and the SQL dialect. Optionally,
    if we want to use `SpringTransactionProvider` as the default provider for jOOQ
    transactions, then we need to set it as in this code. After this minimum configuration,
    you can continue adding your settings, providers, listeners, and so on. You can
    practice this example in *Before250Config* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with version 2.5.0, Spring Boot facilitates easier customization of
    jOOQ''s `DefaultConfiguration` via a bean that implements a functional interface
    named `DefaultConfigurationCustomizer`. This acts as a callback and can be used
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is more practical because we can add only what we need. You can check out
    this example in *After250Config* for MySQL. Next, let's talk about jOOQ providers.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jOOQ SPI exposes a suite of providers such as `TransactionProvider`, `RecordMapperProvider`,
    `ConverterProvider`, and so on. Their overall goal is simple—to provide some feature
    that is not provided by the jOOQ default providers. For instance, let's check
    out `TransactionProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: TransactionProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For instance, we know that jOOQ transactions are backed in Spring Boot by a
    transaction provider named `SpringTransactionProvider` (the Spring Boot built-in
    implementation of jOOQ's `TransactionProvider`) that exposes by default a read-write
    transaction with no name (`null`), having the propagation set to `PROPAGATION_NESTED`
    and the isolation level to the default isolation level of the underlying database,
    `ISOLATION_DEFAULT`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's assume that we implement a module of our application that serves
    only reports via jOOQ transactions (so we don't use `@Transactional`). In such
    a module, we don't want to allow writing, we want to run each query in a separate/new
    transaction with a timeout of 1 second, and we want to avoid the `PROPAGATION_REQUIRES_NEW`,
    the isolation level set to `ISOLATION_READ_COMMITTED`, and the timeout set to
    1 second.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain such a transaction, we can implement a `TransactionProvider` and
    override the `begin()` method as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the transaction provider, we have to configure it in jOOQ. Assuming
    that we are using Spring Boot 2.5.0+, and based on the previous section, this
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'You can practice this example in *A250MyTransactionProvider* for MySQL. When
    you run the application, you''ll notice at the console that the created transaction
    has these coordinates: *Creating new transaction with name [TRANSACTION_1000]:
    PROPAGATION_REQUIRES_NEW, ISOLATION_READ_COMMITTED, timeout_1, readOnly*.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Spring Boot version prior to 2.5.0, then check out the application
    named *B250MyTransactionProvider* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, of course, you can configure the provider via `DSLContext` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's consider another scenario solved via `ConverterProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: ConverterProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to project some JSON functions and map them hierarchically. We already
    know that this is no issue in a Spring Boot + jOOQ combo since jOOQ can fetch
    the JSON and can call Jackson (the default in Spring Boot) to map it accordingly.
    But, we don't want to use Jackson; we want to use Flexjson ([http://flexjson.sourceforge.net/](http://flexjson.sourceforge.net/)).
    jOOQ is not aware of this library (jOOQ can detect only the presence of Jackson
    and Gson), so we need to provide a converter such as `org.jooq.ConverterProvider`
    that uses Flexjson to accomplish this task. Take your time to check the source
    in *{A,B}250ConverterProvider* for MySQL. Finally, let's focus on this scenario
    solved via `RecordMapperProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: RecordMapperProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a ton of legacy POJOs implemented via the `Builder` pattern and we decide
    to write a bunch of jOOQ `RecordMapper` for mapping queries to these POJOs. In
    order to streamline the process of using these `RecordMapper`, we also decide
    to write a `RecordMapperProvider`. Basically, this will be responsible for using
    the proper `RecordMapper` without our explicit intervention. Are you curious about
    how to do it? Then check out the *{A,B}250RecordMapperProvider* and *RecordMapperProvider*
    applications for MySQL. Mainly, these applications are the same, but they use
    different approaches to configure `RecordMapperProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: With `ConverterProvider` and `RecordMapperProvider`, I think it's important
    to mention that these *replace* out-of-the-box behavior, they don't *enhance*
    it. So, custom providers have to make sure to fall back to the default implementations
    if they can't handle a conversion/mapping.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jOOQ comes with a significant number of listeners that are quite versatile and
    useful in hooking us into jOOQ life cycle management for solving a wide range
    of tasks. Let's "arbitrarily" pick up the mighty `ExecuteListener`.
  prefs: []
  type: TYPE_NORMAL
- en: ExecuteListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For instance, one of the listeners that you'll love is `org.jooq.ExecuteListener`.
    This listener comes with a bunch of methods that can hook in the life cycle of
    a `Query`, `Routine`, or `ResultSet` to alter the default rendering, preparing,
    binding, executing, and fetching stage. The most convenient approach to implement
    your own listener is to extend the jOOQ default implementation, `DefaultExecuteListener`.
    This way, you can override only the methods that you want and you keep up with
    the SPI evolution (however, by the time you read this book, it is possible that
    this default listener will have been removed, and all methods are now default
    methods on the interface). Consider applying this technique to any other jOOQ
    listener, since jOOQ provides a default implementation for all (mainly, for `FooListener`,
    there is a `DefaultFooListener`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s write an `ExecuteListener` that alters the rendered SQL that
    is about to be executed. Basically, all we want is to alter every MySQL `SELECT`
    by adding the `/*+ MAX_EXECUTION_TIME(n) */` hint, which allows us to specify
    a query timeout in milliseconds. The jOOQ DSL allows for adding MySQL/Oracle-style
    hints. :) Use `ctx.select(...).hint("/*+ ... */").from(...)`. But only `ExecuteListener`
    can patch multiple queries without modifying the queries themselves. So, `ExecuteListener`
    exposes callbacks such as `renderStart(ExecuteContext)` and `renderEnd(ExecuteContext)`,
    which are called before rendering SQL from `QueryPart` and after rendering SQL
    from `QueryPart`, respectively. Once we are in control, we can rely on `ExecuteContext`,
    which gives us access to the underlying connection (`ExecuteContext.connection()`),
    query (`ExecuteContext.query()`), rendered SQL (`ExecuteContext.sql()`), and so
    on. In this specific case, we are interested in accessing the rendered SQL and
    modifying it, so we override `renderEnd(ExecuteContext)` and call `ExecuteContext.sql()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The code from inside the decisional block is quite simple: we just capture
    the rendered SQL (the SQL that is about to be executed shortly) and modify it
    accordingly by adding the MySQL hint. But, what is `...data().containsKey("timeout_hint_select")`?
    Mainly, `Configuration` comes with three methods that work together to pass custom
    data through `Configuration`. These methods are `data(Object key, Object value)`,
    which allows us to set some custom data; `data(Object key)`, which allows us to
    get some custom data based on a key; and `data()`, which returns the entire `Map`
    of custom data. So, in our code, we check whether the custom data of the current
    `Configuration` contains a key named `timeout_hint_select` (this is a name we
    have chosen). If such a key exists, it means that we want to add the MySQL hint
    (which was set as the value corresponding to this key) to the current `SELECT`,
    otherwise, we take no action. This piece of custom information was set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this custom data is set, we can execute a `SELECT` that will be enriched
    with the MySQL hint by our custom `ExecuteListener`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'You can practice this example in *A250ExecuteListener* for MySQL. If you are
    using a Spring Boot version prior to 2.5.0, then go for *B250ExecuteListener*
    for MySQL. There is also an application named *ExecuteListener* for MySQL that
    does the same thing but it "inlines" `ExecuteListener` via `CallbackExecuteListener`
    (this represents `ExecuteListener` – useful if you prefer functional composition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Most listeners have a functional composition approach as well that can be used
    as in the previous snippet of code. Next, let's talk about a listener named `ParseListener`.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ SQL parser and ParseListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ParseListener` (SQL Parser Listener) was introduced in jOOQ 3.15, but before
    discussing it, we should discuss the SQL `Parser` (`org.jooq.Parser`).'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Parser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jOOQ comes with a powerful and mature `Parser` API that is capable of parsing
    an arbitrary SQL string (or a fragment of it) into different jOOQ API elements.
    For instance, we have `Parser.parseQuery(String sql)`, which returns the `org.jooq.Query`
    type containing a single query that corresponds to the passed `sql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main functionalities of the `Parser` API is that it can act as a
    translator between two dialects. In other words, we have SQL in dialect *X*, and
    we can programmatically pass it through the SQL `Parser` to obtain the SQL translated/emulated
    for dialect *Y*. For instance, consider a Spring Data JPA application that contains
    a significant number of native queries written for the MySQL dialect like this
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is that management took the decision to switch to PostgreSQL, so you
    should migrate all these queries to the PostgreSQL dialect and you should do it
    with insignificant downtime. Even if you are familiar with the differences between
    these two dialects and you don''t have a problem expressing both, you are still
    under time pressure. This is a scenario where jOOQ can save you because all you
    have to do is to pass to the jOOQ `Parser` your native queries and jOOQ will translate/emulate
    them for PostgreSQL. Assuming that you are using Spring Data JPA backed by Hibernate,
    then all you need to do is to add a Hibernate interceptor that exposes the SQL
    string that is about to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Done in 5 minutes! How cool is that?! Obviously, your colleagues will ask you
    what sorcery this was, so you have a good opportunity to introduce them to jOOQ.
    :)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check out the console output, you''ll see that Hibernate reports the
    following SQL string to be executed against the PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can change the dialect and obtain the SQL for any of the jOOQ-supported
    dialects. Now, you have time to copy the jOOQ output and replace your native queries
    accordingly since the application continues to run as usual. At the end, simply
    decouple this interceptor. You can practice this application in *JPAParser*.
  prefs: []
  type: TYPE_NORMAL
- en: Besides `parseQuery()`, we have `parseName(String sql)`, which parses the given
    `sql` into `org.jooq.Name`; `parseField(String sql)`, which parses the given `sql`
    into `org.jooq.Field`; `parseCondition(String sql)`, which parses the given `sql`
    into `org.jooq.Condition`; and so on. Please check out the jOOQ documentation
    to see all the methods and their flavors.
  prefs: []
  type: TYPE_NORMAL
- en: 'But jOOQ can do even more via the so-called *parsing connection* feature (available
    for R2DBC as well). Basically, this means that the SQL string is passed through
    the jOOQ `Parser` and the output SQL can become the source of a `java.sql.PreparedStatement`
    or `java.sql.Statement`, which can be executed via these JDBC APIs (`executeQuery(String
    sql)`). This happens as long as the SQL string comes through a JDBC connection
    (`java.sql.Connection`) that is obtained as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no way from syntax alone to decide which input semantics it could
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: The `sql` passed to the `PreparedStatement` represents any SQL string. For instance,
    it can be produced by `JdbcTemplate`, the Criteria API, `EntityManager`, and so
    on. Gathering the SQL string from the Criteria API and `EntityManager` can be
    a little bit tricky (since it requires a Hibernate `AbstractProducedQuery` action)
    but you can find the complete solution in *JPAParsingConnection* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `Parser` API, jOOQ also exposes a translator between dialects via
    the `Parser` CLI ([https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-cli/](https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-cli/))
    and via this website: . Now, we can talk about `ParseListener`.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Parser Listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is quite easy to intuit that the SQL Parser Listener (`org.jooq.ParseListener`
    introduced in jOOQ 3.15) is responsible for providing hooks that allow altering
    the default behavior of the jOOQ parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s consider the following `SELECT`, which uses the SQL `CONCAT_WS(separator,
    str1, str2, ...)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'This variadic function that ignores `NULL` values and uses a string separator/delimiter
    to separate all arguments concatenated in the resulting string is natively supported
    by MySQL, PostgreSQL, and SQL Server but is not supported by Oracle. Moreover,
    jOOQ (at least until version 3.16.4) doesn''t support it either. One way to use
    it in our queries is via plain SQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'But, if we try to execute this query against Oracle, it will not work since
    Oracle doesn''t support it and jOOQ doesn''t emulate it in Oracle syntax. A solution
    consists of implementing our own `ParseListener` that can emulate the `CONCAT_WS()`
    effect. For instance, the following `ParseListener` accomplishes this via the
    `NVL2()` function (please read all comments in the code in order to get you familiar
    with this API):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'After parsing, we prepare the Oracle emulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: To keep the code simple and short, we have considered some assumptions. Mainly,
    the separator and string literals should be enclosed in single quotes, the separator
    itself is a single character, and it should be at least one argument after the
    separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, when we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Our parser (followed by the jOOQ parser) produces this SQL compatible with
    Oracle syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: You can practice this example in *A250ParseListener* for Oracle (for Spring
    Boot 2.5.0+), and in *B250ParseListener* for Oracle (for Spring Boot prior 2.5.0).
    Besides parsing fields (`Field`), `ParseListener` can also parse tables (`org.jooq.Table`
    via `parseTable()`) and conditions (`org.jooq.Condition` via `parseCondition()`).
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer functional composition, then check out `CallbackParseListener`.
    Next, let's quickly cover other jOOQ listeners.
  prefs: []
  type: TYPE_NORMAL
- en: RecordListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Via the jOOQ `RecordListener` implementations, we can add custom behavior during
    `UpdatableRecord` events such as insert, update, delete, store, and refresh (if
    you are not familiar with `UpdatableRecord`, then consider [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*).
  prefs: []
  type: TYPE_NORMAL
- en: For each *event* listen by `RecordListener` we have an `eventStart()` and `eventEnd()`
    method. `eventStart()` is a callback invoked before the *event* takes place, while
    the `eventEnd()` callback is invoked after the *event* has happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s consider that every time an `EmployeeRecord` is inserted,
    we have an algorithm that generates the primary key, `EMPLOYEE_NUMBER`. Next,
    the `EXTENSION` field is always of type *xEmployee_number* (for instance, if `EMPLOYEE_NUMBER`
    is *9887* then `EXTENSION` is *x9887*). Since we don''t want to let people do
    this task manually, we can easily automate this process via `RecordListener` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Probably worth mentioning, `RecordListener` doesn't apply to ordinary DML statements
    (let alone plain SQL templates). People often think they can add some security
    stuff in there, which is then bypassed. It really only works on `TableRecord`/`UpdatableRecord`
    types. Starting from jOOQ 3.16, a lot of tasks that are currently solved with
    `RecordListener` are probably better solved with `VisitListener`, which will become
    *much* more powerful once the new query object model is in place ([https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/](https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/)).
    In jOOQ 3.16, it won't be ready for this task yet, but it might be in jOOQ 3.17.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can practice this application in *{A,B}250RecordListener1* for MySQL. Moreover,
    you can find the *{A,B}250RecordListener2* application for MySQL, which extends
    this one by overriding `insertEnd()` to automatically insert a row in `EMPLOYEE_STATUS`
    based on the inserted `EmployeeRecord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer functional composition, then check out `CallbackRecordListener`.
  prefs: []
  type: TYPE_NORMAL
- en: DiagnosticsListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DiagnosticsListener` is available from jOOQ 3.11 and it fits perfectly in
    scenarios where you want to detect inefficiencies in your database interaction.
    This listener can act at different levels, such as jOOQ, JDBC, and SQL levels.'
  prefs: []
  type: TYPE_NORMAL
- en: Mainly, this listener exposes a suite of callbacks (one callback per problem
    it detects). For instance, we have `repeatedStatements()` for detecting N+1 problems,
    `tooManyColumnsFetched()` for detecting whether `ResultSet` fetches more columns
    than necessary, `tooManyRowsFetched()` for detecting whether `ResultSet` fetches
    more rows than necessary, and so on (you can find all of them in the documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume a Spring Data JPA application that runs the following classical
    N+1 scenario (the `Productline` and `Product` entities are involved in a lazy
    bidirectional `@OneToMany` relationship):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'So, there is a `SELECT` triggered for fetching the product lines, and for each
    product line, there is a `SELECT` for fetching its products. Obviously, in performance
    terms, this is not efficient, and jOOQ can signal this via a custom `DiagnosticsListener`
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Now, the previous N+1 case will be logged, so you have been warned!
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ can diagnose over a `java.sql.Connection` (`diagnosticsConnection()`) or
    a `javax.sql.DataSource` (`diagnosticsDataSource()` wraps a `java.sql.Connection`
    in a `DataSource`). Exactly as in the case of a *parsing connection*, this JDBC
    connection proxies the underlying connection, therefore you have to pass your
    SQL through this proxy. In a Spring Data JPA application, you can quickly improvise
    a diagnose profile that relies on a `SingleConnectionDataSource`, as you can see
    in *JPADiagnosticsListener* for MySQL. The same case is available in *SDJDBCDiagnosticsListener*
    for MySQL, which wraps a Spring Data JDBC application. Also, the jOOQ manual has
    some cool JDBC examples that you should check ([https://www.jooq.org/doc/latest/manual/sql-execution/diagnostics/](https://www.jooq.org/doc/latest/manual/sql-execution/diagnostics/)).
  prefs: []
  type: TYPE_NORMAL
- en: TransactionListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As its name suggests, `TransactionListener` provides hooks for interfering with
    transaction events such as begin, commit, and rollback. For each such *event*,
    there is an `eventBegin()`, called before the *event*, and an `eventEnd()`, called
    after the *event*. Moreover, for functional composition purposes, there is `CallbackTransactionListener`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a scenario that requires us to back up the data after each update
    of `EmployeeRecord`. By "back up," we understand that we need to save an `INSERT`
    containing the data before this update in the file corresponding to the employee
    to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: '`TransactionListener` doesn''t expose information about the underlying SQL,
    therefore we cannot determine whether `EmployeeRecord` is updated or not from
    inside of this listener. But, we can do it from `RecordListener` and the `updateStart()`
    callback. When an `UPDATE` occurs, `updateStart()` is called and we can inspect
    the record type. If it is an `EmployeeRecord`, we can store its original (`original()`)
    state via `data()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you may think that, at the update end (`updateEnd()`), we can write the
    `EmployeeRecord` original state in the proper file. But a transaction can be rolled
    back, and in such a case, we should roll back the entry from the file as well.
    Obviously, this is cumbersome. It will be much easier to alter the file only after
    the transaction commits, so when we are sure that the update succeeded. Here is
    where `TransactionListener` and `commitEnd()` become useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right!? You just saw how to combine two listeners to accomplish a common
    task. Check the source in *{A,B}250RecordTransactionListener* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: VisitListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last listener that we'll briefly cover is probably the most complex one,
    `VisitListener`. Mainly, `VisitListener` is a listener that allows us to manipulate
    the jOOQ `QueryPart`) and clauses (`Clause`). So, we can visit `QueryPart` (via
    `visitStart()` and `visitEnd()`) and `Clause` (via `clauseStart()` and `clauseEnd()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A very simple example could be like this: we want to create some views via
    the jOOQ DSL (`ctx.createOrReplaceView("product_view").as(...).execute()`) and
    we also want to add them to the `WITH CHECK OPTION` clause. Since the jOOQ DSL
    doesn''t support this clause, we can do it via `VisitListener` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'While you can practice this trivial example in *{A,B}250VisitListener* for
    MySQL, I strongly recommend you read these two awesome articles from the jOOQ
    blog as well: [https://blog.jooq.org/implementing-client-side-row-level-security-with-jooq/](https://blog.jooq.org/implementing-client-side-row-level-security-with-jooq/)
    and [https://blog.jooq.org/jooq-internals-pushing-up-sql-fragments/](https://blog.jooq.org/jooq-internals-pushing-up-sql-fragments/).
    You''ll have the chance to learn a lot about the `VisitListener` API. You never
    know when you''ll need it! For instance, you may want to implement your *soft
    deletes* mechanism, add a condition for each query, and so on. In such scenarios,
    `VisitListener` is exactly what are you looking for! Moreover, when this book
    was written, jOOQ started to add a new player, called **Query Object Model** (**QOM**),
    as a public API. This API facilitates an easy, intuitive, and powerful traversal
    of the jOOQ AST. You don''t want to miss this article: [https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/](https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about altering the jOOQ code generation process.
  prefs: []
  type: TYPE_NORMAL
- en: Altering the jOOQ code generation process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that jOOQ comes with three Code Generators (for Java, Scala,
    and Kotlin). For Java, we use `org.jooq.codegen.JavaGenerator`, which can be shaped/customized
    declaratively (or, programmatically) via a comprehensive set of configurations
    grouped under `<configuration>` (Maven), `configurations` (Gradle), or `org.jooq.meta.jaxb.Configuration`.
    But, sometimes, we need more control, or in other words, we need a custom generator
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a scenario where we need a query method and it would be very handy if
    it was provided by the built-in jOOQ DAO. Obviously, the jOOQ goal is to maintain
    a thin DAO layer that avoids a large number of methods caused by different types
    of query combinations (don't expect to see in the default DAO a query method such
    as `fetchByField1AndField2()` since trying to cover all combinations of fields
    (even for only two fields) leads to a heavy DAO layer that most probably will
    not be fully exploited).
  prefs: []
  type: TYPE_NORMAL
- en: But, we can enrich the generated DAOs via a custom generator. An important aspect
    is the fact that a custom generator requires a separate project (or module) that
    will work as a dependency for the project that is going to use it. This is needed
    because the generator must run at compilation time, so the way to achieve this
    is by adding it as a dependency. Since we use a multi-module Spring Boot application,
    we can easily achieve this by adding the custom generator as a separate module
    of the project. This is very handy since most Spring Boot production apps are
    developed in multi-module style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking about the effective implementation of a custom generator, we have
    to extend the Java generator, `org.jooq.codegen.JavaGenerator`, and override the
    default-empty method, `generateDaoClassFooter(TableDefinition table, JavaWriter
    out)`. The stub code is listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Based on this stub code, let's generate additional DAO query methods.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a query method to all DAOs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to add a query method to all the generated DAOs,
    for instance, a method that limits the number of fetched POJOs (records), such
    as `List<POJO> findLimitedTo(Integer value)`, where `value` represents the number
    of POJOs to fetch in the `List`. Check out the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly see what is happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: In line 5, we ask jOOQ to give the name of the generated POJO that corresponds
    to the current `table` and that is used in our query method to return a `List<POJO>`.
    For instance, for the `ORDER` table, `getFullJavaClassName()` returns `jooq.generated.tables.pojos.Order`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line 9, we generate some Javadoc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In lines 11-17, we generate the method signature and its body. The `getFullJavaIdentifier()`
    used at line 14 gives us the fully qualified name of the current table (for example,
    `jooq.generated.tables.Order.ORDER`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ctx()` method used on line 13 and `mapper()` used in line 16 are defined
    in the `org.jooq.impl.DAOImpl` class. Each generated DAO extends `DAOImpl`, and
    therefore has access to these methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on this code, the jOOQ generator adds at the end of each generated DAO
    a method as follows (this method is added in `OrderRepository`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: How about adding methods only in certain DAOs?
  prefs: []
  type: TYPE_NORMAL
- en: Adding a query method in certain DAOs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add a query method named `findOrderByStatusAndOrderDate()` only in the
    `OrderRepository` DAO. A simple and quick solution consists of checking the table
    name via the `TableDefinition` argument of the `generateDaoClassFooter()` method.
    For instance, the following code adds the `findOrderByStatusAndOrderDate()` method
    only in the DAO that corresponds to the `ORDER` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates `findOrderByStatusAndOrderDate()` only in `jooq.generated.tables.daos.OrderRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Besides `table.getName()`, you can enforce the previous condition for more control
    via `table.getCatalog()`, `table.getQualifiedName()`,`table.getSchema()`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is available in *AddDAOMethods* for MySQL and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, if you need to enrich the jOOQ-generated DAOs with the corresponding
    interfaces, then you need a custom generator as in the application named *InterfacesDao*
    for MySQL and Oracle. If you check out this code, you'll see a so-called *custom
    generator strategy*. Next, let's detail this aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom generator strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already know how to use `<strategy>` (Maven), `strategy {}` (Gradle), or
    `withStrategy()` (programmatic) to inject custom behavior for naming classes,
    methods, members, and so on during the jOOQ code generation process. For instance,
    we have used this technique for renaming our DAO classes in Spring Data JPA style.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, overriding naming schemes during code generation can be accomplished via
    a custom generator strategy as well. For instance, this is useful when we want
    to generate certain method names as in our scenario that starts from the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: This is a self-join that relies on the `employee()` navigation method. Conforming
    to the default generator strategy, writing a self-join is done via a navigation
    method having the same name as the table itself (for the `EMPLOYEE` table, we
    have the `employee()` method).
  prefs: []
  type: TYPE_NORMAL
- en: 'But, if you find `EMPLOYEE.employee()` a little bit confusing, and you prefer
    something more meaningful, such as `EMPLOYEE.reportsTo()` (or something else),
    then you need a custom generator strategy. This can be accomplished by extending
    the jOOQ `DefaultGeneratorStrategy` and overriding the proper methods described
    in the jOOQ manual: [https://www.jooq.org/doc/latest/manual/code-generation/codegen-generatorstrategy/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-generatorstrategy/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our case, we need to override `getJavaMethodName()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to set this custom generator strategy as follows (here, for
    Maven, but you can easily intuit how to do it for Gradle or programmatically):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Now, after code generation, you can re-write the previous query as follows
    (notice the `reportsTo()` method instead of `employee()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: The jOOQ Java default generator strategy follows the *Pascal* naming strategy,
    which is the most popular in the Java language. But, besides the *Pascal* naming
    strategy, jOOQ also comes with a `KeepNamesGeneratorStrategy` custom generator
    strategy that simply holds names in place. Moreover, you may like to study `JPrefixGeneratorStrategy`,
    respectively the `JVMArgsGeneratorStrategy`. These are just some examples (they
    are not part of the jOOQ Code Generator) that can be found on GitHub at [https://github.com/jOOQ/jOOQ/tree/main/jOOQ-codegen/src/main/java/org/jooq/codegen/example](https://github.com/jOOQ/jOOQ/tree/main/jOOQ-codegen/src/main/java/org/jooq/codegen/example).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have briefly covered the jOOQ SPI. Obviously, the tasks
    solved via an SPI are not daily tasks and require overall solid knowledge about
    the underlying technology. But, since you have read earlier chapters in this book,
    you should have no problems assimilating the knowledge in this chapter as well.
    But, of course, using this SPI to solve real problems requires more study of the
    documentation and more practice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we tackle logging and testing jOOQ applications.
  prefs: []
  type: TYPE_NORMAL
