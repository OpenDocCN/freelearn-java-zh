- en: Using RxJava for Kotlin New
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJava 为 Kotlin 新增功能
- en: 'In our final chapter, we will apply RxJava to an exciting new frontier on the
    **JVM**: the Kotlin language.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一章中，我们将把 RxJava 应用于 JVM 上的一个令人兴奋的新领域：Kotlin 语言。
- en: Kotlin was developed by JetBrains, the company behind Intellij IDEA, PyCharm,
    and several other major IDEs and developer tools. For some time, JetBrains used
    Java to build its products, but after 2010, JetBrains began to question whether
    it was the best language to meet their needs and modern demands. After investigating
    existing languages, they decided to build and open source their own. In 2016 (5
    years later), Kotlin 1.0 was released. In 2017, Kotlin 1.1 was released to a growing
    community of users. Shortly afterward, Google announced Kotlin as an officially
    supported language for Android.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 由 JetBrains 开发，该公司还开发了 IntelliJ IDEA、PyCharm 以及其他几个主要的 IDE 和开发者工具。JetBrains
    之前一直使用 Java 来构建其产品，但自 2010 年以来，JetBrains 开始质疑是否有一种更好的语言来满足他们的需求和现代需求。在调查了现有的语言后，他们决定构建并开源自己的语言。2016
    年（5 年后），Kotlin 1.0 发布。2017 年，Kotlin 1.1 发布，面向日益增长的用户群体。不久之后，Google 宣布 Kotlin 为
    Android 的官方支持语言。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why Kotlin?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Kotlin？
- en: Configuring Kotlin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Kotlin
- en: Kotlin basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 基础
- en: Extension operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展操作符
- en: Using RxKotlin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RxKotlin
- en: Dealing with SAM ambiguity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 SAM 模糊性
- en: '`let()` and `apply()`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let()` 和 `apply()`'
- en: Tuples and data classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组和数据类
- en: The future of ReactiveX and Kotlin
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactiveX 和 Kotlin 的未来
- en: Why Kotlin?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Kotlin？
- en: Kotlin strives to be a pragmatic and industry-focused language, seeking a minimal
    (but legible) syntax that expresses business logic rather than boilerplate. However,
    it does not cut corners like many concise languages. It is statically typed and
    performs robustly in production and yet is speedy enough for prototyping. It also
    works 100% with Java libraries and source code, making it feasible for a gradual
    transition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 力求成为一个实用和行业导向的语言，寻求最小（但可读性）的语法，以表达业务逻辑而不是样板代码。然而，它不像许多简洁的语言那样走捷径。它是静态类型的，在生产环境中表现稳健，同时足够快速，可以用于原型设计。它还可以与
    Java 库和源代码 100% 兼容，使得逐步过渡成为可能。
- en: Android developers, who were stuck on Java 6 until recently, were quick to adopt
    Kotlin and effectively make it the "Swift of Android". Funnily, Swift and Kotlin
    have a similar feel and syntax, but Kotlin came into existence first. On top of
    that, a Kotlin community and ecosystem of libraries continued to grow quickly.
    In 2017, Google announced Kotlin as an officially supported language to develop
    Android apps. Due to JetBrains and Google's commitment, it is clear Kotlin has
    a bright future in the JVM.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近还困于 Java 6 的 Android 开发者迅速采用了 Kotlin，并有效地将其变成了“Android 的 Swift”。有趣的是，Swift
    和 Kotlin 有类似的感受和语法，但 Kotlin 出现得要早。除此之外，Kotlin 社区和库生态系统也在迅速增长。2017 年，Google 宣布
    Kotlin 为官方支持的开发 Android 应用程序的语言。由于 JetBrains 和 Google 的承诺，Kotlin 在 JVM 上的光明未来是显而易见的。
- en: But what does Kotlin have to do with RxJava? Kotlin has many useful language
    features that Java does not, and they can greatly improve the expressibility of
    RxJava. Also, more Android developers are using Kotlin as well as RxJava, so it
    makes sense to show how these two platforms can work together.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Kotlin 与 RxJava 有何关系？Kotlin 有许多 Java 所不具备的有用语言特性，它们可以极大地提高 RxJava 的可表达性。此外，越来越多的
    Android 开发者正在使用 Kotlin 和 RxJava，因此展示这两个平台如何协同工作是有意义的。
- en: Kotlin is a language that can quickly be picked up by Java developers within
    a matter of days. If you want to learn Kotlin in detail, *Kotlin in Action* ([https://www.manning.com/books/kotlin-in-action](https://www.manning.com/books/kotlin-in-action))
    by Dmitry Jemerov and Svetlana Isakova is an excellent book. There is also the
    excellent online reference ([https://kotlinlang.org/docs/reference/](https://kotlinlang.org/docs/reference/))
    provided by JetBrains. In this chapter, we will quickly go through some basic
    features of Kotlin to sell its pertinence in expressing RxJava more quickly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种 Java 开发者可以在几天内快速掌握的语言。如果你想要详细了解 Kotlin，Dmitry Jemerov 和 Svetlana
    Isakova 所著的《Kotlin in Action》([https://www.manning.com/books/kotlin-in-action](https://www.manning.com/books/kotlin-in-action))
    是一本极佳的书籍。此外，JetBrains 还提供了优秀的在线参考文档（[https://kotlinlang.org/docs/reference/](https://kotlinlang.org/docs/reference/)）。在本章中，我们将快速浏览
    Kotlin 的几个基本特性，以展示其在表达 RxJava 时的相关性。
- en: Configuring Kotlin
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Kotlin
- en: You can use either Gradle or Maven to build your Kotlin project. You can create
    a new Kotlin project in Intellij IDEA without any build automation, but here is
    how to set up a Kotlin project for Gradle and Maven.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Gradle 或 Maven 来构建您的 Kotlin 项目。您可以在 Intellij IDEA 中创建一个新的 Kotlin 项目而不需要任何构建自动化，但以下是设置
    Kotlin 项目用于 Gradle 和 Maven 的方法。
- en: Configuring Kotlin for Gradle
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Kotlin 用于 Gradle
- en: 'To use the Kotlin language with Gradle, first add the following buildscript
    `{ }` block to your `build.gradle` file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Kotlin 语言与 Gradle，首先将以下构建脚本 `{ }` 块添加到您的 `build.gradle` 文件中：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, you will need to apply the plugin, as shown in the following code, as
    well as the directories that will hold the source code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要应用以下代码中的插件，以及将包含源代码的目录。
- en: 'Note that `src/main/kotlin` is already specified by default, but you would
    use the `sourceSets { }` block to specify a different directory if needed:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`src/main/kotlin` 已经默认指定，但如果需要，您可以使用 `sourceSets { }` 块指定不同的目录：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can learn more about the Kotlin Gradle configuration in detail on the Kotlin
    website at [https://kotlinlang.org/docs/reference/using-gradle.html](https://kotlinlang.org/docs/reference/using-gradle.html).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Kotlin 网站上详细了解 Kotlin Gradle 配置，请访问 [https://kotlinlang.org/docs/reference/using-gradle.html](https://kotlinlang.org/docs/reference/using-gradle.html)。
- en: Configuring Kotlin for Maven
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Kotlin 用于 Maven
- en: 'For Maven, define a `kotlin.version` property and the `Kotlin-stdlib` as a
    dependency in your POM, as shown in the following code. Then, build the project:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Maven，在 POM 文件中定义 `kotlin.version` 属性并将 `Kotlin-stdlib` 作为依赖项，如下面的代码所示。然后，构建项目：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will also need to specify the source code directories and the kotlin-maven-plugin,
    as demonstrated in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要指定源代码目录和 kotlin-maven-plugin，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can learn more about the Kotlin Maven configuration in detail on the Kotlin
    website at [https://kotlinlang.org/docs/reference/using-maven.html](https://kotlinlang.org/docs/reference/using-maven.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Kotlin 网站上详细了解 Kotlin Maven 配置，请访问 [https://kotlinlang.org/docs/reference/using-maven.html](https://kotlinlang.org/docs/reference/using-maven.html)。
- en: Configuring RxJava and RxKotlin
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 RxJava 和 RxKotlin
- en: 'In this chapter, we will also be using RxJava as well as an extension library
    called **RxKotlin**. For Gradle, add these two libraries as your dependencies
    like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将使用 RxJava 以及一个名为 **RxKotlin** 的扩展库。对于 Gradle，将这两个库作为依赖项添加，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For Maven, set them up like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Maven，设置方式如下：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Kotlin basics
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 基础
- en: Although Kotlin has a standalone compiler and can work with Eclipse, we are
    going to use Intellij IDEA.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kotlin 有一个独立的编译器并且可以与 Eclipse 一起工作，但我们将使用 Intellij IDEA。
- en: A Kotlin project is structured much like a Java project. Following a standard
    Maven convention, you typically put your Kotlin source code in a `/src/main/kotlin/`
    folder instead of a `/src/main/java/` folder. The Kotlin source code is stored
    in text files with a `.kt` extension instead of `.java`. However, Kotlin files
    do not have to contain a class sharing the same name as the file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 项目的结构类似于 Java 项目。遵循标准的 Maven 习惯，您通常将 Kotlin 源代码放在 `/src/main/kotlin/`
    文件夹中，而不是 `/src/main/java/` 文件夹中。Kotlin 源代码存储在具有 `.kt` 扩展名的文本文件中，而不是 `.java` 扩展名。然而，Kotlin
    文件不必包含与文件同名的类。
- en: Creating a Kotlin file
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Kotlin 文件
- en: 'In Intellij IDEA, import your Kotlin project, if you haven''t already. Right-click
    on the `/src/main/kotlin/` folder and navigate to New | Kotlin File/Class, as
    shown in the following figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Intellij IDEA 中，如果您还没有导入 Kotlin 项目，请右键单击 `/src/main/kotlin/` 文件夹并导航到 New |
    Kotlin File/Class，如图所示：
- en: '![](img/9deda38b-b7b8-4ab7-825b-4673d98c4a1e.png)**Figure 12.1: **Creating
    a new Kotlin file'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/9deda38b-b7b8-4ab7-825b-4673d98c4a1e.png)**图 12.1：** 创建一个新的 Kotlin
    文件'
- en: 'In the following dialog, name the file `Launcher` and then click on OK. You
    should now see the `Launcher.kt` file in the Project pane. Double-click on it
    to open the editor. Write the following `"Hello World"` Kotlin code, as shown
    here, and then run it by clicking on the K icon in the gutter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下对话框中，将文件命名为 `Launcher`，然后点击 OK。现在您应该在项目视图中看到 `Launcher.kt` 文件。双击它以打开编辑器。编写以下
    `"Hello World"` Kotlin 代码，如图所示，然后通过点击侧边栏中的 K 图标来运行它：
- en: '![](img/969d45bd-ff75-4855-a40b-46f2c86789b8.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/969d45bd-ff75-4855-a40b-46f2c86789b8.png)'
- en: This is our first Kotlin application. Kotlin uses "functions" instead of methods,
    but it has a `main()` function just like Java has a `main()` method. Note that
    we do not have to house our `main()` function in a Java class. This is one benefit
    of Kotlin. Although it does compile to Java bytecode, you are not restricted to
    only object-oriented conventions and can be procedural or functional as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个 Kotlin 应用程序。Kotlin 使用“函数”而不是方法，但它有一个 `main()` 函数，就像 Java 有一个 `main()`
    方法一样。请注意，我们不需要在 Java 类中放置我们的 `main()` 函数。这是 Kotlin 的一个好处。尽管它编译成 Java 字节码，但你不仅限于面向对象的约定，也可以是过程式或函数式的。
- en: Assigning properties and variables
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配属性和变量
- en: 'To declare a variable or property, you must decide whether to make it mutable
    or not. Preceding a variable declaration with a `val` will make it only assignable
    once, whereas `var` is mutable and can be reassigned a value multiple times. The
    name of the variable then follows with a colon separating it from the type. Then,
    you can assign a value if you have it on hand. In the following code, we assign
    a variable for an `Int` and a `String` and print them in an interpolated string:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个变量或属性，你必须决定是否使其可变。在变量声明前加上 `val` 将使其只能赋值一次，而 `var` 是可变的，可以多次重新赋值。变量的名称随后跟一个冒号，将其与类型分开。然后，如果你有值，你可以分配它。在下面的代码中，我们为
    `Int` 和 `String` 分配变量，并在插值字符串中打印它们：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Kotlin''s compiler is pretty smart and does not always have to have the type
    explicitly declared for variables and properties. If you assign it a value immediately,
    it will infer the type from that value. Therefore, we can remove the type declarations
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的编译器非常智能，并不总是需要显式声明变量和属性的类型。如果你立即给它赋值，它将从这个值中推断类型。因此，我们可以按照以下方式移除类型声明：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Extension functions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: When you are doing RxJava work in Kotlin, something that is immensely helpful
    is creating extension functions. We will cover specifically how later, but here
    is a nonreactive example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Kotlin 中进行 RxJava 工作时，创建扩展函数是非常有帮助的。我们将在稍后具体介绍，但这里有一个非响应式示例。
- en: 'Say we want to add a convenient function to `LocalDate` in order to quickly
    compute the number of days to another `LocalDate`. Rather than invoking verbose
    helper classes to do this task repeatedly, we can quickly add an extension function
    to `LocalDate` called `numberOfDaysTo()`, as shown here. This does not extend
    `LocalDate` but rather lets the compiler resolve it as a static method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要向 `LocalDate` 添加一个方便的函数，以便快速计算到另一个 `LocalDate` 的天数。而不是反复调用冗长的辅助类来完成这个任务，我们可以快速向
    `LocalDate` 添加一个名为 `numberOfDaysTo()` 的扩展函数，如下所示。这并不扩展 `LocalDate`，而是让编译器将其解析为一个静态方法：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An extension function is just like a normal function in Kotlin, but you immediately
    declare the type you are adding the function to, followed by a dot, and then the
    extension function name (for example, fun `LocalDate.numberOfDaysTo()`). In the
    block that follows, it will treat the targeted `LocalDate` as `this`, just as
    if it was inside the class. But again, it resolves all this as a static method
    upon compilation. Kotlin magically abstracts this away for you.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数在 Kotlin 中就像一个普通函数，但你必须立即声明你要添加函数的类型，然后是一个点，接着是扩展函数的名称（例如，fun `LocalDate.numberOfDaysTo()`）。在随后的代码块中，它将目标
    `LocalDate` 视为 `this`，就像它是在类内部一样。但再次强调，所有这些都会在编译时解析为一个静态方法。Kotlin 会神奇地将这些抽象化处理。
- en: This allows you to create a more fluent DSL (domain-specific language) that
    is streamlined for your particular business. As an added bonus, Intellij IDEA
    will show this extension function in the autocompletion as you work with `LocalDate`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你创建一个更流畅的 DSL（领域特定语言），它针对你的特定业务进行了优化。作为额外的奖励，IntelliJ IDEA 将在处理 `LocalDate`
    时自动完成此扩展函数。
- en: 'Since the body of this extension function is only one line, you can actually
    use the equals(=) syntax to declare a function more succinctly and omit the return
    keyword as well as the explicit type declaration, as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个扩展函数的主体只有一行，实际上你可以使用等于（=）语法来更简洁地声明一个函数，并省略返回关键字以及显式的类型声明，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we will see soon, Kotlin extension functions are a powerful tool to add new
    operators to Observables and Flowables, and they offer much more flexibility and
    convenience than `compose()` and `lift()`. But first, let's look at Kotlin lambdas.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将很快看到的，Kotlin 扩展函数是向 Observables 和 Flowables 添加新操作符的强大工具，并且它们比 `compose()`
    和 `lift()` 提供了更多的灵活性和便利性。但首先，让我们看看 Kotlin 的 lambda。
- en: Kotlin lambdas
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin lambda
- en: I could spend a lot of time deconstructing lambdas in Kotlin, but in the interest
    of "getting to the point", I will show how they are expressed in the context of
    RxJava. You can learn about Kotlin lambdas in depth on the Kotlin reference site
    ([https://kotlinlang.org/docs/reference/lambdas.html](https://kotlinlang.org/docs/reference/lambdas.html)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以花很多时间来解析 Kotlin 中的 lambda，但为了“直奔主题”，我将展示它们在 RxJava 中的表达方式。你可以在 Kotlin 参考网站上深入了解
    Kotlin lambda（[https://kotlinlang.org/docs/reference/lambdas.html](https://kotlinlang.org/docs/reference/lambdas.html)）。
- en: 'Kotlin offers a few more ways to express lambdas than Java 8, and it also uses
    curly brackets `{ }` instead of round brackets `( )` to accept lambda arguments
    into functions. The following is how we express an `Observable` chain emitting
    strings and then map and print their lengths:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了比 Java 8 更多的表达 lambda 的方式，并且它还使用花括号 `{ }` 而不是圆括号 `( )` 来将 lambda 参数接受到函数中。以下是如何表达一个发射字符串并映射并打印其长度的
    `Observable` 链：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note how we express our lambda arguments for `map()` and `subscribe()`. This
    feels weird at first, using the curly brackets `{ }` to accept lambda arguments,
    but it does not take long before it feels pretty natural. They help make a distinction
    between stateful arguments and functional ones. You can put rounded brackets around
    them if you like, but this is messy and is only needed if you need to pass multiple
    lambda arguments (for operators such as `collect()`):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何表达 `map()` 和 `subscribe()` 的 lambda 参数。一开始使用花括号 `{ }` 接受 lambda 参数可能会觉得有些奇怪，但不久之后就会觉得非常自然。它们有助于区分有状态参数和无状态参数。如果你喜欢，可以围绕它们放置圆括号，但这很混乱，并且只有在需要传递多个
    lambda 参数（如 `collect()` 操作符）时才需要：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As said earlier, the Kotlin compiler is smart when it comes to type inference.
    So most of the time, we do not need to declare our lambda `s` or `i` parameters
    as `String` and `Int`. The compiler can figure that out for us, as shown in the
    following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kotlin 编译器在类型推断方面非常智能。因此，大多数情况下，我们不需要将我们的 lambda 参数 `s` 或 `i` 声明为 `String`
    和 `Int`。编译器可以为我们解决这个问题，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Even better, these are simple one-parameter lambdas, so we do not even have
    to name these parameters. We can omit them entirely and refer to them using the
    `it` keyword as shown next:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，这些是简单的单参数 lambda，所以我们甚至不需要命名这些参数。我们可以完全省略它们，并使用 `it` 关键字来引用，如下所示：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similar to Java 8, we can also use a function-reference syntax. If we are simply
    passing our arguments exactly in the same manner and order to a function or a
    constructor, we can use a double-colon `::` syntax, as shown here. Note that we
    *do* use rounded brackets here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 8 类似，我们也可以使用函数引用语法。如果我们只是以完全相同的方式和顺序将参数传递给函数或构造函数，我们可以使用双冒号 `::` 语法，如下所示。请注意，我们在这里确实使用了圆括号：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Something else that is interesting about Kotlin lambda arguments is that when
    you have multiple arguments where the last one is a lambda, you can put a lambda
    expression outside the rounded parentheses. In the following code, `scan()` emits
    the rolling total of string lengths and provides a seed value of `0`. However,
    we can put the final lambda argument outside of the rounded parentheses `( )`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Kotlin lambda 参数的另一个有趣之处在于，当你有多个参数且最后一个参数是 lambda 时，你可以将 lambda 表达式放在圆括号之外。在下面的代码中，`scan()`
    发射字符串长度的滚动总和，并提供一个种子值 `0`。然而，我们可以将最后的 lambda 参数放在圆括号 `( )` 之外：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Extension operators
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展操作符
- en: As covered earlier, Kotlin provides extension functions. These can be an enormously
    helpful alternative to using just `compose()` and `lift()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kotlin 提供了扩展函数。这些可以作为仅使用 `compose()` 和 `lift()` 的强大替代方案。
- en: 'For instance, we could not use Transformers and `compose()` to turn an `Observable<T>`
    into a `Single<R>`. But this is more than doable with Kotlin extension functions.
    In the following code, we create a `toSet()` operator and add it to `Observable<T>`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们无法使用 Transformers 和 `compose()` 将 `Observable<T>` 转换为 `Single<R>`。但使用 Kotlin
    扩展函数，这完全可行。在下面的代码中，我们创建了一个 `toSet()` 操作符并将其添加到 `Observable<T>`：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `toSet()`returns a `Single<Set<T>>`, and it was called on an `Observable<T>`.
    In the extension function, the `collect()` operator is called on the invoked `Observable`,
    and then it cast the `HashSet` to a `Set` so the implementation is hidden. As
    you can see, it is easy to create new operators and make them easy to discover.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`toSet()`返回一个`Single<Set<T>>`，并且它被调用在一个`Observable<T>`上。在扩展函数中，`collect()`运算符被调用在调用的`Observable`上，然后它将`HashSet`转换为`Set`，因此实现是隐藏的。正如你所见，创建新的运算符并使其易于发现是很简单的。'
- en: 'You can also make extension functions target only certain generic types. For
    example, I can create a `sum()` extension function that only targets `Observable<Int>`
    (`Int` is the Integer/int abstraction type in Kotlin). It will only be valid when
    used with an `Observable` emitting integers and can only compile or show up in
    autocomplete for that type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使扩展函数仅针对某些泛型类型。例如，我可以创建一个仅针对`Observable<Int>`的`sum()`扩展函数（`Int`是Kotlin中的Integer/int抽象类型）。它只有在与发出整数的`Observable`一起使用时才有效，并且只能编译或出现在该类型的自动完成中：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using RxKotlin
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxKotlin
- en: There is a small library called RxKotlin ([https://github.com/ReactiveX/RxKotlin/](https://github.com/ReactiveX/RxKotlin/)),
    which we made a dependency at the beginning of this chapter. At the time of writing
    this, it is hardly a complex library but rather a small collection of convenient
    extension functions for common reactive conversions. It also attempts to standardize
    some conventions when using RxJava with Kotlin.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为RxKotlin的小型库（[https://github.com/ReactiveX/RxKotlin/](https://github.com/ReactiveX/RxKotlin/)），我们在本章开头将其作为依赖项。在撰写本文时，它几乎不是一个复杂的库，而是一组用于常见反应式转换的方便扩展函数的集合。它还试图在Kotlin中使用RxJava时标准化一些约定。
- en: 'For instance, there are the `toObservable()` and `toFlowable()` extension functions
    that can be invoked on iterables, sequences, and a few other sources. In the following
    code, instead of using `Observable.fromIterable()` to turn a `List` into an `Observable`,
    we just call its `toObservable()` extension function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有`toObservable()`和`toFlowable()`扩展函数可以在可迭代的、序列的以及一些其他来源上调用。在下面的代码中，我们不是使用`Observable.fromIterable()`将`List`转换为`Observable`，而是直接调用它的`toObservable()`扩展函数：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are some other extensions in RxKotlin worth exploring, and you can view
    it all on the GitHub page. The library is deliberately small and focused since
    it is easy to clutter an API with every extension function for every task possible.
    But it holds the functionality for common tasks such as the preceding one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxKotlin中还有一些值得探索的其他扩展功能，你可以在GitHub页面上查看所有内容。这个库故意保持小巧和专注，因为它很容易让API因为每个可能的任务都添加一个扩展函数而变得杂乱。但它包含了常见任务的功能，如前面的例子。
- en: RxKotlin also has useful helpers to get around the SAM problem that exists between
    Java and Kotlin (you might have noticed this issue if you have been experimenting
    already). We will cover this next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: RxKotlin还有一些有用的帮助程序可以解决Java和Kotlin之间存在的SAM问题（如果你已经尝试过，你可能已经注意到了这个问题）。我们将在下一节中介绍这个问题。
- en: Dealing with SAM ambiguity
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理SAM歧义
- en: At the time of writing this, there is a nuance when Kotlin invokes Java libraries
    with functional parameters. This problem especially rears its head in RxJava 2.0
    when many parameter overloads are introduced. Kotlin does not have this issue
    when invoking Kotlin libraries but it does with Java libraries. When there are
    multiple argument overloads for different functional SAM types on a given Java
    method, Kotlin gets lost in its inference and needs help. Until JetBrains resolves
    this issue, you will need to work around this either by being explicit or using
    RxKotlin's helpers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，当Kotlin使用功能参数调用Java库时，存在一个细微差别。这个问题在RxJava 2.0中尤其明显，因为引入了许多参数重载。当调用Kotlin库时，Kotlin没有这个问题，但与Java库一起使用时却存在。当给定Java方法上有多个针对不同功能SAM类型的参数重载时，Kotlin会在推断中迷失方向，需要帮助。在JetBrains解决这个问题之前，你需要通过明确指定或使用RxKotlin的帮助程序来解决这个问题。
- en: 'Here is a notorious example: The `zip()` operator. Try to do a simple zip here
    and you will get a compile error due to failed inference:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个臭名昭著的例子：`zip()`运算符。尝试在这里进行简单的`zip`操作，你会因为类型推断失败而得到编译错误：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One way to resolve this is to explicitly construct the SAM type with your lambda.
    In this case, we need to tell the compiler that we are giving it a `BiFunction<String,Int,String>`,
    as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是用你的lambda显式地构造SAM类型。在这种情况下，我们需要告诉编译器我们正在给它一个`BiFunction<String,Int,String>`，如下所示：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unfortunately, this is pretty verbose. Many use RxJava and Kotlin to have less
    code, not more, so this is not ideal. Thankfully, RxKotlin provides some utilities
    to work around this issue. You can use the Observables, Flowables, Singles, and
    Maybes utility classes to invoke implementations of the factories affected by
    the SAM problem. Here is our example using this approach:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这相当冗长。许多人使用 RxJava 和 Kotlin 来减少代码量，而不是增加，所以这不是理想的情况。幸运的是，RxKotlin 提供了一些工具来解决这个问题。你可以使用
    Observables、Flowables、Singles 和 Maybes 工具类来调用受 SAM 问题影响的工厂实现。以下是我们使用这种方法的一个例子：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are also extension functions for non-factory operators affected by the
    SAM issue. The following is our example using a `zipWith()` extension function
    that successfully performs inference with our Kotlin lambda argument. Note that
    we have to import this extension function to use it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于受 SAM 问题影响的非工厂操作符，也存在扩展函数。以下是我们使用 `zipWith()` 扩展函数的一个例子，该函数成功地使用我们的 Kotlin
    lambda 参数进行了推理。请注意，我们必须导入这个扩展函数才能使用它：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It should also be pointed out that `subscribe()` on Single and Maybe is affected
    by the SAM ambiguity issue as well, so there are `subscribeBy()` extensions to
    cope with it, as shown next:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该指出，Single 和 Maybe 上的 `subscribe()` 也受到 SAM 不明确性问题的困扰，因此有 `subscribeBy()`
    扩展来处理它，如下所示：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Try not to let the issue of SAM ambiguity deter you from trying Kotlin. It is
    a nuance when interoperating Kotlin lambdas with Java SAM types. The issue has
    been acknowledged by JetBrains and should be temporary. Also, there has been a discussion
    in the Kotlin community to create a ReactiveX implementation in pure Kotlin for
    other reasons, and we will touch on the future of RxKotlin at the end of this
    chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 务必不要让 SAM 不明确性问题阻碍你尝试 Kotlin。这是 Kotlin lambda 与 Java SAM 类型互操作时的一个细微差别。这个问题已被
    JetBrains 承认，应该是暂时的。此外，在 Kotlin 社区中也有讨论，为了其他原因创建一个纯 Kotlin 的 ReactiveX 实现，我们将在本章末尾讨论
    RxKotlin 的未来。
- en: Using let() and apply()
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 let() 和 apply()
- en: In Kotlin, every type has a `let()` and `apply()` extension function. These
    are two simple but helpful tools to make your code more fluent and expressive.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，每个类型都有一个 `let()` 和 `apply()` 扩展函数。这两个简单但实用的工具可以使你的代码更加流畅和易于表达。
- en: Using let()
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 let()
- en: '`let()` simply accepts a lambda that maps the invoked object `T` to another
    object `R`. It is similar to how RxJava offers the `to()` operator, but it applies
    to any type `T` and not just Observables/Flowables. For example, we can call `let()`
    on a string that has been lowercased and then immediately do any arbitrary transformation
    on it, such as concatenating its `reversed()` string to it. Take a look at this
    operation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`let()` 简单地接受一个将调用对象 `T` 映射到另一个对象 `R` 的 lambda 表达式。这与 RxJava 提供的 `to()` 操作符类似，但它适用于任何类型
    `T`，而不仅仅是 Observables/Flowables。例如，我们可以对一个已经被转换为小写的字符串调用 `let()`，然后立即对其进行任何任意的转换，例如将其
    `reversed()` 字符串连接到它。看看这个操作：'
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `let()` comes in handy when you do not want to save a value to a variable
    just so you can refer to it multiple times. In the preceding code, we did not
    have to save the result of `toLowerCase()` to a variable. Instead, we just immediately
    called `let()` on it to do what we need.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不想为了多次引用而将值保存到变量中时，`let()` 就派上用场了。在上面的代码中，我们不必将 `toLowerCase()` 的结果保存到变量中。相反，我们只需立即对它调用
    `let()` 来完成我们需要的操作。
- en: 'In an RxJava context, the `let()` function can be helpful in quickly taking
    an `Observable`, forking it, and then recombining it using a combine operator.
    In the following code, we multicast an `Observable` of numbers to a `let()` operator,
    which creates a sum and a count, and then returns the result of the `zipWith()`
    operator that uses both to find the average:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 的上下文中，`let()` 函数可以帮助快速处理一个 `Observable`，将其分支，然后使用组合操作符重新组合。在下面的代码中，我们将数字的
    `Observable` 分发给一个 `let()` 操作符，该操作符创建一个总和和一个计数，然后返回使用这两个值来找到平均值的 `zipWith()` 操作符的结果：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The last line in `let()` is what gets returned and does not require a return
    keyword.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`let()` 中的最后一行是返回的内容，不需要返回关键字。'
- en: In summary, `let()` is a powerful and simple tool to fluently convert an item
    into another item. Using it to fork an `Observable` or `Flowable` streams and
    then joining them again is one helpful application for it in RxJava.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`let()` 是一个强大且简单的工具，可以流畅地将一个项目转换为另一个项目。在 RxJava 中，使用它来分支 `Observable` 或
    `Flowable` 流，然后再将它们重新组合，是它的一个有用应用。
- en: Using apply()
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 apply()
- en: A tool similar to `let()` is `apply()`. Instead of turning a `T` item into an
    `R` item,which `let()` does, `apply()` executes a series of actions against the
    `T` item instead, before returning the same `T` item itself. This is helpful in
    declaring an item `T` but doing tangential operations on it without breaking the
    declaration/assignment flow.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `let()` 类似的工具是 `apply()`。与 `let()` 将 `T` 类型的项转换为 `R` 类型的项不同，`apply()` 对 `T`
    类型的项执行一系列操作，然后再返回相同的 `T` 类型的项。这在声明一个项 `T` 但对其执行辅助操作而不打断声明/赋值流程时非常有用。
- en: 'Here is a nonreactive example. We have a simple class, `MyItem`, which has
    a `startProcess()` function. We can instantiate `MyItem` but use `apply()` to
    call this `startProcess()` method before assigning `MyItem` to a variable, as
    shown in the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非响应式示例。我们有一个简单的类 `MyItem`，它有一个 `startProcess()` 方法。我们可以实例化 `MyItem`，但使用
    `apply()` 在将 `MyItem` 赋值给变量之前调用这个 `startProcess()` 方法，如下所示：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In RxJava, `apply()` is helpful in adding an Observer or Subscriber in the middle
    of an `Observable`/`Flowable` chain but not breaking the flow from the primary
    task at hand. This can be helpful in emitting status messages to a separate stream.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 中，`apply()` 函数有助于在 `Observable`/`Flowable` 链中添加观察者或订阅者，同时不会打断当前主要任务的流程。这有助于向单独的流中发送状态消息。
- en: 'In the following code, we emit five 1-second intervals and multiply each one.
    However, we create a `statusObserver` and subscribe to it within `apply()` right
    before the multiplication. We multicast before `apply()` as well so emissions
    are pushed to both destinations:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们发出五个 1 秒的间隔，并乘以每个间隔。然而，我们在乘法之前在 `apply()` 中创建了一个 `statusObserver` 并订阅它。在
    `apply()` 之前也进行了多播，以便将发射物推送到两个目的地：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So again, `apply()` is helpful in taking a multicasted stream of emissions and
    pushing them to multiple Observers without having any intermediary variables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次强调，`apply()` 在将多播流发射物推送到多个观察者时非常有用，而不需要任何中间变量。
- en: Similiar to `apply()` is the extension function `run()`, which executes a series
    of actions but has a void return type (or in Kotlin-speak, Unit). There is also
    `with()`, which is identical to `run()` except than it is not an extension function.
    It accepts the targeted item as an argument.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `apply()` 类似的扩展函数是 `run()`，它执行一系列操作，但返回类型为空（或在 Kotlin 中称为 Unit）。还有 `with()`，它与
    `run()` 相同，但它不是一个扩展函数。它接受目标项作为参数。
- en: Tuples and data classes
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组和数据类
- en: Kotlin supports Tuples to a small degree, but it also offers something even
    better with data classes. We will look at both of these in an RxJava context.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 对元组支持有限，但它还提供了更好的数据类。我们将在 RxJava 的上下文中探讨这两个工具。
- en: Kotlin supports the quick creation of a Pair containing two items (which can
    be of differing types). This is a simple two-value, but statically-typed, tuple.
    You can construct one quickly by putting the `to` keyword between two values.
    This is helpful in doing `zip()` operations between two streams, and you just
    want to pair the two items together.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 支持快速创建包含两个项的 Pair（这些项可以是不同类型的）。这是一个简单的双值元组，但具有静态类型。你可以通过在两个值之间放置 `to`
    关键字来快速构建一个。这在需要在两个流之间执行 `zip()` 操作并将两个项配对时非常有用。
- en: In the following code, we zip a stream of string items with a stream of `Int`
    items and put each pair into `Pair<String,Int>`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将字符串项的流与 `Int` 项的流进行连接，并将每个配对放入 `Pair<String,Int>`。
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: An even better approach is to use a data class. A data class is a powerful Kotlin
    tool that works just like a class, but it automatically implements `hashcode()`/`equals()`,
    `toString()`, as well as a nifty `copy()` function that allows you to clone and
    modify properties onto a new instance of that class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用数据类。数据类是 Kotlin 的一个强大工具，它的工作方式与类相似，但会自动实现 `hashcode()`/`equals()`、`toString()`，以及一个巧妙的
    `copy()` 函数，允许你克隆并修改属性到该类的新实例。
- en: 'But for now, we will just use a data class as a cleaner approach than a `Pair`
    because we actually give each property a name instead of `first` and `second`.
    In the following code, we will create a `StringAndNumber` data class and use it
    to zip each pair of values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但目前，我们将仅使用数据类作为比 `Pair` 更干净的方法，因为我们实际上为每个属性提供了一个名称，而不是 `first` 和 `second`。在以下代码中，我们将创建一个
    `StringAndNumber` 数据类，并使用它来连接每个值对：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Data classes (as well as just plain Kotlin classes) are quick and easy to declare,
    so you can use them tactically for even small tasks. Use them to make your code
    clearer and easier to maintain.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类（以及普通的 Kotlin 类）声明快捷且简单，因此你可以战略性地使用它们来完成小型任务。使用它们可以使你的代码更清晰且易于维护。
- en: Future of ReactiveX and Kotlin
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactiveX 和 Kotlin 的未来
- en: Kotlin is a powerful and pragmatic language. JetBrains put in a lot of effort
    not only to make it effective, but also compatible with existing Java code and
    libraries. Despite a few rough patches such as SAM lambda inference, they did
    a phenomenal job making Java and Kotlin work together. However, even with this
    solid compatibility, many developers become eager to migrate entirely to Kotlin
    to leverage its functionality. Named parameters, optional parameters, nullable
    types, extension functions, inline functions, delegates, and other language features
    make Kotlin attractive for exclusive use. Not to mention, JetBrains has successfully
    made Kotlin compilable to JavaScript and will soon support LLVM native compilation.
    Libraries built in pure Kotlin can potentially be compiled to all these platforms.
    To solidify Kotlin's position even further, Google officially established it as
    the next supported language for Android.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种强大且实用的语言。JetBrains 不仅投入了大量努力使其有效，还使其与现有的 Java 代码和库兼容。尽管存在一些粗糙的地方，比如
    SAM lambda 推断，但他们仍然出色地让 Java 和 Kotlin 一起工作。然而，即使有了这种坚实的兼容性，许多开发者也渴望完全迁移到 Kotlin
    以利用其功能。命名参数、可选参数、可空类型、扩展函数、内联函数、委托和其他语言特性使 Kotlin 对专用使用具有吸引力。更不用说，JetBrains 已经成功地将
    Kotlin 编译成 JavaScript，并将很快支持 LLVM 原生编译。纯 Kotlin 编写的库可以潜在地编译到所有这些平台。为了进一步巩固 Kotlin
    的地位，谷歌官方将其确立为 Android 的下一个支持语言。
- en: 'So this begs the question: would there the benefit in creating a ReactiveX
    implementation in pure Kotlin and not rely on RxJava? After all, the Kotlin language
    has a powerful set of features that could offer a lot to a ReactiveX implementation
    and bring it to multiple platforms Kotlin will compile to. It would also create
    a ReactiveX experience optimized for Kotlin, supporting nullable type emissions,
    extension operators, and coroutine-based concurrency.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这引发了一个问题：在纯 Kotlin 中创建 ReactiveX 实现并不仅仅依赖于 RxJava 是否会有好处？毕竟，Kotlin 语言有一套强大的功能，可以为
    ReactiveX 实现提供很多帮助，并将其带到 Kotlin 可以编译到的多个平台。它还将创建一个针对 Kotlin 优化的 ReactiveX 体验，支持可空类型发射、扩展操作符和基于协程的并发。
- en: Coroutines provide an interesting and useful abstraction to quickly (and more
    safely) implement concurrency into a Kotlin application. Because coroutines support
    task suspension, they provide a natural mechanism to support backpressure. In
    the event that a ReactiveX implementation in Kotlin is pursued, coroutines can
    play a huge part in making backpressure simple to implement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 协程为 Kotlin 应用程序快速（且更安全地）实现并发提供了一个有趣且有用的抽象。因为协程支持任务挂起，它们提供了一种自然机制来支持背压。如果在 Kotlin
    中实现 ReactiveX，协程可以在使背压简单实现方面发挥巨大作用。
- en: If you want to learn about how Kotlin coroutines can be leveraged to create
    a ReactiveX implementation in Kotlin, read Roman Elizarov's fascinating article
    at [https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解如何在 Kotlin 中利用 Kotlin 协程创建 ReactiveX 实现，请阅读 Roman Elizarov 的迷人文章，链接为 [https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md)。
- en: So yes, there could be a lot to gain by making a ReactiveX implementation in
    pure Kotlin. At the time of writing this, this conversation is getting more traction
    in the Kotlin community. Keep an eye out as people continue to experiment and
    proof-of-concepts creep toward prototypes and then the official release.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在纯 Kotlin 中实现 ReactiveX 实现确实可能带来很多好处。在撰写本文时，这个话题在 Kotlin 社区中越来越受欢迎。请密切关注，因为人们将继续实验，从概念验证逐步发展到原型，然后是官方发布。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to use RxJava for Kotlin. The Kotlin language
    is an exciting opportunity to express code on the JVM more pragmatically, and
    RxJava can leverage many of its useful features. Extension functions, data classes,
    RxKotlin, and functional operators such as `let()`/`apply()` allow you to express
    your reactive domain more easily. Although SAM inference can cause you to hit
    snags, you can leverage RxKotlin's helper utilities to get around this issue until
    JetBrains creates a fix. Down the road, it will be interesting to see if a ReactiveX
    implementation in pure Kotlin appears. Such an implementation would bring in a
    lot of functionality that Kotlin allows and Java does not.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用 RxJava 进行 Kotlin 编程。Kotlin 语言为在 JVM 上更实用地表达代码提供了激动人心的机会，而 RxJava
    可以利用其许多有用特性。扩展函数、数据类、RxKotlin 以及如 `let()`/`apply()` 这样的函数式操作符使你更容易地表达你的响应式领域。尽管
    SAM 推断可能会让你遇到障碍，但你可以通过利用 RxKotlin 的辅助工具来解决这个问题，直到 JetBrains 提供修复方案。将来，看到是否会出现纯
    Kotlin 实现的 ReactiveX 将会很有趣。这样的实现将引入 Kotlin 允许而 Java 不允许的大量功能。
- en: This is the end! If you have covered this book cover-to-cover, congrats! You
    should have a strong foundation to leverage RxJava in your workplace and projects.
    Reactive programming is a radically different approach to problem solving, but
    it is radically effective too. Reactive programming will continue to grow in pertinence
    and shape the future of how we model code. Being on this cutting edge will make
    you not only marketable, but also a leader for the years to come.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是终点！如果你从头到尾阅读了这本书，恭喜你！你应该已经具备了在工作和项目中利用 RxJava 的坚实基础。响应式编程是一种彻底不同的解决问题方法，但也是非常有效的。响应式编程将继续增长其相关性，并塑造我们建模代码的未来。站在这个前沿将使你不仅具有市场竞争力，而且在未来几年内成为领导者。
