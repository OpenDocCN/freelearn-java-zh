- en: Using RxJava for Kotlin New
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our final chapter, we will apply RxJava to an exciting new frontier on the
    **JVM**: the Kotlin language.'
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin was developed by JetBrains, the company behind Intellij IDEA, PyCharm,
    and several other major IDEs and developer tools. For some time, JetBrains used
    Java to build its products, but after 2010, JetBrains began to question whether
    it was the best language to meet their needs and modern demands. After investigating
    existing languages, they decided to build and open source their own. In 2016 (5
    years later), Kotlin 1.0 was released. In 2017, Kotlin 1.1 was released to a growing
    community of users. Shortly afterward, Google announced Kotlin as an officially
    supported language for Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Kotlin?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RxKotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with SAM ambiguity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let()` and `apply()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples and data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The future of ReactiveX and Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Kotlin?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin strives to be a pragmatic and industry-focused language, seeking a minimal
    (but legible) syntax that expresses business logic rather than boilerplate. However,
    it does not cut corners like many concise languages. It is statically typed and
    performs robustly in production and yet is speedy enough for prototyping. It also
    works 100% with Java libraries and source code, making it feasible for a gradual
    transition.
  prefs: []
  type: TYPE_NORMAL
- en: Android developers, who were stuck on Java 6 until recently, were quick to adopt
    Kotlin and effectively make it the "Swift of Android". Funnily, Swift and Kotlin
    have a similar feel and syntax, but Kotlin came into existence first. On top of
    that, a Kotlin community and ecosystem of libraries continued to grow quickly.
    In 2017, Google announced Kotlin as an officially supported language to develop
    Android apps. Due to JetBrains and Google's commitment, it is clear Kotlin has
    a bright future in the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: But what does Kotlin have to do with RxJava? Kotlin has many useful language
    features that Java does not, and they can greatly improve the expressibility of
    RxJava. Also, more Android developers are using Kotlin as well as RxJava, so it
    makes sense to show how these two platforms can work together.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin is a language that can quickly be picked up by Java developers within
    a matter of days. If you want to learn Kotlin in detail, *Kotlin in Action* ([https://www.manning.com/books/kotlin-in-action](https://www.manning.com/books/kotlin-in-action))
    by Dmitry Jemerov and Svetlana Isakova is an excellent book. There is also the
    excellent online reference ([https://kotlinlang.org/docs/reference/](https://kotlinlang.org/docs/reference/))
    provided by JetBrains. In this chapter, we will quickly go through some basic
    features of Kotlin to sell its pertinence in expressing RxJava more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use either Gradle or Maven to build your Kotlin project. You can create
    a new Kotlin project in Intellij IDEA without any build automation, but here is
    how to set up a Kotlin project for Gradle and Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kotlin for Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the Kotlin language with Gradle, first add the following buildscript
    `{ }` block to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, you will need to apply the plugin, as shown in the following code, as
    well as the directories that will hold the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `src/main/kotlin` is already specified by default, but you would
    use the `sourceSets { }` block to specify a different directory if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about the Kotlin Gradle configuration in detail on the Kotlin
    website at [https://kotlinlang.org/docs/reference/using-gradle.html](https://kotlinlang.org/docs/reference/using-gradle.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Kotlin for Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Maven, define a `kotlin.version` property and the `Kotlin-stdlib` as a
    dependency in your POM, as shown in the following code. Then, build the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to specify the source code directories and the kotlin-maven-plugin,
    as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about the Kotlin Maven configuration in detail on the Kotlin
    website at [https://kotlinlang.org/docs/reference/using-maven.html](https://kotlinlang.org/docs/reference/using-maven.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RxJava and RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will also be using RxJava as well as an extension library
    called **RxKotlin**. For Gradle, add these two libraries as your dependencies
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For Maven, set them up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Kotlin has a standalone compiler and can work with Eclipse, we are
    going to use Intellij IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: A Kotlin project is structured much like a Java project. Following a standard
    Maven convention, you typically put your Kotlin source code in a `/src/main/kotlin/`
    folder instead of a `/src/main/java/` folder. The Kotlin source code is stored
    in text files with a `.kt` extension instead of `.java`. However, Kotlin files
    do not have to contain a class sharing the same name as the file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kotlin file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Intellij IDEA, import your Kotlin project, if you haven''t already. Right-click
    on the `/src/main/kotlin/` folder and navigate to New | Kotlin File/Class, as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9deda38b-b7b8-4ab7-825b-4673d98c4a1e.png)**Figure 12.1: **Creating
    a new Kotlin file'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following dialog, name the file `Launcher` and then click on OK. You
    should now see the `Launcher.kt` file in the Project pane. Double-click on it
    to open the editor. Write the following `"Hello World"` Kotlin code, as shown
    here, and then run it by clicking on the K icon in the gutter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/969d45bd-ff75-4855-a40b-46f2c86789b8.png)'
  prefs: []
  type: TYPE_IMG
- en: This is our first Kotlin application. Kotlin uses "functions" instead of methods,
    but it has a `main()` function just like Java has a `main()` method. Note that
    we do not have to house our `main()` function in a Java class. This is one benefit
    of Kotlin. Although it does compile to Java bytecode, you are not restricted to
    only object-oriented conventions and can be procedural or functional as well.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning properties and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To declare a variable or property, you must decide whether to make it mutable
    or not. Preceding a variable declaration with a `val` will make it only assignable
    once, whereas `var` is mutable and can be reassigned a value multiple times. The
    name of the variable then follows with a colon separating it from the type. Then,
    you can assign a value if you have it on hand. In the following code, we assign
    a variable for an `Int` and a `String` and print them in an interpolated string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin''s compiler is pretty smart and does not always have to have the type
    explicitly declared for variables and properties. If you assign it a value immediately,
    it will infer the type from that value. Therefore, we can remove the type declarations
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are doing RxJava work in Kotlin, something that is immensely helpful
    is creating extension functions. We will cover specifically how later, but here
    is a nonreactive example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to add a convenient function to `LocalDate` in order to quickly
    compute the number of days to another `LocalDate`. Rather than invoking verbose
    helper classes to do this task repeatedly, we can quickly add an extension function
    to `LocalDate` called `numberOfDaysTo()`, as shown here. This does not extend
    `LocalDate` but rather lets the compiler resolve it as a static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An extension function is just like a normal function in Kotlin, but you immediately
    declare the type you are adding the function to, followed by a dot, and then the
    extension function name (for example, fun `LocalDate.numberOfDaysTo()`). In the
    block that follows, it will treat the targeted `LocalDate` as `this`, just as
    if it was inside the class. But again, it resolves all this as a static method
    upon compilation. Kotlin magically abstracts this away for you.
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to create a more fluent DSL (domain-specific language) that
    is streamlined for your particular business. As an added bonus, Intellij IDEA
    will show this extension function in the autocompletion as you work with `LocalDate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the body of this extension function is only one line, you can actually
    use the equals(=) syntax to declare a function more succinctly and omit the return
    keyword as well as the explicit type declaration, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we will see soon, Kotlin extension functions are a powerful tool to add new
    operators to Observables and Flowables, and they offer much more flexibility and
    convenience than `compose()` and `lift()`. But first, let's look at Kotlin lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I could spend a lot of time deconstructing lambdas in Kotlin, but in the interest
    of "getting to the point", I will show how they are expressed in the context of
    RxJava. You can learn about Kotlin lambdas in depth on the Kotlin reference site
    ([https://kotlinlang.org/docs/reference/lambdas.html](https://kotlinlang.org/docs/reference/lambdas.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin offers a few more ways to express lambdas than Java 8, and it also uses
    curly brackets `{ }` instead of round brackets `( )` to accept lambda arguments
    into functions. The following is how we express an `Observable` chain emitting
    strings and then map and print their lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we express our lambda arguments for `map()` and `subscribe()`. This
    feels weird at first, using the curly brackets `{ }` to accept lambda arguments,
    but it does not take long before it feels pretty natural. They help make a distinction
    between stateful arguments and functional ones. You can put rounded brackets around
    them if you like, but this is messy and is only needed if you need to pass multiple
    lambda arguments (for operators such as `collect()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As said earlier, the Kotlin compiler is smart when it comes to type inference.
    So most of the time, we do not need to declare our lambda `s` or `i` parameters
    as `String` and `Int`. The compiler can figure that out for us, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, these are simple one-parameter lambdas, so we do not even have
    to name these parameters. We can omit them entirely and refer to them using the
    `it` keyword as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to Java 8, we can also use a function-reference syntax. If we are simply
    passing our arguments exactly in the same manner and order to a function or a
    constructor, we can use a double-colon `::` syntax, as shown here. Note that we
    *do* use rounded brackets here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Something else that is interesting about Kotlin lambda arguments is that when
    you have multiple arguments where the last one is a lambda, you can put a lambda
    expression outside the rounded parentheses. In the following code, `scan()` emits
    the rolling total of string lengths and provides a seed value of `0`. However,
    we can put the final lambda argument outside of the rounded parentheses `( )`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Extension operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered earlier, Kotlin provides extension functions. These can be an enormously
    helpful alternative to using just `compose()` and `lift()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we could not use Transformers and `compose()` to turn an `Observable<T>`
    into a `Single<R>`. But this is more than doable with Kotlin extension functions.
    In the following code, we create a `toSet()` operator and add it to `Observable<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `toSet()`returns a `Single<Set<T>>`, and it was called on an `Observable<T>`.
    In the extension function, the `collect()` operator is called on the invoked `Observable`,
    and then it cast the `HashSet` to a `Set` so the implementation is hidden. As
    you can see, it is easy to create new operators and make them easy to discover.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also make extension functions target only certain generic types. For
    example, I can create a `sum()` extension function that only targets `Observable<Int>`
    (`Int` is the Integer/int abstraction type in Kotlin). It will only be valid when
    used with an `Observable` emitting integers and can only compile or show up in
    autocomplete for that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using RxKotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a small library called RxKotlin ([https://github.com/ReactiveX/RxKotlin/](https://github.com/ReactiveX/RxKotlin/)),
    which we made a dependency at the beginning of this chapter. At the time of writing
    this, it is hardly a complex library but rather a small collection of convenient
    extension functions for common reactive conversions. It also attempts to standardize
    some conventions when using RxJava with Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, there are the `toObservable()` and `toFlowable()` extension functions
    that can be invoked on iterables, sequences, and a few other sources. In the following
    code, instead of using `Observable.fromIterable()` to turn a `List` into an `Observable`,
    we just call its `toObservable()` extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are some other extensions in RxKotlin worth exploring, and you can view
    it all on the GitHub page. The library is deliberately small and focused since
    it is easy to clutter an API with every extension function for every task possible.
    But it holds the functionality for common tasks such as the preceding one.
  prefs: []
  type: TYPE_NORMAL
- en: RxKotlin also has useful helpers to get around the SAM problem that exists between
    Java and Kotlin (you might have noticed this issue if you have been experimenting
    already). We will cover this next.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with SAM ambiguity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this, there is a nuance when Kotlin invokes Java libraries
    with functional parameters. This problem especially rears its head in RxJava 2.0
    when many parameter overloads are introduced. Kotlin does not have this issue
    when invoking Kotlin libraries but it does with Java libraries. When there are
    multiple argument overloads for different functional SAM types on a given Java
    method, Kotlin gets lost in its inference and needs help. Until JetBrains resolves
    this issue, you will need to work around this either by being explicit or using
    RxKotlin's helpers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a notorious example: The `zip()` operator. Try to do a simple zip here
    and you will get a compile error due to failed inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to resolve this is to explicitly construct the SAM type with your lambda.
    In this case, we need to tell the compiler that we are giving it a `BiFunction<String,Int,String>`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this is pretty verbose. Many use RxJava and Kotlin to have less
    code, not more, so this is not ideal. Thankfully, RxKotlin provides some utilities
    to work around this issue. You can use the Observables, Flowables, Singles, and
    Maybes utility classes to invoke implementations of the factories affected by
    the SAM problem. Here is our example using this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also extension functions for non-factory operators affected by the
    SAM issue. The following is our example using a `zipWith()` extension function
    that successfully performs inference with our Kotlin lambda argument. Note that
    we have to import this extension function to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It should also be pointed out that `subscribe()` on Single and Maybe is affected
    by the SAM ambiguity issue as well, so there are `subscribeBy()` extensions to
    cope with it, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Try not to let the issue of SAM ambiguity deter you from trying Kotlin. It is
    a nuance when interoperating Kotlin lambdas with Java SAM types. The issue has
    been acknowledged by JetBrains and should be temporary. Also, there has been a discussion
    in the Kotlin community to create a ReactiveX implementation in pure Kotlin for
    other reasons, and we will touch on the future of RxKotlin at the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using let() and apply()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, every type has a `let()` and `apply()` extension function. These
    are two simple but helpful tools to make your code more fluent and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Using let()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`let()` simply accepts a lambda that maps the invoked object `T` to another
    object `R`. It is similar to how RxJava offers the `to()` operator, but it applies
    to any type `T` and not just Observables/Flowables. For example, we can call `let()`
    on a string that has been lowercased and then immediately do any arbitrary transformation
    on it, such as concatenating its `reversed()` string to it. Take a look at this
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `let()` comes in handy when you do not want to save a value to a variable
    just so you can refer to it multiple times. In the preceding code, we did not
    have to save the result of `toLowerCase()` to a variable. Instead, we just immediately
    called `let()` on it to do what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an RxJava context, the `let()` function can be helpful in quickly taking
    an `Observable`, forking it, and then recombining it using a combine operator.
    In the following code, we multicast an `Observable` of numbers to a `let()` operator,
    which creates a sum and a count, and then returns the result of the `zipWith()`
    operator that uses both to find the average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The last line in `let()` is what gets returned and does not require a return
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `let()` is a powerful and simple tool to fluently convert an item
    into another item. Using it to fork an `Observable` or `Flowable` streams and
    then joining them again is one helpful application for it in RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: Using apply()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A tool similar to `let()` is `apply()`. Instead of turning a `T` item into an
    `R` item,which `let()` does, `apply()` executes a series of actions against the
    `T` item instead, before returning the same `T` item itself. This is helpful in
    declaring an item `T` but doing tangential operations on it without breaking the
    declaration/assignment flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a nonreactive example. We have a simple class, `MyItem`, which has
    a `startProcess()` function. We can instantiate `MyItem` but use `apply()` to
    call this `startProcess()` method before assigning `MyItem` to a variable, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In RxJava, `apply()` is helpful in adding an Observer or Subscriber in the middle
    of an `Observable`/`Flowable` chain but not breaking the flow from the primary
    task at hand. This can be helpful in emitting status messages to a separate stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we emit five 1-second intervals and multiply each one.
    However, we create a `statusObserver` and subscribe to it within `apply()` right
    before the multiplication. We multicast before `apply()` as well so emissions
    are pushed to both destinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So again, `apply()` is helpful in taking a multicasted stream of emissions and
    pushing them to multiple Observers without having any intermediary variables.
  prefs: []
  type: TYPE_NORMAL
- en: Similiar to `apply()` is the extension function `run()`, which executes a series
    of actions but has a void return type (or in Kotlin-speak, Unit). There is also
    `with()`, which is identical to `run()` except than it is not an extension function.
    It accepts the targeted item as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and data classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin supports Tuples to a small degree, but it also offers something even
    better with data classes. We will look at both of these in an RxJava context.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin supports the quick creation of a Pair containing two items (which can
    be of differing types). This is a simple two-value, but statically-typed, tuple.
    You can construct one quickly by putting the `to` keyword between two values.
    This is helpful in doing `zip()` operations between two streams, and you just
    want to pair the two items together.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we zip a stream of string items with a stream of `Int`
    items and put each pair into `Pair<String,Int>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: An even better approach is to use a data class. A data class is a powerful Kotlin
    tool that works just like a class, but it automatically implements `hashcode()`/`equals()`,
    `toString()`, as well as a nifty `copy()` function that allows you to clone and
    modify properties onto a new instance of that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'But for now, we will just use a data class as a cleaner approach than a `Pair`
    because we actually give each property a name instead of `first` and `second`.
    In the following code, we will create a `StringAndNumber` data class and use it
    to zip each pair of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Data classes (as well as just plain Kotlin classes) are quick and easy to declare,
    so you can use them tactically for even small tasks. Use them to make your code
    clearer and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Future of ReactiveX and Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is a powerful and pragmatic language. JetBrains put in a lot of effort
    not only to make it effective, but also compatible with existing Java code and
    libraries. Despite a few rough patches such as SAM lambda inference, they did
    a phenomenal job making Java and Kotlin work together. However, even with this
    solid compatibility, many developers become eager to migrate entirely to Kotlin
    to leverage its functionality. Named parameters, optional parameters, nullable
    types, extension functions, inline functions, delegates, and other language features
    make Kotlin attractive for exclusive use. Not to mention, JetBrains has successfully
    made Kotlin compilable to JavaScript and will soon support LLVM native compilation.
    Libraries built in pure Kotlin can potentially be compiled to all these platforms.
    To solidify Kotlin's position even further, Google officially established it as
    the next supported language for Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'So this begs the question: would there the benefit in creating a ReactiveX
    implementation in pure Kotlin and not rely on RxJava? After all, the Kotlin language
    has a powerful set of features that could offer a lot to a ReactiveX implementation
    and bring it to multiple platforms Kotlin will compile to. It would also create
    a ReactiveX experience optimized for Kotlin, supporting nullable type emissions,
    extension operators, and coroutine-based concurrency.'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines provide an interesting and useful abstraction to quickly (and more
    safely) implement concurrency into a Kotlin application. Because coroutines support
    task suspension, they provide a natural mechanism to support backpressure. In
    the event that a ReactiveX implementation in Kotlin is pursued, coroutines can
    play a huge part in making backpressure simple to implement.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn about how Kotlin coroutines can be leveraged to create
    a ReactiveX implementation in Kotlin, read Roman Elizarov's fascinating article
    at [https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/reactive/coroutines-guide-reactive.md).
  prefs: []
  type: TYPE_NORMAL
- en: So yes, there could be a lot to gain by making a ReactiveX implementation in
    pure Kotlin. At the time of writing this, this conversation is getting more traction
    in the Kotlin community. Keep an eye out as people continue to experiment and
    proof-of-concepts creep toward prototypes and then the official release.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to use RxJava for Kotlin. The Kotlin language
    is an exciting opportunity to express code on the JVM more pragmatically, and
    RxJava can leverage many of its useful features. Extension functions, data classes,
    RxKotlin, and functional operators such as `let()`/`apply()` allow you to express
    your reactive domain more easily. Although SAM inference can cause you to hit
    snags, you can leverage RxKotlin's helper utilities to get around this issue until
    JetBrains creates a fix. Down the road, it will be interesting to see if a ReactiveX
    implementation in pure Kotlin appears. Such an implementation would bring in a
    lot of functionality that Kotlin allows and Java does not.
  prefs: []
  type: TYPE_NORMAL
- en: This is the end! If you have covered this book cover-to-cover, congrats! You
    should have a strong foundation to leverage RxJava in your workplace and projects.
    Reactive programming is a radically different approach to problem solving, but
    it is radically effective too. Reactive programming will continue to grow in pertinence
    and shape the future of how we model code. Being on this cutting edge will make
    you not only marketable, but also a leader for the years to come.
  prefs: []
  type: TYPE_NORMAL
