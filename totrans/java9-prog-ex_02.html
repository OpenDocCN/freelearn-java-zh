<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The First Real Java Program - Sorting Names</h1>
            

            <article>
                
<p class="calibre2">In the previous chapter, we got acquainted with Java, and especially with using the REPL tool and interactively executing some simple code. That is a good start, but we need more. In this chapter, we will develop a simple sort program. Using this code as an example, we will look at different build tools, which are frequently used for Java projects, and learn the basic features of the Java language. This chapter will cover the following topics:</p>
<ul class="calibre14">
<li class="calibre15">The sorting problem</li>
<li class="calibre15">The project structure and build tools</li>
<li class="calibre15">The Make, Ant, Maven, and Gradle build tools</li>
<li class="calibre15">Java language features related to the code example</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting started with sorting</h1>
            

            <article>
                
<p class="calibre2">The sorting problem is one of the oldest programming tasks that an engineer deals with. We have a set of records and we know that we want to find a specific one sometime later, and we want to find that one fast. To find it, we sort the records in a specific order that helps us find the record we want quickly.</p>
<p class="calibre2">As an example, we have the names of students with their marks on some cards. When students come to the office asking for their results, we look through all of the cards one after the other to find the name of the enquiring student. However, it is better if we sort the cards by the names of the students alphabetically. When a student makes an enquiry, we can search the mark attached to the name much faster.</p>
<p class="calibre2">We can look at the middle card; if it shows the name of the student, then we are happy to have found the name and the mark. If the card precedes the name of the student alphabetically, then we will continue searching in the second half; otherwise, we will check the first half.</p>
<p class="calibre2">Following that approach, we can find the name of the student in a few steps. The number of steps can not be more than the number as many times the pack of cards can be halved. If we have two cards, then it is two steps at most. If it is four, then we will need three steps at most. If there are eight cards, then we may need four steps, but not more. If there are 1,000 cards, then we may need at most 11 steps, while the original, non-sorted set will need 1,000 steps, worst case. That is, approximately, it speeds up the search 100 times, so this is worth sorting the cards, unless the sorting itself takes too much time. The algorithm finding an element in the already sorted set we just described is called <strong class="calibre1">binary search</strong> (<span><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" class="calibre6">https://en.wikipedia.org/wiki/Binary_search_algorithm</a></span>)<span>.</span></p>
<p class="calibre2">In many cases, it is worth sorting the dataset, and there are many <a class="calibre6">sorting algorithms</a> to do that. There are simpler and more complex algorithms, and, as in many cases, more complex algorithms are the ones that run faster.</p>
<p class="calibre2">As we are focusing on the Java programming part and not the algorithm forging, in this chapter, we will develop a Java code that implements a simple and not-that-fast algorithm.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Bubble sort</h1>
            

            <article>
                
<p class="calibre2">The algorithm that we will implement in this chapter is well-known as <strong class="calibre1">bubble sort</strong>. The approach is very simple. Begin at the start of the cards and compare the first and the second card. If the first card is later in lexicographic order than the second one, then swap the two cards. Then repeat this for the card that is at the second place now, then the third, and so on. There is a card that is lexicographically the latest, say Wilson. When we get this card and start to compare it with the next one, we will always swap them; this way, Wilson's card will travel to the last place where it has to be after the sort. All we have to do is repeat this travelling from the start and do the occasional swapping of cards again, but this time only to the last but one element. This time, the second latest element will get to its place—say, Wilkinson will be right before Wilson. If we have <em class="calibre12">n</em> cards, and we repeat this <em class="calibre12">n-1</em> times, all cards will get to their place.</p>
<p class="calibre2">In the following sections, we will create a Java project that implements this algorithm.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting started with project structure and build tools</h1>
            

            <article>
                
<p class="calibre2">When a project is more complex than a single class, and it usually is, then it is wise to define a project structure. We will have to decide where we store the source files, where the resource files (those that contain some resource for the program, but are not Java source) are, where the <kbd class="calibre11">.class</kbd> files should be written by the compiler, and so on. Generally, the structure is mainly the directory setup and the configuration of the tools that perform the build.</p>
<p class="calibre2">The compilation of complex programs cannot be feasibly done using the command line issuing <kbd class="calibre11">javac</kbd> commands. If we have 100 Java source files, the compilation will require that many <kbd class="calibre11">javac</kbd> commands to be issued. It can be shortened using wild cards, such as <kbd class="calibre11">javac *.java</kbd> ,or we can write a simple bash script or a BAT command file that does that. First, it will be just 100 lines, each compiling one source Java file to class file. Then, we will realize that it is only time, CPU, and power consuming to compile the files that are not changed since the last compilations so we can add some bash programming that checks the time stamp on the source and generated files. Then, we will probably realize that... whatever. At the end, we will end up with a tool that is essentially a build tool. Build tools are available ready made; it is not worth reinventing the wheel.</p>
<p class="calibre2">Instead of creating one, we will use a build tool that is ready. There are a few of them that can be found at <a href="https://en.wikipedia.org/wiki/List_of_build_automation_software" class="calibre6"><span>https://en.wikipedia.org/wiki/List_of_build_automation_software</span></a>. In this chapter, we will use one called Maven; however, before jumping into the details of this tool, we will look at some other tools that you are likely to meet as a Java professional in enterprise projects.</p>
<p class="calibre2">In the following sections, we will discuss a bit of the four build tools:</p>
<ul class="calibre14">
<li class="calibre15">Make</li>
<li class="calibre15">Ant</li>
<li class="calibre15">Maven</li>
<li class="calibre15">Gradle</li>
</ul>
<p class="calibre2">We will mention Make only briefly because it is not used in Java environments these days. However, Make was the first build tool, and many ideas that modern Java build tools are based on come from the <em class="calibre12">good old  </em><kbd class="calibre11">make</kbd>. You, as a professional Java developer, should also be familiar with Make so that you will not freak out if you happen to see the use of it in a project for some purpose, and can know what it is and where its detailed documentation can be found.</p>
<p class="calibre2">Ant was the first build tool widely used for Java many years ago, and it is still used in many projects.</p>
<p class="calibre2">Maven is newer than Ant, and it uses a different approach. We will look at it in detail. Maven is also the official build tool of the Apache software foundation for the Java project. We will also use Maven as a build tool in this chapter.</p>
<p class="calibre2">Gradle is even newer, and it has started to catch up to Maven these days. We will use this tool in later chapters in more detail.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Make</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">make</kbd> program was originally created in April 1976, so this is not a new tool. It is included in the Unix system, so this tool is available without any extra installation on Linux, Mac OS X, or any other Unix-based system. Additionally, there are numerous ports of the tool on Windows, and some version is/was included in the Visual Studio compiler toolset.</p>
<p class="calibre2">The Make is not tied to Java. It was created when the major programming language was C, but it is not tied to C or any other language. The <kbd class="calibre11">make</kbd> is a dependency description language that has a very simple syntax.<br class="title-page-name"/>
The <kbd class="calibre11">make</kbd>, just like any other build tool, is controlled by a project description file. In the case of make, this file contains a rule set. The description file is usually named <kbd class="calibre11">Makefile</kbd>, but in case the name of the description file is different, it can be specified as a command-line option to the <kbd class="calibre11">make</kbd> command.</p>
<p class="calibre2">Rules in <kbd class="calibre11">Makefile</kbd> follow each other and consist of one or more lines. The first line starts at the first position (there is no tab or space at the start of the line) and the following lines start with a tab character. Thus, <kbd class="calibre11">Makefile</kbd> may look something like the following code:</p>
<pre class="calibre20">
run : hello.jar <br class="title-page-name"/>    java -cp hello.jar HelloWorld <br class="title-page-name"/><br class="title-page-name"/>hello.jar : HelloWorld.class <br class="title-page-name"/>    jar -cf hello.jar HelloWorld.class <br class="title-page-name"/><br class="title-page-name"/>HelloWorld.class : HelloWorld.java <br class="title-page-name"/>    javac HelloWorld.java
</pre>
<p class="calibre2">This file defines three so-called targets: <kbd class="calibre11">run</kbd>, <kbd class="calibre11">hello.jar</kbd>, and <kbd class="calibre11">HelloWorld.class</kbd>. To create <kbd class="calibre11">HelloWorld.class</kbd>, type the following line at the command prompt:</p>
<pre class="calibre20">
    <strong class="calibre1">make HelloWorld.class</strong>
</pre>
<p class="calibre2">Make will look at the rule and see that it depends on <kbd class="calibre11">HelloWorld.java</kbd>. If the <kbd class="calibre11">HelloWorld.class</kbd> file does not exist, or <kbd class="calibre11">HelloWorld.java</kbd> is newer than the Java class file, <kbd class="calibre11">make</kbd> will execute the command that is written on the next line and it will compile the Java source file. If the class file was created following the last modification of <kbd class="calibre11">HelloWorld.java</kbd>, then <kbd class="calibre11">make</kbd> knows that there is no need to run the command.</p>
<p class="calibre2">In the case of creating <kbd class="calibre11">HelloWorld.class</kbd>, the <kbd class="calibre11">make</kbd> program has an easy task. The source file was already there. If you issue the <kbd class="calibre11">make hello.jar</kbd> command, the procedure is more complex. The <kbd class="calibre11">make</kbd> command sees that in order to create <kbd class="calibre11">hello.jar</kbd>, it needs <kbd class="calibre11">HelloWorld.class</kbd>, which itself is also a target on another rule. Thus, it may need to be created.</p>
<p class="calibre2">First, it starts the problem the same way as before. If <kbd class="calibre11">HelloWorld.class</kbd> is there, and is older than <kbd class="calibre11">hello.jar</kbd>, there is nothing to do. If it is not there, or is newer than <kbd class="calibre11">hello.jar</kbd>, then the <kbd class="calibre11">jar -cf hello.jar HelloWorld.class</kbd> command needs to be executed, although not necessarily at the moment when it realizes that it has to be performed. The <kbd class="calibre11">make</kbd> program remembers that this command has to be executed sometime in the future when all the commands that are needed to create <kbd class="calibre11">HelloWorld.class</kbd> are already executed successfully. Thus, it continues to create the class file exactly the same way as I described earlier.</p>
<p class="calibre2">In general, a rule can have the following format:</p>
<pre class="calibre20">
target : dependencies <br class="title-page-name"/>    command
</pre>
<p class="calibre2">The <kbd class="calibre11">make</kbd> command can create any target using the <kbd class="calibre11">make target</kbd> command by first calculating which commands to execute and then executing them one by one. The commands are shell commands executing in a different process and may pose problems under Windows, which may render the <kbd class="calibre11">Makefile</kbd> files' operating system dependent.</p>
<p class="calibre2">Note that the <kbd class="calibre11">run</kbd> target is not an actual file that <kbd class="calibre11">make</kbd> creates. A target can be a file name or just a name for the target. In the latter case, <kbd class="calibre11">make</kbd> will never consider the target to be readily available.</p>
<p class="calibre2">As we do not use <kbd class="calibre11">make</kbd> for a Java project, there is no reason to get into more details. Additionally, I cheated a bit by making the description of a rule simpler than it should be. The <kbd class="calibre11">make</kbd> tool has many powerful features out of the scope of this book. There are also several implementations that differ a little from each other. You will most probably meet the one made by the Free Software Foundation—the GNU make. And, of course, just in case of any Unix command-line tool, <kbd class="calibre11">man</kbd> is your friend. The <kbd class="calibre11">man make</kbd> command will display the documentation of the tool on the screen.</p>
<p class="calibre2">The main points that you should remember about <kbd class="calibre11">make</kbd> are as follows:</p>
<ul class="calibre14">
<li class="calibre15">It defines the dependencies of the individual artifacts (targets) in a declarative way</li>
<li class="calibre15">It defines the actions to create the missing artifacts in an imperative way</li>
</ul>
<p class="calibre2">This structure was invented decades ago and has survived up until now for most of the build tools, as you will see in the next few chapters.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Ant</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">ant</kbd> build tool was built especially for Java projects around the year 2000. The aim of Java to be a <em class="calibre12">write-once-run-anywhere</em> language needed a tool that can also be used in different environments. Although <kbd class="calibre11">make</kbd> is available on Unix machines, and Windows as well, <kbd class="calibre11">Makefiles</kbd> were not always compatible. There was a small problem with the use of the tab character that some editors replaced with space, rendering <kbd class="calibre11">Makefile</kbd> unusable, but this was not the major reason. The main problem with <kbd class="calibre11">make</kbd> that ignited the development of Ant is that the commands are shell commands. Even if the implementation of the <kbd class="calibre11">make</kbd> program was made to be compatible on different operating systems, the used commands were many times incompatible, and that was something make itself could not change. Because <kbd class="calibre11">make</kbd> issues external commands to build the targets, developers are free to use any external tool that is available for them on the development machine. Another machine using the same operating system just may not have the same set of tools invoked by <kbd class="calibre11">make</kbd>. This undermines the portability of the <kbd class="calibre11">make</kbd> built projects.</p>
<p class="calibre2">At the same time, Ant is following the major principles of <kbd class="calibre11">make</kbd>. There are targets that may depend on each other and there are commands that need to be executed in an appropriate sequence to create the targets one after the other, following the dependency order. The description of the dependencies and the commands is XML (tab issue solved) and the commands are implemented in Java (system dependency is solved, well... more or less).</p>
<p class="calibre2">As Ant is neither part of the operating system nor the JDK, you will have to download and install it separately if you want to use it.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Installing Ant</h1>
            

            <article>
                
<p class="calibre2">Ant can be downloaded from its official website (<a href="http://ant.apache.org" class="calibre6"><span>http://ant.apache.org</span></a>). You can download the source or the precompiled version. The easiest way is to download the binary in a <kbd class="calibre11">tar.gz</kbd> format.</p>
<p class="calibre2">Whenever you download software from the Internet, it is highly recommended that you check the integrity of the downloaded file. The HTTP protocol does not contain error checking, and it may happen that a network error remains hidden or a malevolent internal proxy modifies the downloaded file. Download sites usually provide checksums for the downloadable files. These are usually MD5, SHA1, SHA512, or some other checksums.</p>
<p class="calibre2">When I downloaded the Apache Ant 1.9.7 version in <kbd class="calibre11">tar.gz</kbd> format, I also opened the page that led to the MD5 checksum. The checksum value is <kbd class="calibre11">bc1d9e5fe73eee5c50b26ed411fb0119</kbd>.</p>
<div class="packtfigure"><img class="image-border21" src="../images/00027.jpeg"/></div>
<div class="packttip">The downloaded file can be checked using the following command line:<br class="calibre23"/>
<kbd class="calibre22">$ md5 apache-ant-1.9.7-bin.tar.gz</kbd><br class="calibre23"/>
<kbd class="calibre22">MD5 (apache-ant-1.9.7-bin.tar.gz) = bc1d9e5fe73eee5c50b26ed411fb0119</kbd><br class="calibre23"/>
The calculated MD5 checksum is the same as the one on the website, which says that the file integrity is not harmed.<br class="calibre23"/>
On the Windows operating system, no tool to calculate MD5 digest is included. There is a tool that Microsoft provides, called <strong class="calibre24">File Integrity Checksum Verifier Utility</strong>, which is available via the page <a href="https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility" class="calibre25"><span class="URLPACKT">https://support.microsoft.com/en-us/help/841290/availability-and-description-of-the-file-checksum-integrity-verifier-utility</span></a>. If you use Linux, it may happen that the <kbd class="calibre22">md5</kbd> or <kbd class="calibre22">md5sum</kbd> utility is not installed. In that case, you can install it using the command <kbd class="calibre22">apt-get</kbd> or whatever installation tool your Linux distribution supports.</div>
<p class="calibre2">After the file is downloaded, you can explode it to a subdirectory using the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">tar xfz apache-ant-1.9.7-bin.tar.gz</strong>
</pre>
<p class="calibre2">The created subdirectory is the usable binary distribution of Ant. Usually, I move it under <kbd class="calibre11">~/bin</kbd>, making it available only for my user on OS X. After that, you should set the environment variable as <kbd class="calibre11">ANT_HOME</kbd> to point to this directory and also add the <kbd class="calibre11">bin</kbd> directory of the installation to the <kbd class="calibre11">PATH</kbd>. To do that, you should edit the <kbd class="calibre11">~/.bashrc</kbd> file and add the following lines to it:</p>
<pre class="calibre20">
export ANT_HOME=~/bin/apache-ant-1.9.7/ <br class="title-page-name"/>export PATH=${ANT_HOME}bin:$PATH
</pre>
<p class="calibre2">Then, restart the terminal application, or just type <kbd class="calibre11">. ~/.bashrc</kbd> and test the installation of Ant by typing the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">$ ant</strong><br class="title-page-name"/><strong class="calibre1">Buildfile: build.xml does not exist!</strong><br class="title-page-name"/><strong class="calibre1">Build failed</strong>
</pre>
<p class="calibre2">If the installation was correct, you should see the preceding error message.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using Ant</h1>
            

            <article>
                
<p class="calibre2">When you see a project to be built by Ant, you will see a <kbd class="calibre11">build.xml</kbd> file. This is the project build file, the one that Ant was missing when you checked that the installation was correct. It can have any other name, and you can specify the name of the file as a command-line option for Ant, but this is the default file name, as <kbd class="calibre11">Makefile</kbd> was for <kbd class="calibre11">make</kbd>. A <kbd class="calibre11">build.xml</kbd> sample looks like the following:</p>
<pre class="calibre20">
&lt;project name="HelloWorld" default="jar" basedir="."&gt; <br class="title-page-name"/>&lt;description&gt; <br class="title-page-name"/>    This is a sample HelloWorld project build file. <br class="title-page-name"/>&lt;/description&gt; <br class="title-page-name"/>    &lt;property name="buildDir" value="build"/&gt; <br class="title-page-name"/>    &lt;property name="srcDir" value="src"/&gt; <br class="title-page-name"/>    &lt;property name="classesDir" value="${buildDir}/classes"/&gt; <br class="title-page-name"/>    &lt;property name="jarDir" value="${buildDir}/jar"/&gt; <br class="title-page-name"/><br class="title-page-name"/>    &lt;target name="dirs"&gt; <br class="title-page-name"/>        &lt;mkdir dir="${classesDir}"/&gt; <br class="title-page-name"/>        &lt;mkdir dir="${jarDir}"/&gt; <br class="title-page-name"/>    &lt;/target&gt; <br class="title-page-name"/><br class="title-page-name"/>    &lt;target name="compile" depends="dirs"&gt; <br class="title-page-name"/>        &lt;javac srcdir="${srcDir}" destdir="${classesDir}"/&gt; <br class="title-page-name"/>    &lt;/target&gt; <br class="title-page-name"/><br class="title-page-name"/>    &lt;target name="jar" depends="dirs,compile"&gt; <br class="title-page-name"/>        &lt;jar destfile="${jarDir}/HelloWorld.jar" basedir="${classesDir}"/&gt; <br class="title-page-name"/>    &lt;/target&gt; <br class="title-page-name"/>&lt;/project&gt;
</pre>
<p class="calibre2">The top-level XML tag is <kbd class="calibre11">project</kbd>. Each build file describes one project, hence the name. There are three possible attributes to the tag, which are as follows:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">name</kbd>: This defines the name of the project and is used by some IDEs to display it in the left panel identifying the project</li>
<li class="calibre15"><kbd class="calibre11">default</kbd>: This names the target to use when no target is defined on the command line starting Ant</li>
<li class="calibre15"><kbd class="calibre11">basedir</kbd>: This defines the initial directory used for any other directory name calculation in the build file</li>
</ul>
<p class="calibre2">The build file can contain a description for the project, as well as properties in property tags. These properties can be used as variables in the attributes of the tasks between the <kbd class="calibre11">${</kbd> and <kbd class="calibre11">}</kbd> characters, and play an important role in the build process.</p>
<p class="calibre2">The targets are defined in target XML tags. Each tag should have a name that uniquely identifies the target in the build file and may have a <kbd class="calibre11">depends</kbd> tag that specifies one or more other targets that this target depends on. In case there is more than one target, the targets are comma separated in the attribute. The tasks belonging to the targets are executed in the same order as the targets dependency chain requires, in a very similar way as we saw in the case of <kbd class="calibre11">make</kbd>.</p>
<p class="calibre2">You can also add a <kbd class="calibre11">description</kbd> attribute to a target that is printed by Ant when the command-line option, <kbd class="calibre11">-projecthelp</kbd>, is used. This helps the users of the build file to know what targets are there and which does what. Build files tend to grow large with many targets, and when you have ten or more targets, it is hard to remember each and every target.</p>
<p class="calibre2">The sample project with <kbd class="calibre11">HelloWorld.java</kbd> is now arranged in the following directories:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">build.xml</kbd> in the <kbd class="calibre11">root</kbd> folder of the project</li>
<li class="calibre15"><kbd class="calibre11">HelloWorld.java</kbd> in the <kbd class="calibre11">src</kbd> folder of the project</li>
<li class="calibre15">The <kbd class="calibre11">build/</kbd> folder does not exist; it will be created during the build process</li>
<li class="calibre15">The <kbd class="calibre11">build/classes</kbd> and <kbd class="calibre11">build/jar</kbd> also do not exist yet, and will be created during the build process</li>
</ul>
<p class="calibre2">When you start the build for the <kbd class="calibre11">HelloWorld</kbd> project the first time, you will see the following output:</p>
<pre class="calibre20">
$ ant  <br class="title-page-name"/>Buildfile: /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build.xml <br class="title-page-name"/><br class="title-page-name"/>dirs: <br class="title-page-name"/>    [mkdir] Created dir: /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build/classes <br class="title-page-name"/>    [mkdir] Created dir: /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build/jar <br class="title-page-name"/><br class="title-page-name"/>compile: <br class="title-page-name"/>... <br class="title-page-name"/>    [javac] Compiling 1 source file to /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build/classes <br class="title-page-name"/><br class="title-page-name"/>jar: <br class="title-page-name"/>      [jar] Building jar: /Users/verhasp/Dropbox/java_9-by_Example/sources/ch02/build/jar/HelloWorld.jar <br class="title-page-name"/><br class="title-page-name"/>BUILD SUCCESSFUL <br class="title-page-name"/>Total time: 0 seconds
</pre>
<div class="packtinfobox">Some unimportant lines are deleted from the actual output.</div>
<p class="calibre2">Ant realizes that first it has to create the directories, then it has to compile the source code, and finally it can pack the <kbd class="calibre11">.class</kbd> files into a <kbd class="calibre11">.jar</kbd> file. Now it is up to you to remember the command to execute the <kbd class="calibre11">HelloWorld</kbd> application. It was listed already in the first chapter. Note that this time, the JAR file is named <kbd class="calibre11">HelloWorld.jar</kbd>, and it is not in the current directory. You can also try to read the online documentation of Ant and create a target <kbd class="calibre11">run</kbd> that executes the compiled and packed program.</p>
<div class="packttip">Ant has a built-in task named <kbd class="calibre22">java</kbd> that executes a Java class in almost the same way as you typed the <kbd class="calibre22">java</kbd> command in the terminal.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Maven</h1>
            

            <article>
                
<p class="calibre2">As Ant was created to overcome the shortages of <kbd class="calibre11">make</kbd>, Maven was created with a similar intention—to overcome the shortages of Ant. You may recall that make could not guarantee build portability because the commands <kbd class="calibre11">make</kbd> executes are arbitrary shell commands that may be system specific. An Ant build, if all the tasks are available on the classpath, is portable as long as Java runs the same way on the different platforms.</p>
<p class="calibre2">The problem with Ant is a bit different. When you download the source code of a project and you want to build, what will the command be? You should ask Ant to list all the targets and select the one that seems to be the most suitable. The name of the task depends on the engineer who crafted the <kbd class="calibre11">build.xml</kbd> file. There are some conventions, but they are not strict rules.</p>
<p class="calibre2">Where will you find the Java source files? Are they in the <kbd class="calibre11">src</kbd> directory or not? Will there also be some Groovy or other programming language files in case the project is polyglot? That depends. Again, there may be some conventions that some groups or company cultures suggest, but there is no general best industry practice.</p>
<p class="calibre2">When you start a new project with Ant, you will have to create the targets for compilation, test execution, and packaging. It is something that you will have already done for other projects. After the second or third project, you will just copy and paste your previous <kbd class="calibre11">build.xml</kbd> to your new project. Is that a problem? Yes, it is. It is copy/paste programming, even if it is <em class="calibre12">only</em> some build files.</p>
<p class="calibre2">Developers realized that a significant effort of the projects utilizing Ant is devoted to project build tool configuration, including repetitive tasks. When a new joiner comes to the team, they will first have to learn how the build is configured. If a new project is started, the build configuration has to be created. If it is a repetitive task, then better let the computers do it. That is generally what programming is all about, isn't it?</p>
<p class="calibre2">Maven approaches the build issue a bit differently. We want to build Java projects. Sometimes, some <em class="calibre12">Groovy</em> or <em class="calibre12">Jython</em> things, but they are also <em class="calibre12">JVM</em> languages; thus, saying that we want to build Java projects is not really a huge restriction. Java projects contain Java files, sometimes some other programming language's source files, resource files, and generally, that is it. <em class="calibre12">Ant</em> can do anything, but we do not want to do just anything with a build tool. We want to build projects.</p>
<p class="calibre2">Okay, after we restricted ourselves and accepted that we do not need a build tool that can be used for anything, we can go on. We can require that the source files be under the <kbd class="calibre11">src</kbd> directory. There are files that are needed for the operational code and there are files that contain some test code and data. Therefore, we will have two directories, <kbd class="calibre11">src/test</kbd> and <kbd class="calibre11">src/main</kbd>. Java files are in <kbd class="calibre11">src/main/java</kbd> as well as <kbd class="calibre11">src/test/java</kbd>. Resource files are under <kbd class="calibre11">src/main/resources</kbd> and <kbd class="calibre11">src/test/resources</kbd>.</p>
<p class="calibre2">If you want to put your source files somewhere else, then don't. I mean it. It is possible, but I will not even tell you how. Nobody does it. I do not even have any idea why Maven makes it possible. Whenever you see a project that is using Maven as a build tool, the sources are organized like that. There is no need to understand the directory structure envisioned by the project's build engineer. It is always the same.</p>
<p class="calibre2">How about the targets and the tasks? They are also the same for all Maven-based projects. What else would you like to do with a Java project other than compile, test, package, or deploy it? Maven defines these project life cycles for us. When you want to compile a project using Maven as a build tool, you will have to type <kbd class="calibre11">$ mvn compile</kbd> to compile the project. You can do that even before understanding what the project actually is.</p>
<p class="calibre2">As we have the same directory structure and the same goals, the actual tasks leading to the goals are also all the same. When we create a Maven project, we do not have to describe what the build process has to do and how it has to do it. We will have to describe the project, and only the parts that are project specific.</p>
<p class="calibre2">The build configuration of a Maven project is given in an XML file. The name of this file is usually <kbd class="calibre11">pom.xml</kbd>, and it should be in the <kbd class="calibre11">root</kbd> directory of the project, which should be the current working directory when firing up Maven. The word <strong class="calibre1">POM</strong> stands for <strong class="calibre1">Project Object Model</strong>, and it describes the projects in a hierarchical way. The source directories, the packaging, and other things are defined in a so-called super POM. This POM is part of the Maven program. Anything that the POM defines, overrides the defaults defined in the super POM. When there is a project with multiple modules, the POMs are arranged into a hierarchy, and they inherit the configuration values from the parent down to the modules. As we will use Maven to develop our sorting code, we will see some more details later.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Installing Maven</h1>
            

            <article>
                
<p class="calibre2">Maven is neither a part of the operating system nor the JDK. It has to be downloaded and installed in a very similar way to Ant. You can download Maven from its official website (<a href="https://maven.apache.org/" class="calibre6"><span>https://maven.apache.org/</span></a>) under the download section. Currently, the latest stable version is 3.3.9. When you download it, the actual release may be different; instead, use the latest stable version. You can download the source or the precompiled version. The easiest way is to download the binary in <kbd class="calibre11">tar.gz</kbd> format.</p>
<div class="packtinfobox">I cannot skip drawing your attention to the importance of checking the download integrity using checksums. I have detailed the way to do it in the section about Ant installation.</div>
<p class="calibre2">After the file is downloaded, you can explode it to a subdirectory using the following command:</p>
<pre class="calibre20">
tar xfz apache-maven-3.3.9-bin.tar.gz
</pre>
<p class="calibre2">The created subdirectory is the usable binary distribution of Maven. Usually, I move it under <kbd class="calibre11">~/bin</kbd>, making it available only for my user on OS X. After that, you should add the <kbd class="calibre11">bin</kbd> directory of the installation to the <kbd class="calibre11">PATH</kbd>. To do that, you should edit the <kbd class="calibre11">~/.bashrc</kbd> file and add the following lines to it:</p>
<pre class="calibre20">
export M2_HOME=~/bin/apache-maven-3.3.9/ <br class="title-page-name"/>export PATH=${M2_HOME}bin:$PATH
</pre>
<p class="calibre2">Then, restart the terminal application, or just type <kbd class="calibre11">. ~/.bashrc</kbd> and test the installation of Maven typing, as follows:</p>
<pre class="calibre20">
    <strong class="calibre1">$ mvn -v</strong><br class="title-page-name"/><strong class="calibre1">Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T17:41:47+01:00)</strong><br class="title-page-name"/><strong class="calibre1">Maven home: /Users/verhasp/bin/apache-maven-3.3.9</strong><br class="title-page-name"/><strong class="calibre1">Java version: 9-ea, vendor: Oracle Corporation</strong><br class="title-page-name"/><strong class="calibre1">Java home: /Library/Java/JavaVirtualMachines/jdk-9.jdk/Contents/Home</strong><br class="title-page-name"/><strong class="calibre1">Default locale: en_US, platform encoding: UTF-8</strong><br class="title-page-name"/><strong class="calibre1">OS name: "mac os x", version: "10.11.6", arch: "x86_64", family: "mac"</strong>
</pre>
<p class="calibre2">You should see a similar message on the screen that displays the installed Maven version and other information.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Using Maven</h1>
            

            <article>
                
<p class="calibre2">Unlike Ant, Maven helps you create the skeleton of a new project. To do that, you will have to type the following command:</p>
<pre class="calibre20">
    $ <a class="calibre26">mvn archetype:generate</a>
</pre>
<p class="calibre2">Maven will first download the actually available project types from the network and prompt you to select the one you want to use. This approach seemed to be a good idea while Maven was new. When I first started Maven, the number of listed projects was somewhere between 10 and 20. Today, as I write this book, it lists 1,635 different archetypes. This number seems more like a historical date (the constitution of the French Academy of Science) than a usable size list of different archetypes. However, do not freak out. Maven offers a default value when it asks for your choice, and it is good for the <kbd class="calibre11">HelloWorld</kbd> we go for.</p>
<pre class="calibre20">
    <strong class="calibre1">Choose a number: 817: </strong>
</pre>
<p class="calibre2">The actual number may be different on your installation. Whatever it is, accept the suggestion and press <em class="calibre12">Enter</em>. After that, Maven will ask you for the version of the project:</p>
<pre class="calibre20">
    <strong class="calibre1">Choose version: </strong><br class="title-page-name"/><strong class="calibre1">1: 1.0-alpha-1</strong><br class="title-page-name"/><strong class="calibre1">2: 1.0-alpha-2</strong><br class="title-page-name"/><strong class="calibre1">3: 1.0-alpha-3</strong><br class="title-page-name"/><strong class="calibre1">4: 1.0-alpha-4</strong><br class="title-page-name"/><strong class="calibre1">5: 1.0</strong><br class="title-page-name"/><strong class="calibre1">6: 1.1</strong><br class="title-page-name"/><strong class="calibre1">Choose a number: 6: 5</strong>
</pre>
<p class="calibre2">Select the <kbd class="calibre11">1.0</kbd> version that is listed as number <kbd class="calibre11">5</kbd>. The next thing Maven asks for is the group ID and the artifact ID of the project. The dependency management that we will discuss later uses these. I selected a group ID based on the book and the publisher. The <a class="calibre6">artifact</a> of the project is <kbd class="calibre11">SortTutorial</kbd> as we will start our chapter example in this project.</p>
<pre class="calibre20">
Define value for property 'groupId': : <strong class="calibre1">packt.java9.by.example</strong><br class="title-page-name"/>Define value for property 'artifactId': : <strong class="calibre1">SortTutorial</strong>
</pre>
<p class="calibre2">The next question is the current version of the project. We have already selected <kbd class="calibre11">1.0</kbd> and Maven offers <kbd class="calibre11">1.0-SNAPSHOT</kbd>. Here, I selected <kbd class="calibre11">1.0.0-SNAPSHOT</kbd> because I prefer semantic versioning.</p>
<pre class="calibre20">
Define value for property 'version':  <strong class="calibre1">1.0-SNAPSHOT: : 1.0.0-SNAPSHOT</strong>
</pre>
<div class="packtinfobox">Semantic versioning, defined on <span class="URLPACKT"><a href="http://semver.org/" class="calibre25">http://semver.org/</a>,</span> is a versioning scheme that suggests three digit version numbers as <em class="calibre27">M.m.p.</em> for <em class="calibre27">Major</em>, <em class="calibre27">minor</em>, and <em class="calibre27">patch</em> version numbers. This is very useful for libraries. You will increment the last version number if there is only a bug fix since the previous release. You will increment the minor number when the new release also contains new features, but the library is compatible with the previous version; in other words, any program that is using the older version can still use the newer version. The major release number is increased when the new version is significantly different from the previous one.<br class="calibre23"/>
In the case of application programs, there is no code that uses the application API; thus, the minor version number is not that important. It does not hurt, though, and it often proves to be useful to signal smaller changes in the application. We will discuss how to version software in the last chapter.</div>
<p class="calibre2">Maven handles the versions that have the <kbd class="calibre11">-SNAPSHOT</kbd> postfix as non-release versions. While we develop the code, we will have many <em class="calibre12">versions</em> of our code, all having the same snapshot version number. On the other hand, non-snapshot version numbers can only be used only for a single version.</p>
<pre class="calibre20">
Define value for property 'package':  packt.java9.by.example: :
</pre>
<p class="calibre2">The last question from the program skeleton generation is the name of the Java package. The default is the value we gave for <kbd class="calibre11">groupId</kbd>, and we will use this. It is a rare exception to use something else.</p>
<p class="calibre2">When we have specified all the parameters that are needed, the final request is to confirm the setting:</p>
<pre class="calibre20">
Confirm properties configuration: <br class="title-page-name"/>groupId: packt.java9.by.example <br class="title-page-name"/>artifactId: SortTutorial <br class="title-page-name"/>version: 1.0.0-SNAPSHOT <br class="title-page-name"/>package: packt.java9.by.example <br class="title-page-name"/> Y: : Y
</pre>
<p class="calibre2">After entering <kbd class="calibre11">Y</kbd>, Maven will generate the files that are needed for the project and display the report about this:</p>
<pre class="calibre20">
[INFO] ----------------------------------------------------------- <br class="title-page-name"/>[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.0 <br class="title-page-name"/>[INFO] ----------------------------------------------------------- <br class="title-page-name"/>[INFO] Parameter: basedir, Value: .../mavenHelloWorld <br class="title-page-name"/>[INFO] Parameter: package, Value: packt.java9.by.example <br class="title-page-name"/>[INFO] Parameter: groupId, Value: packt.java9.by.example <br class="title-page-name"/>[INFO] Parameter: artifactId, Value: SortTutorial <br class="title-page-name"/>[INFO] Parameter: packageName, Value: packt.java9.by.example <br class="title-page-name"/>[INFO] Parameter: version, Value: 1.0.0-SNAPSHOT <br class="title-page-name"/>[INFO] *** End of debug info from resources from generated POM *** <br class="title-page-name"/>[INFO] project created from Old (1.x) Archetype in dir: .../mavenHelloWorld/SortTutorial <br class="title-page-name"/>[INFO] ----------------------------------------------------------- <br class="title-page-name"/>[INFO] BUILD SUCCESS <br class="title-page-name"/>[INFO] ----------------------------------------------------------- <br class="title-page-name"/>[INFO] Total time: 01:27 min <br class="title-page-name"/>[INFO] Finished at: 2016-07-24T14:22:36+02:00 <br class="title-page-name"/>[INFO] Final Memory: 11M/153M <br class="title-page-name"/>[INFO] -----------------------------------------------------------
</pre>
<p class="calibre2">You can take look at the following generated directory structure:</p>
<div class="packtfigure"><img class="image-border22" src="../images/00028.jpeg"/></div>
<p class="calibre2">You can also see that it generated the following three files:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">SortTutorial/pom.xml</kbd> that contains the <strong class="calibre1">Project Object Model</strong></li>
<li class="calibre15"><kbd class="calibre11">SortTutorial/</kbd><kbd class="calibre11">src/main/java/packt/java9/by/example/App.java</kbd> that contains a <kbd class="calibre11">HelloWorld</kbd> sample application</li>
<li class="calibre15"><kbd class="calibre11">SortTutorial/src/test/java/packt/java9/by/example/AppTest.java</kbd> that contains a unit test skeleton utilizing the <kbd class="calibre11">junit4</kbd> library</li>
</ul>
<p class="calibre2">We will discuss unit tests in the next chapter. For now, we will focus on the sorting application. As Maven was so kind and generated a sample class for the app, we can compile and run it without actual coding, just to see how we can build the project using Maven. Change the default directory to <kbd class="calibre11">SortTutorial</kbd> issuing <kbd class="calibre11">cd SortTutorial</kbd> and issue the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">$ mvn package</strong>
</pre>
<p class="calibre2">We will get the following output:</p>
<div class="packtfigure"><img class="image-border" src="../images/00029.jpeg"/></div>
<p class="calibre2">Maven fires up, compiles, and packages the project automatically. If not, please read the next info box.</p>
<div class="packtinfobox">When you first start Maven, it downloads a lot of dependencies from the central repository. These downloads take time, and are reported on the screen, so the actual output may be different from what you saw in the preceding code.<br class="calibre23"/>
Maven compiles code with the default settings for Java version 1.5. It means that the generated class file is compatible with Java version 1.5, and also that the compiler only accepts language constructs that were available already in Java 1.5. If we want to use newer language features, and in this book we use a lot, the <kbd class="calibre22">pom.xml</kbd> file should be edited to contain the following lines:
<div class="calibre23">
<p class="calibre21"><kbd class="calibre22">&lt;build&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">    &lt;plugins&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">      &lt;plugin&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">        &lt;configuration&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">          &lt;source&gt;1.9&lt;/source&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">          &lt;target&gt;1.9&lt;/target&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">        &lt;/configuration&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">      &lt;/plugin&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">    &lt;/plugins&gt;</kbd></p>
<p class="calibre21"><kbd class="calibre22">  &lt;/build&gt;</kbd></p>
</div>
<p class="calibre21">When using Java 9's default settings for Maven, it becomes even more complex, because Java 9 does not generate class format nor restrict source compatibility earlier than Java 1.6. At this very moment, as I write these lines, the latest Maven release is 3.3.9. When I try to compile the preceding code without the modifications, the Java compiler stops with an error displaying the following:<br class="calibre23"/>
<kbd class="calibre22">[ERROR] Source option 1.5 is no longer supported. Use 1.6 or later.</kbd><br class="calibre23"/>
<strong class="calibre24"><kbd class="calibre22">[ERROR] Target option 1.5 is no longer supported. Use 1.6 or later.</kbd><br class="calibre23"/></strong><br class="calibre23"/>
Later, Maven releases may behave differently in the future.</p>
</div>
<p class="calibre2">Now, you can start the code using the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">$ java -cp target/SortTutorial-1.0.0-SNAPSHOT.jar packt.java9.by.example.App</strong>
</pre>
<p class="calibre2">You can see the result of a sample run in the following picture:</p>
<div class="packtfigure"><strong class="calibre1"><br class="title-page-name"/></strong><img class="image-border" src="../images/00030.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Gradle</h1>
            

            <article>
                
<p class="calibre2">Ant and Maven are two worlds, and using one or the other may lead to heated debates on Internet forums. Ant gives freedom to developers to create a build process that fits their taste. Maven restricts the team to use a build process that is more standard. Some special processes that do not match any standard build, but which are sometimes needed in some environments, are hard to implement using Maven. In Ant, you can script almost anything using the built-in tasks, almost the same way as you can program bash. Utilizing Maven is not that simple, and, it often requires writing a plugin. Even though writing a plugin is not rocket science, developers usually like to have the possibility of making things in a simpler way: Scripting. We have two approaches, two mindsets and styles, and not a single tool to fulfill all the needs. No surprise that by the Java technologies were developed, a new build tool was emerging.</p>
<p class="calibre2">Gradle tries to use the best of both worlds, utilizing techniques that were not available by the time Maven and Ant were first developed.</p>
<p class="calibre2">Gradle has built-in targets and life cycle, but at the same time, you can also write your own targets. You can configure a project, just like using Maven, without scripting the tasks to do so, but at the same time, you can also script your own target just like in Ant. What is more, Gradle integrated Ant, so any task implemented for Ant is available for Gradle as well.</p>
<p class="calibre2">Maven and Ant use XML files to describe the build. Today, XML is a technology of the past. We still use it, and a developer should be fluent in handling, reading, and writing XML files, but a <em class="calibre12">modern</em> tool does not use XML for configuration. New, fancy formats such as JSON are more popular. Gradle is no exception. The configuration file of Gradle uses a <strong class="calibre1">domain-specific language</strong> (<strong class="calibre1">DSL</strong>) based on Groovy. This language is more readable for programmers and gives more freedom to program build processes. And, this is also the danger of Gradle.</p>
<p class="calibre2">Having the powerful JVM language Groovy in the hands of developers to create build tools gives a freedom and temptation to create complex build processes that seem to be a good idea at the start, but later may prove to be just too complex and hard, and, therefore, expensive to maintain. This is exactly why Maven was implemented in the first place.</p>
<p class="calibre2">I have to stop before getting into another area that is the ground for heated and pointless debates. Gradle is an extremely powerful build tool. You should use it carefully, just like you would use a weapon—don't shoot your legs.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Installing Gradle</h1>
            

            <article>
                
<p class="calibre2">To install Gradle, you will have to download the compiled binaries from the <a href="https://gradle.org/gradle-download/" class="calibre6"><span>https://gradle.org/gradle-download/</span></a> website.</p>
<div class="packtinfobox">Again, I'd like to emphasize the importance of checking the download integrity using checksums. I have given a detailed way to do it in the section about Ant installation.<br class="calibre23"/>
Unfortunately, the Gradle website does not provide the checksum values for the downloadable files.</div>
<p class="calibre2">Gradle is downloadable in the ZIP format. To unpack the file, you will have to use the unzip command:</p>
<pre class="calibre20">
    <strong class="calibre1">$ unzip gradle-3.3-bin.zip</strong>
</pre>
<p class="calibre2">The created subdirectory is the usable binary distribution of Gradle. Usually, I move it under <kbd class="calibre11">~/bin</kbd>, making it available only for my user on OS X. After that, you should add the <kbd class="calibre11">bin</kbd> directory of the installation to the <kbd class="calibre11">PATH</kbd>. To do that, you should edit the <kbd class="calibre11">~/.bashrc</kbd> file and add the following lines:</p>
<pre class="calibre20">
export GRADLE_HOME=~/bin/gradle-3.3/ <br class="title-page-name"/>export PATH=${GRADLE_HOME}bin:$PATH
</pre>
<p class="calibre2">Then, restart the terminal application, or just type <kbd class="calibre11">. ~/.bashrc</kbd> and test the installation of Gradle, typing the following:</p>
<pre class="calibre20">
    <strong class="calibre1">$ gradle -version</strong>
</pre>
<p class="CDPAlignLeft1">We get to the following output, as can be seen in this screenshot:</p>
<div class="packtfigure"><img class="image-border23" src="../images/00031.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Setting up the project with Maven</h1>
            

            <article>
                
<p class="calibre2">To start the project, we will use the directory structure and <kbd class="calibre11">pom.xml</kbd> that was created by Maven itself when we started with the following command line:</p>
<pre class="calibre20">
    <strong class="calibre1">$ mvn archetype:generate</strong>
</pre>
<p class="calibre2">It created the directories, the <kbd class="calibre11">pom.xml</kbd> file, and an <kbd class="calibre11">App.java</kbd> file. Now, we will extend this project by creating new files. We will code the sorting algorithm first in the <kbd class="calibre11">packt.java9.by.example.stringsort</kbd> package:</p>
<div class="packtfigure"><img class="image-border24" src="../images/00032.jpeg"/></div>
<p class="calibre2">When we create the new package in the IDE, the editor will automatically create the <kbd class="calibre11">stringsort</kbd> subdirectory under the already existing <kbd class="calibre11">src/main/java/packt/java9/by/example</kbd> directory:</p>
<div class="packtfigure"><img class="alignnone1" src="../images/00033.jpeg"/></div>
<p class="calibre2">Creating the new <kbd class="calibre11">Sort</kbd> class using the IDE will also automatically create a new file named <kbd class="calibre11">Sort.java</kbd> in this directory, and it will fill in the skeleton of the class:</p>
<pre class="calibre20">
package packt.java9.by.example.stringsort; <br class="title-page-name"/><br class="title-page-name"/>public class Sort { <br class="title-page-name"/>}
</pre>
<p class="calibre2">We will now have <kbd class="calibre11">App.java</kbd> containing the following code:</p>
<pre class="calibre20">
package packt.java9.by.example; <br class="title-page-name"/><br class="title-page-name"/>public class App  <br class="title-page-name"/>{ <br class="title-page-name"/>    public static void main( String[] args ) <br class="title-page-name"/>    { <br class="title-page-name"/>        System.out.println( "Hello World!" ); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Maven created it as a starting version. We will edit this file to provide a sample list that the sorting algorithm can sort. I recommend that you use the IDE to edit the file and also to compile and run the code. The IDE provides a shortcut menu to start the code and this is a bit easier than typing the command in Terminal. Generally, it is recommended that you get acquainted with the IDE features to save time avoiding repetitive tasks, such as typing terminal commands. Professional developers use the command line almost exclusively to test command-line features and use the IDE whenever it is possible.</p>
<div class="packtfigure"><img class="alignnone2" src="../images/00034.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Coding the sort</h1>
            

            <article>
                
<p class="calibre2">Maven and the IDE created the files for the sort program. They form the skeleton for our code, and now it is time to grow some muscles on them to let it move. We spent quite some time to set up the project by visiting the different build tools, only to learn how to compile the code. I hope that this did not distract you much, but anyhow, we deserve to see some real code.</p>
<p class="calibre2">First, we will create the code for the sorting code, and after that, the code that invokes the sorting. The code that invokes the sorting is a kind of testing code. For simplicity, we will now simply use a <kbd class="calibre11">public static void main</kbd> method to start the code. We will use the test framework in later chapters.</p>
<p class="calibre2">As for now, the code for the sorting will look like this:</p>
<pre class="calibre20">
package packt.java9.by.example.stringsort; <br class="title-page-name"/><br class="title-page-name"/>public class Sort { <br class="title-page-name"/><br class="title-page-name"/>    public void sort(String[] names) { <br class="title-page-name"/>        int n = names.length; <br class="title-page-name"/>        while (n &gt; 1) { <br class="title-page-name"/>            for (int j = 0; j &lt; n - 1; j++) { <br class="title-page-name"/>                if (names[j].compareTo(names[j + 1]) &gt; 0) { <br class="title-page-name"/>                    final String tmp = names[j + 1]; <br class="title-page-name"/>                    names[j + 1] = names[j]; <br class="title-page-name"/>                    names[j] = tmp; <br class="title-page-name"/>                } <br class="title-page-name"/>            } <br class="title-page-name"/>            n--; <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This is the class that does the sorting. There is only one method in this class that does the sorting. The argument to the method is an array containing the strings, and the method sorts this array. The method has no return value. This is denoted in the declaration using the pseudo type <kbd class="calibre11">void</kbd>. Methods use their arguments to perform some tasks, and may return one value. The arguments to the method are passed by value, which means that the method cannot modify the variable passed as argument. However, it can modify the objects the arguments contain. In this case, the array is modified and we will sort it. On the other hand, the <kbd class="calibre11">actualNames</kbd> variable will point to the same array and the <kbd class="calibre11">sort</kbd> method cannot do anything to make this variable point to a different array.</p>
<p class="calibre2">There is no <kbd class="calibre11">main</kbd> method in this class, which means that it cannot be started from the command line on its own. This class can only be used from some other class, as every Java program should have a class that has a <kbd class="calibre11">public static void main</kbd> method that we created separately.</p>
<p class="calibre2">I could also put a <kbd class="calibre11">main</kbd> method into the class to make it executable, but that is not a good practice. Real programs are composed of many classes, and one class should not do many things. Rather, it's the opposite. The s<em class="calibre12">ingle responsibility principle</em> says that a single class should be responsible for one single thing; therefore, <kbd class="calibre11">class sort</kbd> does the sorting. Executing the application is a different task, and thus it has to be implemented in a different class.</p>
<p class="calibre2">Often, we do not implement the class containing the <kbd class="calibre11">main</kbd> method. Often, a framework provides it. For example, writing a <em class="calibre12">servlet</em> that runs in a servlet container requires containing a class that implements the <kbd class="calibre11">javax.servlet.Servlet</kbd> interface. In this case, the program seemingly does not have a <kbd class="calibre11">main</kbd> method. The actual implementation of the servlet container does. The Java command line starts the container and the container loads the servlets when they are needed.</p>
<p class="calibre2">In the following example code, we implemented the <kbd class="calibre11">App</kbd> class containing the <kbd class="calibre11">main</kbd> method:</p>
<pre class="calibre20">
package packt.java9.by.example; <br class="title-page-name"/><br class="title-page-name"/>import packt.java9.by.example.stringsort.Sort; <br class="title-page-name"/><br class="title-page-name"/>public class App { <br class="title-page-name"/>    public static void main(String[] args) { <br class="title-page-name"/>        String[] actualNames = new String[]{ <br class="title-page-name"/>                "Johnson", "Wilson", <br class="title-page-name"/>                "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>        }; <br class="title-page-name"/>        final Sort sorter = new Sort(); <br class="title-page-name"/>        sorter.sort(actualNames); <br class="title-page-name"/>        for (final String name : actualNames) { <br class="title-page-name"/>            System.out.println(name); <br class="title-page-name"/>        } <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">This code contains a string array initialized to contain constant values, creates a new instance of the <kbd class="calibre11">Sort</kbd> class, invokes the <kbd class="calibre11">sort</kbd> method, and then prints out the code to the standard output.</p>
<p class="calibre2">In real programs, we almost never have such constants in program codes; we put them into resource files and have some code to read the actual values. This separates the code from data and eases maintenance, eliminating the risk of accidental modification of code structure when only the data is to be changed. Similarly, we will almost never write anything to standard output using <kbd class="calibre11">System.out</kbd>. Usually, we will use logging possibilities that are available from different sources. There are different libraries that provide logging functionalities and logging is also available from the JDK itself.</p>
<p class="calibre2">As for now, we will focus on simple solutions so as to not distract your focus from Java by the plethora of different libraries and tools. In the following section, we will look at the Java language constructs that we used to code the algorithm. First, we will look at them generally, and then, in a bit more detail. These language features are not independent of each other: one builds up on the other, and therefore, the explanation will first be general, and we will go into details in the subsections.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Understanding the algorithm and language constructs</h1>
            

            <article>
                
<p class="calibre2">The algorithm was explained at the start of the chapter. The implementation is in the <kbd class="calibre11">Sort</kbd> class inside the <kbd class="calibre11">sort</kbd> method, and it is only a few lines:</p>
<pre class="calibre20">
        int n = names.length; <br class="title-page-name"/>        while (n &gt; 1) { <br class="title-page-name"/>            for (int j = 0; j &lt; n - 1; j++) { <br class="title-page-name"/>                if (names[j].compareTo(names[j + 1]) &gt; 0) { <br class="title-page-name"/>                    final String tmp = names[j + 1]; <br class="title-page-name"/>                    names[j + 1] = names[j]; <br class="title-page-name"/>                    names[j] = tmp; <br class="title-page-name"/>                } <br class="title-page-name"/>            } <br class="title-page-name"/>            n--; <br class="title-page-name"/>        }
</pre>
<p class="calibre2">The <kbd class="calibre11">n</kbd> variable holds the length of the array at the start of the sorting. Arrays in Java always have a property that gives the length and it is called <kbd class="calibre11">length</kbd>. When we start the sorting, we will go from the start of the array to the end of it and, as you may recall, the last element, <em class="calibre12">Wilson</em>, will walk up to the last position during this first iteration. Subsequent iterations will be shorter and, therefore, the variable <kbd class="calibre11">n</kbd> will be decreased.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Blocks</h1>
            

            <article>
                
<p class="calibre2">The code in Java is created in code blocks. Anything that is between the <kbd class="calibre11">{</kbd> and <kbd class="calibre11">}</kbd> characters is a block. In the preceding example, the code of the method is a block. It contains commands, and some of them, like the <kbd class="calibre11">while</kbd> loop, also contain a block. Inside that block, there are two commands. One of them is a <kbd class="calibre11">for</kbd> loop, again with a block. Although we can have single expressions to form the body of a loop, we usually use blocks. We will discuss loops in detail in just a few pages.</p>
<p class="calibre2">As we could see in the preceding example, the loops can be nested, and thus the <kbd class="calibre11">{</kbd> and <kbd class="calibre11">}</kbd> characters form pairs. A block can be inside another block, but two blocks cannot overlap. When the code contains a <kbd class="calibre11">}</kbd> character, it is closing the block that was opened last.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Variables</h1>
            

            <article>
                
<p class="calibre2">In Java, just like in almost any programming language, we use variables. The variables in Java are typed. It means that a variable can hold a value of a single type. It is not possible for a variable to hold an <kbd class="calibre11">int</kbd> type at some point in the program and later a <kbd class="calibre11">String</kbd> type. When variables are declared, their type is written in front of the variable name.</p>
<p class="calibre2">Variables also have visibility scope. Local variables in methods can only be used inside the block in which they are defined. A variable can be used inside methods or they can belong to a class or an object. To differentiate the two, we usually call these variables <em class="calibre12">fields</em>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Types</h1>
            

            <article>
                
<p class="calibre2">Each variable has one type. In Java, there are two major groups of type: primitive and reference types. The primitive types are predefined, and you cannot define or create a new primitive type. There are eight primitive types: <kbd class="calibre11">byte</kbd>, <kbd class="calibre11">short</kbd>, <kbd class="calibre11">int</kbd>, <kbd class="calibre11">long</kbd>, <kbd class="calibre11">float</kbd>, <kbd class="calibre11">double</kbd>, <kbd class="calibre11">boolean</kbd>, and <kbd class="calibre11">char</kbd>.</p>
<p class="calibre2">The first four types, <kbd class="calibre11">byte</kbd>, <kbd class="calibre11">short</kbd>, <kbd class="calibre11">int</kbd>, and <kbd class="calibre11">long</kbd>, are signed numeric integer types, capable of storing positive and negative numbers on 8, 16, 32, and 64 bits.</p>
<p class="calibre2">The <kbd class="calibre11">float</kbd> and <kbd class="calibre11">double</kbd> types store floating point numbers on 32 and 64 bits in the <a class="calibre6">IEEE 754 floating-point format</a>.</p>
<p class="calibre2">The <kbd class="calibre11">boolean</kbd> type is a primitive type that can only be <kbd class="calibre11">true</kbd> or <kbd class="calibre11">false</kbd>.</p>
<p class="calibre2">The <kbd class="calibre11">char</kbd> type is a character data type that stores a single 16-bit Unicode character.</p>
<p class="calibre2">For each primitive type, there is a class that can store the same type of value. When a primitive type has to be converted to the matching class type it is done automatically. It is called auto boxing. These types are <kbd class="calibre11">Byte</kbd>, <kbd class="calibre11">Short</kbd>, <kbd class="calibre11">Integer</kbd>, <kbd class="calibre11">Long</kbd>, <kbd class="calibre11">Float</kbd>, <kbd class="calibre11">Double</kbd>, <kbd class="calibre11">Boolean</kbd>, and <kbd class="calibre11">Character</kbd>. Take, for example, the following variable declaration:</p>
<pre class="calibre20">
Integer a = 113;
</pre>
<p class="calibre2">This converts the value <kbd class="calibre11">113</kbd>, which is an <kbd class="calibre11">int</kbd> number, to an <kbd class="calibre11">Integer</kbd> object.</p>
<p class="calibre2">These types are part of the runtime, and also part of the language. Although there is no primitive counterpart of it, there is a very important and ubiquitous class that we have already used: <kbd class="calibre11">String</kbd>. A string contains characters.</p>
<p class="calibre2">The major differences between primitive types and objects are that primitive types cannot be used to invoke methods, but they consume less memory. The difference between the memory consumption and its consequences for speed is important in the case of arrays.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Arrays</h1>
            

            <article>
                
<p class="calibre2">Variables can be a primitive type according to their declaration, or they may hold a reference to an object. A special object type is an array. When a variable holds a reference to an array, then it can be indexed with the <kbd class="calibre11">[</kbd> and <kbd class="calibre11">]</kbd> characters, along with an integral value consisting of 0 or a positive value ranging to one less than the array's length, to access a certain element of the array. Multi-dimensional arrays are also supported by Java when an array has elements that are also arrays. Arrays are indexed from zero in Java. Under or over indexing is checked at runtime, and the result is an exception.</p>
<div class="packtinfobox">An exception is special condition that interrupts the normal execution flow and stops the execution of the code or jumps to the closest enclosing <kbd class="calibre22">catch</kbd> statement. We will discuss exceptions and how to handle them in the next chapter.</div>
<p class="calibre2">When a code has an array of a primitive type, the array contains many memory slots, each holding the value of the type. When the array has a reference type, in other words, when it is an array of objects, then the array elements are references to objects, each containing the type. In the case of <kbd class="calibre11">int</kbd> for example, each element of the array is 32-bit, which is 4 bytes. If the array is a type of <kbd class="calibre11">Integer</kbd>, then the elements are references to objects, pointers, so to say, which is usually 64-bit using 64-bit JVM and 32-bit on 32-bit JVM. In addition to that, there is an <kbd class="calibre11">Integer</kbd> object somewhere in memory that contains the 4-byte value and also an object header that may be as much as 24 bytes.</p>
<div class="packtinfobox">The actual size of the extra information needed to administer each object is not defined in the standard. It may be different on different implementations of the JVM. The actual coding, or even the optimization of the code in an environment, should not depend on the actual size. However, the developers should be aware that this overhead exists and is in the range of around 20 or so bytes for every object. Objects are expensive in terms of memory consumption.</div>
<p class="calibre2">Memory consumption is one issue, but there is something else. When the program works with a large amount of data and the work needs the consecutive elements of the array, then the CPU loads a chunk of memory into the processor cache. It means that the CPU can access elements of the array that are consecutively faster. If the array is of a primitive type, it is fast. If the array is of some class type, then the CPU has to access memory to get the actual value, which may be as much as 50 times slower.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Expressions</h1>
            

            <article>
                
<p class="calibre2">Expressions in Java are very much like in other programming languages. You can use the operators that may be similar from languages such as C or C++. They are as follows:</p>
<ul class="calibre14">
<li class="calibre15">Unary prefix and postfix increment operators (<kbd class="calibre11"> --</kbd> and <kbd class="calibre11">++</kbd> before and after a variable)</li>
<li class="calibre15">Unary sign (<kbd class="calibre11">+</kbd> and <kbd class="calibre11">-</kbd>) operators</li>
<li class="calibre15">Logical (<kbd class="calibre11">!</kbd>) and bitwise (<kbd class="calibre11">~</kbd>) negation</li>
<li class="calibre15">Multiplication (<kbd class="calibre11">*</kbd>), division (<kbd class="calibre11">/</kbd>), and modulo (<kbd class="calibre11">%</kbd>)</li>
<li class="calibre15">Addition and subtraction (<kbd class="calibre11">+</kbd> and - again, but this time as binary operators)</li>
<li class="calibre15">Shift operators move the values bitwise, and there is left (<kbd class="calibre11">&lt;&lt;</kbd>) and right (<kbd class="calibre11">&gt;&gt;</kbd>) shift and unsigned right shift (<kbd class="calibre11">&gt;&gt;&gt;</kbd>)</li>
<li class="calibre15">The comparing operators are <kbd class="calibre11">&lt;</kbd>, <kbd class="calibre11">&gt;</kbd>, <kbd class="calibre11">&lt;=</kbd>, <kbd class="calibre11">&gt;=</kbd>, <kbd class="calibre11">==</kbd>, <kbd class="calibre11">!=</kbd> and <kbd class="calibre11">instanceof</kbd> that result in <kbd class="calibre11">boolean</kbd> value</li>
<li class="calibre15">There are bitwise or (<kbd class="calibre11">|</kbd>), and (<kbd class="calibre11">&amp;</kbd>), exclusive or (<kbd class="calibre11">^</kbd>) operators, and similarly logical or (<kbd class="calibre11">||</kbd>), and (<kbd class="calibre11">&amp;&amp;</kbd>) operators</li>
</ul>
<p class="calibre2">When logical operators are evaluated, they are shortcut evaluated. It means the right-hand operand is evaluated only if the result cannot be identified from the result of the left operand.</p>
<p class="calibre2">The ternary operator is also similar to the one, like it is on C, selecting from one of the expressions based on some condition: <kbd class="calibre11">condition ? expression 1 : expression 2</kbd>. Usually, there is no problem with the ternary operator, but sometimes you have to be careful as there is a complex rule controlling the type conversions in case the two expressions are not of the same type. It's always better to have the two expressions be of the same type.</p>
<p class="calibre2">Finally, there is an assignment operator (<kbd class="calibre11">=</kbd>) that assigns the value of an expression to a variable. For each binary operator, there is an assignment version that combines <kbd class="calibre11">=</kbd> with a binary operator to perform an operation involving the right operand and assign the result to the left operand, which must be a variable. These are <kbd class="calibre11">+=</kbd>, <kbd class="calibre11">-=</kbd>, <kbd class="calibre11">*=</kbd>, <kbd class="calibre11">/=</kbd>, <kbd class="calibre11">%=</kbd>, <kbd class="calibre11">&amp;=</kbd>, <kbd class="calibre11">^=</kbd>, <kbd class="calibre11">|=</kbd>, <kbd class="calibre11">&lt;&lt;=</kbd>, <kbd class="calibre11">&gt;&gt;=</kbd>, and <kbd class="calibre11">&gt;&gt;&gt;=</kbd>.</p>
<p class="calibre2">The operators have precedence and can be overridden by parentheses, as usual.</p>
<p class="calibre2">An important part of expressions is invoking methods. Static methods can be invoked by the name of the class and the name of the method. For example, to calculate the sine of 1.22, we can write the following line:</p>
<pre class="calibre20">
double z = Math.sin(1.22);
</pre>
<p class="calibre2">Here, <kbd class="calibre11">Math</kbd> is the class from the package <kbd class="calibre11">java.lang</kbd>. The method <kbd class="calibre11">sin</kbd> is invoked without using any instance of <kbd class="calibre11">Math</kbd>. This method is <kbd class="calibre11">static</kbd>, and it is not likely that we will ever need any other implementation of it than the one provided in the class <kbd class="calibre11">Math</kbd>.</p>
<p class="calibre2">Non-static methods can be invoked using an instance and the name of the method with a dot separating the two. For example, take the following code line as an example:</p>
<pre class="calibre20">
System.out.println("Hello World");
</pre>
<p class="calibre2">The preceding code uses an instance of the class <kbd class="calibre11">PrintStream</kbd> that is readily available through a static field in the class <kbd class="calibre11">System</kbd>. This variable is called <kbd class="calibre11">out</kbd>, and when we write our code, we have to reference it as <kbd class="calibre11">System.out</kbd>. The method <kbd class="calibre11">println</kbd> is defined in the class <kbd class="calibre11">PrintStream</kbd> and we invoke it on the object referenced by the variable <kbd class="calibre11">out</kbd>. This example also shows that static fields can also be referenced through the name of the class and the field separated by a dot. Similarly, when we need to reference a non-static field, we can do it through an instance of the class.</p>
<p class="calibre2">Static methods defined in the same class from where it is invoked or inherited can be invoked without the class name. Invoking a non-static method defined in the same class or being inherited can be invoked without an instance. In this case, the instance is the current object the execution is in. This object is also available through the <a class="calibre6"><kbd class="calibre28">this</kbd> keyword</a>. Similarly, when we use a field of the same class where our code is, we simply use the name. In case of a static field, the class we are in by default. In the case of a non-static field, the instance is the object referenced by the <kbd class="calibre11">this</kbd> keyword.</p>
<p class="calibre2">You can also import a static method into your code using the <kbd class="calibre11">import</kbd><kbd class="calibre11">static</kbd> language feature, in which case you can invoke the method without the name of the class.</p>
<p class="calibre2">The arguments of the method calls are separated using commas. Methods and method argument passing is an important topic that we will mention in detail in a separate subsection.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Loops</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">for</kbd> loop inside the <kbd class="calibre11">while</kbd> loop will go through all the elements from the first (indexed with zero in Java) up till the last (indexed with <kbd class="calibre11">n-1</kbd>). Generally, the <kbd class="calibre11">for</kbd> loop has the same syntax as in C:</p>
<pre class="calibre20">
for( initial expression ; condition ; increment expression ) <br class="title-page-name"/>  block
</pre>
<p class="calibre2">First, the initial expression is evaluated. It may contain variable declaration, as in our example. The variable <kbd class="calibre11">j</kbd> in the preceding example is visible only inside the block of the loop. After this, the condition is evaluated, and after each execution of the block, the increment expression is executed. The loop repeats so long as the condition is true. If the condition is false right after the execution of the initial expression, the loop does not execute at all. The block is a list of commands separated by semicolons and enclosed between the <kbd class="calibre11">{</kbd> and <kbd class="calibre11">}</kbd> characters.</p>
<div class="packttip">Instead of <kbd class="calibre22">{</kbd> and <kbd class="calibre22">}</kbd>, enclosed block Java lets you use a single command following the head of the <kbd class="calibre22">for</kbd> loop. The same is true in the case of the <kbd class="calibre22">while</kbd> loop, and also for the <kbd class="calibre22">if...else</kbd> constructs. Practice shows that this is not something a professional should use. Professional code always uses curly braces, even when there is only a single command where the block is in place. This prevents the <a class="calibre25">dangling</a> <kbd class="calibre22">else</kbd> problem and generally makes the code more readable. This is similar to many C-like languages. Most of them allow a single command at these places, and professional programmers avoid using a single command in these languages for readability purposes.<br class="calibre23"/>
It is ironic that the only language that strictly requires the use of the <kbd class="calibre22">{</kbd> and <kbd class="calibre22">}</kbd> braces at these places is Perl—the one language infamous for unreadable code.</div>
<p class="calibre2">The loop in the <kbd class="calibre11">for (int j = 0; j &lt; n - 1; j++) {</kbd> sample starts from zero and goes to <kbd class="calibre11">n-2</kbd>. Writing <kbd class="calibre11">j &lt; n-1</kbd> is the same, in this case, as <kbd class="calibre11">j &lt;= n-2</kbd>. We will limit <kbd class="calibre11">j</kbd> to stop in the loop before the end of the section of the array, because we reach beyond the index <kbd class="calibre11">j</kbd> by one comparing and conditionally swapping the elements indexed by <kbd class="calibre11">j</kbd> and <kbd class="calibre11">j+1</kbd>. If we went one element further, we would try to access an element of the array that does not exist, and it would cause a runtime exception. Try and modify the loop condition to <kbd class="calibre11">j &lt; n</kbd> or <kbd class="calibre11">j &lt;= n-1</kbd> and you will get the following error message:</p>
<div class="packtfigure"><img class="alignnone3" src="../images/00035.jpeg"/></div>
<p class="calibre2">It is an important feature of Java that the runtime checks memory access and throws an exception in the case of bad array indexing. In the good old days, while coding in C, often, we faced unexplainable errors that stopped our code much later and at totally different code locations from where the real error was. Array index in C silently corrupted the memory. Java stops you as soon as you make a mistake. It follows the <em class="calibre12">fail-fast</em> approach that you also should use in your code. If something is wrong, the program should fail. No code should try to live with or overcome an error that comes from a coding error. Coding errors should be fixed before they cause even more damage.</p>
<p class="calibre2">There are also two more loop constructs in Java: the <kbd class="calibre11">while</kbd> loop and the <kbd class="calibre11">do</kbd> loop. The example contains a <kbd class="calibre11">while</kbd> loop: it is the outer loop that runs so long as there are at least two elements that may need swapping in the array:</p>
<pre class="calibre20">
while (n &gt; 1) {
</pre>
<p class="calibre2">The general syntax and semantics of the <kbd class="calibre11">while</kbd> loop is very simple, as seen here:</p>
<pre class="calibre20">
while ( condition ) block
</pre>
<p class="calibre2">Repeat the execution of the block so long as the condition is true. If the condition is not true at the very start of the loop, then do not execute the block at all. The <kbd class="calibre11">do</kbd> loop is also similar, but it checks the condition <em class="calibre12">after</em> each execution of the block:</p>
<pre class="calibre20">
do block while( condition );
</pre>
<p class="calibre2">For some reason, programmers rarely use <kbd class="calibre11">do</kbd> loops.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Conditional execution</h1>
            

            <article>
                
<p class="calibre2">The heart of the sort is the condition and the value swapping inside the loop.</p>
<pre class="calibre20">
                if (names[j].compareTo(names[j + 1]) &gt; 0) { <br class="title-page-name"/>                    final String tmp = names[j + 1]; <br class="title-page-name"/>                    names[j + 1] = names[j]; <br class="title-page-name"/>                    names[j] = tmp; <br class="title-page-name"/>                }
</pre>
<p class="calibre2">There is only one conditional command in Java, the <kbd class="calibre11">if</kbd> command. It has the following format:</p>
<pre class="calibre20">
if( condition ) block else block
</pre>
<p class="calibre2">The meaning of the code structure is quite straightforward. If the condition is true, then the first block is executed, otherwise, the second block is executed. The <kbd class="calibre11">else</kbd> keyword, along with the second block, is optional. If there is nothing to be executed in case that the condition is false, then there is no need for the else branch, just like in the example. If the array element indexed with <kbd class="calibre11">j</kbd> is later in the sort order than the element <kbd class="calibre11">j+1,</kbd> then we swap them, but if they are already in order, there is nothing to do with them.</p>
<p class="calibre2">To swap the two array elements, we will use a temporary variable named <kbd class="calibre11">tmp</kbd>. The type of this variable is <kbd class="calibre11">String</kbd>, and this variable is declared to be <kbd class="calibre11">final</kbd>. The <kbd class="calibre11">final</kbd> keyword has different meanings depending on where it is used in Java. This may be confusing for beginners unless you are warned about it, just like now. A <kbd class="calibre11">final</kbd> class or method is a totally different thing than a <kbd class="calibre11">final</kbd> field, which is again different than a <kbd class="calibre11">final</kbd> local variable.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Final variables</h1>
            

            <article>
                
<p class="calibre2">In our case, <kbd class="calibre11">tmp</kbd> is a <kbd class="calibre11">final</kbd> local variable. The scope of this variable is limited to the block following the <kbd class="calibre11">if</kbd> statement, and inside this block, this variable gets a value only once. The block is executed many times during the code execution, and each time the variable gets into scope, it gets a value. However, this value cannot be changed in the block. This may be a bit confusing. You can think about it as having a new <kbd class="calibre11">tmp</kbd> each time the block executes. The variable gets declared and has an undefined value and can get a value only once.</p>
<p class="calibre2">Final local variables do not need to get the value where they are declared. You can assign a value to a <kbd class="calibre11">final</kbd> variable some time later. It is important that there should not be a code execution that assigns a value to a <kbd class="calibre11">final</kbd> variable that was already assigned a value before. The compiler checks it and does not compile the code if there is a possibility of the reassignment of a <kbd class="calibre11">final</kbd> variable.</p>
<p class="calibre2">To declare a variable to be final is generally to ease readability of the code. When you see a variable in a code declared to be <kbd class="calibre11">final</kbd>, you can assume that the value of the variable will not change and the meaning of the variable will always be the same wherever it was used in the method. It will also help you avoid some bugs when you try to modify some <kbd class="calibre11">final</kbd> variables and the IDE will immediately complain about it. In such situations, it is likely to be a programming mistake that is discovered extremely early.</p>
<p class="calibre2">In principle, it is possible to write a program where all variables are <kbd class="calibre11">final</kbd>. It is generally a good practice to declare all <kbd class="calibre11">final</kbd> variables that can be declared to be <kbd class="calibre11">final</kbd> and, in case some variable may not be declared <kbd class="calibre11">final</kbd>, then try to find some way of coding the method a bit differently.</p>
<div class="packttip">If you need to introduce a new variable to do that, it probably means you were using one variable to store two different things. These things are of the same type and stored in the same variable at different times but, logically, they still are different things. Do not try to optimize the use of variables. Never use a variable because you already have a variable of the type in your code that is available. If it is logically a different thing, then declare a new variable.<br class="calibre23"/>
While coding, always prefer source code clarity and readability. In Java, especially, the Just In Time compiler will optimize all this for you.</div>
<p class="calibre2">Although we do not explicitly tend to use the <kbd class="calibre11">final</kbd> keyword on the argument list of a method, it is good practice to make sure that your methods compile and work if the arguments are declared <kbd class="calibre11">final</kbd>. Some experts, including me, believe that the method parameters should have been made final by default in the language. This is something that will not happen in any version of Java, so long as Java follows the backward compatibility philosophy.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Classes</h1>
            

            <article>
                
<p class="calibre2">Now that we have looked at the actual code lines and have understood how the algorithm works, let's look at the more global structures of the code that brings it together: classes and packages enclosing the methods.</p>
<p class="calibre2">Every file in a Java program defines a class. Any code in a Java program is inside a class. There is nothing like global variables or global functions as in C, Python, Go, or other languages. Java is totally object oriented.</p>
<p class="calibre2">There can be more than one class in a single file, but usually one file is one class. Later, we will see that there are inner classes when a class is inside another class, but, for now, we will put one class into one file.</p>
<div class="packttip">There are some features in the Java language that we do not use. When the language was created, these features seemed to be a good idea. CPU, memory, and other resources, including mediocre developers, were also more limited than today. Some of the features, perhaps, made more sense because of these environmental constraints. Sometimes, I will mention these. In the case of classes, you can put more than one class into a single file so long as only one is <kbd class="calibre22">public</kbd>. That is bad practice, and we will never do that.<br class="calibre23"/>
Java never obsoletes these features. It is a philosophy of Java to remain compatible with all previous versions. This philosophy is good for the already written, huge amount of legacy code. Java code written and tested with an old version will work in a newer environment. At the same time, those features lure beginners to a wrong style. For this reason, sometimes, I will not even mention these features. For example, here, I could say: <em class="calibre27">There is one class in a file.</em> This would not be absolutely correct. At the same time, it is more or less pointless to explain in great detail a feature that I recommend not to be used. Later, I may simply skip them and "lie". There are not too many of those features.</div>
<p class="calibre2">A class is defined using the <kbd class="calibre11">class</kbd> keyword and each class has to have a name. The name should be unique within the package (see the next section) and has to be the same as the name of the file. A class can implement an interface or extend another class, for which we will see an example later. A class can also be <kbd class="calibre11">abstract</kbd>, <kbd class="calibre11">final</kbd>, and <kbd class="calibre11">public</kbd>. These are defined with the appropriate keywords, as you will see in examples.</p>
<p class="calibre2">Our program has two classes. Both of them are <kbd class="calibre11">public</kbd>. The <kbd class="calibre11">public</kbd> classes are accessible from anywhere. Classes that are not <kbd class="calibre11">public</kbd> are visible only inside the package. Inner and nested classes can also be <kbd class="calibre11">private</kbd> visible only inside the top-level class defined on the file level.</p>
<p class="calibre2">Classes that contain a <kbd class="calibre11">main</kbd> method to be invoked by the Java environment should be <kbd class="calibre11">public</kbd>. That is because they are invoked by the JVM.</p>
<p class="calibre2">The class starts at the beginning of the file right after the package declaration and everything between the <kbd class="calibre11">{</kbd> and <kbd class="calibre11">}</kbd> characters belong to the class. The methods, fields, inner or nested classes, and so on are part of the class. Generally, curly braces denote some block in Java. This was invented in the C language, and many languages follow this notation. Class declaration is some block, methods are defined using some block, loops, and conditional commands use blocks.</p>
<p class="calibre2">When we use the classes, we will have to create instances of classes. These instances are objects. In other words, objects are created instantiating a class. To do that, the <kbd class="calibre11">new</kbd> keyword is used in Java. When the line <kbd class="calibre11">final Sort sorter = new Sort()</kbd>; is executed in the <kbd class="calibre11">App</kbd> class, it creates a new object instantiating the <kbd class="calibre11">Sort</kbd> class. We will also say that we created a new <kbd class="calibre11">Sort</kbd> object or that the type of the object is <kbd class="calibre11">Sort</kbd>. When a new object is created, a constructor of the object is invoked. A bit sloppy, I may say, that the constructor is a special <em class="calibre12">method</em> in the class that has the same name as the class itself and has no return value. That is because it <em class="calibre12">returns</em> the created object. To be precise, constructors are not methods. They are initializers and they do not return the new object. They work on the <em class="calibre12">not-ready-yet</em> object. When a constructor executing the object is not fully initialized, some of the final fields may not be initialized and the overall initialization still can fail if the constructor throws an exception. In our example, we do not have any constructor in the code. In such a case, Java creates a default constructor that accepts no argument and does not modify the already allocated but uninitialized object. If the Java code defines an initializer, then the Java compiler does not create a default one.</p>
<p class="calibre2">A class can have many constructors, each having different parameter list.</p>
<p class="calibre2">In addition to constructors Java classes can contain initializer blocks. They are blocks on the class level, the same level as the constructor and methods. The code in these blocks is compiled into the constructors and is executed when the constructor is executing.</p>
<p class="calibre2">It is also possible to initialize static fields in static initializer blocks. These are the blocks on the top level inside the class with the <kbd class="calibre11">static</kbd> keyword in front of them. They are executed only once when the class is loaded.</p>
<p class="calibre2">We named the classes in our example <kbd class="calibre11">App</kbd> and <kbd class="calibre11">Sort</kbd>. This is a convention in Java to name almost everything in CamelCase.</p>
<div class="packttip">CamelCase is when the words are written without spaces between them. The first word may start with lowercase or uppercase, and, to denote the start of the second and subsequent words, they start with uppercase. <kbd class="calibre22">ForExampleThisIsALongCamelCase</kbd> name.</div>
<p class="calibre2">Class names start with an uppercase letter. This is not a requirement of the language formally, but this is a convention that every programmer should follow. These coding conventions help you create code that is easier to understand by other programmers, and lead to easier maintenance. Static code analyzer tools, such as Checkstyle (<a href="http://checkstyle.sourceforge.net/" class="calibre6"><span>http://checkstyle.sourceforge.net/</span></a>), also check that the programmers follow the conventions.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Inner, nested, local, and anonymous classes</h1>
            

            <article>
                
<p class="calibre2">I have already mentioned inner and nested classes in the previous section. Now we look at them in bit more detail.</p>
<div class="packttip">The details of inner and nested classes at this point may be difficult. Don't feel ashamed if you do not understand this section fully. If it is too difficult, skip to the next section and read about packages and return here later. Nested, inner, and local classes are rarely used, though they have their roles and use in Java. Anonymous classes were very popular in GUI programming with the Swing user interface that allowed developers to create Java GUI applications. With Java 8 and the lambda feature, anonymous classes are not so important these days, and with the emerging JavaScript and browser technology, the Java GUI became less popular.</div>
<p class="calibre2">When a class is defined in a file on its own, it is called a top-level class. Classes that are inside another class are, obviously, not top-level classes. If they are defined inside a class on the same level as fields (variables that are not local to some method or other block), they are inner or nested classes. There are two differences between them. One is that nested classes have the <kbd class="calibre11">static</kbd> keyword before the <kbd class="calibre11">class</kbd> keyword at their definition, and inner classes don't.</p>
<p class="calibre2">The other difference is that instances of nested classes can exist without an instance of the surrounding class. Inner class instances always have a reference to an instance of the surrounding class.</p>
<p class="calibre2">Because inner class instances cannot exist without an instance of the surrounding class, their instance can only be created by providing an instance of the outer class. We will see no difference if the surrounding class instance is the actual <kbd class="calibre11">this</kbd> variable, but if we want to create an instance of an inner class from outside the surrounding class, then we have to provide an instance variable before the <kbd class="calibre11">new</kbd> keyword separated by a dot, just like if new were a method. For example, we could have a class named <kbd class="calibre11">TopLevel</kbd> that has a class named <kbd class="calibre11">InnerClass</kbd>, like in the following code snippet:</p>
<pre class="calibre20">
public class TopLevel { <br class="title-page-name"/><br class="title-page-name"/>    class InnerClass { } <br class="title-page-name"/>}
</pre>
<p class="calibre2">Then we can create an instance of the <kbd class="calibre11">InnerClass</kbd> from outside with only a <kbd class="calibre11">TopLevel</kbd> object, like in this snippet:</p>
<pre class="calibre20">
TopLevel tl = new TopLevel(); <br class="title-page-name"/>InnerClass ic = tl.new InnerClass();
</pre>
<p class="calibre2">As inner classes have an implicit reference to an instance of the enclosing class, the code inside the inner class can access the fields and the methods of the enclosing class.</p>
<p class="calibre2">Nested classes do not have an implicit reference to any instance of the enclosing class, and they may be instantiated with the <kbd class="calibre11">new</kbd> keyword without any reference to any instance of any other class. Because of that, they cannot access the fields of the enclosing class unless they are static fields.</p>
<p class="calibre2">Local classes are classes that are defined inside a method, constructor, or an initializer block. We will soon talk about initializer blocks and constructors. Local classes can be used inside the block where they are defined.</p>
<p class="calibre2">Anonymous classes are defined and instantiated in a single command. They are a short form of a nested, inner, or local class, and the instantiation of the class. Anonymous classes always implement an interface or extend a named class. The new keyword is followed by the name of the interface or the class with the argument list to the constructor between parentheses. The block that defines the body of the anonymous class stands immediately after the constructor call. In the case of extending an interface, the constructor can only be the one without argument. The anonymous class with no name cannot have its own constructors. In modern Java we usually use lambda instead of anonymous classes.</p>
<div class="packttip">Last but not least—well, actually, least I should mention that nested and inner classes can also be nested in deeper structures. Inner classes cannot contain nested classes, but nested classes can contain inner classes. Why? I have never met anyone who could reliably tell me the real reason. There is no architectural reason. It could be like that. Java does not permit that. However, it is not really interesting. If you happen to write code that has more than one level of class nesting then just stop doing it. Most probably you are doing something wrong.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Packages</h1>
            

            <article>
                
<p class="calibre2">Classes are organized into packages and the first code line in a file should specify the package that the class is in.</p>
<pre class="calibre20">
package packt.java9.by.example.stringsort;
</pre>
<p class="calibre2">If you do not specify the package, then the class will be in the <em class="calibre12">default</em> package. This should not be used, except in the simplest case when you want to try some code. With Java 9, you can use <kbd class="calibre11">jshell</kbd> for this purpose, so, as opposed to previous versions of Java, now the suggestion becomes very simple—never put any class in the default package.</p>
<p class="calibre2">The name of the packages is hierarchical. The parts of the names are separated by dots. Using package names helps you avoid name collisions. Names of the classes are usually kept short and putting them into packages helps the organization of the program. The full name of a class includes the name of the package the class is in. Usually, we will put those classes into a package that are in some way related, and add something to a similar aspect of a program. For example, controllers in an MVC pattern program are kept in a single package. Packages also help you avoid name collision of classes. However, this only pushes the problem from class name collision to package name collision. We have to make sure that the name of the package is unique and does not cause any problem when our code is used together with any other library. When an application is developed, we just cannot know what other libraries will be used in later versions. To be prepared for the unexpected, the convention is to name the packages according to some Internet domain names. When a development company has the domain name <kbd class="calibre11"><span>acmecompany.com</span></kbd>, then their software is usually under the <kbd class="calibre11">com.acmecompany...</kbd>  packages. It is not a strict language requirement. It is only a convention to write the domain name from right to left, and use it as package name, but this proves to be fairly good in practice. Sometimes, like I do in this book, one can deviate from this practice so you can see that this rule is not carved in stone.</p>
<p class="calibre2">When the rubber hits the road, and the code is compiled into byte code, the package becomes the name of the class. Thus, the full name of the <kbd class="calibre11">Sort</kbd> class is <kbd class="calibre11">packt.java9.by.example.stringsort.Sort</kbd>. When you use a class from another package, you can use this full name or import the class into your class. Again, this is on the language level. Using the fully qualified name or importing makes no difference when Java becomes byte code.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Methods</h1>
            

            <article>
                
<p class="calibre2">We have already discussed methods, but not in detail, and there are still some aspects that we should meet before we go on.</p>
<p class="calibre2">There are two methods in the sample classes. There can be many methods in a class. Method names are also camel cased by convention, and the name starts with a lowercase letter, as opposed to classes. Methods may return a value. If a method returns a value, the method has to declare the type of the value it returns and, in that case, any execution of the code has to finish with a <kbd class="calibre11">return</kbd> statement. The <kbd class="calibre11">return</kbd> statement has an expression after the keyword, which is evaluated when the method is executed and is returned by the method. It is good practice to have only one single return from a method but, in some simple cases, breaking that coding convention may be forgiven. The compiler checks the possible method execution paths, and it is a compile-time error if some of the paths do not return a value.</p>
<p class="calibre2">When a method does not return any value, it has to be declared to be <kbd class="calibre11">void</kbd>. This is a special type that means no value. Methods that are <kbd class="calibre11">void</kbd>, such as the <kbd class="calibre11">public static void main</kbd> method, may simply miss the return statement and just end. If there is a <kbd class="calibre11">return</kbd> statement, there is no place for any expression defining a return value after the <kbd class="calibre11">return</kbd> keyword. Again, this is a coding convention to not use the <kbd class="calibre11">return</kbd> statement in case of a method that does not return any value, but in some coding patterns, this may not be followed.</p>
<p class="calibre2">Methods can be <kbd class="calibre11">private</kbd>, <kbd class="calibre11">protected</kbd>, <kbd class="calibre11">public</kbd>, and <kbd class="calibre11">static</kbd>, and we will discuss their meaning later.</p>
<p class="calibre2">We have seen that the <kbd class="calibre11">main</kbd> method that was invoked when the program started is a <kbd class="calibre11">static</kbd> method. Such a method belongs to the class and can be invoked without having any instance of the class. Static methods are declared with the <kbd class="calibre11">static</kbd> modifier, and they cannot access any field or method that is not static.</p>
<p class="calibre2">In our example, the <kbd class="calibre11">sort</kbd> method is not static, but as it does not access any field and does not call any non-static method (as a matter of fact, it does not call any method at all), it could just as well be <kbd class="calibre11">static</kbd>. If we change the declaration of the method to <kbd class="calibre11">public static void sort(String[] names) {</kbd> (note the word <kbd class="calibre11">static</kbd>), the program still works, but the IDE will give a warning while editing, for example:</p>
<pre class="calibre20">
    <strong class="calibre1">Static member 'packt.java9.by.example.stringsort.Sort.sort(java.lang.String[])' accessed via instance reference</strong>
</pre>
<p class="calibre2">That is because you can access the method without an instance directly through the name of the <kbd class="calibre11">Sort.sort(actualNames);</kbd> class without the need of the <kbd class="calibre11">sorter</kbd> variable. Calling a static method via an instance variable is possible in Java (again something that seemed to be a good idea at the genesis of Java, but is probably not), but it may mislead the reader of the code into thinking that the method is an instance method.</p>
<p class="calibre2">Making the <kbd class="calibre11">sort</kbd> method <kbd class="calibre11">static</kbd>, the <kbd class="calibre11">main</kbd> method can be as follows:</p>
<pre class="calibre20">
public static void main(String[] args) { <br class="title-page-name"/>    String[] actualNames = new String[]{ <br class="title-page-name"/>            "Johnson", "Wilson", <br class="title-page-name"/>            "Wilkinson", "Abraham", "Dagobert" <br class="title-page-name"/>    }; <br class="title-page-name"/>    Sort.sort(actualNames); <br class="title-page-name"/>    for (final String name : actualNames) { <br class="title-page-name"/>        System.out.println(name); <br class="title-page-name"/>    } <br class="title-page-name"/>}
</pre>
<p class="calibre2">It seems to be much simpler (it is), and, in case the method does not use any field, you may think that there is no reason to make a method non-static. During the first ten years of Java, static methods were in heavy use. There is even a term, utility class, which means a class that has only static methods and should not be instantiated. With the advent of <strong class="calibre1">Inversion of Control</strong> containers, we tend to use less static methods. When static methods are used, it is harder to use <strong class="calibre1">dependency injection</strong>, and it is also more difficult to create tests. We will discuss these advanced topics in the next few chapters. For now, you are informed as to what static methods are and that they can be used; however, usually, unless there is a very special need for them, we will avoid them.</p>
<p class="calibre2">Later, we will look at how classes are implemented in the hierarchy, and how classes may implement interfaces and extend other classes. When these features are looked at, we will see that there are so-called abstract classes that may contain abstract methods. These methods have the  <kbd class="calibre11">abstract</kbd> modifier, and they are not defined—only the name, argument types (and names), and return type are specified. A concrete (non-abstract) class extending the abstract class should define them.</p>
<p class="calibre2">The opposite of abstract method is the final method declared with the <kbd class="calibre11">final</kbd> modifier. A <kbd class="calibre11">final</kbd> method cannot be overridden in subclasses.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Interfaces</h1>
            

            <article>
                
<p class="calibre2">Methods are also declared in interfaces. A method declared in an interface does not define the actual behavior of the method; they do not contain the code. They have only the head of the method; in other words, they are abstract implicitly. Although nobody does, you may even use the <kbd class="calibre11">abstract</kbd> keyword in an interface when you define a method.</p>
<p class="calibre2">Interfaces look very similar to classes, but instead of using the <kbd class="calibre11">class</kbd> keyword, we use the <kbd class="calibre11">interface</kbd> keyword. Because interfaces are mainly used to define methods, the methods are <kbd class="calibre11">public</kbd> if no modifier is used.</p>
<p class="calibre2">Interfaces can also define fields, but since interfaces cannot have instances (only implementing classes can have instances), these fields are all <kbd class="calibre11">static</kbd> and they also have to be <kbd class="calibre11">final</kbd>. This is the default for fields in interfaces, thus we do not need to write these if we defined fields in interfaces.</p>
<div class="packttip">It was a common practice to define only constants in some interfaces and then use these in classes. To do that, the easiest way was to implement the interface. Since these interfaces do not define any method, the implementation is nothing more than writing the implements keyword and the name of the interface into the header of the class declaration. This is bad practice because this way the interface becomes part of the public declaration of the class, although these constants are needed inside the class. If you need to define constants that are not local to a class but are used in many classes, then define them in a class and import the fields using <kbd class="calibre22">import static</kbd> or just use the name of the class and the field.</div>
<p class="calibre2">Interfaces can also have nested classes, but they cannot have inner classes. The obvious reason for that is that inner class instances have a reference to an instance of the enclosing class. In the case of an interface, there are no instances, so an inner class could not have a reference to an instance of an enclosing interface, because that just does not exist. The joyful part of it is that we do not need to use the <kbd class="calibre11">static</kbd> keyword in the case of nested classes because that is the default, just as in the case of fields.</p>
<p class="calibre2">With the advent of Java 8, you can also have <kbd class="calibre11">default</kbd> methods in interfaces that provide default implementation of the method for the classes that implement the interface. There can also be <kbd class="calibre11">static</kbd> and <kbd class="calibre11">private</kbd> methods in interfaces since Java 9.</p>
<p class="calibre2">Methods are identified by their name and the argument list. You can reuse a name for a method and have different argument types; Java will identify which method to use based on the types of the actual arguments. This is called <strong class="calibre1">method overloading</strong>. Usually, it is easy to tell which method you call, but when there are types that extend each other, the situation becomes more complex. The standard defines very precise rules for the actual selection of the method that the compiler follows, so there is no ambiguity. However, fellow programmers who read the code may misinterpret overloaded methods or, at least, will have hard time identifying which method is actually called. Method overloading may also hinder backward compatibility when you want to extend your class. The general advice is to think twice before creating overloaded methods. They are lucrative, but may sometimes be costly.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Argument passing</h1>
            

            <article>
                
<p class="calibre2">In Java, arguments are passed by value. When the method modifies an argument variable, then only the copy of the original value is modified. Any primitive value is copied during the method call. When an object is passed as an argument, then the copy of the reference to the object is passed.</p>
<p class="calibre2">That way, the object is available to be modified for the method. In the case of classes that have their primitive counterpart, and also in the case of <kbd class="calibre11">String</kbd> and some other class types, the objects simply do not provide methods or fields to modify the state. This is important for the integrity of the language, and to not get into trouble when objects and primitive values automatically get converted.</p>
<p class="calibre2">In other cases, when the object is modifiable, the method can effectively work on the very object it was passed to. This is also the way the <kbd class="calibre11">sort</kbd> method in our example works on the array. The same array, which is also an object itself, is modified.</p>
<p class="calibre2">This argument passing is much simpler than it is in other languages. Other languages let the developer mix the <em class="calibre12">pass by reference</em> and the <em class="calibre12">pass by value</em> argument passing. In Java, when you use a variable by itself as an expression to pass a parameter to a method, you can be sure that the variable itself is never modified. The object it refers to, however, in case it is mutable, may be modified.</p>
<div class="packttip">An object is mutable if it can be modified, altering the value of some of its field directly or via some method call. When a class is designed in a way that there is no normal way to modify the state of the object after the creation of the object, the object is immutable. The classes <kbd class="calibre22">Byte</kbd>, <kbd class="calibre22">Short</kbd>, <kbd class="calibre22">Integer</kbd>, <kbd class="calibre22">Long</kbd>, <kbd class="calibre22">Float</kbd>, <kbd class="calibre22">Double</kbd>, <kbd class="calibre22">Boolean</kbd>, <kbd class="calibre22">Character</kbd>, as well as <kbd class="calibre22">String</kbd>, are designed in the JDK so that the objects are immutable.<br class="calibre23"/>
It is possible to overcome the limitation of immutability implementation of certain classes using reflection, but doing that is hacking and not professional coding. Doing that can be done for one single purpose—getting a better knowledge and understanding of the inner workings of some Java classes, but nothing else.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Fields</h1>
            

            <article>
                
<p class="calibre2">Fields are variables on the class level. They represent the state of an object. They are variables, with defined type and possible initial value. Fields can be <kbd class="calibre11">static</kbd>, <kbd class="calibre11">final</kbd>, <kbd class="calibre11">transient</kbd>, and <kbd class="calibre11">volatile</kbd>, and the access may be modified with the <kbd class="calibre11">public</kbd>, <kbd class="calibre11">protected</kbd>, and <kbd class="calibre11">private</kbd> keywords.</p>
<p class="calibre2">Static fields belong to the class. It means that there is one of them shared by all the instances of the class. Normal, non-static fields belong to the objects. If you have a field named <kbd class="calibre11">f</kbd>, then each instance of the class has its own <kbd class="calibre11">f</kbd>. If <kbd class="calibre11">f</kbd> is declared <kbd class="calibre11">static</kbd>, then the instances will share the very same <kbd class="calibre11">f</kbd> field.</p>
<p class="calibre2">The <kbd class="calibre11">final</kbd> fields cannot be modified after they are initialized. Initialization can be done on the line where they are declared, in an initializer block or in the constructor code. The strict requirement is that the initialization has to happen before the constructor returns. This way, the meaning of the <kbd class="calibre11">final</kbd> keyword is very different, in this case, from what it means in the case of a class or a method. A <kbd class="calibre11">final</kbd> class cannot be extended and a <kbd class="calibre11">final</kbd> method cannot be overridden in an extending class, as we will see in the next chapter. The <kbd class="calibre11">final</kbd> fields are either uninitialized or get a value during instance creation. The compiler also checks that the code does initialize all <kbd class="calibre11">final</kbd> fields during the object-instance creation or during the class loading, in case the <kbd class="calibre11">final</kbd> field is <kbd class="calibre11">static</kbd>, and that the code is not accessing/reading any <kbd class="calibre11">final</kbd> field that was not yet initialized.</p>
<div class="packttip">It is a common misconception that the <kbd class="calibre22">final</kbd> fields have to be initialized at the declaration. It can be done in an initializer code or in a constructor. The restriction is that, no matter which constructor is called in case there are more, the <kbd class="calibre22">final</kbd> fields have to be initialized exactly once.</div>
<p class="calibre2">The <kbd class="calibre11">transient</kbd> fields are not part of the serialized state of the object. Serialization is an act of converting the actual value of an object to physical bytes. Deserialization is the opposite when the object is created from the bytes. It is used to save the state in some frameworks. The code that does the serialization, <kbd class="calibre11">java.lang.io.ObjectOutputStream</kbd>, works only with classes that implement the <kbd class="calibre11">Serializable</kbd> interface, and uses only the fields from those objects that are not <kbd class="calibre11">transient</kbd>. Very obviously, <kbd class="calibre11">transient</kbd> fields are also not restored from the bytes that represent the serialized form of the object because their value is not there.</p>
<p class="calibre2">Serialization is usually used in distributed programs. A good example is the session object of a servlet. When the servlet container runs on a clustered node, some fields of objects stored into the session object may magically disappear between HTTP hits. That is because serialization saves and reloads the session to move the session between the nodes. Serialization, in such a situation, may also be a performance issue if a developer does not know the side effects of the  stored large objects in the session.</p>
<p class="calibre2">The <kbd class="calibre11">volatile</kbd> keyword is a keyword that tells the compiler that the field may be used by different threads. When a <kbd class="calibre11">volatile</kbd> field is accessed by any code, the JIT compiler generates code which ensures that the value of the field accessed is up to date. When a field is not volatile, the compiler-generated code may store the value of the field in a processor cache or registry for faster access when it sees that the value will be needed soon by some subsequent code fragment. In the case of <kbd class="calibre11">volatile</kbd> fields, this optimization cannot be done. Additionally, note that saving the value to memory and loading from there all the time may be 50 or more times slower than accessing a value from a registry or cache.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Modifiers</h1>
            

            <article>
                
<p class="calibre2">Methods, constructors, fields, interfaces, and classes can have access modifiers. The general rule is that in case there is no modifier, the scope of the method, constructor, and so on, is the package. Any code in the same package can access it.</p>
<p class="calibre2">When the <kbd class="calibre11">private</kbd> modifier is used, the scope is restricted to the so-called compilation unit. This means the class that is in one file. What is inside one file can see and use anything declared to be <kbd class="calibre11">private</kbd>. This way, inner and nested classes can have access to each other's <kbd class="calibre11">private</kbd> variables, which may not really be a good programming style, but Java permits that.</p>
<p class="calibre2">The opposite of <kbd class="calibre11">private</kbd> is <kbd class="calibre11">public</kbd>. It extends the visibility to the whole Java program, or at least to the whole module, if the project is a Java 9 module.</p>
<p class="calibre2">There is a middle way: <kbd class="calibre11">protected</kbd>. Anything with this modifier is accessible inside the package and also in classes that extend the class (regardless of package) that the protected method, field, and so on, is in.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Object initializers and constructors</h1>
            

            <article>
                
<p class="calibre2">When an object is instantiated, the appropriate constructor is called. The constructor declaration looks like a method with the following deviation: the constructor does not have a return value. That is because the constructors work on the not-fully-ready instance when the <kbd class="calibre11">new</kbd> command operator is invoked and does not return anything. Constructors, having the same name as the class, cannot be distinguished from each other. If there is a need for more than one constructor, they have to be overloaded. Constructors, thus, can call each other, almost as if they were <kbd class="calibre11">void</kbd> methods with different arguments. However, there is a restriction—when a constructor calls another, it has to be the very first instruction in the constructor. You use <kbd class="calibre11">this()</kbd> syntax with an appropriate argument list, which may be empty, to invoke a constructor from another constructor.</p>
<p class="calibre2">The initialization of the object instance also executes initializer blocks. These are blocks containing executable code inside the <kbd class="calibre11">{</kbd> and <kbd class="calibre11">}</kbd> characters outside the methods and constructors. They are executed before the constructor in the order they appear in the code, together with the initialization of the fields in case their declarations contain value initialization.</p>
<p class="calibre2">If you see the <kbd class="calibre11">static</kbd> keyword in front of an initializer block, the block belongs to the class and is executed when the class is loaded along with the static field initializers.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Compiling and running the program</h1>
            

            <article>
                
<p class="calibre2">Finally, we will compile and execute our program from the command line. There is nothing new in this one; we will only apply what we have learned in this chapter using the following two commands:</p>
<pre class="calibre20">
    <strong class="calibre1">$ mvn package</strong>
</pre>
<p class="calibre2">This compiles the program, packages the result into a JAR file, and finally executes the following command:</p>
<pre class="calibre20">
    <strong class="calibre1">$ java -cp target/SortTutorial-1.0.0-SNAPSHOT.jar packt.java9.by.example.App</strong>
</pre>
<p class="calibre2">This will print the following result on the command line:</p>
<div class="packtfigure"><strong class="calibre1"><img class="alignnone4" src="../images/00036.jpeg"/></strong></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we have developed a very basic sort algorithm. It was made purposefully simple so that we could reiterate the basic and most important Java language elements, classes, packages, variables, methods, and so on. We also looked at build tools, so we are not empty handed in the next chapters when projects will contain more than just two files. We will use Maven and Gradle in the following chapters.</p>
<p class="calibre2">In the very next chapter, we will make the sort program more complex, implementing more effective algorithms and also making our code flexible, giving us the opportunity to learn more advanced Java language features.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>