["```java\n import com.google.common.collect.ImmutableList;\n import io.reactivex.Observable;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\")\n                 .collect(ImmutableList::builder, ImmutableList.Builder::add)\n                 .map(ImmutableList.Builder::build)\n                 .subscribe(System.out::println);\n\n         Observable.range(1,15)\n                 .collect(ImmutableList::builder, ImmutableList.Builder::add)\n                 .map(ImmutableList.Builder::build)\n                 .subscribe(System.out::println);\n     }\n }\n```", "```java\n[Alpha, Beta, Gamma, Delta, Epsilon]\n [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n```", "```java\ncollect(ImmutableList::builder, ImmutableList.Builder::add)\n     .map(ImmutableList.Builder::build)\n```", "```java\npublic static <T> ObservableTransformer<T, ImmutableList<T>> toImmutableList() {\n\n     return new ObservableTransformer<T, ImmutableList<T>>() {\n         @Override\n         public ObservableSource<ImmutableList<T>> apply(Observable<T> upstream) {\n             return upstream.collect(ImmutableList::<T>builder, ImmutableList.Builder::add)\n                     .map(ImmutableList.Builder::build)\n                     .toObservable(); *// must turn Single into Observable*\n         }\n     };\n }\n```", "```java\npublic static <T> ObservableTransformer<T, ImmutableList<T>> toImmutableList() {\n\n     return  upstream -> upstream.collect(ImmutableList::<T>builder, ImmutableList.Builder::add)\n                 .map(ImmutableList.Builder::build)\n                 .toObservable(); *// must turn Single into Observable*\n }\n```", "```java\n import com.google.common.collect.ImmutableList;\n import io.reactivex.Observable;\n import io.reactivex.ObservableTransformer;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\")\n                 .compose(toImmutableList())\n                 .subscribe(System.out::println);\n\n         Observable.range(1,10)\n                 .compose(toImmutableList())\n                 .subscribe(System.out::println);\n     }\n\n     public static <T> ObservableTransformer<T, ImmutableList<T>> toImmutableList() {\n\n         return  upstream -> upstream.collect(ImmutableList::<T>builder, ImmutableList.Builder::add)\n                     .map(ImmutableList.Builder::build)\n                     .toObservable(); *// must turn Single into Observable*\n     }\n }\n```", "```java\n[Alpha, Beta, Gamma, Delta, Epsilon]\n [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```", "```java\n import io.reactivex.Observable;\n import io.reactivex.ObservableTransformer;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\")\n                 .compose(joinToString(\"/\"))\n                 .subscribe(System.out::println);\n     }\n\n     public static ObservableTransformer<String, String> joinToString(String separator) {\n         return  upstream -> upstream\n                 .collect(StringBuilder::new, (b,s) ->  {\n                     if (b.length() == 0)\n                         b.append(s);\n                     else\n                         b.append(separator).append(s);\n                 })\n                 .map(StringBuilder::toString)\n                 .toObservable();\n     }\n }\n```", "```java\nAlpha/Beta/Gamma/Delta/Epsilon\n```", "```java\n import com.google.common.collect.ImmutableList;\n import io.reactivex.Flowable;\n import io.reactivex.FlowableTransformer;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Flowable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\")\n                 .compose(toImmutableList())\n                 .subscribe(System.out::println);\n\n         Flowable.range(1,10)\n                 .compose(toImmutableList())\n                 .subscribe(System.out::println);\n     }\n\n     public static <T> FlowableTransformer<T, ImmutableList<T>> toImmutableList() {\n\n         return  upstream -> upstream.collect(ImmutableList::<T>builder, ImmutableList.Builder::add)\n                 .map(ImmutableList.Builder::build)\n                 .toFlowable(); *// must turn Single into Flowable*\n     }\n }\n```", "```java\n static final class IndexedValue<T> {\n     final int index;\n     final T value;\n\n     IndexedValue(int index, T value) {\n         this.index = index;\n         this.value = value;\n     }\n\n     @Override\n     public String toString() {\n         return  index + \" - \" + value;\n     }\n }\n```", "```java\nstatic <T> ObservableTransformer<T,IndexedValue<T>> withIndex() {\n     final AtomicInteger indexer = new AtomicInteger(-1);\n     return upstream -> upstream.map(v -> new IndexedValue<T>(indexer.incrementAndGet(), v));\n }\n```", "```java\n import io.reactivex.Observable;\n import io.reactivex.ObservableTransformer;\n import java.util.concurrent.atomic.AtomicInteger;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Observable<IndexedValue<String>> indexedStrings =\n                 Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\")\n                     .compose(withIndex());\n\n         indexedStrings.subscribe(v -> System.out.println(\"Subscriber 1: \" + v));\n         indexedStrings.subscribe(v -> System.out.println(\"Subscriber 2: \" + v));\n     }\n\n     static <T> ObservableTransformer<T,IndexedValue<T>> withIndex() {\n         final AtomicInteger indexer = new AtomicInteger(-1);\n         return upstream -> upstream.map(v -> new IndexedValue<T>(indexer.incrementAndGet(), v));\n     }\n\n     static final class IndexedValue<T> {\n         final int index;\n         final T value;\n\n         IndexedValue(int index, T value) {\n             this.index = index;\n             this.value = value;\n         }\n\n         @Override\n         public String toString() {\n             return  index + \" - \" + value;\n         }\n     }\n }\n```", "```java\n Subscriber 1: 0 - Alpha\n Subscriber 1: 1 - Beta\n Subscriber 1: 2 - Gamma\n Subscriber 1: 3 - Delta\n Subscriber 1: 4 - Epsilon\n Subscriber 2: 5 - Alpha\n Subscriber 2: 6 - Beta\n Subscriber 2: 7 - Gamma\n Subscriber 2: 8 - Delta\n Subscriber 2: 9 - Epsilon\n```", "```java\nstatic <T> ObservableTransformer<T,IndexedValue<T>> withIndex() {\n     return upstream -> Observable.defer(() -> {\n         AtomicInteger indexer = new AtomicInteger(-1);\n         return upstream.map(v -> new IndexedValue<T>(indexer.incrementAndGet(), v));\n     });\n }\n```", "```java\n static <T> ObservableTransformer<T,IndexedValue<T>> withIndex() {\n     return upstream ->\n             Observable.zip(upstream,\n                     Observable.range(0,Integer.MAX_VALUE),\n                     (v,i) -> new IndexedValue<T>(i, v)\n             );\n }\n```", "```java\n import io.reactivex.Observable;\n import io.reactivex.rxjavafx.observers.JavaFxObserver;\n import io.reactivex.rxjavafx.schedulers.JavaFxScheduler;\n import javafx.application.Application;\n import javafx.beans.binding.Binding;\n import javafx.scene.Scene;\n import javafx.scene.control.Label;\n import javafx.scene.layout.VBox;\n import javafx.stage.Stage;\n\n import java.util.concurrent.TimeUnit;\n\n public final class JavaFxApp extends Application {\n\n     @Override\n     public void start(Stage stage) throws Exception {\n\n         VBox root = new VBox();\n         Label label = new Label(\"\");\n\n         *// Observable with second timer*\n         Observable<String> seconds =\n                 Observable.interval(1, TimeUnit.SECONDS)\n                         .map(i -> i.toString())\n                         .observeOn(JavaFxScheduler.platform());\n\n         *// Turn Observable into Binding*\n         Binding<String> binding = JavaFxObserver.toBinding(seconds);\n\n         *//Bind Label to Binding*\n         label.textProperty().bind(binding);\n\n         root.setMinSize(200, 100);\n         root.getChildren().addAll(label);\n\n         Scene scene = new Scene(root);\n         stage.setScene(scene);\n         stage.show();\n     }\n }\n```", "```java\n import io.reactivex.Observable;\n import io.reactivex.rxjavafx.observers.JavaFxObserver;\n import io.reactivex.rxjavafx.schedulers.JavaFxScheduler;\n import javafx.application.Application;\n import javafx.beans.binding.Binding;\n import javafx.scene.Scene;\n import javafx.scene.control.Label;\n import javafx.scene.layout.VBox;\n import javafx.stage.Stage;\n import java.util.concurrent.TimeUnit;\n\n public final class JavaFxApp extends Application {\n\n     @Override\n     public void start(Stage stage) throws Exception {\n\n         VBox root = new VBox();\n         Label label = new Label(\"\");\n\n         *// Turn Observable into Binding*\n         Binding<String> binding =\n                 Observable.interval(1, TimeUnit.SECONDS)\n                         .map(i -> i.toString())\n                         .observeOn(JavaFxScheduler.platform())\n                         .to(JavaFxObserver::toBinding);\n\n         *//Bind Label to Binding*\n         label.textProperty().bind(binding);\n\n         root.setMinSize(200, 100);\n         root.getChildren().addAll(label);\n\n         Scene scene = new Scene(root);\n         stage.setScene(scene);\n         stage.show();\n     }\n }\n```", "```java\n import io.reactivex.Observable;\n import io.reactivex.ObservableOperator;\n import io.reactivex.Observer;\n import io.reactivex.functions.Action;\n import io.reactivex.observers.DisposableObserver;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Observable.range(1, 5)\n                 .lift(doOnEmpty(() -> System.out.println(\"Operation 1 Empty!\")))\n                 .subscribe(v -> System.out.println(\"Operation 1: \" + v));\n\n         Observable.<Integer>empty()\n                 .lift(doOnEmpty(() -> System.out.println(\"Operation 2 Empty!\")))\n                 .subscribe(v -> System.out.println(\"Operation 2: \" + v));\n     }\n\n     public static <T> ObservableOperator<T,T> doOnEmpty(Action action) {\n         return new ObservableOperator<T, T>() {\n\n             @Override\n             public Observer<? super T> apply(Observer<? super T> observer) throws Exception {\n                 return new DisposableObserver<T>() {\n                     boolean isEmpty = true;\n\n                     @Override\n                     public void onNext(T value) {\n                         isEmpty = false;\n                         observer.onNext(value);\n                     }\n\n                     @Override\n                     public void onError(Throwable t) {\n                         observer.onError(t);\n                     }\n\n                     @Override\n                     public void onComplete() {\n                         if (isEmpty) {\n                             try {\n                                 action.run();\n                             } catch (Exception e) {\n                                 onError(e);\n                                 return;\n                             }\n                         }\n                         observer.onComplete();\n                     }\n                 };\n             }\n         };\n     }\n }\n```", "```java\n Operation 1: 1\n Operation 1: 2\n Operation 1: 3\n Operation 1: 4\n Operation 1: 5\n Operation 2 Empty!\n```", "```java\n public static <T> ObservableOperator<T,T> doOnEmpty(Action action) {\n     return observer -> new DisposableObserver<T>() {\n         boolean isEmpty = true;\n\n         @Override\n         public void onNext(T value) {\n             isEmpty = false;\n             observer.onNext(value);\n         }\n\n         @Override\n         public void onError(Throwable t) {\n             observer.onError(t);\n         }\n\n         @Override\n         public void onComplete() {\n             if (isEmpty) {\n                 try {\n                     action.run();\n                 } catch (Exception e) {\n                     onError(e);\n                     return;\n                 }\n             }\n             observer.onComplete();\n         }\n     };\n }\n```", "```java\n import io.reactivex.Observable;\n import io.reactivex.ObservableOperator;\n import io.reactivex.observers.DisposableObserver;\n import java.util.ArrayList;\n import java.util.List;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Observable.range(1, 5)\n                 .lift(myToList())\n                 .subscribe(v -> System.out.println(\"Operation 1: \" + v));\n\n         Observable.<Integer>empty()\n                 .lift(myToList())\n                 .subscribe(v -> System.out.println(\"Operation 2: \" + v));\n     }\n\n     public static <T> ObservableOperator<List<T>,T> myToList() {\n         return observer -> new DisposableObserver<T>() {\n\n             ArrayList<T> list = new ArrayList<>();\n\n             @Override\n             public void onNext(T value) {\n                 *//add to List, but don't pass anything downstream*\n                 list.add(value);\n             }\n\n             @Override\n             public void onError(Throwable t) {\n                 observer.onError(t);\n             }\n\n             @Override\n             public void onComplete() {\n                 observer.onNext(list); *//push List downstream*\n                 observer.onComplete();\n             }\n         };\n     }\n }\n```", "```java\n Operation 1: [1, 2, 3, 4, 5]\n Operation 2: []\n```", "```java\n import io.reactivex.Flowable;\n import io.reactivex.FlowableOperator;\n import io.reactivex.functions.Action;\n import io.reactivex.subscribers.DisposableSubscriber;\n import org.reactivestreams.Subscriber;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Flowable.range(1, 5)\n                 .lift(doOnEmpty(() -> System.out.println(\"Operation 1 Empty!\")))\n                 .subscribe(v -> System.out.println(\"Operation 1: \" + v));\n\n         Flowable.<Integer>empty()\n                 .lift(doOnEmpty(() -> System.out.println(\"Operation 2 Empty!\")))\n                 .subscribe(v -> System.out.println(\"Operation 2: \" + v));\n     }\n\n     public static <T> FlowableOperator<T,T> doOnEmpty(Action action) {\n         return new FlowableOperator<T, T>() {\n             @Override\n             public Subscriber<? super T> apply(Subscriber<? super T> subscriber) throws Exception {\n                 return new DisposableSubscriber<T>() {\n                     boolean isEmpty = true;\n\n                     @Override\n                     public void onNext(T value) {\n                         isEmpty = false;\n                         subscriber.onNext(value);\n                     }\n\n                     @Override\n                     public void onError(Throwable t) {\n                         subscriber.onError(t);\n                     }\n\n                     @Override\n                     public void onComplete() {\n                         if (isEmpty) {\n                             try {\n                                 action.run();\n                             } catch (Exception e) {\n                                 onError(e);\n                                 return;\n                             }\n                         }\n                         subscriber.onComplete();\n                     }\n                 };\n             }\n         };\n     }\n }\n```", "```java\n public static <T> FlowableOperator<T,T> doOnEmpty(Action action) {\n     return subscriber -> new DisposableSubscriber<T>() {\n         boolean isEmpty = true;\n\n         @Override\n         public void onNext(T value) {\n             isEmpty = false;\n             subscriber.onNext(value);\n         }\n\n         @Override\n         public void onError(Throwable t) {\n             subscriber.onError(t);\n         }\n\n         @Override\n         public void onComplete() {\n             if (isEmpty) {\n                 try {\n                     action.run();\n                 } catch (Exception e) {\n                     onError(e);\n                     return;\n                 }\n             }\n             subscriber.onComplete();\n         }\n     };\n }\n```", "```java\n import io.reactivex.Observable;\n import io.reactivex.SingleTransformer;\n import java.util.Collection;\n import java.util.Collections;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n         Observable.just(\"Alpha\",\"Beta\",\"Gamma\",\"Delta\",\"Epsilon\")\n                 .toList()\n                 .compose(toUnmodifiable())\n                 .subscribe(System.out::println);\n     }\n\n     public static <T>  SingleTransformer<Collection<T>, Collection<T>> toUnmodifiable() {\n         return singleObserver -> singleObserver.map(Collections::unmodifiableCollection);\n     }\n }\n```", "```java\n[Alpha, Beta, Gamma, Delta, Epsilon]\n```", "```java\n import com.github.davidmoten.rx2.flowable.Transformers;\n import io.reactivex.Flowable;\n\n public class Launcher {\n\n     public static void main(String[] args) {\n\n         Flowable.just(\"Alpha\",\"Beta\",\"Zeta\",\"Gamma\",\"Delta\",\"Theta\",\"Epsilon\")\n                 .compose(Transformers.toListWhile((list,next) ->\n                     list.size() == 0 || list.get(0).length() == next.length()\n                 )).subscribe(System.out::println);\n     }\n }\n```", "```java\n [Alpha]\n [Beta, Zeta]\n [Gamma, Delta, Theta]\n [Epsilon]\n```"]