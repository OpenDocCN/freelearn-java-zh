- en: Scripting Using Oracle Nashorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the jjs command-line tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding the Oracle Nashorn engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking Java from Oracle Nashorn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ES6 features implemented in Oracle Nashorn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle Nashorn is the JavaScript engine developed for the Java platform. This
    was introduced in Java 8\. Prior to Nashorn, the JavaScript engine for the Java
    platform was based on the Mozilla Rhino JavaScript engine. The Oracle Nashorn
    engine leverages the `invokedynamic` support introduced in Java 8 for better runtime
    performance, and also provides better compliance with the ECMAScript specification.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Nashorn supports JavaScript code execution in a standalone mode using
    the `jjs` tool, as well as embedded in Java using its embedded scripting engine.
    In this chapter, we will look at executing the JavaScript code from Java and invoking
    the JavaScript function from Java, and vice versa, including accessing Java types
    from JavaScript. We will also look at using the command-line tool, `jjs`, for
    executing the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the rest of the chapter, we will use the term ES6 to refer to ECMAScript
    6.
  prefs: []
  type: TYPE_NORMAL
- en: Using the jjs command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `jjs` command-line tool supports the execution of JavaScript code files
    as well as an interactive execution of JavaScript code snippets, as supported
    by other JavaScript shells, such as `node.js`. It uses Oracle Nashorn, a next
    generation JavaScript engine for JVM to provide this support. In addition to the
    JavaScript code, `jjs` supports the execution of shell commands, thereby allowing
    us to create shell script utilities in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at executing JavaScript code files via `jjs`, as
    well as the interactive execution of code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, verify whether the `jjs` tool is available by issuing the command, `jjs
    -version`. This will print the version as `nashorn 9-ea` and enter it into the
    shell, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/357afdd6-cf90-45b6-80e2-ff4762151532.png)'
  prefs: []
  type: TYPE_IMG
- en: We can even get more specific version information using `jjs -fv`, which prints
    the version as `nashorn full version 9-ea+169`.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code files used in this recipe are available at the location, `chp14/1_jjs_demo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use `jjs` to execute the script, `$ jjs hellojjs.js`, which gives this
    output: `Hello via JJS using Nashorn`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now try this with ECMAScript 6 features of using `Set`, `Map`, and template
    strings. A template string supports building a `String` with placeholders for
    dynamic values. A placeholder is identified by `${variable}` and the complete
    `String` is embedded within [PRE0]. We run this script using the `jjs --language=es6
    using_map_set_demo.js` command. By default, `jjs` runs in `es5` mode and we enable
    it to run in `es6` by giving this option, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dcf1cc89-2120-4397-92c6-ceceb2f9594a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s use the `jjs` tool interactively. Run `$ jjs --language=es6` on
    the Command Prompt to launch the shell and execute a few JavaScript code snippets,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be printed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45733591-96d6-4e2a-b43e-e339ed909291.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The shell scripting mode can be enabled in `jjs` using the `-scripting` command.
    So, one can embed Shell/Batch commands within the JavaScript code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using ES5 as the language for `jjs`, then you can replace `$EXEC("dir")`
    with `` `dir` ``. But in ES6, [PRE3] are used for representing template strings.
    The preceding script can be executed using `jjs`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are two more variables available, `$ARG` and `$ENV`, which can be used
    to access the arguments passed to the script and the environment variables, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding the Oracle Nashorn engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at embedding the Nashorn JavaScript engine in the
    Java code and execute different JavaScript code snippets, functions, and JavaScript
    source files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have JDK 9 installed, as we will be using a few ES6 JavaScript language
    features with the Nashorn engine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we get an instance of `ScriptEngine` with the ES6 language features
    enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a JavaScript function to find the sum of two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s invoke the function defined in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will look at the template string support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the new `Set` construct in ES6 and the new `for` loop to print
    the `Set` elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will look at loading the JavaScript source file and executing the
    methods defined in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this can be found at the location, `chp14/2_embedded_nashorn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output after executing the sample will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Invoking Java from Oracle Nashorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at calling Java APIs from the JavaScript code,
    including using the Java types, and dealing with package and class imports. There
    is a greater potential in combining the vastness of the Java API and the dynamic
    nature of JavaScript leveraged by the Oracle Nashorn JavaScript engine. We will
    look at creating a purely JavaScript code, which uses the Java APIs, and we'll
    use the `jjs` tool to execute this.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at creating a Swing-based application purely in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `List` of numbers using the `Arrays.asList` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compute the maximum number in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print `max` using the JavaScript `print()` method, and we can use template
    strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the script created using `jjs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s import the `java.util` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the imported package to print today''s date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an alias for a Java type using the `Java.type` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the alias to create a set, add a few elements, and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code for this script file can be found at the location, `chp14/3_java_from_nashorn/java_from_javascript.js`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java types and their APIs can be accessed from the JavaScript code by using
    their fully qualified name, as we saw in the previous section while creating the
    list of numbers using `java.util.Arrays.asList()` and finding the maximum using
    `java.util.Collections.max()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to skip specifying the package name along with the class name, we
    can make use of `JavaImporter` to import the packages and use the `with` clause
    to wrap the code, which uses the classes from the imported package within it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The other feature we saw was creating a type alias for the Java type by using
    `Java.type(<fully qualified class name>)`, as done in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The type has to be an implementation class if you are creating objects using
    the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a script to create a simple Swing GUI with a button and an event
    handler for the button. We will also look at how we leverage imports and implement
    interfaces using an anonymous inner class approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a new `JavaImporter` object with the required Java packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `with(obj){}` clause to wrap all the statements using the required
    imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create `JButton` and provide `ActionListener` to listen to its click
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create `JFrame` to render the GUI with its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code for this can be found in `chp14/3_java_from_nashorn/gui_from_javascript.js`.Let''s
    run the script using `jjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see a small GUI, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/283e7780-2ed0-4ea4-9f9b-d1423184e371.png)'
  prefs: []
  type: TYPE_IMG
- en: To exit the program, we will have to use *Ctrl* + *C* to stop the process because
    `setDefaultCloseOperation` works when running in Java. The other option is to
    override the JFrame's `close` operation to exit from the program.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ES6 features implemented in Oracle Nashorn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at some of the ES6 features implemented in the
    Oracle Nashorn JavaScript engine. For this, we will create a JavaScript file and
    use `jjs` to execute the same. Remember to use `jjs` in the ES6 mode, which can
    be enabled by passing the `--language=es6` command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template strings are strings with variable placeholders, thereby allowing the
    creation of dynamic texts. The strings have to be embedded within the symbols
    [PRE29]:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Any variable in JavaScript has a global scope. ES6 introduced the block scope,
    which can be declared using the `let` keyword. Constants can now be defined using
    the `const` keyword, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the new iteration construct, `for ... of`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at creating sets and maps using the new `Set` and `Map` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at arrow functions. These are similar to the lambda expression
    concept that we have from Java 8 onward. Arrow functions are of the form, `(parameters
    ) => {function body }`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code for this can be found in the file, `chp14/4_es6_features/es6_features.js`.
    The output after executing the complete script using the `jjs --language=es6 es6_features.js` command
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/637b5b67-8cbe-4371-9dbe-e91ae0009c5a.png)'
  prefs: []
  type: TYPE_IMG
