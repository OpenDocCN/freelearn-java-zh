- en: Chapter 12. Long-term Tasks' Execution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。长期任务执行
- en: So far, our applications focused on interaction with the user. This may be the
    most important aspect of your future projects, but there are some scenarios that
    require a different approach. Maintenance tasks, importing big sets of data or
    time-consuming computations are usually addressed in a batch mode instead of an
    interactive manner. Often, these kinds of jobs are not part of the standard operations
    and should be invoked only when the server load is at its lowest or periodical.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序专注于与用户的交互。这可能是你未来项目最重要的方面，但有一些场景需要不同的方法。维护任务、导入大量数据或耗时的计算通常以批处理模式而不是交互式方式处理。通常，这类作业不是标准操作的一部分，而应在服务器负载最低或定期时调用。
- en: Before Java EE 7, there was no standardized way to implement batch jobs (operations
    that do not require user interaction). The deal changed with JSR 352 ([https://jcp.org/en/jsr/detail?id=352](https://jcp.org/en/jsr/detail?id=352))
    and the introduction of the batch framework, which uses an XML language to define
    jobs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE 7之前，没有标准化的方式来实现批处理作业（不需要用户交互的操作）。随着JSR 352 ([https://jcp.org/en/jsr/detail?id=352](https://jcp.org/en/jsr/detail?id=352))
    和批处理框架的引入，这一情况发生了变化，该框架使用XML语言来定义作业。
- en: When it comes to processor-intensive tasks, the natural way is to think about
    parallelization. Modern CPUs have multiple cores, which can be easily utilized
    by the JVM. The only problem is that in Java EE, using concurrency primitives
    known from Java SE is discouraged. The programmer may impair the stability and
    availability of the whole container.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到处理器密集型任务时，自然想到的是并行化。现代CPU具有多个核心，这些核心可以很容易地被JVM利用。唯一的问题是，在Java EE中，使用来自Java
    SE的并发原语是不被鼓励的。程序员可能会损害整个容器的稳定性和可用性。
- en: Once more, the new JSR 236 ([https://jcp.org/en/jsr/detail?id=236](https://jcp.org/en/jsr/detail?id=236))
    provides new ways to overcome this architectural obstacle. The new specification
    `ManagedExecutorService` is a container-aware version of `ExecutorService` known
    from Java SE.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，新的JSR 236 ([https://jcp.org/en/jsr/detail?id=236](https://jcp.org/en/jsr/detail?id=236))
    提供了克服这种架构障碍的新方法。新的规范 `ManagedExecutorService` 是Java SE中已知的 `ExecutorService` 的容器感知版本。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to create and execute batch jobs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和执行批处理作业
- en: What are the differences between different batch job types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同批处理作业类型之间的区别是什么
- en: How to create our custom worker threads inside a Java EE container
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Java EE容器内创建我们的自定义工作线程
- en: The overview of the batching framework
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批处理框架概述
- en: 'A step is the basic unit of work and our main area of interest. The batching
    framework defines two types of steps, which are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤是基本的工作单元，也是我们主要关注的领域。批处理框架定义了两种类型的步骤，如下所示：
- en: '**Chunk steps**: These work on chunks of data in three phases: reading, processing,
    and writing (for each phase, a separate class is created). The chunks can be configured
    with a number of elements that should be processed in one transaction.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分块步骤**：这些步骤在三个阶段上对数据块进行处理：读取、处理和写入（对于每个阶段，都创建一个单独的类）。这些块可以配置为在一个事务中应该处理元素的数量。'
- en: '**Task steps**: These execute a specific block of code created by the programmer,
    without any special constraints. They are used for most non-data processing errands.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务步骤**：这些执行程序员创建的特定代码块，没有任何特殊约束。它们用于大多数非数据处理任务。'
- en: Additionally, the batching framework allows listeners to register for the whole
    job or specific phases of the tasks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，批处理框架允许监听器为整个作业或特定任务阶段进行注册。
- en: Now that we've covered the basic vocabulary, it will be best to jump straight
    to coding.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了基本词汇，最好直接进入编码。
- en: Our first batch job
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个批处理作业
- en: WildFly comes with an implementation of JSR 352 called JBeret ([https://github.com/jberet/jsr352](https://github.com/jberet/jsr352)).
    This means that we can easily extend our ticket application with batch jobs, by
    simply implementing the required interfaces; no additional dependencies are required.
    All APIs are already in place in our current samples, so we only need to create
    some classes and an XML file to specify the job flow.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly提供了一个名为JBeret的JSR 352实现 ([https://github.com/jberet/jsr352](https://github.com/jberet/jsr352)).
    这意味着我们可以通过简单地实现所需的接口轻松地将批处理作业扩展到我们的票务应用程序中；不需要额外的依赖项。所有API都已经在我们当前的示例中就绪，所以我们只需要创建一些类和一个XML文件来指定作业流程。
- en: 'As a base for our development in this chapter, it would be best to use the
    code from [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining Persistence
    with CDI"), *Combining Persistence with CDI*. The persistence layer will allow
    us to code a sample import batching job. To keep it simple, let''s start by defining
    an artificial external service that will provide us with IDs of tickets that should
    be booked. We can deploy it as part of our application or as a separate WAR file.
    This sample is based on a REST endpoint, so be sure to configure JAX-RS in your
    deployment (for details, check out [Chapter 7](part0038_split_000.html#page "Chapter 7. Adding
    Web Services to Your Applications"), *Adding Web Services to Your Applications*).
    This is shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章开发的基线，最好使用[第5章](part0030_split_000.html#page "第5章。将持久性与CDI结合")中的代码，*将持久性与CDI结合*。持久化层将允许我们编写一个示例导入批处理作业。为了保持简单，让我们首先定义一个人工的外部服务，它将为我们提供应预订的票证的ID。我们可以将其作为应用程序的一部分或作为单独的WAR文件部署。此示例基于REST端点，因此请确保在部署中配置JAX-RS（有关详细信息，请参阅[第7章](part0038_split_000.html#page
    "第7章。将Web服务添加到您的应用程序")，*将Web服务添加到您的应用程序*）。以下是一个代码片段：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a chunk-based batch step
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基于块的批处理步骤
- en: 'Our integration scenario will be pretty straightforward. We need to read all
    of the reservation IDs from the external system to get the corresponding seats
    from our database and write the changes back to the database. It would also be
    great to write a log with the operations made by the import. Let''s start with
    the item reader:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的集成场景将非常直接。我们需要从外部系统读取所有预订ID，以从我们的数据库中获取相应的座位，并将更改写回数据库。记录导入操作日志也会很好。让我们从项目读取器开始：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our reader extends the `AbstractItemReader` class so that we don't have to implement
    all methods of the `javax.batch.api.chunk.ItemReader` interface. The only two
    methods we are interested in are `open` and `readItem`. The first one initializes
    the REST client, which will get the data from the server. The implementation is
    optional because not every reader needs initialization logic. Note that a checkpoint
    parameter is passed to the method. It can be used to restart the batch job from
    a specific point. We will, however, leave out this feature.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的读者扩展了`AbstractItemReader`类，这样我们就不必实现`javax.batch.api.chunk.ItemReader`接口的所有方法。我们感兴趣的只有两个方法：`open`和`readItem`。第一个方法初始化REST客户端，将从服务器获取数据。实现是可选的，因为并非每个读取器都需要初始化逻辑。请注意，一个检查点参数被传递给该方法。它可以用来从特定点重新启动批处理作业。然而，我们将省略这个功能。
- en: The `readItem` method requests the data from an external service and returns
    a single item to the batch framework. A null value is an indicator that there
    is no more data. Additional methods of the `ItemReader` interface are responsible
    for checkpoint handling and closing of the reader.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`readItem`方法从外部服务请求数据，并将单个项目返回给批处理框架。null值是一个指示没有更多数据的标志。`ItemReader`接口的其他方法负责检查点处理和读取器的关闭。'
- en: When we define the XML specification for the batch job, we must use the names
    of managed beans to refer to the reader, processor, or writer we want (just like
    in JSF). Therefore, we need the `@Named` annotation in order to provide a string-based
    qualifier; by default, it will be a lowercase name of the class on which the annotation
    is placed. For the `ExternalSystemReader` bean, we will use the `externalSystemReader`
    name.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为批处理作业定义XML规范时，我们必须使用管理bean的名称来引用我们想要的读取器、处理器或写入器（就像在JSF中一样）。因此，我们需要`@Named`注解来提供一个基于字符串的限定符；默认情况下，它将是放置注解的类的名称的小写。对于`ExternalSystemReader`bean，我们将使用`externalSystemReader`名称。
- en: 'After an item is read, we may process it. Our `SeatProcessor` class goes as
    the following code snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取一个项目后，我们可能会处理它。我们的`SeatProcessor`类如下代码片段：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our processor retrieves IDs from the reader and finds the corresponding entry
    in the database. To find the entity, we reuse our `SeatDao` class known from previous
    chapters. Because we have CDI working on the batch framework, we can just inject
    our EJB without caring about transaction handling.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理器从读取器检索ID，并在数据库中找到相应的条目。为了找到实体，我们重用了上一章中已知的`SeatDao`类。因为我们有CDI在批处理框架上工作，所以我们只需注入我们的EJB，无需关心事务处理。
- en: If the seat is found, we check if it's already booked. If yes, we can simply
    return a null value to omit this item from further processing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到座位，我们检查它是否已被预订。如果是，我们可以简单地返回一个null值，以从进一步处理中省略此项目。
- en: 'The last step is `SeatWriter`. This is shown in the following code snippet:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是 `SeatWriter`。以下是一个代码片段：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `ItemWriter` class starts by defining an `open` method, which gets a file
    for writing. The name of the newly created logfile is taken from the job properties.
    Our source of information about the current batch job is the injected `JobContext`
    class (there is also a `StepContext` object that provides information about a
    specific step). It gives us the possibility to get the properties defined for
    a job, its current ID, status, and additional transient data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ItemWriter` 类首先定义了一个 `open` 方法，该方法获取一个用于写入的文件。新创建的日志文件名取自作业属性。我们关于当前批处理作业的信息来源是注入的
    `JobContext` 类（还有一个 `StepContext` 对象，它提供了有关特定步骤的信息）。它为我们提供了获取作业定义的属性、当前 ID、状态和附加瞬态数据的机会。
- en: The heart of our writer is, of course, the `writeItem` method. It receives a
    list of items (seats in our case) to be written and its responsibility is to persist
    them. This method can be invoked multiple times up to the moment when there is
    no more data to be written. You can configure the number of elements that will
    be processed in every chunk. What's more, every chunk runs in its own transaction.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写入器的核心当然是 `writeItem` 方法。它接收要写入的项目列表（在我们的例子中是座位），其责任是持久化它们。此方法可以在没有更多数据要写入之前多次调用。您可以配置每个块中要处理元素的数量。更重要的是，每个块都在自己的事务中运行。
- en: Finally, when the last chunk is written, the `close` method writes a summary
    and closes the file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当最后一个块写入完成后，`close` 方法会写入摘要并关闭文件。
- en: 'All elements are now in place, so we need to create a batch job specification.
    The file `externalSystem.xml` should be placed in the `src/main/resources/META-INF/batch-jobs`
    directory in your project. The contents are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有元素现在都已就绪，因此我们需要创建一个批处理作业规范。`externalSystem.xml` 文件应放置在您的项目中 `src/main/resources/META-INF/batch-jobs`
    目录下。内容如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The structure is pretty straightforward. First, we define a job ID matching
    the filename `[1]`. Next, in the properties section, we set a property `logFile`
    with the `log.txt` value `[2]` we used it in our `SeatWriter` to create an output
    file `[3]`. Then, we define a step with a data chunk. The `item-count` attribute
    defines the number of items we process in one transaction. Finally, we reference
    our reader, processor, and writer in their matching tags `[4]`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 结构非常简单。首先，我们定义一个与文件名 `[1]` 匹配的作业 ID。接下来，在属性部分，我们设置一个名为 `logFile` 的属性，其值为 `log.txt`
    `[2]`，我们在 `SeatWriter` 中使用它来创建输出文件 `[3]`。然后，我们定义一个包含数据块的分步操作。`item-count` 属性定义了我们在一个事务中处理的项目数量。最后，我们在相应的标签
    `[4]` 中引用我们的读取器、处理器和写入器。
- en: 'Now, when our job is defined, it is time to start it. To do this, we need to
    the use the BatchRuntime''s static method, `getJobOperator`. In order to simplify
    the solution, we will use a REST endpoint''s GET method as a way to invoke our
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的作业定义完成后，是时候启动它了。为此，我们需要使用 BatchRuntime 的静态方法 `getJobOperator`。为了简化解决方案，我们将使用
    REST 端点的 GET 方法来调用我们的代码：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `JobOperator start` method returns a job ID, which is a representation of
    the ongoing batch process. We need to provide the name of the file defining the
    batch job without the XML extension and a set of runtime parameters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobOperator start` 方法返回一个作业 ID，它是正在进行的批处理过程的表示。我们需要提供定义批处理作业的文件名（不带 XML 扩展名）和一组运行时参数。'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The properties provided during runtime are not the same as we used earlier!
    These kinds of properties are not bound to a specific job (in contrast to the
    ones defined in the XML file), but can be accessed from the job execution. The
    batching framework calls them parameters. If you need this kind of logic in your
    application, you should just pass them during a job''s startup and use the job
    execution ID to access them:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时提供的属性与我们之前使用的不同！这类属性不是绑定到特定作业的（与在 XML 文件中定义的属性相反），但可以从作业执行中访问。批处理框架称它们为参数。如果您需要在您的应用程序中实现这类逻辑，您只需在作业启动期间传递它们，并使用作业执行
    ID 来访问它们：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can point your browser to `http://localhost:8080/ticket-agency-longterm/rest/job`
    and your batch job should start running! Be sure to set up your seats before running
    the job (the console is available at `http://localhost:8080/ticket-agency-longterm/faces/views/setup.xhtml`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将浏览器指向 `http://localhost:8080/ticket-agency-longterm/rest/job` 并启动您的批处理作业！在运行作业之前，请务必设置您的座位（控制台位于
    `http://localhost:8080/ticket-agency-longterm/faces/views/setup.xhtml`）。
- en: 'A sample output file in your WildFly''s bin directory would look like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 WildFly 的 bin 目录中，一个示例输出文件可能看起来如下：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, you could also start the batch job using a Java EE timer after a
    specific event in your application or even as an effect of an incoming JMS message.
    You can also use the retrieved job IDs to monitor the already running jobs or
    terminate them on demand. The batching framework API gives you many possibilities
    without too many complications in the area of job management.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还可以在应用程序中的特定事件之后或作为传入 JMS 消息的效果使用 Java EE 定时器启动批处理作业。你还可以使用检索到的作业 ID 来监控已运行的作业或根据需要终止它们。批处理框架
    API 在作业管理领域提供了许多可能性，而不会带来太多的复杂性。
- en: Creating a job-based batch step
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基于作业的批处理步骤
- en: Our chunk-based job was great to process big data sets. However, what if we
    only want to perform a specific task? Besides creating chunks, we can also define
    steps that will simply call a process method of a specific class. These kinds
    of classes must implement the `Batchlet` interface (or extend the `AbstractBatchlet`
    class).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于分块的作业非常适合处理大数据集。然而，如果我们只想执行一个特定的任务怎么办？除了创建分块，我们还可以定义将简单地调用特定类的过程方法的步骤。这些类必须实现
    `Batchlet` 接口（或扩展 `AbstractBatchlet` 类）。
- en: 'In our sample, let''s try to contact an external API to ask about the current
    Bitcoin exchange rate (a decentralized, virtual currency). Then, we will store
    the current prices of our tickets in a simple flat file. Our batchlet would be
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，让我们尝试联系一个外部 API 来询问当前的比特币汇率（一种去中心化、虚拟货币）。然后，我们将把我们的票价的当前价格存储在一个简单的平面文件中。我们的批处理单元将如下所示：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The process method `[1]` is our entry point to the batchlet. We will start by
    making a `REST` request against an external API `[2]` and use the response to
    calculate our prices in bitcoins `[3]`. Finally, we will try to write so as to
    gathered data into a file. As you can see, once more, we use `JobContext` to get
    the configuration properties from the batching framework (the filename in this
    case).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 流程方法 `[1]` 是我们进入批处理单元的入口点。我们将首先向外部 API `[2]` 发起一个 `REST` 请求，并使用响应来计算我们的比特币价格
    `[3]`。最后，我们将尝试将收集到的数据写入文件。正如你所见，又一次，我们使用 `JobContext` 从批处理框架（在这种情况下是文件名）获取配置属性。
- en: You may wonder, what is the point of the return type in the `process` method?
    It simply indicates the status of the job, if it has been completed successfully
    or not.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，`process` 方法中的返回类型有什么意义？它仅仅表示作业的状态，如果它已经成功完成或者没有。
- en: 'That''s all we wanted to do and we achieved it in a single batch step: reading,
    processing, and writing. In the chunk-oriented approach, we will have three separate
    mechanisms for this. Let''s add our new step to `externalSystem.xml` from `src/main/resources/META-INF/batch-jobs`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们想要做的，我们通过单个批处理步骤就实现了它：读取、处理和写入。在面向分块的方法中，我们将有三种独立的机制来完成这个任务。让我们将我们的新步骤添加到
    `externalSystem.xml` 中，该文件位于 `src/main/resources/META-INF/batch-jobs`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are three new things to notice in the XML file. First, we added a new
    property, which we referenced earlier in our batchlet `[1]`. Next, we defined
    that after our chunk processing step, we would like to invoke another one, `checkBitcoins`
    `[2]`. Finally, we created a new step in which we referenced our `batchlet` class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 文件中有三个新的需要注意的地方。首先，我们添加了一个新的属性，我们之前在我们的批处理单元 `[1]` 中引用过。接下来，我们定义了在分块处理步骤之后，我们希望调用另一个步骤，即
    `checkBitcoins` `[2]`。最后，我们创建了一个新的步骤，在其中我们引用了我们的 `batchlet` 类。
- en: You can once again start your job, and after it is completed, a `bitcoins.txt`
    file should appear in WildFly's `bin` directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次启动你的作业，完成后，一个 `bitcoins.txt` 文件应该出现在 WildFly 的 `bin` 目录中。
- en: We've covered the foundation of the batching framework, which allows you to
    fulfill most of the frequent requirements defined for enterprise applications.
    However, there is a lot more inside the specification, such as splits, partitions,
    and workflow-related elements (statuses and decisions) that you can explore if
    a more sophisticated mechanism is required by the business processes that you're
    implementing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了批处理框架的基础，它允许你满足企业应用中定义的大多数常见需求。然而，规范中还有更多内容，例如拆分、分区以及与工作流相关的元素（状态和决策），如果你正在实施的业务流程需要更复杂的机制，你可以探索这些内容。
- en: Our next step is to provide some parallelism inside our Java EE container using
    the new concurrency utilities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是使用新的并发工具在 Java EE 容器内提供一些并行性。
- en: Using concurrency utilities in Java EE
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Java EE 中使用并发工具
- en: In Java EE 6 (specifically in the EJB container), creation of new threads was
    discouraged because the application server would not be able to control the stability
    of the platform nor guarantee any transactional features. This could be a problem
    for applications that would like to effectively use CPU and execute multiple tasks
    in parallel. It was possible to overcome this using JCA adapters, but additional
    effort was required to implement them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 6（特别是在 EJB 容器中），不建议创建新线程，因为应用程序服务器将无法控制平台的稳定性，也无法保证任何事务功能。这可能对希望有效使用
    CPU 并并行执行多个任务的应用程序造成问题。可以通过使用 JCA 适配器来克服这一点，但实现它们需要额外的努力。
- en: 'Fortunately, the JSR 236 introduces the `ManagedExecutorService` (along with
    the `ManagedScheduledExecutorService`), a container-aware version of the `ExecutorService`
    used in Java SE. The well-known API ported to Java EE was merged in the platform,
    providing a smooth workflow for concurrent operations in the EJB container. The
    new managed executor services have the following advantages over the standard
    ones:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JSR 236 引入了 `ManagedExecutorService`（以及 `ManagedScheduledExecutorService`），这是
    Java SE 中使用的 `ExecutorService` 的容器感知版本。已知的 API 已移植到 Java EE 平台，为 EJB 容器中的并发操作提供了顺畅的工作流程。新的托管执行器服务相对于标准服务有以下优点：
- en: They rely on the thread pool provided by the container. This means that the
    server controls have many threads that can be spawned from all deployed applications
    and you can tweak the configuration in order to ensure the desired quality of
    service.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们依赖于容器提供的线程池。这意味着服务器控制着可以由所有部署的应用程序生成的许多线程，你可以调整配置以确保所需的服务质量。
- en: The thread configuration is totally separated from the code, so it is possible
    to change it without changing the application itself.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程配置完全独立于代码，因此可以在不更改应用程序本身的情况下更改它。
- en: It is possible to propagate the caller context to the created thread. For example,
    it is possible to use the security principal of the user's request that initiated
    the new thread.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将调用者上下文传播到创建的线程中。例如，可以使用启动新线程的用户请求的安全主体。
- en: The application server allows monitoring of the current thread count.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序服务器允许监控当前线程数。
- en: Threads started by the managed executors can create new transactions for business
    components; they cannot, however, participate in transactions from other components.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由托管执行器启动的线程可以为业务组件创建新的事务；然而，它们不能参与来自其他组件的事务。
- en: 'The main parts of the concurrency utilities are described in the following
    table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 并发实用工具的主要部分在以下表中描述：
- en: '| Component | Description |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ManagedExecutorService` | This is used to execute submitted tasks in an
    asynchronous manner. The developer may submit a `Callable` or `Runnable` function
    and use returned `Future` to check for the result when it is available. The container
    context will be propagated by the container.This interface extends the standard
    `ExecutorService` interface. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `ManagedExecutorService` | 这用于以异步方式执行提交的任务。开发者可以提交 `Callable` 或 `Runnable`
    函数，并使用返回的 `Future` 在结果可用时检查结果。容器上下文将由容器传播。该接口扩展了标准的 `ExecutorService` 接口。|'
- en: '| `ManagedScheduledExecutorService` | This is similar to `ManagedExecutorService`,
    but it is used to execute tasks at specific times (cyclic, scheduled, or delayed).The
    interface extends the standard `ScheduleExecutorService`, but it additionally
    provides the Trigger feature; the possibility to create a dynamic object, which
    can decide when a specific event should be fired (see `javax.enterprise.concurrent.Trigger`).
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `ManagedScheduledExecutorService` | 这与 `ManagedExecutorService` 类似，但它用于在特定时间执行任务（循环、计划或延迟）。该接口扩展了标准的
    `ScheduleExecutorService`，但还提供了触发功能；创建一个动态对象的可能性，该对象可以决定何时触发特定事件（请参阅 `javax.enterprise.concurrent.Trigger`）。|'
- en: '| `ContextService` | This is used to capture the context of the container;
    it can then be used while submitting a job to the executor service. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `ContextService` | 这用于捕获容器的上下文；然后可以在提交作业到执行器服务时使用它。|'
- en: '| `ManagedThreadFactory` | This is used to create threads by the container.
    The developer can provide its own thread factory in order to fulfil specific use
    cases (for instance, setting specific properties on the created objects). |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `ManagedThreadFactory` | 这用于由容器创建线程。开发者可以提供自己的线程工厂以满足特定的用例（例如，在创建的对象上设置特定的属性）。|'
- en: 'Instances of these components can be obtained using the JNDI lookup or the
    `@Resource` injection. The Java EE 7 specification requires that every container
    provides a set of default resources that should be injectable without any additional
    configuration. So, in WildFly, the easiest way to get your hands on them would
    be to just type the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过JNDI查找或`@Resource`注入来获取这些组件的实例。Java EE 7规范要求每个容器提供一组默认资源，这些资源可以在没有任何额外配置的情况下注入。因此，在WildFly中，获取它们的简单方法就是输入以下代码：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also find any additional executor services and the configuration of
    the default ones in the `standalone.xml` file (and in other variants of the configuration
    file). A part of the relevant subsystem is presented as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`standalone.xml`文件中找到任何额外的执行服务以及默认执行服务的配置（以及其他配置文件变体）。以下展示了相关子系统的一部分配置：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the `standalone.xml` file contains the configuration of the
    default `ManagedExecutorService`. You can add a new custom configuration with
    another name and JNDI path; you can also create a separate one for every deployed
    application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`standalone.xml`文件包含了默认`ManagedExecutorService`的配置。您可以使用另一个名称和JNDI路径添加一个新的自定义配置；您也可以为每个部署的应用程序创建一个单独的配置。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the default ManagedExecutorService has two JNDI names: the one in
    the configuration and the one defined in the Java EE specification (`java:comp/DefaultManagedExecutorService`).
    You can switch to the default executor service (and other components) using the
    default-bindings tag in the `standalone.xml` file.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认的ManagedExecutorService有两个JNDI名称：配置文件中的那个和Java EE规范中定义的那个（`java:comp/DefaultManagedExecutorService`）。您可以通过`standalone.xml`文件中的default-bindings标签切换到默认的执行服务（以及其他组件）。
- en: 'Let''s take a closer look at some of the properties of the executor service:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看一些执行服务的属性：
- en: '**core-threads**: This defines how many threads should be alive in the thread
    pool all the time (even if those threads are idle and the server is handling no
    user requests).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**core-threads**：这定义了在所有时间都应该在线程池中保持活跃的线程数量（即使这些线程是空闲的，服务器也没有处理用户请求）。'
- en: '**max-threads**: This states how many threads the server can start (including
    the core threads) if necessary, for instance, when under heavy load.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**max-threads**：这表示服务器在必要时可以启动多少个线程（包括核心线程），例如，在负载很重的情况下。'
- en: '**keepalive-time**: This defines after how many milliseconds a thread can be
    idle before the server kills it (it only applies if there are more threads running
    than the core-threads parameter specified). This configuration value defines how
    long the server will keep around the additional threads when they are not needed
    anymore.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**keepalive-time**：这定义了线程在服务器将其杀死之前可以空闲多少毫秒（仅当运行的线程数多于指定的core-threads参数时适用）。此配置值定义了服务器在不再需要额外线程时将保留这些线程的时间长度。'
- en: '**hung-task-threshold**: This defines after how many milliseconds the server
    will mark a thread as hung. If set to `0`, a thread will never be marked as hung
    (the thread will have no execution time limit).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hung-task-threshold**：这定义了服务器将在多少毫秒后将一个线程标记为挂起。如果设置为`0`，则线程永远不会被标记为挂起（线程将没有执行时间限制）。'
- en: By using these configuration properties and creating additional executor services,
    the server administrator can gain a fine control over the maximum load that the
    server can handle at a given time. Be sure to take a closer look at them during
    an application's performance tuning.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些配置属性和创建额外的执行服务，服务器管理员可以精细控制服务器在特定时间可以处理的最大负载。确保在应用程序性能调整期间仔细查看它们。
- en: As for development, the default configuration suits us well, so it's time to
    dive into the code with an example usage of the concurrency utilities!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发而言，默认配置非常适合我们，因此现在是时候通过并发工具的示例用法来深入代码了！
- en: Introducing threads to enterprise beans
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将线程引入企业Bean
- en: When we were working with the batching framework, we contacted a REST endpoint,
    which was mocking an external system in our sample. Now, we are going to add some
    concurrency to it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与批处理框架一起工作时，我们联系了一个REST端点，该端点在我们的示例中模拟了一个外部系统。现在，我们将向其中添加一些并发性。
- en: 'An external system may aggregate booking requests from several sources. If
    every request takes a substantial amount of time, it could be a good idea to make
    all the requests simultaneously. Let''s start with creating `Callable`, which
    will return a list of the seat IDs that should be booked. This is shown in the
    following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 外部系统可能从多个来源汇总预订请求。如果每个请求都需要大量时间，同时发出所有请求可能是个好主意。让我们从创建 `Callable` 开始，它将返回应该预订的座位ID列表。如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our task implements `[1]` two interfaces: `Callable` and `ManagedTask`. The
    `ManagedExecutorService` requires an object that fulfils the contract of a `Callable`
    or `Runnable` interface known from Java SE.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务实现了 `[1]` 两个接口：`Callable` 和 `ManagedTask`。`ManagedExecutorService` 需要一个满足
    Java SE 中 `Callable` 或 `Runnable` 接口契约的对象。
- en: The `ManagedTask` interface is optional, but it allows us to register a `ManagedTaskListener`
    along with the task itself and return additional properties from the task. The
    task listener has a set of life cycle callbacks, which are called during the task's
    execution. We will use it in order to log additional information about our task.
    In order to create an instance of the task listener, we used the `Instance<T>`
    class `[2]`. It is used to create instances of CDI beans on demand. We return
    `ManagedTaskListener` in a method from the `ManagedTask` interface `[3]`. We don't
    need any additional properties; therefore, we return an empty object in the second
    method from the `ManagedTask` interface `[4]`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagedTask` 接口是可选的，但它允许我们与任务本身一起注册 `ManagedTaskListener` 并从任务返回额外的属性。任务监听器有一组生命周期回调，这些回调在任务执行期间被调用。我们将使用它来记录有关我们任务的额外信息。为了创建任务监听器的实例，我们使用了
    `Instance<T>` 类 `[2]`。它用于按需创建 CDI 实例。我们从 `ManagedTask` 接口的方法中返回 `ManagedTaskListener`
    `[3]`。我们不需要任何额外的属性；因此，我们从 `ManagedTask` 接口的第二个方法中返回一个空对象 `[4]`。'
- en: Finally, we implement the `call` method; the thread will be suspended for 5
    seconds (to simulate long work) and return a list of predefined IDs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了 `call` 方法；线程将被挂起5秒钟（以模拟长时间工作）并返回一个预定义的ID列表。
- en: 'Our task listener is simply a bean with a logger, which will get all the information
    about the task''s lifecycle. This is shown in the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务监听器只是一个带有记录器的bean，它将获取有关任务生命周期的所有信息。如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, most of the implemented methods are getting the executor service,
    future, and the task itself as parameters. We simply log the current status using
    an injected logger.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大多数实现的方法都是获取执行器服务、未来和任务本身作为参数。我们简单地使用注入的记录器记录当前状态。
- en: 'So, we''ve created one task, which is pretty static. Now, let''s try to create
    another one, which will contact a database. As before, we''ll need a `Callable`
    implementation, which returns a list of integers. This is shown in the following
    code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经创建了一个任务，它相当静态。现在，让我们尝试创建另一个任务，该任务将联系数据库。和之前一样，我们需要一个 `Callable` 实现来返回一个整数列表。如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The main difference between this task and the previous one is that we injected
    an EJB `[1]`, which will start an underlying transaction. In the `call` method,
    a database request is issued `[2]`. The returned list of seats is then filtered
    and transformed into a list of IDs `[3]`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个任务相比，主要区别在于我们注入了一个 EJB `[1]`，这将启动一个底层事务。在 `call` 方法中，发出一个数据库请求 `[2]`。然后，返回的座位列表被过滤并转换成一个座位ID列表
    `[3]`。
- en: Additionally, as mentioned earlier, we will stop the thread for 5 seconds so
    that we can observe the execution later `[4]`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如前所述，我们将停止线程5秒钟，以便我们可以在稍后观察执行情况 `[4]`。
- en: 'We''ve got our building blocks in place. Now, it is time to combine them into
    a working example. We can revisit our `PendingSeats` class from the beginning
    of this chapter, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了构建块。现在，是时候将它们组合成一个工作示例了。我们可以从本章开头提到的 `PendingSeats` 类开始，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by obtaining an instance of `ManagedExecutorService` using the `@Resource`
    annotation `[1]`. Next, the previously created tasks are injected using the CDI's
    `Instance<T>` class pattern `[2]`. Thanks to this, the are managed beans and have
    their dependencies injected. With the dependencies in place, we use the `invokeAll`
    method `[3]` of `executorService` in order to start all our tasks at once (we
    could also use multiple calls of the `submit` method). The return values represent
    a set of future results, which can be used to retrieve the collected data when
    it is ready.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`@Resource`注解[1]获取`ManagedExecutorService`的实例。接下来，使用CDI的`Instance<T>`类模式[2]注入先前创建的任务。多亏了这一点，它们是管理Bean，并且它们的依赖项被注入。有了依赖项，我们使用`executorService`的`invokeAll`方法[3]一次性启动所有任务（我们也可以使用多次调用`submit`方法）。返回值代表一组未来结果，可以在数据准备好时用于检索收集的数据。
- en: At this point, our tasks are already running so we can simply make a blocking
    `get` call on the future results and wait for the data `[4]`. When it is ready,
    we remove any duplicates, and collect the results in a single list using the `flatMap`
    operation. As you remember, our previous two tasks were waiting 5 seconds each.
    Thanks to the fact that they are executed simultaneously, we expect that they
    will both finish after 5 seconds.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的任务已经开始运行，因此我们可以在未来结果上简单地执行阻塞的`get`调用并等待数据[4]。当它准备好时，我们删除任何重复项，并使用`flatMap`操作将结果收集到一个单独的列表中。如您所记得，我们之前的两个任务各自等待了5秒钟。由于它们是同时执行的，我们预计它们将在5秒后同时完成。
- en: Because our bean is a singleton with a startup annotation, the whole process
    will be invoked during the deployment of our application. Feel free to try it
    out now!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的Bean是一个带有启动注解的单例，所以整个流程将在我们的应用程序部署期间被调用。现在就试试看吧！
- en: 'Of course, the database task requires some data in the `seats` table or it
    will yield empty results (that''s not a big issue for us). If you want the application
    to automatically seed some data to the database, you can create another singleton
    bean, for instance:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，数据库任务需要在`seats`表中有一些数据，否则将返回空结果（对我们来说这不是一个大问题）。如果您希望应用程序自动将一些数据种入数据库，您可以创建另一个单例Bean，例如：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Be sure to add a `@DependsOn("DatabaseInitializer")` annotation on the `PendingSeats`
    bean, so that the initializer runs before our database collector.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在`PendingSeats`Bean上添加`@DependsOn("DatabaseInitializer")`注解，以便初始化器在我们数据库收集器之前运行。
- en: 'If everything goes well, you should see something like this on your console:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在控制台看到如下内容：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, both tasks started at the same time (1 and 2) in two separate
    threads (notice the `EE-ManagedExecutorService-default-Thread-1` and `…-Thread-2`
    entries in the log). The final result is yielded after roughly 5 seconds, and
    it contains data from both the collectors, and additionally, is collected in the
    thread that originally submitted the tasks (`ServerService Thread Pool -- 54`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，两个任务同时在两个不同的线程中启动（1和2），注意日志中的`EE-ManagedExecutorService-default-Thread-1`和`…-Thread-2`条目）。最终结果在大约5秒后产生，它包含来自两个收集器的数据，并且还收集在最初提交任务的线程中（`ServerService
    Thread Pool -- 54`）。
- en: 'You can also use the Java VisualVM tool to visualize your threads in the application
    server. The tool is available in your JDK installation in the `bin` directory
    (the `jvisualvm` executable). After running it, you should see JBoss in the left
    tree and the **Threads** tab after clicking on the JBoss node. This is shown in
    the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Java VisualVM工具来可视化应用程序服务器中的线程。该工具位于您的JDK安装的`bin`目录中（`jvisualvm`可执行文件）。运行它后，您应该在左侧树中看到JBoss，并在点击JBoss节点后看到**线程**选项卡。这在上面的屏幕截图中显示：
- en: '![Introducing threads to enterprise beans](img/00099.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![向企业Bean介绍线程](img/00099.jpeg)'
- en: 'If you switch to the **Threads** tab during your application deployment, you
    will see a graph, as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在应用程序部署期间切换到**线程**选项卡，您将看到一个图表，如以下屏幕截图所示：
- en: '![Introducing threads to enterprise beans](img/00100.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![向企业Bean介绍线程](img/00100.jpeg)'
- en: 'The purple color denotes a sleeping thread and the two highlighted threads
    with a purple part of the timeline are our tasks during execution. You can use
    a detailed thread view to additionally examine your worker threads. This is shown
    in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 紫色表示休眠线程，时间轴上带有紫色部分的两个突出显示的线程是执行过程中的我们的任务。您可以使用详细的线程视图来进一步检查您的工作线程。这在上面的屏幕截图中显示：
- en: '![Introducing threads to enterprise beans](img/00101.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![向企业Bean介绍线程](img/00101.jpeg)'
- en: Java VisualVM offers many more features useful for every developer, such as
    resource monitoring of the virtual machine, profiler, sampler, and others that
    are implemented as dedicated plugins. Be sure to check them out!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Java VisualVM 为每个开发者提供了许多有用的功能，例如虚拟机的资源监控、分析器、采样器等，这些功能都作为专用插件实现。务必查看它们！
- en: In this section, we implemented a use case that was a lot harder to cover in
    a proper manner in previous versions of Java EE. We were able to do this with
    less code, thanks to the high-level API that was made available to the developers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现了一个在 Java EE 之前版本中难以适当覆盖的用例。得益于提供给开发者的高级 API，我们能够用更少的代码完成这项工作。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create batching applications using the new
    batching framework in two different ways. Next, we tried some of the mechanisms
    provided by the concurrency utilities. Our exploration went away from the user
    interaction and concentrated on the internals of the middleware layer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用新的批处理框架以两种不同的方式创建批处理应用程序。接下来，我们尝试了一些并发工具提供的机制。我们的探索从用户交互转向了中间件层的内部。
- en: In the next chapter, we will fill the last gap in the Java EE developer's toolbox,
    which is integration testing with Arquillian.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将填补 Java EE 开发者工具箱中的最后一个空白，即使用 Arquillian 进行集成测试。
