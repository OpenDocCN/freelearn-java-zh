["```java\n@Table(\"users\")\npublic record User(@Id Long id, String name, String email) {}\n```", "```java\n# Enable H2 Console\nspring.h2.console.enabled=true\n# Database Configuration for H2\nspring.r2dbc.url=r2dbc:h2:mem:///testdb\nspring.r2dbc.username=sa\nspring.r2dbc.password=\n# Schema Generation\nspring.sql.init.mode=always\nspring.sql.init.platform=h2\n```", "```java\npublic interface UserRepository extends R2dbcRepository<User, String> {\n    Mono<User> findByEmail(String email);\n}\n```", "```java\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController {\n    private final UserRepository userRepository;\n    public UserController(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    // ... CRUD operations\n}\n```", "```java\n        @PostMapping\n        public Mono<User> createUser(@RequestBody User user) {\n            return userRepository.save(user);\n        }\n    ```", "```java\n        @GetMapping\n        public Flux<User> getAllUsers() {\n            return userRepository.findAll();\n        }\n    `getUserById` fetches a single user based on the provided ID. It’s a typical example of a read operation in a REST API, returning `Mono<User>` as it expects at most one result.\n    ```", "```java\n        @DeleteMapping(\"/{id}\")\n        public Mono<Void> deleteUser(@PathVariable String id) {\n            return userRepository.deleteById(id);\n        }\n    ```", "```java\n@PostMapping\npublic Mono<ResponseEntity<User>> createUser(@RequestBody User user) {\n    return userRepository.findByEmail(user.email())\n            .flatMap(existingUser -> Mono.error(new EmailUniquenessException(\"Email already exists!\")))\n            .then(userRepository.save(user)) // Save the new user if the email doesn't exist\n            .map(ResponseEntity::ok) // Map the saved user to a ResponseEntity\n            .doOnNext(savedUser -> System.out.println(\"New user created: \" + savedUser)) // Logging or further action\n            .onErrorResume(e -> { // Handling errors, such as email uniqueness violation\n                System.out.println(\"An exception has occurred: \" + e.getMessage());\n                if (e instanceof EmailUniquenessException) {\n                    return Mono.just(ResponseEntity\n                            .status(HttpStatus.CONFLICT).build());\n                } else {\n                    return Mono.just(ResponseEntity\n                            .status(HttpStatus.INTERNAL_SERVER_ERROR)\n                            .build());\n                }\n            });\n}\n```", "```java\n       ./gradlew bootRun\n    ```", "```java\n        409 (conflict).\n        ```", "```java\n        GET /users/{id}): This command will gather just one user:\n\n        ```", "```java\n        204 (no content), indicating successful deletion.\n        ```", "```java\n\n        ```", "```java\n            private static final Logger log = LoggerFactory.getLogger(UserController.class);\n        ```", "```java\n        @GetMapping\n            public Flux<User> getAllUsers() {\n                long start = System.currentTimeMillis();\n                return userRepository.findAll()\n                        .doOnSubscribe(subscription -> log.debug(\"Subscribed to User stream!\"))\n                        .doOnNext(user -> log.debug(\"Processed User: {} in {} ms\", user.name(), System.currentTimeMillis() - start))\n                        .doOnComplete(() -> log.info(\"Finished streaming users for getAllUsers in {} ms\", System.currentTimeMillis() - start));\n            }\n        ```", "```java\n           @GetMapping(\"/stream\")\n            public Flux<User> streamUsers() {\n                long start = System.currentTimeMillis();\n                return userRepository.findAll()\n                        .onBackpressureBuffer()  // Buffer strategy for back-pressure\n                        .doOnNext(user -> log.debug(\"Processed User: {} in {} ms\", user.name(), System.currentTimeMillis() - start))\n                        .doOnError(error -> log.error(\"Error streaming users\", error))\n                        .doOnComplete(() -> log.info(\"Finished streaming users for streamUsers in {} ms\", System.currentTimeMillis() - start));\n            }\n        ```", "```java\n        #!/bin/bash\n        # A simple script to create load by sending multiple concurrent requests to the server.\n        # Define the number of requests\n        REQUESTS=300\n        # The endpoint to test\n        URL=\"http://localhost:8080/users/stream\"\n        for i in $(seq 1 $REQUESTS)\n        do\n           curl \"$URL\" &  # The ampersand at the end sends the request in the background, allowing for concurrency\n        done\n        wait # Wait for all background jobs to finish\n        echo \"All requests sent.\"\n        ```"]