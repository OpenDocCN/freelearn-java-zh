<html><head></head><body>
		<div id="_idContainer085">
			<h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor132"/>Chapter 7</em>: Handling Microservice Concerns</h1>
			<p>Any microservice architecture implementation is incomplete without handling some fundamental microservice concerns such as <strong class="bold">configuration management</strong>, <strong class="bold">API documentation</strong>, <strong class="bold">service discovery</strong>, <strong class="bold">API gateways</strong>, and <strong class="bold">fault tolerance</strong>. Hitherto we were focused on the disintegration journey of the microservices, such as how to separate the concerns in modular microservices. For seamless and unified application access, we need the microservices to integrate and expose a coalesced interface. A coalesced interface enables the upstream consumers to interact with backend microservices as though they were one. </p>
			<p>A key benefit of implementing microservices is fault tolerance. Fault tolerance mechanisms such as on-demand scaling, fallbacks, and circuit breakers make microservices ubiquitous and robust.</p>
			<p>In this chapter, we will explore ways to handle and implement the following microservice concerns:</p>
			<ul>
				<li>Externalizing the application configuration</li>
				<li>Documenting the service APIs</li>
				<li>Implementing service discovery</li>
				<li>Implementing the API gateway</li>
				<li>Implementing the fault-tolerance mechanisms</li>
			</ul>
			<p>By the end of this chapter, you will have practical knowledge of handling and implementing these key microservice concerns in the Micronaut framework.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor133"/>Technical requirements</h1>
			<p>All the commands and technical instructions in this chapter run on Windows 10 and macOS. The code examples covered in this chapter are available on the book's GitHub repo at <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter07">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter07</a>.</p>
			<p>The following tools need to be installed and set up in the development environment:</p>
			<ul>
				<li><strong class="bold">Java SDK</strong> version 13 or above (we used Java 14).</li>
				<li><strong class="bold">Maven</strong> – This is optional and only required if you would like to use Maven as the build system. However, we recommend having Maven set up on any development machine. Instructions to download and install Maven can be found at <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</li>
				<li><strong class="bold">A development IDE</strong> – Based on your preference, any Java-based IDE can be used, but for purpose of writing this chapter, IntelliJ was used. </li>
				<li><strong class="bold">Git</strong> – Instructions to download and install this can be found at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</li>
				<li><strong class="bold">PostgreSQL</strong> – Instructions to download and install this can be found at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</li>
				<li><strong class="bold">MongoDB</strong> – MongoDB Atlas provides a free online database-as-a-service with up to 512 MB storage. However, if a local database is preferred then instructions to download and install this can be found at <a href="https://docs.mongodb.com/manual/administration/install-community/">https://docs.mongodb.com/manual/administration/install-community/</a>. We used a local installation for writing this chapter.</li>
				<li><strong class="bold">A REST client</strong> – Any HTTP REST client can be used. We used the Advanced REST Client Chrome plugin.</li>
				<li><strong class="bold">Docker </strong>– Instructions to download and install Docker can be found at <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>.</li>
			</ul>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor134"/>Externalizing the application configuration</h1>
			<p>Irrespective<a id="_idIndexMarker552"/> of the size and complexities of a microservice application, the task of maintaining the configuration settings for each service seems one of the most crucial aspects of working with microservices. Decoupling the service configurations goes back to our earlier discussion on separating the concerns. In the earlier chapters, we have seen how we can handle service configurations using the <strong class="source-inline">application.properties</strong> files. Though this is a step up from not hard-coding these configurations in production code, it's still not enough. </p>
			<p>One of the<a id="_idIndexMarker553"/> key requirements for any microservice is agility. An ideal microservice should be flexible and rapid in addressing any change in the user's requirements, as well as handling code defects or network issues. Having said that, each enterprise application needs to meet the specific demands of compliance and auditing, which implies that a developer often can't just deploy a code artifact from their workspace directly to a production environment. If the configurations are decoupled from the service code logic then we can easily build the artifact once (without configurations) and deploy it to many environments (where each environment can bootstrap its own configurations).</p>
			<p>In the next section, we will dive into how we can manage distributed service configurations in the Micronaut framework. </p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor135"/>Using distributed configuration management to externalize the configuration</h2>
			<p>Micronaut<a id="_idIndexMarker554"/> has out-of-the-box features for <strong class="bold">distributed configuration management</strong>. It has <a id="_idIndexMarker555"/>built-in support and integration with <a id="_idIndexMarker556"/>HashiCorp's <strong class="bold">Consul</strong>. Though Consul is a service discovery tool, it also has the capability to store application properties. In the following section, we will use <strong class="bold">Consul key-value store</strong> for managing <a id="_idIndexMarker557"/>configurations for the <strong class="source-inline">pet-owner</strong> microservice.</p>
			<h3>Implementing a configuration store in Consul</h3>
			<p>We will <a id="_idIndexMarker558"/>use a Dockerized Consul instance. Work through the following instructions for installing and running Consul in Docker:</p>
			<ol>
				<li>Make sure the Docker application is running in your workspace/environment. Then open a bash terminal (I used Git Bash) and run the following command:<p class="source-code"><strong class="bold">docker run -d --name consul -p 8500:8500 consul</strong></p></li>
				<li>Wait for Docker to download and install <strong class="bold">Consul</strong>.</li>
			</ol>
			<p>The preceding <a id="_idIndexMarker559"/>command will kick-start a single-node Consul instance and expose it on port <strong class="source-inline">8500</strong>. We can verify the installation by accessing the Consul web interface at <strong class="source-inline">http://localhost:8500/</strong>.</p>
			<p>Now, to create a configuration store in Consul, follow these instructions:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Consul</strong> web interface at <strong class="source-inline">http://localhost:8500/</strong> and select <strong class="bold">Key/Value</strong> from the top header.</li>
				<li>Click on the <strong class="bold">Create</strong> button.</li>
				<li>Type <strong class="source-inline">config/pet-owner/application.yml</strong> in the <strong class="bold">Key or folder</strong> input box.</li>
				<li>Add the <strong class="source-inline">pet-owner</strong> <strong class="source-inline">application.properties</strong> in the text area:<p class="source-code">micronaut:</p><p class="source-code">  application:</p><p class="source-code">    name: pet-owner</p><p class="source-code">  router:</p><p class="source-code">    static-resources:</p><p class="source-code">      swagger:</p><p class="source-code">        paths: classpath:META-INF/swagger</p><p class="source-code">        mapping: /swagger/**</p><p class="source-code">datasources:</p><p class="source-code">  default:</p><p class="source-code">    url: "jdbc:postgresql://localhost:5432/postgres"</p><p class="source-code">    username: postgres</p><p class="source-code">    password: postgres</p><p class="source-code">    driverClassName: org.postgresql.Driver</p><p class="source-code">jpa:</p><p class="source-code">  default:</p><p class="source-code">    entity-scan:</p><p class="source-code">      packages:</p><p class="source-code">        - com.packtpub.micronaut.domain</p><p class="source-code">    properties:</p><p class="source-code">      hibernate:</p><p class="source-code">        show_sql: false</p><p class="source-code">        dialect: org.hibernate.dialect.PostgreSQL95Dialect</p><p class="source-code">        enable_lazy_load_no_trans: true</p></li>
			</ol>
			<p>By following the <a id="_idIndexMarker560"/>preceding steps, we have set up a key-value store in Consul for the <strong class="source-inline">pet-owner</strong> microservice.</p>
			<p>It's a good practice to keep a backup of these properties in the <strong class="source-inline">pet-owner resource</strong> folder as the Dockerized Consul instance may lose the configurations upon restarting. </p>
			<p>We can review the configurations by navigating to the <strong class="source-inline">pet-owner application.yml</strong> file:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_7.1_B16585_Fixed.jpg" alt="Figure 7.1 – Managing the pet-owner configurations in Consul&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Managing the pet-owner configurations in Consul</p>
			<p>As shown in <em class="italic">Figure 7.1</em>, we can easily review/modify application configurations in Consul. We<a id="_idIndexMarker561"/> have the option to <strong class="bold">Save </strong>the edits or <strong class="bold">Delete </strong>the <strong class="source-inline">application.yml</strong> file (in case you want to start fresh). </p>
			<p>Now let's dive into the changes we need to make in the <strong class="source-inline">pet-owner</strong> microservice to integrate it with Consul configuration management. </p>
			<h3>Integrating the pet-owner microservice with Consul configuration management</h3>
			<p>To<a id="_idIndexMarker562"/> integrate the<a id="_idIndexMarker563"/> <strong class="source-inline">pet-owner</strong> microservice with Consul, we will need to add the following dependency to the <strong class="source-inline">pom.xml</strong> project:</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">   &lt;groupId&gt;io.micronaut&lt;/groupId&gt;</p>
			<p class="source-code">   &lt;artifactId&gt;micronaut-discovery-client&lt;/artifactId&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p>By importing the <strong class="source-inline">micronaut-discover-client</strong> dependency, we can leverage out-of-the-box features for service discovery (which we will cover later in the chapter) and integration with Consul.</p>
			<p>We will also<a id="_idIndexMarker564"/> need to add a new <strong class="source-inline">bootstrap.yml</strong> file in the <strong class="source-inline">pet-owner</strong> microservice<a id="_idIndexMarker565"/> resources directory. Bootstrap YAML will inform the service to load (or bootstrap) the application properties from an external resource while starting up. To do so, add the following configurations to the <strong class="source-inline">bootstrap.yml</strong> file:</p>
			<p class="source-code">micronaut:</p>
			<p class="source-code">  application:</p>
			<p class="source-code">    name: pet-owner</p>
			<p class="source-code">  config-client:</p>
			<p class="source-code">    enabled: true</p>
			<p class="source-code">consul:</p>
			<p class="source-code">  client:</p>
			<p class="source-code">    config:</p>
			<p class="source-code">      enabled: true</p>
			<p class="source-code">      format: yaml</p>
			<p class="source-code">      defaultZone: «${CONSUL_HOST:localhost}:${CONSUL_PORT:8500}»</p>
			<p class="source-code">      path: "config/pet-owner/"</p>
			<p class="source-code">    registration:</p>
			<p class="source-code">      enabled: true</p>
			<p>All the configurations related to the Consul server are prefixed with the keyword <strong class="source-inline">consul</strong>. Some configurations to ponder are as follows:</p>
			<ul>
				<li><strong class="bold">defaultZone</strong>:  This parameter points to the Consul server. By default, we provide fallbacks of localhost and port <strong class="source-inline">8500</strong>. </li>
				<li><strong class="bold">path</strong>: This points to the <strong class="source-inline">application.yml</strong> relative path on the Consul server.</li>
			</ul>
			<p>These <a id="_idIndexMarker566"/>changes in <strong class="source-inline">bootstap.yml</strong> will enable the loading of the configuration for the<a id="_idIndexMarker567"/> <strong class="source-inline">pet-owner</strong> microservice from the Consul server. We can verify the changes made by running the <strong class="source-inline">pet-owner</strong> microservice. When booting up, it should sync with Consul to load the configuration:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_7.2_B16585_Fixed.jpg" alt="Figure 7.2 – Pet-owner microservice loading the service configurations from Consul at bootup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Pet-owner microservice loading the service configurations from Consul at bootup</p>
			<p>When we boot up the pet-owner microservice, <strong class="source-inline">bootstap.yml</strong> will inform the service to load the configuration from the Consul server. Built-in components in <strong class="source-inline">micronaut-discover-client</strong> dependency will sync with Consul and load this external configuration. </p>
			<p>Up to here, you have learned how to employ Micronaut for distributed configuration management. In the next section, we will implement API documentation using the Micronaut framework.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor136"/>Documenting the service APIs</h1>
			<p>API <a id="_idIndexMarker568"/>documentation is especially important in a microservices architecture for intuitive access to the API information, since an application can have multiple microservices and each microservice runs several API endpoints. <strong class="bold">OpenAPI</strong> is <a id="_idIndexMarker569"/>the <em class="italic">de facto</em> standard for any web services documentation. The <strong class="bold">Swagger framework</strong>, an<a id="_idIndexMarker570"/> implementation of OpenAPI, is integrated easily with a Micronaut microservice. We can easily document all our service endpoints using Swagger. In the following sections, we will explore how we can integrate Swagger into the <strong class="source-inline">pet-owner</strong> microservice. </p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor137"/>Using Swagger to document the pet-owner service endpoints</h2>
			<p>To start using <a id="_idIndexMarker571"/>Swagger in the<a id="_idIndexMarker572"/> <strong class="source-inline">pet-owner</strong> microservice, we first need to import the following dependency into the <strong class="source-inline">pom.xml</strong> project:</p>
			<p class="source-code">&lt;!-- Swagger --&gt;</p>
			<p class="source-code">&lt;dependency&gt;</p>
			<p class="source-code">  &lt;groupId&gt;io.swagger.core.v3&lt;/groupId&gt;</p>
			<p class="source-code">  &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;</p>
			<p class="source-code">  &lt;version&gt;${swagger.version}&lt;/version&gt;</p>
			<p class="source-code">  &lt;scope&gt;compile&lt;/scope&gt;</p>
			<p class="source-code">&lt;/dependency&gt;</p>
			<p>By importing the preceding dependency, we can leverage <a id="_idIndexMarker573"/>the <strong class="bold">Swagger v3</strong> toolbox in the pet-owner microservice. We can configure <strong class="source-inline">swagger.version</strong> in the prompt properties section. We will also need to amend the annotation processing so that the annotation processor can generate Swagger artifacts at compile time. Add the following path to the <strong class="source-inline">maven-compiler-plugin</strong> annotation processing paths:</p>
			<p class="source-code">&lt;path&gt;</p>
			<p class="source-code">  &lt;groupId&gt;io.micronaut.openapi&lt;/groupId&gt;</p>
			<p class="source-code">  &lt;artifactId&gt;micronaut-openapi&lt;/artifactId&gt;</p>
			<p class="source-code">  &lt;version&gt;2.3.1&lt;/version&gt;</p>
			<p class="source-code">&lt;/path&gt;</p>
			<p>Adding <strong class="source-inline">micronaut-openapi</strong> to the annotation processor paths will enable <strong class="source-inline">maven-compile</strong> to build the Swagger artifacts for the project. Once you have made the changes to the<a id="_idIndexMarker574"/> project prompt, add <a id="_idIndexMarker575"/>the following annotation to the main class:</p>
			<p class="source-code">@OpenAPIDefinition(</p>
			<p class="source-code">    info = @Info(</p>
			<p class="source-code">        title = "pet-owner-service",</p>
			<p class="source-code">        version = "1.0",</p>
			<p class="source-code">        description = "Pet Owner APIs"</p>
			<p class="source-code">    )</p>
			<p class="source-code">)</p>
			<p class="source-code">@Singleton</p>
			<p class="source-code">public class Application {</p>
			<p class="source-code">…</p>
			<p class="source-code">}</p>
			<p>Using the <strong class="source-inline">@OpenAPIDefinition</strong> annotation will create a Swagger artifact with the <strong class="source-inline">&lt;title&gt;-&lt;version&gt;.yml</strong> pattern in the generated sources. In our case, it will create the <strong class="source-inline">pet-owner-service-1.0.yml</strong> Swagger artifact when we build the project:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_7.3_B16585_Fixed.jpg" alt="Figure 7.3 – Generated Swagger artifact&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Generated Swagger artifact</p>
			<p>As shown in <em class="italic">Figure 7.3</em>, Swagger <a id="_idIndexMarker576"/>will create<a id="_idIndexMarker577"/> the <strong class="source-inline">pet-owner-service-1.0.yml</strong> artifact in the target folder. The generated text-only artifact can be opened in the Swagger Editor at <a href="https://editor.swagger.io/">https://editor.swagger.io/</a>:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_7.4_B16585_Fixed.jpg" alt="Figure 7.4 – Reviewing the Swagger YAML in the Editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Reviewing the Swagger YAML in the Editor</p>
			<p>Using the Swagger Editor<a id="_idIndexMarker578"/> to review the generated YAML is very intuitive. It provides a simple user interface for all the service endpoints including the option to try out an API call. Though Micronaut provides a mechanism to generate Swagger UI views, it's very new and requires a lot of changes. Therefore, using the standard Swagger Editor is an easier and quicker option.</p>
			<p>API documentation comes in handy when we have different product teams working on isolated microservices. Moreover, if a microservice is exposed to the end users, it's the go-to resource to know everything about a service endpoint. Continuing with this amalgamation journey, in the next section, we will implement service discovery for all the microservices in the <strong class="source-inline">pet-clinic</strong> application.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor138"/>Implementing service discovery</h1>
			<p>In the<a id="_idIndexMarker579"/> traditional monolithic architecture, if an application has multiple services then often these services are running on fixed and well-known locations (such as a URL or ports). This understanding of "well-known" is coupled into the code logic to make inter-service calls. A consumer service will call another service either at the code level or use hardcoded remote calls over the network. </p>
			<p>By contrast, often<a id="_idIndexMarker580"/> microservices are running in virtualized or containerized environments and IP ports are assigned dynamically. To facilitate inter-service calls, we implement service discovery. In the service discovery pattern, all the microservices will register their running instances with service discovery, and clients (that is, upstream clients or even another service) will then sync up with service discovery to get the network location of the required service. Furthermore, service discovery will maintain a continuous health check on all the registered services. In the following section, we will implement service discovery using Consul in the Micronaut framework.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor139"/>Implementing service discovery using Consul</h2>
			<p>To enable <a id="_idIndexMarker581"/>service discovery, you need to import<a id="_idIndexMarker582"/> the following dependency in the <strong class="source-inline">pom.xml</strong> project file. We have already added this to the <strong class="source-inline">pet-owner</strong> microservice; now add this to the <strong class="source-inline">pet-clinic</strong> and <strong class="source-inline">pet-clinic-reviews</strong> microservices as well:</p>
			<p class="source-code">&lt;!-- Service discovery --&gt;</p>
			<p class="source-code">    &lt;dependency&gt;</p>
			<p class="source-code">      &lt;groupId&gt;io.micronaut&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;micronaut-discovery-client&lt;/artifactId&gt;</p>
			<p class="source-code">    &lt;/dependency&gt;</p>
			<p>Once <strong class="source-inline">micronaut-discovery-client</strong> is imported into the services, we can leverage its service discovery capabilities.</p>
			<p>In order to synchronize the services with Consul, make the following changes in the <strong class="source-inline">pet-clinic</strong> and <strong class="source-inline">pet-clinic-reviews</strong> microservices:</p>
			<p class="source-code">consul:</p>
			<p class="source-code">  client:</p>
			<p class="source-code">    registration:</p>
			<p class="source-code">      enabled: true</p>
			<p>By making these changes, we enable the <strong class="source-inline">pet-clinic</strong> and <strong class="source-inline">pet-clinic-reviews </strong>microservices to register with Consul service discovery. Micronaut's <strong class="source-inline">micronaut-discovery-client</strong> implementation already has the required tools so we don't need to make<a id="_idIndexMarker583"/> any code changes. To verify that all the <a id="_idIndexMarker584"/>services are registered with Consul, just run the services and they will automatically register with their application name, as shown in the following screenshot:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">If you are using <strong class="bold">Apache Kafka</strong> in the <a id="_idIndexMarker585"/><strong class="source-inline">pet-clinic</strong> and <strong class="source-inline">pet-clinic-reviews</strong> microservices, then start up the Docker container for Apache Kafka before the services start up. </p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_7.5_B16585.jpg" alt="Figure 7.5 – Pet-clinic application service discovery&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Pet-clinic application service discovery</p>
			<p>After successful startups, all the microservices will register their instances with the Consul service discovery. We can view the running services by going to the <strong class="bold">Services</strong> screen on Consul. </p>
			<p>Though service <a id="_idIndexMarker586"/>discovery brings all the services under <a id="_idIndexMarker587"/>one umbrella by centralizing the runtime metadata (mainly the network locations), it still leaves a gap for upstream consumers as we don't have a unified interface yet. In the next section, we will implement an API gateway for the <strong class="source-inline">pet-clinic</strong> application, which will provide a unified interface for all the clients.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor140"/>Implementing the API gateway</h1>
			<p>To further the earlier discussion <a id="_idIndexMarker588"/>on dynamic network locations in the <em class="italic">microservices architecture</em>, we will focus on the API gateway now. The API gateway is an orchestrator service meant to provide unified, ubiquitous access to all the services. Though we can have multiple microservices running in the backend, an API gateway can provide a unified interface for the upstream consumers to access them. For the upstream consumers, the API gateway appears to be the only service running in the backend. On receiving a client request, the API gateway determines which service instance to call using service discovery. </p>
			<p>In order to learn how to implement the API gateway, we will add an API gateway service to the <strong class="source-inline">pet-clinic</strong> application. Since this microservice is an orchestrator service, we can call it <strong class="source-inline">pet-clinic-concierge</strong>. The system components after the gateway service would be as seen in <em class="italic">Figure 7.6</em>:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_7.6_B16585_Fixed.jpg" alt="Figure 7.6 – Pet Clinic Application with service discovery and an API gateway&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Pet Clinic Application with service discovery and an API gateway</p>
			<p>In the preceding<a id="_idIndexMarker589"/> diagram, we can see the <strong class="bold">API Gateway</strong> and <strong class="bold">Service Discovery</strong> orchestration in the <strong class="source-inline">pet-clinic</strong> application. The <strong class="source-inline">pet-clinic-concierge</strong> service will implement the API gateway, and any service consumer will invoke the gateway (not the service or service discovery), which will determine the service instance by synchronizing up with service discovery. The double-line connectors in the diagram show how an actual service request will be executed inside the <strong class="source-inline">pet-clinic</strong> application.</p>
			<p>In the next section, we will dive into how to implement the API gateway in the <strong class="source-inline">pet-clinic-concierge</strong> service.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/>Implementing the API gateway service</h2>
			<p>In order to<a id="_idIndexMarker590"/> learn how we can implement an API gateway in Micronaut, we will create a new service project called <strong class="source-inline">pet-clinic-concierge</strong>. To generate the boilerplate, follow the instructions:</p>
			<ol>
				<li value="1">Open <strong class="bold">Micronaut Launch</strong> by accessing <a href="https://micronaut.io/launch/">https://micronaut.io/launch/</a>.</li>
				<li>Select <strong class="bold">Micronaut Application</strong> from the <strong class="bold">Application Type</strong> dropdown.</li>
				<li>Select <strong class="bold">Java 13</strong> from the <strong class="bold">Java Version</strong> dropdown.</li>
				<li>Enter <strong class="source-inline">com.packtpub.micronaut</strong> in the <strong class="bold">Base Package</strong> input box.</li>
				<li>Enter <strong class="source-inline">pet-clinic-concierge</strong> in the <strong class="bold">Name</strong> input box.</li>
				<li>Select the following features from the <strong class="bold">Features</strong> multi-selection options:<p><strong class="bold">config-consul discovery-consul</strong></p><p><strong class="bold">http-client</strong></p><p><strong class="bold">netflix-hystrix</strong></p><p><strong class="bold">netflix-ribbon</strong></p><p><strong class="bold">openapi</strong></p></li>
				<li>Hit <strong class="bold">Generate Project</strong> button and select the <strong class="bold">Download Zip</strong> option.</li>
			</ol>
			<p>Micronaut Launch will now generate the boilerplate for the <strong class="source-inline">pet-clinic-concierge</strong> service. In Micronaut Launch, we opted for discovery and OpenAPI, so the boilerplate will have these features already enabled and configured. In the next section, we will explore implementing a unified service façade in the <strong class="source-inline">pet-clinic-concierge</strong> service.</p>
			<h3>Implementing a unified service façade for the API gateway</h3>
			<p>To <a id="_idIndexMarker591"/>begin, we<a id="_idIndexMarker592"/> will need to copy all the <strong class="bold">Data Transfer Objects </strong>(<strong class="bold">DTOs</strong>) to <a id="_idIndexMarker593"/>the <strong class="source-inline">pet-clinic-concierge</strong> service. These DTOs will be used in implementing clients for all the <strong class="source-inline">pet-clinic</strong> services. Copy all the DTOs in the <strong class="source-inline">pet-clinic-concierge</strong> project. We can then define the clients for all the RESTful services.</p>
			<p>In the next section, we will focus on defining the client for the <strong class="source-inline">pet-owner</strong> microservice.</p>
			<h4>Accessing pet-owner resources</h4>
			<p>To access the<a id="_idIndexMarker594"/> <strong class="source-inline">pet-owner</strong> resources, we will create clients under the <strong class="source-inline">com.packtpub.micronaut.web.rest.client.petowner</strong> package. For each resource controller in the <strong class="source-inline">pet-owner</strong> microservice, we will declare an HTTP client interface. The following is the client interface for <strong class="source-inline">OwnerResource</strong>:</p>
			<p class="source-code">@Client(id = "pet-owner")</p>
			<p class="source-code">public interface OwnerResourceClient {</p>
			<p class="source-code">    @Post("/api/owners")</p>
			<p class="source-code">    HttpResponse&lt;OwnerDTO&gt; createOwner(@Body OwnerDTO </p>
			<p class="source-code">     ownerDTO);</p>
			<p class="source-code">    @Put("/api/owners")</p>
			<p class="source-code">    HttpResponse&lt;OwnerDTO&gt; updateOwner(@Body OwnerDTO </p>
			<p class="source-code">     ownerDTO);</p>
			<p class="source-code">    @Get("/api/owners")</p>
			<p class="source-code">    HttpResponse&lt;List&lt;OwnerDTO&gt;&gt; getAllOwners(HttpRequest </p>
			<p class="source-code">     request, Pageable pageable);</p>
			<p class="source-code">    @Get("/api/owners/{id}")</p>
			<p class="source-code">    Optional&lt;OwnerDTO&gt; getOwner(@PathVariable Long id);</p>
			<p class="source-code">    @Delete("/api/owners/{id}")</p>
			<p class="source-code">    HttpResponse deleteOwner(@PathVariable Long id);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">@Client</strong> annotation will implement a concrete client. This client will integrate with a Consul service instance for the <strong class="source-inline">pet-owner</strong> service. We would need to declare all the RESTful methods exposed in <strong class="source-inline">OwnerResource</strong> with their relative paths.  </p>
			<p>Although<a id="_idIndexMarker595"/> post-build we will have a concrete <strong class="source-inline">OwnerResourceClient</strong>, we will still need to map the various RESTful methods in <strong class="source-inline">OwnerResourceClient</strong> to a local controller. This controller will then be exposed as a service façade for the upstream consumer. For <strong class="source-inline">OwnerResourceClient</strong> we can create <strong class="source-inline">OwnerResourceClientController</strong> as follows:</p>
			<p class="source-code">@Controller("/api")</p>
			<p class="source-code">public class OwnerResourceClientController {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    OwnerResourceClient ownerResourceClient;</p>
			<p class="source-code">    @Post("/owners")</p>
			<p class="source-code">    public HttpResponse&lt;OwnerDTO&gt; createOwner(OwnerDTO </p>
			<p class="source-code">     ownerDTO) {</p>
			<p class="source-code">        return ownerResourceClient.createOwner(ownerDTO);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Put("/owners")</p>
			<p class="source-code">    HttpResponse&lt;OwnerDTO&gt; updateOwner(@Body OwnerDTO </p>
			<p class="source-code">      ownerDTO) {</p>
			<p class="source-code">        return ownerResourceClient.updateOwner(ownerDTO);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Get("/owners")</p>
			<p class="source-code">    public HttpResponse&lt;List&lt;OwnerDTO&gt;&gt; </p>
			<p class="source-code">     getAllOwners(HttpRequest request, Pageable pageable) {</p>
			<p class="source-code">        return ownerResourceClient.getAllOwners(request, </p>
			<p class="source-code">         pageable);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Get("/owners/{id}")</p>
			<p class="source-code">    public Optional&lt;OwnerDTO&gt; getOwner(@PathVariable Long </p>
			<p class="source-code">     id) {</p>
			<p class="source-code">        return ownerResourceClient.getOwner(id);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Delete("/owners/{id}")</p>
			<p class="source-code">    HttpResponse deleteOwner(@PathVariable Long id) {</p>
			<p class="source-code">        return ownerResourceClient.deleteOwner(id);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In <strong class="source-inline">OwnerResourceClientController</strong>, we are injecting <strong class="source-inline">OwnerResourceClient</strong>. Any incoming request to <strong class="source-inline">OwnerResourceClientController</strong> will be passed to the client, which will then call a <a id="_idIndexMarker596"/><strong class="source-inline">pet-owner</strong> service instance (after syncing with Consul service discovery) for further processing. Similarly, you can implement <strong class="source-inline">Clients</strong> and <strong class="source-inline">Controllers</strong> for other resources in the <strong class="source-inline">pet-owner</strong> microservice. </p>
			<p>Next, we will implement the service façade for the <strong class="source-inline">pet-clinic</strong> resources as well.</p>
			<h4>Accessing the pet-clinic resources</h4>
			<p>To access the <a id="_idIndexMarker597"/><strong class="source-inline">pet-clinic</strong> resources we will create clients under the <strong class="source-inline">com.packtpub.micronaut.web.rest.client.petclinic</strong> package. For each resource controller in the <strong class="source-inline">pet-clinic</strong> microservice, we will declare an HTTP client interface. The following is the client interface for <strong class="source-inline">VetResource</strong>:</p>
			<p class="source-code">@Client(id = "pet-clinic")</p>
			<p class="source-code">public interface VetResourceClient {</p>
			<p class="source-code">    @Post("/api/vets")</p>
			<p class="source-code">    HttpResponse&lt;VetDTO&gt; createVet(@Body VetDTO vetDTO);</p>
			<p class="source-code">    @Put("/api/vets")</p>
			<p class="source-code">    HttpResponse&lt;VetDTO&gt; updateVet(@Body VetDTO vetDTO);</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">@Client</strong> annotation <a id="_idIndexMarker598"/>will implement a concrete client using the <strong class="source-inline">pet-clinic</strong> service instance in service discovery. To expose these methods on a service façade, we will implement <strong class="source-inline">VetResourceClientController</strong>:</p>
			<p class="source-code">@Controller("/api")</p>
			<p class="source-code">public class VetResourceClientController {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    VetResourceClient vetResourceClient;</p>
			<p class="source-code">    @Post("/vets")</p>
			<p class="source-code">    public HttpResponse&lt;VetDTO&gt; createVet(VetDTO vetDTO) {</p>
			<p class="source-code">        return vetResourceClient.createVet(vetDTO);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Put("/vets")</p>
			<p class="source-code">    public HttpResponse&lt;VetDTO&gt; updateVet(VetDTO vetDTO) {</p>
			<p class="source-code">        return vetResourceClient.updateVet(vetDTO);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>We are injecting <strong class="source-inline">VetResourceClient</strong> into <strong class="source-inline">VetResourceClientController</strong>, so any incoming request to the controller will be passed to the client, which will invoke a <strong class="source-inline">pet-clinic</strong> service instance for further processing. </p>
			<p>In the next section, our focus will be on implementing the service façade for <strong class="source-inline">pet-clinic-reviews</strong>.</p>
			<h4>Accessing the pet-clinic-reviews resources</h4>
			<p>For <a id="_idIndexMarker599"/>accessing <strong class="source-inline">pet-clinic-reviews</strong> resources, you will create clients under the <strong class="source-inline">com.packtpub.micronaut.web.rest.client.petclinicreviews</strong> package. We will first declare a client interface for <strong class="source-inline">VetReviewResource</strong>: </p>
			<p class="source-code">@Client(id = "pet-clinic-reviews")</p>
			<p class="source-code">public interface VetReviewResourceClient {</p>
			<p class="source-code">    @Post("/api/vet-reviews")</p>
			<p class="source-code">    HttpResponse&lt;VetReviewDTO&gt; createVetReview(@Body </p>
			<p class="source-code">      VetReviewDTO vetReviewDTO);</p>
			<p class="source-code">    @Put("/api/vet-reviews")</p>
			<p class="source-code">    HttpResponse&lt;VetReviewDTO&gt; updateVetReview(@Body </p>
			<p class="source-code">     VetReviewDTO vetReviewDTO);</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">@Client</strong> annotation will implement a concrete client using the <strong class="source-inline">pet-clinic-reviews</strong> service instance in service discovery. To expose these methods on a service façade we will implement <strong class="source-inline">VetReviewResourceClientController</strong>:</p>
			<p class="source-code">@Controller("/api")</p>
			<p class="source-code">public class VetReviewResourceClientController {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    VetReviewResourceClient vetReviewResourceClient;</p>
			<p class="source-code">    @Post("/vet-reviews")</p>
			<p class="source-code">    public HttpResponse&lt;VetReviewDTO&gt; </p>
			<p class="source-code">     createVetReview(VetReviewDTO vetReviewDTO) {</p>
			<p class="source-code">        return vetReviewResourceClient.createVetReview</p>
			<p class="source-code">         (vetReviewDTO);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Put("/vet-reviews")</p>
			<p class="source-code">    public HttpResponse&lt;VetReviewDTO&gt; </p>
			<p class="source-code">     updateVetReview(VetReviewDTO vetReviewDTO) {</p>
			<p class="source-code">        return vetReviewResourceClient.updateVetReview</p>
			<p class="source-code">         (vetReviewDTO);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>Here we inject <strong class="source-inline">VetReviewResourceClient</strong> into <strong class="source-inline">VetReviewResourceClientController</strong> and incoming requests to the controller will be <a id="_idIndexMarker600"/>passed to the client, which we will invoke on a <strong class="source-inline">pet-clinic-reviews</strong> service instance for further processing.</p>
			<p>In the next section, we will focus on handling fault tolerance concerns in regard to the microservices. </p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor142"/>Implementing the fault tolerance mechanisms</h1>
			<p>Faults and failures <a id="_idIndexMarker601"/>are inevitable in a microservice environment. As the numbers of distributed components increase, the number of faults both within each component and those originating from their interactions increase as well. Any microservices application must have built-in resilience for these unfortunate scenarios. In this section, we will explore and implement different ways to handle faults and failures in the Micronaut framework.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/>Leveraging built-in mechanisms</h2>
			<p>Micronaut is a <a id="_idIndexMarker602"/>cloud-native framework and has built-in capabilities to handle faults and failures. Essentially, its fault tolerance is driven by <strong class="bold">retry advice</strong>. Retry advice<a id="_idIndexMarker603"/> offers the <strong class="source-inline">@Retryable</strong> and <strong class="source-inline">@CircuitBreaker</strong> annotations that can be used in any HTTP client.</p>
			<h3>Using @Retryable in an HTTP client</h3>
			<p><strong class="bold">@Retryable</strong> is an effortless but effective fault tolerance mechanism – to put it simply, it's used to try again in case of a failure. These try attempts can be made again after a fixed delay and can<a id="_idIndexMarker604"/> continue until the service either responds back or <a id="_idIndexMarker605"/>no more attempts are left.</p>
			<p>To use <strong class="source-inline">@Retryable</strong> we can just annotate the client declaration. We can use <strong class="source-inline">@Retryable</strong> on <strong class="source-inline">OwnerResource</strong> as follows:</p>
			<p class="source-code">@Retryable(attempts = "5", delay = "2s", multiplier = "1.5", maxDelay = "20s")</p>
			<p class="source-code">@Client(id = "pet-owner")</p>
			<p class="source-code">public interface OwnerResourceClient {</p>
			<p class="source-code">  …</p>
			<p class="source-code">}</p>
			<p>By using <strong class="source-inline">@Retryable</strong> on <strong class="source-inline">OwnerResourceClient</strong> you enable fault-tolerance on all its methods. If the <strong class="source-inline">pet-owner</strong> microservice is down then <strong class="source-inline">OwnerResourceClient</strong> will retry attempting to establish the communication for a maximum of five attempts. We can configure <strong class="source-inline">@Retryable</strong> with the following settings:</p>
			<ul>
				<li><strong class="bold">attempts</strong>: This denotes the maximum number of retries the client can make. By default, this is 3 attempts.</li>
				<li><strong class="bold">delay</strong>: This marks the delay between the retries and is 1 second by default.</li>
				<li><strong class="bold">multiplier</strong>: This specifies the multiplier used to calculate the delay and is 1.0 by default.</li>
				<li><strong class="bold">maxDelay</strong>: This specifies the maximum overall delay and is empty by default. If specified, any retry attempts will be halted if retries reach the maximum delay limit. </li>
			</ul>
			<p><strong class="source-inline">@Retryable</strong> is well <a id="_idIndexMarker606"/>suited for temporary/momentary <a id="_idIndexMarker607"/>faults but for long-lasting faults, we would need to use the circuit breaker pattern. In the next section, we will see how we can use the circuit breaker in the Micronaut framework.</p>
			<h3>Using @CircuitBreaker in an HTTP client</h3>
			<p>As we <a id="_idIndexMarker608"/>discussed, failure in a highly distributed system such <a id="_idIndexMarker609"/>as microservices is inevitable. In a microservice architecture, if a service goes down there is another defensive mechanism to help avoid congesting the service traffic with more requests until the service is healthy again. This mechanism is called the <strong class="bold">circuit breaker</strong>. In <a id="_idIndexMarker610"/>normal circumstances, the circuit is open and accepting requests. On a failure instance, a counter is increased until it reaches a specified threshold. After reaching the threshold, the circuit is put into a closed state and the service will respond immediately with an error avoiding any timeouts. The circuit breaker has an internal polling mechanism to determine the health of the service and if the service is healthy again then the circuit is put back to an open state.</p>
			<p>We can simply use Micronaut's built-in annotation to specify a circuit breaker on an HTTP client. Let's implement a circuit breaker in <strong class="source-inline">PetResourceClient</strong>:</p>
			<p class="source-code">@Client(id = "pet-owner")</p>
			<p class="source-code">@CircuitBreaker(delay = "5s", attempts = "3", multiplier = "2", reset = "300s")</p>
			<p class="source-code">public interface PetResourceClient {</p>
			<p class="source-code">    @Post("/api/pets")</p>
			<p class="source-code">    HttpResponse&lt;PetDTO&gt; createPet(@Body PetDTO petDTO);</p>
			<p class="source-code">    @Put("/api/pets")</p>
			<p class="source-code">    HttpResponse&lt;PetDTO&gt; updatePet(@Body PetDTO petDTO);</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p>In the preceding circuit breaker implementation, if the <strong class="source-inline">PetResource</strong> endpoints fail then <strong class="source-inline">PetResourceClient</strong> will try five attempts, waiting for 3 seconds for the first attempt and a <a id="_idIndexMarker611"/>multiplier of two for future attempts. After five <a id="_idIndexMarker612"/>attempts, if the service is still not responding, then the circuit will be put into a closed state. It will try to access it again after a reset interval of 5 minutes to check if the service is healthy yet.</p>
			<h4>Using @Fallback for an HTTP client</h4>
			<p>Often in<a id="_idIndexMarker613"/> a circuit breaker implementation, there are <strong class="bold">feign clients</strong> or <strong class="bold">fallbacks</strong>. Instead <a id="_idIndexMarker614"/>of raising a server error when the circuit is closed, a <a id="_idIndexMarker615"/>fallback implementation can handle the request and respond <a id="_idIndexMarker616"/>normally. This is especially effective when the actual service call might be returning that a fallback can also return. </p>
			<p>In the following example of the circuit breaker in <strong class="source-inline">PetResourceClient</strong>, we can create a simple fallback that will handle the incoming requests when the circuit is closed:</p>
			<p class="source-code">@Fallback</p>
			<p class="source-code">public class PetResourceFallback implements PetResourceClient {</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public HttpResponse&lt;PetDTO&gt; createPet(PetDTO petDTO) {</p>
			<p class="source-code">        return HttpResponse.ok();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public HttpResponse&lt;PetDTO&gt; updatePet(PetDTO petDTO) {</p>
			<p class="source-code">        return HttpResponse.ok();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public HttpResponse&lt;List&lt;PetDTO&gt;&gt; </p>
			<p class="source-code">      getAllPets(HttpRequest request, Pageable pageable) {</p>
			<p class="source-code">        return HttpResponse.ok();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public Optional&lt;PetDTO&gt; getPet(Long id) {</p>
			<p class="source-code">        return Optional.empty();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    @Override</p>
			<p class="source-code">    public HttpResponse deletePet(Long id) {</p>
			<p class="source-code">        return HttpResponse.noContent();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">PetResourceFallback</strong> has default implementations of all the <strong class="source-inline">PetResource</strong> endpoints and it <a id="_idIndexMarker617"/>will provide a gracious response when <strong class="source-inline">PetResource</strong> is unaccessible. In this example, we return an empty response from <a id="_idIndexMarker618"/>all the endpoints. You can tinker with the implementation and create a default response as desired.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor144"/>Summary</h1>
			<p>In this chapter, you learned how to handle various microservice concerns in the Micronaut framework. We kickstarted the journey by externalizing the application configurations using Consul and learned why distributed configuration management is required in the microservices. We then dived into how to automate API documentation using OpenAPI and Swagger. Later, we discussed service discovery and the API gateway and implemented those in the pet clinic application. </p>
			<p>At last, we explored the need for fault tolerance and how you can simply use the built-in mechanism in the Micronaut framework for building resilience in your microservices application. </p>
			<p>This chapter has equipped you with all the first-hand knowledge you require to handle various microservice concerns relating to service discovery, API gateways, and fault tolerance. The chapter took a practical approach by adding to the pet-clinic application while covering these aspects.</p>
			<p>In the next chapter, you will explore various ways to deploy the <strong class="source-inline">pet-clinic</strong> microservice application.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor145"/>Questions</h1>
			<ol>
				<li value="1">What is distributed configuration management?</li>
				<li>How can you implement a configuration store in Consul?</li>
				<li>How can you automate the process of API documentation using Swagger in the Micronaut framework?</li>
				<li>What is service discovery?</li>
				<li>How can you implement service discovery in the Micronaut framework?</li>
				<li>What is an API gateway in the microservices architecture?</li>
				<li>How can you implement an API gateway in the Micronaut framework?</li>
				<li>What is <strong class="source-inline">@Retryable</strong> in Micronaut?</li>
				<li>What is <strong class="source-inline">@CircuitBreaker</strong> in Micronaut?</li>
				<li>How can you implement a circuit breaker in the Micronaut framework?</li>
				<li>How can you implement a fallback in Micronaut?</li>
			</ol>
		</div>
	</body></html>