- en: Chapter 5. BPMN Constructs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。BPMN 构造
- en: 'To classify the level of support that a BPMN software tool provides, the BPMN
    standard defines the "conformance classes" as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分类 BPMN 软件工具提供的支持级别，BPMN 标准定义了“一致性类别”如下：
- en: '**Process Modeling Conformance**: This class includes the BPMN core elements,
    process, collaboration, and conversation diagrams. It defines subclasses that
    contain a limited set of visual elements (descriptive), an extended set of modeling
    elements (analytical), and modeling elements that are required to model executable
    processes (common executable).'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程建模一致性**：此类包括 BPMN 核心元素、流程、协作和对话图。它定义了包含有限视觉元素（描述性）、扩展建模元素（分析性）以及建模执行流程所需元素（通用可执行）的子类。'
- en: '**Process Execution Conformance**: It requires a software tool to support the
    operational semantics of BPMN.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程执行一致性**：它要求软件工具支持 BPMN 的操作语义。'
- en: '**Choreography Modeling Conformance**: The choreography modeling conformance
    class includes the BPMN core elements and the collaboration and choreography diagrams.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排建模一致性**：编排建模一致性类别包括 BPMN 核心元素和协作与编排图。'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: jBPM supports a great part of the Common Executable class, with additional extensions.
    Please check [Chapter 6](ch06.html "Chapter 6. Core Architecture"), *Core Architecture*,
    of the jBPM 6.2 user guide for insights into the topic.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM 支持大部分的通用可执行类别，并增加了额外的扩展。请查阅 jBPM 6.2 用户指南的[第 6 章](ch06.html "第 6 章。核心架构")，*核心架构*，以了解该主题的见解。
- en: jBPM introduced the implementation of the BPMN 2.0 specification with the jBPM
    5 release, for both the graphical notation (element visual representation) and
    the XML serialization, easing the task of exchanging process definitions between
    developers and the business team (in terms of Eclipse-based BPMN editor and process
    Web-based designer interoperability).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM 在 jBPM 5 版本中引入了 BPMN 2.0 规范的实现，包括图形符号（元素视觉表示）和 XML 序列化，简化了开发者和业务团队之间交换流程定义的任务（就基于
    Eclipse 的 BPMN 编辑器和基于 Web 的流程设计器互操作性而言）。
- en: 'Other jBPM BPMN notable features are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 jBPM BPMN 显著特性如下：
- en: Compliance with the BPMN process execution semantics ("Common Executable" subclass
    specification)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循 BPMN 流程执行语义（“通用可执行”子类规范）
- en: The BPMN **DI** (which stands for **Diagram Interchangeability**) specification
    for storing diagram information
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPMN **DI**（代表**图互操作性**）规范用于存储图信息
- en: The BPMN I/O specification for input/output mapping
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPMN 输入/输出映射规范
- en: In [Chapter 1](ch01.html "Chapter 1. Business Process Modeling – Bridging Business
    and Technology"), *Business Process Modeling – Bridging Business and Technology*,
    we already had an overview of the main BPMN concepts, constructs, and modeling
    patterns. We selected the topics for this chapter not to provide you with a BPMN
    modeling or reference guide, but as hands-on, example-driven explanation of all
    BPMN constructs supported by jBPM, without completely hiding away the underlying
    technical details.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.html "第 1 章。业务流程建模 – 连接业务与技术")，*业务流程建模 – 连接业务与技术*中，我们已经对主要的 BPMN
    概念、构造和建模模式进行了概述。我们选择本章的主题，不是为了提供 BPMN 建模或参考指南，而是为了提供一个实际的、以示例驱动的解释，说明 jBPM 支持的所有
    BPMN 构造，同时不隐藏其背后的技术细节。
- en: 'In this chapter, we will discuss the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: The concept behind the BPMN construct
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPMN 构造背后的概念
- en: How to use it in a business process (with examples)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在业务流程中使用它（示例）
- en: Best practices for when and where to use BPMN constructs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 BPMN 构造的最佳实践
- en: Parameters, variables, and data
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数、变量和数据
- en: 'Most of the time, business processes are data-driven processes: tasks handle
    variables, and rules handle facts; you will not be asked to draw a BPMN diagram
    without handling variables, parameters, objects, and states coming from external
    systems, user input, and other sources. A majority of the jBPM constructs are
    useless without data. Let us clarify the basics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，业务流程是数据驱动的流程：任务处理变量，规则处理事实；在没有处理来自外部系统、用户输入和其他来源的变量、参数、对象和状态的情况下，不会要求你绘制
    BPMN 图形。大多数 jBPM 构造在无数据的情况下都是无用的。让我们澄清基本概念：
- en: '**Parameters**: These are the data input coming from the user through the API.
    The user can pass parameters during process creation, at a human task completion,
    or into a service task for a Web service call.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这些是通过 API 从用户那里传入的数据输入。用户可以在流程创建期间、在人工任务完成时或向 Web 服务调用中的服务任务传递参数。'
- en: '**Variables**: Variables are objects living in the scope of a single process
    instance. Variables can be created directly inside a process instance construct
    (for example, Script Activity and Data Object) or can be mapped from/to other
    variables (Data Input/Output Mapping) defined in another scope, for example, from
    the main process to a subprocess, from the process to a human task, and so on.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：变量是存在于单个流程实例作用域内的对象。变量可以直接在流程实例结构内部创建（例如，脚本活动和数据对象）或从另一个作用域中的其他变量（数据输入/输出映射）映射而来，例如，从主流程到子流程，从流程到人工任务等。'
- en: '**Globals**: Static variables shared across different process instances for
    a single Kie working session.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局变量**：在单个Kie工作会话中跨不同流程实例共享的静态变量。'
- en: '**Facts**: Data that can be added to the Kie session and then updated or removed
    (retracted). This information is inserted, technically speaking, into the session
    through channels named **entry points,** and evaluated according to the Drools
    business rules, for activation. Drools Agenda manages the rule activation and
    firing mechanism.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事实**：可以添加到Kie会话中的数据，然后更新或删除（撤回）。从技术上讲，这些信息通过名为**入口点**的通道插入到会话中，并根据Drools业务规则进行评估以激活。Drools议程管理规则激活和触发机制。'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to Drools reference documentation for additional details on facts,
    rules, entry points, Agenda, and the Drools rule engine in general: [https://docs.jboss.org/drools/release/6.2.0.Final/drools-docs/html](https://docs.jboss.org/drools/release/6.2.0.Final/drools-docs/html).
    Drools and jBPM are complementary projects that integrate together very nicely.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅Drools参考文档以获取有关事实、规则、入口点、议程以及Drools规则引擎的一般信息的更多详细信息：[https://docs.jboss.org/drools/release/6.2.0.Final/drools-docs/html](https://docs.jboss.org/drools/release/6.2.0.Final/drools-docs/html)。Drools和jBPM是互补的项目，它们可以很好地集成在一起。
- en: 'Variables and globals are accessed through context-type implicit references
    made available to the jBPM constructs at runtime:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和全局变量通过在运行时提供给jBPM结构的上下文类型隐式引用来访问：
- en: '`ProcessContext` (`kcontext`): This gives you access to variables'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessContext`（`kcontext`）：这为您提供了访问变量的权限'
- en: '`KieRuntime` (`kcontext.getKieRuntime()`): This gives you access to globals
    and facts'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KieRuntime`（`kcontext.getKieRuntime()`）：这为您提供了访问全局和事实的权限'
- en: There are no implementation constraints on parameters, variables, and global
    class types apart from implementing the `java.io.Serialization` interface. Remember
    in fact that jBPM uses the standard in-memory serialization mechanism (`readObject`/`writeObject`).
    When we enable persistence, it features an additional custom object marshalling
    mechanism to and from the store for session and process instances (see *Marshalling*
    in [Chapter 7](ch07.html "Chapter 7. Customizing and Extending jBPM"), *Customizing
    and Extending jBPM*). Furthermore, when there are persisting process variables
    for auditing and logging (`VARIABLEINSTANCELOG` table), jBPM stores the values
    by calling the process variable `toString()` method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现`java.io.Serialization`接口外，对参数、变量和全局类类型没有实现约束。实际上，记住jBPM使用的是标准的内存序列化机制（`readObject`/`writeObject`）。当我们启用持久化时，它还具备一个额外的自定义对象序列化机制，用于会话和流程实例的存储和检索（参见[第7章](ch07.html
    "第7章. 定制和扩展jBPM")中的*序列化*，*定制和扩展jBPM*）。此外，当存在用于审计和记录的持久化流程变量（`VARIABLEINSTANCELOG`表）时，jBPM通过调用流程变量的`toString()`方法来存储这些值。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: jBPM does not provide out-of-the-box process variable persistence in any of
    its schema tables. We need to implement our ad-hoc variable serialization strategy
    (we will cover variables persistence with *Marshalling* in [Chapter 7](ch07.html
    "Chapter 7. Customizing and Extending jBPM"), *Customizing and Extending jBPM*.).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM在其任何架构表中都不提供开箱即用的流程变量持久化。我们需要实现我们的专用变量序列化策略（我们将在[第7章](ch07.html "第7章. 定制和扩展jBPM")中介绍变量持久化，*定制和扩展jBPM*）。
- en: Sequence flow
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序流
- en: 'The sequence flow is the connector between two elements of the process. It
    represents a flow of execution. A sequence flow may optionally have a condition
    defined (conditional sequence flow). The engine always evaluates a task node''s
    outgoing sequence flows: If the condition evaluates to true then the engine selects
    and follows that sequence flow; a sequence flow with no condition defined is always
    followed by the engine. A **diamond shaped** connector (see [Appendix B](apb.html
    "Appendix B. jBPM BPMN Constructs Reference"), *jBPM BPMN Constructs Reference,
    Gateways* section for some pictorial examples) indicates a conditional sequence
    flow. Multiple sequence flows represent branching and merging without the usage
    of a gateway. Gateways, depending on their nature, handle conditional sequence
    flows in specific ways as we are about to see.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序流程是流程中两个元素之间的连接器。它表示执行流程。顺序流程可以可选地定义一个条件（条件顺序流程）。引擎始终评估任务节点的输出顺序流程：如果条件评估为真，则引擎选择并遵循该顺序流程；没有定义条件的顺序流程始终由引擎跟随。一个**菱形**连接器（见[附录B](apb.html
    "附录 B. jBPM BPMN 构造参考"），*jBPM BPMN 构造参考，网关*部分中的一些图示示例）表示条件顺序流程。多个顺序流程表示使用网关的情况下没有分支和合并。网关根据其性质，以特定方式处理条件顺序流程，正如我们即将看到的。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: jBPM allows you to enable multiple outgoing conditional sequence flows from
    a task by setting the `jbpm.enable.multi.con` system property to `true` (default
    is `false`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM允许您通过将`jbpm.enable.multi.con`系统属性设置为`true`（默认为`false`）来从任务启用多个输出条件顺序流程。
- en: The following example process (see the figure) shows how the `jbpm.enable.multi.con`
    property affects the sequence flow behavior.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例流程（见图）展示了`jbpm.enable.multi.con`属性如何影响顺序流程行为。
- en: '![Sequence flow](img/9578OS_05_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![顺序流程](img/9578OS_05_01.jpg)'
- en: 'Example test class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Example process:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Description: The test creates the process instance with an `Order` variable
    with different cost values. The process, thanks to the `jbpm.enable.multi.con`
    system property set to `TRUE`, allows the execution of multiple (here, we have
    two) conditional sequence flows that diverge from a single Script Activity. The
    first sequence flow is taken if the Order costs more than 10, while the second
    one is taken when the Order cost is ≤10.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：该测试创建了一个具有`Order`变量和不同成本值的流程实例。由于将`jbpm.enable.multi.con`系统属性设置为`TRUE`，该流程允许执行多个（此处有两个）从单个脚本活动发散的条件顺序流程。如果订单成本超过10，则选择第一条顺序流程，而当订单成本≤10时，则选择第二条顺序流程。
- en: Gateways
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关
- en: 'Gateways are elements that allow you to create branches in your process. These
    branches can be, conceptually, diverging or converging. You can model the behavior
    of the different types of business process sequence flows: conditional branching
    (inclusive and exclusive), forking, merging, and joining.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 网关是允许您在流程中创建分支的元素。从概念上讲，这些分支可以是发散或汇聚的。您可以建模不同类型的业务流程顺序流程的行为：条件分支（包含和排除）、分支、合并和连接。
- en: 'Let us first review the key gateway concepts and the practical examples in
    the upcoming sections:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下即将在下一节中讨论的关键网关概念和实际示例：
- en: 'Fork (split) indicates a flow dividing into two or more paths that should execute
    in a logically parallel (concurrent) way: jBPM, for implementation reasons, never
    executes parallel flows concurrently (at the thread level) but always sequentially,
    one step at a time'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支（分裂）表示流程分为两个或更多应逻辑并行（并发）执行的路径：由于实现原因，jBPM永远不会并发（在线程级别）执行并行流程，而是始终顺序执行，一次一步
- en: Join (or synchronization) refers to the combining of two or more parallel paths
    into one path
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并联（或同步）指的是将两个或更多并行路径合并为一条路径
- en: Branch (or decision) is a point where the control flow can take one or more
    alternative paths
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支（或决策）是控制流可以采取一个或多个替代路径的点
- en: Merge refers to a process point where two or more alternative sequence flow
    paths are combined into a single sequence flow path
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并指的是两个或更多替代顺序流程路径合并为单个顺序流程路径的过程点
- en: 'Hence, the gateway **direction** property is defined as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，网关**方向**属性定义如下：
- en: '**Unspecified**: May have both multiple incoming and outgoing connections'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未指定**：可能具有多个输入和输出连接'
- en: '**Mixed**: Multiple incoming and outgoing connections'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：多个输入和输出连接'
- en: '**Converging**: Multiple incoming connections and only one outgoing connection'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇聚**：多个输入连接和仅一个输出连接'
- en: '**Diverging**: Only one incoming connection and multiple outgoing sequence
    flows'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支**：只有一个入连接和多个出序列流'
- en: Unspecified and mixed directions are not implemented
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 未指定和混合方向尚未实现
- en: Let us now see how these BPM concepts translate into jBPM modeling elements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些BPM概念如何转换为jBPM建模元素。
- en: Parallel (AND) gateway
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行（AND）网关
- en: This gateway allows us to fork into multiple paths of execution or to join multiple
    incoming paths of execution. When used to fork a sequence flow (diverging or AND-split),
    all outgoing branches are activated simultaneously. When joining parallel branches
    (converging or AND-join), it waits for all incoming branches to complete before
    moving to the outgoing sequence flow. This gateway must be used when many activities
    have to be carried out at the same time in any particular order.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此网关允许我们进入多个执行路径或连接多个执行路径。当用于分支序列流（分支或AND分裂）时，所有出分支同时激活。当连接并行分支（汇聚或AND连接）时，它等待所有入分支完成后再移动到出序列流。当需要在任何特定顺序同时执行许多活动时，必须使用此网关。
- en: 'Example test class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Example process:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Description: The plan route script task calculates the order delivery route,
    while the **Prepare Ingredients** human task adds some mozzarella to the order
    bill of materials. The closing **Done** Script task displays the result after
    all outgoing flows are complete.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：计划路线脚本任务计算订单配送路线，而**准备原料**人工任务向订单物料清单中添加一些马苏里拉奶酪。关闭**完成**脚本任务在所有出流完成后显示结果。
- en: '![Parallel (AND) gateway](img/9578OS_05_22.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![并行（AND）网关](img/9578OS_05_22.jpg)'
- en: Conditional branching
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件分支
- en: 'These gateways introduce the *condition expression*. The condition expressions
    linked to each of the outgoing/incoming sequence flows are evaluated during process
    execution using process data (data-based gateways). Optionally, one of the gateway
    outgoing paths can be flagged as the **default flow** (its condition is ignored):
    this path is taken only if none of the other path flows can be selected. The default
    (sequence) flow is visually marked with a slash mark as shown in the following
    image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些网关引入了*条件表达式*。与每个出/入序列流链接的条件表达式在过程执行期间使用过程数据（基于数据的网关）进行评估。可选地，可以将网关的一个出路径标记为**默认流**（其条件被忽略）：只有当其他路径流都无法选择时，才会采取此路径。默认（序列）流在以下图像中以斜杠标记进行视觉标记：
- en: '![Conditional branching](img/9578OS_05_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![条件分支](img/9578OS_05_02.jpg)'
- en: The "default flow" property is supported in the Exclusive and Inclusive Gateway
    elements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在排他和包含网关元素中支持“默认流”属性。
- en: Drools
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Drools
- en: 'We briefly introduced Drools facts and rules in the first section. Conditional
    branching based on Drools expressions works with facts but not with process variables.
    If we want to leverage the Drools expression features in the gateway constructs,
    we have to insert the process variable as a Drools fact, for example, given the
    process variable `order`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一部分简要介绍了Drools事实和规则。基于Drools表达式的条件分支与事实一起工作，但不与过程变量一起工作。如果我们想在网关结构中利用Drools表达式功能，我们必须将过程变量作为Drools事实插入，例如，给定过程变量`order`：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From inside the process definition (by a Script task, a Task **on exit** Script,
    and so on), we insert the following fact:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从过程定义内部（通过脚本任务、**退出**脚本等），我们插入以下事实：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, we can do so by using the API as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过以下API来实现：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Exclusive (XOR) gateway
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排他（XOR）网关
- en: It is used to model a decision in the process. More than one path cannot be
    taken; the paths are mutually exclusive, hence, the name. In case multiple sequence
    flows have a condition that evaluates to true, the first one defined in the XML
    is selected for continuing the process. In an exclusive gateway, all outgoing
    sequence flows should have conditions defined on them. The default sequence flow
    is an exception to this rule.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于在过程中建模一个决策。不能采取多条路径；路径是互斥的，因此得名。如果有多个序列流具有评估为真的条件，则选择在XML中定义的第一个路径以继续过程。在排他网关中，所有出序列流都应该定义条件。默认序列流是此规则的例外。
- en: 'Example test class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Example process:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Description: Different paths are taken for successful Pizza deliveries; the
    default path is chosen when other conditions are not met.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：对于成功的披萨配送，采取不同的路径；当其他条件不满足时，选择默认路径。
- en: '![Exclusive (XOR) gateway](img/9578OS_05_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![排他（XOR）网关](img/9578OS_05_03.jpg)'
- en: Inclusive (OR) gateway
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含（OR）网关
- en: An inclusive gateway is a branching point of the business process. Unlike the
    exclusive gateway, an inclusive gateway may trigger more than one outgoing flow
    and execute them in parallel (such as the parallel gateway). So, with diverging
    behavior, the gateway will always evaluate all outgoing sequence flow conditions,
    regardless of whether it already has a satisfied outgoing flow or not (unlike
    the exclusive gateway). In the case of converging behavior, the gateway will wait
    until all the incoming active sequence flows have reached it (merging). We can
    usually use this construct in a pair of splitting/merging gateways (see the following
    example) when we need to fork executions depending on certain conditions and then
    rejoin them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包容网关是业务流程的分支点。与排他网关不同，包容网关可以触发多个输出流并在并行中执行它们（例如并行网关）。因此，在分支行为中，网关将始终评估所有输出序列流条件，无论它是否已经有一个满足的输出流（与排他网关不同）。在合并行为的情况下，网关将等待直到所有进入的激活序列流都到达它（合并）。当我们需要根据某些条件分叉执行并在之后重新连接它们时，我们通常可以在一对拆分/合并网关中使用此结构（参见以下示例）。
- en: 'Example test class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Example process:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Inclusive (OR) gateway](img/9578OS_05_23.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![包容（OR）网关](img/9578OS_05_23.jpg)'
- en: 'Description: Multiple different paths are taken for evaluation of the order
    delivery status; the `testIssues` test is set up so as to make the process take
    both the **delivery not on time** (`deliveryDate` > `dueDate`) and the **retries
    > 1** path. The default path is chosen when other conditions are not met (see
    the `testNoIssues` test).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：为了评估订单交付状态，采取了多条不同的路径；`testIssues` 测试被设置成使流程同时采取**未按时交付**（`deliveryDate`
    > `dueDate`）和**重试次数 > 1**的路径。当其他条件不满足时，选择默认路径（参见`testNoIssues`测试）。
- en: Event-based gateways
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于事件的网关
- en: Event-based gateways are similar to exclusive gateways, but the gateway trigger
    is based on event occurrence instead of condition evaluation. When our process
    arrives at an event-based gateway, we will have to wait until something happens.
    A specific event, usually the receipt of a message, determines the path that will
    be taken. Basically, the decision is made by another actor on the basis of data
    that is not visible to a process. This gateway is always a diverging gateway and
    must have at least one event attached.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件的网关与排他网关类似，但网关触发是基于事件发生而不是条件评估。当我们的流程到达基于事件的网关时，我们将必须等待直到发生某些事情。一个特定的事件，通常是收到消息，决定了将要采取的路径。基本上，决策是由另一个不可见于流程的数据的演员做出的。此网关始终是一个分支网关，并且必须至少有一个事件附加。
- en: 'Example test class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Example process:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Event-based gateways](img/9578OS_05_24.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![基于事件的网关](img/9578OS_05_24.jpg)'
- en: 'Description: The event gateway has a timer attached; when the timer expires,
    the **send alert** script is executed, bringing the process to termination.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：事件网关附加了一个计时器；当计时器到期时，将执行**发送警报**脚本，使流程终止。
- en: Instantiating gateway
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例化网关
- en: 'The instantiating gateway is a specialized event-based gateway, which triggers
    the process instantiation as soon as an attached event is received. The "instantiate"
    option (as of jBPM 6.2 the option is available in the jBPM Eclipse plug-in only)
    configures the gateway as a diverging gateway with no incoming connections: this
    gives you a way to instantiate a process by using an event, such as timer expiration
    or a catching signal event (see the following sections for timers and signals).
    jBPM does not support a pure instantiating gateway with no incoming connection:
    you always have to link it to a Start "None" event (see the following figure)
    or the process compilation will fail (complaining with a "missing incoming connection"
    error)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化网关是一种特殊的事件网关，它一收到附加的事件就触发流程实例化。"实例化"选项（截至jBPM 6.2，此选项仅在jBPM Eclipse插件中可用）将网关配置为没有输入连接的分支网关：这为您提供了通过事件实例化流程的方法，例如计时器到期或捕获信号事件（参见以下章节中的计时器和信号）。jBPM不支持没有输入连接的纯实例化网关：您始终必须将其链接到"无"启动事件（参见以下图示）或流程编译将失败（报错"缺少输入连接"）。
- en: 'Example test class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Example process:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Description: Depending on events sent from an external (API call), different
    paths are taken (the `testCustomerPhoneCallEvent` and `testDeliveredEvent` methods);
    the timer triggers after 15 s if no event is caught (the `testTimerExpired` method).
    Note that both catching events pass the signal data (a randomly generated `orderid`
    string) to the process parameter `orderid`, which is later printed from the script
    tasks.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：根据从外部（API调用）发送的事件，不同的路径会被采取（`testCustomerPhoneCallEvent`和`testDeliveredEvent`方法）；如果在15秒内没有捕获到事件，计时器会触发（`testTimerExpired`方法）。请注意，捕获事件都会将信号数据（一个随机生成的`orderid`字符串）传递给过程参数`orderid`，该参数随后会在脚本任务中打印出来。
- en: '![Instantiating gateway](img/9578OS_05_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![实例化网关](img/9578OS_05_04.jpg)'
- en: Complex gateway
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂网关
- en: This gateway can be used to model complex synchronization behavior. The construct
    options are available at the designer level, but jBPM has no implementation for
    this construct.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此网关可用于建模复杂的同步行为。构造选项在设计师级别可用，但jBPM没有对此结构进行实现。
- en: Events
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'Events are elements used to model something that happens during the process
    lifetime. BPMN 2.0 defines two main event categories: **catching** and **throwing**
    events.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是用于在过程生命周期中建模发生的事情的元素。BPMN 2.0定义了两个主要的事件类别：**捕获**和**抛出**事件。
- en: '**Catching**: This event represents a pausing point in the process execution:
    Once the process flow reaches the catching event node, it stops in the wait state,
    waiting for a specific trigger to happen.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获**：此事件表示过程执行中的暂停点：一旦流程达到捕获事件节点，它将停止在等待状态，等待特定触发器发生。'
- en: '**Throwing**: This event represents an action generating an event. When process
    execution reaches the event construct, an action is performed and a trigger is
    fired. For this throwing event, depending on the event type, there could be a
    matching catching event or not, that is, a send signal (throwing)/catch signal
    or send error (throwing)/catch error. On the other hand, the compensate throw
    event does not have a catch companion, while the timer event is always a catching
    event.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抛出**：此事件表示生成事件的动作。当过程执行达到事件构造时，会执行一个动作并触发一个触发器。对于此抛出事件，根据事件类型，可能存在匹配的捕获事件，也可能不存在，即发送信号（抛出）/捕获信号或发送错误（抛出）/捕获错误。另一方面，补偿抛出事件没有对应的捕获事件，而计时器事件始终是捕获事件。'
- en: 'Events are also categorized according to other criteria:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 事件还可以根据其他标准进行分类：
- en: An event can appear at the beginning of a process (Start event), within a process
    (Intermediate event), or at the end of a process (End event)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件可以出现在过程的开始（开始事件）、过程中（中间事件）或过程的结束（结束事件）。
- en: 'An event can be generic or one of the different predefined types: time-based,
    message-based, signal-based, rule-based, exception-based, and so on'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件可以是通用的，或者是以下预定义类型之一：基于时间的、基于消息的、基于信号的、基于规则的、基于异常的等等。
- en: An event can be positioned within a sequence flow or attached at the boundary
    of an activity (Boundary event)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件可以位于序列流内，也可以附加在活动的边界上（边界事件）。
- en: An event can exit the current process execution or not
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件可以退出当前过程执行，也可以不退出。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A note before we start:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前的一个注意事项：
- en: To facilitate reading, we'll go through the events by grouping them by event
    type (Start, Boundary, End) and then illustrating the supported variations (catching/throwing
    and start/intermediate/boundary/end) for each type of event (Signal, Message,
    Timer…).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，我们将通过按事件类型（开始、边界、结束）分组事件，然后展示每种事件类型（信号、消息、计时器等）支持的变体（捕获/抛出和开始/中间/边界/结束）。
- en: For additional information and a complete jBPM constructs reference (ordered
    the same way as you will find in both the Eclipse BPMN modeling tool palette and
    the KIE console palette), please refer to [Appendix B](apb.html "Appendix B. jBPM
    BPMN Constructs Reference"), *jBPM BPMN Constructs Reference*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多信息以及完整的jBPM结构参考（按与您在Eclipse BPMN建模工具调色板和KIE控制台调色板中找到的相同方式排序），请参阅[附录B](apb.html
    "附录 B. jBPM BPMN 结构参考")，*jBPM BPMN 结构参考*。
- en: Start events
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始事件
- en: The start event defines where (and how) the process is started; Start events
    are catching-only events. When a specific start event trigger fires (timer, messages,
    signal, and so on) the process is started. We will now see the None Start event;
    the other start event types are discussed in their respective sections.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 开始事件定义了过程开始的位置（以及方式）；开始事件是仅捕获事件。当特定的开始事件触发器被触发（计时器、消息、信号等）时，过程开始。我们现在将看到无开始事件；其他开始事件类型将在各自的章节中讨论。
- en: 'Supported start events are: None, Message, Timer, Escalation, Conditional,
    Error, Compensation, Signal'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的开始事件有：无、消息、定时器、升级、条件、错误、补偿、信号
- en: None Start event
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无开始事件
- en: The simplest form of a Start event is the None Start event. It technically means
    that the trigger for starting the process instance is not specified; in other
    words, the engine does not know when the process instance is to be started. The
    only way to start the process is by invoking the `startProcess` method on a Kie
    session reference.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的开始事件形式是无开始事件。从技术上讲，这意味着启动流程实例的触发器未指定；换句话说，引擎不知道何时启动流程实例。启动流程的唯一方法是通过对Kie会话引用调用`startProcess`方法。
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: End events
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束事件
- en: The End events are meant to express the end of a process or subprocess, and
    they are always throwing events. When the process execution arrives in the End
    event node, the associated event type is thrown. A process definition can have
    one or more End events defined. In this section, we will see the None and the
    Terminate End event; the other End event types are discussed in their respective
    sections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 结束事件旨在表达流程或子流程的结束，并且它们总是抛出事件。当流程执行到达结束事件节点时，将抛出相关的事件类型。一个流程定义可以定义一个或多个结束事件。在本节中，我们将看到“无”和“终止”结束事件；其他结束事件类型将在各自的章节中讨论。
- en: 'Supported end events are: None, Message, Escalation, Error, Cancel, Compensation,
    Signal, Terminate'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的结束事件有：无、消息、升级、错误、取消、补偿、信号、终止
- en: (None) End event
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: （无）结束事件
- en: The None End event throws no events, and the engine just ends the current process
    instance sequence flow execution. If there are no more active sequence flows or
    nothing else to be performed (activities), the process instance is completed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无结束事件不会抛出任何事件，引擎只是结束当前流程实例的序列流执行。如果没有更多的活动序列流或没有其他要执行的操作（活动），则流程实例完成。
- en: Terminate End event
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终止结束事件
- en: The Terminate End event brings the process instance to the Completed state;
    all pending tasks, active sequence flows, and subprocesses are aborted.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 终止结束事件将流程实例带到完成状态；所有挂起的任务、活动序列流和子流程都将被中止。
- en: Boundary events
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界事件
- en: Boundary events are events (always catching) that are graphically attached to
    an activity (subprocesses included) boundary (see the following figure). The event
    is registered for a certain type of trigger (see the following supported boundary
    events) and reacts only within the scope of the execution of the attached activity,
    with slight variations depending on the event type. In case the event triggers,
    it can optionally cancel the activity that it is attached to (by its `cancelActivity`
    property), and the event's outgoing sequence flow is executed. The boundary events
    are activated when the attached activity is started; in other words, they are
    bound to the activity instance life cycle. When the engine process execution path
    leaves the activity, all its attached boundary events are deactivated and their
    triggering is cancelled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 边界事件是事件（总是捕获），它们以图形方式附加到活动（包括子流程）的边界（参见以下图）。事件注册为某种类型的触发器（参见以下支持的边界事件），并且仅在附加活动的执行范围内做出反应，根据事件类型略有不同。如果事件被触发，它可以选择取消附加到其上的活动（通过其`cancelActivity`属性），并执行事件的输出序列流。边界事件在附加活动启动时被激活；换句话说，它们绑定到活动实例的生命周期。当引擎流程执行路径离开活动时，所有附加的边界事件都将被停用，并且它们的触发将被取消。
- en: 'Supported boundary events are: Conditional, Error, Escalation, Message, Signal,
    Timer'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的边界事件有：条件、错误、升级、消息、信号、定时器
- en: See the *Boundary Message event* section for a working example.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*边界消息事件*部分以获取一个工作示例。
- en: '![Boundary events](img/9578OS_05_05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![边界事件](img/9578OS_05_05.jpg)'
- en: Signal events
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号事件
- en: A signal is a generic, simple form of communication, such as messages (see below).
    We can use signals to synchronize and exchange information. A catching signal
    may not have a corresponding throwing signal construct. It can also be sent programmatically
    from an external source (API). In contrast to other events (error event), if a
    signal is caught, it is not consumed. If there are two active intermediate catching
    events firing on the same signal event name, both events are triggered, even if
    they are part of different process instances and definitions. If the signal is
    sent and there are no catching signals registered for this event, the event is
    lost.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是一种通用、简单的通信形式，例如消息（见下文）。我们可以使用信号来同步和交换信息。捕获信号可能没有对应的抛出信号构造。它也可以从外部源（API）以编程方式发送。与其它事件（错误事件）不同，如果捕获到信号，它不会被消耗。如果有两个活动中间捕获事件在同一信号事件名称上触发，这两个事件都会被触发，即使它们属于不同的流程实例和定义。如果发送了信号，但没有为该事件注册捕获信号，则该事件会丢失。
- en: Scope
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围
- en: Signals can have visibility between different parts of the same process or broadcast
    processes (scope across all process instances), or targeted to a specific process
    instance. You can throw a signal event in a process instance, and other process
    instances with a different process definition can react to the event. Please keep
    in mind that this behavior (broader or narrower signal scope) can be affected
    by the *runtime strategy* chosen to create your Kie session (the subject is discussed
    in [Chapter 6](ch06.html "Chapter 6. Core Architecture"), *Core Architecture*).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可以在同一流程的不同部分或广播流程（跨所有流程实例的范围）之间具有可见性，或者针对特定的流程实例。你可以在流程实例中抛出一个信号事件，其他具有不同流程定义的流程实例可以对此事件做出反应。请记住，这种行为（更广泛的或更窄的信号范围）可能会受到创建你的
    Kie 会话时选择的 *运行时策略* 的影响（该主题在 [第 6 章](ch06.html "第 6 章。核心架构")，*核心架构* 中讨论）。
- en: Signal ID and signal name tips
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号 ID 和信号名称提示
- en: You may notice some issues with signals when creating/modifying process signals
    in BPMN processes shared between the KIE jBPM console editor and the Eclipse BPMN
    modeler. The generated BPMN differs, and this may lead to bugs and unexpected
    behavior.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在创建/修改 BPMN 流程中的流程信号时注意到与信号相关的一些问题，这些流程是在 KIE jBPM 控制台编辑器和 Eclipse BPMN
    模型器之间共享的。生成的 BPMN 有所不同，这可能会导致错误和意外的行为。
- en: 'When creating the process definition from the Eclipse BPMN editor, the signal
    is assigned an internal ID of the form: `Signal_{number}`. Therefore, the actual
    signal ID to use is the same signal ID that you see in the `Signal` property editor
    and not the user-assigned signal name in the process definition panel (signal
    list table). Keep in mind this additional signal name referencing when coding
    against the `org.kie.api.runtime.KieSession.sendSignal` method.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 Eclipse BPMN 编辑器创建流程定义时，信号被分配一个内部 ID，其形式为：`Signal_{number}`。因此，实际使用的信号 ID
    与你在 `Signal` 属性编辑器中看到的相同信号 ID，而不是流程定义面板（信号列表表）中用户指定的信号名称。在针对 `org.kie.api.runtime.KieSession.sendSignal`
    方法编码时，请记住这个额外的信号名称引用。
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Therefore, with an Eclipse-generated process, the `Signal_1` ID must be used
    with the API.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 Eclipse 生成的流程，必须使用 `Signal_1` ID 与 API 一起使用。
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With a process generated from a jBPM Web console editor, the signal ID is equal
    to the name attribute; `customerPhoneCall` must be used with the API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从 jBPM Web 控制台编辑器生成的流程，信号 ID 等于名称属性；使用 API 时必须使用 `customerPhoneCall`。
- en: Signal data mapping
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号数据映射
- en: Signals can carry optional object data; for each triggered catching signal,
    you can get this signal data and map it to a process variable. When operating
    with the jBPM Web designer, in order to successfully map the signal data to a
    process variable, you have to configure the **DataOutput** signal and assign it
    the name **event** as you can see in the following screenshot. The picture shows
    the event's data mapping for the `start_signal.bpmn` process signal events (see
    the *Start* *Signal event* section example for a detailed event data mapping example).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可以携带可选的对象数据；对于每个触发的捕获信号，你可以获取这个信号数据并将其映射到流程变量。当使用 jBPM Web 设计师操作时，为了成功将信号数据映射到流程变量，你必须配置
    **DataOutput** 信号并将其命名为 **event**，正如你在以下屏幕截图中所见。图片显示了 `start_signal.bpmn` 流程信号事件的
    数据映射（见 *Start* *Signal event* 部分的详细事件数据映射示例）。
- en: '![Signal data mapping](img/9578OS_05_06.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Signal data mapping](img/9578OS_05_06.jpg)'
- en: This is a very flexible mechanism. By delivering data with your signals, you
    can update process variables, convey extra information, or change the process
    flow very easily.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常灵活的机制。通过在信号中传递数据，您可以轻松地更新过程变量、传递额外信息或更改过程流程。
- en: Start Signal event
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始信号事件
- en: With a named Start Signal, we can programmatically start a process instance.
    The signal can be fired from within an existing process instance by using the
    intermediary signal throw event or through the API (the `sendSignal` method).
    In both cases, all process definitions that have a Signal Start event with the
    same name will be started. You can have multiple Start Signal events in a single
    process definition.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名的开始信号，我们可以通过编程方式启动流程实例。该信号可以通过使用中间信号抛出事件或通过API（`sendSignal`方法）在现有流程实例内部触发。在这两种情况下，所有具有相同名称的信号开始事件的流程定义都将启动。您可以在单个流程定义中拥有多个开始信号事件。
- en: 'Example test class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Example process:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Start Signal event](img/9578OS_05_25.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![开始信号事件](img/9578OS_05_25.jpg)'
- en: 'Description: Different Start Signal events are sent so as to create different
    process instances. The signal data is mapped to the process variable (see the
    previous section for an explanation of event data mapping).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：发送不同的开始信号事件以创建不同的流程实例。信号数据映射到流程变量（请参见前一小节中对事件数据映射的解释）。
- en: Intermediate Signal event
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间信号事件
- en: An Intermediate catching Signal event catches signals sent from a throwing intermediate
    signal or through the API call (`KieSession` or `ProcessInstance.sendSignal`)
    and continues the process instance flow. The catching signal has no incoming connections.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 中间捕获信号事件捕获从抛出中间信号或通过API调用（`KieSession`或`ProcessInstance.sendSignal`）发送的信号，并继续流程实例流程。捕获信号没有传入连接。
- en: Boundary Signal event
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界信号事件
- en: See the *Boundary events* section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*边界事件*部分。
- en: End Signal event
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结束信号事件
- en: This kind of signal event is sent at the completion of the process. It can be
    a handy way to track process instance completions across the system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种信号事件在流程完成时发送。它可以是一种方便的方式来跟踪整个系统中的流程实例完成情况。
- en: Message events
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息事件
- en: 'Message events reference a name and can optionally have a payload. Unlike a
    signal, a message event is always targeted at a single catching message. The name
    of the catch and throw messages must be exactly the same in order to make the
    message flow work properly. Let us point out some differences between messages
    and signals:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 消息事件引用一个名称，并且可以选择性地包含有效负载。与信号不同，消息事件始终针对单个捕获消息。为了使消息流正常工作，捕获和抛出消息的名称必须完全相同。让我们指出消息和信号之间的一些区别：
- en: Inside the BPMN diagram, the message flow is drawn linking the sender to the
    receiver, while signals are never directly connected on the diagram. The throwing
    and the catching signal are implicitly connected only by their name.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在BPMN图中，消息流程通过连接发送者和接收者来绘制，而信号永远不会在图中直接连接。抛出和捕获信号仅通过它们的名称隐式连接。
- en: Messages should only be thrown/caught in the same process instance; there is
    no such limitation for signals. Messages work at the process instance scope only
    and are point-to-point links. A signal can travel from one process instance to
    many process instances (broadcast scope).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息应在同一流程实例中抛出/捕获；信号没有这种限制。消息仅在流程实例范围内工作，是点对点链接。一个信号可以从一个流程实例传播到多个流程实例（广播范围）。
- en: Message data mapping
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息数据映射
- en: See the *Signal data mapping* section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*信号数据映射*部分。
- en: Start Message event
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始消息事件
- en: A Start Message event is used to start a process instance as a direct consequence
    of catching a message; a process can have multiple Message Start events. This
    allows us to choose the process creation method simply by changing the Message
    event name to send (see the following image). Make sure that the message event
    name is unique across all loaded process definitions to avoid unwanted process
    creations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 开始消息事件用于在捕获消息的直接后果中启动流程实例；一个流程可以拥有多个消息开始事件。这允许我们通过简单地更改消息事件名称来选择流程创建方法（请参见以下图像）。确保消息事件名称在所有加载的流程定义中是唯一的，以避免不希望的过程创建。
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When sending the message from the API (`sendSignal`), we have to prefix the
    message name with the `Message-` string.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当从API（`sendSignal`）发送消息时，我们必须在消息名称前加上`Message-`字符串前缀。
- en: Message Start events are supported only with top-level processes and not with
    embedded subprocesses.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 消息开始事件仅支持顶层流程，而不支持嵌入式子流程。
- en: '![Start Message event](img/9578OS_05_07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![开始消息事件](img/9578OS_05_07.jpg)'
- en: Intermediate Message event
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间消息事件
- en: If a process is waiting for the message, it will either be paused until the
    message arrives or change the flow for exception handling. For using a throw message,
    there has to be a catch message event that catches the message. It can be a message
    intermediate event or a message start event.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流程正在等待消息，它将暂停直到消息到达，或者改变异常处理的流程。要使用抛出消息，必须有一个捕获消息事件来捕获消息。它可以是消息中间事件或消息开始事件。
- en: Boundary Message event
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界消息事件
- en: The following example shows task cancellation and message data passing by using
    two boundary events (a timer and a message) attached to a human task. The timer
    has the `cancel activity` property set to `FALSE`, while the message has it set
    to `TRUE`. The boundary message event maps the event data to a process variable
    in order to log the cancellation reason passed by the throwing (external) message
    sent by the test class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了通过将两个边界事件（计时器和消息）附加到人工任务来执行任务取消和消息数据传递。计时器将`cancel activity`属性设置为`FALSE`，而消息将其设置为`TRUE`。边界消息事件将事件数据映射到流程变量，以便记录由测试类发送的抛出（外部）消息传递的取消原因。
- en: 'Example test class:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Example process:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Description: A process with a human task is created. The timer event''s duty
    is to cycle and expire every 15 s calling the script task "time out warning" (its
    timer expression is `15s###15s`, and it is not flagged as "cancel activity"; therefore,
    the task will not be cancelled as the timer triggers). When the user continues
    with the test (the test class asks the user to press a key to proceed), a message
    is sent (`sendSignal`), the process message boundary event is triggered, and the
    activity is cancelled (since the boundary message event has the "cancel activity"
    flag enabled). Note that the message is sent by our test class with some data
    that serves as the task cancellation reason (`"cancelled by ADMIN"`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：创建了一个包含人工任务的流程。计时器事件的职责是每15秒循环并过期，调用脚本任务“超时警告”（其计时器表达式为`15s###15s`，且未标记为“取消活动”；因此，当计时器触发时，任务不会被取消）。当用户继续进行测试（测试类要求用户按下一个键以继续）时，会发送一个消息（`sendSignal`），触发流程消息边界事件，并取消活动（因为边界消息事件启用了“取消活动”标志）。请注意，消息是由我们的测试类发送的，其中包含一些数据，作为任务取消的原因（`"cancelled
    by ADMIN"`）：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The boundary message (`id=messageCancelService`) catches the sent message, and
    the message event data, which is bound to the process variable **reason**, is
    printed in standard output by the **cancel log** script task.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 边界消息（`id=messageCancelService`）捕获发送的消息，并将绑定到流程变量**reason**的消息事件数据通过**取消日志**脚本任务打印到标准输出。
- en: '![Boundary Message event](img/9578OS_05_08.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![边界消息事件](img/9578OS_05_08.jpg)'
- en: End Message event
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结束消息事件
- en: A message is sent to a specific process at the conclusion of a process.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在流程结束时向特定流程发送消息。
- en: jBPM throwing message implementation
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jBPM抛出消息实现
- en: 'The jBPM throwing message default implementation is just a placeholder. You
    must provide your own WorkItemHandler definition and register it with the name
    `Send Task` to the jBPM Runtime, providing a hook to the working Kie session (identified
    by `ksession` in the following code fragment):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM抛出消息的默认实现只是一个占位符。您必须提供自己的WorkItemHandler定义，并将其以`Send Task`的名称注册到jBPM运行时，提供一个到工作Kie会话的钩子（以下代码片段中通过`ksession`标识）：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Throughout this chapter, you will find several references to "workItem" and
    "workItem handler and manager." These are the jBPM component part of a feature
    that lets you define a custom Java class and bind it with a specific process activity
    type in the engine runtime. Every time the engine activates this activity type,
    your handler will be invoked and passed the control. Please refer to [Chapter
    7](ch07.html "Chapter 7. Customizing and Extending jBPM"), *Customizing and Extending
    jBPM* for detailed explanation and examples.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将找到对“workItem”和“workItem handler and manager”的多次引用。这些都是jBPM组件的一部分，允许您定义一个自定义Java类并将其与引擎运行时中特定的流程活动类型绑定。每次引擎激活此活动类型时，您的处理程序将被调用并传递控制权。请参阅[第7章](ch07.html
    "第7章。自定义和扩展jBPM")，*自定义和扩展jBPM*以获取详细说明和示例。
- en: 'From the custom workItemHandler, you can then send signals:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从自定义workItemHandler，您然后可以发送信号：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Example test class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Example processes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Description: The process created sends a message by a custom WorkItemHandler
    starting a new instance of the `start_message_catch` process (by a start message
    event).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：创建的流程通过自定义WorkItemHandler发送消息，启动`start_message_catch`流程的新实例（通过开始消息事件）。
- en: Timer events
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时器事件
- en: 'Timer events are events that are triggered when a timer construct expression
    is met; the timer properties are as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器事件是在满足计时器构造表达式时触发的事件；计时器属性如下：
- en: '**Time Duration**: Single trigger delay value (for example: 10 m, 25 s).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间持续时间**：单个触发延迟值（例如：10 m，25 s）。'
- en: '**Timer Cycle**: The time expression that shall be evaluated. It can be a string
    (interval-based 20 s or 5 m###35 s, where the first value is the initial delay
    and the second value is the delay between repeated fires), a string `cron` expression,
    or a process variable. In the case of JBPM 6.x, it can also be a ISO-8601 formatted
    date.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时器周期**：要评估的时间表达式。它可以是字符串（基于间隔的20 s或5 m###35 s，其中第一个值是初始延迟，第二个值是重复触发的延迟），字符串`cron`表达式，或流程变量。在JBPM
    6.x的情况下，它还可以是ISO-8601格式的日期。'
- en: '**Timer Cycle Language**: Can be a default interval (empty value and time duration
    set) or `cron`.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时器周期语言**：可以是默认间隔（空值和时间持续时间设置）或`cron`。'
- en: Start Timer event
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始计时器事件
- en: 'A Start Timer event is used to create a process instance at a given time. It
    can be used for processes that should start only once and for processes that should
    start at specific time intervals. Note the following points:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 开始计时器事件用于在给定时间创建流程实例。它可以用于应该只启动一次的流程和应该按特定时间间隔启动的流程。请注意以下要点：
- en: A subprocess cannot have a start timer event.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子流程不能有开始计时器事件。
- en: A Start Timer event is registered as soon as the process is deployed. There
    is no need to call the `startProcessInstance` API.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦流程部署，就会注册一个开始计时器事件。无需调用`startProcessInstance` API。
- en: When a new version of a process with a Start Timer event is deployed, the job
    corresponding to the old timer will be removed.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当部署带有开始计时器事件的流程的新版本时，对应旧计时器的作业将被移除。
- en: Intermediate Timer event
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间计时器事件
- en: This event is a catching event only. The timer value triggers the execution
    of the outgoing sequence flow. You can use the timer to insert a generic delay
    or a timed-out sequence flow execution; for example, you could add a timer to
    manage a due date for a human task completion (see the *Event-based gateway* section
    example for a timer that acts this way).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件仅是一个捕获事件。计时器值触发输出序列流的执行。您可以使用计时器来插入通用延迟或超时序列流执行；例如，您可以为管理人工任务完成截止日期添加计时器（请参阅*基于事件的网关*部分示例，其中计时器以这种方式操作）。
- en: Boundary Timer event
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界计时器事件
- en: See the *Boundary Message event* section for an example.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*边界消息事件*部分以获取示例。
- en: Error events
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误事件
- en: Error events are used to model business exceptions. They are triggered by an
    exception that might be generated during the execution of an activity. Intermediary
    throw/catch error events do not apply.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 错误事件用于模拟业务异常。它们由在活动执行过程中可能生成的异常触发。中间抛出/捕获错误事件不适用。
- en: Boundary Error event
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界错误事件
- en: This boundary error event must be attached to an activity. As the error event
    triggers, the activity is always canceled and the error event's outgoing sequence
    flow is taken.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此边界错误事件必须附加到活动上。当错误事件触发时，活动总是被取消，并采取错误事件的输出序列流。
- en: 'Example test class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Example process:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Description: Two different boundary error events are attached to the same user
    task registered on different `errorCode` properties (`FileNotFoundException` or
    `RuntimeException`); the error handler logs the exception message. Depending on
    the process parameter (`triggerexceptionflag`) value passed, the user task throws
    a different exception upon completion (the `onExit` script), which triggers the
    appropriate boundary error event.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：两个不同的边界错误事件附加到不同`errorCode`属性（`FileNotFoundException`或`RuntimeException`）上注册的同用户任务；错误处理器记录异常消息。根据传递给过程参数（`triggerexceptionflag`）的值，用户任务在完成时抛出不同的异常（`onExit`脚本），这触发了适当的边界错误事件。
- en: '![Boundary Error event](img/9578OS_05_09.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![边界错误事件](img/9578OS_05_09.jpg)'
- en: 'The process is started with a variable whose value affects the type of exception
    to be thrown:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 流程以一个变量启动，其值影响要抛出的异常类型：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The user task''s `onExit` script evaluates the process variable and throws
    the exception accordingly:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 用户任务的`onExit`脚本评估流程变量并相应地抛出异常：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The engine triggers the appropriate boundary error event depending on the exception
    thrown; the event, in fact, must be configured with the `errorCode` property set
    to the exception classname: `java.lang.RuntimeException` (see the following screenshot).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎根据抛出的异常触发适当的边界错误事件；实际上，事件必须配置为将`errorCode`属性设置为异常类名：`java.lang.RuntimeException`（参见以下截图）。
- en: '![Boundary Error event](img/9578OS_05_28.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![边界错误事件](img/9578OS_05_28.jpg)'
- en: 'Note that the boundary error can bind the exception to a process variable.
    In the example, this variable (`exceptionvar`) is logged to the console by the
    script task:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，边界错误可以将异常绑定到流程变量。在示例中，该变量（`exceptionvar`）通过脚本任务记录到控制台：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Error Start event
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误开始事件
- en: The Error Start event can only be used to trigger an Event Subprocess and cannot
    be used to start a process instance. This is a feature you could consider using
    when activating alternative subprocesses on error exceptions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 错误开始事件只能用于触发事件子流程，不能用于启动流程实例。这是您可以考虑在错误异常激活替代子流程时使用的一个功能。
- en: Error End event
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误结束事件
- en: When the process execution reaches an Error End event, the current path of execution
    is ended and an error event is thrown. This error is caught by a matching intermediate
    boundary Error event or a subprocess Start Error event. If no Error event is found,
    an exception is thrown.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当流程执行达到错误结束事件时，当前执行路径结束并抛出一个错误事件。此错误由匹配的中间边界错误事件或子流程开始错误事件捕获。如果没有找到错误事件，则抛出异常。
- en: The following example uses the Error End event to trigger a subprocess by its
    Error Start event.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用错误结束事件通过其错误开始事件触发一个子流程。
- en: 'Example test class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Example process:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Description: The main process features a human task and an Error End event,
    which triggers an embedded subprocess Script task by an Error Start event.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：主要流程特征包括一个人类任务和一个错误结束事件，该事件通过错误开始事件触发一个嵌入的子流程脚本任务。
- en: '![Error End event](img/9578OS_05_10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![错误结束事件](img/9578OS_05_10.jpg)'
- en: Compensation
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补偿
- en: Complex business processes may involve a number of heterogeneous parties and
    systems such as modern transactional systems, legacy systems (not transactional),
    and Web services. In order to preserve business consistency, when something fails
    and no transactional protocols are available, these systems may require you to
    perform programmatic corrective actions by invoking some dedicated API or by any
    other means. The compensation is the action of post-processing trying to remedy
    (not properly undoing or rolling-back) the effects produced by an action.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的业务流程可能涉及多个异构的参与者和系统，例如现代事务系统、遗留系统（非事务性）和Web服务。为了保持业务一致性，当出现故障且没有事务性协议可用时，这些系统可能需要您通过调用某些专用API或其他方式执行程序性纠正操作。补偿是后处理操作，试图补救（而不是正确撤销或回滚）由操作产生的效果。
- en: We want to stress the fact that jBPM compensations are not a transactional feature
    or a `try`/`catch` error mechanism. The compensation is a BPM business feature,
    which models an activity as the compensating counterpart for an already completed
    activity.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想强调的是，jBPM的补偿不是事务性功能或`try`/`catch`错误机制。补偿是BPM业务功能，它将活动建模为已完成的活动的补偿对应物。
- en: Here you have the common steps, which take place during a compensation event
    (see the following process example figure for a visual reference of the sequence).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是常见的步骤，这些步骤发生在补偿事件期间（参见以下流程示例图以获取序列的视觉参考）。
- en: An activity (A1) whose boundary is attached to a compensation event (E1) is
    completed
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个活动（A1），其边界连接到补偿事件（E1）已完成
- en: A compensate event (E2) is thrown somewhere in the process
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流程中某处抛出一个补偿事件（E2）
- en: The compensate event (E1) catches E2
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补偿事件（E1）捕获E2
- en: jBPM activates the compensation handler (A2), which is connected to E1
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jBPM激活与E1相连的补偿处理程序（A2）。
- en: The engine is ignorant of what the compensating activity will do since it is
    up to the developer to define the compensating business logic.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎不知道补偿活动将做什么，因为补偿业务逻辑的定义取决于开发者。
- en: Intermediate Compensation event
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间补偿事件
- en: 'The throwing Compensation event (E2) and the boundary Compensation event (E1)
    are implicitly connected by the same event name (we have already seen this with
    signals and messages). What we have explained for boundary events still applies
    here: when the Compensation event (E2) is triggered, the boundary Compensation
    event (E1) reacts by invoking the linked compensating activity (A2), which is
    marked with the typical compensation **FastBackward**-like symbol.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出补偿事件（E2）和边界补偿事件（E1）通过相同的事件名称隐式连接（我们已经在信号和消息中看到过这一点）。我们之前对边界事件的解释仍然适用：当补偿事件（E2）被触发时，边界补偿事件（E1）会通过调用标记有典型补偿**FastBackward**样式的关联补偿活动（A2）来做出反应。
- en: Boundary Compensation event
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界补偿事件
- en: The Compensation boundary event (E1) must reference one Compensation handler
    (A2) only through the direct association line. The Compensation boundary event
    is activated only when the activity (A1) has been completed (unlike the default
    boundary event behavior where the event is activated depending on the Activity
    start state). The Compensation catch event (E1) is removed after either the parent
    process instance completes or the Compensation event itself is triggered. If a
    Compensation boundary event is attached to a multiple-instance subprocess, a compensation
    event listener will be created for each instance. jBPM does not seem to support
    this last feature.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 补偿边界事件（E1）必须仅通过直接关联线引用一个补偿处理程序（A2）。补偿边界事件仅在活动（A1）完成时被激活（与默认边界事件行为不同，事件激活取决于活动启动状态）。补偿捕获事件（E1）在父流程实例完成或补偿事件本身被触发后将被移除。如果补偿边界事件附加到多实例子流程，将为每个实例创建一个补偿事件监听器。jBPM似乎不支持此最后功能。
- en: Compensating activity
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 补偿活动
- en: This activity (also called a compensation handler) is directly connected to
    the triggering boundary compensation event and must have no outgoing sequence
    flows.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动（也称为补偿处理程序）直接连接到触发边界补偿事件，并且不能有出序列流。
- en: 'Example test class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Example process:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Description: We used this example process to explain the typical compensation
    "workflow," so you should already be familiar with it. Let us just add that the
    Compensate event is thrown when the human task (**H1**) is completed and the `cancelOrder`
    variable evaluates to "y." This activates the exclusive gateway sequence flow,
    which triggers the event (**E2**). This activates the boundary Compensate event
    (**E1**), which in turn calls the **cancel order** script task (A2). The **cancel
    order** task acts as a "compensating" activity.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：我们使用这个示例过程来解释典型的补偿“工作流程”，因此你应该已经熟悉它。让我们再补充一点，当人工任务（**H1**）完成并且`cancelOrder`变量评估为“y”时，会抛出补偿事件。这激活了排他网关序列流，从而触发事件（**E2**）。这激活了边界补偿事件（**E1**），进而调用**取消订单**脚本任务（A2）。**取消订单**任务充当“补偿”活动。
- en: '![Compensating activity](img/9578OS_05_11.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![补偿活动](img/9578OS_05_11.jpg)'
- en: Triggering compensations with signals
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用信号触发补偿
- en: 'jBPM offers additional ways to trigger compensations inside a process instance
    by using signals: general (implicit) and specific compensation handling. An **implicit**
    compensation triggers all of the compensation handlers for the process instance:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: jBPM通过使用信号（通用（隐式）和特定补偿处理）提供额外的触发流程实例内补偿的方法。**隐式**补偿触发流程实例的所有补偿处理程序：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You must use the compensation signal type and pass the signal data a string
    that results from concatenating the `CompensationScope` class constant and the
    process definition ID resulting in the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用补偿信号类型，并将信号数据传递为一个字符串，该字符串是通过连接`CompensationScope`类常量和流程定义ID生成的：
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The **specific** compensation triggers a specific compensation handler inside
    a process instance. You must pass the activity node ID attached to the boundary
    compensation event, along with the process instance ID:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**特定**补偿在流程实例内触发特定的补偿处理程序。你必须传递附加到边界补偿事件的活动节点ID，以及流程实例ID：'
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our example process script task XML element follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例流程脚本任务XML元素如下：
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: No new signal event needs to be defined at the process definition level.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在流程定义级别不需要定义新的信号事件。
- en: 'For working examples, please refer to the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作示例，请参考以下内容：
- en: 'Example test class:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: End Compensation event
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束补偿事件
- en: The end compensation event works the same way as the intermediate one (please
    see the example process figure). A compensation end event is thrown (**E1**),
    and the compensation handler triggered (**A1**). This kind of event is useful
    when there is a need to perform housekeeping or remediation business logic at
    the end of a process, but only when your bounded activity (**S1**) is in the COMPLETE
    state. Note in fact, as we already stressed, that the compensation handler kicks
    in only when the **subprocess** (**S1**) is already in the completed state.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 结束补偿事件的工作方式与中间事件相同（请参阅示例流程图）。抛出补偿结束事件（**E1**），并触发补偿处理程序（**A1**）。此类事件在需要执行流程结束时的维护或补救业务逻辑时很有用，但仅当您的有界活动（**S1**）处于完成状态时。请注意，实际上，正如我们之前强调的，补偿处理程序仅在子进程（**S1**）已经处于完成状态时启动。
- en: 'Example test class:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Example processes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Description: The process has a **subprocess** (**S1**) with an attached boundary
    Compensate event (**E2**). The subprocess triggers the throwing compensate end
    event (**E1**). The Compensate boundary catch event (**E2**) invokes the compensation
    handler (**A1**), which rolls back the process variable to the initial value.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：该流程有一个带有附加边界补偿事件（**E2**）的**子进程**（**S1**）。子进程触发抛出补偿结束事件（**E1**）。补偿边界捕获事件（**E2**）调用补偿处理程序（**A1**），该处理程序将流程变量回滚到初始值。
- en: '![End Compensation event](img/9578OS_05_12.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![结束补偿事件](img/9578OS_05_12.jpg)'
- en: Multi-instance compensation
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多实例补偿
- en: Compensation catching events attached to a multi-instance subprocess are not
    implemented. See the *Subprocess* section for details about multi-instance activities.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到多实例子进程的补偿捕获事件尚未实现。有关多实例活动的详细信息，请参阅*子进程*部分。
- en: Escalation
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级
- en: Escalation, according to the common policies of an institution, organization,
    or corporate, refers to the existing relationships between the working personnel
    and their duties. The presence of an escalation event indicates that there is
    a condition that requires the business process flow to be diverted to a different
    user group. For instance, if an order above a certain price threshold is received,
    the approval task must be performed by a user in a higher role (for example, a
    manager); otherwise, it can also be approved by a clerk user.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 升级，根据机构、组织或公司的普遍政策，指的是工作人员与其职责之间现有的关系。升级事件的产生表明存在需要将业务流程流转转向不同用户组的条件。例如，如果收到超过一定价格阈值的订单，则必须由高级别用户（例如，经理）执行审批任务；否则，也可以由职员用户审批。
- en: In the case of jBPM 6.2.0, escalation events seem to be partially implemented
    and it is not clear what part of the BPMN specification is supported at this stage.
    You can partially overcome the lack of an escalation event with Deadlines and
    Notifications (see the *User Task* section).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jBPM 6.2.0 的情况下，升级事件似乎部分实现，目前尚不清楚在此阶段支持 BPMN 规范的哪一部分。您可以通过截止日期和通知（请参阅*用户任务*部分）部分克服升级事件的缺乏。
- en: Conditional events
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件事件
- en: Conditional events are a jBPM feature extension. They are triggered by an evaluation
    of user-provided expressions of Drools rules and facts properties. Conditional
    Start and Boundary events are supported.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 条件事件是 jBPM 的功能扩展。它们由对用户提供的 Drools 规则和事实属性的评估触发。支持条件开始和边界事件。
- en: 'Example test class:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 示例测试类：
- en: '[PRE43]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Example process:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 示例流程：
- en: '[PRE44]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Description: The main process is started when the Fact order note property
    matches "urgent"; the following script task **ordercost** is cancelled if Order
    cost > 100.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 描述：当事实订单笔记属性匹配“紧急”时，主过程开始；如果订单成本 > 100，则取消以下脚本任务**ordercost**。
- en: '![Conditional events](img/9578OS_05_13.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![条件事件](img/9578OS_05_13.jpg)'
- en: Activities
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动
- en: An activity is a unit of work that is executed within a business process; it
    can be atomic or non-atomic (Compound activity, Call activity, or Subprocess).
    Activities can be of the Task, Call activity, or Subprocess type.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 活动是在业务过程中执行的工作单元；它可以是最小单元或非最小单元（复合活动、调用活动或子进程）。活动可以是任务、调用活动或子进程类型。
- en: Task
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: A task is the smallest atomic activity unit that can be included within a process.
    Usually, the performer of the task can be an end user (called human) using a UI-based
    application, a participating external service, or a generic set of business statements.
    Tasks have their local scope and can accept input parameters from their container
    and return output parameters.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: User Task
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A user task is used to model work that needs to be done by a human actor. When
    the process execution arrives at the user task node, a new task instance is created
    in the work list of the actor(s) or group(s) defined for this task (the Actors
    and Groups properties). Human tasks can transition to several different states
    and involve human stakeholders depending on the action taken on the task itself
    and the defined human roles.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Human roles
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Human roles define what a person or a group of actors can do with tasks. Let
    us review the roles defined for the human task activities:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '**Task initiator**: The person who creates the task instance. Depending on
    how the task has been created, the task initiator may not be defined.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actual owner**: The person who owns the task and is performing it. A task
    always has one actual owner.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential owners**: Persons who are given a task so that they can claim and
    complete it. A potential owner can become the actual owner of a task by claiming
    it.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excluded owners**: Actors may not transition to be an actual or potential
    owner, and they may not reserve or start a task.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business administrators**: Business administrators are able to perform the
    same operations as task users since they are always potential owners of every
    task. jBPM provides a default business administrator user (Administrator) and
    group (Administrators).'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State transitions
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The task remains in the **Created** state until it is activated. When the task
    has a single potential owner, it transitions into the **Reserved** state (it is
    assigned to a single actual actor); otherwise, it transitions into the **Ready**
    state; this state indicates that the task can be claimed by one of its potential
    owners. After being claimed, the task transitions into the **Reserved** state,
    elevating the potential owner to the actual owner actor. At this point, the actor
    can start the task that is in either the **Ready** or the **Reserved** state and
    make it transition to the **InProgress** state. The **InProgress** state means
    that the task is being worked on. If the actor completes the work, the task transitions
    into the **Completed** state. If the completion of the work goes wrong (exception),
    the task is put into the **Failed** state. Alternatively, the user can release
    the task, bringing it back to the **Ready** state. No transition is allowed from
    the **Complete** state and the **Failed** state.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For detailed information on task state transitions, please refer to the Web
    Services – Human Task (WS-HumanTask) Specification by Oasis at [http://docs.oasis-open.org](http://docs.oasis-open.org).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![State transitions](img/9578OS_05_21.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: State transitions
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Deadlines and escalations
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The jBPM concept of a task deadline is bound to the task start-complete time
    interval duration; deadlines are associated with task escalations: the task escalation
    may exist in either a task reassignment or a task notification action. The task
    deadline is calculated on the task expiry date: it is reset when the task is started,
    and it expires when the task is completed over the allowed time boundary. Deadlines
    are physically stored in the `DEADLINE` table while notifications are stored in
    the `NOTIFICATION` set of tables.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Reassignment and Notifications property editor is available in the KIE Web
    process editor only.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Task reassignment
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Task reassignment is a jBPM mechanism that lets you change a task ownership
    by setting specific rules, which are based on the task state transition and a
    deadline time expression, for example: "if Luigi (a named task actor) does not
    start the task in 60 seconds then reassign the task instance to Mario." The nominated
    user is replaced by the new user as the potential owner for the task. The resulting
    reassignment rule syntax is as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can define multiple reassignment rules on a single task instance.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Task event type conditions can be `not-started` and `not-completed`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The BPMN XML task parameters are `NotStartedReassign` and `NotCompletedReassign`.
    The reassignment information is persisted by the engine into the `REASSIGNMENT`
    and `REASSIGNMENT_POTENTIALOWNERS` tables.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test class:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Example process:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Description: The main process is started, and the task is assigned to Luigi.
    The reassign rule states that "if Luigi (named task actor) does not start his
    task in 60 seconds then the task should be assigned to Mario."'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A notification is the action of alerting someone (actor, group) when a task
    deadline expires. The default jBPM notification is e-mail based, and the default
    e-mail configuration is read from the `userinfo.properties` and `email.properties`
    files. The `userinfo.properties` file lists the user/group information in the
    following form:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'e.g., for an entity of type actor, we have:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Member data is optional and is used for listing members belonging to a group
    organizational entity.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to the official jBPM 6.2 documentation for the configuration details.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The BPMN XML task parameters are `NotStartedNotify` and `NotCompletedNotify.`
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'An example `NotStartedNotify` parameter value follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Delegation
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Delegation is the process of setting a task's potential owners. The actual owners,
    potential owners, or business administrators can delegate a task to another user,
    adding this user to the potential owners (if he/she isn't already) and making
    the user the task owner. A task can be delegated when it is in an active state
    (Ready, Reserved, or InProgress) and transitioned into the Reserved state, and
    its `skippable` property can be flagged to `true` (the target actor/owner can
    skip the task). The task's state and parameters will not change after delegation.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Forward
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Task forwarding is the process performed by a potential owner on an active task
    who replaces himself in the potential owner list, passing the task to another
    person. The potential owner can only forward tasks when in the Ready state. If
    the task is in the Reserved or InProgress state, the task is transitioned to the
    Ready state again.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Suspend/resume
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A task can be suspended in any of its active states (Ready, Reserved, or InProgress),
    transitioning it into the Suspended state. The Suspended state has sub-states
    to indicate the original state of the task. When resumed, the task transitions
    back to the original state from which it had been suspended.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Skip
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A stakeholder working on a human task or a business administrator may decide
    that a task is no longer needed and hence, skip this task. This makes the task
    transition into the Obsolete state. The task can only be skipped if this capability
    is specified during the task configuration (the `skippable` property).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'For delegate, forward and skip, and suspend/resume examples have a look at
    a test class:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Example process:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Description: The main process is started, and a human task is reserved to Luigi.
    The test methods check for task delegation, forwarding, and suspend/resume.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Release
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A task may be released by the current owner as a human task, making it available
    for other potential owners. From active states that have an actual owner (Reserved
    or InProgress), a task can be released and transitioned into the Ready state.
    Task data associated with the task is kept unchanged.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: If a task is currently InProgress, it can be stopped by the actual owner, transitioning
    it into the Reserved state. Business data associated with the task as well as
    its actual owner is kept unchanged.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Script Task
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Script task is an automatic activity. When a process execution arrives at
    the Script task, the corresponding script is executed. All process variables that
    are accessible through the execution context (the `kcontext` variable) can be
    referenced within the script. It has the following properties:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: It is executed by the business process engine
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script is defined in a language supported by the engine (Java or MVEL)
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script task execution is always immediate
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script task transitions to the complete state after the script execution
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete MVEL reference, please visit [http://mvel.codehaus.org/](http://mvel.codehaus.org/).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test class:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Example process:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Description: The process script activity updates the process variable `order`
    description property:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Service Task
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The service task indicates the work that is to be automatically performed by
    a service provider. Usually, all work that has to be executed outside the engine
    should be designed as a service task. jBPM supports two types of service task
    implementations: plain Java class and Web service. The service task is backed
    by a WorkItemHandler implementation (`org.jbpm.process.workitem.bpmn2.ServiceTaskHandler`)
    registered with the name **Service Task**.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '`Interface`: Java class name or WSDL WebService service interface'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Operation`: Java method name or WSDL WebService operation'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parameter`: Method name (to invoke)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParameterType`: Method (to invoke) parameter type (only 1 parameter supported)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mode` (WS only): `SYNC` (default), `ASYNC`, or `ONEWAY`'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of a service task of type Java, jBPM uses Java reflection to load the
    Java class type (by using an `Interface` parameter), instantiate it, and invoke
    the specified method (searched by `Operation` and `ParameterType`) with the value
    provided by `Parameter`. Only method signatures with a single parameter are supported,
    and the result of the invoked method is mapped in the activity `Results` output
    parameter.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Mode` parameter applies to a Web service only and describes the way a
    request has to be performed:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous (SYNC)**: Sends a request and waits for a response before continuing'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous (ASYNC)**: Sends a request and uses callback to get a response'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oneway**: Sends request without blocking (ignore response)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Web service runtime leverages the "dynamic clients" features of the Apache
    CXF framework in order to generate Java classes at runtime.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please visit [http://cxf.apache.org/docs/dynamic-clients.html](http://cxf.apache.org/docs/dynamic-clients.html)
    for the official reference documentation.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'A Service task can be really useful for rapid prototyping, but when it comes
    to complex external service integration, it falls short in meeting common development
    needs: multiple parameter passing, additional Web service configuration, and so
    on.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The following example demonstrates how to override the standard jBPM service
    task component by adding a custom workItem handler. Note, however, that the input/output
    parameters of the custom service task handler cannot be changed from the process
    designer because the task interface is defined in the configuration files of the
    jBPM workItem handlers.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WorkItem handlers are thoroughly explained in [Chapter 7](ch07.html "Chapter 7. Customizing
    and Extending jBPM"), *Customizing and Extending jBPM*.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test class:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Example process:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Description: The first test (`testJavaServiceTask`) launches the process with
    a standard Java Service task (Interface: `ServiceJavaTask`, Operation: `processOrder`,
    Parameter: `order`, ParameterType: `Order`). The Service task changes the note
    field of the order and returns it to the main process whose script activity traces
    the change to the console. The second test (`testJavaCustomServiceTask`) features
    a custom Service task handler (`PacktServiceTaskHandler`) that overrides the default
    handler and processes the order parameter, setting its `note` property with a
    specific value.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Rule Task
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The (Business) Rule tasks let us execute rules and get output from the embedded
    rule engine (Drools). Remember that process variables can be shared with the Rule
    tasks by using global variables or Drools session facts.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Example class:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Example knowledge artifacts:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Description: The main process is started, and the rule task triggers when the
    order cost is >100, and as a result, it changes the order''s `note` property to
    `URGENT`. Look at the `rule.drl` file:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `order` variable (with `cost > 100`) is inserted into the knowledge session
    to activate the rule that triggers when `Order (cost > 100)`; see the `RuleTaskTest.testRule()`
    method:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'While the shared `orderglobal` variable is used to get the result back:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Send/Receive Task
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Send/Receive tasks are general-purpose messaging tasks since they do not provide
    a default implementation. They are handled as workItem and it is up to the implementer
    to back them with a working implementation through the `WorkItemHandler` interface,
    registering it with the jBPM `WorkItemManager`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The workItem name of the receive task must be **Receive Task**. **Receive Task**
    refers to the message ID through the `messageRef` attribute; the handler receives
    the message ID value with the `MessageId` parameter.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: The workItem name of the send task must be **Send Task**. **Send Task** refers
    to the message ID through the `messageRef` attribute; for additional reference,
    check the Intermediate Message event.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '![Send/Receive Task](img/9578OS_05_17.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
- en: Example class
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Example process artifacts:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Description: The subprocess send task passes data to the receive task of the
    parent process. The test registers two custom workItem handlers, and the Send
    task and the Receive task share a message by using a global process variable.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Manual Task
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A manual task defines a task that is to be performed externally to the engine.
    It is used to model work that is done by a stakeholder without interacting with
    the system; the engine does not know anything about the task, and it does not
    need to. There is no UI interface or system available for the manual task completion.
    For the engine, a manual task is managed as a passthrough activity. It continues
    the process from the moment process execution arrives into it.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc (Custom or None) Task
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The custom task is an empty, generic, unspecialized unit of work. The implementer
    is requested to provide a WorkItemHandler implementation for the task and register
    it with WorkItemManager
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [Chapter 7](ch07.html "Chapter 7. Customizing and Extending jBPM"), *Customizing
    and Extending jBPM* for detailed sections on the WorkItemHandler architecture.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The handler is registered for all workItems of the given workItemName and is
    called every time the process activates a node with that name. Further, workItemName
    must match the `taskname` attribute of the task element. WorkItemHandler is responsible
    for completing or aborting the task instance.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: See the *Conditional* events section for a working example.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Async tasks
  id: totrans-437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are now going to take a closer look at some peculiar usage of the custom
    task. In [Chapter 4](ch04.html "Chapter 4. Operation Management"), *Operation
    Management* we introduced the new jBPM executor service and the job scheduling
    features of the KIE console. The custom task can be conveniently configured to
    instruct the executor to call service-oriented components in an asynchronous fashion
    by scheduling an execution job in the background. The jBPM handler responsible
    for the job submission is `org.jbpm.executor.impl.wih.AsyncWorkItemHandler` (more
    on this in [Chapter 7](ch07.html "Chapter 7. Customizing and Extending jBPM"),
    *Customizing and Extending jBPM*).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The jBPM process designer gives you the ability to toggle a `wait-for-completion`
    flag on the workitem handler node. This flag does not reflect the sync/async nature
    of the handler invocation. It does tell the engine to evaluate (by an event listener)
    the handler results and map them back to the process context variables, using
    the task output mapping. If the flag is set to false, the custom task results
    will be ignored.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure an async task by doing the following:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Specifying `async` as the task `taskName` property
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a data input parameter called `CommandClass`, and assigning a fully qualified
    Java class name to the schedule
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) adding a data input parameter called `Retries`, which tells the executor
    how many times the execution should be retried (default = 3)
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. Operation Management"), *Managing Jobs and
    Asynchronous Command Execution* explains in detail how to write `Command` classes.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: The example that we discuss sets our `AsyncTaskCommand` as `CommandClass`, starts
    the executor service, and registers AyncWorkItemHandler.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Example class:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Example process artifacts:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Call Activity Task
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The call activity task is a general-purpose means to reuse existing, externally
    defined business constructs (process) simply by specifying their ID (the `calledElement`
    attribute of `bpmn2:callActivity`) or `Name` (`calledElementByName`). The execution
    of the called element can be synchronous/asynchronous (`waitForCompletion=true`)
    or independent (`independent=true`). You can set `independent` to false only if
    `waitForCompletion` is `true`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'All these properties are easily set, as usual, through both the jBPM Eclipse
    plugin or the KIE process editor; we extract from the process definition, for
    reference purposes, the relevant XML for the `callActivity` construct:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following figure shows the main process on the left and the callactivitySub1
    process "zoomed out" from the CallActivity node:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '![Call Activity Task](img/9578OS_05_26.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
- en: The callee construct supports, like other activity nodes (tasks), data input
    and output mappings from/to the caller process, as we are going to see in the
    following example.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'Example class:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Example process artifacts:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Description: The main process is started and `callActivity` is executed; the
    main process passes the process order variable to `callActivity`. The `callActivity`
    subprocess modifies the order variable and returns it to the calling process definition.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, if we examine the `PROCESSINSTANCELOG` table, we can see the
    two instances of the processes (the main and the called process) logged; their
    parentship relation is saved through the **PARENTPROCESSINSTACEID** column; it
    shows that **callactivitySubprocess** is a child process of the **callactivityprocess**.
    This is the output when callActivity has the `independent=true` and `waitforcompletion=true`
    properties set.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![Call Activity Task](img/9578OS_05_14.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
- en: Let us look at another example and see how the independent property affects
    the called subprocess.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Example class:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Example process artifacts:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Description: The `callactivityabort` process is started, and callActivity (with
    `independent=false`) is executed. The subprocess referenced by callActivity (`callactivitysubprocessabort`)
    has a human task, so it stops for user interaction. This gives us the time to
    issue (see the test class code) `abortProcessInstance` on the parent process.
    The `independent` flag set to `FALSE` forces callActivity (that is, the waiting
    subprocess) to abort contextually to the main process instance; when the flag
    is set to `TRUE`, the callActivity is not affected (see previous example).'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: This is the output when aborting the parent process instance, which has callActivity
    with the `independent=false` property set. Note also that `status = 3` (ABORTED)
    for both process instances.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '![Call Activity Task](img/9578OS_05_16.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
- en: Subprocess
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A subprocess, as the name suggests, is a process that is included within another
    process. It can contain activities, events, gateways, and so on, which form a
    **boxed** process that is part of the enclosing process. The subprocess can be
    completely defined inside a parent process (an embedded subprocess) or can be
    linked through a CallActivity element by its ID or Name property. You can link
    a subprocess (by callActivity) across different multiple process definitions,
    reusing common groups of process elements (activities, gateways, and so on). The
    embedded subprocess construct can have multi-instance capabilities (see the MultiInstance
    section). However, using a subprocess does impose the following constraints:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Sequence flow cannot cross subprocess boundaries
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process variables must be mapped for input and/or output
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the designer level, a subprocess can be expanded or collapsed so as to hide
    or show its details.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc subprocess
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ad hoc subprocesses are commonly used when a number of tasks can be selected
    and performed in any order (because unspecified or unknown), and there is no execution
    dependency between them. Tasks might have unknown dependencies, most often because
    they are dynamic and managed by a human user on a case-by-case basis. The subprocess
    can complete even if some of the tasks are not executed at all. An ad hoc subprocess
    is represented as a subprocess with a tilde (˜) marker at the base.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '![Ad hoc subprocess](img/9578OS_05_15.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
- en: 'The jBPM ad hoc subprocess implementation seems to be fairly incomplete. There
    seem to be some issues when exiting from the subprocess instance. The user is
    able to start the ad hoc subprocess activities by using the `signal` method by
    referencing the activity name:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Because of their nature, ad hoc subprocesses are hard to design and of little
    use in real structured business processes; nevertheless, here, we provide you
    with an example that you can tweak and experiment with:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Example class:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Example process artifacts:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Description: The ad hoc subprocess has 2 script activities and 1 human task.
    The script tasks are signaled, and the human task is completed.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Multiple instances
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This construct can be used to create multiple instances of a reusable subprocess
    definition as well as an embedded subprocess. Passing an input parameter collection
    works as the instantiation loop. jBPM will create one instance of the looping
    process for each element in the collection. The following figure shows the process
    with the embedded multi-instance subprocess (**Log pizzas**, the parallel symbol
    denotes that it is a multi-instance process) and the subprocess attributes. The
    loop input is the process variable `list` and the loop instance parameter (the
    collection item) is `item` of type `Pizza`. The `item` variable is visible in
    the instantiated subprocess scope.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple instances](img/9578OS_05_27.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
- en: 'Example class:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Example process artifacts:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Description: The process is created by passing a variable `list` of pizzas:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Subsequently, two subprocess instances are created, and each is passed the loop
    `item` variable (a `Pizza` instance). The subprocess script activity simply prints
    the pizza description, and the subprocess exits.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Lanes
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lane is a partitioning box-shaped element used to group activities within
    the process definition. Lanes can be used to visually point out different group
    task assignments. For example, you can think of a lane as a company department
    (IT, business administration, and so on) where all employees have (more or less)
    the same duties. jBPM will try to assign (making a task reserved for the user)
    all tasks within the same lane to the same user. For example, if there are several
    tasks on a lane, the user who claimed and completed the first task will be assigned
    to the other tasks on the lane. Usually, it is convenient to assign the same group
    ID to all the tasks in the same lane.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'Example class:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Example process artifacts:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Description: The **task1** and **task2** (on **lane**) activities are assigned
    to the `pizzerianapoli` group, while **Mario''s Task** is assigned to the actor
    Mario. **taskNotInLane** is also assigned to `pizzerianapoli` but it''s not on
    **lane**.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '![Lanes](img/9578OS_05_18.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
- en: After the process is started, the actor Luigi (belonging to the `pizzerianapoli`
    group; see the `LaneUserCallBack` class) has 2 tasks on the list (**task1** and
    **taskNotInLane**). After he completes task1, he is automatically given the task2
    activity (status = **Reserved**), while the **taskNotInLane** status remains unchanged
    (**Ready**).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '![Lanes](img/9578OS_05_19.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
- en: Data objects
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data objects are BPMN constructs that represent how data is required or produced
    by an activity. Data objects can have a direct association to one or more activity
    providing the input or the target output for that activity.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '![Data objects](img/9578OS_05_20.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
- en: 'Example class:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Example process artifacts:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Description: The task1 and task2 activities share the same data object (pizza
    class type); the first task produces the pizza, which then serves as the input
    of the second task.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we examined the jBPM BPMN constructs, providing hands-on working
    examples, tips, and, whenever possible, some details regarding the jBPM internal
    mechanisms. The chapter is not meant to be a BPMN tutorial or a BPMN best practices
    modeling guide for which we suggest picking more suitable books and a lot of real-world
    practice. In the next chapter, we will cover the jBPM subsystems API with several
    practical examples: the new Kie API, the runtime engine, the human task service,
    and the persistence engine.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
