["```java\nsourceCompatibility = JavaVersion.VERSION_20\n```", "```java\n$ mkdir api$ cd api\n(you can also use gradlew from other chapter's code)\n$ ../server/gradlew init\nSelect type of project to generate:\n  1: basic\n  2: application\n  3: library\n  4: Gradle plugin\nEnter selection (default: basic) [1..4] 3\nSelect implementation language:\n  1: C++\n  2: Groovy\n  3: Java\n  4: Kotlin\n  5: Scala\n  6: Swift\nEnter selection (default: Java) [1..6] 3\nSelect build script DSL:\n  1: Groovy\n  2: Kotlin\nEnter selection (default: Groovy) [1..2] 1\nGenerate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes, no] no\nSelect test framework:\n  1: JUnit 4\n  2: TestNG\n  3: Spock\n  4: JUnit Jupiter\nEnter selection (default: JUnit Jupiter) [1..4] 4\nProject name (default: api): api\nSource package (default: api): com.packt.modern.api\n> Task :init\nBUILD SUCCESSFUL in 1m 41s\n2 actionable tasks: 2 executed\n```", "```java\n    rootProject.name = 'api/lib/build.gradle file. Add the Protobuf and Maven Publish Gradle plugins. Also, replace the java-library plugin with java, as shown next:\n\n    ```", "```java\n\n    ```", "```java\n    group = 'com.packt.modern.api'version = '0.0.1'sourceCompatibility = JavaVersion.VERSION_17\n    ```", "```java\n    def grpcVersion = '1.54.0'dependencies { implementation \"protoc command-line compiler. The plugin searches for the protoc executable in the system path by default. However, you can add a Protobuf compiler artifact to the plugin, which will make the build file self-sufficient as far as the gRPC compile task is concerned. Let’s configure it as shown in the following code block by adding a protobuf section to the api/libs/build.gradle file:\n\n    ```", "```java\n\n    ```", "```java\n    sourceSets {  main {    proto {      // In addition to the default \"src/main/proto\"      srcDir \"src/main/grpc\"    }  }}task sourcesJar(type: Jar, dependsOn: classes) {    archiveClassifier = \"sources\"    from sourceSets.main.allSource}\n    ```", "```java\n    publishing {  publications {    mavenJava(MavenPublication) {      artifactId = 'payment-gateway-api'      from components.java    }  }}\n    ```", "```java\n    syntax = \"proto3\";                                   //1package com.packtpub.v1;                             //2option java_package = \"com.packt.modern.api.grpc.v1\";//3option java_multiple_files = true;                   //4\n    ```", "```java\n    service ChargeService { rpc Create(CreateChargeReq)     returns(CreateChargeReq.Response); rpc Retrieve(ChargeId)     returns (ChargeId.Response); rpc Update(UpdateChargeReq)     returns(UpdateChargeReq.Response); rpc Capture(CaptureChargeReq)     returns(CaptureChargeReq.Response); rpc RetrieveAll(CustomerId)     returns (CustomerId.Response);}\n    ```", "```java\n    service SourceService {  rpc Create(CreateSourceReq)      returns (CreateSourceReq.Response);  rpc Retrieve(SourceId)      returns (SourceId.Response);  rpc Update(UpdateSourceReq)      returns (UpdateSourceReq.Response);  rpc Attach(AttachOrDetachReq)      returns (AttachOrDetachReq.Response);  rpc Detach(AttachOrDetachReq)      returns (AttachOrDetachReq.Response);}\n    ```", "```java\n    message Charge {  string id = 1;  uint32 amount = 2;  uint32 amountCaptured = 3;  uint32 amountRefunded = 4;  string balanceTransactionId = 5;  BillingDetails billingDetails = 6;  string calculatedStatementDescriptor = 7;  bool captured = 8;  uint64 created = 9;  string currency = 10;  string customerId = 11;  string description = 12;  bool disputed = 13;  uint32 failureCode = 14;  string failureMessage = 15;  string invoiceId = 16;  string orderId = 17;  bool paid = 18;  string paymentMethodId = 19;  PaymentMethodDetails paymentMethodDetails = 20;  string receiptEmail = 21;  string receiptNumber = 22;  bool refunded = 23;  repeated Refund refunds = 24;  string statementDescriptor = 25;  enum Status {    SUCCEEDED = 0;    PENDING = 1;    FAILED = 2;  }  Status status = 26;  string sourceId = 27;}\n    ```", "```java\n    message CreateChargeReq {  uint32 amount = 1;  string currency = 2;  string customerId = 3;  string description = 4;  string receiptEmail = 5;  Source source Id = 6;  string statementDescriptor = 7;  message Response { Charge charge = 1; }}message UpdateChargeReq {  string chargeId = 1;  string customerId = 2;  string description = 3;  string receiptEmail = 4;  message Response { Charge charge = 1; }}message CaptureChargeReq {  string chargeId = 1;  uint32 amount = 2;  string receiptEmail = 3;  string statementDescriptor = 4;  message Response { Charge charge = 1; }}message ChargeId {  string id = 1;  message Response { Charge charge = 1; }}message CustomerId {  string id = 1;  message Response { repeated Charge charge = 1; }}\n    ```", "```java\nenum Flow {  REDIRECT = 0;\n  RECEIVER = 1;\n  CODEVERIFICATION = 2;\n  NONE = 3;\n}\nenum Usage {\n  REUSABLE = 0;\n  SINGLEUSE = 1;\n}\n```", "```java\nmessage Source {  string id = 1;\n  uint32 amount = 2;\n  string clientSecret = 3;\n  uint64 created = 4;\n  string currency = 5;\n  Flow flow = 6;\n  Owner owner = 7;\n  Receiver receiver = 8;\n  string statementDescriptor = 9;\n  enum Status {\n    CANCELLED = 0;\n    CHARGEABLE = 1;\n    CONSUMNED = 2;\n    FAILED = 3;\n    PENDING = 4;\n  }\n  Status status = 10;\n  string type = 11;\n  Usage usage = 12;\n}\n```", "```java\n    message CreateSourceReq {  string type = 1;  uint32 amount = 2;  string currency = 3;  Owner owner = 4;  string statementDescriptor = 5;  Flow flow = 6;  Receiver receiver = 7;  Usage usage = 8;  message Response { Source source = 1; }}message UpdateSourceReq {  string sourceId = 1;  uint32 amount = 2;  Owner owner = 3;  message Response { Source source = 1; }}message SourceId {  string id = 1;  message Response { Source source = 1; }}message AttachOrDetachReq {  string sourceId = 1;  string customerId = 2;  message Response { Source source = 1; }}\n    ```", "```java\n# Make sure to enable UTF-8 for file encoding because# we are using UTF characters in Java files.\n$ export JAVA_TOOL_OPTIONS=\"-Dfile.encoding=UTF8\"\n$ gradlew clean publishToMavenLocal\n```", "```java\n├── server    ├── build.gradle\n    ├── gradle\n    │   └── wrapper\n    ├── gradlew\n    ├── gradlew.bat\n    ├── settings.gradle\n    └── src\n        ├── main\n        │   ├── java\n        │   │   └── com\n        │   │       └── packt\n        │   │           └── modern\n        │   │               └── api\n        │   └── resources\n        └── test\n            └── java\n```", "```java\n    rootProject.name = 'chapter11-server'\n    ```", "```java\n    def grpcVersion = '1.54.1'dependencies { implementation payment-gateway-api dependency is published in the local Maven repository. Therefore, you need to add the local Maven repository to the repositories section in Chapter11/server/build.gradle, as shown in the following code block:\n\n    ```", "```java\n\n    ```", "```java\n@Componentpublic class DbStore {\n private static final Map<String, Source> sourceEntities =\n    new ConcurrentHashMap<>();\n private static final Map<String, Charge> chargeEntities =\n    new ConcurrentHashMap<>();\n public DbStore() {\n  Source source = Source.newBuilder().setId(\n      RandomHolder.randomKey())\n      .setType(\"card\").setAmount(100)\n      .setOwner(createOwner()).\n      setReceiver(createReceiver())\n      .setCurrency(\"USD\").setStatementDescriptor(\"Statement\")\n      .setFlow(Flow.RECEIVER).setUsage(Usage.REUSABLE)\n      .setCreated(Instant.now().getEpochSecond()).build();\n  sourceEntities.put(source.getId(), source);\n  Charge charge = Charge.newBuilder().setId(\n      RandomHolder.randomKey()).setAmount(1000)\n      .setCurrency(\"USD\").setCustomerId(\"ab1ab2ab3ab4ab5\")\n      .setDescription(\"ChargeDescription\")\n      .setReceiptEmail(\"receipt@email.com\")\n      .setStatementDescriptor(\"Statement Descriptor\")\n      .setSourceId(source.getId())\n      .setCreated(Instant.now().getEpochSecond()).build();\n  chargeEntities.put(charge.getId(), charge);\n }\n// continue …\n```", "```java\npublic CreateSourceReq.Response       createSource(CreateSourceReq req) {\n  Source source = Source.newBuilder().setId(\n      RandomHolder.randomKey()).setType(req.getType())\n      .setAmount(req.getAmount()).setOwner(createOwner())\n      .setReceiver(createReceiver())\n      .setCurrency(req.getCurrency())\n      .setStatementDescriptor(req.getStatementDescriptor())\n      .setFlow(req.getFlow()).setUsage(req.getUsage())\n      .setCreated(Instant.now().getEpochSecond()).build();\n  sourceEntities.put(source.getId(), source);\n  return CreateSourceReq.Response.newBuilder()\n         .setSource(source).build();\n}\n```", "```java\n@Repositorypublic class ChargeRepositoryImpl implements\n    ChargeRepository {\n  private DbStore dbStore;\n  public ChargeRepositoryImpl(DbStore dbStore) {\n    this.dbStore = dbStore;\n  }\n  @Override\n  public CreateChargeReq.Response create(\n      CreateChargeReq req) {\n    return dbStore.createCharge(req);\n  }\n  // code truncated for brevity\n```", "```java\n@Repositorypublic class SourceRepositoryImpl\n    implements SourceRepository {\n private DbStore dbStore;\n public SourceRepositoryImpl(DbStore dbStore) {\n   this.dbStore = dbStore;\n }\n @Override\n public UpdateSourceReq.Response update\n    (UpdateSourceReq req) {\n   return dbStore.updateSource(req);\n }\n // Other methods removed for brevity\n```", "```java\n    @Servicepublic class SourceService     extends SourceServiceImplBase {  private final SourceRepository repository;  public SourceService(SourceRepository repository) {    this.repository = repository;  }@Overridepublic void create(CreateSourceReq req, StreamObserver<CreateSourceReq.Response> resObserver) {  CreateSourceReq.Response resp = repository.create      (req);  resObserver.onNext(resp);  resObserver.onCompleted();}// Other methods removed for brevity\n    ```", "```java\n    @Servicepublic class ChargeService       extends ChargeServiceImplBase {  private final ChargeRepository repository;  public ChargeService(ChargeRepository repository) {    this.repository = repository;  }  @Override  public void create(CreateChargeReq req,  StreamObserver<CreateChargeReq.Response>     resObserver) {    CreateSourceReq.Response resp =                                 repository.create(req);    resObserver.onNext(resp);    resObserver.onCompleted();  }  // Other methods truncated for brevity\n    ```", "```java\nspring.main.web-application-type=nonegrpc.port=8080\n```", "```java\n@Componentpublic class GrpcServer {\n  @Value(\"${grpc.port:8080}\");\n  private int port;\n  private Server server;\n  private final ChargeService chargeService;\n  private final SourceService sourceService;\n  private final ExceptionInterceptor exceptionInterceptor;\n  public GrpcServer(…) { // code removed for brevity }\n  public void start() throws IOException,\n     InterruptedException {\n    server = ServerBuilder.forPort(port)\n        .addService(sourceService).\n            addService(chargeService)\n        .intercept(exceptionInterceptor).build().start();\n        server.getServices().stream().forEach(s ->\n           Systen.out.println(\"Service Name: {}\",\n           s.getServiceDescriptor().getName()));\n    Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n       GrpcServer.this.stop();\n    }));\n  }\n  private void stop() {\n    if (server != null) { server.shutdown(); }\n  }\n  public void block() throws InterruptedException {\n    if (server != null) {\n      // received the request until application is\n         terminated\n      server.awaitTermination();\n    }\n  }\n}\n```", "```java\n@Profile(\"!test\")@Component\npublic class GrpcServerRunner implements CommandLineRunner {\n  private GrpcServer grpcServer;\n  public GrpcServerRunner(GrpcServer grpcServer) {\n    this.grpcServer = grpcServer;\n  }\n  @Override\n  public void run(String... args) throws Exception {\n    grpcServer.start();\n    grpcServer.block();\n  }\n}\n```", "```java\n@ActiveProfiles(\"test\")@SpringBootTest\n@TestMethodOrder(OrderAnnotation.class)\nclass ServerAppTests {\n  @Autowired\n  private ApplicationContext context;\n  @Test\n  @Order(1)\n  void beanGrpcServerRunnerTest() {\n    assertNotNull(context.getBean(GrpcServer.class));\n    assertThrows(NoSuchBeanDefinitionException.class,\n        () -> context.getBean(GrpcServerRunner.class),\n        \"GrpcServerRunner should not be loaded during\n          test\");\n  }\n  // continue …\n```", "```java\n@Rulepublic final GrpcCleanupRule grpcCleanup = new\n    GrpcCleanupRule();\nprivate static\n  SourceServiceGrpc.SourceServiceBlockingStub blockingStub;\n@Autowired\nprivate static String newlyCreatedSourceId = null;\n@BeforeAll\npublic static void setup(@Autowired SourceService\n      srcSrvc, @Autowired ChargeService chrgSrvc,\n      @Autowired ExceptionInterceptor exceptionInterceptor)\n      throws IOException {\n String sName = InProcessServerBuilder.generateName(); // 1\n grpcCleanup.register(InProcessServerBuilder\n      .forName(sName).directExecutor().addService(srcSrvc)\n      .intercept(exceptionInterceptor)\n      .build().start());                               // 2\n blockingStub = SourceServiceGrpc.newBlockingStub(\n      grpcCleanup.register(InProcessChannelBuilder\n      .forName(sName).directExecutor().build()));      // 3\n}\n```", "```java\n@Test@Order(2)\n@DisplayName(\"Creates source object using create RPC call\")\npublic void SourceService_Create() {\n  CreateSourceReq.Response response = blockingStub.create(\n     CreateSourceReq.newBuilder().setAmount(100)\n     .setCurrency(\"USD\").build());\n  assertNotNull(response);\n  assertNotNull(response.getSource());\n  newlyCreatedSourceId = response.getSource().getId();\n  assertEquals(100, response.getSource().getAmount());\n  assertEquals(\"USD\", response.getSource().getCurrency());\n}\n```", "```java\n@Test@Order(3)\n@DisplayName(\"Throws exception when invalid source id is\n     passed to retrieve RPC call\")\npublic void SourceService_RetrieveForInvalidId() {\n  Throwable throwable = assertThrows(\n       StatusRuntimeException.class, () -> blockingStub\n       .retrieve(SourceId.newBuilder().setId(\"\").build()));\n  assertEquals(\"INVALID_ARGUMENT: Invalid Source ID passed\"\n       , throwable.getMessage());\n}\n```", "```java\n@Test@Order(4)\n@DisplayName(\"Retrieves source obj created by\n   createRPC call\")\npublic void SourceService_Retrieve() {\n  SourceId.Response response = blockingStub.retrieve\n    (SourceId\n      .newBuilder().setId(newlyCreatedSourceId).build());\n  assertNotNull(response);\n  assertNotNull(response.getSource());\n  assertEquals(100, response.getSource().getAmount());\n  assertEquals(\"USD\", response.getSource().getCurrency());\n}\n```", "```java\n@Componentpublic class ExceptionInterceptor implements ServerInterceptor {\n @Override\n public <RQT, RST> ServerCall.Listener<RQT> interceptCall(\n    ServerCall<RQT, RST> serverCall, Metadata\n        metadata,\n    ServerCallHandler<RQT, RST> serverCallHandler) \n   ServerCall.Listener<RQT> listener = serverCallHandler\n          .startCall(serverCall, metadata);\n   return new ExceptionHandlingServerCallListener <>(\n       listener, serverCall, metadata);\n}\n// continue …\n```", "```java\nprivate class ExceptionHandlingServerCallListener<RQT, RST>    extends ForwardingServerCallListener\n        .SimpleForwardingServerCallListener<RQT> {\n  private final ServerCall<RQT, RST> serverCall;\n  private final Metadata metadata;\n  ExceptionHandlingServerCallListener\n      (ServerCall.Listener<RQT>\n     lsnr,ServerCall<RQT, RST> serverCall, Metadata mdata) {\n    super(lstnr);\n    this.serverCall = serverCall;\n    this.metadata = mdata;\n  }\n  @Override\n  public void onHalfClose() {\n    try { super.onHalfClose();}\n    catch (RuntimeException e) {\n      handleException(e, serverCall, metadata);\n      throw e;\n    }\n  }\n  @Override\n  public void onReady() {\n    try { super.onReady();}\n    catch (RuntimeException e) {\n      handleException(e, serverCall, metadata);\n      throw e;\n    }\n  }\n  private void handleException(RuntimeException e,\n       ServerCall<RQT, RST> serverCall, Metadata metadata) {\n    StatusRuntimeException status = ExceptionUtils.traceException(e);\n    serverCall.close(status.getStatus(), metadata);\n  }\n}\n```", "```java\n@Componentpublic class ExceptionUtils {\nprivate static final Logger LOG = LoggerFactory.getLogger\n    (ExceptionInterceptor.class);\n  public static StatusRuntimeException\n      traceException(Throwable e) {\n    return traceException(e, null);\n  }\n  public static <T extends GeneratedMessageV3> void\n    observeError(StreamObserver<T>\n        responseObserver, Throwable e) {\n    responseObserver.onError(traceException(e));\n  }\n  public static <T extends GeneratedMessageV3> void\n    observeError(StreamObserver<T> responseObserver,\n       Exception\n      e, T defaultInstance) {\n    responseObserver.onError(\n        traceException(e, defaultInstance));\n  }\n  // Continue …\n```", "```java\npublic static <T extends       com.google.protobuf.GeneratedMessageV3>\n         StatusRuntimeException traceException(\n            Throwable e, T defaultInstance) {\n  com.google.rpc.Status status;\n  StatusRuntimeException statusRuntimeException;\n  if (e instanceof StatusRuntimeException) {\n    statusRuntimeException = (StatusRuntimeException) e;\n  } else {\n    Throwable cause = e;\n    if (cause != null && cause.getCause() != null &&\n        cause.getCause() != cause) {\n      cause = cause.getCause();\n    }\n    if (cause instanceof SocketException) {\n      String errorMessage = \"Sample exception message\";\n      status = com.google.rpc.Status.newBuilder()\n          .setCode(com.google.rpc.Code.UNAVAILABLE_VALUE)\n          .setMessage(errorMessage + cause.getMessage())\n          .addDetails(Any.pack(defaultInstance))\n          .build();\n    } else {\n      status = com.google.rpc.Status.newBuilder()\n          .setCode(com.google.rpc.Code.INTERNAL_VALUE)\n          .setMessage(\"Internal server error\")\n          .addDetails(Any.pack(defaultInstance))\n          .build();\n    }\n    statusRuntimeException = StatusProto\n         .toStatusRuntimeException(status);\n  }\n  return statusRuntimeException;\n}\n```", "```java\npublic SourceId.Response retrieveSource(String sourceId) {  if (Strings.isBlank(sourceId)) {\n    com.google.rpc.Status status =\n         com.google.rpc.Status.newBuilder()\n        .setCode(Code.INVALID_ARGUMENT.getNumber())\n        .setMessage(\"Invalid Source ID is\n           passed.\").build();\n    throw StatusProto.toStatusRuntimeException(status);\n  }\n  Source source = sourceEntities.get(sourceId);\n  if (Objects.isNull(source)) {\n    com.google.rpc.Status status =\n         com.google.rpc.Status.newBuilder()\n        .setCode(Code.INVALID_ARGUMENT.getNumber())\n        .setMessage(\"Requested source is not available\")\n        .addDetails(Any.pack(\n           SourceId.Response.getDefaultInstance())\n              ).build();\n    throw StatusProto.toStatusRuntimeException(status);\n  }\n  return SourceId.Response.newBuilder()\n        .setSource(source).build();\n}\n```", "```java\n@Overridepublic void retrieve(SourceId sourceId, StreamObserver<SourceId.Response> resObserver) {\n  try {\n    SourceId.Response resp =\n                      repository.retrieve(sourceId.getId());\n    resObserver.onNext(resp);\n    resObserver.onCompleted();\n  } catch (Exception e) {\n    ExceptionUtils.observeError(resObserver, e,\n                      SourceId.Response.getDefaultInstance());\n  }\n}\n```", "```java\n├── client   ├── build.gradle\n   ├── gradle\n   │   └── wrapper\n   ├── gradlew\n   ├── gradlew.bat\n   ├── settings.gradle\n   └── src\n       ├── main\n       │   ├── java\n       │   │   └── com\n       │   │       └── packt\n       │   │           └── modern\n       │   │               └── api\n       │   └── resources\n       └── test\n           └── java\n```", "```java\n    rootProject.name = 'chapter11-client'\n    ```", "```java\n    def grpcVersion = '1.54.1'dependencies {    implementation 'com.packt.modern.api:payment-      gateway-api:0.0.1'    implementation \"io.grpc:grpc-stub:${grpcVersion}\"    implementation \"com.google.protobuf:protobuf-java-      util:3.22.2\"    implementation 'org.springframework.boot:      spring-boot-starter-web'    testImplementation 'org.springframework.boot:      spring-boot-starter-test'}\n    ```", "```java\n    repositories {  mavenCentral()  mavenLocal()}\n    ```", "```java\nserver.port=8081grpc.server.host=localhost\ngrpc.server.port=8080\n```", "```java\n@Componentpublic class GrpcClient {\n  @Value(\"${grpc.server.host:localhost}\")\n  private String host;\n  @Value(\"${grpc.server.port:8080}\")\n  private int port;\n  private ManagedChannel channel;\n  private SourceServiceBlockingStub sourceServiceStub;\n  private ChargeServiceBlockingStub chargeServiceStub;\n  public void start() {\n    channel = ManagedChannelBuilder.forAddress(host, port)\n        .usePlaintext().build();\n    sourceServiceStub = SourceServiceGrpc\n         .newBlockingStub(channel);\n    chargeServiceStub = ChargeServiceGrpc\n        .newBlockingStub(channel);\n  }\n  public void shutdown() throws InterruptedException {\n    channel.shutdown().awaitTermination\n      (1, TimeUnit.SECONDS);\n  }\n  public SourceServiceBlockingStub getSourceServiceStub() {\n    return this.sourceServiceStub;\n  }\n  public ChargeServiceBlockingStub getChargeServiceStub() {\n    return this.chargeServiceStub;\n  }\n}\n```", "```java\n@Profile(\"!test\")@Component\npublic class GrpcClientRunner implements CommandLineRunner {\n  private static final Logger LOG = LoggerFactory.getLogger\n     (GrpcClient.class);\n  @Autowired\n  GrpcClient client;\n  @Override\n  public void run(String... args) {\n    client.start();\n    Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n      try {\n        client.shutdown();\n      } catch (InterruptedException e) {\n        System.out.println(\"error: {}\", e.getMessage());\n      }\n    }));\n  }\n}\n```", "```java\n@RestControllerpublic class ChargeController {\n  private final GrpcClient client;\n  public ChargeController(GrpcClient client) {\n    this.client = client;\n  }\n  @GetMapping(\"/charges\")\n  public String getSources(@RequestParam(defaultValue =\n      \"ab1ab2ab3ab4ab5\") String customerId)\n        throws InvalidProtocolBufferException {\n    var req = CustomerId.newBuilder()\n        .setId(customerId).build();\n    CustomerId.Response resp =\n       client.getChargeServiceStub().retrieveAll(req);\n    var printer = JsonFormat.printer()\n         .includingDefaultValueFields();\n      return printer.print(resp);\n  }\n}\n```", "```java\n    server project’s root directory (Java should be set to version 17):\n\n    ```", "```java\n    server and client services are up and running, open a new terminal window and execute the following command (the output is truncated):\n\n    ```", "```java\n\n    ```", "```java\n\n    ```", "```java\n    Metadata.Key<SourceId.Response> key = ProtoUtils    .keyForProto(SourceId.Response. getDefaultInstance);Metadata metadata = new Metadata();metadata.put(key, sourceIdResponse);respObserver.onError(Status.INVALID_ARGUMENT   .withDescription(\"Invalid Source ID\")   .asRuntimeException(metadata));\n    ```"]