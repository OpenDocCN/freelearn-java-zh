- en: Chapter 7. Networking with SpiderMonkey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be all about using the networking engine of jMonkeyEngine,
    SpiderMonkey, to take our games beyond the isolation of our own computers to the
    Internet. Don't worry if you're not well versed in networking, we'll take it from
    the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a server and client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling basic messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a networked game – Battleships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a network code for FPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpolating between player positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing over a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the bandwidth and avoiding cheating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data sent over the network is organized in packets, and protocols handle them
    differently. Packets can look different depending on protocols, but they contain
    the data itself along with control information, such as addresses and formatting
    information.
  prefs: []
  type: TYPE_NORMAL
- en: SpiderMonkey supports both TCP and UDP. In SpiderMonkey, TCP is referred to
    as reliable. TCP is reliable because it verifies each network packet sent, minimizing
    problems due to packet loss and other errors. TCP guarantees that everything arrives
    safely (if at all possible). Why ever use anything else then? For speed. Reliability
    means that TCP can be slow. In some cases, we're not dependent on every packet
    reaching the destination. UDP is more suitable for streaming and low-latency applications,
    but the application will have to be prepared to compensate for the unreliability.
    This means that when a packet is lost in FPS, the game needs to know what to do.
    Will it just stop in its tracks, or stutter along? If a character is moving and
    the game can predict the movement between the messages that arrive, it will create
    a smoother experience.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use the API is fairly easy, but we will also see that networking
    is not something you add to a game; the game needs to be adapted for it from the
    planning stage.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a server and client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll look at the absolute minimum in order to get a server
    and client up and running and be able to talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: This is accomplished in just a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: The server and client will share some common data that we'll store inside a
    `properties` file for easy access and external modification. First and foremost,
    the client must know the address of the server, and both server and client need
    to know which port to listen on and connect to. These would most likely be editable
    from within a game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to set up a server and client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor of the server class, we start by loading the properties
    file. Once done, we can initialize the server with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the static block, we must also make sure that the server doesn't shut down
    immediately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The client is set up in a similar way, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To verify that a connection has taken place, we can add `ConnectionListener`
    to the server, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we connect to the server again, we should see the message printed in the
    server's output window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Network` class is the main class used when setting up and connecting our
    components. This particular method is the simplest way to create a server, simply
    stating a port to listen to. Let's set different ports for TCP and UDP and supply
    the name and version of the server.
  prefs: []
  type: TYPE_NORMAL
- en: The `connectToServer` method creates a client and connects it to the specified
    address and port. Like in the server case, there are other convenient methods
    in `Network` that let us specify more parameters if we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s actually all that''s needed. When running the two programs in parallel,
    we should see the client connected to the server. There is no verification, however,
    that anything has happened. That''s why we added `ConnectionListener` at the end.
    It''s an interface with two methods: `connectionAdded` and `connectionRemoved`.
    These methods will be called whenever a client connects or disconnects. These
    methods gave the server a way to communicate to us that a connection has happened.
    These methods will be sources for a chain of events in more advanced recipes.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the server is started, it begins to listen for incoming connections on
    the specified port. If the network address is considered the street name, the
    port will be the door that will be opened and made passable. So far, a mere handshake
    between the server and client has been made at the doorstep.
  prefs: []
  type: TYPE_NORMAL
- en: Handling basic messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've learned the basics to set up a server and connecting a client.
    However, they don't do much, so let's look into what it takes to get them to communicate
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In SpiderMonkey, communication is handled via messaging and the message interface.
    When a server sends a message, it uses the `broadcast()` method, while a client
    uses `send()`. The side that is supposed to receive the message has to have a
    suitable `MessageListener` class. To try all these things out, let's have our
    server greet the connecting player by sending them a message, which will be displayed
    once received.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to connect and handle basic messaging:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by defining our message. It''s a simple serializable bean with just
    one field, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a class that implements `MessageListener`. It''s a very simple
    class that will print the message to the console when received, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We instantiate `ServerMessageHandler` and add it to the client, telling it
    to only listen for `ServerMessages`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also possible to let `ServerMessageHandler` handle all incoming messages
    by using the following line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now tell the server to create a message and send it to all the players when
    someone connects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is one more thing we need to do. All the message classes used need to
    be registered before being used. We do this before the application starts, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spending time and defining what messages should contain is a good way to get
    a grip of the project as a lot of the architecture will revolve around them. The
    message we created in this recipe is called `ServerMessage`, because it is used
    to send a lot of information from the server to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The next class we created was `MessageListener`. The only thing it does upon
    receiving the message is print it to the console. We added it to the client, and
    also stated that it should specifically listen for `ServerMessages`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, calling `broadcast` will send the message to all the connected clients.
    In this case, we just want to send a message to a specific client or a group of
    clients (like a team). Broadcast can also be called with `Filter`. It can also
    send messages to a specific channel, to which a team or group of players might
    be assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Making a networked game – Battleships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we looked at how to set up a server, and connect and
    handle basic messaging. In this recipe, we'll reinforce this knowledge and expand
    it by adding server verification and applying it to a real game.
  prefs: []
  type: TYPE_NORMAL
- en: A turn-based board game is perhaps not what you would normally develop using
    a 3D game SDK, but it's a very good game to learn networking. The Battleships
    game is a good example not only because the rules are simple and known to many
    but also because it has a hidden element, which will help us understand the concept
    of server verification.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're unfamiliar with the Battleships game, visit [http://www.wikipedia.org/wiki/Batt](http://www.wikipedia.org/wiki/Batt).
  prefs: []
  type: TYPE_NORMAL
- en: Since we're mainly interested in the networking aspects of the game, we'll skip
    some of the verification normally needed such as looking for overlapping ships.
    We also won't write any graphical interface and use the command prompt to obtain
    input. Again, to focus on the networking API, some of the plain Java logic for
    game rules won't be explained.
  prefs: []
  type: TYPE_NORMAL
- en: The game will have a client and server class. Each class will have a `MessageListener`
    implementation and share messages and game objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is highly recommended to familiarize yourself with the content of the previous
    recipes in the chapter, if you haven't already.
  prefs: []
  type: TYPE_NORMAL
- en: 'The amount of messages will increase greatly compared to the previous recipes.
    Since both the server and client need to keep a track of the same messages and
    they need to be registered in the same order, we can create a `GameUtil` class.
    It has a static method called `initialize()`. For every new message type we create,
    we add a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The game revolves around a couple of objects that we'll define before getting
    into the networking aspect.
  prefs: []
  type: TYPE_NORMAL
- en: We need a `Ship` class. For this implementation, it only needs the `name` and
    `segments` fields. We add methods so that once a tile containing `Ship` is hit,
    we can decrease the segments. When segments reach zero, it's sunk. Likewise, `Player`
    can be a simple class, with only an ID necessary for identification with the server,
    and the number of ships still alive. If the number of ships reaches zero, the
    player loses.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the message types extend a class called `GameMessage`. This class in
    turn extends `AbstractMessage` and needs to contain the ID of the game, and state
    that the message should be reliable, thus using the TCP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by setting up a `Game` class. This will consist of the following six
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the `Game` class needs an ID. This is used by the server to keep
    track of which game messages to relate to (since it supports many games at the
    same time), and will also be used as a reference for other things.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Game` class needs the two `Player` objects, `player1` and `player2`, as
    well as the ID of the player whose turn it currently is. We can call that `currentPlayerId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Game` class needs two boards; one for each player. The boards will be made
    of 2D `Ship` arrays. Each tile where there is a segment of a ship has a reference
    to the `Ship` object; the others are null.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An integer `status` field lets us know what state the game currently is in,
    which is useful for message filtering. We can also add constants for the different
    statuses and set a default status, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add a `placeShip` method. The method in this implementation is simplified
    and only contains verification that the ship is inside the board, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other method that does some work in the `Game` class is `applyMove`. This
    takes `FireActionMessage` as input, checking the supplied tile to see whether
    there is a ship in that spot. It then checks whether the supposed ship is sunk,
    and whether the player has any ships left. If a ship is hit, it returns the `Ship`
    object to the calling method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s have a look at the server side of things. In the previous chapters,
    we had a look at connecting the clients, but a full game requires a bit more communication
    to set things up as we will see. This section will have the following eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the server is meant to handle several instances of a game at once, we''ll
    define a couple of `HashMaps` to keep a track of the game objects. For each game
    we create, we put the `Game` object in the `games` map with the ID as a key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll also use `Filters` to only send messages to players in a related game.
    To do this, we store a list of `HostedConnections`, with each being an address
    to a client, with the game ID as a key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we''re continuously giving out a new player ID and increasing the value
    of the game ID, we''ll have two fields for that as well: `nextGameId` and `nextPlayerId`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Everything starts with a connecting client. Like in the *Setting up a server
    and client* recipe, we use `ConnectionListener` to handle this. The method either
    adds the player to an existing game, or creates a new one if none are available.
    Regardless of whether a new game is created or not, the `addPlayer` method is
    called afterwards, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `createGame` method creates a new `game` object and sets the correct ID.
    After placing it in the `games` map, it creates a new `List<HostedConnection>`
    called `connsForGame` and adds it to the `connectionFilters` map. The `connsForGame`
    list is empty for now, but will be populated as players connect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first thing the `addPlayer` method does is create a new `Player` object
    and then set the ID of it. We use `WelcomeMessage` to send the ID back to the
    player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The server broadcasts this message using the client''s connection as a filter,
    ensuring it''s the only recipient of the message, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It then decides whether the player is the first or second to connect to the
    game, and adds the player''s `HostedConnection` instance to the list of connections
    associated with this game, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It then creates a `GameStatusMessage` object, letting all players in the game
    know the current status (which is `WAITING`) and any player information it might
    have, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re going to take a look at message handling on the client side and see
    how its `MessageListener` interface will handle incoming `WelcomeMessages` and
    game updates:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class called `ClientMessageHandler`, which implements `MessageListener`.
    First, we will walk through the part handling the start of a game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `thisPlayer` object has already been instanced in the client, so all we
    need to do when receiving `WelcomeMessage` is set the player''s ID. Additionally,
    we can display something to the player letting it know the connection is set up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a `GameStatusMessage` is received, we need to accomplish three things.
    First, set the ID of the game. Knowing the ID of the game is not necessary for
    the client in this implementation, but can be useful for communication with the
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set the `playerOne` and `playerTwo` fields by simply checking whether
    they have been set before or not. We also need to identify the player by comparing
    the IDs of the players in the message with the ID associated with this client.
    Once found, we let him or her start placing ships, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When `TurnMessage` is received, we should extract `activePlayer` from it and
    set it on the game. If `activePlayer` is the same as `thisPlayer` of `gameClient`,
    set `myTurn` to `true` on `gameClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last message to be handled by the class is the `FiringResult` message. This
    calls `applyMove` on the `game` object. Some kind of output should be tied to
    this message telling the player what happened. This example game uses `System.out.println`
    to convey this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, initialize our `ClientMessageHandler` object in the constructor of
    the client class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the received messages handled, we can look at the logic on the client side
    and the messages it sends. This is very limited as most of the game functionality
    is handled by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show how to implement the client-side game logic:'
  prefs: []
  type: TYPE_NORMAL
- en: The `placeShip` method can be written in many different ways. Normally, you
    will have a graphical interface. For this recipe though, we use a command prompt,
    which breaks down the input to *x* and *y* coordinates and whether the ship is
    placed horizontally or vertically. At the end, it should send five instances of
    `PlaceShipMessages` to the server. For each added ship, we also call `thisPlayer.increaseShips()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need a method called `setMyTurn`. This uses the command prompt to receive
    *x* and *y* coordinates to shoot at. After this, it populates `FireActionMessage`,
    which is sent to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `PlaceShipMessage`, create a new class and have it extend `GameMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class needs to contain the ID of the player placing the ship, coordinates,
    and orientation of the ship. The ID of the ship refers to the position in the
    following array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create another class called `FireActionMessage`, which also extends `GameMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This has a reference to the player firing and an *x* and *y* coordinate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Message handling on the server is similar to the one on the client. We have
    a `ServerMessageHandler` class implementing the `MessageListener` interface. This
    has to handle receiving messages from the player placing ships, and firing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `messageReceived` method, catch all `PlaceShipMessages`. Using the
    supplied `gameId`, we get the game instance from the server''s `getGame` method
    and call the `placeShip` method. Once this is done, we check to see whether both
    players have placed all their ships. If that is the case, it''s time to start
    the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `startGame` method, the first thing we need to do is send a message
    to let the players know the game is now started. We know what clients to send
    the message to by getting the list of connections from the `connectionFilters`
    map as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we decide which player will have the first move and send `TurnMessage`
    to the players, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to define `TurnMessage`. It is another simple message, only containing
    the ID of the player whose turn it currently is and extending `GameMessage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in `ServerMessageListener`, we make it ready to receive `FireActionMessage`
    from a player. We begin by verifying that the `playerId` of the incoming message
    matches with the current player on the server side. It can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we call `applyMove` on the game, letting it decide whether it''s a hit
    or not. If it''s a hit, the ship will be returned. It can be implemented by typing
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We go on and create a `FiringResult` message. This is an extension of `FireActionMessage`
    with additional fields for the (possible) ship being hit. It should be broadcasted
    to both the players letting them know whether the action was a hit or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we switch the active player and send another `TurnMessage` to both
    the players as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This flow will continue until one of the players has run out of ships. Then,
    we should simply send `GameStatusMessage` with the `END` status to the players
    and disconnect them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a player launches the client, it will automatically connect to the server
    defined in the properties file.
  prefs: []
  type: TYPE_NORMAL
- en: The server will acknowledge this, assign a user ID to the player, and send back
    `WelcomeMessage` containing the ID. The job of `WelcomeMessage` is to confirm
    the connection to the client, and let the client know its given ID. In this implementation,
    it is used for future communication from the client. Another way of filtering
    incoming messages would be possible using the `HostedConnection` instance, as
    it holds a unique address to the client.
  prefs: []
  type: TYPE_NORMAL
- en: When the first player connects, a new game will be created. The game is put
    in the `WAITING` status until two players have connected, and both have placed
    their ships. For each player connecting, it creates a `GameStatusMessage` letting
    all players in the game know the current status (which is `WAITING`) and any player
    information it might have. The first player, `PlayerOne`, will receive the message
    twice (again when `PlayerTwo` connects), but it doesn't matter as the game will
    be in the `WAITING` status until both players have placed their ships.
  prefs: []
  type: TYPE_NORMAL
- en: The `placeShip` method is simplified and doesn't contain all the verification
    that you will normally have in a full game. Make sure that the the server checks
    whether a ship is outside the board, or overlapping, and make sure it's of the
    right type, length, and so on and send a message back if it is wrong. This method
    simply checks that the ship is inside bounds and skips it if it isn't. Verification
    can also be done on the client, but to limit exploitation, it has to be done on
    the server as well.
  prefs: []
  type: TYPE_NORMAL
- en: The starting player will be selected randomly and sent in a `TurnMessage` to
    both players stating who begins. The player is asked to enter a set of coordinates
    to fire at and `FireActionMessage` is sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The server verifies the player and applies it to the board. It then broadcasts
    a `FireResult` message to all players with information about the action, and whether
    any ships are hit. If the attacked player still has ships left, it becomes his
    or her turn to fire.
  prefs: []
  type: TYPE_NORMAL
- en: Once a player has run out of ships, the game ends. The server broadcasts a message
    to all the clients and disconnects them.
  prefs: []
  type: TYPE_NORMAL
- en: The clients have very little information about the other player. The benefit
    of this is that it makes cheating much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a network code for FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networked FPS games are a genre of games that never seem to lose popularity.
    In this recipe, we'll look at the basics to get a server and multiple clients
    up and running. We will emulate a server with a persistent environment, where
    players can connect and disconnect at any time.
  prefs: []
  type: TYPE_NORMAL
- en: We have the benefit of using some of the code generated in earlier chapters.
    The code we'll use requires some changes to be adapted to a networked game, but
    it will again show the benefit of using jMonkeyEngine's `Control` and `AppState`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good recipes to read up on before this are the previous recipes in this chapter
    (especially *Making a networked game – Battleships*, on which the architecture
    relies heavily) and also the *Creating a reusable character control* recipe from
    [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game
    Controls*, as we will use a similar pattern here for our `NetworkedPlayerControl`
    implementations. To avoid repetition, this recipe will not show or explain all
    of the regular gameplay code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by defining a few classes that will be used commonly across both server
    and client:'
  prefs: []
  type: TYPE_NORMAL
- en: First off, we define a class called `NetworkedPlayerControl` extending `AbstractControl`.
    We will use this both as an identifier for a player object and as a control for
    the spatial representation of the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class will be extended in further recipes, but for now it should keep track
    of an integer called `ID`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also needs an abstract method called `onMessageReceived`, taking `PlayerMessage`
    as input. This is the method that our message handlers will call to apply changes.
    In `ServerPlayerControl`, the message will contain the actual input from the player,
    whereas `ClientPlayerControl` simply replicates what has happened on the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we define a class called `Game`, which will be shared by both the client
    and server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `HashMap` object called `players`, where `playerId` is the key and
    `NetworkedPlayerControl` is the value. It keeps track of the players.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need a couple of new messages for this example. All messages are assumed
    to be in a bean pattern with getters and setters. We define the messages with
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a base message to be used for player-related information and call
    it `PlayerMessage`, extending `AbstractMessage`. This only needs an integer called
    `playerId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create the first message that extends `PlayerMessage`. It is called `PlayerActionMessage`
    and handles player input. This should be set to be reliable as we don't want to
    ever miss a player's input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since player input can either be a key press or mouse click, it needs to have
    both a Boolean value called `pressed` and a float value called `floatValue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, we also have to add a String value called `action`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We extend `PlayerMessage` in another class called `PlayerUpdateMessage`. This
    will be used to distribute player location information from the server to the
    clients. This should not be reliable to avoid unnecessary delays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has a `Vector3f` field called `position` and a `Quaternion` field called
    `lookDirection`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the messages defined, let''s see what the server code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a new class called `FPSServer`, which extends `SimpleApplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It needs to keep track of the following fields. Apart from the `Server` field,
    it also keeps track of the next ID to give to a connecting player, a Game, and
    a Map of all the currently connected players, with their connection as the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like in the previous recipe, we use a class called `GameUtil` to register all
    our message classes. We also set `frameRate` to `30 fps`. This might be different
    depending on the game type. Finally, we start the application in the headless
    mode, to save resources as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We initialize the server as in the *Making a networked game ‑ Battleships* recipe
    and create a `ConnectionListener` instance to look for connecting and disconnecting
    players. This will call `addPlayer` and `removePlayer` respectively, when players
    connect or disconnect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `addPlayer` method, we create a new `ServerPlayerControl` instance,
    which is the server-side implementation of `NetworkedPlayerControl`, and assign
    an ID to it for easier reference, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a spatial for it so that it has a reference in the scene graph
    (and thus, it will be automatically updated). This is not only for visual representation,
    but we are dependent on it to update our method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For any future communication with the server, the client will supply its `playerId`
    in all messages, so the server sends the assigned ID back to the client in `WelcomeMessage`.
    It broadcasts the message using the client''s connection as a filter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we send information about all the other players to the player that joins,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, the server sends a message to all the other players about the new player,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `removePlayer` method works similarly, but it only has to send a message
    to each player currently connected about the disconnected player. It also uses
    `PlayerJoinMessage` but it sets the `leaving` Boolean to `true` to indicate the
    player is leaving, not joining the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, the server will continuously send location and rotation (direction) updates
    to all players. Since we set `fps` to `30`, it will try to do this every 33 ms
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also create a `ServerMessageHandler` class that implements `MessageListener`.
    It''s a short class in this case, which will only listen to messages extending
    `PlayerMessage` and pass it on to the correct `NetworkedPlayerControl` class to
    update it. In this recipe, this will mean the input coming from the player, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the server-side implementation of the `NetworkedPlayerControl` class, we
    extend it to a new class called `ServerPlayerControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to the `GameCharacterControl` class from [Chapter 2](ch02.html "Chapter 2. Cameras
    and Game Controls"), *Cameras and Game Controls*, we will use a set of Booleans
    to keep track of the input, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the implemented `onMessageReceived` method, listen for `PlayerMessages`.
    We don''t know if it will contain Boolean or float values, so we look for both,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we apply the values as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the overridden `controlUpdate` method, we then modify the position and rotation
    of the spatial based on the input, just like we did in the *Creating a reusable
    character control* recipe of [Chapter 2](ch02.html "Chapter 2. Cameras and Game
    Controls"), *Cameras and Game Controls*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The client is simple in many ways, since it basically only does two things.
    It takes a player''s input, sends it to the server, receives updates from the
    server, and applies them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating a new class called `FPSClient` extending `SimpleApplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, we read the network properties file and connect to the
    server, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just as with the server, we register all the message classes before launching
    the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application should have a reference to a `Node` class called `playerModel`,
    which will be the visual representation of the players in the game. There should
    also be a `ClientPlayerControl` class called `thisPlayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `simpleInitApp` method, we attach `InputAppState`. This has the same
    functionality as the one in the *Creating an input AppState object* recipe of
    [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game
    Controls*. The only difference is it will benefit from having a direct way of
    reaching the client to send messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create `playerGeometry` to be used for all the players in this example,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also turn off the application''s `flyByCamera` instance and create a new
    `game` object, which we will populate when we receive information from the server,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we create a new `ClientMessageListener` object and add it to the client,
    as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `createPlayer` method, we create a new `ClientPlayerControl` instance
    and also a `Node` instance, which we attach to the scene graph, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we don''t know when this method will be called, we make sure that we
    attach the spatial in a thread-safe way. This can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we return the created `ClientPlayerControl` instance to the calling
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add a new method called `setThisPlayer`. This method will be called when
    the player''s `WelcomeMessage` is received. Inside this, we create `CameraNode`,
    which will be attached to the player, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also have to override the `destroy` method to make sure we close the connection
    to the server when the client is shutdown. This can be implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to create the client representation of `NetworkedPlayerControl`
    and extend it in a class called `ClientPlayerControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has a `Vector3f` field called `tempLocation` and a `Quaternion` field called
    `tempRotation`. These are used to hold received updates from the server. It can
    also have a `float` field called `yaw` for head movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onMessageReceived` method, we only look for `PlayerUpdateMessages`
    and set `tempLocation` and `tempRotation` with the values received in the message,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then apply the `temp` variable values in the `controlUpdate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just like on the server side, we need a message handler listening for incoming
    messages. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `ClientMessageHandler`, which implements `MessageListener<Client>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ClientMessageHandler` class should have a reference to `FPSClient` in a
    field called `gameClient` and `Game` itself in another field called `game`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `messageReceived` method, we need to handle a number of messages. The
    `WelcomeMessage` is most likely to arrive first. When this happens, we create
    a player object and spatial and assign it to be this client''s player, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `PlayerJoinMessage` is received both when player joins and leaves a game.
    What sets it apart is the `leaving` Boolean. We call both the `game` and `gameClient`
    methods based on whether the player is joining or leaving, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the `PlayerUpdateMessage` is received, we first find the corresponding
    `ClientPlayerControl` class and pass on the message to it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server is running in the headless mode, which means it won't do any rendering
    and there will be no graphical output, but we still have access to the full jMonkeyEngine
    application. In this recipe, one server instance will only have one game active
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate all network messages inside a class called `GameUtil`, since
    they have to be the same (and serialized in the same order) on the client and
    server.
  prefs: []
  type: TYPE_NORMAL
- en: The client will try to connect to the server as soon as it launches. Once connected,
    it will receive `playerId` from the server via `WelcomeMessage`, as well as `PlayerJoinMessages`
    for all other players that are already connected. Likewise, all other players
    will receive `PlayerJoinMessage` with the new player's ID.
  prefs: []
  type: TYPE_NORMAL
- en: The client sends any actions the players perform to the server using `PlayerActionMessage`,
    which applies them to its instance of the game. The server, which runs at 30 fps,
    will send positions and directions of each player to all the other players, using
    `PlayerUpdateMessages`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InputAppState` class on the client is very similar to the one in [Chapter
    2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game Controls*.
    The only difference is that instead of directly updating a `Control` instance,
    it creates a message and sends it to the server. In the `onAction` class, we set
    the Boolean value of the message, whereas in `onAnalog` (to look and rotate),
    `floatValue` will be used instead, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the event of a player leaving the game, `PlayerJoinMessages` will be sent
    to the other players, with `leaving` set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkedPlayerControl` class is an abstract class, and doesn't do much
    on its own. You might recognize the implementation of `ServerPlayerControl` from
    `GameCharacterControl`, and they function similarly, but rather than receiving
    the input directly from the user, `ServerPlayerControl` gets it via a networked
    message instead.
  prefs: []
  type: TYPE_NORMAL
- en: Both the client and server implementation of `NetworkedPlayerControl` use the
    `tempRotation` and `tempLocation` fields to which they apply any incoming changes.
    This is so we don't modify the actual spatial transforms outside the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: We shouldn't be fooled by the relative simplicity of this recipe. It merely
    shows the basics of a real-time networked environment. Making a full game creates
    much more complexity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you'd like to see an example of a full real-time game, have a look at the
    full source of MonkeyZone at [http://hub.jmonkeyengine.org/wiki/doku.php/jme3:advanced:monkey_zone](http://hub.jmonkeyengine.org/wiki/doku.php/jme3:advanced:monkey_zone).
    It features not only human players, but also networked AI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter if it's an FPS, RTS, or driving game we're making, we'll want to be
    able to load different kinds of environments for the players to roam around in.
    How can we do that easily?
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll add functionalities to the networked FPS game we outlined
    previously in this chapter. The principle will work for any kind of already networked
    game, although it might differ depending on how the game implements the level.
    Here, we'll assume it uses jMonkeyEngine scenes or `.j3o` scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following set of steps to load a level:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining a new message class: `LoadLevelMessage`. It extends `GameMessage`
    since it might be useful to know the `gameId`. Apart from that, it has one field
    `levelName`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll add the same field to our `Game` class so that it can keep track of which
    level it's running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s create a `levelNode` field on our server, which we can load our
    level into, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a small method that will load the level from a predefined path,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `simpleInitApp` method, we''ll tell the application to load `TestScene`
    from [Chapter 1](ch01.html "Chapter 1. SDK Game Development Hub"), *SDK Game Development
    Hub*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, inside the `addPlayer` method, we need to create and send the message
    to the connecting client. That's all for the server side of things.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the client, we create a `levelNode` field and a `loadLevel` method, but
    it''s a little bit different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to make sure we manipulate the scene graph at the correct moment in
    time so that we can detach and attach the node inside an `enqueue` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we make sure `MessageListener` picks up `LoadLevelMessage` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! When we connect to the server again, we should see a familiar scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a client joins, the server creates a `LoadLevelMessage` class and populates
    it with the name of the level currently loaded. The server doesn't supply the
    level itself, but the client must have the levels supplied previously. The `LoadLevelMessage`
    class only provides a name in this case, which is probably enough in many cases.
    For some games, it's a good idea to support a custom path when loading levels,
    since it allows for greater customization options.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating between player positions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we were to only run our game in a LAN environment, we would probably never
    expect low latency or any significant packet loss. While many are blessed even
    with good Internet connections nowadays, from time to time, problems still happen.
    One of the tricks to try to mitigate these problems is to use interpolation for
    entities on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: This means that rather than just applying the position and rotation the client
    gets from the server, the client will move towards the target position and rotation
    in steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to interpolate between the player positions:'
  prefs: []
  type: TYPE_NORMAL
- en: To simulate some network problems, set `framerate` on the server to `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you connect to the server now, the movement will be noticeably jerky.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We replace the contents of the `controlUpdate` method of `ClientPlayerControl`
    with the following lines to apply the interpolation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we connect again and compare the experience, it will be much smoother.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simulate an environment with problems such as packet loss, we changed the
    FPS on the server to 10\. Instead of sending out the 30 updates per second it
    did before, it will only send one every tenth of a second. This is not the same
    as 100 ms of latency, since it says nothing about the turnaround time. It's more
    as if two out of three updates were lost on the way, a 66 percent packet loss.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, the client simply took the values it got from the server and applied
    them to the local players. Using interpolation, the player's position and rotation
    will move towards the latest actual position and rotation in steps every update.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the interpolation by first determining the interpolation factor.
    This was done by dividing `tpf` by the amount of time (roughly, in seconds) we
    would like the interpolation to take. The actual time will be longer since the
    steps become shorter with each update.
  prefs: []
  type: TYPE_NORMAL
- en: We then input this value and use the interpolation method of `Vector3f` and
    the `slerp` method of `Quaternion` to move them towards the actual values.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by using a factor based on the `tpf` value provided in the `update`
    method. By doing so, the interpolation time will be roughly the same regardless
    of the frame rate. We should be aware that this in reality becomes latency, a
    delay between the action and appearance, as we have added a slight delay to when
    the player reaches the actual position.
  prefs: []
  type: TYPE_NORMAL
- en: Firing over a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An FPS wouldn't be a shooter unless there's actually some shooting possible.
    We'll look at an example with visible, non-instant bullets. For this, we'll be
    able to reuse some code from [Chapter 2](ch02.html "Chapter 2. Cameras and Game
    Controls"), *Cameras and Game Controls*. The recipe won't describe the actual
    collision as this is already described in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to fire over a network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, we create a new message, called `BulletUpdateMessage` to send
    updates on bullet positions. It only needs two fields: a `Vector3f` field for
    position and a Boolean field for whether it''s alive or not.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll add a check in the `messageReceived` method of `ServerMessageHandler`
    to see whether a player is firing. Any action verification we want to do should
    happen prior to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We find out the direction the player is facing and create a new `ServerBullet`
    instance. It''s assigned the next available object ID and added to the `bullets`
    list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to add another code block to the `simpleUpdate` method to maintain
    the bullets and send out messages, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a `for` loop, we first update the bullet, and then create a new `BulletUpdateMessage`,
    which is sent to all players. If the bullet is out of range, it is removed from
    the list. This is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the client side, we write a new method that creates a new bullet, once it
    receives information from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we need a `removeBullet` method once we receive the information from the
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like in the previous recipes, it's the server that is in control of things.
    The client merely says it wants to fire and any checks happen on the server side
    (although it's fine to mimick verification on the client side to save bandwidth).
    The recipe doesn't contain any specific verifications (a player can fire at any
    time), but this is explained more in [Chapter 2](ch02.html "Chapter 2. Cameras
    and Game Controls"), *Cameras and Game Controls*.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras
    and Game Controls*, we can't use the camera as input; instead, we use the direction
    of the firing player and apply the yaw for up and down tilt.
  prefs: []
  type: TYPE_NORMAL
- en: Bullets are different on the server and client side. On the server, they are
    merely logical objects. Like the non-instant bullets from the *Firing non-instant
    bullets* recipe of [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"),
    *Cameras and Game Controls*, they work like slow rays, moving through the world
    until they hit something or move out of range.
  prefs: []
  type: TYPE_NORMAL
- en: On the client, the bullet is a bit different from the server side, and is based
    on the control pattern. The client finds out about the bullet in `ClientMessageHandler`,
    as the first update is received. It sees if `ClientBullet` exists already, and
    if not, it will create a new one. All `ClientBullet` does then is update the position
    in the `controlUpdate` method.
  prefs: []
  type: TYPE_NORMAL
- en: It's not the actual fire message that creates the bullets, but the first time
    a `BulletUpdateMessage` is received on the client. The client will keep updating
    the Bullet's position, much like the player positions, until a message says it's
    no longer alive. At this point, it will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe currently sends all bullets to all players. As with players, this
    could (and probably should) be based on a need-to-know basis to avoid cheating
    (and excessive bandwidth usage).
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the bandwidth and avoiding cheating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It can be summarized as follows: the less information a client has, the less
    opportunity there is of exploiting said information for cheating. Also, the less
    information a client needs, the less bandwidth is required.'
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we've generously sent information about every player, every update
    cycle. In this recipe, we'll change that so that the server checks what players
    can be seen by others, and only send that information.
  prefs: []
  type: TYPE_NORMAL
- en: We'll build this on top of the *Implementing a network code for FPS* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add some complexity to the `simpleUpdate` method of the server application.
    So, instead of sending information about all players to everybody, we need to
    check who should receive what.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to optimize a bandwidth:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we'll add a visible field to our `PlayerUpdateMessage`. This is
    so that a client knows when a player has disappeared from the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the server side, we need to change two classes. First, our `ServerPlayerControl`
    needs to maintain a list of player IDs it currently sees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we do our checks, we need to make sure all the players are updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we iterate through our `playerMap` object. Here, we add a simple range
    check to see whether a player is visible or not, and lastly broadcast the information
    to the relevant players, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's all for the server side. On the client side, we need to add a visible
    field to `ClientPlayerControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second change we make is in `ClientMessageHandler`. We check whether the
    player is supposed to be visible, and whether it''s attached to the scene graph
    or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using this principle, each client will only receive updates on other relevant
    players. We can't, however, just stop sending updates about certain players without
    also letting the client know why, or they would just freeze in their last known
    position. That's why the last message the server sends about a player is with
    `visible` set to `false`. However, to do so, the server must keep track of when
    a player has disappeared, and not just when it's not visible. That's why each
    `ServerPlayerControl` class needs to keep track of which players it saw the last
    update in its `visibleList`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe focused on the networking aspects of visibility and how and when
    to send updates. A proper game (at least an FPS) will need to keep track of obscured
    players as well, not only how far away they are.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization can be done in different ways, and it all comes down to the application.
    An MMO may for example not be as dependent on frequent updates. In a game like
    that, network updates can be done with less frequency, if a player is further
    away, and instead rely on good interpolation to avoid jerkiness.
  prefs: []
  type: TYPE_NORMAL
- en: If we're using interpolation, and not absolute updates, we should also turn
    off interpolation when visible switches from false to true, to avoid players possibly
    gliding to the new position. We can also turn off updates when visible is false.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Sensing – vision* recipe in [Chapter 5](ch05.html "Chapter 5. Artificial
    Intelligence"), *Artificial Intelligence*, which provides an idea on how to implement
    sight on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
