- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Key Architectural Patterns in Microservices – DDD, CQRS, and Event Sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about appreciation of the backbone of microservices – the
    central patterns that make our software designs strong, scalable, and effective.
  prefs: []
  type: TYPE_NORMAL
- en: So first off, we’ll want to delve into the world of domain-driven design. It’s
    an approach to software that fits business concerns to any given software project.
    It’s akin to ensuring our software speaks the same lingo as the business challenges
    it’s working to answer.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up is Command Query Responsibility Segregation. It’s a nice way to divide
    how we manipulate data in two – one for updating and another for retrieving. It
    divides our software duties in a cleaner, more efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Next, there is Event Sourcing. We record each change as a series of events here.
    It is like an itemized account of everything that has happened – one which can
    be very powerful for looking back at the history of our data and choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we progress through this chapter, we will understand why architectural patterns
    are important and how to apply them in order to build our microservices correctly.
    We will learn not only what architectural patterns are but their practical application
    as well. In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to architectural patterns in microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain-Driven** **Design** (**DDD**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command Query Responsibility** **Segregation** (**CQRS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event Sourcing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brief overview of other architectural patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To better understand this chapter, it would be beneficial if you had knowledge
    in the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solid understanding of microservice architecture principles**: Grasp the
    foundational concepts that underpin microservices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Familiarity with software design patterns**: Know the common patterns that
    solve software design problems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Basic programming concepts**: Have a good command of the fundamental principles
    of programming'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding of distributed systems**: Be aware of how distributed systems
    work and their challenges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Knowledge of microservices’ purpose and implementation**: Understand why
    microservices are used, how they are implemented, and their benefits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grasp of microservice communication and operation**: Know how microservices
    communicate with each other and operate within a larger system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to architectural patterns in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, so in this section, we’re going to look at how to implement design
    patterns into microservices. To really understand this topic, let’s first go over
    some subheadings to help build up the big picture.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need an architectural design in the first place?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An architectural pattern is, simply put, a proven balanced solution from experience
    to tackle some recurring problem in software architecture. These patterns solve
    issues from hardware limitation to high availability and minimizing business risk.
  prefs: []
  type: TYPE_NORMAL
- en: One significant advantage is that they offer ways of solving software problems
    since most of the basic architectural design problems have been already tested.
    They streamline the process through which tightly connected and communicating
    modules that work together with minimal coupling are created. This also helps
    to make the overall system easier to understand and maintain by allowing variations
    in the structure depending on what is actually needed.
  prefs: []
  type: TYPE_NORMAL
- en: Another great advantage is that design patterns help increase the effectiveness
    of communication between developers and designers. When working on system design,
    if developers or designers refer to a pattern by its name, then everyone knows
    the general high-level design they’re talking about right away.
  prefs: []
  type: TYPE_NORMAL
- en: What are design patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Design patterns** are basically templates that developers use to solve common
    problems in software design. Each pattern shows you a typical solution that you
    can then customize for your own project’s needs. For example, if you often have
    to structure a program a certain way, a design pattern can provide a proven approach
    for you to modify as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Microservices** are an architecture style where you basically break up an
    application into a bunch of small, independent services. Each service focuses
    on doing one specific thing really well and communicates with the other services
    through simple protocols. The big benefit is that teams can work on their own
    services separately without affecting the rest of the app.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows teams to focus solely on their specific tasks without worrying
    about how changes might impact other parts of the application. They can iterate
    quickly on their code and features without the need for extensive coordination
    and testing across the entire codebase. When done right, microservices make the
    development process more efficient since teams have autonomy over their own services.
  prefs: []
  type: TYPE_NORMAL
- en: The separation also makes the application more scalable and resilient. Since
    each service is independent, teams can update their code and deploy new versions
    without disrupting the other services. If one service experiences an outage or
    needs to be taken offline for maintenance, it doesn’t bring down the entire application.
    Companies are able to keep their software running smoothly even if some parts
    are temporarily unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the modular design means the application can grow really large
    without everything getting too tangled and complex. New features don’t require
    changes throughout the codebase. Teams can simply build out additional services
    to handle new capabilities. With microservices, companies can build software really
    fast since teams don’t slow each other down by waiting on code reviews and deployments.
  prefs: []
  type: TYPE_NORMAL
- en: The tradeoff is that keeping the services separate takes more work upfront.
    There’s additional complexity in managing the communication between independent
    parts. However, for large applications, microservices provide benefits that outweigh
    the initial cost by enabling rapid, reliable development at scale.
  prefs: []
  type: TYPE_NORMAL
- en: What are the principles behind microservices?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The six main principles behind microservices are autonomy, loose coupling,
    reuse, fault tolerance, composability, and discoverability. Let me explain a bit
    more about each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autonomy** means that each microservice is independent and in control of
    its own runtime and database. This makes it faster and more reliable since it’s
    not dependent on other services. As long as it stays stateless, it can also scale
    up easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loose coupling** means the services don’t rely too much on each other. By
    using standardized APIs, one service can change without affecting the others.
    This allows for more flexibility and evolution over time. It also makes development
    and fixes faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reuse** is still important but at a more specific domain level within the
    business. Teams can decide how to adapt services for new uses case by case. This
    guided reuse approach is better than a rigid predetermined model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance** means each service can keep working even if another fails.
    Things like circuit breakers stop individual failures from spreading. This keeps
    the whole system reliable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composability** means services can deliver value in different combinations.
    Multiple services working together become the new way of building applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discoverability** means each service clearly communicates what business problem
    it solves and how other teams can use its technical interface. This makes it easy
    for developers to understand the microservices’ functionality and how to consume
    the events it publishes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, these six principles of autonomy, loose coupling, reuse, fault tolerance,
    composability, and discoverability form the foundation of microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have discussed why we need an architectural design, what
    design patterns and microservices are, and the principles behind microservices.
    In this section, our focus is on the microservice design patterns. That is, as
    previously explained, design patterns help in such a way that they fix the particular
    challenge of microservice architecture and also help to reduce the risk of failure
    in microservices – but only if we understand them clearly.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is what exactly those design patterns are. Well, I’d like
    to share a diagram that illustrates the big picture of design patterns in microservices
    architecture. It does not cover all design patterns, but the most common designs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Common microservice design patterns](img/B18400_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Common microservice design patterns'
  prefs: []
  type: TYPE_NORMAL
- en: In previous sections, we talked about microservice architecture and the importance
    of having well-defined patterns when you are designing microservices. Microservices
    can get complicated very fast based on the fact that there are so many moving
    parts; design patterns help to take care of some specific problems while reducing
    the risks of failure. In this section, we would like to take a slightly deeper
    dive into some of the most common microservice design patterns that it’s good
    to have an awareness of.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to talk about a couple of the most common microservice design patterns
    and give a bit of explanation about each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregator design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Aggregator pattern is useful when you need to display data from multiple
    microservices on a single page or interface. For example, if you have a dashboard
    that pulls in various metrics and statuses from different services, the Aggregator
    pattern allows you to collect that data in one place efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The API gateway acts as a single entry point or “front door” for your microservices.
    All requests must go through the API gateway, which handles authentication, authorization,
    monitoring, and routing requests to the appropriate services. This provides an
    extra layer of security compared to exposing services directly.
  prefs: []
  type: TYPE_NORMAL
- en: Saga design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Saga pattern is useful when you have a business process that involves multiple
    services, and the steps must be executed transactionally. For example, when posting
    a photo to a social profile, the Saga pattern coordinates saving the photo, updating
    the profile, and notifying followers all in a reliable way, even if some services
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, there are so many different microservice design patterns out there
    these days. It can be tough to decide which ones might work best for your particular
    project. But I’ve found that oftentimes, you can actually use a couple of different
    patterns at the same time, depending on what you’re trying to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say you have a project with multiple independent services,
    all of which need to access the same database. In that case, a Gateway pattern
    might make sense for the database access to avoid having every service connect
    directly. That way you consolidate the database connections through a single service.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time though, some of your services might work really well with a
    Client/Server pattern between them. Maybe one service acts as a server providing
    data to others functioning as clients. So, in that part of the architecture, Client/Server
    could be a good fit.
  prefs: []
  type: TYPE_NORMAL
- en: The main thing is to think about the goals and needs of each individual service
    or group of services. What patterns will help you achieve things such as loose
    coupling, scalability, fault tolerance, and the like? As long as you can clearly
    explain why you’ve selected the patterns that you have, and how they help address
    specific goals, then using more than one pattern in a project is totally reasonable.
    The patterns are there to serve your design – not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing various microservice design patterns and their applications
    for specific architectural challenges, we will move on to the next section. Here,
    we will explore DDD, which will help us understand how each microservice can be
    responsible for domain-specific actions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring DDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to be breaking down DDD for you in a way that’s easy to understand.
    Now if you’ve never heard of DDD before, don’t stress – it’s mainly used for big
    projects that take around six months or longer to complete. But even if you’re
    just doing smaller stuff, learning the basics can still be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: DDD is all about structuring your code around the specific problem or “domain”
    that your software is trying to solve. In simpler terms, it’s organizing your
    code to match what your app is actually about.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we will discuss some basic terminologies such as domain and DDD, and
    then later, we will explore how to implement DDD. Finally, we will go over a real-world
    example.
  prefs: []
  type: TYPE_NORMAL
- en: What is a domain exactly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **domain** refers to the main topic or area that your app focuses on. For
    example, if you’re building an ordering app, the domain would likely be online
    shopping or order processing. It’s important to really understand the domain too,
    because one company could be working in multiple domains at the same time, such
    as shopping, delivery, transportation, repairs – you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a domain might seem too broad, such as “food,” for example. In these
    cases, you should specify the exact part of that industry you’re tackling. Now
    for really big domain models, you can break them into smaller *bounded contexts*
    to make things easier to manage. For example, within a food company, there may
    be separate contexts for the sales team and delivery team, each with its own experts.
  prefs: []
  type: TYPE_NORMAL
- en: These domain experts work closely with developers to nail the functionality.
    Dividing the domain into bounded contexts simplifies the work and keeps everything
    organized.
  prefs: []
  type: TYPE_NORMAL
- en: So, in summary, DDD is a way to develop software for complex problems by focusing
    on domains and contexts to make sure your code matches the specifics of what you’re
    trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: What is DDD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re now going to talk about DDD. DDD is all about deeply linking your code
    to the core concepts or context of your business domain. The goal is to help handle
    complex scenarios by facilitating effective collaboration between the domain experts
    and developers. This way there’s less room for misunderstandings.
  prefs: []
  type: TYPE_NORMAL
- en: DDD really shines in big projects with lots of moving parts, where you need
    experts weighing in and everyone working together. But it’s probably overkill
    for smaller solo projects that you can manage on your own. The key to successful
    collaboration is communication. With DDD, both the developers and experts (such
    as architecture and domain experts) share a common language that they use when
    discussing things, building the domain model, and writing the code. This helps
    speed up the feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: But you have to be careful. If you don’t keep enriching and defining that shared
    language, separate languages could start forming within the teams. And then it’s
    goodbye to effective communication – this causes inaccuracies and confusion. For
    example, the term “client” could mean a user in one context but a system service
    in another. So, it’s super important to clearly define what everything means.
  prefs: []
  type: TYPE_NORMAL
- en: Also, each domain should have its own custom language to avoid conflicts. And
    we’ll want to establish boundaries between domains to prevent cross-contamination.
    One way to shield a domain is with an **Anti-Corruption Layer**. This layer acts
    like a translator between different domain models, using patterns like adapters,
    facades, or translators to help the domains communicate without polluting each
    other. This helps explain what DDD is all about.
  prefs: []
  type: TYPE_NORMAL
- en: How to define DDD structure?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will break down the DDD structure for an online shopping
    app example that we will discuss later in this section. There are a few key layers
    we need to focus on to make our application run smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: First up is the **UI layer**. This is what the customers see when they’re browsing
    on their phones or computers. It displays the products and lets them add stuff
    to their carts and checkout. It takes the user input and sends it to the next
    layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next layer is the **application layer**. Now this layer doesn’t have any
    actual business logic, it just guides the user through the UI process and talks
    to other systems. It organizes all the objects and makes sure the tasks get done
    in the right order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we get to the **domain layer**, which is like the heart and soul of the
    whole operation. This layer has all the core concepts that make the business tick.
    It has things such as users, products, orders – basically anything related to
    the main functions of the app. Each entity has its own unique ID so it can be
    tracked no matter what else changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services here also have predefined behaviors that everyone understands.
    The domain layer stands on its own and doesn’t rely on the other layers, but they
    can all depend on the domain layer since it’s got all the important business rules
    locked down.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we’ve got the **infrastructure layer**. This layer facilitates the
    communication between all the other layers. It also provides things such as libraries
    to help the UI work smoothly. But it doesn’t actually have any business logic
    – it just supports the technical functions behind the scenes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in summary – the UI layer talks to users, the application layer manages
    tasks, the domain layer handles the core business functions, and the infrastructure
    layer helps them all work together seamlessly. Make sure each layer stays focused
    on your app architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.2* helps you understand the relationship between different layers
    visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Relationship between the DDD layers](img/B18400_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Relationship between the DDD layers'
  prefs: []
  type: TYPE_NORMAL
- en: We’re now going to go through an example by following the DDD structure to make
    it clear and picturesque in our mind – we’re going to break down microservices
    using a real-world example of an online store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We all know shopping online is huge these days, so let me walk through how
    an e-commerce site could be structured using a domain-driven design:'
  prefs: []
  type: TYPE_NORMAL
- en: First up, you’ve got to have a **User Service**. This handles all the account
    details – logging in, profiles, addresses, payment information, and all related
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the **Product Service**. This one is in charge of the product catalog
    – keeping track of inventory levels, product details, descriptions – all the information
    about the items you can buy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we have the **Order Service**. As you can probably guess, this one creates
    orders when people checkout. It also processes payments using different methods
    such as credit cards or PayPal. And of course, it ships out orders to customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that is the **Payment Service**. Now this one specifically focuses on
    processing payments from different sources such as Visa, Mastercard, or digital
    wallets. It interacts with the payment gateways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Review Service** manages all the reviews, ratings, and feedback left by
    customers – people should be able to see what others think of a product before
    buying, right?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, we have the **Notification Service**. This one sends out emails
    or push notifications to let customers know about their orders, sales, new products
    – you name it – keeping everyone in the loop!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 2**.3* illustrates these microservices following the DDD approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: The services of the project in DDD structure](img/B18400_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The services of the project in DDD structure'
  prefs: []
  type: TYPE_NORMAL
- en: So, in summary, these are the main microservices an online store might use following
    a DDD approach.
  prefs: []
  type: TYPE_NORMAL
- en: We have a good understanding of a DDD approach now. We segregate the microservices
    per business domain. Next, we will explore CQRS – as you can understand from its
    name, we will again be segregating microservices, but in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about CQRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to talk about CQRS, which is an awesome software
    architecture pattern! CQRS is based on separating the responsibilities of the
    commands and queries in a system. This means we slice our application logic vertically.
  prefs: []
  type: TYPE_NORMAL
- en: By dividing commands and queries, our system becomes greatly efficient. Commands
    focus on data changes without worrying about queries. Queries focus only on reading
    data without impacting commands. Each part of the system optimizes itself, for
    its single purpose. It’s like dividing and conquering to make everything faster!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the context of CQRS with its cons and pros.
    Later on, we will see a real-world scenario and how CQRS help to solve real problems.
  prefs: []
  type: TYPE_NORMAL
- en: What is the context of CQRS?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be thinking, *“Why should I care about CQRS?”* The simple answer is
    efficiency and simplicity. We can easily optimize each part separately when we
    split the app into command and query parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk about these two main components:'
  prefs: []
  type: TYPE_NORMAL
- en: The command side is all about actions – creating, updating, and deleting data.
    As we can see, these are the ‘do-er’ operations of our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other side, the query side is the ‘viewer’ or ‘reader’. It fetches the
    data, but doesn’t make any changes to the state of the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, with such a clear separation, you can see how easy it is to optimize and
    scale commands and queries according to their needs.
  prefs: []
  type: TYPE_NORMAL
- en: However, we must remember that CQRS isn’t a one-size-fits-all solution. If all
    other architecture designs of our system have unbalanced command and query operations,
    then we should choose this design. Otherwise, it will increase the complexity
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap it up, CQRS is all about dividing your application into two parts –
    one for commands (doing) and one for queries (viewing). This separation can lead
    to more efficient, maintainable, and scalable applications. But remember, evaluating
    whether CQRS fits your project’s needs is crucial. And now in the next section,
    we will see the best practices and common mistakes when we implement CQRS in our
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: What are best practices and common pitfalls?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As all other architecture design patterns, there are some best practices to
    follow up and some common mistakes we need to consider while we are implementing
    this architecture design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start simple**: Begin with a plain approach. You don’t need to split every
    piece of your application into commands and queries from the beginning. You are
    still in the microservices realm and can determine each service’s needs individually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep communication clear**: Ensure the communication between the command
    and query sides is well defined. This relates to the next item because if you
    design your database well, you can build clear communication between the command
    and query sides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize database design**: Design your database to suit the split nature
    of CQRS. Please consider this design carefully, this is not just creating a table
    – in this database design, one side of the code inserts data, and the other side
    of the code will view it. You need to pay attention to this database design more
    than other design patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regularly test and refine**: Continuously test and refine your implementation.
    This is an inevitable step for all implementations. You can only be comfortable
    with our designs if we test them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While implementing CQRS, there are some mistakes we want to avoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overcomplication**: You need to be sure that your system is manageable and
    is doing what it needs to do, nothing more, nothing less.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Misjudging the scale**: Implementing CQRS in a system that doesn’t really
    need it is like using an 18-wheeler to drive to the grocery store. You must be
    very careful while assessing whether your application truly benefits from CQRS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ignoring business logic separation**: You must keep our command and query
    responsibilities strictly separate. You need to keep checking this for each pull
    request we create and each code review you do, because if it gets mixed up, the
    application may soon become garbage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Underestimating the learning curve**: You must recognize that CQRS requires
    a learning curve for your team. You need learning tools for new joiners to touch
    base with them on our system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these best practices and avoiding common pitfalls, you can make
    your CQRS implementation successful. It’s about finding that sweet spot for making
    your system efficient without overcomplicating it. Remember, the goal is to create
    a system that’s as smooth and efficient as a well-tuned car, ready to take you
    wherever you need to go.
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of the CQRS design pattern?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With CQRS, you get some totally awesome features including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Independent scaling** – CQRS allows the read and write workloads to scale
    separately, which means fewer slowdowns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimized schemas** – The read side can have a schema perfectly optimized
    for querying, while the write side focuses on updates. With CQRS, you can scale
    the command side (write operations) by adding more instances or resources dedicated
    to handling these commands without necessarily increasing the load on the query
    side querying, while the write side focuses on updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** – It’s way easier to make sure only the right people are making
    writes to the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns** – Splitting read and write means models that are
    so much easier to maintain and adapt. Most complex business logic goes in the
    write model, while reading is simple and sweet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these patterns together maximizes performance at the cost of more complex
    implementation. But it ensures your domain model and data are adaptable to any
    future changes!
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have learned about CQRS, its benefits, best practices, and common
    pitfalls. But CQRS has a twin brother, and they are mostly used together – namely,
    Event Sourcing. In the next section, we will learn about the core concepts of
    Event Sourcing and how they work together with CQRS.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Event Sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to talk about Event Sourcing. We will also examine
    **Event-Driven Architecture** (**EDA**) and will break down the differences between
    EDA and Event Sourcing. Additionally, we mentioned CQRS previously, but in this
    section we will learn where CQRS fits into the whole picture, and I’ll explain
    it all in a way that’s easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Event-Driven Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’re going to break down some key concepts in EDA. *Figure
    2**.4* shows some basic examples of events and commands in this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Examples of events and commands](img/B18400_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Examples of events and commands'
  prefs: []
  type: TYPE_NORMAL
- en: First up, we have **events**. Events are basically things that happen – such
    as a user logging in, or an order being placed. Then we have **commands**. Commands
    are like orders or requests, telling something else to do something.
  prefs: []
  type: TYPE_NORMAL
- en: Events can be communicated as event notifications, and commands as messages.
    These are pretty similar – they both contain information. Sometimes an event notification
    is called a message too. In practice, people often just call both events. But
    technically, an event is something that happens, not a notification about it.
    Events are different from commands, which are more about intention. But for this
    section, we’ll just call them events to keep it simple. These events can have
    data about what happened, or just be a notification. And they’re immutable, meaning
    they can’t be changed once created. EDA is based around these events. There’s
    some debate about whether it’s just events or includes other messages too. But
    for now, just focus on the events flowing through the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so in EDA, there are usually three main **components**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: EDA components](img/B18400_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: EDA components'
  prefs: []
  type: TYPE_NORMAL
- en: First, the **producer** creates the events. Then the **broker** redirects events
    to the right **consumers**, and consumers react to events and take action accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: What is Event Sourcing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will talk about Event Sourcing and how it can be useful
    for tracking changes in your apps. Basically, instead of just saving the final
    state, you can record every single change that happens as an event. These events
    get stored in something called an **event log**, which keeps them in order so
    you can see the full history. By reading through the event log from start to finish,
    you can literally rebuild the entire state of your app! This is what people call
    **event sourcing**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now go through an example event log schema and then talk a bit about one
    of the main features of Event Sourcing – parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: Example of event log schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take the example of an e-commerce store again. Say you want to keep track
    of inventory levels for all your products. Well, you could have a `ProductAdded`
    event that stores the product ID and how many products were added whenever you
    stock up. And when someone buys something, you’d log a `ProductPurchased` event
    with the ID and amount. By replaying all these events in order, you can always
    know the current inventory levels no matter what. Event sourcing is super useful
    for anything where you need the full audit trail of all changes over time. This
    is definitely something worth checking out if you want your apps to have that
    kind of historical data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.6* shows how the events log orders the inventory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Event log – detailed example](img/B18400_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Event log – detailed example'
  prefs: []
  type: TYPE_NORMAL
- en: Now let me break this down for you real quick. First, we add some products to
    our inventory – let’s say we add 10 products. Later on, some customers start buying
    those products. We get a purchase event for one product, then another purchase
    event for another product. Now here’s the cool part – we can look at our event
    log at any time and figure out what our current inventory is! We know we started
    with 10 products. Then we had two purchase events, so that means we must have
    eight products left now.
  prefs: []
  type: TYPE_NORMAL
- en: The key thing about Event Sourcing is that we can reset our inventory to zero
    at any time. We can delete how many products we have. But as long as we have that
    event log, we can always go back and recalculate how many products we should have
    based on all the events!
  prefs: []
  type: TYPE_NORMAL
- en: So, in summary, Event Sourcing uses an event log to keep track of everything
    that happens, so you can always go back in time and see what your data looked
    like at any point and check the previous states of your data. For example, let’s
    say on day 1 you added 10 products to your inventory. On day 2, someone bought
    one product. And on day 3, someone else grabbed another product. With Event Sourcing,
    you can look back and see exactly what your inventory looked like on day 2 or
    even day 1\. This is super useful for debugging or replicating your data somewhere
    else. All you have to do is replay the log of events – there’s no need to manually
    set everything up from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parallel processing is a super useful feature of Event Sourcing when you have
    multiple apps or services reading from the same data source. Instead of each app
    having to wait their turn to read stuff, they can all read at the same time in
    parallel. This is perfect if you have way more readers than writers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have an event log that tracks everything happening in your system.
    Instead of one app reading the log and then the next, they can all read simultaneously,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Parallel processing feature](img/B18400_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Parallel processing feature'
  prefs: []
  type: TYPE_NORMAL
- en: As long as the data in the log doesn’t change, you can have tons of parallel
    reading, no problem. This comes in super clutch because it means each app can
    independently grab what it needs from the log and do its own process without getting
    in the way of the others. They can process in parallel. As long as the log only
    ever adds new events and doesn’t modify old ones, everything stays consistent.
  prefs: []
  type: TYPE_NORMAL
- en: So, parallel reading is a great way to maximize your throughput and take full
    advantage of all your resources.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between Event-Driven Architecture and Event Sourcing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EDA is all about components communicating through events. When something important
    happens in the system, it emits an event. Other components can then **subscribe**
    to those events and react accordingly. This loose coupling makes EDA great for
    scalability and real-time responsiveness. You see it a lot in microservices, messaging
    systems, and IoT apps.
  prefs: []
  type: TYPE_NORMAL
- en: With Event Sourcing, instead of just storing the current data state, it stores
    a log of all the events that changed the data over time. So, the current state
    is reconstructed by replaying all those past events. This is useful for auditing,
    having different versions, and analyzing historical data. Event Sourcing also
    works well with CQRS, which separates reading from writing. The write side stores
    events while the read side is optimized for queries.
  prefs: []
  type: TYPE_NORMAL
- en: While both EDA and Event Sourcing involve events, they focus on different things.
    EDA is more about how components communicate through events. Event Sourcing is
    about persisting event logs to represent state changes over time to benefit from
    things including auditing and versions. You can have Event Sourcing as part of
    an event-driven system, but they each solve their own problems.
  prefs: []
  type: TYPE_NORMAL
- en: A real-world example of the Event Sourcing pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Event Sourcing, every single change is written down in order so that we can
    always look back and see how things changed with timelines. We will understand
    this better with a story about someone named Sarah and how she interacts with
    an online platform. Her activities, say putting up a status or adding contact
    details, are recorded as a series of events. Every event is part of a transaction
    and has a single sequence ID ensuring that every change is tracked to chronology.
    In our following example, every event is kept in **Java Script Object Notation**
    (**JSON**) format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of events created by Sarah’s operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event 1 – Account Creation** – The journey begins with Sarah creating her
    account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Event 2 – Email Update** – Shortly after, Sarah updates her email address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Event 3 – Add Mailing Address** – Sarah then adds a mailing address to her
    profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Event 4 – Name Update** – Later, she decides to update her name on the profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Event 5 – Phone Number Added** – Finally, Sarah adds her phone number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we process these events in the sequence in which they were recorded, we
    are able to reconstruct the current state of Sarah’s profile at any point in time.
    Every event is immutable so once an event is put to record, it cannot be changed.
    This account gives a very clear and comprehensive history of how Sarah’s profile
    has changed with time.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, Event Sourcing presents a very strong framework for recording
    as well as managing changes to the states of systems. It excels in scenarios requiring
    detailed audit trails and historical data analysis. Event Sourcing logs every
    change as a distinct event, providing a powerful overview of data evolution, allowing
    the systems not only to present the current state but to revisit and analyze the
    past states. This, therefore, is an invaluable approach to complex systems where
    understanding the journey of data is as important as the system itself.
  prefs: []
  type: TYPE_NORMAL
- en: The relation of Event Sourcing with CQRS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned, at the beginning of *Event Sourcing* section, that we will discover
    how CQRS fits into the larger picture, so let’s now combine all of the concepts
    we learned in the previous sections. Alright! Basically, with CQRS, the way you
    write data is different from how you read it. In the past, you might have just
    used one database for everything. You could do operations such as inserting data
    and then get it right back out of the same place, and that works fine if you’re
    just doing basic create, read, update, and delete operations. But sometimes you
    might want to scale how much you can write versus read separately. Or maybe you
    need different views of the data for reading versus writing. That’s where CQRS
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.8* shows how commands and queries interact with the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Representation of CQRS pattern](img/B18400_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Representation of CQRS pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that you split up how you write data from how you query or
    get data out. So you could write to one database that’s optimized for the speed
    of inserts, and then have a separate database setup just for reading where you
    combine data from other services to give customized views of the information.
    Separating writing and reading gives you more flexibility to scale both independently
    based on your specific needs. It also lets you transform the data in different
    ways for different uses.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s say we have a few services – we have a Payment service, Shipping service,
    and Order service. Each of these services is keeping track of what’s going on
    in their part of the process using an event log.
  prefs: []
  type: TYPE_NORMAL
- en: The Payment service knows what payments went through and which ones failed.
    The Shipping service knows where all the deliveries are at. The Order service
    has the full history of orders for each user.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to make a page that shows a user all their past orders in one place.
    Well, to do that, our Orders review feature is going to use all three services
    to show all past orders in one place. It’s going to ask the Payment service for
    the payment information, the Shipping service for shipping statuses, and the Order
    service for the basic order details.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Zoom in on the service side](img/B18400_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Zoom in on the service side'
  prefs: []
  type: TYPE_NORMAL
- en: Then it takes all that data and combines it into one nice clean page for the
    user to see the full story of their order history in one spot. Pretty cool how
    even though each service handles its own part independently using events, we can
    still tie them all together to give the user a unified view!
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of using CQRS is that it allows you to split the reads and
    the writes in different systems. This allows you to scale them independently.
    If you’re having more reads than writes, or the other way around, you can scale
    each of these parts independently. You can also have different logic – you can
    have additional processing when you write, or additional layers or capabilities
    when you’re reading. You can also get information from different systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s take a look at how the Event Sourcing and CQRS patterns work
    together in the bigger picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Event Sourcing pattern with CQRS](img/B18400_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Event Sourcing pattern with CQRS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through together through this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UI**: User Interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First up, the UI is like the front desk of our office. This is where you, the
    user, go to interact. You can either give instructions (commands) or ask for information
    (queries).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Command**: Getting things done'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issuing commands through the UI is like sending off requests to get something
    done – maybe adding a new file or updating an existing one. This command is taken
    up by the system, does its magic, and updates our “write” database, where we keep
    track of all these changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Query**: Asking for information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now if it is information you are interested in, that’s a query. It’s like asking
    someone at the office to pull out a file for you. This information is pulled from
    another database specially designed for reading purposes. It’s faster and cleaner,
    sort of like having a set of files ready for viewing each time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Event Sourcing**: Detailed record keeping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And now, the interesting part. Rather than keeping only the latest update, in
    Event Sourcing, a detailed log of every single individual change is kept by the
    system – more like a diary entry for every single action. Each such action, adding
    or taking something away, is recorded as an event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Event Store or Log**: The system’s memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Log or Event Store is literally the memory of the system. It holds on to
    all these event records. If there ever were a need, one could scroll back through
    this log and see its full history of changes or even replay them to understand
    how the system got to its current state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Publishing Events**: Spreading the news'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon successful processing of a command, the system doesn’t just update the
    database, but also broadcasts an event. It functions as an announcement shouting
    at the world what has just changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Event Handler or Bus**: The messenger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event bus or handler is no different than an office messenger. It captures
    the event and delivers the news to all relevant places so that the read database
    is updated with the latest information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Database (Read)**: Optimized for quick access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The read database is there to make access to information rapid and easy. It
    is different from the write database, and it’s set up to enable you to pull information
    swiftly and without hesitation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Materialized View**: Information ready to go'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we come with the materialized view. It’s a snapshot of the data essentially
    already prepared and optimized for your queries. Think of it as a summary report,
    ready at your fingertips.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Figure 2**.10* shows a smart and efficient system, where tasking is neatly
    divided among all the other resources that facilitate and manage the interrogations
    you make to that data warehouse *and* the actual data warehouse itself. On the
    one side, you have commands changing things and on the other side, you have queries
    getting information. And in Event Sourcing, there’s a complete history of every
    change. It’s like running a smooth, highly efficient, organized, and transparent
    company office workflow where nothing is misplaced or lost in the process.'
  prefs: []
  type: TYPE_NORMAL
- en: A real-world example of CQRS with Event Sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I’m going to provide a real-world example diagram of a banking
    system using CQRS with Event Sourcing. We’re going to focus on the bank account
    side. Take, for instance, a bank that has to do with opening accounts, depositing
    money, processing transactions, and closing accounts. To execute these tasks adequately,
    the bank puts into practice a system based on CQRS combined with Event Sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the system works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: Banking example using the CQRS pattern with Event Sourcing](img/B18400_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Banking example using the CQRS pattern with Event Sourcing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down this diagram in simple terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OpenAccountCommand` is like walking into the bank and saying, *“I want to
    open a new account.”* These commands are part of the **Bank Account Command API**,
    which is just some fancy way of saying that this system understands and handles
    what you ask your bank to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command Handler**: This could be considered as the bank employees who take
    your request and initiate the process. The handler ensures all steps necessary
    for your command are taken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventStore**: Everything that a user does (such as opening an account) gets
    stored as an *event* in a special database called the *EventStore*. It’s like
    a meticulous diary of everything that happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Publisher**: This is a loudspeaker in the bank, which tells everyone
    what has just happened. For example, when you open an account, then the event
    publisher goes and tells the whole system, *“Hey, a new account* *was opened!”*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Kafka Message Queue Broker**: Apache Kafka is like the mail system
    at a bank that makes sure messages (events) go to the right department. It’s really
    efficient and even if the bank’s super busy, every single message gets through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Consumer**: This component of the system is a listener. It listens
    for any announcements (events) that are pertinent to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Handler**: If the event consumer is like the employee listening for
    an announcement, then the event handler is the actual employee that takes that
    information and updates the bank’s records accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindAllAccountsQueries`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query Handler**: This is much the same as the customer service representative
    that accepts your query and looks up the information for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read Database**: This is a separate database where the bank holds information
    that can be read – for example, your account balance, or even a list of all the
    accounts. It is organized such that any form of information can be reached easily
    and quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding diagram essentially just details two different processes in the
    bank’s system – one for doing things (for example, the process of opening an account)
    and another for querying things (such as how much money you have in your account).
    They work together but are separate, making the whole bank system run smoothly
    and efficiently. The “doing” part records whatever happens as events and remembers
    everything, while the “asking” part uses a simplified database in order to give
    you quick answers to your questions.
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have learned about some commonly used architecture designs that
    are used in microservice architecture. In the next section, we will briefly discuss
    some other architectural designs.
  prefs: []
  type: TYPE_NORMAL
- en: Brief overview of other architectural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to mention some additional architectural patterns.
    Using patterns is helpful because it makes your development way more efficient
    and productive. It also helps optimize costs and improve planning – basically,
    it just makes everything easier.
  prefs: []
  type: TYPE_NORMAL
- en: There are tons of different enterprise patterns you can check out. To help you
    pick the right ones for your project, I have rounded up summaries of a few of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Service Oriented Architecture (SOA) design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service-oriented design patterns are kind of like building with LEGO blocks
    for software. You break the whole program down into smaller reusable pieces called
    **services**.
  prefs: []
  type: TYPE_NORMAL
- en: Each service has its own specific job to do. It can work on its own without
    needing the whole program. But these services talk to each other to get everything
    done together.
  prefs: []
  type: TYPE_NORMAL
- en: It’s kind of like if you had a big project and broke it into parts for different
    people. Each person focuses just on their part without worrying what the others
    are doing. Then it all comes together in the end.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the software more flexible and easier to change later. Just as with
    LEGO blocks, you can use the same pieces to build lots of different things without
    always starting from scratch. It’s easier to swap things in and out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 2**.12*, we can see the general design of SOA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12: Example of the SOA design pattern](img/B18400_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Example of the SOA design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there is an **Event Service Bus** (**ESB**) in between the services
    and the users. It delegates the tasks among the services. There is a **Shared**
    layer between the services and database systems. Through this layer, all services
    can reach all the data they need, even data that wasn’t created by that given
    service.
  prefs: []
  type: TYPE_NORMAL
- en: So in summary, this pattern breaks programs into smaller communicating services,
    much like breaking projects into parts or building with reusable blocks. It makes
    software simpler to work with as it changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: The Circuit Breaker pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Circuit Breaker pattern is all about building software that can handle problems
    without crashing. Circuit breakers in code work similarly to those in electrical
    circuits. A lot of programs these days rely on lots of different parts all working
    together over a network, right? But sometimes one of those parts can crash. With
    the Circuit Breaker pattern, your program is constantly checking that the different
    pieces are communicating okay. If it notices the same part is erroring out over
    and over, it will temporarily block any more requests to that part. This keeps
    the whole system from getting overwhelmed by one small glitch. Instead of everything
    grinding to a halt, the program can keep chugging along while that problem part
    gets its act together. Pretty handy for creating software that bends but doesn’t
    break!
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand this pattern better, see *Figure 2**.13:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13: Example of the Circuit Breaker pattern](img/B18400_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Example of the Circuit Breaker pattern'
  prefs: []
  type: TYPE_NORMAL
- en: In the Circuit Breaker pattern, as shown in our diagram, **Service A** is the
    main one responsible for dealing with users’ requests and has some critical internal
    components such **Health Checker** and **Request Processor** looking after the
    system healthiness and how it interacts with the users. This **Service A** is
    mediated by the key player, the **Circuit Breaker**, which watches for failed
    requests and as soon as a certain number is reached, it trips just like a real
    circuit breaker, stopping any further requests from taking place to prevent the
    system from getting overloaded, thus allowing for recovery time.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism aimed not only at protecting **Service A** but also a way of
    safeguarding the external dependencies such as **Service B** and databases from
    being overwhelmed. It’s a failsafe that helps bring stability to a system, and
    in turn, prevents the other services that comprise the microservices architecture
    from falling over like dominoes.
  prefs: []
  type: TYPE_NORMAL
- en: The Layered design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Layered design pattern is a way for programmers to structure their code
    in an organized fashion. Basically what it does is break the software up into
    different levels, each with its own specific job.
  prefs: []
  type: TYPE_NORMAL
- en: The levels are stacked on top of each other, with the lower levels providing
    services for the higher ones. So, the bottom level would focus on things such
    as data access or hardware interfaces. Then the next level up could use those
    lower services to do things such as business logic, while the top levels are more
    about interfaces, such as the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: By separating everything like this, it makes the code easier to manage and maintain.
    Programmers can work on individual levels without worrying too much about the
    other pieces. And it’s easier to reuse code since each level has a clear purpose.
    If you need to update how data is stored, you only have to change the bottom level
    rather than digging through the whole program.
  prefs: []
  type: TYPE_NORMAL
- en: Overall it promotes a logical structure where each new level you build on top
    of relies on the work done below. This hierarchical setup helps organize large
    and complex software systems into understandable and manageable chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following *Figure 2**.14*, we can see what the layered design pattern
    looks like overall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14: Example of the Layered design pattern](img/B18400_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Example of the Layered design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the diagram, each layer is isolated from the others, and they
    can’t skip one layer and communicate with another one directly. So, by this design,
    you can keep user interactions in the controller layer, perform the business logic
    in the application layer, and keep database operations in the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MVC** stands for **Model-View-Controller** and basically splits everything
    into three parts. It is such a common design pattern for building web and mobile
    applications!'
  prefs: []
  type: TYPE_NORMAL
- en: The Model is where all the important stuff is stored, such as user accounts,
    posts, products – you name it! That’s the core data and logic of the app.
  prefs: []
  type: TYPE_NORMAL
- en: The View is what the user sees on their screen – things such as HTML, CSS, and
    maybe templates if it’s a single-page app. This renders the Model data so users
    can view it all.
  prefs: []
  type: TYPE_NORMAL
- en: Then we’ve got the Controller! This handles everything the user does including
    clicks, forms, and API calls. When something happens, the Controller figures it
    out, updates the Model if needed, and tells the View to change up.
  prefs: []
  type: TYPE_NORMAL
- en: By separating the code out like this, it stays super clean and organized over
    time. You can tweak one part without messing up the others as much. Plus it gives
    flexibility to reuse or swap pieces in and out.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.15* shows an example MVC design, and we will next discuss how the
    request returns to a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: Example of MVC design pattern](img/B18400_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: Example of MVC design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see a very similar diagram to the previous
    Layered architecture design pattern. However, here, we don’t have an application
    layer. The business logic is divided between the controller and model layers.
    When the user makes a request, after the business logic has been applied, the
    controller returns a view, which can be a web page or a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, MVC is the best pattern for building user interfaces in a way that’s
    maintainable and organized for the long run. It really makes app development a
    total breeze!
  prefs: []
  type: TYPE_NORMAL
- en: The Saga design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Saga design pattern is so cool for building distributed systems! It helps
    manage long transactions and keeps data consistent between different services.
    Maintaining atomicity and consistency is tough when you have multiple related
    steps spread across multiple services. But Saga has you covered!
  prefs: []
  type: TYPE_NORMAL
- en: Saga is perfect when you have a big distributed system made up of many microservices.
    Sometimes you need a business transaction that involves multiple steps happening
    across different services. No problem! With Saga, you can break the transaction
    into a sequence of smaller transactions, with each one fully contained within
    a single service. It coordinates all data flows to make sure each request lines
    up properly in the end, without needing complicated distributed transactions.
    Distributed transactions can be complex and hard to scale, but Saga avoids all
    that for smooth sailing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As reflected in *Figure 2**.16*, the Saga design pattern is a technique to
    deal with complex, multi-service transactions such as the order, payment, and
    shipping services in an e-commerce context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16: Example of the Saga design pattern](img/B18400_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: Example of the Saga design pattern'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down the preceding diagram. The order service initiates a multi-step
    transaction, each step of which gets handled by a different service. They communicate
    through event streams, making sure every step of the transaction happens in order.
    If anything goes wrong with any step, special actions (some abstraction saying
    what happened would be needed, not shown on the diagram) should be taken to *undo*
    previous steps that ensure everything *reverts*. Each service has its own database,
    hence they can operate independently, while the Saga pattern ensures that the
    entire transaction either fully succeeds or is properly compensated in case of
    any hiccups. This is key in managing complicated transactions in systems where
    there are different services that have to work together seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s review what we have learned in this chapter and then look forward to
    the things that we’ll cover next. Here’s what we learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DDD**: A strategy to ensure that our software development work aligns properly
    with the specific requirements of a business. This method guides us to create
    software that really serves its intended purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CQRS**: We learned to manage data effectively, separating the operations
    that change data (commands) from those that retrieve them (queries). This separation
    aims to empower the performance and reliability of our systems, making them more
    feasible in terms of their actual use case scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Sourcing**: This pattern involves the logging of every change in the
    system as an event. It particularly shines when you are tracking changes over
    time and is a fundamental building block for systems where understanding the history
    of decisions and actions throughout their lifetime is core to their operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benefits of design architectures**: We learned how to structure robust, efficient,
    and business-aligned systems, how to structure software in order to manage data
    better, and how to share the expected functional and nonfunctional requirements
    of modern business applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we look forward to [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064), where
    we will learn about building reactive REST APIs using Spring Boot and delve into
    the principles of asynchronous systems and back-pressure. This chapter focuses
    on advanced principles and concepts for designing web applications considering
    our understanding of software architecture from *Chapters 1* and *2* in order
    to develop applications that are both responsive and efficient.
  prefs: []
  type: TYPE_NORMAL
