<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Writing Your First Program</h1>
                </header>
            
            <article>
                
<p class="mce-root">In 2001, Martin Odersky started to design the Scala language <span>– it</span> took him three years to release the first public version. The name comes from Scalable language. This was chosen because Scala is designed to grow with the requirements of its users <span>– </span>you can use Scala for small scripts or for large enterprise applications.</p>
<p class="mce-root">Scala has been constantly evolving ever since, with a growing popularity. As a general purpose language, it is used in many different industries such as finance, telecoms, retail, and media. It is particularly compelling in distributed scalable systems and big data processing. Many leading open source software projects have been developed in Scala, such as Apache Spark, Apache Kafka, Finagle (by Twitter), and Akka. A large number of companies use Scala in production, such as Morgan Stanley, Barclays, Twitter, LinkedIn, The Guardian, and Sony.</p>
<p>Scala is not an extension of Java but is fully interoperable with it. You can call Java code from Scala, and you can call Scala code from Java. There is also a compiler to JavaScript, which we will explore later on in this book. You can, therefore, run Scala code in your browser.</p>
<p>Scala is a blend of object-oriented and functional programming paradigms, and it is statically typed. As such, it can serve as a bridge for people from an object-oriented or imperative background to move gradually to functional programming.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Setting up your environment</li>
<li>Using the basic features</li>
<li>Running the Scala Console</li>
<li>Using the Scala Console and Worksheet</li>
<li>Creating my first project</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up your environment</h1>
                </header>
            
            <article>
                
<p>First things first, we need to set up our work environment. In this section, we will get all the tools and libraries, and then install and configure them on your computer.</p>
<p>Scala programs are compiled to Java bytecode, which is a kind of assembly language that can be executed using a <strong>Java Virtual Machine</strong> (<strong>JVM</strong>). You will, therefore, need to have a Java compiler and a JVM installed on your computer. The <strong>Java Development Kit</strong> (<strong>JDK</strong>) provides both components, alongside other tools.</p>
<p>You could develop in Scala using a simple text editor and compile your programs using the Scala <strong>Simple Build Tool</strong> (<strong>SBT</strong>). However, this would not be a pleasant nor productive experience. The majority of professional Scala developers use an <strong>Integrated Development Environment</strong> (<strong>IDE</strong>), which provides many helpful features such as syntax highlighting, autocompletion, code navigation, integration with SBT, and many more. The most widely used IDE for Scala is IntelliJ Idea from JetBrains, and this is the one we are going to install and use in this book. The other options are Scala IDE for Eclipse and ENSIME. ENSIME is an open source project that brings IDE-like features to popular text editors such as Emacs, Vim, Atom, Sublime, and VSC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the Java SDK</h1>
                </header>
            
            <article>
                
<p>We are going to install the Oracle JDK, which includes a JVM and a Java compiler. On many Linux distributions, the open source OpenJDK is preinstalled. OpenJDK is fully compatible with the Oracle JDK, so if you already have it you do not need to install anything else to follow this book.</p>
<p>You might already have a Java SDK installed on your computer. We are going to check if this is the case. If you are using Windows, open a DOS Command Prompt. If you are using macOS or Linux, open a Terminal. After the prompt, type the following:</p>
<pre class="src src-bash"><strong>javac -version</strong></pre>
<p>If you have a JDK installed, the version of the installed compiler will be printed:</p>
<pre class="src src-bash"><strong>javac <span>1.8.0_112</span></strong></pre>
<p>If the version installed is greater than or equal to 1.8.0_112, you can skip the JDK installation. The version of Scala that we are going to use is compatible with JDK version 1.8 or 1.9.</p>
<p>If not, open the following URL, download the SDK for your platform, and follow the installation instructions given: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing IntelliJ IDEA</h1>
                </header>
            
            <article>
                
<p>Go to <a href="https://www.jetbrains.com/idea/download">https://www.jetbrains.com/idea/download.</a> Download the community edition for your platform. The ultimate edition offers more features, but we will not use them in this book.</p>
<p>The following are the steps to install IntelliJ IDEA:</p>
<ol>
<li>Run IntelliJ Idea.</li>
<li>Select the <span class="packt_screen">Do not import settings</span> option:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a53b8758-c0cc-47b9-8933-e0fbcf1f6f78.png" style="width:40.50em;height:15.92em;"/></p>
<ol start="3">
<li>
<p>Choose a UI theme. I personally prefer <span class="packt_screen">Dracula</span>, since a dark background saves battery on a laptop and is more gentle on the eyes:</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d48ef942-8909-4efa-a8ad-45a47487222a.png"/></p>
<ol start="4">
<li class="mce-root CDPAlignLeft CDPAlign">
<p> Create a desktop entry by checking the options given:</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/06ce0b8c-7f23-4b80-9266-2be97e805fa6.png"/></p>
<ol start="5">
<li class="mce-root CDPAlignLeft CDPAlign">In the <span class="packt_screen">Create Launcher Script</span> dialog window, check the create a script... checkbox. It will let you open files in IntelliJ from the command line:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6714f751-ed3c-4763-a363-49baa5fef44e.png"/></p>
<ol start="6">
<li class="mce-root CDPAlignLeft CDPAlign">Customize the plugins. For each component, click on <span class="packt_screen">Customize...</span> or <span class="packt_screen">Disable All</span>. We will not need most of the plugins. You can only select the following:</li>
</ol>
<ul>
<li style="padding-left: 30px"><span class="packt_screen">Build Tools</span>: <span class="packt_screen">Disable All.</span></li>
<li style="padding-left: 30px"><span class="packt_screen">Version Controls</span>: Only keep Git and GitHub.</li>
<li style="padding-left: 30px"><span class="packt_screen">Test Tools</span>: <span class="packt_screen">Disable All.</span></li>
<li style="padding-left: 30px"><span class="packt_screen">Swing</span>: <span class="packt_screen">Disable.</span></li>
<li style="padding-left: 30px"><span class="packt_screen">Android</span>: <span class="packt_screen">Disable.</span></li>
<li style="padding-left: 30px"><span class="packt_screen">Other Tools</span>: <span class="packt_screen">Disable All</span> and keep Bytecode viewer, Terminal, and YAML.</li>
<li style="padding-left: 30px"><span class="packt_screen">Plugin Development</span>: <span class="packt_screen">Disable.</span></li>
</ul>
<p style="padding-left: 60px">You can see the aforementioned plugins in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7fe5cac6-1d21-4501-837e-c7d3e6618346.png"/></p>
<ol start="7">
<li class="mce-root CDPAlignLeft CDPAlign">Install the featured plugins—<span>s</span>ome additional plugins are proposed for you to install, such as the Scala plugin and a tool to learn the essential features of IntelliJ.</li>
</ol>
<ol start="8">
<li class="mce-root CDPAlignLeft CDPAlign">Click on the <span class="packt_screen">Install</span> button for <span class="packt_screen">Scala<span><span> </span></span></span>and for the<span class="packt_screen"><span><span> </span></span></span><span class="packt_screen">IDE Features Trainer, </span><span>as shown in the following screenshot, and then proceed</span><span> by clicking on </span><span class="packt_screen">Start using IntelliJ IDEA</span><span>:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/56d6e253-1734-428f-998b-2e5c26480292.png"/></p>
<div class="packt_tip"><span>If you are already a Vim aficionado, you can install </span><span class="packt_screen">IdeaVim</span><span>. Otherwise, I would recommend that you avoid it. I personally use it daily, but it took me some time to get used to it.</span></div>
<ol start="8">
<li>Click on <span class="packt_screen">Create New</span> <span class="packt_screen">Project</span> | <span class="packt_screen">Scala</span> | <span class="packt_screen">sbt</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d8ca4efd-cfe5-4dd1-9a31-5e70a3e89f6a.png"/></p>
<ol start="9">
<li>Fill in the following details, as shown in the following screenshot:</li>
</ol>
<ul>
<li style="padding-left: 30px"><span class="packt_screen">Name</span>: <kbd>scala_fundamentals</kbd>.</li>
<li style="padding-left: 30px"><span class="packt_screen">JDK</span>: Click on <span class="packt_screen">New</span> and then select the installation directory of the Oracle JDK.</li>
<li style="padding-left: 30px"><span class="packt_screen">sbt</span>: Choose the version <span class="packt_screen">1.0.4</span>, check <span class="packt_screen">Sources.</span></li>
<li style="padding-left: 30px"><span class="packt_screen">Scala</span>: Choose the latest version 2.12.x, for instance <span class="packt_screen">2.12.4</span> (IntelliJ lists all the possible versions and will download the one you choose), and check <span class="packt_screen">Sources.</span></li>
<li style="padding-left: 30px">Click on <span class="packt_screen">Finish</span>.</li>
</ul>
<p style="padding-left: 60px">It is going to take some time depending on your internet connection's speed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8c23de9f-3e7e-4ede-b12e-93530f90bde3.png"/></p>
<ol start="10">
<li class="mce-root CDPAlignLeft CDPAlign">You should see the following project structure:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3bbba4a-6292-4c12-9705-2312348e3d4e.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the basic features</h1>
                </header>
            
            <article>
                
<p>In this section, and in the rest of this book, we will highlight some key shortcuts in <em>italics</em>. I strongly encourage you to use and remember these shortcuts. They save a tremendous amount of time and will keep you focused on the task at hand. If you cannot remember a shortcut, you can use the mother of all shortcuts, <em>Ctrl</em> + <em>Shift</em> + <em>A</em> (Windows/Linux) or <em>cmd</em> + <em>shift</em> + <em>A</em> (macOS), and type the name of the action you are looking for.</p>
<p>If you are using IntelliJ for the first time, I find it useful to display all tool buttons. Go to the <span class="packt_screen">View</span> menu, and check <span class="packt_screen">Toolbar</span> and <span class="packt_screen">Tool buttons</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SBT synchronization</h1>
                </header>
            
            <article>
                
<p>Now, let's have a look at our build configuration. <strong>SBT</strong> (short for <strong>Simple Build Tool</strong>) is the <em>de facto</em> build tool in the Scala community. Double-click on <kbd>build.sbt</kbd>:</p>
<pre>name := 'scala_fundamentals"<br/><br/>version := "0.1"<br/><br/>scalaVersion := "2.12.4"</pre>
<p>This file describes how SBT will compile, test, and deploy our project. For now, it is fairly simple.</p>
<p>One important thing to keep in mind is that IntelliJ manages its own set of files to define a project structure. They are located in the <kbd>.idea</kbd> directory of your project.<br/>
Whenever you change <kbd>build.sbt</kbd>, IntelliJ has to interpret the changes and translate them.</p>
<p>For instance, If I change the Scala version to <kbd>2.12.3</kbd> and save (<em>Ctrl</em> + <em>S</em> or <em>cmd + S</em>), IntelliJ will propose to synchronize the changes or enable autoimport:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f62ef11e-9c53-4824-8565-37ed0b176394.png"/></p>
<p class="mce-root CDPAlignLeft CDPAlign">On a small project, it is ok to use autoimport, but on a large one, it can be a bit annoying. The synchronization can take time and it might kick off too often.</p>
<p>When you program in Scala using IntelliJ, you therefore have two ways of compiling your project:</p>
<ul>
<li>SBT, in which case you would only use IntelliJ as an advanced text editor</li>
<li>IntelliJ</li>
</ul>
<p>You could, in theory, mix and match: start building with SBT and continue with IntelliJ or the other way around. However, I strongly discourage you to do so, as you may get some unexpected compilation errors. When you want to switch to one tool or the other, it is best to clean all compiled files first.</p>
<p>We will further expand on SBT later in this book, but for now, we are only going to use IntelliJ's own build.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Build</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The project has been created and ready to be built. The build process does the following:</span></p>
<ul>
<li class="mce-root"><span>Compiles the source files present at the source path and the test path</span></li>
<li class="mce-root"><span>Copies any resource files needed in the output path</span></li>
<li class="mce-root"><span>Reports any errors/warnings in the <span class="packt_screen">Message</span> tool window</span></li>
</ul>
<p class="mce-root"><span>There are two ways to build the project:</span></p>
<ul>
<li>If you want to build your project incrementally, go to <span class="packt_screen">Build</span> | <span class="packt_screen">Build Project</span> (<em>Ctrl</em> + <em>F9</em> or <em>cmd + F9</em>)</li>
<li>If you want to delete all files and rebuild everything, go to <span class="packt_screen">Build</span> | <span class="packt_screen">Rebuild All</span></li>
</ul>
<p>As we do not have a source yet, the build is fast and no errors should appear in the <span class="packt_screen">Message</span> tool window.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Scala Console</h1>
                </header>
            
            <article>
                
<p>In IntelliJ, you need to have a run configuration whenever you want to run something: a program, a unit test, an external tool. A run configuration sets up the classpath, arguments, and environment variables that you need to run your executable.</p>
<p>We need to create a run configuration the first time we want to run the Scala console:</p>
<ol>
<li>Go to <span class="packt_screen">Run</span> | <span class="packt_screen">Edit Configurations</span>. Click on the green <span class="packt_screen">+</span> button, and select <span class="packt_screen">Scala Console</span>. You should see the following screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8049a3f1-7e63-45fe-9b26-d5b846ac03f8.png"/></p>
<ol start="2">
<li>Make the following changes and click <span class="packt_screen">OK</span>:</li>
</ol>
<ul>
<li style="padding-left: 30px">Name: <kbd>Scala Console</kbd>.</li>
<li style="padding-left: 30px">Check <span class="packt_screen">Single instance only</span> box <span>– w</span>e rarely need to have two consoles running at the same time.</li>
<li style="padding-left: 30px">In, <span class="packt_screen">Before launch</span>, click on <span class="packt_screen">Build</span> and then click the <span class="packt_screen">Remove</span> button. This way, you will always be able to quickly run a console, even if your code does not compile.</li>
<li class="CDPAlignLeft CDPAlign" style="padding-left: 30px">Following that, click on <span class="packt_screen"><span class="packt_screen">OK.</span></span></li>
</ul>
<ol start="3">
<li>
<p class="CDPAlignLeft CDPAlign"> On the top toolbar, you should see that IntelliJ created a new <span class="packt_screen">Scala Console</span> run configuration:</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/eeec9bab-77cb-48e5-94f3-05d35ba0675a.png" style="width:20.08em;height:2.58em;"/></p>
<ol start="3">
<li>
<p>Click on the green arrow to run the console. You should see the following at the bottom of the screen, in the <span class="packt_screen">Run</span> window. We can now type our first Scala expression after the Scala prompt:</p>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1dff86a2-f0aa-448a-9dcd-af955adf5c0f.png" style="width:41.58em;height:15.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Scala Console and Worksheet</h1>
                </header>
            
            <article>
                
<p>By now, all the necessary tools and libraries should be installed. Let's start to play with the basics of Scala by experimenting in different environments. The simplest way to try Scala is to use the Scala Console. Subsequently, we will introduce the Scala Worksheet, which allows you to keep all the instructions that are entered in a file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Scala Console</h1>
                </header>
            
            <article>
                
<p>The Scala console, also called Scala <strong>REPL</strong> (short for <strong>Read-Eval-Print-Loop</strong>), allows you to execute bits of code without having to compile them beforehand. It is a very convenient tool to experiment with the language or when you want to explore the capabilities of a library.</p>
<p>In the console, type <kbd>1+1</kbd> after the <kbd>scala&gt;</kbd> prompt and hit <em>Ctrl</em> + <em>Enter</em> or <em>cmd + Enter</em>:</p>
<pre>scala&gt; 1+1</pre>
<p>The console displays the result of the evaluation, like so:</p>
<pre>res0: Int = 2</pre>
<p>What happened here? The REPL compiled, evaluated the expression <kbd>1+1</kbd>, and automatically assigned it to a variable named <kbd>res0</kbd>. This variable is of type <kbd>Int</kbd>, and its value is <kbd>2</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring variables</h1>
                </header>
            
            <article>
                
<p><span>In Scala, a variable can be declared using </span><kbd>val</kbd><span> or </span><kbd>var</kbd><span>. A <kbd>val</kbd> is </span><strong>immutable</strong><span>, which means you can never change its value. A </span>var <span>is </span><strong>mutable</strong><span>. It is not mandatory to declare the type of the variable. If you do not declare it, Scala will </span><strong>infer</strong><span> it for you.</span></p>
<p>Let's define some immutable variables:</p>
<div class="packt_infobox">In all the following code examples, you only need to type the code that is after the Scala Command Prompt, and hit <em>Ctrl</em> + <em>Enter</em> or <em>cmd + return</em> to evaluate. We show the result of the evaluation underneath the prompt, as it would appear on your screen.</div>
<pre>scala&gt; val x = 1 + 1<br/>x: Int = 2<br/><br/>scala&gt; val y: Int = 1 + 1<br/>y: Int = 2</pre>
<p>In both cases, the type of the variable is <kbd>Int</kbd>. The type of <kbd>x</kbd> was inferred by the compiler to be <kbd>Int</kbd>. The type of <kbd>y</kbd> was explicitly specified with <kbd>: Int</kbd> after the name of the variable.</p>
<p>We can define a mutable variable and modify it as follows:</p>
<pre>scala&gt; var x = 1<br/>x: Int = 1<br/><br/>scala&gt; x = 2<br/>x: Int = 2</pre>
<p>It is a good practice to use <kbd>val</kbd> in most situations. Whenever I see a <kbd>val</kbd> declared, I know that its content will never change subsequently. It helps to reason about a program, especially when multiple threads are running. You can share an immutable variable across multiple threads without fearing that one thread might see a different value at some point. Whenever you see a Scala program using <kbd>var</kbd>, it should make you raise an eyebrow: <strong>the programmer should have a good reason to use a mutable variable, and it should be documented</strong>.</p>
<p>If we attempt to modify a <kbd>val</kbd>, the compiler will raise an error message:</p>
<pre>scala&gt; val y = 1<br/>y: Int = 1<br/><br/>scala&gt; y = 2<br/>&lt;console&gt;:12: error: reassignment to val<br/>       y = 2<br/>         ^</pre>
<p>This is a good thing: the compiler helps us make sure that no piece of code can ever modify a <kbd>val</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types</h1>
                </header>
            
            <article>
                
<p>We saw in the previous examples that Scala expressions have a <strong>type</strong>. For instance, the <strong>value</strong> <kbd>1</kbd> is of type <kbd>Int</kbd>, and the expression <kbd>1+1</kbd> is also of type <kbd>Int</kbd>. A type is a classification of data and provides a finite or infinite set of values. An expression of a given type can take any of its provided values.</p>
<p>Here are a few examples of types available in Scala:</p>
<ul>
<li><kbd>Int</kbd> provides a finite set of values, which are all the integers between -2<sup>31</sup> and 2<sup>31</sup>-1.</li>
<li><kbd>Boolean</kbd> provides a finite set of two values: <kbd>true</kbd> and <kbd>false</kbd>.</li>
<li><kbd>Double</kbd> provides a finite set of values: all the 64 bits and IEEE-754 floating point numbers.</li>
<li><kbd>String</kbd> provides an infinite set of values: all the sequence of characters are of an arbitrary length. For instance, <kbd>"Hello World"</kbd> or <kbd>"Scala is great !"</kbd>.</li>
</ul>
<p>A type determines the operations that can be performed on the data. For instance, you can use the <kbd>+</kbd> operator with two expressions of type <kbd>Int</kbd> or <kbd>String</kbd>, but not with expressions of type <kbd>Boolean</kbd>:</p>
<pre>scala&gt; val str = "Hello" + "World"<br/>str: String = HelloWorld<br/><br/>scala&gt; val i = 1 + 1<br/>i: Int = 2<br/><br/>scala&gt; val b = true + false<br/>&lt;console&gt;:11: error: type mismatch;<br/> found   : Boolean(false)</pre>
<p>When we attempt to use an operation on a type that does not support it, the Scala compiler complains of a type mismatch error.</p>
<p>An important feature of Scala is that it is a statically typed language. This means that the type of a variable or expression is known at compile time. The compiler will also check that you do not call an operation or function that is not legal for this type. This helps tremendously to reduce the number of bugs that can occur at <strong>runtime</strong> (when running a program).</p>
<p>As we saw earlier, the type of an expression can be specified explicitly with <kbd>:</kbd> followed by the name of the type, or in many cases, it can be automatically inferred by the compiler.</p>
<p>If you are not used to working with statically typed languages, you might get frustrated to have to fight with the compiler to make it accept your code, but you will gradually get more accustomed to the kind of errors thrown at you and how to resolve them. You will soon find that the compiler is not an enemy that prevents you from running your code; it is acting more like a good friend that shows you what logical errors you have made and gives you some indication on how to resolve them.</p>
<p>People coming from dynamically typed languages such as Python, or people coming from not-as-strongly statically typed language such as Java or C++, are often astonished to see that a Scala program that compiles has a much higher probability of being correct on the first run.</p>
<div class="packt_infobox">IntelliJ can automatically add the inferred type to your definitions.<br/>
For instance, type <kbd>val a = 3</kbd> in the Scala console, then move the cursor at the beginning of the <kbd>a</kbd>. You should see a light bulb icon. When you click on it, you will see a hint <em>add type annotation to value definition</em>. Click on it, and IntelliJ will add <kbd>: Int</kbd> after the <kbd>a</kbd>.<br/>
Your definition will become <kbd>val a: Int = 3</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring and calling functions</h1>
                </header>
            
            <article>
                
<p>A Scala function takes <em>0</em> to <em>n</em> <strong>parameters</strong> and returns a value. The type of each parameter must be declared. The type of the returned value is optional, as it is inferred by the Scala compiler when not specified. However, it is a good practice to always specify the return type, as it makes the code more readable:</p>
<pre>scala&gt; def presentation(name: String, age: Int): String = <br/>  "Hello, my name is " + name + ". I am " + age + " years old."<br/>presentation: (name: String, age: Int)String<br/><br/>scala&gt; presentation(name = "Bob", age = 25)<br/>res1: String = Hello, my name is Bob. I am 25 years old.<br/><br/>scala&gt; presentation(age = 25, name = "Bob")<br/><br/>res2: String = Hello, my name is Bob. I am 25 years old.</pre>
<p>We can call a function by passing arguments in the right order, but we can also name the arguments and pass them in any order. It is a good practice to name the arguments when some of them have the same type, or when a function takes many arguments. It avoids passing the wrong argument and improves readability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Side effects</h1>
                </header>
            
            <article>
                
<p>A function or expression is said to have a side effect when it modifies some state or has some action in the outside world. For instance, printing a string to the console, writing to a file, and modifying a <kbd>var</kbd>, are all side effects.</p>
<p><span>In Scala, all expressions have a type. A statement which performs a side effect is of type </span><kbd>Unit</kbd><span>. The only value provided by the type <kbd>Unit</kbd> is </span><kbd>()</kbd><span>:<br/></span></p>
<pre>scala&gt; val x = println("hello")<br/>hello<br/>x: Unit = ()<br/><br/>scala&gt; def printName(name: String): Unit = println(name)<br/>printName: (name: String)Unit<br/><br/>scala&gt; val y = {<br/>  var a = 1<br/>  a = a+1<br/><strong>}</strong><br/>y: Unit = ()<br/><br/>scala&gt; val z = ()<br/>z: Unit = ()</pre>
<p>A pure function is a function whose result depends only on its arguments, and that does not have any observable side effect. Scala allows you to mix side-effecting code with pure code, but it is a good practice to push side-effecting code to the boundaries of your application. We will talk about this later in more detail in the <em>Ensuring referential transparency</em> section in <a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml" target="_blank">Chapter 3</a>, <em>Handling Errors</em>.</p>
<div class="mce-root packt_tip">Good practice: When a function with no parameters has side effects, you should declare it and call it with empty brackets <kbd>()</kbd>. It informs users of your function that it has side effects. Conversely, a pure function with no parameters should not have empty brackets, and should not be called with empty brackets. IntelliJ helps you in keeping some consistency: it will display a warning if you call a parameterless function with <kbd>()</kbd>, or if you omit the <kbd>()</kbd> when you call a function declared with <kbd>()</kbd>.</div>
<p>Here is an example of a method call with a side effect where we have to use empty brackets, and an example of a pure function:</p>
<pre>scala&gt; def helloWorld(): Unit = println("Hello world")<br/>helloWorld: ()Unit<br/><br/>scala&gt;<strong> h</strong>elloWorld()<br/>Hello world<br/><br/>scala&gt; def helloWorldPure: String = "Hello world"<br/>helloWorldPure: String<br/><br/>scala&gt; val x = helloWorldPure<br/>x: String = Hello world</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">If...else expression</h1>
                </header>
            
            <article>
                
<p><span>In Scala, </span><kbd>if (condition) ifExpr else if ifExpr2 else elseExpr</kbd><span> is an expression, and has a type. If all sub-expressions have a type <kbd>A</kbd>, the type of the <kbd>if ... else</kbd> expression will be <kbd>A</kbd> as well:</span></p>
<pre>scala&gt; def agePeriod(age: Int): String = {<br/>  if (age &gt;= 65)<br/>    "elderly"<br/>  else if (age &gt;= 40 &amp;&amp; age &lt; 65)<br/>    "middle aged"<br/>  else if (age &gt;= 18 &amp;&amp; age &lt; 40)<br/>    "young adult"<br/>  else<br/>    "child"<br/>}<br/>agePeriod: (age: Int)String<br/><br/></pre>
<p> If sub-expressions have different types, the compiler will infer a common super-type, or widen the type if it is a numeric type:</p>
<pre>scala&gt; val ifElseWiden = if (true) 2: Int else 2.0: Double<br/>ifElseWiden: Double = 2.0<br/><br/>scala&gt; val ifElseSupertype = if (true) 2 else "2"<br/>ifElseSupertype: Any = 2</pre>
<p>In the first expression present in the preceding code, the first sub-expression is of type <kbd>Int</kbd> and the second is of type <kbd>Double</kbd>. The type of <kbd>ifElseWiden</kbd> is widened to be <kbd>Double</kbd>.</p>
<p>In the second expression, the type of <kbd>ifElseSupertype</kbd> is <kbd>Any</kbd>, which is the common super-type for <kbd>Int</kbd> and <kbd>String</kbd>.</p>
<p><span>An <kbd>if</kbd> without an <kbd>else</kbd> is equivalent to <kbd>if (condition) ifExpr else ()</kbd>. It is better to always specify the <kbd>else</kbd> expression, otherwise, the type of the <kbd>if</kbd>/<kbd>else</kbd> expression might not be the one we expect:</span></p>
<pre class="mce-root">scala&gt; val ifWithoutElse = if (true) 2<br/>ifWithoutElse: AnyVal = 2<br/> <br/>scala&gt; val ifWithoutElseExpanded = if (true) 2: Int else (): Unit<br/>ifWithoutElseExpanded: AnyVal = 2<br/> <br/>scala&gt; def sideEffectingFunction(): Unit = if (true) println("hello world")<br/>sideEffectingFunction: ()Unit</pre>
<p><span>In the preceding code, the common super-type between <kbd>Int</kbd> and <kbd>Unit</kbd> is <kbd>AnyVal</kbd>. This can be a bit surprising. In most situations, you would want to avoid that.</span> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Class</h1>
                </header>
            
            <article>
                
<p>We mentioned earlier that all Scala expressions have a type. A <kbd>class</kbd> is a sort of template that can create objects of a specific type. When we want to obtain a value of a certain type, we can <strong>instantiate</strong> a new <strong>object</strong> using <kbd>new</kbd> followed by the class name:</p>
<pre>scala&gt; class Robot<br/>defined class Robot<br/><br/>scala&gt; val nao = new Robot<br/>nao: Robot = Robot@78318ac2</pre>
<p>The instantiation of an object allocates a portion of <strong>heap</strong> memory in the JVM. In the preceding example, the value <kbd>nao</kbd> is actually a <strong>reference</strong> to the portion of heap memory that keeps the content of our new <kbd>Robot</kbd> object. You can observe that when the Scala console printed the variable <kbd>nao</kbd>, it outputted the name of the class, followed by <kbd>@78318ac2</kbd>. This hexadecimal number is, in fact, the memory address of where the object is stored in the heap.</p>
<p>The <kbd>eq</kbd> operator can be handy to check if two references are equal. If they are equal, this means that they point to the same portion of memory:</p>
<pre>scala&gt; val naoBis = nao<br/>naoBis: Robot = Robot@78318ac2<br/><br/>scala&gt; nao eq naoBis<br/>res0: Boolean = true<br/><br/>scala&gt; val johnny5 = new Robot<br/>johnny5: Robot = Robot@6b64bf61<br/><br/>scala&gt; nao eq johnny5<br/>res1: Boolean = false</pre>
<p>A class can have zero to many <strong>members</strong>. A member can be either:</p>
<ul>
<li>An <strong>attribute</strong>, also called a <strong>field</strong>. It is a variable whose content is unique to each instance of the class.</li>
<li>A <strong>method</strong>. This is a function that can read and/or write the attributes of the instance. It can have additional parameters.</li>
</ul>
<p>Here is a class that defines a few members:</p>
<pre>scala&gt; class Rectangle(width: Int, height: Int) {<br/>  val area: Int = width * height<br/>  def scale(factor: Int): Rectangle = new Rectangle(width * factor, height * factor)<br/>}<br/>defined class Rectangle</pre>
<p>The attributes declared inside the brackets <kbd>()</kbd> are a bit special: they are <strong>constructor arguments</strong>, which means that their value must be specified when we instantiate a new object of the class. The other members must be defined inside the curly brackets <kbd>{}</kbd>. In our example, we defined four members:</p>
<ul>
<li>Two attributes that are constructor arguments: <kbd>width</kbd> and <kbd>height</kbd>.</li>
<li>One attribute, <kbd>area</kbd>. Its value is defined when an instance is created by using the other attributes.</li>
<li>One method, <kbd>scale</kbd>, which uses the attributes to create a new instance of the class <kbd>Rectangle</kbd>.</li>
</ul>
<p>You can call a member on an instance of a class by using the <strong>postfix</strong> notation <kbd>myInstance.member</kbd>. Let's create a few instances of our class and try to call the members:</p>
<pre>scala&gt; val square = new Rectangle(2, 2)<br/>square: Rectangle = Rectangle@2af9a5ef<br/><br/>scala&gt; square.<strong>area</strong><br/>res0: Int = 4<br/><br/>scala&gt; val square2 = square.<strong>scale(2)</strong><br/>square2: Rectangle = Rectangle@8d29719<br/><br/>scala&gt; square2.<strong>area</strong><br/>res1: Int = 16<br/><br/>scala&gt; square.<strong>width</strong><br/>&lt;console&gt;:13: error: value width is not a member of Rectangle<br/>       square.width</pre>
<p>We can call the members <kbd>area</kbd> and <kbd>scale</kbd>, but not <kbd>width</kbd>. Why is that?</p>
<p>This is because, by default, constructor arguments are not accessible from the outside world. They are private to the instance and can only be accessed from the other members. If you want to make the constructor arguments accessible, you need to prefix them with <kbd>val</kbd>:</p>
<div>
<pre>scala&gt; class Rectangle(val width: Int, val height: Int) {<br/>  val area: Int = width * height<br/>  def scale(factor: Int): Rectangle = new Rectangle(width * factor, height * factor)<br/>}<br/>defined class Rectangle<br/><br/>scala&gt; val rect = new Rectangle(3, 2)<br/>rect: Rectangle = Rectangle@3dbb7bb<br/><br/>scala&gt; rect.<strong>width</strong><br/>res3: Int = 3<br/><br/>scala&gt; rect.<strong>height</strong><br/>res4: Int = 2</pre></div>
<p>This time, we can get access to the constructor arguments. Note that you can declare attributes using <kbd>var</kbd> instead of <kbd>val</kbd>. This would make your attribute modifiable. However, in functional programming, we avoid mutating variables. A <kbd>var</kbd> attribute in a class is something that should be used cautiously in specific situations. An experienced Scala programmer would flag it immediately in a code review and its usage should be always justified in a code comment.</p>
<p>If you need to modify an attribute, it is better to return a new instance of the class with the modified attribute, as we did in the preceding <kbd>Rectangle.scale</kbd> method.</p>
<div class="packt_infobox">You might worry that all these new objects will consume too much memory. Fortunately, the JVM has a mechanism known as the <strong>garbage collector</strong>. It automatically frees up the memory used by objects that are not referenced by any variable.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the worksheet</h1>
                </header>
            
            <article>
                
<p>IntelliJ offers another handy tool to experiment with the language: the Scala worksheet.</p>
<p>Go to <span class="packt_screen">File</span> | <span class="packt_screen">New |</span> <span class="packt_screen">Scala Worksheet</span>. Name it <kbd>worksheet.sc</kbd>. You can then enter some code on the left-hand side of the screen. A red/green indicator in the top right corner shows you if the code you are typing is valid or not. As soon as it compiles, the results appear on the right-hand side:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/52041c53-eec6-4efb-a633-65534f6fad94.png"/></p>
<p class="mce-root"/>
<p>You will notice that nothing gets evaluated until your whole worksheet compiles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Class inheritance</h1>
                </header>
            
            <article>
                
<p>Scala classes are extensible. You can extend an existing class to inherit from all its members. If <kbd>B</kbd> extends <kbd>A</kbd>, we say that <kbd>B</kbd> is a <strong>subclass</strong> of <kbd>A</kbd>, a <strong>derivation</strong> of <kbd>B</kbd>, or a <strong>specialization</strong> of <kbd>B</kbd>. <kbd>A</kbd> is a <strong>superclass</strong> of <kbd>B</kbd> or a <strong>generalization</strong> of <kbd>B</kbd>.</p>
<p>Let's see how it works in an example. Type the following code in the worksheet:</p>
<pre><span>class </span>Shape(<span>val </span>x: <span>Int, </span><span>val </span>y: <span>Int</span>) {<br/>  <span>val </span><span>isAtOrigin</span>: <span>Boolean </span>= x == <span>0 </span>&amp;&amp; y == <span>0<br/></span>}<br/><br/><span>class </span>Rectangle(x: <span>Int, </span>y: <span>Int, </span><span>val </span>width: <span>Int, </span><span>val </span>height: <span>Int</span>)<br/>  <span>extends </span>Shape(x, y)<br/><br/><span>class </span>Square(x: <span>Int, </span>y: <span>Int, </span>width: <span>Int</span>)<br/>  <span>extends </span>Rectangle(x<span>, </span>y<span>, </span>width<span>, </span>width)<br/><br/><span>class </span>Circle(x: <span>Int, </span>y: <span>Int, </span><span>val </span>radius: <span>Int</span>)<br/>  <span>extends </span>Shape(x<span>, </span>y)<br/><br/><span>val </span>rect = <span>new </span>Rectangle(x = <span>0</span><span>, </span>y = <span>3</span><span>, </span>width = <span>3</span><span>, </span>height = <span>2</span>)<br/>rect.x<br/>rect.y<br/>rect.<span>isAtOrigin<br/></span>rect.width<br/>rect.height</pre>
<p>The classes <kbd>Rectangle</kbd> and <kbd>Circle</kbd> are subclasses of <kbd>Shape</kbd>. They inherit from all the members of <kbd>Shape</kbd>: <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>isAtOrigin</kbd>. This means that when I instantiate a new <kbd>Rectangle</kbd>, I can call members declared in <kbd>Rectangle</kbd>, such as <kbd>width</kbd> and <kbd>height</kbd>, and I can also call members declared in <kbd>Shape</kbd>.</p>
<p>When declaring a subclass, you need to pass the constructor arguments of the superclass, as if you were instantiating it. As <kbd>Shape</kbd> declares two constructor parameters, <kbd>x</kbd> and <kbd>y</kbd>, we have to pass them in the declaration <kbd>extends Shape(x, y)</kbd>. In this declaration, <kbd>x</kbd> and <kbd>y</kbd> are themselves the constructor arguments of <kbd>Rectangle</kbd>. We just passed these arguments up the chain.</p>
<p>Notice that in the subclasses, the constructor parameters <kbd>x</kbd> and <kbd>y</kbd> are declared without <kbd>val</kbd>. If we had declared them with <kbd>val</kbd>, they would have been promoted as publicly available attributes. The problem is that <kbd>Shape</kbd> also has <kbd>x</kbd> and <kbd>y</kbd> as public attributes. In this situation, the compiler would have raised a compilation error to highlight the conflict.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subclass assignment</h1>
                </header>
            
            <article>
                
<p>Consider two classes, <kbd>A</kbd> and <kbd>B</kbd>, with <kbd>B extends A</kbd>.</p>
<p>When you declare a variable of type <kbd>A</kbd>, you can assign it to an instance of <kbd>B</kbd>, with <kbd>val a: A = new B</kbd>.</p>
<p>On the other hand, if you declare a variable of type <kbd>B</kbd>, you cannot assign it to an instance of <kbd>A</kbd>.</p>
<p>Here is an example that uses the same <kbd>Shape</kbd> and <kbd>Rectangle</kbd> definitions that were described earlier:</p>
<pre><span>val </span>shape: Shape = <span>new </span>Rectangle(x = <span>0</span><span>, </span>y = <span>3</span><span>, </span>width = <span>3</span><span>, </span>height = <span>2</span>)<br/><span>val </span>rectangle: Rectangle = <span>new </span>Shape(x = <span>0</span><span>, </span>y = <span>3</span>)</pre>
<p>The first line compiles because <kbd>Rectangle</kbd> <strong>is a</strong> <kbd>Shape</kbd>.</p>
<p>The second line does not compile, because not all shapes are rectangles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overriding methods</h1>
                </header>
            
            <article>
                
<p>When you derive a class, you can override the members of the superclass to provide a different implementation. Here is an example that you can retype in a new worksheet:</p>
<pre><span>class </span>Shape(<span>val </span>x: <span>Int, </span><span>val </span>y: <span>Int</span>) {<br/>  <span>def </span><span>description</span>: <span>String </span>= <span>s"Shape at (" </span>+ x + <span>"," </span>+ y + <span>")"<br/></span>}<br/><br/><span>class </span>Rectangle(x: <span>Int, </span>y: <span>Int, </span><span>val </span>width: <span>Int, </span><span>val </span>height: <span>Int</span>)<br/>  <span>extends </span>Shape(x<span>, </span>y) {<br/>  <span><strong>override</strong> def </span><span>description</span>: <span>String </span>= {<br/>    <strong>super.description</strong> + <span>s" - Rectangle " </span>+ width + <span>" * " </span>+ height<br/>  }<br/>}<br/><br/><span>val </span>rect = <span>new </span>Rectangle(x = <span>0</span><span>, </span>y = <span>3</span><span>, </span>width = <span>3</span><span>, </span>height = <span>2</span>)<br/>rect.description</pre>
<p>When you run the worksheet, it evaluates and prints the following <kbd>description</kbd> on the right-hand side:</p>
<pre>res0: String = Shape at (0,3) - Rectangle 3 * 2</pre>
<p>We defined a method <kbd>description</kbd> on the class <kbd>Shape</kbd> that returns a String. When we call <kbd>rect.description</kbd>, the method called is the one defined in the class <kbd>Rectangle</kbd>, because <kbd>Rectangle</kbd> overrides the method <kbd>description</kbd> with a different implementation.</p>
<p>The implementation of <kbd>description</kbd> in the class <kbd>Rectangle</kbd> refers to <kbd>super.description</kbd>. <kbd>super</kbd> is a keyword that lets you use the members of the superclass without taking into account any overriding. In our case, this was necessary so that we could use the <kbd>super</kbd> reference, otherwise, <kbd>description</kbd> would have called itself in an infinite loop!</p>
<p>On the other hand, the keyword <kbd>this</kbd> allows you to call the members of the same class. Change <kbd>Rectangle</kbd> to add the following methods:</p>
<pre><span>class </span>Rectangle(x: <span>Int, </span>y: <span>Int, </span><span>val </span>width: <span>Int, </span><span>val </span>height: <span>Int</span>)<br/>  <span>extends </span>Shape(x<span>, </span>y) {<br/>  <span>override def </span><span>description</span>: <span>String </span>= {<br/>    <span>super</span>.description + <span>s" - Rectangle " </span>+ width + <span>" * " </span>+ height<br/>  }<br/><br/>  <span>def </span><span>descThis: String </span>= <strong>this</strong>.description<br/>  <span>def </span><span>descSuper: String </span>= <strong>super</strong>.description<br/>}<br/><br/><span>val </span>rect = <span>new </span>Rectangle(x = <span>0</span><span>, </span>y = <span>3</span><span>, </span>width = <span>3</span><span>, </span>height = <span>2</span>)<br/>rect.description<br/>rect.descThis<br/>rect.descSuper</pre>
<p>When you evaluate the worksheet, it prints the following strings:</p>
<pre>res0: String = Shape at (0,3) - Rectangle 3 * 2<br/>res1: String = Shape at (0,3) - Rectangle 3 * 2<br/>res2: String = Shape at (0,3)</pre>
<p>The call to <kbd>this.description</kbd> used the definition of <kbd>description</kbd>, as declared in the class <kbd>Rectangle</kbd>, whereas the call to <kbd>super.description</kbd> used the definition of <kbd>description</kbd>, as declared in the class <kbd>Shape</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstract class</h1>
                </header>
            
            <article>
                
<p>An abstract class is a class that can have many abstract members. An <strong>abstract member</strong> defines only a signature for an attribute or a method, without providing any implementation. You cannot instantiate an abstract class: you must create a subclass that implements all the abstract members.</p>
<p>Replace the definition of <kbd>Shape</kbd> and <kbd>Rectangle</kbd> in the worksheet as follows:</p>
<pre><span><strong>abstract</strong> class </span>Shape(<span>val </span>x: <span>Int, </span><span>val </span>y: <span>Int</span>) {<br/>  <span>val </span>area: <span>Double<br/></span><span>  </span><span>def </span><span>description</span>: <span>String<br/></span>}<br/><br/><span>class </span>Rectangle(x: <span>Int, </span>y: <span>Int, </span><span>val </span>width: <span>Int, </span><span>val </span>height: <span>Int</span>)<br/>  <span>extends </span>Shape(x<span>, </span>y) {<br/><br/>  <span>val </span><span>area</span>: <span>Double </span>= width * height<br/><br/>  <span>def </span><span>description</span>: <span>String </span>=<br/>    <span>"Rectangle " </span>+ width + <span>" * " </span>+ height<br/>}</pre>
<p>Our class <kbd>Shape</kbd> is now abstract. We cannot instantiate a <kbd>Shape</kbd> class directly anymore: we have to create an instance of <kbd>Rectangle</kbd> or any of the other subclasses of <kbd>Shape</kbd>. <kbd>Shape</kbd> defines two concrete members, <kbd>x</kbd> and <kbd>y</kbd>, and two abstract members, <kbd>area</kbd> and <kbd>description</kbd>. The subclass, <kbd>Rectangle</kbd>, implements the two abstract members.</p>
<div class="packt_infobox">You can use the prefix <kbd>override</kbd> when implementing an abstract member, but it is not necessary. I recommend <strong>not</strong> adding it to keep the code less cluttered. Also, if you subsequently implement the abstract method in the superclass, the compiler will help you find all subclasses that had an implementation. It will not do this if they use <kbd>override</kbd>. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trait</h1>
                </header>
            
            <article>
                
<p>A trait is similar to an abstract class: it can declare several abstract or concrete members and can be extended. It cannot be instantiated. The difference is that a given class can only extend one abstract class, however, it can <strong>mixin</strong> one to many traits. Also, a trait cannot have constructor arguments.</p>
<p>For instance, we can declare several traits, each declaring different abstract methods, and mixin them all in the <kbd>Rectangle</kbd> class:</p>
<pre><span>trait </span>Description {<br/>  <span>def </span><span>description</span>: <span>String<br/></span>}<br/><br/><span>trait </span>Coordinates <span>extends </span>Description {<br/>  <span>def </span><span>x</span>: <span>Int<br/></span><span>  </span><span>def </span><span>y</span>: <span>Int<br/></span><span><br/></span><span>  </span><span>def </span><span>description</span>: <span>String </span>=<br/>    <span>"Coordinates (" </span>+ x + <span>", " </span>+ y + <span>")"<br/></span>}<br/><br/><span>trait </span>Area {<br/>  <span>def </span><span>area</span>: <span>Double<br/></span>}<br/><br/><span>class </span>Rectangle(<span>val </span>x: <span>Int,<br/></span><span>                </span><span>val </span>y: <span>Int,<br/></span><span>                </span><span>val </span>width: <span>Int,<br/></span><span>                </span><span>val </span>height: <span>Int</span>)<br/>  <strong>extends </strong>Coordinates <strong>with </strong>Description <strong>with </strong>Area {<br/><br/>  <strong>val </strong><span>area</span>: <span>Double </span>= width * height<br/><br/>  <span><strong>override</strong> def </span><span>description</span>: <span>String </span>=<br/>    <span>super</span>.description + <span>" - Rectangle " </span>+ width + <span>" * " </span>+ height<br/>}<br/><br/><span>val </span>rect = <span>new </span>Rectangle(x = <span>0</span><span>, </span>y = <span>3</span><span>, </span>width = <span>3</span><span>, </span>height = <span>2</span>)<br/>rect.description</pre>
<p>The following string gets printed when evaluating <kbd>rect.description</kbd>:</p>
<pre>res0: String = Coordinates (0, 3) - Rectangle 3 * 2</pre>
<p>The class <kbd>Rectangle</kbd> mixes in the traits <kbd>Coordinates</kbd>, <kbd>Description</kbd>, and <kbd>Area</kbd>. We need to use the keyword <kbd>extends</kbd> before <kbd>trait</kbd> or <kbd>class</kbd>, and the keyword <kbd>with</kbd> for all subsequent traits.</p>
<p>Notice that the <kbd>Coordinates</kbd> trait also mixes the <kbd>Description</kbd> trait, and provides a default implementation. As we did when we had a <kbd>Shape</kbd> class, we override this implementation in <kbd>Rectangle</kbd>, and we can still call <kbd>super.description</kbd> to refer to the implementation of <kbd>description</kbd> in the <kbd>trait Coordinates</kbd>.</p>
<p>Another interesting point is that you can implement an abstract method with <kbd>val</kbd><span> – </span>in <kbd>trait Area</kbd>, we defined <kbd>def area: Double</kbd>, and implemented it in <kbd>Rectangle</kbd> using <kbd>val area: Double</kbd>. It is a good practice to define abstract members with <kbd>def</kbd>. This way, the implementer of the trait can decide whether to define it by using a method or a variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scala class hierarchy</h1>
                </header>
            
            <article>
                
<p>All Scala types extend a built-in type called <kbd>Any</kbd>. This type is the root of the hierarchy of all Scala types. It has two direct subtypes:</p>
<ul>
<li><kbd>AnyVal</kbd> is the root class of all value types. These types are represented as primitive types in the JVM.</li>
<li><kbd>AnyRef</kbd> is the root class of all object types. It is an alias for the class <kbd>java.lang.Object</kbd>.</li>
<li>A variable of type <kbd>AnyVal</kbd> directly contains the value, whereas a variable of type <kbd>AnyRef</kbd> contains the address of an object stored somewhere in memory.</li>
</ul>
<p>The following diagram shows a partial view of this hierarchy:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/efce7006-377a-4192-8a78-3687ddd9ec87.png"/></p>
<p>When you define a new class, it indirectly extends <kbd>AnyRef</kbd>. This being an alias for <kbd>java.lang.Object</kbd>, your class inherits from all the default methods implemented in <kbd>Object</kbd>. Its most important methods are as follows:</p>
<ul>
<li><kbd>def toString: String</kbd> returns a string representation of an object. This method is called whenever you print an object using <kbd>println</kbd>. The default implementation returns the class's name followed by the address of the object in memory.</li>
<li><kbd>def equals(obj: Object): Boolean</kbd> returns <kbd>true</kbd> if the object is equal to another object, and <kbd>false</kbd> otherwise. This method is called whenever you compare two objects using <kbd>==</kbd>. The default implementation only compares the objects' references, and hence is equivalent to <kbd>eq</kbd>. Fortunately, most classes from the Java and Scala SDK override this method to provide a good comparison. For instance, the class <kbd>java.lang.String</kbd> overrides the <kbd>equals</kbd> method to compare the content of the strings, character by character. Therefore, when you compare two strings with <kbd>==</kbd>, the result will be <kbd>true</kbd> if the strings are the same, even if they are stored in different places in memory.</li>
<li><kbd>def hashCode: Int</kbd> is called whenever you put an object in <kbd>Set</kbd> or if you use it as a key in <kbd>Map</kbd>. The default implementation is based on the address of the object. You can override this method if you want to have a better distribution of the data in <kbd>Set</kbd> or <kbd>Map</kbd>, which can improve the performance of these collections. However, if you do so, you must make sure that <kbd>hashCode</kbd> is consistent with <kbd>equals</kbd>: if two objects are equal, their <kbd>hashCodes</kbd> must also be equal.</li>
</ul>
<p>It would be very tedious to have to override these methods for all your classes. Fortunately, Scala offers a special construct called <kbd>case class</kbd> that will automatically override these methods for us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case class</h1>
                </header>
            
            <article>
                
<p>In Scala, we define most data structures using case classes. <kbd>case class</kbd> has one to many immutable attributes and provides several built-in functions compared to a standard class.</p>
<p>Type the following into the worksheet:</p>
<pre>case class Person(name: String, age: Int)<br/>val mikaelNew = new Person("Mikael", 41)<br/>// 'new' is optional<br/>val mikael = Person("Mikael", 41)<br/>// == compares values, not references<br/>mikael == mikaelNew<br/>// == is exactly the same as .equals<br/>mikael.equals(mikaelNew)<br/> <br/>val name = mikael.name<br/> <br/>// a case class is immutable. The line below does not compile:<br/>//mikael.name = "Nicolas"<br/>// you need to create a new instance using copy<br/>val nicolas = mikael.copy(name = "Nicolas")</pre>
<p>In the preceding code, the text following <kbd>//</kbd> is a comment that explains the preceding statement.</p>
<p>When you declare a class as <kbd>case class</kbd>, the Scala compiler automatically generates a default constructor, an <kbd>equals</kbd> and <kbd>hashCode</kbd> method, a <kbd>copy</kbd> constructor, and an accessor for each attribute.</p>
<p>Here is a screenshot of the worksheet we have. You can see the results of the evaluations on the right-hand side:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e1f72981-d0a7-419b-b270-6c8509386678.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Companion object</h1>
                </header>
            
            <article>
                
<p>A class can have a companion object. It must be declared in the same file as the class, using the keyword <kbd>object</kbd> followed by the name of the class it is accompanying. A companion object is a <strong>singleton</strong> <span>– </span>there is only one instance of this object in the JVM. It has its own type and is not an instance of the accompanied class.</p>
<p>This object defines static functions or values that are closely related to the class it is accompanying. If you are familiar with Java, it replaces the keyword <kbd>static</kbd>: in Scala, all static members of a class are declared inside the companion object.</p>
<p>Some functions in the companion object have a special meaning. Functions named <kbd>apply</kbd> are constructors of the class. The name <kbd>apply</kbd> can be omitted when we call them:</p>
<pre>case class City(name: String, urbanArea: Int)<br/>object City {<br/>  val London = City("London", 1738)<br/>  val Lausanne = City("Lausanne", 41)<br/>}<br/> <br/>case class Person(firstName: String, lastName: String, city: City)<br/>object Person {<br/>  def apply(fullName: String, city: City): Person = {<br/>    val splitted = fullName.split(" ")<br/>    new Person(firstName = splitted(0), lastName = splitted(1), city = city)<br/>  }<br/>}<br/><br/>// Uses the default apply method<br/>val m1 = Person("Mikael", "Valot", City.London)<br/>// Call apply with fullName<br/>val m2 = Person("Mikael Valot", City.London)<br/>// We can omit 'apply'<br/>val n = Person.apply("Nicolas Jorand", City.Lausanne)</pre>
<p>In the preceding code, we defined a companion object for the class <kbd>City</kbd>, which defines some <strong>constants</strong>. The convention for constants is to have the first letter in uppercase.</p>
<p>The companion object for the class <kbd>Person</kbd> defines an additional <kbd>apply</kbd> function that acts as a constructor. Its implementation calls the method <kbd>split(" ")</kbd>, which splits a string separated by spaces to produce an array of type string. It allows us to construct a <kbd>Person</kbd> instance using a single string where the first name and last name are separated by a space. We then demonstrated that we can either call the default <kbd>apply</kbd> function that comes with the case class, or the one we implemented.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating my first project</h1>
                </header>
            
            <article>
                
<p>As you now know the basics of running code in the REPL and the worksheet, it is time to create your first 'Hello World' project. In this section, we are going to filter a list of people and print their name and age into the console.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the project</h1>
                </header>
            
            <article>
                
<p class="mce-root">Repeat the same recipe that you completed in the <em>Installing IntelliJ</em> section to create a new project. Here is a summary of the tasks you must complete:</p>
<ol>
<li class="mce-root">Run IntelliJ and select <span class="packt_screen">Create New Project</span></li>
<li><span>Select <span class="packt_screen">Scala</span> and</span> <span class="packt_screen">sbt</span></li>
<li><span>Input the name of the project, such as</span> <kbd>Examples</kbd></li>
<li><span>If the selected directory doesn't</span> exist<span>, IntelliJ will ask you if you want to create it – select <span class="packt_screen">OK</span></span></li>
</ol>
<p class="mce-root">As soon as you accept that you are going to create the directory, IntelliJ is going to download all the necessary dependencies and build the project structure. Be patient, as this could take a while, especially if you do not have a good internet connection.</p>
<p class="mce-root">Once everything is downloaded, you should have your IDE in the following state:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9d4c33c6-bb33-49a3-a3bf-d3b602c8d889.png"/></p>
<p class="mce-root">Notice the folder structure. The source code is under <kbd>src/main/scala</kbd> and the test code is under <kbd>src/test/scala</kbd>. If you have used Maven before, this structure should sound familiar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Main object</h1>
                </header>
            
            <article>
                
<p class="mce-root">Here we are! Let's create our first application. First, create the entry point for the program. If you are coming from Java, it would be equivalent to defining the <kbd>public static void main(String[] args)</kbd>.</p>
<p class="mce-root">Right-click on the <kbd>src/main/scala</kbd> folder and select <span class="packt_screen">New</span> | <span class="packt_screen">Scala Class</span>. Give <kbd>Main</kbd> as the class name and <kbd>Object</kbd> as the <span class="packt_screen">Kind</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4445c695-e866-4165-a4e7-d2fe6d25fb2e.png" style="width:25.83em;height:9.75em;"/></p>
<p class="mce-root">We have created our first object. This object is a singleton. There can be only one instance of it in the JVM. The equivalent in Java would be a static class with static methods.</p>
<p><span>We would like to use it as the main entry point of our program. Scala provides a convenient class named <kbd>App</kbd> that needs to be extended. Let's extend our <kbd>Main</kbd> object with that class:<br/></span></p>
<pre><span>object Main extends App {<br/><br/>}</span></pre>
<p class="mce-root">The <kbd>App</kbd> superclass defines a static <kbd>main</kbd> method that will execute all the code defined inside your <kbd>Main</kbd> object. That's all <span>– </span>we created our first version, which does nothing!</p>
<p class="mce-root">We can now run the program in IntelliJ. Click on the small green triangle in the gutter of the object definition, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/061b5895-ab23-4769-a0a9-277cc6d46c22.png" style="width:24.00em;height:6.17em;"/></p>
<p class="mce-root">The program gets compiled and executed, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e1c01182-986e-4739-ad94-9c6b0e209fe5.png" style="width:56.50em;height:11.67em;"/></p>
<p class="mce-root">It is not spectacular, but let's improve it. To get the right habits, we are going to use the <strong>TDD</strong> technique to proceed further.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the first unit test</h1>
                </header>
            
            <article>
                
<p>TDD is a very powerful technique to write efficient, modular, and safe programs. It is very simple, and there are only three rules to play this game:</p>
<ol>
<li>You are not allowed to write any production code unless it is to make a failing unit test pass.</li>
<li>You are not allowed to write any more of a unit test than is sufficient to fail, and compilation failures are failures.</li>
<li>You are not allowed to write any more production code than is sufficient to pass the one failing unit test.</li>
</ol>
<div class="packt_infobox">See the full article from Uncle Bob here: <a href="http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd">http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd</a>.</div>
<p>There are multiple testing frameworks in Scala, but we chose ScalaTest (<a href="http://www.scalatest.org/">http://www.scalatest.org/</a>) for its simplicity.</p>
<p class="mce-root">In order to add the ScalaTest library in the project, follow these steps:</p>
<ol>
<li class="mce-root">Edit the <kbd>build.sbt</kbd> file.</li>
<li class="mce-root">Add a new repository resolver to search for Scala libraries.</li>
<li class="mce-root">Add the ScalaTest library:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">name := "Examples"<br/>version := "0.1"<br/>scalaVersion := "2.12.4"<br/>resolvers += "Artima Maven Repository" at "http://repo.artima.com/releases"<br/>libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.4" % "test"</pre>
<div class="mce-root packt_infobox">Notice the information bar on the top of the screen. It tells you that your file has changed and asks for multiple choices. As this is a small project, you can select <strong>enable autoimport</strong>.</div>
<ol start="4">
<li>Create the test class by right-clicking on the <kbd>test/scala</kbd> folder and clicking on create a new class. Name it <kbd>MainSpec</kbd>.</li>
</ol>
<p class="mce-root" style="padding-left: 60px">ScalaTest offers multiple ways to define your test <span>– t</span>he full list can be found on the official website (<a href="http://www.scalatest.org/at_a_glance/WordSpec">http://www.scalatest.org/at_a_glance/WordSpec</a>). We are going to use the <kbd>WordSpec</kbd> style since it is quite prescriptive, offers a hierarchical structure, and is commonly used on large Scala projects.</p>
<p class="mce-root" style="padding-left: 60px">Your <kbd>MainSpec</kbd> should extend the <kbd>WordSpec</kbd> class and the <kbd>Matchers</kbd> class, like so:</p>
<pre class="mce-root" style="padding-left: 60px">class MainSpec extends WordSpec with Matchers {<br/><br/>}</pre>
<div class="packt_infobox"><span>The class <kbd>Matchers</kbd> is providing the word <kbd>should</kbd> as a keyword to perform the comparison on a test.</span></div>
<p class="mce-root"><kbd>WordSpec</kbd> and <kbd>Matchers</kbd> are underlined in red, which means that the class is not resolved. To make it resolved, go with the cursor on the class and press <em>Alt</em> + <em>Enter</em> of your keyboard. If you are positioned on the <kbd>WordSpec</kbd> word, a popup should appear. This is normal, as there are several classes named <kbd>WordSpec</kbd> in different packages:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1d0292f5-2ed4-4cc9-8eb7-12a507cafe24.png" style="width:21.92em;height:5.33em;"/></p>
<p class="mce-root">Select the first option and IntelliJ will automatically add the import on the top of your code. On the <kbd>Matchers</kbd> class, as soon as you type <em>Alt</em> + <em>Enter</em>, the import will be added directly.</p>
<p class="mce-root">The final code should be as follows:</p>
<pre class="mce-root">import org.scalatest.{WordSpec, Matchers}<br/><br/>class MainSpec extends WordSpec with Matchers {<br/><br/>}</pre>
<p class="mce-root">Our class skeleton is now ready for our first test. We would like to create the <kbd>Person</kbd> class and test its constructor.</p>
<p class="mce-root">Let's explain what we would like to test using simple sentences. Complete the test class with the following code:</p>
<pre class="mce-root">class MainSpec extends WordSpec with Matchers {<br/>  "A Person" should {<br/><span>    "be instantiated with a age and name" </span>in {<br/>      <span>val </span>john = <span>Person</span>(firstName = <span>"John"</span><span>, </span>lastName =  <span>"Smith"</span><span>, </span><span>42</span>)<br/>      john.firstName should <span>be</span>(<span>"John"</span>)<br/>      john.lastName should <span>be</span>(<span>"Smith"</span>)<br/>      john.age should <span>be</span>(<span>42</span>)<br/>    }<br/>  }<br/>}</pre>
<p class="mce-root">IntelliJ is complaining that it cannot resolve the symbols <kbd>Person</kbd>, <kbd>name</kbd>, <kbd>surname</kbd>, and <kbd>age</kbd>. This is expected since the <kbd>Person</kbd> class does not exist. Let's create it in the folder <kbd>src/main/scala</kbd>. Right-click on the folder and create a new class named <kbd>Person</kbd>.</p>
<p class="mce-root">Transform it in the case of the class by adding the <kbd>case</kbd> keyword and defining the constructor with the <kbd>name</kbd>, <kbd>surname</kbd>, and <kbd>age</kbd>:</p>
<pre><span>case class </span>Person(firstName: <span>String</span><span>, </span>lastName: <span>String</span><span>, </span>age: <span>Int</span>)</pre>
<p class="mce-root">If you go back to the <kbd>MainSpec.scala</kbd> file, you'll notice that the class is now compiled without any error and warning. The green tick (<img src="assets/9f8ce7bf-9938-4c7d-9407-5956acda33e4.png" style="width:1.08em;height:1.00em;"/>) on the top-right of the code window confirms this.</p>
<p class="mce-root">Run the test by right-clicking on the <kbd>MainSpec.scala</kbd> file and selecting <kbd>Run 'MainSpec'</kbd>, or use the keyboard shortcut <em>Ctrl</em> + <em>Shift</em> + <em>F10</em> or <em>Ctrl + Shift + R</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23c5dc20-e039-4e05-9e54-47620e355584.png" style="width:24.67em;height:9.25em;"/></p>
<p class="mce-root">The test contained in <kbd>MainSpec</kbd> runs and the results appear in the <span class="packt_screen">Run</span> window:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/40f72e70-ebe3-4992-88c3-66a60fc9d9c0.png" style="width:38.00em;height:21.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing another feature</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now, we would like to have a nice representation of the person by stating his/her name and age. The test should look like the following:</p>
<pre><span>"Get a human readable representation of the person" </span>in {<br/>  <span>val </span>paul = <span>Person</span>(firstName = <span>"Paul"</span><span>, </span>lastName = <span>"Smith"</span><span>, </span>age = <span>24</span>)<br/>  paul.description should <span>be</span>(<span>"Paul Smith is 24 years old"</span>)<br/>}</pre>
<p class="mce-root">Run the test again. We will get a compilation error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/083f47c0-b6db-4aa9-bbb2-69f5aa4eb291.png" style="width:46.50em;height:13.67em;"/></p>
<p class="mce-root">This is expected as the function doesn't exist on the <kbd>Person</kbd> class. To implement it, add the expected implementation by setting the cursor on the <kbd>description()</kbd> error in the <kbd>MainSpec.scala</kbd> class, hitting <em>Alt</em> + <em>Enter</em>, and selecting the create method description.<br/>
IntelliJ generates the method for you and sets the implementation to <kbd>???</kbd>. Replace <kbd>???</kbd> with the expected code:</p>
<pre><span>def </span><span>description </span>= <span>s"</span><span>$</span>firstName <span>$</span>lastName<span> is </span><span>$</span>age <span>$</span>{<span>if </span>(age &lt;= <span>1</span>) <span>"year"                    </span><span>else </span><span>"years"</span>}<span> old"</span></pre>
<p class="mce-root">By doing so, we defined a method that does not take any parameter and return a string representing <kbd>Person</kbd>. In order to simplify the code, we are using a <strong>string interpolation</strong> to build the string. To use string interpolation, you just have to prepend an <kbd>s</kbd> before the first quote. Inside the quote, you can use the wildcard <kbd>$</kbd> so that we can use an external variable and use the bracket after the dollar sign to enter more code than just a variable name.</p>
<p class="mce-root">Execute the test and the result should be green:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1f693679-234a-4b66-be9f-6a8d605365ad.png" style="width:45.50em;height:21.58em;"/></p>
<p class="mce-root">The next step is to write a utility function that, given a list of people, returns only the adults.</p>
<p class="mce-root">For the tests, two cases are defined:</p>
<pre><span>"The Person companion object" </span>should {<br/>  <span>val </span>(akira<span>, </span>peter<span>, </span>nick) = (<br/>    <span>Person</span>(firstName = <span>"Akira"</span><span>, </span>lastName = <span>"Sakura"</span><span>, </span>age = <span>12</span>)<span>,<br/></span><span>    </span><span>Person</span>(firstName = <span>"Peter"</span><span>, </span>lastName = <span>"Müller"</span><span>, </span>age = <span>34</span>)<span>,<br/></span><span>    </span><span>Person</span>(firstName = <span>"Nick"</span><span>, </span>lastName = <span>"Tagart"</span><span>, </span>age = <span>52</span>)<br/>  )<br/>  <span>"return a list of adult person" </span>in {<br/>    <span>val </span>ref = <span>List</span>(akira<span>, </span>peter<span>, </span>nick)<br/>    Person.<span>filterAdult</span>(ref) should <span>be</span>(<span>List</span>(peter<span>, </span>nick))<br/>  }<br/>  <span>"return an empty list if no adult in the list" </span>in {<br/>    <span>val </span>ref = <span>List</span>(akira)<br/>    Person.<span>filterAdult</span>(ref) should <span>be</span>(<span>List</span>.<span>empty</span>[Person])<br/>  }<br/>}</pre>
<p class="mce-root">Here, we used a tuple to define three variables. This is a convenient way to define multiple variables. The scope of the variables is bounded by the enclosing curly brackets.<br/>
Use IntelliJ to create the <kbd>filterAdult</kbd> function by using the <em>Alt</em>+ <em>Enter</em> shortcut. The IDE understands that the function should be in the <kbd>Person</kbd> companion object and generates it for you.</p>
<div class="packt_tip">If you didn't use the named parameters and would like to use them, IntelliJ can help you: hit <em>Alt</em> + <em>Enter</em> when the cursor is after the parenthesis and select "used named arguments ...".</div>
<p class="mce-root">We implement this method using the <kbd>for</kbd> <strong>comprehension</strong> Scala feature:</p>
<pre class="mce-root">object Person {<br/>  def filterAdult(persons: List[Person]) : List[Person] = {<br/>    for {<br/>      person &lt;- persons<br/>      if (person.age &gt;= 18)<br/>    } yield (person)<br/>  }<br/>}</pre>
<p class="mce-root">It is a good practice to define the return type of the method, especially when this method is exposed as a public API.</p>
<p class="mce-root">The <kbd>for</kbd> comprehension has been used only for demonstration purposes. We can simplify it using the <kbd>filter</kbd> method on <kbd>List</kbd>. <kbd>filter</kbd> is part of the Scala Collections API and is available for many kinds of collections:</p>
<pre class="mce-root">def filterAdult(persons: List[Person]) : List[Person] = {<br/>  persons.filter(_.age &gt;= 18)<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Main method</h1>
                </header>
            
            <article>
                
<p>Now that all our tests are green, we can implement the <kbd>main</kbd> method. The implementation becomes trivial as all the code is already in the test:</p>
<pre><span>object </span>Main <span>extends </span>App {<br/>  <span>val </span><span>persons </span>= <span>List</span>(<br/>    <span>Person</span>(firstName = <span>"Akira"</span><span>, </span>lastName = <span>"Sakura"</span><span>, </span>age = <span>12</span>)<span>,<br/></span><span>    </span><span>Person</span>(firstName = <span>"Peter"</span><span>, </span>lastName = <span>"Müller"</span><span>, </span>age = <span>34</span>)<span>,<br/></span><span>    </span><span>Person</span>(firstName = <span>"Nick"</span><span>, </span>lastName = <span>"Tagart"</span><span>, </span>age = <span>52</span>))<br/><br/>  <span>val </span><span>adults </span>= Person.<span>filterAdult</span>(<span>persons</span>)<br/>  <span>val </span><span>descriptions </span>= <span>adults</span>.map(p =&gt; p.description).mkString(<span>"</span><span>\n\t</span><span>"</span>)<br/>  <span>println</span>(<span>s"The adults are </span><span>\n\t</span><span>$</span><span>descriptions</span><span>"</span>)<br/>}</pre>
<p>The first thing is to define a list of <kbd>Person</kbd>, so that <kbd>Person.filterAdult()</kbd> is used to remove all the persons, not the adults. The <kbd>adults</kbd> variable is a list of <kbd>Person</kbd>, but I would like to transform this list of <kbd>Person</kbd> into a list of the description of the <kbd>Person</kbd>. To perform this operation, the <kbd>map</kbd> function of the collection is used. The <kbd>map</kbd> function transforms each element of the list by applying the function in the parameter.</p>
<p>The notation inside the <kbd>map()</kbd> function defines an anonymous function that takes <kbd>p</kbd> as the parameter. The body of the function is <kbd>p.description</kbd>. This notation is commonly used whenever a function takes another function as an argument.</p>
<p>Once we have a list of descriptions, we create a string with the <kbd>mkString()</kbd> function. It concatenates all the elements of the list using the special character <kbd>\n\t</kbd>, which are respectively the carriage return and the tab character.</p>
<p>Finally, we perform the side effect, which is the print on the console. To print in the console, the <kbd>println</kbd> alias is used. It is a syntactic sugar for <kbd>System.out.println</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have finished the first chapter, and you should now have the basics to start a project on your own. We covered the installation of an IDE to code in Scala with the basic usage of the dedicated build tool named SBT. Three ways to explore Scala have been demonstrated, including the REPL to test simple Scala features, the IntelliJ worksheet to play with a small environment, and lastly a real project.</p>
<p>To code our first project, we used ScalaTest and the TDD methodology so that we had good code quality from the beginning. </p>
<p>In the next chapter, we will write a complete program. It is a financial application that allows its users to estimate when they can retire. We will keep using the TDD technique and will further explore the Scala language, its development kit, and their best practices. </p>


            </article>

            
        </section>
    </body></html>