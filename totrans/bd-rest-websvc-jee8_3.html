<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Content Marshalling with JSON-B and JSON-P</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this<span class="calibre10"> chapter</span><span class="calibre10">, </span>we will focus on the data structures and payloads of web services. You will learn how to properly use content types and content negotiation for your web services, how to use the new JSON-B APIs for easy data binding, how JSON-P API can be used for very flexible JSON processing, and how it can be used to implement hypermedia-driven REST APIs.</p>
<p class="calibre6"><span class="calibre10">The following topics will be covered in this chapter:</span></p>
<ul class="calibre14">
<li class="calibre15">Introduction to content types and content negotiation</li>
<li class="calibre15">Easy data binding using JSON-B</li>
<li class="calibre15">Flexible JSON processing with JSON-P</li>
<li class="calibre15">Implementing hypermedia-driven REST APIs</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction to content types and content negotiation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at using the <kbd class="calibre17">@Produces</kbd> and <kbd class="calibre17">@Consumes</kbd> annotations to specify the content types. We'll also learn about API versioning using custom content types, smart content negotiation using a quality from server factor, and how you can serve and upload binary content.</p>
<p class="calibre6"/>
<p class="calibre6">Let's switch to code and open our IDE. Let's take a look at the small REST service that we have prepared. As you already know, you can specify the <kbd class="calibre17">@Produces</kbd> or <kbd class="calibre17">@Consumes</kbd> annotations to specify what your REST service will consume as a content type and what content type your REST service will produce. What we do here is we specify <kbd class="calibre17">application/json</kbd>. This is what we usually do. We implement this method and return a simple <kbd class="calibre17">Map</kbd> with the status code <kbd class="calibre17">ok</kbd>. Using JAX-RS, we'll make sure that this <kbd class="calibre17">Map</kbd> is serialized to proper JSON:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Produces("application/json")<br class="calibre2"/>    public Response v1() {<br class="calibre2"/>        Map&lt;String, String&gt; version = <br class="calibre2"/>          Collections.singletonMap("version", "v1");<br class="calibre2"/>        return Response.ok(version).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">What if we want to implement a second version of this? We can do that by implementing the method called <kbd class="calibre17">v2</kbd> and returning something different:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Produces("application/json")<br class="calibre2"/>    public Response v2() {<br class="calibre2"/>        Map&lt;String, String&gt; version =    <br class="calibre2"/>          Collections.singletonMap("version", "v2");<br class="calibre2"/>        return Response.ok(version).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">Now, this here will not work correctly because we have two methods producing the same content type. What we can do is specify a custom <kbd class="calibre17"><span class="calibre4">MediaType</span></kbd>. We will specify <kbd class="calibre17">MediaType v1</kbd> and <kbd class="calibre17">MediaType v2</kbd> of type <kbd class="calibre17">"application"</kbd>, <span class="calibre10">and we will use the custom subtype. We have one subtype for version one and the JSON format (</span><kbd class="calibre17">"vnd.version.v1+json"</kbd><span class="calibre10">), and another one for version two and the JSON format (<kbd class="calibre17">"vnd.version.v2+json"</kbd>):</span></p>
<pre class="calibre22">public class VersionResource {<br class="calibre2"/><br class="calibre2"/>    /**<br class="calibre2"/>     * MediaType implementation for the version resource in v1.<br class="calibre2"/>     */<br class="calibre2"/>    <strong class="calibre3">public static final MediaType V1 = new MediaType(</strong><br class="calibre2"/><strong class="calibre3">      "application", "vnd.version.v1+json");</strong><br class="calibre2"/><br class="calibre2"/></pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<pre class="calibre22">    /**<br class="calibre2"/>     * MediaType implementation for the version resource in v2.<br class="calibre2"/>     */<br class="calibre2"/>    <strong class="calibre3">public static final MediaType V2 = new MediaType(</strong><br class="calibre2"/><strong class="calibre3">      "application", "vnd.version.v2+json");</strong></pre>
<p class="calibre6">We can use those custom content types with <kbd class="calibre17">v1</kbd> and <kbd class="calibre17">v2</kbd>. Since this is done, we have an API version for <kbd class="calibre17">v1</kbd> and <kbd class="calibre17">v2</kbd> using content types. This is the way it should be if we use an API version. <kbd class="calibre17">v1</kbd> supports application JSON and also supports the content type <kbd class="calibre17">v1</kbd> in the JSON format:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Produces({"application/json, <br class="calibre2"/>      <strong class="calibre3">"application/vnd.version.v1+json"</strong>})<br class="calibre2"/>    public Response v1() {<br class="calibre2"/>        Map&lt;String, String&gt; version = <br class="calibre2"/>          Collections.singletonMap("version", "v1");<br class="calibre2"/>        return Response.ok(version).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">How does the client specify or know which content type it accepts? Well, basically, they can specify the accept header for this specific content type. If they don't, we specify a factor which is called <strong class="calibre8">quality from server</strong>, that is, <kbd class="calibre17">qs</kbd>, <kbd class="calibre17">qs=0.75</kbd>, and <kbd class="calibre17">qs=1</kbd>. If the client does not specify the content type, <kbd class="calibre17">"application/vnd.version.v1+json"</kbd><strong class="calibre8"> </strong>will always win because it has the higher factor:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Produces({"application/json; <strong class="calibre3">qs=0.75</strong>", <br class="calibre2"/>      "application/vnd.version.v1+json; <strong class="calibre3">qs=1.0</strong>"})</pre>
<p class="calibre6">Let's look at using binary content. We will prepare two methods: serving a JPEG image and a GIF image. <span class="calibre10">All we have to do is just open a file and send the file back</span>:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Path("/me.jpg")<br class="calibre2"/>    @Produces("image/jpeg")<br class="calibre2"/>    public Response jpg() {<br class="calibre2"/>        String path = context.getRealPath("/me.jpg");<br class="calibre2"/>        return Response.ok(new File(path))<br class="calibre2"/>                .header("Content-Disposition", "attachment; <br class="calibre2"/>                  filename=me.jpg")<br class="calibre2"/>                .build();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/></pre>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Path("/magic.gif")<br class="calibre2"/>    @Produces("image/gif")<br class="calibre2"/>    public Response gif() {<br class="calibre2"/>        String path = context.getRealPath("/magic.gif");<br class="calibre2"/>        return Response.ok(new File(path)).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">What we can also do is implement and upload a mechanism by using the HTTP <kbd class="calibre17">POST</kbd> method. We will consume <kbd class="calibre17">MULTIPART_FORM_DATA</kbd>. While you are referencing the form with a parameter called <kbd class="calibre17">"file"</kbd>, which is an input stream, to get the filename, you can also reference <kbd class="calibre17">@FormDataParam</kbd> and use <kbd class="calibre17">FormDataContentDisposition</kbd>:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    @Consumes(MediaType.MULTIPART_FORM_DATA)<br class="calibre2"/>    public Response upload(<br class="calibre2"/>      @FormDataParam("file") InputStream inputStream,<br class="calibre2"/>      @FormDataParam("file") FormDataContentDisposition fileInfo) {<br class="calibre2"/>        <br class="calibre2"/>        String fileName = fileInfo.getFileName();<br class="calibre2"/>        saveFile(inputStream, fileName);<br class="calibre2"/><br class="calibre2"/>        URI uri = uriInfo.getBaseUriBuilder()<br class="calibre2"/>          .path(DocumentsResource.class)<br class="calibre2"/>          .path(fileName).build();<br class="calibre2"/>        return Response.created(uri).build();<br class="calibre2"/>    }</pre>
<p class="calibre6">Now, let's open our REST API. We do not specify anything; we just send the version and receive <kbd class="calibre17">"v1"</kbd>, which is the default setting:</p>
<div class="cdpaligncenter1"><img src="Images/943b3a68-6d03-4209-9bc7-442939d63f38.png" width="507" height="205" class="calibre45"/></div>
<p class="calibre6">We also get <kbd class="calibre17">"v1"</kbd> because I've explicitly set the <span class="calibre10">Accept</span> header here:</p>
<div class="cdpaligncenter1"><img src="Images/43954a70-c83e-43a0-9acc-625bd44b994a.png" width="540" height="424" class="calibre46"/></div>
<p class="calibre6">To obtain <kbd class="calibre17">"v2"</kbd>, we must specify the <span class="calibre10">Accept</span> header with the <kbd class="calibre17">application/vnd.version.v2+json</kbd> content type:</p>
<div class="cdpaligncenter1"><img src="Images/7a81c7b2-780c-49b8-8238-a68de3bdc4bb.png" width="555" height="454" class="calibre47"/></div>
<p class="calibre6">Finally, we can see that the serving of GIF images and JPEGs is also working. We can request a GIF image and, as you can see here, we have the magic of content types:</p>
<div class="cdpaligncenter1"><img src="Images/a110088b-3ced-48aa-b651-0cf592b195d2.png" width="648" height="334" class="calibre48"/></div>
<p class="calibre6">In the next section, we will talk about easy data binding using JSON-B.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Easy data binding using JSON-B</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at using JSON-B for marshalling and unmarshalling of your JSON and POJO data structures, how you can use JSON-B annotations on POJOs such as <kbd class="calibre17">@JsonbProperty</kbd>, <kbd class="calibre17">@JsonbNumberFormat</kbd>, <kbd class="calibre17">@JsonbDateFormat</kbd>, <kbd class="calibre17">@JsonbTransient</kbd>, and <kbd class="calibre17">@JsonbPropertyOrder</kbd>, and finally how you can explicitly create <kbd class="calibre17">JsonbConfig</kbd> and <kbd class="calibre17">Jsonb</kbd> instances using <kbd class="calibre17">JsonbBuilder</kbd>.</p>
<p class="calibre6">Let's get started and switch to code. We will create a <kbd class="calibre17">JsonResource</kbd> class. This is our basic REST resource and we want to implement our basic methods that return JSON structures from a POJO and that unmarshall our POJO from JSON structures.</p>
<p class="calibre6">The first bit is easy; first up, we're implementing a basic <kbd class="calibre17">@GET</kbd> method. We call it <kbd class="calibre17">marshall</kbd> and it returns a <kbd class="calibre17">JsonbPojo</kbd>. <kbd class="calibre17"><span class="calibre4">JsonbPojo</span></kbd> is a plane POJO object: it's a plane class. We'll use the <kbd class="calibre17">@Produces</kbd> application for JSON and JAX-RS, and Java EE 8 will make sure that this POJO is marshalled properly to JSON using JSON-B:</p>
<pre class="calibre22">@Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>public class JsonbResource {<br class="calibre2"/>    @GET<br class="calibre2"/>    public JsonbPojo marshall() {<br class="calibre2"/>        return jsonbPojo;<br class="calibre2"/>    }</pre>
<p class="calibre6">The same is true for unmarshalling. Let's assume that we want to <kbd class="calibre17">POST</kbd> a <kbd class="calibre17">JsonbPojo</kbd> to this REST resource. At the class level, we make sure that we use the <kbd class="calibre17">@Consumes</kbd> application JSON. If you <kbd class="calibre17">POST</kbd> a proper JSON to this REST resource, JAX-RS and Java EE 8 will make sure that this JSON structure is then deserialized and unmarshalled into a <kbd class="calibre17">JsonbPojo</kbd>:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    public void unmarshall(JsonbPojo pojo) {<br class="calibre2"/>        LOGGER.log(Level.INFO, "Default Unmarshalled {0}", pojo);<br class="calibre2"/>        this.jsonbPojo = pojo;<br class="calibre2"/>    }</pre>
<p class="calibre6">If you don't like the default serialization, what you can always do is take care of the marshalling yourself using the <kbd class="calibre17">jsonb</kbd> instance. It offers a method called <kbd class="calibre17">toJson</kbd>, which you can pass to any object and it will return the string as an output, and vice versa. You can say that it expects the JSON string as the first parameter and the class of the final POJO as the second parameter. If everything goes the way you want it to, you'll receive the unmarshalled object:</p>
<pre class="calibre22">    @GET<br class="calibre2"/>    @Path("/custom")<br class="calibre2"/>    public String marshallCustom() {<br class="calibre2"/>        return jsonb.toJson(customJsonbPojo);<br class="calibre2"/>    }</pre>
<p class="calibre6">Let's have a closer look at using this <kbd class="calibre17">jsonb</kbd>. We will prepare simple unit tests here. What we can always do is create and use JSON-B standalone without any JAX-RS resources. The one thing you should do is use <kbd class="calibre17">JsonbConfig</kbd> and make sure that we import everything in there. We will create a new <kbd class="calibre17"><span class="calibre4">JsonbConfig</span></kbd> and on this <kbd class="calibre17"><span class="calibre4">JsonbConfig</span></kbd>, we can set several parameters. For example, you can specify a property ordering strategy where we use <kbd class="calibre17">LEXICOGRAPHICAL</kbd>. You can also specify <kbd class="calibre17">REVERSE</kbd> and <kbd class="calibre17">ANY</kbd> in any case as well. We can specify if we want to marshall null values, use a property naming strategy, in this case, <kbd class="calibre17">LOWERCASE_CASE_WITH_DASHES</kbd>, we can specify whether the produced JSON is formatted or not, you can specify a default date format, you can specify how to handle binary data, and you can specify the overall locale. Using <kbd class="calibre17">jsonbConfig</kbd> is pretty straightforward; we use the JSON-B builder (<kbd class="calibre17">JsonbBuilder</kbd>) and call the <kbd class="calibre17">create</kbd> method on it and pass <kbd class="calibre17">create</kbd> (<kbd class="calibre17">jsonbConfig</kbd>):</p>
<pre class="calibre22">    @Before<br class="calibre2"/>    public void setUp() throws Exception {<br class="calibre2"/>        JsonbConfig jsonbConfig = new JsonbConfig()<br class="calibre2"/>                .withPropertyOrderStrategy(<br class="calibre2"/>                  PropertyOrderStrategy.LEXICOGRAPHICAL)<br class="calibre2"/>                .withNullValues(true)<br class="calibre2"/>                .withPropertyNamingStrategy(PropertyNamingStrategy<br class="calibre2"/>                   .LOWER_CASE_WITH_DASHES)<br class="calibre2"/>                .withFormatting(false)<br class="calibre2"/>                .withDateFormat("dd.MM.yyyy", Locale.GERMANY)<br class="calibre2"/>                .withBinaryDataStrategy(BinaryDataStrategy.BASE_64)<br class="calibre2"/>                .withLocale(Locale.GERMANY);<br class="calibre2"/><br class="calibre2"/>        jsonb = JsonbBuilder.create(jsonbConfig);<br class="calibre2"/>    }</pre>
<p class="calibre6">Once we obtain this JSON-B instance, in the test methods, we use <kbd class="calibre17">jsonb.toJson(pojo)</kbd> and we get the string JSON-B from JSON. Pass it the string data and a class you want and the <kbd class="calibre17">pojo</kbd> will be returned:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void testToJsonWithPlainPojo() {<br class="calibre2"/>        PlainPojo pojo = PlainPojo.create();<br class="calibre2"/>        String json = jsonb.toJson(pojo);<br class="calibre2"/>        assertThat(json).isEqualTo(PLAIN_POJO_JSON);<br class="calibre2"/>    }</pre>
<p class="calibre6">This works for plain POJOs and POJOs that have not been specifically annotated. If we want to overwrite these default configurations, we can annotate our POJO like we did previously using <kbd class="calibre17">@JsonbPropertyOrder</kbd>. For example, to specify the very explicit property order, we can say <kbd class="calibre17">@JsonbProperty</kbd> to give it a different name, <kbd class="calibre17">@JNumberFormat</kbd> to specify the number format to use, <kbd class="calibre17">@JsonbDateFormat</kbd> to specify a different date, or <kbd class="calibre17">@JsonbTransient</kbd>, which tells JSON-B to ignore this property during marshalling and unmarshalling:</p>
<pre class="calibre22">    @JsonbPropertyOrder(value = {"message", <br class="calibre2"/>      "answerToEverything", "today"})<br class="calibre2"/>    public static class AnnotatedPojo {<br class="calibre2"/>        @JsonbProperty(value = "greeting", nillable = true)<br class="calibre2"/>        public String message;<br class="calibre2"/><br class="calibre2"/>        @JsonbNumberFormat("#,##0.00")<br class="calibre2"/>        public Integer answerToEverything;<br class="calibre2"/><br class="calibre2"/>        @JsonbDateFormat("MM/dd/yyyy")<br class="calibre2"/>        public LocalDate today;<br class="calibre2"/><br class="calibre2"/>        @JsonbTransient<br class="calibre2"/>        public BigDecimal invisible = BigDecimal.TEN;</pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">Let's take this test and run our thing. Our test should hopefully be green, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/b59eeaa3-b404-4bec-bc9d-ea1a35bc12d3.png" class="calibre49"/></p>
<p class="calibre6">In this section, we saw that using JSON-B is really simple and straightforward. In the next section, we'll talk about flexible JSON processing with JSON-P.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Flexible JSON processing with JSON-P</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at using JSON-P builders to construct JSON arrays and objects. We'll see how you can use JSON-P in REST resources for marshalling and unmarshalling data, how to use JSON Pointers to access JSON structures, and have a closer look at JSON Patch and JSON Diff to modify JSON structures. We will also be using the <kbd class="calibre17">@PATCH</kbd> annotation and the <kbd class="calibre17">application/json-patch+json</kbd> content type to apply patches in our REST resources, so there's lots of content ahead.</p>
<p class="calibre6">Let's get started. As usual, we prepare a small REST resource as a template to start. The first thing we do is create arrays for JSON and JSON objects using the associated builders, so let's do that:</p>
<pre class="calibre22">    public void testJsonBuilder() {<br class="calibre2"/>        JsonArray values = Json.createArrayBuilder()<br class="calibre2"/>                .add(Json.createObjectBuilder()<br class="calibre2"/>                        .add("aString", "Hello Json-P 1")<br class="calibre2"/>                        .add("aInteger", 42)<br class="calibre2"/>                        .add("aBoolean", false)<br class="calibre2"/>                        .add("aNullValue", JsonValue.NULL)<br class="calibre2"/>                        .build())</pre>
<p class="calibre6">Here, we're using the <kbd class="calibre17">createArrayBuilder</kbd> to create an array builder, and we're using the <kbd class="calibre17">add</kbd> method to add JSON objects. Here, you can use <kbd class="calibre17">Json.createObjectBuilder</kbd> to obtain an object builder. On this object builder, we then call different <kbd class="calibre17">add</kbd> methods to add a string, an integer, a Boolean, or maybe a null value using the special <kbd class="calibre17">JsonValue</kbd>. That's all there is to it. Using these two builders, you can create complex JSON structures quite easily.</p>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">What do we do with this? The first thing we do is we return <kbd class="calibre17">jsonArray</kbd>; this is really straightforward. You can explicitly and directly return this <kbd class="calibre17">jsonArray</kbd> for marshalling. To do this, w<span class="calibre10">e will produce an <kbd class="calibre17">APPLICATION_JSON</kbd> as our content type and JAX-RS will make sure that our <kbd class="calibre17">jsonArray</kbd> is serialized and marshalled to the corresponding JSON structure</span>:</p>
<pre class="calibre22">@Produces(MediaType.APPLICATION_JSON) <br class="calibre2"/>   @GET<br class="calibre2"/>    public JsonArray marshall() {<br class="calibre2"/>        return jsonArray;<br class="calibre2"/>    }</pre>
<p class="calibre6">The same is true if we want to unmarshall the data using JSON-P. We will consume the <kbd class="calibre17">APPLICATION_JSON</kbd>, get the <kbd class="calibre17">InputStream</kbd> which is basically <kbd class="calibre17">jsonBody</kbd>, and we're going to use <kbd class="calibre17">JsonReader</kbd> Here, we're going to use <kbd class="calibre17">Json.CreateReader(jsonBody)</kbd> from the <kbd class="calibre17">InputStream</kbd>, obtain a <kbd class="calibre17"><span class="calibre4">JsonReader</span></kbd>, and on the <kbd class="calibre17">reader</kbd>, we can read the array:</p>
<pre class="calibre22">    @POST<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public void unmarshall(InputStream jsonBody) {<br class="calibre2"/>        JsonReader reader = Json.createReader(jsonBody);<br class="calibre2"/>        this.jsonArray = reader.readArray();<br class="calibre2"/><br class="calibre2"/>        LOGGER.log(Level.INFO, "Unmarshalled JSON-P {0}.", jsonArray);<br class="calibre2"/>    }</pre>
<p class="calibre6">Let's see what else there is in JSON-P. Well, first up there are JSON Pointers. Let's look into JSON Pointers. Let's assume we have a simple JSON structure. In this test, we'll create a reader using a string, and we'll obtain a <kbd class="calibre17">JsonObject</kbd> from the reader and a <kbd class="calibre17">JsonArray</kbd> from this object:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void testJsonPointer() {<br class="calibre2"/>        JsonReader jsonReader = Json.createReader(new StringReader("<br class="calibre2"/>          {\"aString\":\"Hello Json-P\",\"arrayOfInt\":[1,2,3]}"));<br class="calibre2"/>        JsonObject jsonObject = jsonReader.readObject();<br class="calibre2"/>        JsonArray jsonArray = jsonObject.getJsonArray("arrayOfInt");</pre>
<p class="calibre6">What if we want to access an array value by index? For this, we use a JSON Pointer. We'll use <kbd class="calibre17">Json.createPointer</kbd>, and using this annotation here basically specifies the path and the index of the value we want to reference. We'll also create a <kbd class="calibre17"><span class="calibre4">jsonPointer</span></kbd>, and on the <kbd class="calibre17"><span class="calibre4">jsonPointer</span></kbd> we can then set <kbd class="calibre17">getValue</kbd> and pass it the <kbd class="calibre17">JsonObject</kbd>.</p>
<p class="calibre6"/>
<p class="calibre6">Doing this, we'll get back a <kbd class="calibre17">jsonValue</kbd> and what we can do is we can check that the values of the <kbd class="calibre17">JsonNumber</kbd> and <kbd class="calibre17">jsonArray</kbd> instances are correct as well:</p>
<pre class="calibre22">        // access an array value by index<br class="calibre2"/>        JsonPointer jsonPointer = Json.createPointer("/arrayOfInt/1");<br class="calibre2"/>        JsonValue jsonValue = jsonPointer.getValue(jsonObject);<br class="calibre2"/>        assertThat(jsonValue).isInstanceOf(JsonNumber.class);<br class="calibre2"/>        assertThat(jsonValue).isEqualTo(jsonArray.get(1));</pre>
<p class="calibre6">We can also use the JSON Pointer to replace objects in the array, for example, or in the JSON structure. We use <kbd class="calibre17">jsonPointer.replace</kbd>, give it the original <kbd class="calibre17">jsonObject</kbd>, and we specify the new <kbd class="calibre17">createValue(42)</kbd> value we want to replace the pointer value with:</p>
<pre class="calibre22">        // replace the array value by index<br class="calibre2"/>        jsonObject = jsonPointer.replace(jsonObject, <br class="calibre2"/>          Json.createValue(42));<br class="calibre2"/>        jsonArray = jsonObject.getJsonArray("arrayOfInt");<br class="calibre2"/>        assertThat(jsonArray.getInt(1)).isEqualTo(42);</pre>
<p class="calibre6">We can also use the JSON Pointer to remove things from the JSON's structure. Here, we can use the JSON Pointer, say, on <kbd class="calibre17">remove(jsonObject)</kbd>, and a new JSON object will be returned. If we check the JSON array, the size is smaller than before:</p>
<pre class="calibre22">        // remove the array value by index<br class="calibre2"/>        jsonObject = jsonPointer.remove(jsonObject);<br class="calibre2"/>        jsonArray = jsonObject.getJsonArray("arrayOfInt");<br class="calibre2"/>        assertThat(jsonArray.size()).isEqualTo(2);<br class="calibre2"/>    }</pre>
<p class="calibre6">Something else regarding JSON-P is JSON Patch. We will create a JSON object first, a <kbd class="calibre17">jsonReader</kbd>, pass it a string, and read the object from the reader. We will create a <kbd class="calibre17">JsonPatch</kbd>. For this, we will use the <kbd class="calibre17">createPatchBuilder</kbd> and on the <kbd class="calibre17">patch</kbd> we want to say, please replace the element <kbd class="calibre17">"/aString"</kbd> with the <kbd class="calibre17">"Patched Json-P."</kbd> value and please remove this from <kbd class="calibre17">"/arrayOfInt/1"</kbd>. Therefore, you can use JSON Patch to specify modifying operations, such as replacing, removing, and adding values to JSON structures. On the <kbd class="calibre17">patch</kbd>, we call the <kbd class="calibre17">apply</kbd> method and we'll pass it as a parameter to the JSON structure we want to apply the patch to. This will return a new and modified JSON object. Here, we can make sure that the modification is done properly:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void testJsonPatch() {<br class="calibre2"/>        JsonReader jsonReader = Json.createReader(<br class="calibre2"/>          new StringReader("{\"aString\":<br class="calibre2"/>            \"Hello Json-P\",\"arrayOfInt\":[1,2,3]}"));<br class="calibre2"/>        JsonObject jsonObject = jsonReader.readObject();<br class="calibre2"/><br class="calibre2"/>        JsonPatch patch = Json.createPatchBuilder()<br class="calibre2"/>                .replace("/aString", "Patched Json-P.")<br class="calibre2"/>                .remove("/arrayOfInt/1")<br class="calibre2"/>                .build();<br class="calibre2"/><br class="calibre2"/>        jsonObject = patch.apply(jsonObject);<br class="calibre2"/>        assertThat(jsonObject.getString("aString"))<br class="calibre2"/>          .isEqualTo("Patched Json-P.");<br class="calibre2"/>        assertThat(jsonObject.getJsonArray("arrayOfInt")<br class="calibre2"/>          .size()).isEqualTo(2);<br class="calibre2"/>    }</pre>
<p class="calibre6">Something else that's quite nice is the JSON Diff feature. Let's assume that we have a <kbd class="calibre17">source</kbd> and a <kbd class="calibre17">target</kbd> object. As you can see, they're both kind of the same<span class="calibre10">—</span>they have one element called <kbd class="calibre17">"aString"</kbd>, but the values differ. What we then do is create a <kbd class="calibre17">diff</kbd>, say, <kbd class="calibre17">Json.createDiff(source, target)</kbd>, and what we get back is a <kbd class="calibre17">JsonPatch</kbd> describing the necessary changes it needs to apply to <kbd class="calibre17">source</kbd> so that we can get the <kbd class="calibre17">target</kbd> object. If we have a look at our JSON Diff, we can see all that is required is a <kbd class="calibre17">replace</kbd> operation. For the following path, we do the same with <kbd class="calibre17">"/aString"</kbd>, and we need to replace the <kbd class="calibre17">"value"</kbd> with <kbd class="calibre17">"xyz"</kbd>. If we apply this patch to the <kbd class="calibre17">source</kbd> object, we get the <kbd class="calibre17">target</kbd> object, and we do that by taking the <kbd class="calibre17">diff</kbd> and applying it to the <kbd class="calibre17">source</kbd>. We get back a new object and we assert that the <kbd class="calibre17">source</kbd> is equal to the <kbd class="calibre17">target</kbd>:</p>
<pre class="calibre22">    @Test<br class="calibre2"/>    public void testJsonDiff() {<br class="calibre2"/>        JsonObject source = Json.createObjectBuilder()<br class="calibre2"/>          .add("aString", "abc").build();<br class="calibre2"/>        JsonObject target = Json.createObjectBuilder()<br class="calibre2"/>          .add("aString", "xyz").build();<br class="calibre2"/><br class="calibre2"/>        JsonPatch diff = Json.createDiff(source, target);<br class="calibre2"/>        JsonObject replace = diff.toJsonArray().getJsonObject(0);<br class="calibre2"/>        assertThat(replace.getString("op")).isEqualTo("replace");<br class="calibre2"/>        assertThat(replace.getString("path")).isEqualTo("/aString");<br class="calibre2"/>        assertThat(replace.getString("value")).isEqualTo("xyz");<br class="calibre2"/><br class="calibre2"/>        source = diff.apply(source);<br class="calibre2"/>        assertThat(source).isEqualTo(target);<br class="calibre2"/>    }</pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">You can also use JSON Patch in your JAX-RS resources as well. For this, we have to use the following two annotations. First up, we use <kbd class="calibre17">@PATCH</kbd> and then specify <kbd class="calibre17">@Consumes</kbd> with a media type of <kbd class="calibre17">APPLICATION_JSON_PATCH_JSON</kbd>. The structure we send this in is a <kbd class="calibre17">JsonArray</kbd>, and from that <kbd class="calibre17"><span class="calibre4">JsonArray</span></kbd>, we create a <kbd class="calibre17">jsonPatch</kbd> that we can use to apply it to our data structures:</p>
<pre class="calibre22">    @PATCH<br class="calibre2"/>    @Consumes(MediaType.APPLICATION_JSON_PATCH_JSON)<br class="calibre2"/>    public void patch(JsonArray jsonPatchArray) {<br class="calibre2"/>        LOGGER.log(Level.INFO, "Unmarshalled JSON-P Patch {0}.", <br class="calibre2"/>          jsonPatchArray);<br class="calibre2"/><br class="calibre2"/>        JsonPatch jsonPatch = Json.createPatchBuilder(jsonPatchArray)<br class="calibre2"/>          .build();<br class="calibre2"/>        this.jsonArray = jsonPatch.apply(jsonArray);<br class="calibre2"/>        LOGGER.log(Level.INFO, "Patched {0}.", jsonArray);<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6"><span class="calibre10">That was a lot of content for covering JSON-P. </span>In the next section, we are going to implement a hypermedia-driven REST API using what we've learned so far.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing hypermedia-driven REST APIs</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at how you can traverse REST resources using hypermedia (with links and URIs). We'll see how to use JSON-P to construct hypermedia enabled JSON structures. We'll use the <kbd class="calibre17">@Context</kbd> and <kbd class="calibre17">UriInfo</kbd> objects to construct resource URIs programmatically. We will also have a look at how to set link headers with URIs on the HTTP response.</p>
<p class="calibre6">Let's get started and switch to our IDE. We will prepare a resource, and this resource will be serving books and authors; both are individual REST resources. Obviously, books are written by authors, so we should be able to navigate from books to the authors and vice versa. This is what we can use hypermedia for.</p>
<p class="calibre6">Navigate to our book resource. In here, we have the method to serve a specific book. First up, we'll obtain the book and then we can construct the URI for this book. <kbd class="calibre17">createBookResourceUri</kbd> is the URI to use to reference this book: </p>
<pre class="calibre22">        @GET<br class="calibre2"/>        @Path("/{isbn}")<br class="calibre2"/>        public Response book(@PathParam("isbn") String isbn) {<br class="calibre2"/>            Book book = books.get(isbn);<br class="calibre2"/>            URI bookUri = createBookResourceUri(isbn, uriInfo);<br class="calibre2"/>            URI authorUri = createAuthorResourceUri(book<br class="calibre2"/>              .authorId, uriInfo);<br class="calibre2"/>            return null;<br class="calibre2"/>        }</pre>
<p class="calibre6"><span class="calibre10">We also want to construct the author URI for this book. I</span>f you look in here into one of those methods, you'll see that we use the <kbd class="calibre17">uriInfo</kbd> object and that we obtain a base URI builder from it. We then use the <kbd class="calibre17">path</kbd> methods to actually build the final URI. Using these <kbd class="calibre17">path</kbd> methods, we can construct the path from the <kbd class="calibre17">@Path</kbd> annotations of our resources and resource methods:</p>
<pre class="calibre22">    static URI createAuthorResourceUri(Integer authorId, <br class="calibre2"/>      UriInfo uriInfo) {<br class="calibre2"/>        return uriInfo.getBaseUriBuilder()<br class="calibre2"/>                .path(HateosResource.class)<br class="calibre2"/>                .path(HateosResource.class, "author")<br class="calibre2"/>                .path(AuthorResource.class, "author")<br class="calibre2"/>                .build(authorId);<br class="calibre2"/>    }</pre>
<p class="calibre6">In the final result, we have a URI that references the actual resource:</p>
<pre class="calibre22">            URI authorUri = createAuthorResourceUri(book<br class="calibre2"/>              .authorId, uriInfo);</pre>
<p class="calibre6">Next up, what we do is create a JSON object from <kbd class="calibre17">book</kbd> from our <kbd class="calibre17">bookUri</kbd>, and this is where hypermedia comes into play. Let's have a look at them. We'll use JSON-P to create an object builder and add <kbd class="calibre17">"isbn"</kbd> and <kbd class="calibre17">"title"</kbd> to it. However, there's one bit missing and that bit makes the final hypermedia enabled JSON structure. We will add an additional object called <kbd class="calibre17">"_links"</kbd> which is a JSON object, and this JSON object contains two other JSON objects which are called <kbd class="calibre17">"self"</kbd> and <kbd class="calibre17">"author"</kbd>. <kbd class="calibre17">"self"</kbd> describes the URI of the REST resource itself, which in this case is the type of book. Then, we specify <kbd class="calibre17">"author"</kbd>, and we give it an <kbd class="calibre17">"href"</kbd> attribute which points to <kbd class="calibre17">authorUri</kbd>:</p>
<pre class="calibre22">        private JsonObject asJsonObject(Book book, URI bookUri, <br class="calibre2"/>          URI authorUri) {<br class="calibre2"/>            return Json.createObjectBuilder()<br class="calibre2"/>                    .add("isbn", book.isbn)<br class="calibre2"/>                    .add("title", book.title)<br class="calibre2"/>                    .add("_links", Json.createObjectBuilder()<br class="calibre2"/>                            .add("self", Json.createObjectBuilder()<br class="calibre2"/>                                    .add("href", bookUri.toString()))<br class="calibre2"/>                            .add("author", Json.createObjectBuilder()<br class="calibre2"/>                                    .add("href", <br class="calibre2"/>                                      authorUri.toString())))<br class="calibre2"/>                    .build();<br class="calibre2"/>        }</pre>
<p class="calibre6">Finally, we return the JSON object, and on the <kbd class="calibre17">response</kbd> object you can also set the link HTTP headers as well so that you have two options. You can either specify the link header on the HTTP <kbd class="calibre17">response</kbd> or embed the URIs, which adds a linked JSON structure here. We've completed the books.</p>
<p class="calibre6">We can pretty much do almost the same thing for authors; the code this is pretty much copy/paste. This kind of follows the same procedure: we get the authors and then construct the URI for the author and the books. We construct our JSON object where we're going to embed the links to <kbd class="calibre17">"self"</kbd>, which is <kbd class="calibre17">"books"</kbd> itself, and do the same for the <kbd class="calibre17">booksUri</kbd>. Finally, you return the response of this JSON object and we can also embed the <kbd class="calibre17">link</kbd> HTTP headers.</p>
<p class="calibre6">Now, let's put this API to the test. Open our Postman and issue a <kbd class="calibre17">GET</kbd> request for the list of books. In here, you will see that the book has a title and that it also contains a list of links. For <kbd class="calibre17">"self"</kbd>, this is the book itself and for <kbd class="calibre17">"author"</kbd>, we get the author of the book, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/1aee538a-1f94-468c-98d8-4560e1bb6597.png" width="829" height="480" class="calibre50"/></p>
<p class="calibre6">Let's click on the book, that is, the URI present in <kbd class="calibre17">"self"</kbd>, to get information about this book in particular. As you can see, this returns a single book structure. If you want to navigate to the author, we can use the author link. Here, we have the author of this book, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/b575a269-e5c8-4d97-ac28-539aa98574f3.png" width="820" height="455" class="calibre51"/></p>
<p class="calibre6"><span class="calibre10">If we want to obtain the list of books that this author has written, we can use the <kbd class="calibre17">"books"</kbd> link, which gets all the books from this author's ID, as shown in the preceding screenshot.</span></p>
<p class="calibre6">If you want to have a look at this book again, you can navigate from those two books. What you can also see here in the headers is that we have the two links for the author and the book itself:</p>
<p class="cdpaligncenter"><img src="Images/7adbe647-433e-4c27-b0d4-798bb2ac86f5.png" width="869" height="268" class="calibre52"/></p>
<p class="calibre6"/>
<p class="calibre6"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6"><span class="calibre10">Let's summarize what we have learned in this chapter. First up, we had a look at how we can use custom content types and content negotiation in our web services. Next up, we had a look at JSON-B and how we can use it for easy data binding of your POJOs to and from JSON. We also had a look at JSON-P for very flexible JSON processing, and how we can create JSON structures and retrace these structures using JSON-P. Then, we looked at how to use JSON Pointers, JSON Patch, and JSON Diff for more flexible JSON processing, and finally, we had a look at implementing hypermedia enabled REST APIs using JSON-P and <kbd class="calibre17">UriInfo</kbd>.</span></p>
<p class="calibre6"><span class="calibre10">In the next chapter, we will talk about building asynchronous web services.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>