<html><head></head><body>
		<div id="_idContainer220">
			<h1 id="_idParaDest-151"><em class="italic"><a id="_idTextAnchor150"/>Chapter 10</em>: Beginning the Decomposition Journey</h1>
			<p class="author-quote">A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.</p>
			<p class="author-quote">— Leslie Lamport</p>
			<p>So far, we have a working application for <strong class="bold">Letter of Credit</strong> (<strong class="bold">LC</strong>) application processing, which is bundled along with other components as a single package. Although we have discussed the idea of subdomains and bounded contexts, the separation between these components is logical rather than physical. Furthermore, we have primarily focused on the <em class="italic">LC Application Processing</em> aspect of the overall solution.</p>
			<p>In this chapter, we will look at how to extract the LC Application Processing bounded context into a component that is physically disparate and, hence, enables us to deploy them independently of the rest of the solution. We will discuss the various options that are available to us, the rationale for choosing a given option, and the implications that we need to be cognizant of.</p>
			<p>In this chapter, we’ll cover the following topics:</p>
			<ul>
				<li>Continuing our design journey</li>
				<li>Decomposing our monolith</li>
				<li>Changes to frontend interactions</li>
				<li>Changes in database interactions</li>
			</ul>
			<p>By the end of this chapter, you will have learned what it takes to design well-factored APIs—both remote procedure calls and event-based. For event-based APIs, you will gain an understanding of the various guarantees that might be needed to create robust solutions. Finally, you will also learn how to manage consistency when using multiple data stores.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Continuing our design journey</h1>
			<p>In the preceding chapters, we had a <a id="_idIndexMarker597"/>solution for LC Application Processing that worked as an in-process component of the remainder of the overall application. From a logical perspective, our realization of the LC application is similar to the following diagram:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B16716_Figure_10.1.jpg" alt="Figure 10.1 – The current view of the LC application monolith&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The current view of the LC application monolith</p>
			<p>Although the <strong class="bold">LC Application Processing</strong> component is loosely coupled with the rest of the application, we are still required to coordinate with several other teams to realize the business value. This could inhibit our ability to innovate at a pace that is faster than the slowest contributor in the ecosystem. This is because all teams need to be production-ready before a deployment can happen. This can be further exacerbated by the fact that individual teams might be at different levels of engineering maturity. Let’s look at some options regarding how we can achieve a level of independence from the rest of the ecosystem by physically decomposing our components into distinctly deployable artifacts.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Decomposing our monolith</h1>
			<p>First and foremost, the <strong class="bold">LC Application Processing</strong> component exposes only in-process APIs when other<a id="_idIndexMarker598"/> components interact with it. This includes interactions with the following:</p>
			<ul>
				<li>The frontend</li>
				<li>Published/consumed events</li>
				<li>Databases</li>
			</ul>
			<p>To extract LC Application Processing functionality into its own, independently deployable component, remotely invokable interfaces will have to be supported instead of the in-process ones that we currently have. So, let’s examine the remote API options for each.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Changes to frontend interactions</h1>
			<p>Currently, the <strong class="bold">JavaFX</strong> frontend interacts<a id="_idIndexMarker599"/> with the rest of the application by making request-response style in-process method calls (that is, <strong class="source-inline">CommandGateway</strong> for commands and <strong class="source-inline">QueryGateway</strong> for queries), as shown here:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/ch10-1.jpg" alt=""/>
				</div>
			</div>
			<p>One very simple way to replace these in-process<a id="_idIndexMarker600"/> calls is to introduce <a id="_idIndexMarker601"/>some form of <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>). Now our application looks similar to the following:</p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/B16716_Figure_10.2.jpg" alt="Figure 10.2 – Introducing remote interaction with the frontend&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Introducing remote interaction with the frontend</p>
			<p>When working with in-process <a id="_idIndexMarker602"/>interactions, we are simply invoking methods on objects within the confines of the same process. However, when we switch to using out-of-process calls, there are quite a few considerations. These days when working with remote APIs, we have several popular choices in the form of <strong class="bold">JSON</strong>-based web services, <strong class="bold">GraphQL</strong>, <strong class="bold">gRPC</strong>, and more. While it is possible to make use of a completely custom format to facilitate the communication, DDD <a id="_idIndexMarker603"/>advocates the use of the <strong class="bold">Open Host Service pattern</strong> (<a href="https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_open_host_service_ohs">https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_open_host_service_ohs</a>) using a published language that we covered in <a href="B16716_09_Final_NM_ePub.xhtml#_idTextAnchor138"><em class="italic">Chapter 9</em></a>, <em class="italic">Integrating with External Systems</em>. Even with the open host service style of communication, there<a id="_idIndexMarker604"/> are a few considerations, some of which we discuss in the following subsections.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Protocol options</h2>
			<p>There are several options <a id="_idIndexMarker605"/>available to us when exposing remote APIs. These days, using a JSON-based API (often labeled as <strong class="bold">Representation State Transfer</strong> or <strong class="bold">REST</strong>) seems to<a id="_idIndexMarker606"/> be quite popular. However, this isn’t the only option available to us. In a resource-based approach, the first step is to identify a resource (noun) and then map the interactions (verbs) associated with the resource as a next step. In an action-based approach, the focus is on<a id="_idIndexMarker607"/> the actions to be performed. Arguably, REST takes a resource-based approach, whereas <strong class="bold">graphQL</strong>, <strong class="bold">gRPC</strong>, <strong class="bold">SOAP</strong>, and more, seem to be action-based. Let’s<a id="_idIndexMarker608"/> take an example of <a id="_idIndexMarker609"/>an API where we want to start a new LC application. In a RESTful world, this could look something like this:</p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/10-2.jpg" alt=""/>
				</div>
			</div>
			<p>In comparison, with a graphQL implementation, this could look like the following:</p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/10-3.jpg" alt=""/>
				</div>
			</div>
			<p>In our experience, designing APIs using REST does result in some form of dilution when attempting to mirror the language of the domain—because the focus is first and foremost on resources. Purists will be quick to point out that the preceding example is not RESTful because there is no resource named <strong class="source-inline">start-new</strong> and that we should leave the URL to simply include the name <a id="_idIndexMarker610"/>of the resource (use /lc- applications instead of <strong class="source-inline">/lc-applications/start-new</strong>). Our approach is to place more importance on remaining true to the ubiquitous language as opposed to being dogmatic about adherence to technical purity.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Transport format</h2>
			<p>Here, we have two broad choices: <strong class="bold">text-based</strong> (for example, <strong class="bold">JSON</strong> or <strong class="bold">XML</strong>) versus <strong class="bold">binary</strong> (for example, protocol<a id="_idIndexMarker611"/> buffers, <a href="https://developers.google.com/protocol-buffers">https://developers.google.com/protocol-buffers</a>, or Avro, <a href="https://avro.apache.org/">https://avro.apache.org/</a>). If non-functional<a id="_idIndexMarker612"/> requirements (such as performance) are met, our preference is to use<a id="_idIndexMarker613"/> text-based protocols as a starting point. That’s because it can afford the flexibility of not needing any additional tools to visually interpret the data (when debugging).</p>
			<p>When designing a remote API, we have the option of choosing a format that enforces a schema (for example, protocol buffers or Avro) or something less formal such as plain JSON. In such cases, in order to stay true to the ubiquitous language, the process might have to include additional governance in the form of more formal design and code reviews, documentation, and more.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Compatibility and versioning</h2>
			<p>As requirements evolve, there will be a need to enhance the interfaces to reflect these changes. This will mean that our <a id="_idIndexMarker614"/>ubiquitous language will also change over time, rendering old concepts obsolete. The general principle is to maintain backward compatibility with consumers for as long as possible. But this does come at the cost of having to maintain old and new concepts together—leading to a situation where it can become hard to tell what is relevant versus what is not. Using an explicit versioning strategy can help to manage this complexity up to an extent—where newer versions might be able to break backward compatibility with older ones. However, it is also not feasible to continue supporting a large number of incompatible versions indefinitely. Hence, it is important to make sure that the versioning strategy makes deprecation and retirement agreements explicit.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>REST APIs</h2>
			<p>We recognize that there are several options when exposing web-based APIs, and claims of using a REST approach seem quite common<a id="_idIndexMarker615"/> these days. REST was coined by Roy Fielding as part of his doctoral dissertation. The idea of what constitutes REST has been a matter of debate and, arguably, remains ambiguous even today. Leonard Richardson introduced the notion of a maturity model for HTTP-based REST APIs that somewhat helped provide some clarity. The model describes broad conformance to REST in four levels, with each level being more mature than the preceding one:</p>
			<p>0.	<strong class="bold">Adhoc</strong>: Where APIs are designed without the use of any perceptible structure.</p>
			<ol>
				<li><strong class="bold">Resources</strong>: Where APIs are designed around a <em class="italic">thing</em> that makes sense on its own (usually, this is a noun). Here, a very small subset of verbs (either a GET or a POST) could be used to model all operations.</li>
				<li><strong class="bold">HTTP verbs</strong>: Where APIs are designed by making <a id="_idIndexMarker616"/>use of a standard set of operations that can be performed on a resource (for example, GET for reads, POST for creates, PUT for updates, DELETE for deletes, and more).</li>
				<li><strong class="bold">HATEOAS</strong>: Where APIs include hypermedia<a id="_idIndexMarker617"/> links to help clients discover our API in a self-service manner.</li>
			</ol>
			<p>In our experience, most web service-based solutions that claim to be RESTful seem to stop at level 2. Roy Fielding, the inventor of REST, seems to claim that <em class="italic">REST APIs must be hypertext-driven</em> (<a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a>). In our opinion, the use of hypertext controls in APIs allows them to become self-documenting and, thereby, promotes the use of the ubiquitous language more explicitly. More importantly, it also indicates what operations are applicable for a given resource at that time in its life cycle. For example, let’s look at a sample response where all pending LC applications have been listed:</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/10-4.jpg" alt=""/>
				</div>
			</div>
			<p>In the preceding example, there are two <strong class="source-inline">lc-applications</strong> listed. Based on the current status of the LC, the links provide a means to act on the LC appropriately. In addition to the <em class="italic">self</em> link, the first LC<a id="_idIndexMarker618"/> application shows a submit link denoting that it can be submitted, whereas the second application shows the approve and reject links, but not a submit link. Presumably, this is because it has already been submitted. Also, notice how the response does not need to include a status attribute so that they can use this to deduce which operations are relevant for the LC application at that time (this is an example of the <em class="italic">tell</em><em class="italic">,</em><em class="italic"> don’t ask</em> principle, <a href="https://martinfowler.com/bliki/TellDontAsk.html">https://martinfowler.com/bliki/TellDontAsk.html</a>). While this might be a subtle nuance, we felt that it is valuable to point out in the context of our DDD journey.</p>
			<p>So, we have looked at a few considerations when moving from an in-process API to an out-of-process API. There are quite a few other considerations, specifically pertaining to non-functional requirements (such as performance, resilience, error handling, and more). We will look at these in more detail in <a href="B16716_11_Final_NM_ePub.xhtml#_idTextAnchor164"><em class="italic">Chapter 11</em></a>, <em class="italic">Decomposing into Finer-Grained Components</em>.</p>
			<p>Now that we have a handle on how we can work with APIs that interact with the frontend, let’s look at how we can handle event publication and consumption <em class="italic">remotely</em>.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Changes for event interactions</h2>
			<p>Currently, our application publishes and<a id="_idIndexMarker619"/> consumes domain events over an in-process<a id="_idIndexMarker620"/> bus that the <strong class="bold">Axon</strong> framework makes available.</p>
			<p>We publish events when processing commands:</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/ch10-5.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">Publishing an event when processing a command successfully and consume events to expose query APIs:</li>
			</ol>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/ch10-6.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="1">We subscribe to an event using the Axon-provided <strong class="source-inline">@EventHandler</strong> annotation.</li>
			</ol>
			<p>In order to process events remotely, we <a id="_idIndexMarker621"/>need to introduce an explicit infrastructure component in the form of an event bus. Common options <a id="_idIndexMarker622"/>include message<a id="_idIndexMarker623"/> brokers such as <strong class="bold">ActiveMQ</strong> and <strong class="bold">RabbitMQ</strong>, or a distributed event streaming platform, such <a id="_idIndexMarker624"/>as <strong class="bold">Apache Kafka</strong>. Application components can continue to publish and consume events as before—only, now, they will happen using an out-of-process style of invocation. Logically, this now causes our application to look similar to the following:</p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/B16716_Figure_10.3.jpg" alt="Figure 10.3 – Introducing an out-of-process event bus&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Introducing an out-of-process event bus</p>
			<p>When working with events <a id="_idIndexMarker625"/>within the confines of a single process, assuming synchronous processing (event publishing and consumption on the same thread), we do not encounter a majority of problems that only become apparent when the publisher and the consumer are distributed across multiple processes. Let’s examine some of these in more detail next.</p>
			<h3>Atomicity guarantees</h3>
			<p>Previously, when the publisher processed <a id="_idIndexMarker626"/>a command by publishing an event and the consumer(s) handled it, transaction processing occurred as a single atomic unit, as follows:</p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/B16716_Figure_10.4.jpg" alt="Figure 10.4 – ACID transaction processing within the monolith&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – ACID transaction processing within the monolith</p>
			<p>Notice how all the highlighted operations in the preceding diagram happen as part of a single database transaction. This<a id="_idIndexMarker627"/> allows the system to be strongly consistent from end to end. When the event bus is distributed to work within its own process, atomicity cannot be guaranteed as it was previously. Each of the preceding numbered operations works as an independent transaction. This means that they can fail independently, which can lead to data inconsistencies.</p>
			<p>To solve this problem, let’s look at each step of the process in more detail, starting with command processing:</p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/B16716_Figure_10.5.jpg" alt="Figure 10.5 – Command processing transaction semantics&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Command processing transaction semantics</p>
			<p>Let’s consider a situation where we save to the database but fail to publish the event. Consumers will remain oblivious of the event that is occurring and become inconsistent. On the flip side, if we publish the<a id="_idIndexMarker628"/> event but fail to save it in the database, the command processing side itself becomes inconsistent—not to mention that the query side now thinks that a domain event occurred, when, in fact, it did not. Again, this leads<a id="_idIndexMarker629"/> to inconsistency. This <strong class="bold">dual-write</strong> problem is fairly common in distributed event-driven applications. If command processing has to work in a foolproof manner, saving to the database and publishing to the event bus have to happen atomically—both operations should succeed or fail in unison. Here are a few solutions that we have used to solve this issue (in increasing order of complexity):</p>
			<ul>
				<li><strong class="bold">Do nothing</strong>: Arguably, this approach is not really a solution; however, it might be the only placeholder until a more robust solution is in place. While it might be puzzling to see this being listed as an option, we have seen several occasions where this is indeed how event-driven systems have been implemented. We leave this here as a word of caution so that teams become cognizant of the pitfalls.</li>
				<li><strong class="bold">Transaction synchronization</strong>: In this approach, multiple resource managers are synchronized in a way that a failure in any one system will trigger a cleanup in the others where the transaction has already been committed. It is pertinent to note that this might not <a id="_idIndexMarker630"/>be foolproof, as it might lead to cascading failures.</li>
			</ul>
			<p class="callout-heading">Information</p>
			<p class="callout">The Spring Framework provides support for this style of behavior through the <strong class="source-inline">TransactionSynchronization</strong> interface and the now deprecated <strong class="source-inline">ChainedTransactionManager</strong> interface. Please refer to the framework documentation for further details. Needless to say, this interface should not be used without careful consideration of the business requirements.</p>
			<ul>
				<li><strong class="bold">Distributed transactions</strong>: Another approach is to make use of distributed transactions. A distributed transaction is a set of operations on data that is performed across two or more resource managers (usually, these are databases) using techniques such as <strong class="bold">two-phase commit</strong> (<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html">https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html</a>). Typically, this<a id="_idIndexMarker631"/> functionality is implemented using pessimistic locking on the underlying resource managers (databases) and could present scaling challenges in highly concurrent environments.</li>
				<li><strong class="bold">Transactional outbox</strong>: None of the preceding methods are completely foolproof in the sense that there still exists a window of opportunity where the database and the event bus can become inconsistent (this is true even with two-phase commits). One way to circumvent this problem is by completely eliminating the dual-write problem.</li>
			</ul>
			<p>In this solution, the command processor writes to its database and the intended event to an <em class="italic">outbox</em> table in a local transaction. A separate poller component polls the outbox table and writes to the event bus. Polling can be computationally intensive and<a id="_idIndexMarker632"/> could lead back to the dual write problem again because the poller has to keep track of the last written event. This could be avoided by making event processing idempotent on the consumer so that processing duplicate events do not cause issues, especially in extremely high concurrency and volume scenarios. Another way to <a id="_idIndexMarker633"/>mitigate this issue is to use a <strong class="bold">Change Data Capture</strong> (<strong class="bold">CDC</strong>) tool (such as <strong class="bold">Debezium</strong>, <a href="https://debezium.io/">https://debezium.io/</a>) and Oracle <a id="_idIndexMarker634"/>LogMiner (<a href="https://en.wikipedia.org/wiki/OracleLogMiner">https://en.wikipedia.org/wiki/OracleLogMiner</a>). Most modern <a id="_idIndexMarker635"/>databases ship with tools to make this easier, and they may be worth exploring. One way to implement this<a id="_idIndexMarker636"/> is to use the <strong class="bold">transactional outbox pattern</strong>, as shown in the following diagram:</p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/B16716_Figure_10.6.jpg" alt="Figure 10.6 – The transactional outbox pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – The transactional outbox pattern</p>
			<p>The transactional outbox pattern is a robust approach for dealing with the dual-write problem. However, it also introduces a non-trivial amount of operational complexity. In one of our previous implementations, we made use of transactional synchronization to ensure that we never <a id="_idIndexMarker637"/>missed writes to the database. Additionally, we ensured that the event bus was highly available through redundancy on both the compute and storage tiers and, most importantly, by avoiding <em class="italic">any</em> business logic on the event bus.</p>
			<h3>Delivery guarantees</h3>
			<p>Previously, because all of our components worked within a single process, the delivery of events to the consumers was guaranteed at least as<a id="_idIndexMarker638"/> long as the process stayed alive. Even if event processing failed on the consumer side, it was fairly straightforward to detect the failure because exception handling was fairly straightforward.</p>
			<p>Furthermore, rollbacks were straightforward because the production and consumption of events happened as part of a single database transaction. With the LC processing application now becoming a remote component, event delivery becomes a lot more challenging. When it comes to message delivery semantics, there are three basic categories:</p>
			<ul>
				<li><strong class="bold">At-most-once delivery</strong>: This means that each message might be delivered once or not at all. Arguably, this style of <a id="_idIndexMarker639"/>delivery is the easiest to implement because the producer creates messages in a fire-and-forget fashion. This might be okay in environments where the loss of some messages is tolerated. For example, data from click-stream analytics or logging can fall into this category.</li>
				<li><strong class="bold">At-least-once delivery</strong>: This means that <a id="_idIndexMarker640"/>each message will be delivered more than once with no messages being lost. Delivery of undelivered messages is retried—potentially infinitely. This style of delivery might be required when it is not feasible to lose messages, but where it would be tolerable to process the same message more than once. For example, analytical environments can tolerate duplicate message delivery or have duplicate detection logic to discard already processed messages.</li>
				<li><strong class="bold">Exactly-once delivery</strong>: This means that each message is delivered exactly once without either being lost or duplicated. This style of message delivery is extremely hard to implement, and <a id="_idIndexMarker641"/>a lot of solutions could approach exactly-once semantics with some implementation help from the consumers where duplicate messages are detected and discarded with the producer sticking to at-least-once delivery semantics.</li>
			</ul>
			<p>For domain event processing, most teams will, of course, prefer to have exactly-once processing semantics, given that they would not want to lose any of these events. However, given the practical <a id="_idIndexMarker642"/>difficulties guaranteeing <em class="italic">exactly-once</em> semantics, it is not unusual to approach exactly-once processing by having the consumer process events in an idempotent manner or designing events to make it easier to detect errors.</p>
			<p>For example, consider a <strong class="source-inline">MonetaryAmountWithdrawn</strong> event, which includes <strong class="source-inline">accountId</strong> and <strong class="source-inline">withdrawalAmount</strong>. This event could carry an additional <strong class="source-inline">currentBalance</strong> attribute so that the consumer will know if they are out of sync with the producer when processing the withdrawal. Another way to do this is for the consumer to keep track of the last <em class="italic">n</em> events processed. When processing an event, the consumer can check whether this event has already been processed. If so, they can detect it as a duplicate and simply discard it. Again, all the preceding methods add a level of complexity to the overall system. Despite all these safeguards, consumers could still find themselves out of sync with the system of record (the command side that produces the event). If so, as <a id="_idIndexMarker643"/>a last resort, it might be necessary to use partial or full event replays (<a href="https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_historic_event_replays">https://ddd-book.karthiks.in/10-distributing-into-multiple-components.html#_historic_event_replays</a>), which was discussed in <a href="B16716_07_Final_NM_ePub.xhtml#_idTextAnchor112"><em class="italic">Chapter 7</em></a>, <em class="italic">Implementing Queries</em>.</p>
			<h3>Ordering guarantees</h3>
			<p>In an event-driven system such as the<a id="_idIndexMarker644"/> one we are building, it is desirable for consumers to receive events in a deterministic order. Not knowing the order or receiving it in the wrong order could result in inaccurate outcomes. Let’s consider the example of <strong class="source-inline">LCApplicationAddressChangedEvent</strong> occurring twice in <em class="italic">quick succession</em>. If these changes are processed in the wrong order, we could end up displaying the wrong address as their current one. This does not necessarily mean that events need to be ordered for all use cases. Let’s consider another example where we receive <strong class="source-inline">LCApplicationSubmittedEvent</strong> more than once erroneously when it is not possible to submit a given LC application more than once. All such notifications after the first can be ignored.</p>
			<p>As a consumer, it is important to<a id="_idIndexMarker645"/> know whether events will be ordered or not so that we can make design considerations for out-of-order events. One default might be to accommodate for out-of-order events as a default. In our experience, this does tend to make the resulting design more complicated, especially in cases where the order does matter. Here, we will discuss three-event ordering strategies and their implications for both the producer and the consumer:</p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/B16716_10_Table_01.jpg" alt=""/>
				</div>
			</div>
			<p>In most applications, per <a id="_idIndexMarker646"/>aggregate ordering might be a good place to start and cater to most business scenarios. </p>
			<h3>Durability and persistence guarantees</h3>
			<p>When an event is published to the event bus, the happy path scenario is that the intended consumer(s) can process it <a id="_idIndexMarker647"/>successfully. However, there are scenarios that can cause message processing to be impacted adversely. Let’s examine each of these scenarios:</p>
			<ul>
				<li><strong class="bold">Slow consumer</strong>: The consumer is <a id="_idIndexMarker648"/>unable to process events as fast as the producers are publishing them.</li>
				<li><strong class="bold">Offline consumer</strong>: The consumer is <a id="_idIndexMarker649"/>unavailable (down) at the time of the events being published.</li>
				<li><strong class="bold">Failing consumer</strong>: The consumer is experiencing<a id="_idIndexMarker650"/> errors when trying to process events.</li>
			</ul>
			<p>In each of these cases, we could develop a backlog of unprocessed events. Because these are domain events, we need to prevent the loss of these events until the consumer has been able to process them successfully. There are two communication characteristics that need to be true for this to work successfully:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/B16716_Figure_10.7.jpg" alt="Figure 10.7 – Persistence versus durability&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Persistence versus durability</p>
			<ul>
				<li><strong class="bold">Persistence</strong>: This is the communication style between the <strong class="bold">Producer</strong> instance and the <strong class="bold">Event Bus</strong> instance.</li>
				<li><strong class="bold">Durability</strong>: This is the communication style between the <strong class="bold">Event Bus</strong> instance and the <strong class="bold">Consumer</strong> instance.</li>
			</ul>
			<p>Firstly, messages need to be<a id="_idIndexMarker651"/> persistent (that is, stored on disk), and secondly, the message subscription (the relationship between the consumer and the event bus) needs to be durable (persist across <strong class="bold">Event Bus</strong> restarts). It is important to note that events have to be made persistent by the producer for them to be consumed durably by the consumer.</p>
			<h3>Processing guarantees</h3>
			<p>When an event is processed by the query side<a id="_idIndexMarker652"/> component, as shown here, the following steps occur:</p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/B16716_Figure_10.8.jpg" alt="Figure 10.8 – Event processing failure scenarios&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Event processing failure scenarios</p>
			<ol>
				<li value="1">The event is consumed (either through a push or a pull) from the <strong class="bold">Event Bus</strong> instance.</li>
				<li>Transformation logic is applied to the payload of the event.</li>
				<li>The transformed payload is saved in the query side store.</li>
			</ol>
			<p>Each of these steps can <a id="_idIndexMarker653"/>encounter failures. Irrespective of the cause of failure, the event should be durable (as discussed earlier) so that it can be processed later when the issue is fixed. These errors can be broadly segregated into four categories:</p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/B16716_10_Table_02.jpg" alt=""/>
				</div>
			</div>
			<p>Now we have<a id="_idIndexMarker654"/> looked at the <a id="_idIndexMarker655"/>changes that we need to make because of the introduction of an out-of-process event bus. Having done this allows us to actually extract the <strong class="bold">LC Application Processing</strong> component into its own independently deployable unit, which will look similar to the following diagram:</p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/B16716_Figure_10.9.jpg" alt="Figure 10.9 – LC Application Processing deployed independently&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – LC Application Processing deployed independently</p>
			<p>However, we are continuing <a id="_idIndexMarker656"/>to use a common datastore for the <strong class="bold">LC Application Processing</strong> component. Let’s look at what is involved in segregating this into its own store.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Changes in database interactions</h1>
			<p>While we have extracted our application <a id="_idIndexMarker657"/>component into its own unit, we continue to be coupled at the database tier. If we are to achieve true independence from the monolith, we need to break this database dependency. Let’s look at the changes involved in making this happen.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>Data migration</h2>
			<p>As a first step to start using a database<a id="_idIndexMarker658"/> of our own, we will need to start migrating data from the command side event store and the query store(s), as shown here:</p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/B16716_Figure_10.10.jpg" alt="Figure 10.10 – Data migration&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Data migration</p>
			<p>In our case, we have the command side event store and the query store(s) that will need to be migrated out. To minimize effort from the outset, it might be prudent to do a simple homogenous migration by keeping the source and target database technologies identical. In advance of the cut-over, among other things, it will be essential to do the following:</p>
			<ul>
				<li><strong class="bold">Profile</strong> to make sure that latency numbers are within tolerable limits</li>
				<li><strong class="bold">Test</strong> to make sure that the data has migrated correctly</li>
				<li><strong class="bold">Minimize downtime</strong> by understanding <a id="_idIndexMarker659"/>and agreeing on <strong class="bold">SLAs</strong>, such <a id="_idIndexMarker660"/>as the <strong class="bold">Recovery Time Objective</strong> (<strong class="bold">RTO</strong>) and <strong class="bold">Recovery Point Objective</strong> (<strong class="bold">RPO</strong>)</li>
			</ul>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Cut-over</h2>
			<p>If we have made it so far, we are<a id="_idIndexMarker661"/> ready to complete the migration of the LC Application Processing from the rest of the monolith. The logical architecture of our solution now looks similar to the following diagram:</p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/B16716_Figure_10.11.jpg" alt="Figure 10.11 – Independent data persistence&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Independent data persistence</p>
			<p>With this step, we have successfully completed the migration of our first component. There is still quite a lot of work to do. Arguably, our component was already well-structured and loosely <a id="_idIndexMarker662"/>coupled with the rest of the application. Despite that, moving from an in-process model to an out-of-process model between bounded contexts is quite an involved process—as should be evident from the work we have done in this chapter.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, we learned how we can extract a bounded context from an existing monolith, although you could argue that this was from a reasonably well-structured one. We looked at the challenges involved in decomposing the monolith from various interaction points such as the frontend, event exchanges, and the database. You should have an understanding of what it takes to go from an in-process event-driven application to an out-of-process one.</p>
			<p>In the next chapter, we will look at how to extract pieces out of a monolith that might not be as well-structured, possibly very close to the dreaded big ball of mud.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>References</h1>
			<p>For more information, please refer to the following resources:</p>
			<ul>
				<li><a href="https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a></li>
				<li><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html">https://martinfowler.com/articles/patterns-of-distributed-systems/two-phase-commit.html</a></li>
				<li><a href="https://debezium.io/">https://debezium.io/</a></li>
			</ul>
		</div>
	</body></html>