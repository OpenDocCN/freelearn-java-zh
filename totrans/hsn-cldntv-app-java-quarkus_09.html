<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Securing Applications</h1>
                </header>
            
            <article>
                
<p>Security is a key requirement of every enterprise system. In this chapter, we will learn how to effectively secure Quarkus services using a variety of approaches. The first approach we will put into practice embeds the security layer within our service. This can still be considered a valid solution for rapid application development and testing. On the other hand, when moving our service into production, we need to avoid this extreme centralization. Therefore, the next strategy we will learn about is how the Quarkus service can connect to a distributed security system such as Keycloak. The last topic in this chapter is about encrypting the HTTP channel through some easy configuration steps.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Securing our customer service</li>
<li>Securing Quarkus services with Elytron</li>
<li>Securing Quarkus services with Keycloak</li>
<li>Securing Quarkus services with MicroProfile JWT</li>
<li>Using HTTPS with Quarkus</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can find the source code for the project in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter07">https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter07</a>.<a href="https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/chapter7"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing our customer service</h1>
                </header>
            
            <article>
                
<p>The Quarkus security infrastructure derives from the standard <strong>Java Enterprise Edition</strong> (<strong>Java EE</strong>) specification, which is based on a simple role-based security model. By using that, you can specify your security constraints through annotations and configuration files.</p>
<p>In terms of Java annotations, the following ones can be used to specify security constraints that can be applied either on a single method or on a class:</p>
<ul>
<li><kbd>@javax.annotation.security.RolesAllowed</kbd>: This is the most common annotation as it specifies one or more roles that have been authorized to invoke a certain method or class.</li>
<li><kbd>@javax.annotation.security.RunAs</kbd>: This annotation assigns a role dynamically during the invocation of a method or class. It can be a handy option if we need to temporarily allow the execution of some methods.</li>
<li><kbd>@javax.annotation.security.PermitAll</kbd>: This annotation allows us to release security constraints from methods. It can be useful in some scenarios where you haven't identified which role will be entitled to invoke a method.</li>
<li><kbd>@javax.annotation.security.DenyAll</kbd>: This annotation is the exact opposite of <kbd>@PermitAll</kbd> as it denies access to a method or class that bears this annotation.</li>
</ul>
<p>To keep things simple, we will define a simple security policy for our customer service application. This will include two roles:</p>
<ul>
<li><strong>User</strong> <strong>role</strong>: This role will be entitled to perform <em>read-only</em> operations, such as querying the <kbd>Customer</kbd> list.</li>
<li><strong>Admin</strong> <strong>role</strong>: This role will be entitled to perform all the available operations, including create, update, and delete.</li>
</ul>
<p>The following is the code for our <kbd>CustomerEndpoint</kbd> class, which has been decorated with the <kbd>@RolesAllowed</kbd> security annotation:</p>
<pre><span>public class </span>CustomerEndpoint {<br/><span><br/></span><span>    </span><span>@Inject </span>CustomerRepository <span>customerRepository</span><span>;<br/></span><span><br/></span><span>    </span><span>@GET<br/></span><strong><span>    @RolesAllowed</span>(<span>"user"</span>)</strong><br/>    <span>public </span>List&lt;Customer&gt; <span>getAll</span>() {<br/><span>        </span><span>return </span><span>customerRepository</span>.findAll()<span>;<br/></span><span>    </span>}<br/><br/>    <span>@POST<br/></span><strong><span>    @RolesAllowed</span>(<span>"admin"</span>)</strong><br/>    <span>public </span>Response <span>create</span>(Customer customer) {<br/><br/>        <span>customerRepository</span>.createCustomer(customer)<span>;<br/></span><span>        return </span>Response.<span>status</span>(<span>201</span>).build()<span>;<br/></span><span><br/></span><span>    </span>}<br/><br/>    <span>@PUT<br/></span><strong><span>    @RolesAllowed</span>(<span>"admin"</span>)</strong><br/>    <span>public </span>Response <span>update</span>(Customer customer) {<br/>        <span>customerRepository</span>.updateCustomer(customer)<span>;<br/></span><span>        return </span>Response.<span>status</span>(<span>204</span>).build()<span>;<br/></span><span>    </span>}<br/>    <span>@DELETE<br/></span><strong><span>    @RolesAllowed</span>(<span>"admin"</span>)</strong><br/>    <span>public </span>Response <span>delete</span>(<span>@QueryParam</span>(<span>"id"</span>) Long customerId) {<br/>        <span>customerRepository</span>.deleteCustomer(customerId)<span>;<br/></span><span>        return </span>Response.<span>status</span>(<span>204</span>).build()<span>;<br/></span><span>    </span>}<br/><br/>}</pre>
<p>For the sake of brevity, we won't include the <kbd>OrderEndpoint</kbd> class here, which has been updated in the same way in order to secure read methods with the <strong>user</strong> role and the write methods with the <strong>admin</strong> role.</p>
<p>Having defined our security policy, we can now choose which security provider will be applied to our service. This will require us to add the right settings in <kbd>application.properties</kbd> and include the dependencies in our project's <kbd>pom.xml</kbd> file.</p>
<p>We will start with the Elytron security provider, which doesn't require us to install any external applications or tools to secure our service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing Quarkus services with Elytron</h1>
                </header>
            
            <article>
                
<p>Elytron is a security framework that has been created to unify the security aspects of WildFly and JBoss' <strong>Enterprise Application Platform</strong> (<strong>EAP</strong>). It comes as a consequence that this framework has been initially designed for monolithic applications in order to provide coverage on every aspect of security. What is the advantage of using Elytron in a container-ready native platform such as Quarkus?</p>
<p>Although it may look like an oversimplified solution to securing your assets, it can prove to be advantageous when developing or testing applications that include security roles. Out of the box, Quarkus provides an implementation of a <strong>file-based security realm</strong> in order to provide <strong>role-based access control</strong> (<strong>RBAC</strong>) to our basic endpoints with minimal configuration requirements.</p>
<p>In terms of libraries, at the time of writing this book, there are three available Elytron extensions we can use to secure our applications:</p>
<ul>
<li><kbd>quarkus-elytron-security-properties-file</kbd>: Provides support for basic authentication via property files.</li>
<li><kbd>quarkus-elytron-security-jdbc</kbd>: Provides support for database authentication via JDBC.</li>
<li><kbd>quarkus-elytron-security-oauth2</kbd>: Provides support for OAuth2 authentication. This extension may be deprecated in future versions of Quarkus and replaced by a reactive Vert.x version.</li>
</ul>
<p>Since our customer application already uses a database as a backend, we will show you how to use database authentication. Please check out the source code in the <kbd>Chapter07/elytron-demo</kbd> folder before you move on.</p>
<p>As shown in the <kbd>pom.xml</kbd> file, we have added the following extension to our project:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.quarkus<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span><span>quarkus-elytron-security-jdbc&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>To configure authentication, we need to specify which table contains the list of users and roles. We also need to add a couple of users with different roles. For this purpose, we have included the following SQL statements in the <kbd>import.sql</kbd> script, which are located in the <kbd>src/main/resources</kbd> folder:</p>
<pre><span>CREATE TABLE </span>quarkus_user (<br/>    id <span>INT</span>,<br/>    username <span>VARCHAR</span>(<span>255</span>),<br/>    password <span>VARCHAR</span>(<span>255</span>),<br/>    role <span>VARCHAR</span>(<span>255</span>)<br/>);<br/><span>INSERT INTO </span>quarkus_user (id, username, password, role) <span>VALUES </span>(<span>1</span>, <span>'admin'</span>, <span>'password123'</span>, <span>'admin'</span>);<br/><span>INSERT INTO </span>quarkus_user (id, username, password, role) <span>VALUES </span>(<span>2</span>, <span>'frank'</span>,<span>'password123'</span>, <span>'user'</span>);</pre>
<p>Now, within the <kbd>application.properties</kbd> file, we need to activate JDBC authentication by providing some basic configuration parameters for it. Here is the list of properties we have added:</p>
<pre><span>quarkus.security.jdbc.enabled</span><span>=</span><span>true<br/></span><span>quarkus.security.jdbc.principal-query.sql</span><span>=</span><span>SELECT u.password, u.role FROM quarkus_user u WHERE u.username=?<br/></span><span>quarkus.security.jdbc.principal-query.clear-password-mapper.enabled</span><span>=</span><span>true<br/></span><span>quarkus.security.jdbc.principal-query.clear-password-mapper.password-index</span><span>=</span><span>1<br/></span><span>quarkus.security.jdbc.principal-query.attribute-mappings.0.index</span><span>=</span><span>2<br/></span><span>quarkus.security.jdbc.principal-query.attribute-mappings.0.to</span><span>=</span><span>groups</span><span> </span></pre>
<p>Let's quickly discuss these properties:</p>
<ul>
<li>The <kbd>quarkus.security.jdbc.enabled</kbd> property, when set to true, enables JDBC authentication.</li>
<li>The <kbd>quarkus.security.jdbc.principal-query.sql</kbd> property is used to specify the SQL statements that will check for a valid username/password combination.</li>
<li>The <kbd>quarkus.security.jdbc.principal-query.clear-password-mapper.enabled</kbd> property, when set to true, configures a mapper that maps a column that's returned from a SQL query to a clear password key type.</li>
<li>The <kbd>quarkus.security.jdbc.principal-query.clear-password-mapper.password-index</kbd> property sets the column index from the clear text authentication query.</li>
<li>Finally, <kbd>quarkus.security.jdbc.principal-query.attribute-mappings.0.index</kbd> and <kbd>quarkus.security.jdbc.principal-query.attribute-mappings.0.to</kbd> are used to bind the second field in the authentication query (<kbd>index=2</kbd>) with the principal's role (groups).</li>
</ul>
<p>That's all you need to secure your service using the Elytron security domain. With all the pieces in the right place, we will be using a test class that verifies authentication against the REST endpoints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a test class that performs basic authentication</h1>
                </header>
            
            <article>
                
<p>Our test class needs to be adjusted so that it can fit the new secured scenario. In practice, we need to send the header files with the user's credentials, along with the HTTP request, with them to authorize the service's execution. Thanks to the Fluent <kbd>RestAssured</kbd> API, it is fairly easy to plug the <kbd>auth()</kbd> method into our HTTP request, as shown in the following code:</p>
<pre><span>@Test</span><span><br/></span><span>public void </span><span>testCustomerService</span>() {<br/>    // Test GET for Customer size<br/>    <span>given</span>()<br/>            .auth()<br/>            .preemptive()<br/>            .basic(<span>"frank"</span><span>, </span><span>"password123"</span>)<br/>            .when().get(<span>"/customers"</span>)<br/>            .then()<br/>            .statusCode(<span>200</span>)<br/>            .body(<span>"$.size()"</span><span>, </span><span>is</span>(<span>2</span>))<span>;<br/></span><span><br/></span><span><br/></span><span>    </span>JsonObject objOrder = Json.<span>createObjectBuilder</span>()<br/>            .add(<span>"item"</span><span>, </span><span>"bike"</span>)<br/>            .add(<span>"price"</span><span>, new </span>Long(<span>100</span>))<br/>            .build()<span>;<br/></span><span><br/></span><span><br/></span><span>    </span><span>// Test POST Order for Customer #1<br/></span><span>    </span><span>given</span>()<br/>            .auth()<br/>            .preemptive()<br/>            .basic(<span>"admin"</span><span>, </span><span>"password123"</span>)<br/>            .contentType(<span>"application/json"</span>)<br/>            .body(objOrder.toString())<br/>            .when()<br/>            .post(<span>"/orders/1"</span>)<br/>            .then()<br/>            .statusCode(<span>201</span>)<span>;<br/></span><span><br/></span><span>    </span><span>// Create new JSON for Order #1<br/></span><span>    </span>objOrder = Json.<span>createObjectBuilder</span>()<br/>            .add(<span>"id"</span><span>, new </span>Long(<span>1</span>))<br/>            .add(<span>"item"</span><span>, </span><span>"mountain bike"</span>)<br/>            .add(<span>"price"</span><span>, new </span>Long(<span>100</span>))<br/>            .build()<span>;<br/></span><span><br/></span><span>    </span><span>// Test UPDATE Order #1<br/></span><span>    </span><span>given</span>()<br/>            .auth()<br/>            .preemptive()<br/>            .basic(<span>"admin"</span><span>, </span><span>"password123"</span>)<br/>            .contentType(<span>"application/json"</span>)<br/>            .body(objOrder.toString())<br/>            .when()<br/>            .put(<span>"/orders"</span>)<br/>            .then()<br/>            .statusCode(<span>204</span>)<span>;<br/></span><span><br/></span><span>    </span><span>// Test GET for Order #1<br/></span><span>    </span><span>given</span>()<br/>            .auth()<br/>            .preemptive()<br/>            .basic(<span>"admin"</span><span>, </span><span>"password123"</span>)<br/>            .when().get(<span>"/orders?customerId=1"</span>)<br/>            .then()<br/>            .statusCode(<span>200</span>)<br/>            .body(<span>containsString</span>(<span>"mountain bike"</span>))<span>;<br/></span><span><br/></span><span>    </span><span>// Test DELETE Order #1<br/></span><span>    </span><span>given</span>()<br/>            .auth()<br/>            .preemptive()<br/>            .basic(<span>"admin"</span><span>, </span><span>"password123"</span>)<br/>            .when().delete(<span>"/orders/1"</span>)<br/>            .then()<br/>            .statusCode(<span>204</span>)<span>;<br/></span><span><br/></span><span><br/></span>}</pre>
<div class="packt_tip">Please note that we have to use a preemptive basic authentication. This means that the authentication details are sent in the request header immediately, regardless of whether the server has already challenged the authentication. Without that, the current Vert.x implementation in Quarkus would return an unauthorized response.</div>
<p>Assuming that the PostgreSQL database has been started, our test class is ready to be executed:</p>
<pre><strong>mvn compile test</strong></pre>
<p>You should see that all of the CRUD operations have completed successfully:</p>
<pre><strong>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.799 s - in com.packt.quarkus.chapter7.CustomerEndpointTest</strong><br/><strong> 2019-08-16 15:30:12,281 INFO  [io.quarkus] (main) Quarkus stopped in 0.012s</strong><br/><strong>[INFO]</strong><br/><strong>[INFO] Results:</strong><br/><strong>[INFO]</strong><br/><strong>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</strong></pre>
<p>In the next section, we will cover how to use Keycloak to leverage OpenID (<a href="https://openid.net/">https://openid.net/</a>) security standards in our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing Quarkus services with Keycloak</h1>
                </header>
            
            <article>
                
<div class="paragraph">
<p><strong>Keycloak</strong> (<a href="https://www.keycloak.org/">https://www.keycloak.org/</a>) is an open source access management solution that builds on top of the WildFly application server. You can adopt it in your architecture to leverage a wide variety of features, such as the following:</p>
</div>
<ul>
<li><strong>Client adapters</strong></li>
<li><strong>Single Sign-On</strong> (<strong>SSO</strong>)</li>
<li><strong>Identity management and social login</strong></li>
<li><strong>Standard protocols (<span class="ILfuVd"><span class="e24Kjd">OpenID Connect or SAML</span></span>)</strong></li>
<li><strong>A rich admin console</strong></li>
<li><strong>A user account management console</strong></li>
</ul>
<div class="paragraph">
<p>Thanks to these features and the ability to connect to existing identity standards, Keycloak has become a de facto standard for many large organizations. A supported version of it, known as <strong>Red Hat Single Sign-On</strong> (<strong>RH-SSO</strong>:<strong> </strong><a href="https://access.redhat.com/products/red-hat-single-sign-on">https://access.redhat.com/products/red-hat-single-sign-on</a>), is also available for enterprise customers.</p>
<p>Once installed, Keycloak acts as the main security endpoint for the applications in your network. Therefore, your applications don't have to add login forms to authenticate users and store their credentials. Instead, applications are configured to point to Keycloak, which supports protocol standards such as OpenID or SAML to secure your endpoints.</p>
<p>In short, client applications will be redirected from their domain to Keycloak's identity server, where they exhibit their credentials. This way, your services are completely isolated from your security policies and from your user's credentials. Instead, services are granted a digitally signed identity token or assertion. These tokens hold identity information (such as name or email address) but can also hold information about roles that are authorized to perform business operations. In the next section, we will learn how to configure Keycloak so that we can issue tokens that can be used to access our example customer service.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a Keycloak extension to our service</h1>
                </header>
            
            <article>
                
<p>Within the <kbd>Chapter07/keycloak-demo</kbd> folder, you will find another version of our customer service application that uses Keycloak to secure the REST endpoints. To use Keycloak authorization and the OpenID extension, we have included the following set of dependencies in the <kbd>pom.xml</kbd> file:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.quarkus<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>quarkus-keycloak-authorization<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.quarkus<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>quarkus-oidc<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Now that all the required libraries are in place, let's learn how to install Keycloak Identity Server and load a security realm in it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Keycloak</h1>
                </header>
            
            <article>
                
<p>In this section, we will be using Docker to quickly take the reins of Keycloak. First, we need to pull the Keycloak image and start a container instance. The following command will start the Keycloak Server in the background and choose <kbd>8180</kbd> as the HTTP port and expose the host and port locally:</p>
<pre><strong>docker run --rm  \</strong><br/><strong>   --name keycloak \</strong><br/><strong>   -e KEYCLOAK_USER=admin \</strong><br/><strong>   -e KEYCLOAK_PASSWORD=admin \</strong><br/><strong>   -p 8180:8180 \</strong><br/><strong>   -it quay.io/keycloak/keycloak:7.0.1 \</strong><br/><strong>   -b 0.0.0.0 \</strong></pre>
<pre><strong>   -Djboss.http.port=8180 \</strong><br/><strong>   -Dkeycloak.profile.feature.upload_scripts=enabled</strong></pre>
<p>In the console, you should see that the server has managed to start successfully:</p>
<pre><strong>10:33:15,519 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0060: Http management interface listening on http://127.0.0.1:9990/management</strong><br/><strong> 10:33:15,519 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0051: Admin console listening on http://127.0.0.1:9990</strong><br/><strong> 10:33:15,519 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: Keycloak 6.0.1 (WildFly Core 8.0.0.Final) started in 15991ms - Started 672 of 937 services (652 services are lazy, passive or on-demand)</strong></pre>
<p>Now that Keycloak is up and running, let's load a realm, which contains a valid security configuration that we will apply to our service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the security realm</h1>
                </header>
            
            <article>
                
<p>A key aspect of Keycloak configuration is the security realm, which contains all the configuration (user, roles, client policies, and many others) that are pertinent to one security context. When you start Keycloak for the first time, it will contain just one realm: the <strong>master</strong> realm. This is the top level in the hierarchy of realms. You shouldn't use this realm to configure users and services in your organization. Instead, consider using the master realm for administrators who are in charge of defining the other realms in your organization.</p>
<p>Our GitHub repository for this chapter contains an application realm named <strong>Quarkus realm</strong> that will be useful for our purposes. We will show you how to import it and then we will walk through its configuration so that you will be able to create new realms based on this template. Let's proceed with the following steps:</p>
<ol>
<li>Start by connecting to the Keycloak console, which is available at <kbd>http://localhost:8180</kbd>. An authentication challenge will be displayed. Log in with <kbd>admin/admin</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7b04d01d-7e6d-4543-bd34-6cd80142e3cd.png" style=""/></div>
<ol start="2">
<li class="CDPAlignCenter CDPAlign">Now, from the top-left panel, choose to add a new realm, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/16b183e1-d7f3-4303-86e3-cf2377431073.png" style=""/></div>
<ol start="3">
<li>Choose to <span class="packt_screen">Import</span> a realm and point to the JSON file (<kbd>quarkus-realm.json</kbd>) that contains an export of Quarkus' realm:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/864912ae-fa33-4d16-82a6-c190a1d55b47.png" style=""/></div>
<ol start="4">
<li>Click on <span class="packt_screen">Create</span> to continue. Now, let's look at a short overview of the realm's options.</li>
</ol>
<p>Within the realm settings window, you will be able to define some core settings, such as the domain name, and your login settings, predefine your tokens' lifespan and timeouts, and more:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5781993e-6718-4d52-a2cb-95756ac16a49.png" style=""/></div>
<p>For the purpose of our learning path, we will not vary these settings. In the realm panel, you will be able to verify that we have included the same roles (<span class="packt_screen">admin</span> and <span class="packt_screen">user</span>) so that they match our existing security constraints:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/889a139b-e185-4ac5-89d9-48f463110248.png" style=""/></div>
<p>Here, we have recreated the same list of users that we tested in our file-based Elytron domain:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ecc9c4d6-5a0c-41cd-b451-fef370f51552.png" style=""/></div>
<p>From within the <span class="packt_screen">Role Mappings</span> tab, you can check that the <span class="packt_screen">test</span> user is a member of the <span class="packt_screen">user</span> role:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/07d431be-45f1-442e-b6f4-9828a25de68a.png" style=""/></div>
<p>On the other hand, the <span class="packt_screen">admin</span> user will be assigned to both the <span class="packt_screen">admin</span> and the <span class="packt_screen">user</span> role:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ccaa9f2a-04d7-4402-9867-d9d386bebf81.png" style=""/></div>
<p>Now that we've looked at the users and roles, let's discuss a key aspect of the realm's client configuration, which is displayed in the following UI:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/724afdbe-9817-4458-af06-c3788a30efb4.png" style=""/></div>
<p>Let's look at some of the key aspects of the client configuration. First and foremost, we have to define the client protocol. There are two types of client authentication protocols:</p>
<ul>
<li><strong>OpenID Connect</strong> (<strong>OIDC</strong>) is an authentication system where the client requests an access token that's used to call other services on behalf of the authenticated user.</li>
<li><strong>SAML</strong> authentication requires Keycloak to provide an SSO for the users of your organization.</li>
</ul>
<p>For our needs, OIDC token-based authentication is what we need to grant access to our services. We also need to select whether we will be using the standard flow or the implicit flow for authentication.</p>
<p>The default option (<span class="packt_screen">Standard Flow Enabled</span>) involves an initial browser redirection to/from the OIDC provider (Keycloak) for user authentication and consent. Then, a second back-channel request is needed to retrieve the ID token. This flow offers optimal security since tokens aren't revealed to the browser and the client can be safely authenticated.</p>
<p>Let's depict this flow in the form of a sequence diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/79970357-6452-4a8f-a669-7696771cf27a.png" style=""/></div>
<p>To provide a better performance, Keycloak also supports <strong>implicit flows</strong>, which occur when the access token is sent immediately after successful authentication. Although this option may scale better (since there is no additional request to exchange the code for tokens), you will be in charge of monitoring when the token expires so that you can issue a fresh one.</p>
<p>Since we've chosen to use the standard flow, we will specify an appropriate <span class="packt_screen">Valid Redirect URI</span>, which needs to be set to the default HTTP port of our application running on Quarkus.</p>
<p class="mce-root">For the <span class="packt_screen">Access Type</span>, we have configured it to be <span class="packt_screen">c</span><span class="packt_screen">onfidential</span>, which requires client applications to provide a secret in order to obtain an ID token. When you set the <span class="packt_screen">Access Type</span> to <span class="packt_screen">confidential</span>, you will be able to choose the <span class="packt_screen">Client Authenticator</span> from the <span class="packt_screen">Credentials</span> tab, which defines the type of credential you will use for your client and its secret. The secret that's defined for this client ID is <span class="packt_screen">mysecret</span>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/302fa96c-9029-4ea0-a071-761c46de61ab.png" style=""/></div>
<p>If you want to change the default secret, just click on the <span class="packt_screen">Regenerate Secret</span> button and update your client applications accordingly.</p>
<p><span><span>Now that we have configured</span></span> Keycloak, we will use this realm to execute a test using a bearer token authentication. However, before that, we will configure our Quarkus service accordingly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Quarkus for Keycloak</h1>
                </header>
            
            <article>
                
<p>Believe it or not, once we have configured the identity server, we don't have much work to do in our Quarkus application. We only need to provide the Keycloak URL and client settings to the <kbd>application.properties</kbd> configuration file of our application:</p>
<pre><span>keycloak.url</span><span>=</span><span>http://localhost:8180<br/></span><span><br/></span><span>quarkus.oidc.enabled</span><span>=</span><span>true<br/></span><span>quarkus.oidc.auth-server-url</span><span>=</span><span>${keycloak.url}/auth/realms/quarkus-realm<br/></span><span>quarkus.oidc.client-id</span><span>=</span><span>quarkus-client<br/></span><span>quarkus.oidc.credentials.secret</span><span>=</span><span>mysecret</span><span># Enable Policy Enforcement<br/></span><span>quarkus.keycloak.policy-enforcer.enable</span><span>=</span><span>true<br/></span><span><br/></span><span>quarkus.http.cors</span><span>=</span><span>true<br/></span></pre>
<p>In the preceding configuration, we have provided the mandatory settings to connect to the Keycloak Identity Server. We have also added a property named <kbd>keycloak.url</kbd> to define Keycloak's IP address and port. In the following table, we have added some details about each parameter:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Parameter</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>quarkus.oidc.enabled</kbd></td>
<td>When set to true, the OIDC extension will be enabled.</td>
</tr>
<tr>
<td><kbd>quarkus.oidc.auth-server-url</kbd></td>
<td>The root URL where Keycloak authenticates client requests.</td>
</tr>
<tr>
<td><kbd>quarkus.oidc.client-id</kbd></td>
<td>The client ID.</td>
</tr>
<tr>
<td><kbd>quarkus.oidc.credentials.secret</kbd></td>
<td>The client secret.</td>
</tr>
<tr>
<td><kbd>quarkus.keycloak.policy-enforcer.enable</kbd></td>
<td>By enabling the policy enforcer, requests are not allowed in, although there is no policy associated with that resource.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Other than this, if you are planning to run Keycloak on a different machine from your application, it is recommended to enable HTTP CORS so that you can access Keycloak <span class="st">across domain boundaries</span> (check out <a href="078ed3f6-b849-4240-a0d4-cf3bd58c00ab.xhtml" target="_blank">Chapter 5</a>, <em>Managing Data Persistence with Quarkus</em>, for more details about this).</p>
<p>Now, let's dive into the test class that will be used to perform CRUD operations that have been authorized through Keycloak's Identity Server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Coding the test class</h1>
                </header>
            
            <article>
                
<p>Our test class is composed of two blocks. In the first block, we retrieve a token for the <kbd>test</kbd> user and the <kbd>admin</kbd> user. Then, we use both tokens to test the application. More specifically, the <kbd>test</kbd> token, which belongs to the user role, will be used for <kbd>GET</kbd> requests. On the other hand, the <kbd>admin</kbd> token will be used to authorize <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> requests.</p>
<p>Here is the first block of the test class:</p>
<pre>@ConfigProperty(name = "keycloak.url")<br/>String keycloakURL;<br/><br/>    @Test<br/>    public void testHelloEndpoint() {<br/><br/>        RestAssured.baseURI = keycloakURL;<br/>        Response response = given().urlEncodingEnabled(true)<br/>                .auth().preemptive().basic("quarkus-client", <br/>                  "mysecret")<br/>                .param("grant_type", "password")<br/>                .param("client_id", "quarkus-client")<br/>                .param("username", "test")<br/>                .param("password", "test")<br/>                .header("Accept", ContentType.JSON.getAcceptHeader())<br/>                .post("/auth/realms/quarkus-realm/protocol/openid-<br/>                  connect/token")<br/>                .then().statusCode(200).extract()<br/>                .response();<br/><br/>        JsonReader jsonReader = Json.createReader(new <br/>         StringReader(response.getBody().asString()));<br/>        JsonObject object = jsonReader.readObject();<br/>        <strong>String userToken = object.getString("access_token");</strong><br/><br/>        response = given().urlEncodingEnabled(true)<br/>                .auth().preemptive().basic("quarkus-client", <br/>                  "mysecret")<br/>                .param("grant_type", "password")<br/>                .param("client_id", "quarkus-client")<br/>                .param("username", "admin")<br/>                .param("password", "test")<br/>                .header("Accept", ContentType.JSON.getAcceptHeader())<br/>                .post("/auth/realms/quarkus-realm/protocol/openid-<br/>                  connect/token")<br/>                .then().statusCode(200).extract()<br/>                .response();<br/><br/>        jsonReader = Json.createReader(new <br/>         StringReader(response.getBody().asString()));<br/>        object = jsonReader.readObject();<br/>        <strong>String adminToken = object.getString("access_token");</strong><br/><br/>       // Test CRUD Methods here<br/><br/>     }</pre>
<p>This code issues a <kbd>POST</kbd> request against the auth URL of our Keycloak realm. The request contains the username and password, along with the client's ID (<kbd>quarkus_client</kbd>) and its secret (<kbd>mysecret</kbd>) as parameters. The <kbd>RESTAssured</kbd> API verifies that a status code of 200 is returned and returns the response object. Then, we extracted the token contained in the JSON response, which is under the <kbd>access_token</kbd> key.</p>
<p>If you want to debug the low-level details of your token claim, you can use a tool such as <kbd>curl</kbd> to inspect the response returned by Keycloak. For example, if you are going to request a token for the <kbd>test</kbd> user, then here is a plain <kbd>curl</kbd> command that will do the job:</p>
<pre><strong>curl -X POST http://localhost:8180/auth/realms/quarkus-realm/protocol/openid-connect/token \</strong><br/><strong>    --user quarkus-client:mysecret \</strong><br/><strong>    -H 'content-type: application/x-www-form-urlencoded' \</strong><br/><strong>    -d 'username=test&amp;password=test&amp;grant_type=password'</strong></pre>
<p>In the second block of code, we access our service by including the user's token in each REST call. We do this using the <kbd>oauth2</kbd> method:</p>
<pre>RestAssured.baseURI = "http://localhost:8081";<br/>given().auth().preemptive()<br/>        .oauth2(userToken)   <br/>        .when().get("/customers")<br/>        .then()<br/>        .statusCode(200)<br/>        .body("$.size()", is(2));<br/><br/><br/>JsonObject objOrder = Json.createObjectBuilder()<br/>        .add("item", "bike")<br/>        .add("price", new Long(100))<br/>        .build();<br/><br/>// Test POST Order for Customer #1<br/><br/>given().auth()<br/>        .oauth2(adminToken)<br/>        .contentType("application/json")<br/>        .body(objOrder.toString())<br/>        .when()<br/>        .post("/orders/1")<br/>        .then()<br/>        .statusCode(201);<br/><br/>// Create new JSON for Order #1<br/>objOrder = Json.createObjectBuilder()<br/>        .add("id", new Long(1))<br/>        .add("item", "mountain bike")<br/>        .add("price", new Long(100))<br/>        .build();<br/><br/>// Test UPDATE Order #1<br/>given().auth()<br/>        .oauth2(adminToken)<br/>        .contentType("application/json")<br/>        .body(objOrder.toString())<br/>        .when()<br/>        .put("/orders")<br/>        .then()<br/>        .statusCode(204);<br/><br/>// Test GET for Order #1<br/>given().auth()<br/>        .oauth2(adminToken)<br/>        .when().get("/orders?customerId=1")<br/>        .then()<br/>        .statusCode(200)<br/>        .body(containsString("mountain bike"));<br/><br/>// Test DELETE Order #1<br/>given().auth()<br/>        .oauth2(adminToken)<br/>        .when().delete("/orders/1")<br/>        .then()<br/>        .statusCode(204);</pre>
<p>The test can be executed will the following command:</p>
<pre><strong>$ mvn compile test</strong></pre>
<p>You should expect it to complete successfully, as follows:</p>
<pre><strong>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.84 s - in com.packt.quarkus.chapter7.CustomerEndpointTest</strong><br/><strong>2019-08-24 12:28:28,056 INFO  [io.quarkus] (main) Quarkus stopped in 0.011s</strong><br/><strong>[INFO] </strong><br/><strong>[INFO] Results:</strong><br/><strong>[INFO] </strong><br/><strong>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</strong></pre>
<p>Congratulations! You have just managed to set up an enterprise-grade security infrastructure for your service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gathering principal and role information at runtime</h1>
                </header>
            
            <article>
                
<p>Before moving on to the next authentication schema, it's worth noting that you can determine the principal name and roles at runtime by injecting the <kbd>SecurityIdentity</kbd> interface <span class="pl-c">that represents the currently logged-in user.</span> In this short excerpt, we will learn how to retrieve and log the user that's connected, the name/surname they used to<span> register, and the set of roles they are entitled to:</span></p>
<pre><strong><span>@Inject </span>SecurityIdentity <span>securityContext</span><span>;</span></strong><span><br/></span><span>@Inject </span>CustomerRepository <span>customerRepository</span><span>;<br/></span><span><br/>@GET<br/></span><span>@RolesAllowed</span>(<span>"user"</span>)<br/><span>public </span>List&lt;Customer&gt; <span>getAll</span>() {<br/><br/>    <span>LOGGER</span>.info(<span>"Connected with User <br/>     "</span>+<span>securityContext</span>.getPrincipal().getName())<span>;<br/></span><span>    </span>Iterator&lt;String&gt; roles = <span>securityContext</span>.getRoles().iterator()<span>;<br/></span><span>    while </span>(roles.hasNext()) {<br/>       <span>LOGGER</span>.info(<span>"Role: "</span>+roles.next())<span>;<br/></span><span>    </span>}<br/>    <span>return </span><span>customerRepository</span>.findAll()<span>;<br/></span>}</pre>
<p>In this case, when accessing the list of customers, the service will log the following information:</p>
<pre>Connected with User test<br/>Role: offline_access<br/>Role: uma_authorization<br/>Role: user</pre>
<p>You can check all the available methods in the <kbd>SecurityIdentity</kbd> interface by having a look at its source code, which is available at <a href="https://github.com/quarkusio/quarkus-security/blob/master/src/main/java/io/quarkus/security/identity/SecurityIdentity.java">https://github.com/quarkusio/quarkus-security/blob/master/src/main/java/io/quarkus/security/identity/SecurityIdentity.java</a>.<a href="https://github.com/keycloak/keycloak/blob/master/core/src/main/java/org/keycloak/KeycloakSecurityContext.java"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing Quarkus services with MicroProfile JWT</h1>
                </header>
            
            <article>
                
<p>In the previous example, we covered how to use Keycloak to authenticate and authorize requests using a bearer token. A bearer token alone, however, is a simplified security schema since it's based on exchanging a potentially arbitrary string.</p>
<p>Any client in possession of a valid bearer token can use it to get access to the associated resources without demonstrating his/her identity, which can only be verified with a cryptographic key. In order to fill this gap, we will learn how to use <strong>JSON Web Tokens</strong> (<strong>JWTs</strong>), an encoding standard for tokens, using a JSON data payload that can be signed and encrypted. A JWT includes the following sections:</p>
<ul>
<li><strong>Header</strong>: This is a Base64-encoded string and consists of two parts: the type of the token, which is JWT, and the hashing algorithm being used, such as HMAC SHA256 or RSA. Here is a sample decoded header JWT:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2e38798b-1c5b-4a97-aa74-9707936283fb.png" style="width:31.42em;height:12.17em;"/>                </p>
<ul>
<li><strong>Payload</strong>: This is also a Base64-encoded string that contains claims. Claims are statements about an entity (user or group) and additional metadata. Here is a sample payload that's been returned to our service:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/63798a61-1827-4eb8-aa76-5227b85c28ae.png" style=""/></div>
<ul>
<li><strong>Signature</strong>: The signature is used to verify that the message wasn't altered along the way. In the case of tokens that have been signed with a private key, it can also assert that the sender of the JWT is who they say they are:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e81e186a-8dc6-4855-8154-1084234e507f.png" style="width:23.33em;height:25.58em;"/>             </p>
<p>The JWT token can also be provided by Keycloak, so we don't have to change our realm configuration to use it with JWT. On the other hand, we had to include the <strong>groups claim</strong> so that the JWT token will map the token subject's group memberships to the application-level roles defined in the services.</p>
<p>This information has been included in our realm (in the <span class="packt_screen">Mappers</span> section of our client configuration) through the <span class="packt_screen">Token Claim Name</span> field:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f504a1fb-2814-4c7b-87dd-f079aa810861.png" style=""/></div>
<p>Now, let's configure our service so that it can use this authentication schema.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring our service to use JWT</h1>
                </header>
            
            <article>
                
<p>Our proof of concept project can be located in the <kbd>Chapter07/jwt-demo</kbd> folder. We recommend that you import it into your IDE to compare it with the other projects in this chapter.</p>
<p>First off, we have replaced the Keycloak authorization and the OpenID extension with the <kbd>quarkus-smallrye-jwt</kbd> extension:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.quarkus<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>quarkus-smallrye-jwt<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<div class="post-text">
<p>Then, we included a different set of properties for our project. The following is the code for the <kbd>application.properties</kbd> configuration file, which targets the same Keycloak Server and provides details about the public key location and authentication mechanism:</p>
<pre><span>keycloak.url</span><span>=</span><span>http://localhost:8180<br/></span><span><br/></span><span># MP-JWT Config<br/></span><span>mp.jwt.verify.publickey.location</span><span>=</span><span>${keycloak.url}/auth/realms/quarkus-realm/protocol/openid-connect/certs<br/></span><span>mp.jwt.verify.issuer</span><span>=</span><span>${keycloak.url}/auth/realms/quarkus-realm<br/></span><span>quarkus.smallrye-jwt.realmName</span><span>=</span><span>quarkus-realm</span></pre>
<p>The following table provides a brief description of each property:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Parameter</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>
<p><kbd>mp.jwt.verify.publickey.location</kbd></p>
</td>
<td>The location where the provider's public key is stored. It can be a relative path or a URL.</td>
</tr>
<tr>
<td><kbd>mp.jwt.verify.issuer</kbd></td>
<td>Specifies the value of the <strong>iss</strong> (short for <strong>issuer</strong>) claim of the JWT that the server will accept as valid.</td>
</tr>
<tr>
<td><kbd>quarkus.smallrye-jwt.realmName</kbd></td>
<td>The security realm that's used for authentication.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now, we are ready to execute our test class using the JWT authentication mechanism.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running our test</h1>
                </header>
            
            <article>
                
<p>Our <kbd>CustomerEndpointTest</kbd> class contains the same code we used to verify the Keycloak authentication. Behind the scenes, however, it will execute the following steps:</p>
<ol>
<li>Request the access token.</li>
<li>Validate the access token fields.</li>
<li>Perform signature verification using the realm's RSA public key, which is available at the location defined in the <kbd>mp.jwt.verify.publickey.location</kbd> system property.</li>
</ol>
<p>The test can be executed with the following command:</p>
<pre><strong>$ mvn compile test</strong></pre>
<p>You should see that it completes successfully, as follows:</p>
<pre><strong>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.463 s - in com.packt.quarkus.chapter7.CustomerEndpointTest</strong><br/><strong>2019-08-24 15:37:29,879 INFO  [io.quarkus] (main) Quarkus stopped in 0.006s</strong><br/><strong>[INFO] </strong><br/><strong>[INFO] Results:</strong><br/><strong>[INFO] </strong><br/><strong>[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</strong></pre>
<p>As for pure Keycloak authentication, let's learn how to gather more information from the JWT context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting JWT claims and token information</h1>
                </header>
            
            <article>
                
<p>To manage the information contained in the JWT programmatically, we can inject the relevant API into our services. The main class, <kbd>org.<span class="pl-smi">eclipse.microprofile.jwt.JsonWebToken</span></kbd>, can be injected plainly with the following command:</p>
<pre><span>@Inject<br/></span>JsonWebToken <span>jwt</span><span>;</span></pre>
<p>This class provides methods that we can use to retrieve the token itself, its subject, and the claims contained in the token. More details can be found in the source code, which is available at <a href="https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java">https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java</a>.<a href="https://github.com/eclipse/microprofile-jwt-auth/blob/master/api/src/main/java/org/eclipse/microprofile/jwt/JsonWebToken.java"/></p>
<p>On the other hand, a shortcut for retrieving a specific claim can be done through the <kbd>@Claim</kbd> annotation, which includes its <kbd>standard</kbd> attribute and the name of the <kbd>Claim</kbd>. Use the following code to inject the groups and the username contained in the token's claim:</p>
<pre><span>@Inject<br/></span>@Claim(standard = Claims.groups)<br/>Optional&lt;JsonString&gt; <span>groups</span><span>;<br/></span><span><br/></span><span>@Inject<br/></span>@Claim(standard = Claims.preferred_username)<br/>Optional&lt;JsonString&gt; <span>currentUsername</span><span>;</span></pre>
<p class="mce-root">That was our last topic on Keycloak for this chapter. Now, let's dissect one more security topic, which is about using SSL for HTTP communication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using HTTPS with Quarkus</h1>
                </header>
            
            <article>
                
<p>The last section of this chapter is dedicated to encrypting the HTTP communication in Quarkus. In order to do that, you need to provide a valid (either self-signed or signed by a CA) Keystore or PEM certificate in your configuration.</p>
<p>First, let's learn how to generate a self-signed PEM key and certificate pair. The simplest way to do this is by using the OpenSSL tool, as follows:</p>
<pre><strong> $ openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem</strong></pre>
<p>The preceding command will generate a certificate named <kbd>cert.pem</kbd> and a related key file named <kbd>key.pem</kbd> in the current directory. Next, configure the filesystem path to your certificate and the key file in your <kbd>application.properties</kbd>:</p>
<pre><span>quarkus.http.ssl.certificate.file</span><span>=</span><span>/path/cert.pem<br/></span><span>quarkus.http.ssl.certificate.key-file</span><span>=</span><span>/path/key.pem<br/></span></pre>
<p>On the other hand, you can also generate and use a Keystore that already contains a default entry with a certificate. You can generate it using the <kbd>keytool</kbd> utility and provide a password for it:</p>
<pre><strong>$ keytool -genkey -keyalg RSA -alias quarkus -keystore keystore.jks -storepass password -validity 365 -keysize 2048</strong><br/> <br/><strong> Enter key password for &lt;quarkus&gt;</strong><br/><strong>     (RETURN if same as keystore password):</strong></pre>
<p>In our case, the only file that will be created will be <kbd>keystore.jks</kbd>; we can include it in our configuration as follows:</p>
<pre><span>quarkus.http.ssl.certificate.key-store-file=/path/keystore.jks<br/></span><span>quarkus.http.ssl.certificate.key-store-password=password</span></pre>
<p class="mce-root">Finally, we can specify the port that's used by the Undertow server to bind the HTTPS protocol:</p>
<pre><span>quarkus.http.ssl-port</span><span>=</span><span>8443</span><span><br/></span></pre>
<p>As a proof of concept, you can build and run the application contained in <kbd>Chapter07/https</kbd> to verify that it can be accessed through the SSL port:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/de4d6adf-ffc2-41b4-b073-6d458234591c.png" style=""/></div>
<p>The warning you can see in the browser's bar simply means that the SSL certificate that's being used <span class="st">isn't being issued by a trusted authority.</span></p>
<p><span class="st">In this section, we have covered the basic configuration steps that we need to follow in order to secure our application at the transport level. Now, we don't communicate with our customer service through a clear text channel; instead, we use a <strong>Secure Sockets Layer</strong> (<strong>SSL</strong>) to secure our connection.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We started this chapter by discussing the security policies that can be applied to Quarkus services. Out of the box, you can provide file-based security authentication and authorization by using the Elytron extension. Then, we took a closer look at Keycloak, which can be used to provide enterprise-grade security standards by supporting the OpenID standards. We covered a basic example using a bearer token and a more complex one using a digitally signed token, both in compliance with the JWT specification. Finally, we discovered how to generate and configure certificates to secure access to our Quarkus endpoints using HTTPS.</p>
<p>In the next chapter, we will cover some advanced tactics that can improve the untapped potential of Quarkus services!</p>


            </article>

            
        </section>
    </body></html>