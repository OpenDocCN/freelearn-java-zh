["```java\n(ns clojure-concurrency.core)\n\n(defn start-thread [func]\n  (.start (Thread. func)))\n```", "```java\njava -XX:+PrintFlagsFinal -version | grep ThreadStackSize\n\n```", "```java\n (defproject clojure-concurrency \"0.1.0-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"http://example.com/FIXME\"\n  :license {:name \"Eclipse Public License\"\n            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n            :dependencies [[org.clojure/clojure \"1.6.0\"]\n            [co.paralleluniverse/pulsar \"0.6.2\"]]\n  :java-agents [[co.paralleluniverse/quasar-core \"0.6.2\"]])\n```", "```java\n (clojure.core/use 'co.paralleluniverse.pulsar.core)\n(def p1 (promise))\n(def p2 (promise))\n(def p3 (promise))\n(spawn-fiber #(clojure.core/deliver p2 (clojure.core/+ @p1 5)))\n(spawn-fiber #(clojure.core/deliver p3 (clojure.core/+ @p1 @p2)))\n(spawn-thread #(println @p3))\n(clojure.core/deliver p1 99)\n;; 203\n```", "```java\n(def f (future (Thread/sleep 20000) \"Hello world\"))\n(println @f)\n```", "```java\n(def account (ref 20000))\n(dosync (ref-set account 10))\n(deref account)\n\n(defn test []\n  (dotimes [n 5]\n    (println n @account)\n    (Thread/sleep 2000))\n  (ref-set account 90))\n\n(future (dosync (test)))\n(Thread/sleep 1000)\n(dosync (ref-set account 5))\n```", "```java\n(def account (ref 20000))\n\n(defn test []\n  (println \"Transaction started\")\n  (dotimes [n 5]\n    (println n @account)\n    (Thread/sleep 2000))\n  (ref-set account 90))\n\n(future (dosync (test)))\n(future (dosync (Thread/sleep 4000) (ref-set account 5)))\n```", "```java\n(def account-a (ref 10000))\n(def account-b (ref 2000))\n(def started (clojure.core/promise))\n\n(defn move [acc1 acc2 amount]\n  (dosync\n    (let [balance1 @acc1\n           balance2 @acc2]\n      (println \"Transaction started\")\n      (clojure.core/deliver started true)\n      (Thread/sleep 5000)\n      (when (> balance1 amount)\n        (alter acc1 - amount)\n        (alter acc2 + amount))\n      (println \"Transaction finished\"))))\n\n(future (move account-a account-b 50))\n@started\n(dosync (ref-set account-a 20))\n```", "```java\n(alter ref fun arg1 arg2)\n```", "```java\n(ref-set ref (fun @ref arg1 arg2))\n```", "```java\n(def account (ref 1000))\n(def secured (ref false))\n(def started (promise))\n\n(defn withdraw [account amount secured]\n  (dosync\n    (let [secured-value @secured]\n      (deliver started true)\n      (Thread/sleep 5000)\n      (println :started)\n      (when-not secured-value\n        (alter account - amount))\n      (println :finished))))\n\n(future (withdraw account 500 secured))\n@started\n(dosync (ref-set secured true))\n```", "```java\n (ensure secured)\n;; instead of\n@secured\n\n(def account (ref 1000))\n(def secured (ref false))\n(def started (promise))\n\n(defn withdraw [account amount secured]\n  (dosync\n    (let [secured-value (ensure secured)]\n      (deliver started true)\n      (Thread/sleep 5000)\n      (println :started)\n      (when-not secured-value\n        (alter account - amount))\n      (println :finished))))\n\n(future (withdraw account 500 secured))\n@started\n(dosync (ref-set secured true))\n```", "```java\n(clojure.core/use 'co.paralleluniverse.pulsar.core)\n(def events (atom []))\n(defn log-events [count event-id]\n  (dotimes [_ count]\n    (swap! events conj event-id)))\n(dotimes [n 5]\n  (spawn-fiber #(log-events 500 n)))\n```", "```java\n(conj events event-id)\n```", "```java\n(count (filter #(= 0 %) @events))\n;; 500\n(count (filter #(= 1 %) @events))\n;; 500\n(count (filter #(= 2 %) @events))\n;; 500\n(count (filter #(= 3 %) @events))\n;; 500\n(count (filter #(= 4 %) @events))\n;; 500\n```", "```java\n(def agt (agent 0))\n(defn sum [& nums]\n  (Thread/sleep 5000)\n  (println :done)\n  (apply + nums))\n(send agt sum 10) ;; You can replace send with send-off\n                  ;; if you want this to be executed in a different thread\n@agt\n```", "```java\n(def v (atom 0))\n(set-validator! v #(< % 5))\n(swap! v + 10)\n\n;; IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\n```", "```java\n(swap! v + 4)\n;; 4\n```", "```java\n(def v (agent 0))\n(set-validator! v #(< % 5))\n(swap! v + 10)\n;; THERE IS NO EXCEPTION\n```", "```java\n(def v (atom 0))\n(add-watch v :sample (fn [k i old-value new-value] (println (= i v) k old-value new-value)))\n(reset! v 5)\n```", "```java\ntrue :sample 0 5\n```", "```java\n(ns test\n  (:require [clojure.core.async :refer [go]]))\n\n(go\n  (println \"Running in a goblock!\"))\n```", "```java\n (ns test\n  (:require [clojure.core.async :refer [go chan >! <!]]))\n\n(let [c (chan)]\n  (go (println (str \"The data in the channel is\" (<! c))))\n  (go (>! c 6)))\n```", "```java\n(ns test\n  (:require [clojure.core.async.lab :refer [broadcast]]\n            [clojure.core.async :refer [chan <! >!! go-loop]])\n\n(let [c1 (chan 5)\n      c2 (chan 5)\n      bc (broadcast c1 c2)]\n  (go-loop []\n    (println \"Getting from the first channel\" (<! c1))\n    (recur))\n  (go-loop []\n    (println \"Getting from the second channel\" (<! C2))\n    (recur))\n  (>!! bc 5)\n  (>!! bc 9))\n```", "```java\n(let [odd-counts (comp (map count)\n                       (filter odd?))\n      vs [[1 2 3 4 5 6]\n          [:a :c :d :e]\n          [:test]]]\n  (sequence odd-counts vs))\n```", "```java\n(let [odd-counts (comp (map count)\n                       (filter odd?))\n      input (chan)\n      output (chan 5 odd-counts)]\n  (go-loop []\n    (let [x (<! output)]\n      (println x))\n      (recur))\n  (>!! input [1 2 3 4 5 6])\n  (>!! input [:a :c :d :e])\n  (>!! input [:test]))\n```"]