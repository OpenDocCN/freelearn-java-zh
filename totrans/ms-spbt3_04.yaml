- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: 'Spring Data: SQL, NoSQL, Cache Abstraction, and Batch Processing'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data：SQL、NoSQL、缓存抽象和批处理
- en: Welcome to [*Chapter 4*](B18400_04.xhtml#_idTextAnchor146). Here, we are going
    to take a closer look at the Spring Data approach. In this chapter, we want to
    learn how the Spring Data approach can work for us. Spring Data is one of the
    key parts of the Spring Boot ecosystem. This will help you to clearly understand
    how to work with different kinds of databases in Spring Boot 3.0.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第4章*](B18400_04.xhtml#_idTextAnchor146)。在这里，我们将更深入地了解Spring Data方法。在本章中，我们想要了解Spring
    Data方法如何为我们工作。Spring Data是Spring Boot生态系统中的关键部分。这将帮助您清楚地了解如何在Spring Boot 3.0中处理不同类型的数据库。
- en: Why does this chapter matter? In software development, how we manage data is
    very important, and is more than just storing the data. This part of the book
    is not only about studying various parts of Spring Data, but it’s also about putting
    them to work in real-life situations. In this chapter, we will see how to configure
    and use Spring Data, which helps a lot in data management activities. You will
    learn how to work with structured data, stored in SQL databases, and unstructured
    data that is stored in NoSQL databases, ideal for various types of data. Furthermore,
    we will cover what cache abstraction is and why it’s good for making your app
    run faster. Another really big topic is batch processing, and how to work with
    a lot of data all at once. Further than that, you will learn important techniques
    for changing and updating your data safely.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么本章很重要？在软件开发中，我们如何管理数据非常重要，而不仅仅是存储数据。本书的这一部分不仅关于研究Spring Data的各个部分，而且还关于将它们应用于实际场景。在本章中，我们将看到如何配置和使用Spring
    Data，这对于数据管理活动非常有帮助。您将学习如何处理存储在SQL数据库中的结构化数据以及存储在NoSQL数据库中的非结构化数据，这对于各种类型的数据都是理想的。此外，我们将介绍缓存抽象是什么以及为什么它有助于使您的应用程序运行更快。另一个非常重要的主题是批处理，以及如何一次性处理大量数据。更进一步，您将学习如何安全地更改和更新数据的重要技术。
- en: Knowing how to handle data, whether it is simple or complex, is key and will
    contribute to better software programming skills. By the end of this chapter,
    you are not just going to know the theory but will be able to be hands-on in actual
    projects, applying these skills. We will use a real project, an online bookstore
    management system, to show you how things work.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何处理数据，无论是简单还是复杂，都是关键，并将有助于提高软件编程技能。在本章结束时，您不仅将了解理论，还将能够在实际项目中亲自动手，应用这些技能。我们将使用一个真实的项目，一个在线书店管理系统，向您展示事物是如何运作的。
- en: By the end of this chapter, you will have a good grasp of both the theory and
    practical use of Spring Data. This is essential for any developer, whether regarded
    as experienced or just starting out.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对Spring Data的理论和实践应用有很好的掌握。这对于任何开发者来说都是必不可少的，无论被视为经验丰富还是初出茅庐。
- en: Let’s get the ball rolling. We will see how Spring Data will help you to change
    the way you manage data in your projects. We will turn the theory into real skills
    and help you to grow as a developer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们将看到Spring Data如何帮助您改变在项目中管理数据的方式。我们将把理论转化为实际技能，并帮助您作为开发者成长。
- en: 'In this chapter, we will focus on these main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主要主题：
- en: Introduction to Spring Data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data简介
- en: Using Spring Data with SQL databases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Data与SQL数据库
- en: NoSQL databases in Spring Boot
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot中的NoSQL数据库
- en: Spring Boot cache abstraction
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot缓存抽象
- en: Spring Boot batch processing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot批处理
- en: Data migration and consistency
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据迁移和一致性
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we are going to need some installations on our local machines:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将在本地机器上需要一些安装：
- en: Docker Desktop
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: 'GitHub repository: You can clone all repositories related to [*Chapter 4*](B18400_04.xhtml#_idTextAnchor146)
    here: [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub仓库：您可以在以下位置克隆与[*第4章*](B18400_04.xhtml#_idTextAnchor146)相关的所有仓库：[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/)
- en: 'Here are the steps to install Docker Desktop:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是安装Docker Desktop的步骤：
- en: 'Visit the Docker Desktop website: [https://docs.docker.com/desktop/](https://docs.docker.com/desktop/)'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Docker Desktop网站：[https://docs.docker.com/desktop/](https://docs.docker.com/desktop/)
- en: Follow the instructions under the **Install Docker Desktop** menu. It’s available
    for various operating systems and provides a straightforward installation process.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照**安装Docker Desktop**菜单下的说明操作。它适用于各种操作系统，并提供了一个简单的安装过程。
- en: Introduction to Spring Data
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data简介
- en: In this section, we will look at the general fundamental concepts of Spring
    Data and how they are useful. We will also examine their application in our case
    study project, the online bookstore management system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Spring Data的一般基本概念及其用途。我们还将检查它们在我们案例研究项目——在线书店管理系统中的应用。
- en: '**Spring Data** is a part of the Spring Framework that can simplify interaction
    with data in our application as much as possible. Its main advantage and greatest
    strength is the ability to simplify database operations. This means you can perform
    tasks such as querying a database or updating records with less code and complexity.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Data**是Spring框架的一部分，它可以尽可能简化我们应用程序与数据的交互。其主要优点和最大优势是简化数据库操作的能力。这意味着您可以用更少的代码和复杂性执行查询数据库或更新记录等任务。'
- en: Understanding Spring Data will build your skills in dealing with data effectively
    – one of the key factors of software development. Whether it is a small application
    or a complex enterprise system, effective role-based access on the data layer
    plays an impactful role in better performance and maintenance of the whole system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Spring Data将有助于您在有效处理数据方面提升技能——这是软件开发的关键因素之一。无论是小型应用程序还是复杂的企业系统，在数据层上实施有效的基于角色的访问对整个系统的性能和维护都起着重要作用。
- en: In this chapter, we will display the main characteristics of Spring Data and
    how it can help you to simplify your work. Knowing about these concepts will help
    you manage data in your software projects, thus making the development process
    an easier one and expediting its flow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示Spring Data的主要特性以及它如何帮助您简化工作。了解这些概念将帮助您在软件项目中管理数据，从而使开发过程更加容易，并加快其流程。
- en: So, let’s embark on this interesting journey with Spring Data. It is going to
    be a practical and informative ride, and by the end of it, you will surely be
    well-equipped to manage data in your own applications using Spring Data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们带着Spring Data踏上这段有趣的旅程。这将是一次实用且富有信息性的旅程，到结束时，您将肯定能够熟练地使用Spring Data来管理自己的应用程序中的数据。
- en: Understanding the fundamentals and benefits of Spring Data
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Spring Data的基本知识和好处
- en: In this section, we’ll focus on the basics of Spring Data. We are first going
    to learn about its core concepts and benefits that are critical to every developer.
    From there, we will step into setting up a Spring Boot project and defining some
    key JPA entities. By taking little steps like these, we will graduate to having
    a solid foundation in Spring Data, which will render further applications more
    advanced.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注Spring Data的基础知识。我们首先将了解其核心概念和每个开发者都至关重要的好处。从那里，我们将进入设置Spring Boot项目并定义一些关键的JPA实体。通过采取这些小步骤，我们将逐步建立起Spring
    Data的坚实基础，这将使后续的应用程序更加高级。
- en: We’ll start with what makes Spring Data a powerful tool in the Spring Boot ecosystem
    and why it could be beneficial for your projects as well. We’ll then continue
    to the practical parts of setting up your project and going deeper into the world
    of **Java Persistence API** (**JPA**) entities.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Spring Data在Spring Boot生态系统中的强大工具以及它为何对您的项目有益开始。然后，我们将继续探讨设置项目并深入了解Java持久化API（**JPA**）实体的实际部分。
- en: Before diving into the technical setup, let’s first understand the core principles
    and advantages of using Spring Data in our projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入技术设置之前，让我们首先了解在项目中使用Spring Data的核心原则和优势。
- en: Exploring the core concepts of Spring Data
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索Spring Data的核心概念
- en: 'Spring Data is designed to simplify interaction with databases in Java applications.
    Here are some of its fundamental concepts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data旨在简化Java应用程序与数据库的交互。以下是其一些基本概念：
- en: '**Data access simplified**: Spring Data reduces the complexity of data access
    operations. You no longer need to write boilerplate code for common database interactions.
    We will see how to perform **Create, Read, Update, and Delete** (**CRUD**) operations
    without writing a single line of code. This will make our code more readable and
    manageable.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问简化**：Spring Data简化了数据访问操作。您不再需要为常见的数据库交互编写样板代码。我们将看到如何在不编写任何代码的情况下执行**创建、读取、更新和删除**（**CRUD**）操作。这将使我们的代码更易于阅读和管理。'
- en: '**Repository abstraction**: One of the key features of Spring Data is its repository
    abstraction. This helps us to use database operations like a function in our framework.
    If we don’t know how to write a query in a specific database, we don’t need to
    worry. This abstraction makes it work the same for all supported databases. It
    abstracts the data layer, meaning you can focus more on your business logic rather
    than database intricacies.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库抽象**：Spring Data 的一个关键特性是其仓库抽象。这使我们能够将数据库操作像函数一样在我们的框架中使用。如果我们不知道如何在特定数据库中编写查询，我们不需要担心。这种抽象使得它对所有支持的数据库都一样工作。它抽象了数据层，这意味着你可以更多地关注业务逻辑，而不是数据库的复杂性。'
- en: '**Support for multiple database types**: Spring Data supports a wide range
    of database types, including both SQL and NoSQL options. This versatility makes
    it a valuable tool for projects that may require different database technologies.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持多种数据库类型**：Spring Data 支持广泛的数据库类型，包括 SQL 和 NoSQL 选项。这种多功能性使其成为可能需要不同数据库技术的项目的宝贵工具。'
- en: Benefits of using Spring Data
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Spring Data 的好处
- en: 'Now, let’s look at why Spring Data is beneficial for your development process:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看为什么 Spring Data 对你的开发过程有益：
- en: '**Increased efficiency and productivity**: Spring Data not only reduces the
    boilerplate coding for database operations but also performs these operations
    in a best-practice, efficient way. In old structures, we often dealt with connection
    issues that were not closed. Spring Data manages all connection pool issues effectively.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高效率和生产力**：Spring Data 不仅减少了数据库操作中的样板代码，而且以最佳实践和高效的方式执行这些操作。在旧结构中，我们经常处理未关闭的连接问题。Spring
    Data 有效地管理所有连接池问题。'
- en: '**Easy to learn and use**: Spring Data is designed to be user-friendly. Just
    a few pages later, you will understand what I mean. Developers can quickly learn
    how to use it and start using it in their projects. Its integration with the Spring
    ecosystem also means that it works seamlessly with other Spring technologies.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于学习和使用**：Spring Data 被设计成用户友好。只需翻几页，你就会明白我的意思。开发者可以快速学习如何使用它，并将其应用到他们的项目中。它与
    Spring 生态系统的集成也意味着它可以与其他 Spring 技术无缝工作。'
- en: '**Enhanced code quality and maintainability**: With less code clutter and a
    cleaner approach to data handling, Spring Data enhances the overall quality of
    your code. It makes your applications easier to maintain and update in the long
    run.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码质量和可维护性**：通过减少代码冗余和更干净的数据处理方法，Spring Data 提升了代码的整体质量。这使得你的应用程序在长期内更容易维护和更新。'
- en: You will understand these benefits and concepts better as we progress through
    the setup and usage of our Spring Boot application. Now that we have basic knowledge
    of what Spring Data is and why it’s advantageous, let’s move forward with setting
    up our project and defining our JPA entities.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们逐步完成 Spring Boot 应用程序的设置和使用，你会更好地理解这些优势和概念。现在，我们已经对 Spring Data 是什么以及为什么它有优势有了基本了解，让我们继续设置我们的项目并定义我们的
    JPA 实体。
- en: Setting up your Spring Boot project
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置你的 Spring Boot 项目
- en: First things first, let’s set up a Spring Boot project. This is your starting
    point for any Spring application. You can follow the same steps as in [*Chapter
    3*](B18400_03.xhtml#_idTextAnchor064). Or you can directly clone the Git repository
    provided in the *Technical* *requirements* section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个 Spring Boot 项目。这是任何 Spring 应用程序的起点。你可以遵循与 [*第 3 章*](B18400_03.xhtml#_idTextAnchor064)
    中相同的步骤。或者，你可以直接克隆 *技术要求* 部分提供的 Git 仓库。
- en: 'These are the basic dependencies you need while creating the application:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建应用程序时，你需要以下基本依赖项：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The library, called Lombok, is commonly used to eliminate boilerplate code like
    the `getId` and `setId` methods.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为 Lombok 的库通常用于消除像 `getId` 和 `setId` 方法这样的样板代码。
- en: With these steps, you have your Spring Boot project ready. Now, let’s define
    some JPA entities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，你的 Spring Boot 项目就准备好了。现在，让我们定义一些 JPA 实体。
- en: 'Defining JPA entities: Book, Author, and Publisher'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 JPA 实体：书籍、作者和出版社
- en: 'In a bookstore application, we deal with books, authors, and publishers. Let’s
    define them as JPA entities. We will create three classes as follows. You can
    see them in the repository under the `model` package:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个书店应用程序中，我们处理书籍、作者和出版社。让我们将它们定义为 JPA 实体。我们将创建以下三个类。你可以在 `model` 包下的仓库中看到它们：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of the `Book`, `Author`, and `Publisher` entities represents a crucial
    part of our bookstore system. By using the `@Data` annotation, we simplify our
    code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Book`、`Author` 和 `Publisher` 实体都代表了我们书店系统的一个关键部分。通过使用 `@Data` 注解，我们简化了我们的代码。
- en: Understanding the role of repositories in Spring Data
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Spring Data 中仓库的作用
- en: After defining our entities, we need to create repositories. **Repositories**
    in Spring Data help us to interact with the database easily.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义我们的实体之后，我们需要创建仓库。Spring Data 中的**仓库**帮助我们轻松地与数据库交互。
- en: In order to create a repository for each entity (`Book`, `Author`, `Publisher`),
    create an interface that extends `JpaRepository`. This interface provides methods
    for common database operations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为每个实体（`Book`、`Author`、`Publisher`）创建一个仓库，创建一个扩展 `JpaRepository` 的接口。此接口提供了常见数据库操作的方法。
- en: 'For `Book`, it might look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Book`，它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These repositories provide some generic methods for saving, finding, deleting,
    and updating entities. For instance, to find all books, you can use `bookRepository.findAll()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仓库提供了一些通用的方法来保存、查找、删除和更新实体。例如，要查找所有书籍，你可以使用 `bookRepository.findAll()`。
- en: This setup will be the base for our building in the upcoming Spring Boot application.
    By now, you should have a basic project ready with entities and repositories.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置将成为我们即将构建的 Spring Boot 应用程序的基础。到目前为止，你应该有一个包含实体和仓库的基本项目准备就绪。
- en: Now, we have a Spring Boot project set up with Spring Data dependencies, and
    we’ve defined essential JPA entities and repositories. This is the foundation
    of our work with Spring Data. We have not connected to a database yet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了一个带有 Spring Data 依赖项的 Spring Boot 项目，并定义了基本的 JPA 实体和仓库。这是我们使用 Spring
    Data 的工作基础。我们尚未连接到数据库。
- en: In the next section, we’ll delve into how to use Spring Data with SQL databases.
    We will look at an easy and effective way to use Spring Data in our project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨如何使用 Spring Data 与 SQL 数据库。我们将查看在项目中使用 Spring Data 的简单有效的方法。
- en: Using Spring Data with SQL databases
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Data 与 SQL 数据库
- en: As a developer who deals with Spring Data, it’s important to understand its
    relationship with SQL databases. **SQL databases** are known for their structured
    approach to data management. They are widely used in various applications. We
    are going to use them in our online bookstore management system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理 Spring Data 的开发者来说，了解其与 SQL 数据库的关系非常重要。**SQL 数据库**以其对数据管理的结构化方法而闻名。它们在各种应用程序中得到广泛应用。我们将在我们的在线书店管理系统中使用它们。
- en: In this section, we’ll explore how Spring Data JPA interfaces with SQL databases,
    focusing on PostgreSQL configuration and the creation of complex entity relationships.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Spring Data JPA 如何与 SQL 数据库接口，重点关注 PostgreSQL 配置和复杂实体关系的创建。
- en: Integrating PostgreSQL with Spring Boot using Docker
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker 将 PostgreSQL 集成到 Spring Boot 中
- en: First off, we need to have an up-and-running PostgreSQL server on our local
    machine. The easiest way of doing this is using Docker containers. **Docker**
    is a tool that simplifies the setup and deployment of applications and their dependencies.
    Let’s go through how you can set up PostgreSQL using Docker and configure your
    Spring Boot application to connect to it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的本地机器上有一个运行中的 PostgreSQL 服务器。最简单的方法是使用 Docker 容器。**Docker** 是一个简化应用程序及其依赖项设置和部署的工具。让我们看看如何使用
    Docker 设置 PostgreSQL 并配置你的 Spring Boot 应用程序以连接到它。
- en: Setting up PostgreSQL with Docker
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Docker 设置 PostgreSQL
- en: Using Docker, you can easily install and run a PostgreSQL database. This method
    offers a consistent and isolated environment for your database, regardless of
    your local setup.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker，你可以轻松地安装和运行 PostgreSQL 数据库。这种方法为你的数据库提供了一个一致且隔离的环境，无论你的本地设置如何。
- en: 'You already installed Docker Desktop as instructed in the *Technical requirements*
    section. We will use a `Docker Compose` file, which can also be found in the root
    folder of the GitHub repository. Here’s a basic example using a `Docker` `Compose`
    file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经按照 *技术要求* 部分的说明安装了 Docker Desktop。我们将使用一个 `Docker Compose` 文件，该文件也可以在 GitHub
    仓库的根目录中找到。以下是一个使用 `Docker` `Compose` 文件的示例：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will set up a PostgreSQL server with the database named `bookstore`. Replace
    `yourpassword` with a secure password of your choice. Save this file as `docker-compose.yml`
    in the root source folder.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个名为 `bookstore` 的数据库的 PostgreSQL 服务器。将 `yourpassword` 替换为你选择的密码。将此文件保存为
    `docker-compose.yml` 在根源文件夹中。
- en: Run the `docker-compose up` command in the directory where your `docker-compose.yml`
    file is located. This command will download the PostgreSQL image and start the
    database server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `docker-compose.yml` 文件所在的目录中运行 `docker-compose up` 命令。此命令将下载 PostgreSQL
    镜像并启动数据库服务器。
- en: Configuring Spring Boot to connect to PostgreSQL
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Spring Boot 以连接到 PostgreSQL
- en: 'Now that PostgreSQL is running in a Docker container, let’s configure our Spring
    Boot application to connect to it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 PostgreSQL 在 Docker 容器中运行，让我们配置我们的 Spring Boot 应用程序以连接到它：
- en: 'Update `application.properties`: Open the `application.properties` file in
    your Spring Boot project. Add the following properties to configure the connection
    to the PostgreSQL server:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`application.properties`：打开您的 Spring Boot 项目中的`application.properties`文件。添加以下属性以配置到
    PostgreSQL 服务器的连接：
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make sure to replace `yourpassword` with the password you set in the `Docker
    Compose` file. The `spring.jpa.hibernate.ddl-auto=update` property helps manage
    the database schema based on your entity classes.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将`yourpassword`替换为您在`Docker Compose`文件中设置的密码。`spring.jpa.hibernate.ddl-auto=update`属性有助于根据您的实体类管理数据库模式。
- en: 'Verifying the connection: Run your Spring Boot application. At this stage,
    we can only see whether the app starts up properly or not. In the *Implementing
    practical CRUD operations in the online bookstore* section, we will introduce
    the REST controller to verify that it connects to the PostgreSQL database successfully.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证连接：运行您的 Spring Boot 应用程序。在这个阶段，我们只能看到应用程序是否能够正确启动。在*在线书店实现实际 CRUD 操作*部分，我们将介绍
    REST 控制器以验证它是否成功连接到 PostgreSQL 数据库。
- en: With these steps, you have successfully integrated a PostgreSQL database into
    your Spring Boot application using Docker. This setup not only simplifies the
    initial configuration but also ensures a consistent database environment for development
    and testing. Now, we will go one step ahead and introduce the advanced entity
    relationships between the objects in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，您已成功将 PostgreSQL 数据库集成到您的 Spring Boot 应用程序中，使用 Docker。这种设置不仅简化了初始配置，还确保了开发和测试环境中数据库的一致性。现在，我们将更进一步，在下一节介绍对象之间的高级实体关系。
- en: Developing complex relationships between entities
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发实体之间的复杂关系
- en: 'In this section, we’ll focus on developing complex relationships between our
    entities: `Book`, `Author`, and `Publisher`. We’ll use Spring Data’s annotation-driven
    approach to link these entities, reflecting real-world connections in our database
    design.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于开发我们实体之间的复杂关系：`Book`、`Author`和`Publisher`。我们将使用 Spring Data 的注解驱动方法来链接这些实体，反映我们数据库设计中的现实世界联系。
- en: In our bookstore application, we created basic objects. Now, we are going to
    connect them to each other. Let’s start with the `Books` to `Authors` connection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的书店应用程序中，我们创建了基本对象。现在，我们将把它们连接起来。让我们从`书籍`到`作者`的连接开始。
- en: Each book can have one or more authors, forming a many-to-many relationship.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每本书可以有一个或多个作者，形成一个多对多关系。
- en: 'Here’s how we can represent this in our `Book` record:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`Book`记录中表示它的方法：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `@ManyToMany` annotation indicates that each book can be associated with
    multiple authors. This relationship is bidirectional, meaning authors can also
    be linked to multiple books. In a many-to-many relationship, you need a new cross
    table to link these tables. This is a part of database design, so we will mention
    this feature so as not to surprise you when you view your tables in the database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ManyToMany`注解表示每本书可以与多个作者相关联。这种关系是双向的，这意味着作者也可以与多本书相关联。在多对多关系中，你需要一个新的交叉表来链接这些表。这是数据库设计的一部分，因此我们将提及此功能，以免您在查看数据库中的表时感到惊讶。'
- en: 'Now, we are going to link `Authors` to `Publisher`. An author may be associated
    with a publisher. This is a many-to-one relationship, as multiple authors can
    be published by the same publisher:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把`作者`与`出版社`关联起来。一个作者可能关联到一个出版社。这是一个多对一的关系，因为多个作者可以被同一个出版社出版：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `@ManyToOne` annotation here signifies that each author is linked to one
    publisher, while a publisher can have multiple authors.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`@ManyToOne`注解表示每个作者都与一个出版社相关联，而一个出版社可以有多个作者。
- en: The `Publisher` entity remains simple as it does not need to establish a new
    relationship in this context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`出版社`实体保持简单，因为它在此上下文中不需要建立新的关系。'
- en: 'In *Figure 4**.1*, we can see the tables and the relationships between them:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4**.1*中，我们可以看到表及其之间的关系：
- en: '![Figure 4.1 – Database diagram of the tables](img/B18400_04_01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 表的数据库图](img/B18400_04_01.jpg)'
- en: Figure 4.1 – Database diagram of the tables
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 表的数据库图
- en: The tables you can see in the diagram were generated by the Spring Data library
    when we started the application. You can see there is one extra table called `books_authors`.
    This table is for a many-to-many relationship between the `books` and `authors`
    tables.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中您可以看到的表是在我们启动应用程序时由 Spring Data 库生成的。您可以看到有一个额外的表叫做 `books_authors`。这个表用于
    `books` 和 `authors` 表之间的多对多关系。
- en: With this implementation, we have applied a real-world connection between books,
    authors, and publishers in our application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现，我们在应用程序中应用了书籍、作者和出版社之间的现实世界联系。
- en: As we conclude this section on entity relationships, we have defined complex
    data structures in our online bookstore management system. Next, we will see how
    these relationships work in practical scenarios.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结本节关于实体关系的内容时，我们在在线书店管理系统中定义了复杂的数据结构。接下来，我们将看到这些关系在实际场景中的工作方式。
- en: Implementing practical CRUD operations in the online bookstore
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在在线书店中实现实用的 CRUD 操作
- en: With our complex entity relationships established, let’s see how these are practically
    implemented in the online bookstore management system. We’ll introduce **create,
    read, update, delete** (**CRUD**) operations through REST endpoints, demonstrating
    how the controllers interact with the PostgreSQL database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们建立了复杂的实体关系后，让我们看看这些关系如何在在线书店管理系统中实际实现。我们将通过 REST 端点介绍 **创建、读取、更新、删除** （**CRUD**）操作，展示控制器如何与
    PostgreSQL 数据库交互。
- en: First, we will create controller classes. Let’s go over the `book` object. You
    can make similar changes for both the `Author` and `Publisher` objects. Or, you
    can check the GitHub repository ([https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-4-1-intorduction-spring-data/src/main/java/com/packt/ahmeric/bookstore/data](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-4-1-intorduction-spring-data/src/main/java/com/packt/ahmeric/bookstore/data))
    for the latest implementation for all three objects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建控制器类。让我们回顾一下 `book` 对象。您可以对 `Author` 和 `Publisher` 对象进行类似的修改。或者，您可以查看
    GitHub 仓库 ([https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-4-1-intorduction-spring-data/src/main/java/com/packt/ahmeric/bookstore/data](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-4-1-intorduction-spring-data/src/main/java/com/packt/ahmeric/bookstore/data))
    以获取所有三个对象的最新实现。
- en: Developing CRUD endpoints
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发 CRUD 端点
- en: 'Now, we will get our hands dirty to make these objects reachable from outside.
    First off, we need a `Repository` class to manage the entities. This is a basic
    repository class for `book` objects:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将动手操作，使这些对象可以从外部访问。首先，我们需要一个 `Repository` 类来管理实体。这是一个用于 `book` 对象的基本仓库类：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This one, single-line class will help us to use so many common methods, such
    as `findAll()`, `save(book)`, and `findById(id)`. This is the power of Spring
    Data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行类将帮助我们使用许多常用方法，例如 `findAll()`、`save(book)` 和 `findById(id)`。这就是 Spring Data
    的力量。
- en: In order to create a controller class for the `book` object, we introduce the
    `BookController` class to handle requests related to books. This controller will
    manage operations such as adding a new book, retrieving book details, updating
    book information, and deleting a book.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个处理与书籍相关的请求的控制器类，我们引入了 `BookController` 类来处理书籍相关的操作。这个控制器将管理添加新书、检索书籍详情、更新书籍信息和删除书籍等操作。
- en: 'So, let’s introduce a new class named `BookController`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们引入一个新的类名为 `BookController`：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this simple class, you can see new annotations above the class name – `@RestController`
    and `@RequestMapping`. As you’ll remember, we used them in [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064).
    But there is a new annotation here: `@RequiredArgsConstructor`. This annotation
    belongs to Lombok as well. This will create a constructor at compile time, so
    we have a clear class without boilerplate code lines.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的类中，您可以看到类名上方的新注解 – `@RestController` 和 `@RequestMapping`。如您所记，我们在 [*第
    3 章*](B18400_03.xhtml#_idTextAnchor064) 中使用过它们。但这里有一个新的注解：`@RequiredArgsConstructor`。这个注解也属于
    Lombok。这个注解将在编译时创建一个构造函数，因此我们有一个没有样板代码行的清晰类。
- en: In this sample code, we have two endpoints for creating a book and getting a
    book by ID. These are REST endpoints that accept and return JSON data. And you
    can see we are using default methods from `bookRepository`, such as `findById()`
    and `save()`. We haven’t written them in our `Repository` class. They came from
    the `JpaRepository` extension. The Spring Data JPA repositories, coupled with
    Hibernate, efficiently manage the underlying SQL queries and transactions, abstracting
    the complexities and ensuring smooth data handling. So, we don’t even write a
    single line of code to save an entity in the database. We only use the `save()`
    method instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码中，我们有两个端点用于创建书籍和通过ID获取书籍。这些是接受和返回JSON数据的REST端点。您可以看到我们正在使用来自`bookRepository`的默认方法，例如`findById()`和`save()`。我们并没有在我们的`Repository`类中编写它们。它们来自`JpaRepository`扩展。Spring
    Data JPA仓库与Hibernate结合，有效地管理底层的SQL查询和事务，抽象复杂性并确保数据处理的顺畅。因此，我们甚至不需要写一行代码来在数据库中保存实体。我们只使用`save()`方法。
- en: You can see other endpoints for deleting and finding all updates in the GitHub
    repository. If you want, you can create `AuthorController` and `PublisherController`
    similarly for managing authors and publishers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库中看到其他用于删除和查找所有更新的端点。如果您愿意，可以类似地创建`AuthorController`和`PublisherController`来管理作者和出版商。
- en: As we introduced the relationship between the tables, when we add a book with
    its authors, the `books_authors` table will be updated accordingly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们介绍的表之间的关系，当我们添加带有其作者的书籍时，`books_authors`表将相应更新。
- en: Let’s do some curl requests to see how it works.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一些curl请求来查看它是如何工作的。
- en: Using curl requests for a practical run-through
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用curl请求进行实际操作演练
- en: 'Run the Spring Boot application with this command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行Spring Boot应用程序：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we will run the following requests in order:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按顺序运行以下请求：
- en: 'Create a publisher:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建出版商：
- en: '[PRE10]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the response:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是响应：
- en: '[PRE11]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create an author:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建作者：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a book:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建书籍：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we have used the `id` of the linked object. For example, when
    we created an author, we linked the author with a publisher with ID 1.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了链接对象的`id`。例如，当我们创建一个作者时，我们使用ID为1的出版商将作者链接起来。
- en: In this practical implementation phase, we have established how to create functional
    endpoints within our controllers to manage books, authors, and publishers within
    the online bookstore. These endpoints interact seamlessly with the PostgreSQL
    database, showing us how powerful and effective it is to use Spring Data within
    a real application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实际实施阶段，我们已经建立了如何在我们的控制器中创建功能端点来管理在线书店中的书籍、作者和出版商。这些端点与PostgreSQL数据库无缝交互，展示了在真实应用程序中使用Spring
    Data的强大和高效。
- en: With this section under our belts, we’re ready to learn about the next step
    in our journey – integrating NoSQL databases with Spring Boot and further extending
    its data management capabilities.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握这一部分内容后，我们准备好学习我们旅程的下一步——将NoSQL数据库集成到Spring Boot中，并进一步扩展其数据管理功能。
- en: NoSQL databases in Spring Boot
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot中的NoSQL数据库
- en: Having studied structured SQL databases, we will now delve into NoSQL databases.
    We will see how they are more flexible than SQL databases. In this section, we
    will see how easy it is to implement NoSQL databases within Spring Boot 3.0\.
    We will implement this database connection in our bookstore management system
    application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究了结构化SQL数据库之后，我们现在将深入研究NoSQL数据库。我们将看到它们比SQL数据库更加灵活。在本节中，我们将看到在Spring Boot
    3.0中实现NoSQL数据库是多么容易。我们将在我们的书店管理系统应用程序中实现这个数据库连接。
- en: Exploring the integration of NoSQL databases in Spring Boot
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Spring Boot中NoSQL数据库的集成
- en: At this point in our Spring Boot journey, we’ll shift gears and look at the
    integration of NoSQL databases, which are an essential part of a modern application
    stack. Unlike traditional SQL databases, **NoSQL databases** such as MongoDB offer
    a different style of managing data, thus their suitability in this case. Here,
    we’ll gain in the context of Spring Boot not just an understanding of these benefits
    but also learn how to effectively implement them in real-world applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Spring Boot之旅的这个阶段，我们将转换方向，研究NoSQL数据库的集成，这是现代应用程序堆栈的一个基本组成部分。与传统的SQL数据库不同，**NoSQL数据库**如MongoDB提供了一种不同的数据管理风格，因此它们适用于这种情况。在这里，我们将不仅了解这些好处，而且还将学习如何在现实世界的应用程序中有效地实现它们。
- en: NoSQL databases shine for being able to flexibly take care of different data
    types, mostly unstructured or semi-structured. This flexibility gives a great
    advantage to developers who are facing diverse data requirements or even an ever-changing
    data structure. In the world of NoSQL, MongoDB is distinguished as document-oriented,
    which makes it one of the best data storage options for applications that demand
    a scalable and agile data storage platform.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库因其能够灵活处理不同数据类型而备受赞誉，这些数据类型大多是未结构化或半结构化的。这种灵活性为面临多样化数据需求或甚至不断变化的数据结构的开发者提供了巨大的优势。在
    NoSQL 的世界中，MongoDB 被视为面向文档的，这使得它成为需要可扩展和敏捷数据存储平台的应用程序的最佳数据存储选项之一。
- en: With regard to the integration of NoSQL databases with Spring Boot, the whole
    process is simplified and very easy to accomplish. The way in which Spring Boot
    integrates well with NoSQL databases such as MongoDB literally allows developers
    to plug it into their applications without annoying configurations. This integration
    opens a new world of application development, the prospects of which revolve around
    the potential to build more dynamic, scalable, and efficient applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将 NoSQL 数据库与 Spring Boot 集成的过程，整个过程得到了简化，并且非常容易完成。Spring Boot 与 MongoDB 等NoSQL数据库的良好集成方式实际上允许开发者将其直接插入到他们的应用程序中，而无需进行烦人的配置。这种集成开辟了应用程序开发的新天地，其前景围绕着构建更动态、可扩展和高效应用程序的潜力。
- en: The best thing about that synergy is using NoSQL databases in Spring Boot. The
    philosophy of Spring Boot is to simplify the development of an application, which
    complements NoSQL’s nature, coming with scalability and flexibility. This combination
    is particularly potent for the development of applications that do not only involve
    dealing with complex data structures but must be adaptable to changing demands
    for data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那种协同效应的最好之处在于在 Spring Boot 中使用 NoSQL 数据库。Spring Boot 的哲学是简化应用程序的开发，这与 NoSQL
    的本质相辅相成，带来了可扩展性和灵活性。这种组合对于开发不仅涉及处理复杂数据结构，而且必须适应数据需求变化的应用程序尤其有效。
- en: In the context of our online bookstore management system, integrating a NoSQL
    database such as MongoDB won’t just add a great deal of value to the capabilities
    of the application but will also present a practical example of how these state-of-the-art
    families of technologies can be brought together. We can use MongoDB to integrate
    functions such as user reviews or even personalized recommendations that leverage
    the flexible data modeling that is powered by NoSQL databases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的在线书店管理系统背景下，集成如 MongoDB 这样的 NoSQL 数据库不仅将为应用程序的功能增加大量价值，还将展示如何将这些最先进的技术家族结合起来的实际例子。我们可以使用
    MongoDB 来集成用户评论或个性化推荐等功能，这些功能利用了由 NoSQL 数据库提供的灵活的数据建模。
- en: When we delve into how to integrate NoSQL databases into Spring Boot, we not
    only have yet another tool at our disposal but learn a lot more about the workings
    of various kinds of databases so that we can develop applications that are stronger,
    more flexible, and perform faster. This knowledge is priceless in a landscape
    where the capability to adapt and evolve with modern technological advances remains
    among the key factors of success. In the next sections, we will implement MongoDB
    in our project step by step.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究如何将 NoSQL 数据库集成到 Spring Boot 中时，我们不仅又获得了一个可用的工具，而且对各种数据库的工作原理有了更多的了解，这样我们就可以开发出更强大、更灵活且性能更快的应用程序。在这个适应和随着现代技术进步而发展的能力仍然是成功关键因素之一的领域中，这种知识是无价的。在接下来的章节中，我们将逐步在我们的项目中实现
    MongoDB。
- en: Setting up and configuring MongoDB
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和配置 MongoDB
- en: We need to run a MongoDB on our local machine as we did for PostgreSQL in the
    previous section. Similar to PostgreSQL, MongoDB can be set up in a Docker container,
    ensuring an isolated and consistent database environment.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在本地机器上运行 MongoDB，就像在上一节中为 PostgreSQL 所做的那样。与 PostgreSQL 类似，MongoDB 可以在 Docker
    容器中设置，确保数据库环境独立且一致。
- en: 'You can see an enhanced version of our `docker-compose.yml` file here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处看到我们 `docker-compose.yml` 文件的增强版本：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can also find the same file in the GitHub repository. You can run the `docker-compose
    up` command to run both MongoDB and PostgreSQL at the same time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 GitHub 仓库中找到相同的文件。您可以通过运行 `docker-compose up` 命令同时运行 MongoDB 和 PostgreSQL。
- en: After running a MongoDB instance, we need to update the `application.properties`
    file in our resources folder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 MongoDB 实例后，我们需要更新我们资源文件夹中的 `application.properties` 文件。
- en: 'This single configuration line will create a connection between the Spring
    Boot app and MongoDB:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this simple configuration update, we are ready to connect MongoDB to our
    local machine. In the next section, we will introduce a new object and see how
    our app works with MongoDB.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Building the Review object and its repository
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did for the `Book`, `Author`, and `Publisher` objects, we need to introduce
    a new object called `Review.class`. You can also check it out in the GitHub repository,
    under the `data` package:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see the difference from other data objects. There is a new annotation
    here called `@Document`. This annotation refers to the collection of this object.
    So, whatever we put in this object will be written under the `reviews` collection.
    We have just introduced some basic fields a review might need.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, we also need a repository to manage this document in MongoDB. Let’s
    introduce the `ReviewRepository` class under the `repositories` package:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s it! Now, we can manage the data wherever we want. We are extending from
    `MongoRepository` instead of JPA repository interfaces. This is the only difference
    between `BookRepository` and `AuthorRepository`. So, now we have all CRUD functions
    such as `findById()` and `save()`. Also, this can be customized for more complex
    business requirements. We can start implementing the controller for the `Review`
    object in the next section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a hybrid data model in the online bookstore
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our project has now evolved into a hybrid model, integrating both SQL (PostgreSQL)
    and NoSQL (MongoDB) databases. So, let’s expose the `review` object to the REST
    world so we can create and read the reviews in MongoDB.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new controller class in the controller package:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, there is no difference between the `BookController` and `ReviewController`
    classes, because we have isolated the database layer from the repository level.
    These two endpoints expose `GET` `review` and `POST` `review` endpoints. You can
    introduce the rest of the CRUD endpoints or you can check out the GitHub repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do some `curl` requests to see how it works:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The response will be as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `id` of the record is generated by the `@Id` annotation in the `Review`
    class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is how it looks in MongoDB:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – MongoDB data view](img/B18400_04_02.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – MongoDB data view
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we can see how MongoDB tags our object in the `_class` attribute.
    This exploration of NoSQL databases, with a focus on MongoDB, in a Spring Boot
    context has broadened our understanding of managing diverse data types in modern
    applications. By implementing MongoDB in the online bookstore management system,
    we have not only enriched the application with new features but also embraced
    the advantages of a hybrid database approach.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this section, our journey through the data landscape of Spring
    Boot continues. Next, we delve into cache abstraction in Spring Boot, where we
    will explore strategies to optimize application performance. This progression
    from NoSQL databases to caching techniques exemplifies the comprehensive nature
    of data management in Spring Boot applications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结本节内容时，我们通过 Spring Boot 的数据景观之旅仍在继续。接下来，我们将深入研究 Spring Boot 中的缓存抽象，我们将探讨优化应用程序性能的策略。从
    NoSQL 数据库到缓存技术这一进展，体现了 Spring Boot 应用程序中数据管理的全面性。
- en: Spring Boot cache abstraction
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 缓存抽象
- en: In this section, we will delve into cache abstraction in Spring Boot. This is
    one of the significant facilitating components for maximizing your application’s
    performance. We’ll see what cache abstraction is, how to do its setup, and finally,
    how to use it in our application. We will show this using our online bookstore
    management system.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究 Spring Boot 中的缓存抽象。这是最大化应用程序性能的重要辅助组件之一。我们将了解缓存抽象是什么，如何进行其设置，以及最后如何在我们的应用程序中使用它。我们将使用我们的在线书店管理系统来展示这一点。
- en: Your application will gain from cache abstraction since it sits on top of your
    caching system, remembering the information that is used repeatedly, giving your
    application a faster execution speed. It is similar to placing your frequently
    used tools on top of your desk so you don’t search for them every time. This comes
    with a time gain since your application doesn’t have to keep fetching this information
    over and over again from slow sources such as databases.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓存抽象位于您的缓存系统之上，它能够记住重复使用的信息，从而提高应用程序的执行速度。这就像把您常用的工具放在桌子上一样，这样您就不必每次都去寻找它们。这带来了时间上的节省，因为您的应用程序不必反复从数据库等慢速来源中获取这些信息。
- en: Let us now see how to add cache abstraction to your Spring Boot application,
    which will make your app run more smoothly. In the above context, caching is what
    can be used to quickly display book details or user reviews that are not changed
    frequently.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将缓存抽象添加到您的 Spring Boot 应用程序中，这将使您的应用程序运行更加顺畅。在上面的上下文中，缓存是可以用来快速显示不经常更改的书籍详情或用户评论的。
- en: By the end of this part, you will know how to make your Spring Boot app faster
    with caching. It’s a very nice skill to have in your arsenal for the development
    of better, faster apps.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到这部分结束时，您将了解如何通过缓存使您的 Spring Boot 应用程序更快。这是您武器库中一个非常好的技能，用于开发更好、更快的应用程序。
- en: Understanding cache abstraction
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解缓存抽象
- en: So, let us dive into understanding cache abstraction in Spring Boot and why
    it is like a superpower for your app’s performance. **Cache abstraction** is just
    storing some pieces of information that your app uses a lot in any application
    in some special memory space. This way, the app does not have to keep asking for
    the same information over and over again – this can be a total bummer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们深入了解 Spring Boot 中的缓存抽象以及为什么它对应用程序的性能来说就像是一种超级能力。**缓存抽象**只是在某个特殊的内存空间中存储应用程序在任意应用程序中大量使用的一些信息。这样，应用程序就不必反复请求相同的信息——这可能会非常令人沮丧。
- en: Using cache abstraction in Spring Boot is pretty simple and carries big dividends.
    For instance, in our online bookstore app, we can use caching to remember the
    details of a book. Normally, every time somebody wants to see a book, the app
    has to ask for the information from the database. With caching, after the application
    has asked for a book’s details, it *remembers* them. And so, the next time somebody
    wants to see that book, the application can show the details super quickly without
    going back to the database. This helps to run your app faster, reduces the load
    on your database, and gives your users an enhanced experience.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 中使用缓存抽象非常简单，并且能带来巨大的收益。例如，在我们的在线书店应用程序中，我们可以使用缓存来记住书籍的详情。通常情况下，每当有人想要查看一本书时，应用程序都必须从数据库中请求信息。有了缓存，当应用程序请求一本书的详情后，它会*记住*这些信息。因此，下次有人想查看那本书时，应用程序可以非常快速地显示详情，而无需再次回到数据库。这有助于使您的应用程序运行得更快，减少数据库的负载，并为您的用户提供更好的体验。
- en: Next in this section, we will be looking at how easily caching in Spring Boot
    3.0 can be set up and what difference it can make in your app. We’ll walk through
    some practical steps to integrate caching within our bookstore app in a way that
    shows how it could speed things up even more for features that don’t change often.
    This is one of the key techniques if you want to build efficient and user-friendly
    apps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的下一部分，我们将探讨如何在 Spring Boot 3.0 中轻松设置缓存以及它可以在您的应用程序中带来哪些不同。我们将通过一些实际步骤来展示如何在书店应用程序中集成缓存，以展示它如何加快那些不经常变化的功能的速度。如果您想构建高效且用户友好的应用程序，这是关键技术之一。
- en: Configuring and using cache abstraction in the application
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在应用程序中配置和使用缓存抽象
- en: In this section, we’re going to see how cache abstraction can be implemented
    effortlessly in Spring Boot 3.0, particularly in our bookstore application. Cache
    abstraction is not about the performance boost only but also about making it simple
    for us to handle the frequently accessed data in our applications. That reaches
    a whole new level of simplicity with Spring Boot 3.0.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何在 Spring Boot 3.0 中轻松实现缓存抽象，特别是在我们的书店应用程序中。缓存抽象不仅关乎性能提升，还关乎简化我们处理应用程序中频繁访问的数据。在
    Spring Boot 3.0 中，这达到了前所未有的简单程度。
- en: 'Under the terms of our bookstore app, effectively using cache abstraction implies
    that often referred to data such as a book’s details are available without hitting
    the database over and over again. This is important in improving user experience
    from two perspectives: reducing the wait time and reducing the server load.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的书店应用程序条款，有效地使用缓存抽象意味着经常引用的数据，如书籍详情，可以在不反复击中数据库的情况下获得。从两个角度来看，这很重要：减少等待时间和减少服务器负载。
- en: 'Let’s see how easy it is to implement caching in Spring Boot 3.0\. There are
    two simple steps to enable caching in our project:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 Spring Boot 3.0 中实现缓存有多简单。启用项目中的缓存只需要两个简单的步骤：
- en: 'First, we need to add the library to the `build.gradle` file:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将库添加到 `build.gradle` 文件中：
- en: '[PRE21]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will add `@EnableCaching` on top of our main class:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在主类上添加 `@EnableCaching`：
- en: '[PRE22]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s it! We are now ready to use caching wherever we need.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在可以在需要的地方使用缓存了。
- en: Let’s look at how caching is implemented in the `BookController` class of our
    bookstore app. The controller already has several endpoints – for adding, fetching,
    updating, and deleting books. We’ll focus on integrating Spring Boot’s caching
    capabilities to optimize these operations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在书店应用程序的 `BookController` 类中实现缓存。控制器已经具有几个端点——用于添加、获取、更新和删除书籍。我们将专注于集成
    Spring Boot 的缓存能力以优化这些操作。
- en: Using @CacheEvict for adding, updating, and deleting books
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 @CacheEvict 添加、更新和删除书籍
- en: When a new book is added or an existing one is updated, it’s essential to ensure
    that our cache reflects these changes. The `@CacheEvict` annotation is used here
    to invalidate the cache. This means that the cached data is removed or updated,
    ensuring that subsequent requests fetch the most recent data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加新书或更新现有书籍时，确保我们的缓存反映了这些更改至关重要。在这里使用 `@CacheEvict` 注解来使缓存失效。这意味着缓存数据被删除或更新，确保后续请求获取最新的数据。
- en: 'This is what they will look like:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来是这样的：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the `addBook` and `updateBook` methods, `@CacheEvict(value = "books", allEntries
    = true)` effectively clears the cache of all entries related to books. This approach
    guarantees that the cache does not serve outdated information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addBook` 和 `updateBook` 方法中，`@CacheEvict(value = "books", allEntries = true)`
    有效地清除了与书籍相关的所有条目的缓存。这种方法保证了缓存不会提供过时的信息。
- en: Similarly, when a book is deleted, we use `@CacheEvict(value = "books", key
    = "#id")` to remove only the cache entry for that specific book. This targeted
    approach helps us to maintain cache accuracy without affecting other cached data.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当一本书被删除时，我们使用 `@CacheEvict(value = "books", key = "#id")` 来仅删除该特定书籍的缓存条目。这种有针对性的方法有助于我们保持缓存准确性，而不会影响其他缓存数据。
- en: Efficient retrieval with caching
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用缓存进行高效检索
- en: Although not explicitly shown in the provided code, fetching operations (such
    as `getAllBooks` or `getBook`) can be optimized using `@Cacheable`. This annotation
    ensures that the result of a method call is stored in the cache, making subsequent
    requests for the same data faster and more efficient.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管提供的代码中没有明确显示，但获取操作（如 `getAllBooks` 或 `getBook`）可以使用 `@Cacheable` 进行优化。这个注解确保方法调用的结果被存储在缓存中，使得后续对相同数据的请求更快、更高效。
- en: 'Also, we can implement this feature at the repository level. For example, we
    can introduce a query and make it cacheable:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以在存储库级别实现此功能。例如，我们可以引入一个查询并使其可缓存：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We don’t need some analyzer to see the difference; just run the application
    and see how you will get a faster response to your second call.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要某个分析器来看到差异；只需运行应用程序，看看你将如何获得对第二次调用的更快响应。
- en: In summary, cache abstraction in Spring Boot 3.0 is a powerful and straightforward
    way to optimize data retrieval processes. We have seen how easy it is to implement
    in the bookstore application. By utilizing cache control annotations such as `@CacheEvict`
    and `@Cacheable`, we ensure that our application remains responsive and efficient
    and always keeps accrual data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Spring Boot 3.0中的缓存抽象是优化数据检索过程的一种强大且简单直接的方法。我们看到了在书店应用程序中实现它的简便性。通过利用缓存控制注解，如`@CacheEvict`和`@Cacheable`，我们确保我们的应用保持响应性和高效性，并始终保持数据的准确性。
- en: In conclusion
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总之
- en: To conclude this exploration of cache abstraction in Spring Boot, we learned
    about the significant advantages it provides us when it is undertaken to enhance
    application performance. We have noticed that caching can bring a lot of improvement
    to the rapid accessing of data, particularly simple repetitive retrieval of information
    such as book details in our online bookstore management system. We have learned
    from the implementation of cache abstraction that it not only drastically reduces
    the load on the database but also delivers a smooth, quick user experience.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结我们对Spring Boot中缓存抽象的探索时，我们了解到它在提升应用性能时为我们提供了显著的优点。我们注意到，缓存可以极大地提高数据的快速访问，尤其是像我们在线书店管理系统中的书籍详情这样的简单重复信息检索。我们从缓存抽象的实现中学习到，它不仅极大地减轻了数据库的负载，还提供了流畅、快捷的用户体验。
- en: This tour through cache abstraction has given us pragmatic tools that are absolutely
    essential in the fast-moving technology environments of today. It is quite evident
    that understanding and using a cache properly is an important key in developing
    efficient and responsive applications with Spring Boot.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这次对缓存抽象的游览为我们提供了在当今快速发展的技术环境中绝对必要的实用工具。很明显，正确理解和使用缓存是开发Spring Boot中高效和响应性应用的重要关键。
- en: Next, we will get into the world of batch processing in Spring Boot. We will
    dig deeper into how to efficiently handle huge sets of data, which are commonly
    required for applications that are meant for processing high volumes of records.
    Batch processing is another key tool in our toolkit for getting things done with
    Spring Boot, helping us to manage data at scale from all aspects while ensuring
    our applications cope well without being burdened to the max with complex tasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进入Spring Boot批处理的世界。我们将深入了解如何高效地处理大量数据，这对于旨在处理大量记录的应用程序来说是常见的。批处理是我们工具箱中的另一个关键工具，帮助我们从各个方面管理大规模数据，同时确保我们的应用能够很好地处理复杂任务，而不会被压垮。
- en: Spring Boot batch processing
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot批处理
- en: 'Now let’s take a look at one of the most important features of Spring Boot:
    batch processing. We’ll look at how you can manage and process huge amounts of
    data in an effective manner with Spring Boot. Batch processing is especially important
    when your application has to handle tasks such as importing big datasets or performing
    actions on a large number of records at once.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Spring Boot最重要的功能之一：批处理。我们将探讨如何使用Spring Boot有效地管理和处理大量数据。当你的应用程序需要处理像导入大型数据集或一次性对大量记录执行操作这样的任务时，批处理尤为重要。
- en: In this part of our guide, we’ll cover three main areas. To begin with, let’s
    discuss batch processing in Spring Boot, why it is so crucial at the very beginning
    of our discussion, and how it can be a game changer for any enterprise or any
    application related to hefty data operations. Next, we’ll walk through the detailed
    setup and execution of batch jobs – a key aspect for efficiently handling large-scale
    data tasks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南的这一部分，我们将涵盖三个主要领域。首先，让我们讨论Spring Boot中的批处理，为什么它在我们的讨论一开始就如此关键，以及它如何成为任何企业或与大量数据操作相关的应用的变革者。接下来，我们将详细介绍批作业的设置和执行——这是高效处理大规模数据任务的关键方面。
- en: Last, but the most interesting, we’ll look at how batch processing can be actually
    implemented in our online bookstore project. Imagine how infeasible it would be
    to have to upload thousands of books or publisher details into the system – batch
    processing would make such a task extremely feasible. If you apply all these concepts
    to the bookstore, you’ll get a real feel of how batch processing works in live
    applications such as book imports in bulk.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但也是最有意思的，我们将探讨如何在我们的在线书店项目中实际实现批处理。想象一下，如果必须将数千本书或出版商详情上传到系统中将有多么不切实际——批处理将使这项任务变得极其可行。如果你将这些概念应用到书店中，你将真正感受到批处理在现实应用程序（如批量导入书籍）中的工作方式。
- en: By the end of this section, you’ll have a solid grasp of batch processing in
    Spring Boot and the power to wield it effectively in real-world use cases. This
    is critical stuff to know, especially when developing web applications that need
    high throughput data management for many purposes. Let’s get started and discover
    how batch processing can enhance the capabilities of our Spring Boot applications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将牢固掌握Spring Boot中的批处理，并能够有效地在实际用例中运用它。这是需要了解的关键内容，尤其是在开发需要为多种目的进行高吞吐量数据管理的Web应用程序时。让我们开始吧，看看批处理如何增强我们的Spring
    Boot应用程序的功能。
- en: Understanding the role of batch processing in Spring Boot
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Spring Boot中批处理的作用
- en: '**Batch processing** is a lightweight and very effective way to process large
    amounts of data. It’s sort of like having a super-efficient assembly line in your
    app where big data chores are broken down and processed in manageable batches,
    especially so if your application is to perform heavy-duty work that involves
    processing thousands of records at a time.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**批处理**是一种轻量级且非常有效的处理大量数据的方法。它有点像在你的应用程序中有一个超级高效的装配线，其中大数据任务被分解并分批处理，特别是如果你的应用程序需要一次性处理数千条记录的重型工作。'
- en: Batch processing in Spring Boot will enable the management of such large-scale
    data operations. It helps in the organizing, executing, and automation of the
    bulk processing of data that is required in many modern-day applications. Most
    batch-processing jobs are continuous processes, not one-time processes. Remember,
    we have to introduce new books, publishers, and authors to our platform every
    week or every day. A batch process will handle it for us automatically in a simple
    way.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot中的批处理将使管理此类大规模数据操作成为可能。它有助于组织、执行和自动化许多现代应用程序所需的批量数据处理。大多数批处理作业是连续过程，而不是一次性过程。记住，我们必须每周或每天向我们的平台引入新书、出版商和作者。批处理过程将自动以简单的方式为我们处理这些任务。
- en: You will learn the significance of batch processing in Spring Boot; you will
    be able to handle scenarios that involve handling large amounts of datasets and
    executing them, where the system is not affected. This is an essential skill to
    have for developers working on data-intensive applications and to make sure that
    your app can handle big tasks without seeming to break a sweat. As we proceed,
    you will begin to see how batch processing is implemented and the magnitude of
    the impact it may have on the performance and efficiency of your application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解Spring Boot中批处理的重要性；你将能够处理涉及处理大量数据集并执行它们的场景，而系统不会受到影响。这对于从事数据密集型应用程序开发的开发者来说是一项必备技能，以确保你的应用程序能够处理大型任务而不会显得力不从心。随着我们的深入，你将开始看到批处理是如何实现的，以及它可能对你的应用程序的性能和效率产生的影响。
- en: Implementing Spring Batch
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Spring Batch
- en: After all this theoretical information, we must get our hands dirty to learn
    better.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些理论信息之后，我们必须亲自动手实践，以更好地学习。
- en: In this section, we’ll learn how to set up batch processes in Spring Boot 3.0\.
    We’ll introduce a separate batch repository application, showing you step by step
    how to handle tasks such as bulk book imports for our online bookstore.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在Spring Boot 3.0中设置批处理过程。我们将介绍一个独立的批处理仓库应用程序，逐步向您展示如何处理诸如为我们的在线书店进行批量书籍导入等任务。
- en: Creating a batch processing application
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建批处理应用程序
- en: 'We will start by setting up a new Spring Boot project dedicated to batch processing.
    We can use the following dependencies in the project:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置一个新的Spring Boot项目，专门用于批处理。我们可以在项目中使用以下依赖项：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have also added a PostgreSQL dependency because we would like to import the
    bulk data into the PostgreSQL database.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了PostgreSQL依赖项，因为我们希望将大量数据导入PostgreSQL数据库。
- en: Introducing the Publisher class
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍Publisher类
- en: 'We need to add the `Publisher` class again as it is under the `data` package:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次添加`Publisher`类，因为它位于`data`包下：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will deal with the `Publisher` object in batch processing. So, we need the
    same exact object as we used in our project.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在批量处理中处理`Publisher`对象。因此，我们需要与我们在项目中使用的完全相同的对象。
- en: Configuring a batch job
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置批量作业
- en: Let’s define a batch job in our application. This involves specifying the steps
    the job will take, such as reading data, processing it, and then writing the results.
    Create a package named `config` and create a `BatchConfig.java` file. Everything
    we need will be done in this file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用程序中定义一个批量作业。这包括指定作业将采取的步骤，例如读取数据、处理数据，然后将结果写入。创建一个名为`config`的包，并创建一个`BatchConfig.java`文件。我们需要做的所有事情都将在这个文件中完成。
- en: First, we need to understand the flow here. Our sample code will have one job,
    but depending on the requirements, we can define multiple jobs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解这里的流程。我们的示例代码将有一个作业，但根据需求，我们可以定义多个作业。
- en: 'This is what a job looks like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是作业的样子：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we have just a job repository and steps. In our example, we
    have one step, but we may have more than one, depending on the requirements.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只有一个作业仓库和步骤。在我们的例子中，我们有一个步骤，但根据需求，我们可能有多个步骤。
- en: 'Let’s look at the `Step` function because it will explain to us how a step
    can be built:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Step`函数，因为它将向我们解释如何构建一个步骤：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, a step has a `reader`, `processor`, and `writer` method. The
    functions of these methods are hidden in their names, literally. These functions
    basically read the data, process the data if needed, do some processes on it like
    setting `address` and `name` values, and write it to the repository. Let’s look
    at them one by one in the next section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个步骤有一个`reader`、`processor`和`writer`方法。这些方法的函数在它们的名称中是隐含的。这些函数基本上读取数据，如果需要，处理数据，对它进行一些处理，如设置`地址`和`名称`值，然后将其写入仓库。让我们在下一节逐一查看它们。
- en: Reading, processing, and writing data
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取、处理和写入数据
- en: For each step in the batch job, define how the application will read, process,
    and write data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于批量作业中的每个步骤，定义应用程序将如何读取、处理和写入数据。
- en: In the preceding code example, you can see how to read publisher data from a
    **Comma-Separated Values** (**CSV**) file, process it to map it to your publisher
    entity, and then write it to the database.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，您可以了解如何从**逗号分隔值**（**CSV**）文件中读取发布者数据，将其处理以映射到您的发布者实体，然后将它写入数据库。
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In `reader`, we define where to read data and how to parse the data. We also
    map the data to our entity object, and in the `processor` function, we can convert
    it to the required object or objects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reader`中，我们定义了读取数据的位置以及如何解析数据。我们还将数据映射到我们的实体对象，在`processor`函数中，我们可以将其转换为所需的对象或对象。
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here is the `processor` function. We can do all the processing steps in this
    function. As an example, I have converted the text to uppercase.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`processor`函数。我们可以在该函数中完成所有的处理步骤。例如，我已经将文本转换为大写。
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, this is the `writer` object; it gets the processed data from the processor
    and writes it to the database. In the next step, we will execute our application
    and discuss the output.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是`writer`对象；它从处理器获取处理后的数据并将其写入数据库。在下一步中，我们将执行我们的应用程序并讨论输出。
- en: Executing the batch job
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行批量作业
- en: Once the batch job is set, it triggers to run either on an event or on a schedule.
    This serves to trigger the job to kick-start the processing and manipulation of
    the big dataset in a very efficient management process of the job task.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置批量作业，它就会在事件或计划触发时运行。这有助于触发作业以启动对大数据集的处理和操作，这是一个非常高效的作业任务管理过程。
- en: 'You can create a simple CSV file in the `Resources` folder. We can name it
    `publishers.csv`. This name should match the filename in the `reader` function.
    The sample data will be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Resources`文件夹中创建一个简单的 CSV 文件。我们可以将其命名为`publishers.csv`。这个名字应该与`reader`函数中的文件名匹配。示例数据如下：
- en: '`name,address`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`名称，地址`'
- en: '`Publisher Name` `1,Address 1`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`发布者名称` `1,地址 1`'
- en: '`Publisher Name` `2,Address 2`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`发布者名称` `2,地址 2`'
- en: You can write as many rows as you want. And we can run our bookstore batch application.
    We will see these values have been imported into our PostgreSQL database as processed
    (see *Figure 4**.3*).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以写尽可能多的行。我们可以运行我们的书店批量应用程序。我们将看到这些值已经被导入我们的 PostgreSQL 数据库作为处理后的数据（见*图 4**.3*）。
- en: '![Figure 4.3 – Publishers table after batch operation](img/B18400_04_03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 批量操作后的发布者表](img/B18400_04_03.jpg)'
- en: Figure 4.3 – Publishers table after batch operation
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 批量操作后的发布者表
- en: As we can see in *Figure 4**.3*, the values are uppercased while importing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: With such batch processing, this would properly allow managing the large data
    tasks that will come through our online bookstore application. This also makes
    our data handling efficient and subsequently scalable to manage large-scale data
    operations in our database while the application is running.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion to our exploration of batch processing in Spring Boot 3.0, we
    gained valuable insights into handling immense datasets efficiently. We have seen
    how doing so not only streamlines the process of breaking up massive data tasks
    into manageable chunks but also helps to make our application perform better.
    Within the context of our online bookstore, batch processing has demonstrated
    how important this feature is in managing large volumes of data, such as bulk
    publisher imports.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: On this journey, we learned that batch processing is not just a technical necessity
    but also an important strategic way to handle intelligent data-intensive operations
    in Spring Boot. This insight becomes especially important while working with applications
    that need to process large volumes of data as part of their business workloads,
    in the background periodically and regularly.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we move on to our next section, we are poised to dive into data migration
    and consistency. We’ve seen some powerful strategies for keeping and evolving
    the data structure of our applications without any seams. This is an important
    aspect to make sure that the handling of data by our applications not only remains
    efficient but is more reliable and sturdy over time. So, let’s move forward, geared
    up for new challenges, thereby strengthening our command of these advanced features
    of Spring Boot.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Data migration and consistency
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this critical section, we look at data migration and consistency with Spring
    Boot. We will talk about how we can actually migrate and even amend crucial data
    in our applications without compromising precision or causing problems. We are
    going to detail some strategies for data migration, and we’re specifically going
    to look at tools such as Liquibase, which enables the management and even automation
    of such processes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Before that, we are going to start with an introduction to data migration strategies
    and offer a view on why these are relevant in order to keep your application healthy.
    Then, we are going to proceed with the practical steps of data migration implementation
    with Liquibase as a core tool. Namely, we will find out how to integrate Liquibase
    into your project and use it for managing database changes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: These strategies will be implemented practically in our online bookstore. We
    will see how we can add new features to the bookstore by applying data migration
    and consistency techniques that could keep the existing data consistent and reliable.
    Let’s get started and unlock the skills to manage data changes smoothly and efficiently.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Exploring data migration strategies and tools like Liquibase
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’re going to dive into **data migration strategies**. We
    will focus on understanding their importance and how tools like Liquibase are
    important. **Data migration** is all about moving data from one system to another,
    or from one version of a database to another, in a way that’s safe, efficient,
    and reliable. It’s a vital process, especially when updating or improving your
    application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**Liquibase** is a key tool and is like a skilled architect for your data migration.
    It helps manage database revisions, track changes, and apply them consistently
    across different environments. This tool uses a simple format for defining database
    changes, making it easier to track and implement changes over time.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: If we understand and apply the strategies of data migration tools like Liquibase,
    then we will be well placed to handle the evolution of our applications’ requirements
    very effectively.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: As we wind up this section, we’re preparing to delve into the world of ensuring
    data consistency that builds on our understanding of migration and how it happens.
    This next topic will focus on techniques used in maintaining data integrity throughout
    data changes, as covered in the previous topic. Stay tuned as we continue to navigate
    the intricate landscape of data management in Spring Boot applications.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for implementing data migration using Liquibase
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to updating or changing your application’s database, data migration
    is a crucial step. In this section, we’ll walk through the practical steps of
    implementing data migration. We will use Liquibase. We will see how it is a powerful
    tool that helps manage database changes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Liquibase into your project
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to add Liquibase to your project. You can open your book
    store application, or you can follow these steps in one of your Spring Boot applications
    to implement Liquibase. As we have been using Gradle since the beginning, we need
    to add a dependency in the `build.gradle` file:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will import all necessary libraries into your project.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Liquibase configuration
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you need to configure Liquibase in your application. This involves specifying
    the database connection properties and the path to your change log file, which
    will contain all the database changes you want to apply. In our application, we
    will update the `application.properties` file as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we already added our database connection settings here, I am just mentioning
    the line related to Liquibase.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Liquibase change log
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The change log file in Liquibase is where you define your database changes,
    such as creating new tables, adding columns, or modifying existing structures.
    Changes are written in XML, JSON, YAML, or SQL format. Here’s our sample in YAML
    format:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we have used the `includeAll` method. It means check the path, sort files
    alphabetically, and start to execute them one by one. There is one more approach,
    in that we can define each file with `include` and Liquibase will follow the orders
    in this file, not the files in the folder.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Executing the migration
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the change log file is created, Liquibase has the capability to perform
    such changes on your database. This could be done automatically at the startup
    of the application or manually running Liquibase commands. When execution takes
    place, the change log is read by Liquibase, and then, one by one, the changes
    get executed, as defined in the order in `databaseChangeLog` or alphabetical order
    in the database.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Following these steps will let you effectively handle such a change in your
    database for your projects and will keep you in control so that the probability
    of making mistakes during migration is reduced. This kind of approach becomes
    critical when we have applications evolving with time – like our online bookstore
    – where data integrity and consistency are paramount in nature.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look into how we can use Liquibase in our bookstore application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Implementing migration strategies in the online bookstore
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s apply what we’ve learned about data migration strategies to our online
    bookstore project. This practical implementation will focus on integrating new
    features and maintaining data consistency throughout the process. Let’s assume
    we have a new requirement to add a `published` column in the `books` table. We
    need to handle this requirement without breaking the data and by not touching
    the database server manually. When we need to run our application on another platform,
    we need to be sure we don’t need to do anything manually in the data structure;
    it will be handled by the application.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Liquibase for migration
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already introduced the dependency and configuration for Liquibase in
    our bookstore application. Now, we will introduce a change log file.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a folder named `changes` in `resources/db/changelog/`. This is
    the folder to which Liquibase listens. Then create a file named `001-add-published-column.yaml`.
    Naming is important for two reasons: As we mentioned before, Liquibase will sort
    files alphabetically and execute them accordingly. We need to keep this sorting
    aligned and the latest change always needs to be at the end of the list. The second
    reason is, when we read the filename, we need to understand what it includes.
    Otherwise, when we need to track some changes, it takes ages to find the particular
    file.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample YAML file to add a published column to the `books` table:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you read the content, you can understand what all these fields mean. Here,
    `author` is the name of the developer who implements this change. It basically
    adds a new column with the name `published` and the default value is `false`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'This is enough to change the table in the database, but we also need it to
    be aligned in our application by updating our `Book` entity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, when we fetch or save data, we will manage the database table accordingly.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Executing the migration
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the change log ready, we run Liquibase to apply these changes. This process
    will create the new column in the books table in our database without disrupting
    existing data. This is done carefully to ensure there is no downtime or loss of
    service for our bookstore’s users.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'When you check your database, you will see the new column has been created,
    as you can see in *Figure 4**.4*:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Updated books table](img/B18400_04_04.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Updated books table
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: As we make these changes, we continuously ensure that data consistency is maintained.
    This involves checking that the new data aligns with the existing data structures
    and follows all the integrity rules.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We have learned now that we should handle the new feature addition in our online
    bookstore carefully. Careful data migration helps the smooth addition of the new
    column to the `books` table, thus maintaining the consistency as well as the reliability
    of the data. This is essential to keep the bookstore up to date and effective
    for users.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have acquired the knowledge and skills to help us manage
    data as required in application development. This prepares us for future challenges
    and hence helps our applications remain relevant in the digital world.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as Liquibase enable us to change our database safely and efficiently.
    This is important for updating our apps without harming existing features.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: These ideas have been applied to the online bookstore, showing how the theory
    works out in practice in real life. It keeps our application accurate as well
    as reliable while growing.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: This section was so informative and has given us essential skills and knowledge.
    These are critical to any developer in Spring Boot app development. Moving on,
    these lessons on data management will prove to be a strong foundation. They will
    guide you in developing applications that are not only functional but also have
    sturdy data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we reach the end of this chapter, let’s recap the key learnings and insights
    we’ve gathered. This chapter has been a very deep dive into the world of data
    management with Spring Boot 3.0, covering a broad spectrum of topics that are
    crucial for any developer touching any aspect of this powerful framework. You
    should now have a grasp of the data management features in Spring Boot, as they
    are fundamental to building robust, efficient, and scalable applications. The
    skills acquired after the completion of this chapter are not only elemental to
    backend development but also quite useful when working with the intricacies and
    vagaries posed by modern application development opportunities.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we have covered:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to Spring Data**: We began with the basics of Spring Data, understanding
    how this technology for data access simplifies data access in Spring applications.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL databases with Spring Data**: We also touched on database integration,
    including PostgreSQL, as well as setting both data sources that are simple and
    that include more than one data source, and how to handle complex relationships
    entities.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NoSQL databases in Spring Boot**: The chapter guided us through the integration
    of NoSQL databases, specifically MongoDB, pointing out the flexibility and scaling
    up options they present.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data migration and consistency**: We delved into strategies for data migration,
    touching on tools such as Liquibase, which comes in handy to ensure the integrity
    of data is not lost during transitions.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache abstraction in Spring Boot**: This topic really exposed us to cache
    abstraction and raised the point of its importance when seeking to improve the
    performance of an application.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batch processing in Spring Boot**: We looked at the batch processing concept,
    which is important when it comes to effectively handling large datasets.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Practical application**: We practically applied those concepts throughout
    the chapter on a real project, the online bookstore management system, which exhibited
    the concrete implementation of the described data management strategies in Spring
    Boot.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we conclude this chapter, remember that the learning path and mastery of
    Spring Boot is an ongoing journey. Technology changes are quite frequent and keeping
    up to date with these changes will go a long way in making one effective at developing
    applications. Keep exploring, keep coding, and let the knowledge from this chapter
    be a stepping stone to build more complex and efficient Spring Boot applications.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18400_05.xhtml#_idTextAnchor179), we will learn about Advanced
    Testing Strategies. This knowledge will help us gain confidence in conducting
    application testing efficiently. We will learn about discovering differences between
    unit and integration tests, testing application reactive components, and securing
    application features. Other than that, implementation will demonstrate broad-based
    comprehension of **Test-Driven Development** (**TDD**) with the Spring Boot ecosystem.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
