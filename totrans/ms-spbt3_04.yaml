- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Data: SQL, NoSQL, Cache Abstraction, and Batch Processing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 4*](B18400_04.xhtml#_idTextAnchor146). Here, we are going
    to take a closer look at the Spring Data approach. In this chapter, we want to
    learn how the Spring Data approach can work for us. Spring Data is one of the
    key parts of the Spring Boot ecosystem. This will help you to clearly understand
    how to work with different kinds of databases in Spring Boot 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Why does this chapter matter? In software development, how we manage data is
    very important, and is more than just storing the data. This part of the book
    is not only about studying various parts of Spring Data, but it’s also about putting
    them to work in real-life situations. In this chapter, we will see how to configure
    and use Spring Data, which helps a lot in data management activities. You will
    learn how to work with structured data, stored in SQL databases, and unstructured
    data that is stored in NoSQL databases, ideal for various types of data. Furthermore,
    we will cover what cache abstraction is and why it’s good for making your app
    run faster. Another really big topic is batch processing, and how to work with
    a lot of data all at once. Further than that, you will learn important techniques
    for changing and updating your data safely.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to handle data, whether it is simple or complex, is key and will
    contribute to better software programming skills. By the end of this chapter,
    you are not just going to know the theory but will be able to be hands-on in actual
    projects, applying these skills. We will use a real project, an online bookstore
    management system, to show you how things work.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good grasp of both the theory and
    practical use of Spring Data. This is essential for any developer, whether regarded
    as experienced or just starting out.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get the ball rolling. We will see how Spring Data will help you to change
    the way you manage data in your projects. We will turn the theory into real skills
    and help you to grow as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on these main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Spring Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Data with SQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL databases in Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot cache abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot batch processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data migration and consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we are going to need some installations on our local machines:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub repository: You can clone all repositories related to [*Chapter 4*](B18400_04.xhtml#_idTextAnchor146)
    here: [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the steps to install Docker Desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the Docker Desktop website: [https://docs.docker.com/desktop/](https://docs.docker.com/desktop/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the instructions under the **Install Docker Desktop** menu. It’s available
    for various operating systems and provides a straightforward installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduction to Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the general fundamental concepts of Spring
    Data and how they are useful. We will also examine their application in our case
    study project, the online bookstore management system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Data** is a part of the Spring Framework that can simplify interaction
    with data in our application as much as possible. Its main advantage and greatest
    strength is the ability to simplify database operations. This means you can perform
    tasks such as querying a database or updating records with less code and complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Spring Data will build your skills in dealing with data effectively
    – one of the key factors of software development. Whether it is a small application
    or a complex enterprise system, effective role-based access on the data layer
    plays an impactful role in better performance and maintenance of the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will display the main characteristics of Spring Data and
    how it can help you to simplify your work. Knowing about these concepts will help
    you manage data in your software projects, thus making the development process
    an easier one and expediting its flow.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s embark on this interesting journey with Spring Data. It is going to
    be a practical and informative ride, and by the end of it, you will surely be
    well-equipped to manage data in your own applications using Spring Data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the fundamentals and benefits of Spring Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll focus on the basics of Spring Data. We are first going
    to learn about its core concepts and benefits that are critical to every developer.
    From there, we will step into setting up a Spring Boot project and defining some
    key JPA entities. By taking little steps like these, we will graduate to having
    a solid foundation in Spring Data, which will render further applications more
    advanced.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with what makes Spring Data a powerful tool in the Spring Boot ecosystem
    and why it could be beneficial for your projects as well. We’ll then continue
    to the practical parts of setting up your project and going deeper into the world
    of **Java Persistence API** (**JPA**) entities.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the technical setup, let’s first understand the core principles
    and advantages of using Spring Data in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the core concepts of Spring Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spring Data is designed to simplify interaction with databases in Java applications.
    Here are some of its fundamental concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data access simplified**: Spring Data reduces the complexity of data access
    operations. You no longer need to write boilerplate code for common database interactions.
    We will see how to perform **Create, Read, Update, and Delete** (**CRUD**) operations
    without writing a single line of code. This will make our code more readable and
    manageable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository abstraction**: One of the key features of Spring Data is its repository
    abstraction. This helps us to use database operations like a function in our framework.
    If we don’t know how to write a query in a specific database, we don’t need to
    worry. This abstraction makes it work the same for all supported databases. It
    abstracts the data layer, meaning you can focus more on your business logic rather
    than database intricacies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Support for multiple database types**: Spring Data supports a wide range
    of database types, including both SQL and NoSQL options. This versatility makes
    it a valuable tool for projects that may require different database technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of using Spring Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s look at why Spring Data is beneficial for your development process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased efficiency and productivity**: Spring Data not only reduces the
    boilerplate coding for database operations but also performs these operations
    in a best-practice, efficient way. In old structures, we often dealt with connection
    issues that were not closed. Spring Data manages all connection pool issues effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to learn and use**: Spring Data is designed to be user-friendly. Just
    a few pages later, you will understand what I mean. Developers can quickly learn
    how to use it and start using it in their projects. Its integration with the Spring
    ecosystem also means that it works seamlessly with other Spring technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced code quality and maintainability**: With less code clutter and a
    cleaner approach to data handling, Spring Data enhances the overall quality of
    your code. It makes your applications easier to maintain and update in the long
    run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will understand these benefits and concepts better as we progress through
    the setup and usage of our Spring Boot application. Now that we have basic knowledge
    of what Spring Data is and why it’s advantageous, let’s move forward with setting
    up our project and defining our JPA entities.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your Spring Boot project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First things first, let’s set up a Spring Boot project. This is your starting
    point for any Spring application. You can follow the same steps as in [*Chapter
    3*](B18400_03.xhtml#_idTextAnchor064). Or you can directly clone the Git repository
    provided in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the basic dependencies you need while creating the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The library, called Lombok, is commonly used to eliminate boilerplate code like
    the `getId` and `setId` methods.
  prefs: []
  type: TYPE_NORMAL
- en: With these steps, you have your Spring Boot project ready. Now, let’s define
    some JPA entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining JPA entities: Book, Author, and Publisher'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a bookstore application, we deal with books, authors, and publishers. Let’s
    define them as JPA entities. We will create three classes as follows. You can
    see them in the repository under the `model` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each of the `Book`, `Author`, and `Publisher` entities represents a crucial
    part of our bookstore system. By using the `@Data` annotation, we simplify our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of repositories in Spring Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After defining our entities, we need to create repositories. **Repositories**
    in Spring Data help us to interact with the database easily.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a repository for each entity (`Book`, `Author`, `Publisher`),
    create an interface that extends `JpaRepository`. This interface provides methods
    for common database operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `Book`, it might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These repositories provide some generic methods for saving, finding, deleting,
    and updating entities. For instance, to find all books, you can use `bookRepository.findAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: This setup will be the base for our building in the upcoming Spring Boot application.
    By now, you should have a basic project ready with entities and repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a Spring Boot project set up with Spring Data dependencies, and
    we’ve defined essential JPA entities and repositories. This is the foundation
    of our work with Spring Data. We have not connected to a database yet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll delve into how to use Spring Data with SQL databases.
    We will look at an easy and effective way to use Spring Data in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Data with SQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer who deals with Spring Data, it’s important to understand its
    relationship with SQL databases. **SQL databases** are known for their structured
    approach to data management. They are widely used in various applications. We
    are going to use them in our online bookstore management system.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore how Spring Data JPA interfaces with SQL databases,
    focusing on PostgreSQL configuration and the creation of complex entity relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating PostgreSQL with Spring Boot using Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First off, we need to have an up-and-running PostgreSQL server on our local
    machine. The easiest way of doing this is using Docker containers. **Docker**
    is a tool that simplifies the setup and deployment of applications and their dependencies.
    Let’s go through how you can set up PostgreSQL using Docker and configure your
    Spring Boot application to connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PostgreSQL with Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using Docker, you can easily install and run a PostgreSQL database. This method
    offers a consistent and isolated environment for your database, regardless of
    your local setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already installed Docker Desktop as instructed in the *Technical requirements*
    section. We will use a `Docker Compose` file, which can also be found in the root
    folder of the GitHub repository. Here’s a basic example using a `Docker` `Compose`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will set up a PostgreSQL server with the database named `bookstore`. Replace
    `yourpassword` with a secure password of your choice. Save this file as `docker-compose.yml`
    in the root source folder.
  prefs: []
  type: TYPE_NORMAL
- en: Run the `docker-compose up` command in the directory where your `docker-compose.yml`
    file is located. This command will download the PostgreSQL image and start the
    database server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Spring Boot to connect to PostgreSQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that PostgreSQL is running in a Docker container, let’s configure our Spring
    Boot application to connect to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `application.properties`: Open the `application.properties` file in
    your Spring Boot project. Add the following properties to configure the connection
    to the PostgreSQL server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace `yourpassword` with the password you set in the `Docker
    Compose` file. The `spring.jpa.hibernate.ddl-auto=update` property helps manage
    the database schema based on your entity classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verifying the connection: Run your Spring Boot application. At this stage,
    we can only see whether the app starts up properly or not. In the *Implementing
    practical CRUD operations in the online bookstore* section, we will introduce
    the REST controller to verify that it connects to the PostgreSQL database successfully.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these steps, you have successfully integrated a PostgreSQL database into
    your Spring Boot application using Docker. This setup not only simplifies the
    initial configuration but also ensures a consistent database environment for development
    and testing. Now, we will go one step ahead and introduce the advanced entity
    relationships between the objects in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing complex relationships between entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll focus on developing complex relationships between our
    entities: `Book`, `Author`, and `Publisher`. We’ll use Spring Data’s annotation-driven
    approach to link these entities, reflecting real-world connections in our database
    design.'
  prefs: []
  type: TYPE_NORMAL
- en: In our bookstore application, we created basic objects. Now, we are going to
    connect them to each other. Let’s start with the `Books` to `Authors` connection.
  prefs: []
  type: TYPE_NORMAL
- en: Each book can have one or more authors, forming a many-to-many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can represent this in our `Book` record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `@ManyToMany` annotation indicates that each book can be associated with
    multiple authors. This relationship is bidirectional, meaning authors can also
    be linked to multiple books. In a many-to-many relationship, you need a new cross
    table to link these tables. This is a part of database design, so we will mention
    this feature so as not to surprise you when you view your tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to link `Authors` to `Publisher`. An author may be associated
    with a publisher. This is a many-to-one relationship, as multiple authors can
    be published by the same publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `@ManyToOne` annotation here signifies that each author is linked to one
    publisher, while a publisher can have multiple authors.
  prefs: []
  type: TYPE_NORMAL
- en: The `Publisher` entity remains simple as it does not need to establish a new
    relationship in this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4**.1*, we can see the tables and the relationships between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Database diagram of the tables](img/B18400_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Database diagram of the tables
  prefs: []
  type: TYPE_NORMAL
- en: The tables you can see in the diagram were generated by the Spring Data library
    when we started the application. You can see there is one extra table called `books_authors`.
    This table is for a many-to-many relationship between the `books` and `authors`
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: With this implementation, we have applied a real-world connection between books,
    authors, and publishers in our application.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this section on entity relationships, we have defined complex
    data structures in our online bookstore management system. Next, we will see how
    these relationships work in practical scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing practical CRUD operations in the online bookstore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our complex entity relationships established, let’s see how these are practically
    implemented in the online bookstore management system. We’ll introduce **create,
    read, update, delete** (**CRUD**) operations through REST endpoints, demonstrating
    how the controllers interact with the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create controller classes. Let’s go over the `book` object. You
    can make similar changes for both the `Author` and `Publisher` objects. Or, you
    can check the GitHub repository ([https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-4-1-intorduction-spring-data/src/main/java/com/packt/ahmeric/bookstore/data](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-4-1-intorduction-spring-data/src/main/java/com/packt/ahmeric/bookstore/data))
    for the latest implementation for all three objects.
  prefs: []
  type: TYPE_NORMAL
- en: Developing CRUD endpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we will get our hands dirty to make these objects reachable from outside.
    First off, we need a `Repository` class to manage the entities. This is a basic
    repository class for `book` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This one, single-line class will help us to use so many common methods, such
    as `findAll()`, `save(book)`, and `findById(id)`. This is the power of Spring
    Data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a controller class for the `book` object, we introduce the
    `BookController` class to handle requests related to books. This controller will
    manage operations such as adding a new book, retrieving book details, updating
    book information, and deleting a book.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s introduce a new class named `BookController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple class, you can see new annotations above the class name – `@RestController`
    and `@RequestMapping`. As you’ll remember, we used them in [*Chapter 3*](B18400_03.xhtml#_idTextAnchor064).
    But there is a new annotation here: `@RequiredArgsConstructor`. This annotation
    belongs to Lombok as well. This will create a constructor at compile time, so
    we have a clear class without boilerplate code lines.'
  prefs: []
  type: TYPE_NORMAL
- en: In this sample code, we have two endpoints for creating a book and getting a
    book by ID. These are REST endpoints that accept and return JSON data. And you
    can see we are using default methods from `bookRepository`, such as `findById()`
    and `save()`. We haven’t written them in our `Repository` class. They came from
    the `JpaRepository` extension. The Spring Data JPA repositories, coupled with
    Hibernate, efficiently manage the underlying SQL queries and transactions, abstracting
    the complexities and ensuring smooth data handling. So, we don’t even write a
    single line of code to save an entity in the database. We only use the `save()`
    method instead.
  prefs: []
  type: TYPE_NORMAL
- en: You can see other endpoints for deleting and finding all updates in the GitHub
    repository. If you want, you can create `AuthorController` and `PublisherController`
    similarly for managing authors and publishers.
  prefs: []
  type: TYPE_NORMAL
- en: As we introduced the relationship between the tables, when we add a book with
    its authors, the `books_authors` table will be updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do some curl requests to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Using curl requests for a practical run-through
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Run the Spring Boot application with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will run the following requests in order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a publisher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an author:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have used the `id` of the linked object. For example, when
    we created an author, we linked the author with a publisher with ID 1.
  prefs: []
  type: TYPE_NORMAL
- en: In this practical implementation phase, we have established how to create functional
    endpoints within our controllers to manage books, authors, and publishers within
    the online bookstore. These endpoints interact seamlessly with the PostgreSQL
    database, showing us how powerful and effective it is to use Spring Data within
    a real application.
  prefs: []
  type: TYPE_NORMAL
- en: With this section under our belts, we’re ready to learn about the next step
    in our journey – integrating NoSQL databases with Spring Boot and further extending
    its data management capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases in Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having studied structured SQL databases, we will now delve into NoSQL databases.
    We will see how they are more flexible than SQL databases. In this section, we
    will see how easy it is to implement NoSQL databases within Spring Boot 3.0\.
    We will implement this database connection in our bookstore management system
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the integration of NoSQL databases in Spring Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in our Spring Boot journey, we’ll shift gears and look at the
    integration of NoSQL databases, which are an essential part of a modern application
    stack. Unlike traditional SQL databases, **NoSQL databases** such as MongoDB offer
    a different style of managing data, thus their suitability in this case. Here,
    we’ll gain in the context of Spring Boot not just an understanding of these benefits
    but also learn how to effectively implement them in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases shine for being able to flexibly take care of different data
    types, mostly unstructured or semi-structured. This flexibility gives a great
    advantage to developers who are facing diverse data requirements or even an ever-changing
    data structure. In the world of NoSQL, MongoDB is distinguished as document-oriented,
    which makes it one of the best data storage options for applications that demand
    a scalable and agile data storage platform.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to the integration of NoSQL databases with Spring Boot, the whole
    process is simplified and very easy to accomplish. The way in which Spring Boot
    integrates well with NoSQL databases such as MongoDB literally allows developers
    to plug it into their applications without annoying configurations. This integration
    opens a new world of application development, the prospects of which revolve around
    the potential to build more dynamic, scalable, and efficient applications.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing about that synergy is using NoSQL databases in Spring Boot. The
    philosophy of Spring Boot is to simplify the development of an application, which
    complements NoSQL’s nature, coming with scalability and flexibility. This combination
    is particularly potent for the development of applications that do not only involve
    dealing with complex data structures but must be adaptable to changing demands
    for data.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of our online bookstore management system, integrating a NoSQL
    database such as MongoDB won’t just add a great deal of value to the capabilities
    of the application but will also present a practical example of how these state-of-the-art
    families of technologies can be brought together. We can use MongoDB to integrate
    functions such as user reviews or even personalized recommendations that leverage
    the flexible data modeling that is powered by NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: When we delve into how to integrate NoSQL databases into Spring Boot, we not
    only have yet another tool at our disposal but learn a lot more about the workings
    of various kinds of databases so that we can develop applications that are stronger,
    more flexible, and perform faster. This knowledge is priceless in a landscape
    where the capability to adapt and evolve with modern technological advances remains
    among the key factors of success. In the next sections, we will implement MongoDB
    in our project step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and configuring MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to run a MongoDB on our local machine as we did for PostgreSQL in the
    previous section. Similar to PostgreSQL, MongoDB can be set up in a Docker container,
    ensuring an isolated and consistent database environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an enhanced version of our `docker-compose.yml` file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can also find the same file in the GitHub repository. You can run the `docker-compose
    up` command to run both MongoDB and PostgreSQL at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: After running a MongoDB instance, we need to update the `application.properties`
    file in our resources folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This single configuration line will create a connection between the Spring
    Boot app and MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this simple configuration update, we are ready to connect MongoDB to our
    local machine. In the next section, we will introduce a new object and see how
    our app works with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Review object and its repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did for the `Book`, `Author`, and `Publisher` objects, we need to introduce
    a new object called `Review.class`. You can also check it out in the GitHub repository,
    under the `data` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see the difference from other data objects. There is a new annotation
    here called `@Document`. This annotation refers to the collection of this object.
    So, whatever we put in this object will be written under the `reviews` collection.
    We have just introduced some basic fields a review might need.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, we also need a repository to manage this document in MongoDB. Let’s
    introduce the `ReviewRepository` class under the `repositories` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Now, we can manage the data wherever we want. We are extending from
    `MongoRepository` instead of JPA repository interfaces. This is the only difference
    between `BookRepository` and `AuthorRepository`. So, now we have all CRUD functions
    such as `findById()` and `save()`. Also, this can be customized for more complex
    business requirements. We can start implementing the controller for the `Review`
    object in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a hybrid data model in the online bookstore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our project has now evolved into a hybrid model, integrating both SQL (PostgreSQL)
    and NoSQL (MongoDB) databases. So, let’s expose the `review` object to the REST
    world so we can create and read the reviews in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new controller class in the controller package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no difference between the `BookController` and `ReviewController`
    classes, because we have isolated the database layer from the repository level.
    These two endpoints expose `GET` `review` and `POST` `review` endpoints. You can
    introduce the rest of the CRUD endpoints or you can check out the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do some `curl` requests to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `id` of the record is generated by the `@Id` annotation in the `Review`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is how it looks in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – MongoDB data view](img/B18400_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – MongoDB data view
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we can see how MongoDB tags our object in the `_class` attribute.
    This exploration of NoSQL databases, with a focus on MongoDB, in a Spring Boot
    context has broadened our understanding of managing diverse data types in modern
    applications. By implementing MongoDB in the online bookstore management system,
    we have not only enriched the application with new features but also embraced
    the advantages of a hybrid database approach.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this section, our journey through the data landscape of Spring
    Boot continues. Next, we delve into cache abstraction in Spring Boot, where we
    will explore strategies to optimize application performance. This progression
    from NoSQL databases to caching techniques exemplifies the comprehensive nature
    of data management in Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot cache abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will delve into cache abstraction in Spring Boot. This is
    one of the significant facilitating components for maximizing your application’s
    performance. We’ll see what cache abstraction is, how to do its setup, and finally,
    how to use it in our application. We will show this using our online bookstore
    management system.
  prefs: []
  type: TYPE_NORMAL
- en: Your application will gain from cache abstraction since it sits on top of your
    caching system, remembering the information that is used repeatedly, giving your
    application a faster execution speed. It is similar to placing your frequently
    used tools on top of your desk so you don’t search for them every time. This comes
    with a time gain since your application doesn’t have to keep fetching this information
    over and over again from slow sources such as databases.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see how to add cache abstraction to your Spring Boot application,
    which will make your app run more smoothly. In the above context, caching is what
    can be used to quickly display book details or user reviews that are not changed
    frequently.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this part, you will know how to make your Spring Boot app faster
    with caching. It’s a very nice skill to have in your arsenal for the development
    of better, faster apps.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cache abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, let us dive into understanding cache abstraction in Spring Boot and why
    it is like a superpower for your app’s performance. **Cache abstraction** is just
    storing some pieces of information that your app uses a lot in any application
    in some special memory space. This way, the app does not have to keep asking for
    the same information over and over again – this can be a total bummer.
  prefs: []
  type: TYPE_NORMAL
- en: Using cache abstraction in Spring Boot is pretty simple and carries big dividends.
    For instance, in our online bookstore app, we can use caching to remember the
    details of a book. Normally, every time somebody wants to see a book, the app
    has to ask for the information from the database. With caching, after the application
    has asked for a book’s details, it *remembers* them. And so, the next time somebody
    wants to see that book, the application can show the details super quickly without
    going back to the database. This helps to run your app faster, reduces the load
    on your database, and gives your users an enhanced experience.
  prefs: []
  type: TYPE_NORMAL
- en: Next in this section, we will be looking at how easily caching in Spring Boot
    3.0 can be set up and what difference it can make in your app. We’ll walk through
    some practical steps to integrate caching within our bookstore app in a way that
    shows how it could speed things up even more for features that don’t change often.
    This is one of the key techniques if you want to build efficient and user-friendly
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and using cache abstraction in the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’re going to see how cache abstraction can be implemented
    effortlessly in Spring Boot 3.0, particularly in our bookstore application. Cache
    abstraction is not about the performance boost only but also about making it simple
    for us to handle the frequently accessed data in our applications. That reaches
    a whole new level of simplicity with Spring Boot 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the terms of our bookstore app, effectively using cache abstraction implies
    that often referred to data such as a book’s details are available without hitting
    the database over and over again. This is important in improving user experience
    from two perspectives: reducing the wait time and reducing the server load.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how easy it is to implement caching in Spring Boot 3.0\. There are
    two simple steps to enable caching in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add the library to the `build.gradle` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add `@EnableCaching` on top of our main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s it! We are now ready to use caching wherever we need.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how caching is implemented in the `BookController` class of our
    bookstore app. The controller already has several endpoints – for adding, fetching,
    updating, and deleting books. We’ll focus on integrating Spring Boot’s caching
    capabilities to optimize these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Using @CacheEvict for adding, updating, and deleting books
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a new book is added or an existing one is updated, it’s essential to ensure
    that our cache reflects these changes. The `@CacheEvict` annotation is used here
    to invalidate the cache. This means that the cached data is removed or updated,
    ensuring that subsequent requests fetch the most recent data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what they will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the `addBook` and `updateBook` methods, `@CacheEvict(value = "books", allEntries
    = true)` effectively clears the cache of all entries related to books. This approach
    guarantees that the cache does not serve outdated information.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when a book is deleted, we use `@CacheEvict(value = "books", key
    = "#id")` to remove only the cache entry for that specific book. This targeted
    approach helps us to maintain cache accuracy without affecting other cached data.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient retrieval with caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although not explicitly shown in the provided code, fetching operations (such
    as `getAllBooks` or `getBook`) can be optimized using `@Cacheable`. This annotation
    ensures that the result of a method call is stored in the cache, making subsequent
    requests for the same data faster and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can implement this feature at the repository level. For example, we
    can introduce a query and make it cacheable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need some analyzer to see the difference; just run the application
    and see how you will get a faster response to your second call.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, cache abstraction in Spring Boot 3.0 is a powerful and straightforward
    way to optimize data retrieval processes. We have seen how easy it is to implement
    in the bookstore application. By utilizing cache control annotations such as `@CacheEvict`
    and `@Cacheable`, we ensure that our application remains responsive and efficient
    and always keeps accrual data.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To conclude this exploration of cache abstraction in Spring Boot, we learned
    about the significant advantages it provides us when it is undertaken to enhance
    application performance. We have noticed that caching can bring a lot of improvement
    to the rapid accessing of data, particularly simple repetitive retrieval of information
    such as book details in our online bookstore management system. We have learned
    from the implementation of cache abstraction that it not only drastically reduces
    the load on the database but also delivers a smooth, quick user experience.
  prefs: []
  type: TYPE_NORMAL
- en: This tour through cache abstraction has given us pragmatic tools that are absolutely
    essential in the fast-moving technology environments of today. It is quite evident
    that understanding and using a cache properly is an important key in developing
    efficient and responsive applications with Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will get into the world of batch processing in Spring Boot. We will
    dig deeper into how to efficiently handle huge sets of data, which are commonly
    required for applications that are meant for processing high volumes of records.
    Batch processing is another key tool in our toolkit for getting things done with
    Spring Boot, helping us to manage data at scale from all aspects while ensuring
    our applications cope well without being burdened to the max with complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot batch processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let’s take a look at one of the most important features of Spring Boot:
    batch processing. We’ll look at how you can manage and process huge amounts of
    data in an effective manner with Spring Boot. Batch processing is especially important
    when your application has to handle tasks such as importing big datasets or performing
    actions on a large number of records at once.'
  prefs: []
  type: TYPE_NORMAL
- en: In this part of our guide, we’ll cover three main areas. To begin with, let’s
    discuss batch processing in Spring Boot, why it is so crucial at the very beginning
    of our discussion, and how it can be a game changer for any enterprise or any
    application related to hefty data operations. Next, we’ll walk through the detailed
    setup and execution of batch jobs – a key aspect for efficiently handling large-scale
    data tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but the most interesting, we’ll look at how batch processing can be actually
    implemented in our online bookstore project. Imagine how infeasible it would be
    to have to upload thousands of books or publisher details into the system – batch
    processing would make such a task extremely feasible. If you apply all these concepts
    to the bookstore, you’ll get a real feel of how batch processing works in live
    applications such as book imports in bulk.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you’ll have a solid grasp of batch processing in
    Spring Boot and the power to wield it effectively in real-world use cases. This
    is critical stuff to know, especially when developing web applications that need
    high throughput data management for many purposes. Let’s get started and discover
    how batch processing can enhance the capabilities of our Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of batch processing in Spring Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Batch processing** is a lightweight and very effective way to process large
    amounts of data. It’s sort of like having a super-efficient assembly line in your
    app where big data chores are broken down and processed in manageable batches,
    especially so if your application is to perform heavy-duty work that involves
    processing thousands of records at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: Batch processing in Spring Boot will enable the management of such large-scale
    data operations. It helps in the organizing, executing, and automation of the
    bulk processing of data that is required in many modern-day applications. Most
    batch-processing jobs are continuous processes, not one-time processes. Remember,
    we have to introduce new books, publishers, and authors to our platform every
    week or every day. A batch process will handle it for us automatically in a simple
    way.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn the significance of batch processing in Spring Boot; you will
    be able to handle scenarios that involve handling large amounts of datasets and
    executing them, where the system is not affected. This is an essential skill to
    have for developers working on data-intensive applications and to make sure that
    your app can handle big tasks without seeming to break a sweat. As we proceed,
    you will begin to see how batch processing is implemented and the magnitude of
    the impact it may have on the performance and efficiency of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Spring Batch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After all this theoretical information, we must get our hands dirty to learn
    better.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn how to set up batch processes in Spring Boot 3.0\.
    We’ll introduce a separate batch repository application, showing you step by step
    how to handle tasks such as bulk book imports for our online bookstore.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a batch processing application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by setting up a new Spring Boot project dedicated to batch processing.
    We can use the following dependencies in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have also added a PostgreSQL dependency because we would like to import the
    bulk data into the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Publisher class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to add the `Publisher` class again as it is under the `data` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will deal with the `Publisher` object in batch processing. So, we need the
    same exact object as we used in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a batch job
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s define a batch job in our application. This involves specifying the steps
    the job will take, such as reading data, processing it, and then writing the results.
    Create a package named `config` and create a `BatchConfig.java` file. Everything
    we need will be done in this file.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to understand the flow here. Our sample code will have one job,
    but depending on the requirements, we can define multiple jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a job looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have just a job repository and steps. In our example, we
    have one step, but we may have more than one, depending on the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the `Step` function because it will explain to us how a step
    can be built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a step has a `reader`, `processor`, and `writer` method. The
    functions of these methods are hidden in their names, literally. These functions
    basically read the data, process the data if needed, do some processes on it like
    setting `address` and `name` values, and write it to the repository. Let’s look
    at them one by one in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reading, processing, and writing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each step in the batch job, define how the application will read, process,
    and write data.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, you can see how to read publisher data from a
    **Comma-Separated Values** (**CSV**) file, process it to map it to your publisher
    entity, and then write it to the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In `reader`, we define where to read data and how to parse the data. We also
    map the data to our entity object, and in the `processor` function, we can convert
    it to the required object or objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here is the `processor` function. We can do all the processing steps in this
    function. As an example, I have converted the text to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Finally, this is the `writer` object; it gets the processed data from the processor
    and writes it to the database. In the next step, we will execute our application
    and discuss the output.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the batch job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the batch job is set, it triggers to run either on an event or on a schedule.
    This serves to trigger the job to kick-start the processing and manipulation of
    the big dataset in a very efficient management process of the job task.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a simple CSV file in the `Resources` folder. We can name it
    `publishers.csv`. This name should match the filename in the `reader` function.
    The sample data will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name,address`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Publisher Name` `1,Address 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Publisher Name` `2,Address 2`'
  prefs: []
  type: TYPE_NORMAL
- en: You can write as many rows as you want. And we can run our bookstore batch application.
    We will see these values have been imported into our PostgreSQL database as processed
    (see *Figure 4**.3*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Publishers table after batch operation](img/B18400_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Publishers table after batch operation
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 4**.3*, the values are uppercased while importing.
  prefs: []
  type: TYPE_NORMAL
- en: With such batch processing, this would properly allow managing the large data
    tasks that will come through our online bookstore application. This also makes
    our data handling efficient and subsequently scalable to manage large-scale data
    operations in our database while the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion to our exploration of batch processing in Spring Boot 3.0, we
    gained valuable insights into handling immense datasets efficiently. We have seen
    how doing so not only streamlines the process of breaking up massive data tasks
    into manageable chunks but also helps to make our application perform better.
    Within the context of our online bookstore, batch processing has demonstrated
    how important this feature is in managing large volumes of data, such as bulk
    publisher imports.
  prefs: []
  type: TYPE_NORMAL
- en: On this journey, we learned that batch processing is not just a technical necessity
    but also an important strategic way to handle intelligent data-intensive operations
    in Spring Boot. This insight becomes especially important while working with applications
    that need to process large volumes of data as part of their business workloads,
    in the background periodically and regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we move on to our next section, we are poised to dive into data migration
    and consistency. We’ve seen some powerful strategies for keeping and evolving
    the data structure of our applications without any seams. This is an important
    aspect to make sure that the handling of data by our applications not only remains
    efficient but is more reliable and sturdy over time. So, let’s move forward, geared
    up for new challenges, thereby strengthening our command of these advanced features
    of Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Data migration and consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this critical section, we look at data migration and consistency with Spring
    Boot. We will talk about how we can actually migrate and even amend crucial data
    in our applications without compromising precision or causing problems. We are
    going to detail some strategies for data migration, and we’re specifically going
    to look at tools such as Liquibase, which enables the management and even automation
    of such processes.
  prefs: []
  type: TYPE_NORMAL
- en: Before that, we are going to start with an introduction to data migration strategies
    and offer a view on why these are relevant in order to keep your application healthy.
    Then, we are going to proceed with the practical steps of data migration implementation
    with Liquibase as a core tool. Namely, we will find out how to integrate Liquibase
    into your project and use it for managing database changes.
  prefs: []
  type: TYPE_NORMAL
- en: These strategies will be implemented practically in our online bookstore. We
    will see how we can add new features to the bookstore by applying data migration
    and consistency techniques that could keep the existing data consistent and reliable.
    Let’s get started and unlock the skills to manage data changes smoothly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring data migration strategies and tools like Liquibase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’re going to dive into **data migration strategies**. We
    will focus on understanding their importance and how tools like Liquibase are
    important. **Data migration** is all about moving data from one system to another,
    or from one version of a database to another, in a way that’s safe, efficient,
    and reliable. It’s a vital process, especially when updating or improving your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Liquibase** is a key tool and is like a skilled architect for your data migration.
    It helps manage database revisions, track changes, and apply them consistently
    across different environments. This tool uses a simple format for defining database
    changes, making it easier to track and implement changes over time.'
  prefs: []
  type: TYPE_NORMAL
- en: If we understand and apply the strategies of data migration tools like Liquibase,
    then we will be well placed to handle the evolution of our applications’ requirements
    very effectively.
  prefs: []
  type: TYPE_NORMAL
- en: As we wind up this section, we’re preparing to delve into the world of ensuring
    data consistency that builds on our understanding of migration and how it happens.
    This next topic will focus on techniques used in maintaining data integrity throughout
    data changes, as covered in the previous topic. Stay tuned as we continue to navigate
    the intricate landscape of data management in Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for implementing data migration using Liquibase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to updating or changing your application’s database, data migration
    is a crucial step. In this section, we’ll walk through the practical steps of
    implementing data migration. We will use Liquibase. We will see how it is a powerful
    tool that helps manage database changes.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Liquibase into your project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to add Liquibase to your project. You can open your book
    store application, or you can follow these steps in one of your Spring Boot applications
    to implement Liquibase. As we have been using Gradle since the beginning, we need
    to add a dependency in the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will import all necessary libraries into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Liquibase configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you need to configure Liquibase in your application. This involves specifying
    the database connection properties and the path to your change log file, which
    will contain all the database changes you want to apply. In our application, we
    will update the `application.properties` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we already added our database connection settings here, I am just mentioning
    the line related to Liquibase.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Liquibase change log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The change log file in Liquibase is where you define your database changes,
    such as creating new tables, adding columns, or modifying existing structures.
    Changes are written in XML, JSON, YAML, or SQL format. Here’s our sample in YAML
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the `includeAll` method. It means check the path, sort files
    alphabetically, and start to execute them one by one. There is one more approach,
    in that we can define each file with `include` and Liquibase will follow the orders
    in this file, not the files in the folder.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the migration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the change log file is created, Liquibase has the capability to perform
    such changes on your database. This could be done automatically at the startup
    of the application or manually running Liquibase commands. When execution takes
    place, the change log is read by Liquibase, and then, one by one, the changes
    get executed, as defined in the order in `databaseChangeLog` or alphabetical order
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Following these steps will let you effectively handle such a change in your
    database for your projects and will keep you in control so that the probability
    of making mistakes during migration is reduced. This kind of approach becomes
    critical when we have applications evolving with time – like our online bookstore
    – where data integrity and consistency are paramount in nature.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look into how we can use Liquibase in our bookstore application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing migration strategies in the online bookstore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s apply what we’ve learned about data migration strategies to our online
    bookstore project. This practical implementation will focus on integrating new
    features and maintaining data consistency throughout the process. Let’s assume
    we have a new requirement to add a `published` column in the `books` table. We
    need to handle this requirement without breaking the data and by not touching
    the database server manually. When we need to run our application on another platform,
    we need to be sure we don’t need to do anything manually in the data structure;
    it will be handled by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Liquibase for migration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already introduced the dependency and configuration for Liquibase in
    our bookstore application. Now, we will introduce a change log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a folder named `changes` in `resources/db/changelog/`. This is
    the folder to which Liquibase listens. Then create a file named `001-add-published-column.yaml`.
    Naming is important for two reasons: As we mentioned before, Liquibase will sort
    files alphabetically and execute them accordingly. We need to keep this sorting
    aligned and the latest change always needs to be at the end of the list. The second
    reason is, when we read the filename, we need to understand what it includes.
    Otherwise, when we need to track some changes, it takes ages to find the particular
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample YAML file to add a published column to the `books` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you read the content, you can understand what all these fields mean. Here,
    `author` is the name of the developer who implements this change. It basically
    adds a new column with the name `published` and the default value is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is enough to change the table in the database, but we also need it to
    be aligned in our application by updating our `Book` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, when we fetch or save data, we will manage the database table accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the migration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the change log ready, we run Liquibase to apply these changes. This process
    will create the new column in the books table in our database without disrupting
    existing data. This is done carefully to ensure there is no downtime or loss of
    service for our bookstore’s users.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you check your database, you will see the new column has been created,
    as you can see in *Figure 4**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Updated books table](img/B18400_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Updated books table
  prefs: []
  type: TYPE_NORMAL
- en: As we make these changes, we continuously ensure that data consistency is maintained.
    This involves checking that the new data aligns with the existing data structures
    and follows all the integrity rules.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned now that we should handle the new feature addition in our online
    bookstore carefully. Careful data migration helps the smooth addition of the new
    column to the `books` table, thus maintaining the consistency as well as the reliability
    of the data. This is essential to keep the bookstore up to date and effective
    for users.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have acquired the knowledge and skills to help us manage
    data as required in application development. This prepares us for future challenges
    and hence helps our applications remain relevant in the digital world.
  prefs: []
  type: TYPE_NORMAL
- en: Tools such as Liquibase enable us to change our database safely and efficiently.
    This is important for updating our apps without harming existing features.
  prefs: []
  type: TYPE_NORMAL
- en: These ideas have been applied to the online bookstore, showing how the theory
    works out in practice in real life. It keeps our application accurate as well
    as reliable while growing.
  prefs: []
  type: TYPE_NORMAL
- en: This section was so informative and has given us essential skills and knowledge.
    These are critical to any developer in Spring Boot app development. Moving on,
    these lessons on data management will prove to be a strong foundation. They will
    guide you in developing applications that are not only functional but also have
    sturdy data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we reach the end of this chapter, let’s recap the key learnings and insights
    we’ve gathered. This chapter has been a very deep dive into the world of data
    management with Spring Boot 3.0, covering a broad spectrum of topics that are
    crucial for any developer touching any aspect of this powerful framework. You
    should now have a grasp of the data management features in Spring Boot, as they
    are fundamental to building robust, efficient, and scalable applications. The
    skills acquired after the completion of this chapter are not only elemental to
    backend development but also quite useful when working with the intricacies and
    vagaries posed by modern application development opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we have covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to Spring Data**: We began with the basics of Spring Data, understanding
    how this technology for data access simplifies data access in Spring applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL databases with Spring Data**: We also touched on database integration,
    including PostgreSQL, as well as setting both data sources that are simple and
    that include more than one data source, and how to handle complex relationships
    entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NoSQL databases in Spring Boot**: The chapter guided us through the integration
    of NoSQL databases, specifically MongoDB, pointing out the flexibility and scaling
    up options they present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data migration and consistency**: We delved into strategies for data migration,
    touching on tools such as Liquibase, which comes in handy to ensure the integrity
    of data is not lost during transitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache abstraction in Spring Boot**: This topic really exposed us to cache
    abstraction and raised the point of its importance when seeking to improve the
    performance of an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batch processing in Spring Boot**: We looked at the batch processing concept,
    which is important when it comes to effectively handling large datasets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Practical application**: We practically applied those concepts throughout
    the chapter on a real project, the online bookstore management system, which exhibited
    the concrete implementation of the described data management strategies in Spring
    Boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we conclude this chapter, remember that the learning path and mastery of
    Spring Boot is an ongoing journey. Technology changes are quite frequent and keeping
    up to date with these changes will go a long way in making one effective at developing
    applications. Keep exploring, keep coding, and let the knowledge from this chapter
    be a stepping stone to build more complex and efficient Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18400_05.xhtml#_idTextAnchor179), we will learn about Advanced
    Testing Strategies. This knowledge will help us gain confidence in conducting
    application testing efficiently. We will learn about discovering differences between
    unit and integration tests, testing application reactive components, and securing
    application features. Other than that, implementation will demonstrate broad-based
    comprehension of **Test-Driven Development** (**TDD**) with the Spring Boot ecosystem.
  prefs: []
  type: TYPE_NORMAL
