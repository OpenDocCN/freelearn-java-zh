<html><head></head><body>
		<div id="_idContainer110">
			<h1 id="_idParaDest-248"><em class="italic"><a id="_idTextAnchor247"/>Chapter 11</em>: Network Programming</h1>
			<p>In this chapter, we will describe and discuss the most popular network protocols – <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>), <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>), <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>), and <strong class="bold">WebSocket</strong> – and their support from the <strong class="bold">Java Class Library</strong> (<strong class="bold">JCL</strong>). We will demonstrate how to use these protocols and how to implement client-server communication in Java code. We will also review <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>)-based communication and the latest <strong class="bold">Java HTTP Client API</strong>. After studying this chapter, you will be able to create server and client applications that communicate using the <strong class="bold">UDP</strong>, <strong class="bold">TCP</strong>, and <strong class="bold">HTTP</strong> protocols as well as <strong class="bold">WebSocket</strong>.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Network protocols</li>
				<li>UDP-based communication</li>
				<li>TCP-based communication</li>
				<li>UDP versus TCP protocols</li>
				<li>URL-based communication</li>
				<li>Using the HTTP 2 Client API</li>
				<li>Creating a standalone application HTTP server</li>
			</ul>
			<p>By the end of the chapter, you will be able to use all the most popular protocols to send/receive messages between the client and server. You will also learn how to create a server as a separate project and how to create and use a common shared library. </p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor248"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or code editor of your choosing</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, of this book. The files with the code examples for this chapter are available on GitHub in the <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> repository, in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch11_network</strong> folder, and in the <strong class="source-inline">common</strong> and <strong class="source-inline">server</strong> folders, as separate projects.</p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor249"/>Network protocols</h1>
			<p>Network programming<a id="_idIndexMarker1225"/> is a vast area. The <strong class="bold">internet protocol</strong> (<strong class="bold">IP</strong>) suite consists of four<a id="_idIndexMarker1226"/> layers, each of which has a dozen or more protocols:</p>
			<ul>
				<li><strong class="bold">The link layer</strong>: The group of protocols<a id="_idIndexMarker1227"/> used when a client<a id="_idIndexMarker1228"/> is physically connected<a id="_idIndexMarker1229"/> to the host; three core<a id="_idIndexMarker1230"/> protocols include the <strong class="bold">Address Resolution Protocol</strong> (<strong class="bold">ARP</strong>), the <strong class="bold">Reverse Address Resolution</strong> <strong class="bold">Protocol</strong> (<strong class="bold">RARP</strong>), and the <strong class="bold">Neighbor Discovery Protocol</strong> (<strong class="bold">NDP</strong>).</li>
				<li><strong class="bold">The internet layer</strong>: The group of inter-networking<a id="_idIndexMarker1231"/> methods, protocols, and specifications used to transport network packets from the originating<a id="_idIndexMarker1232"/> host to the destination host, specified by an IP address. The core protocols of this layer are <strong class="bold">Internet Protocol version 4</strong> (<strong class="bold">IPv4</strong>) and <strong class="bold">Internet Protocol version 6</strong> (<strong class="bold">IPv6</strong>); IPv6 specifies a new packet<a id="_idIndexMarker1233"/> format and allocates 128 bits for the dotted IP address, compared to 32 bits in IPv4. An example of an IPv4 address is <strong class="source-inline">10011010.00010111.11111110.00010001</strong>, which results in an IP address of <strong class="source-inline">154.23.254.17</strong>. The examples in this chapter use IPv4. The industry, though, is slowly switching to IPv6. An example of an IPv6 address is <strong class="source-inline">594D:1A1B:2C2D:3E3F:4D4A:5B5A:6B4E:7FF2</strong>.</li>
				<li><strong class="bold">The transport layer</strong>: The group of host-to-host communication services. It includes<a id="_idIndexMarker1234"/> TCP, also<a id="_idIndexMarker1235"/> known as the TCP/IP protocol, and UDP (which we are going to discuss shortly). The<a id="_idIndexMarker1236"/> other protocols in<a id="_idIndexMarker1237"/> this group are the <strong class="bold">Datagram Congestion Control Protocol</strong> (<strong class="bold">DCCP</strong>) and the <strong class="bold">Stream Control Transmission Protocol</strong> (<strong class="bold">SCTP</strong>).</li>
				<li><strong class="bold">The application layer</strong>: The group<a id="_idIndexMarker1238"/> of protocols<a id="_idIndexMarker1239"/> and<a id="_idIndexMarker1240"/> interface<a id="_idIndexMarker1241"/> methods<a id="_idIndexMarker1242"/> used by<a id="_idIndexMarker1243"/> hosts<a id="_idIndexMarker1244"/> in a<a id="_idIndexMarker1245"/> communication<a id="_idIndexMarker1246"/> network. It includes <strong class="bold">Telnet</strong>, <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>), <strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>), <strong class="bold">Simple Mail Transfer Protocol</strong> (<strong class="bold">SMTP</strong>), <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>), <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>), <strong class="bold">Hypertext Transfer Protocol Secure</strong> (<strong class="bold">HTTPS</strong>), and <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>).</li>
			</ul>
			<p>The link layer is the lowest layer; it is used by the internet layer, which is, in turn, used by the transport layer. This transport layer is then used by the application layer in support of the protocol implementations.</p>
			<p>For security reasons, Java does not provide<a id="_idIndexMarker1247"/> access to the protocols of the link layer and the internet layer. This means that Java does not allow you to create custom transport protocols that, for example, serve as an alternative to TCP/IP. That is why, in this chapter, we will review only the protocols of the transport layer (TCP and UDP) and the application layer (HTTP). We will explain and demonstrate how Java supports them and how a Java application can take advantage of this support.</p>
			<p>Java supports the TCP and UDP protocols with classes of the <strong class="source-inline">java.net</strong> package, while the HTTP protocol can be implemented in the Java application using the classes of the <strong class="source-inline">java.net.http</strong> package (which was introduced with Java 11).</p>
			<p>Both the TCP and UDP protocols can be implemented in Java using <em class="italic">sockets</em>. Sockets<a id="_idIndexMarker1248"/> are identified by a combination of an IP address and a port number, and they represent a connection<a id="_idIndexMarker1249"/> between two applications. Since the UDP protocol is somewhat simpler than the TCP protocol, we’ll start with UDP.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor250"/>UDP-based communication</h1>
			<p>The UDP protocol<a id="_idIndexMarker1250"/> was designed by David P. Reed in 1980. It allows applications to<a id="_idIndexMarker1251"/> send messages called <strong class="bold">datagrams</strong> using a simple connectionless communication<a id="_idIndexMarker1252"/> model with a minimal protocol mechanism such as a checksum, for data integrity. It has no handshaking dialogs and, thus, does not guarantee message delivery or preserve the order of messages. It is suitable for those cases when dropping messages or mixing up orders are preferred instead of waiting for retransmission.</p>
			<p>A datagram is represented by the <strong class="source-inline">java.net.DatagramPacket</strong> class. An object of this class can be created using one of the six constructors; the following two constructors are the most commonly used:</p>
			<ul>
				<li><strong class="source-inline">DatagramPacket(byte[] buffer, int length)</strong>: This constructor creates a datagram packet and is used to receive the packets; <strong class="source-inline">buffer</strong> holds the incoming datagram, while <strong class="source-inline">length</strong> is the number of bytes to be read.</li>
				<li><strong class="source-inline">DatagramPacket(byte[] buffer, int length, InetAddress address, int port)</strong>: This creates a datagram packet and is used to send the packets; <strong class="source-inline">buffer</strong> holds the packet data, <strong class="source-inline">length</strong> is the packet data length, <strong class="source-inline">address</strong> holds the destination IP address, and <strong class="source-inline">port</strong> is the destination port number.</li>
			</ul>
			<p>Once constructed, the <strong class="source-inline">DatagramPacket</strong> object exposes the following methods that can be used to extract data from the object or set/get its properties:</p>
			<ul>
				<li><strong class="source-inline">void setAddress(InetAddress iaddr)</strong>: This sets the destination IP address.</li>
				<li><strong class="source-inline">InetAddress getAddress()</strong>: This returns the destination or source IP address.</li>
				<li><strong class="source-inline">void setData(byte[] buf)</strong>: This sets the data buffer.</li>
				<li><strong class="source-inline">void setData(byte[] buf, int offset, int length)</strong>: This sets the data<a id="_idIndexMarker1253"/> buffer, data offset, and<a id="_idIndexMarker1254"/> length.</li>
				<li><strong class="source-inline">void setLength(int length)</strong>: This sets the length for the packet.</li>
				<li><strong class="source-inline">byte[] getData()</strong>: This returns the data buffer.</li>
				<li><strong class="source-inline">int getLength()</strong>: This returns the length of the packet that is to be sent or received.</li>
				<li><strong class="source-inline">int getOffset()</strong>: This returns the offset of the data that is to be sent or received.</li>
				<li><strong class="source-inline">void setPort(int port)</strong>: This sets the destination port number.</li>
				<li><strong class="source-inline">int getPort()</strong>: This returns the port number where data is to be sent or received from. Once a <strong class="source-inline">DatagramPacket</strong> object is created, it can be sent or received using the <strong class="source-inline">DatagramSocket</strong> class, which represents a connectionless socket for sending and receiving datagram packets. An object of this class can be created using one of six constructors; the following three constructors are the most commonly used:<ul><li><strong class="source-inline">DatagramSocket()</strong>: This creates a datagram socket and binds it to any available port on the local host machine. It is typically used to create a sending socket because the destination address (and port) can be set inside the packet (see the preceding <strong class="source-inline">DatagramPacket</strong> constructors and methods).</li><li><strong class="source-inline">DatagramSocket(int port)</strong>: This creates a datagram socket and binds it to the specified port on the local host machine. It is used to create<a id="_idIndexMarker1255"/> a receiving socket when any local machine address (called a <strong class="bold">wildcard address</strong>) is good enough.</li><li><strong class="source-inline">DatagramSocket(int port, InetAddress address)</strong>: This creates a datagram socket and binds it to the specified port and the specified local address; the local port must be between <strong class="source-inline">0</strong> and <strong class="source-inline">65535</strong>. It is used to create a receiving socket when a particular local machine address needs to be bound.</li></ul></li>
			</ul>
			<p>The following two methods<a id="_idIndexMarker1256"/> of the <strong class="source-inline">DatagramSocket</strong> object are the most commonly used for sending<a id="_idIndexMarker1257"/> and receiving messages (or packets):</p>
			<ul>
				<li><strong class="source-inline">void send(DatagramPacket p)</strong>: This sends the specified packet.</li>
				<li><strong class="source-inline">void receive(DatagramPacket p)</strong>: This receives a packet by filling the specified <strong class="source-inline">DatagramPacket</strong> object’s buffer with the data received. The specified <strong class="source-inline">DatagramPacket</strong> object also contains the sender’s IP address and the port number on the sender’s machine.</li>
			</ul>
			<p>Let’s take a look at a code example. Here is the UDP message receiver that exits after the message has been received:</p>
			<pre class="source-code">public class UdpReceiver {</pre>
			<pre class="source-code">  public static void main(String[] args){</pre>
			<pre class="source-code">    try(DatagramSocket ds = new DatagramSocket(3333)){</pre>
			<pre class="source-code">       DatagramPacket dp = </pre>
			<pre class="source-code">                          new DatagramPacket(new byte[16], 16);</pre>
			<pre class="source-code">       ds.receive(dp);</pre>
			<pre class="source-code">       for(byte b: dp.getData()){</pre>
			<pre class="source-code">           System.out.print(Character.toString(b));</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">    } catch (Exception ex){</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the receiver<a id="_idIndexMarker1258"/> is listening for a text<a id="_idIndexMarker1259"/> message (it interprets each byte as a character) on any address of the local machine on port <strong class="source-inline">3333</strong>. It uses a buffer of 16 bytes only; as soon as the buffer is filled with the received data, the receiver prints its content and exits.</p>
			<p>Here is an example of the UDP message sender:</p>
			<pre class="source-code">public class UdpSender {</pre>
			<pre class="source-code">  public static void main(String[] args) {</pre>
			<pre class="source-code">    try(DatagramSocket ds = new DatagramSocket()){</pre>
			<pre class="source-code">       String msg = "Hi, there! How are you?";</pre>
			<pre class="source-code">       InetAddress address = </pre>
			<pre class="source-code">                            InetAddress.getByName("127.0.0.1");</pre>
			<pre class="source-code">       DatagramPacket dp = new DatagramPacket(msg.getBytes(), </pre>
			<pre class="source-code">                                  msg.length(), address, 3333);</pre>
			<pre class="source-code">       ds.send(dp);</pre>
			<pre class="source-code">    } catch (Exception ex){</pre>
			<pre class="source-code">        ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the sender constructs a packet with the message, the local machine address, and the same port as the one that the receiver uses. After the constructed packet is sent, the sender exits.</p>
			<p>We can run the sender now, but without the receiver running, there is nobody to get the message. So, we’ll start the receiver first. It listens on port <strong class="source-inline">3333</strong>, but there is no message coming – so it waits. Then, we run the sender and the receiver displays the following message:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B18388_Figure_11.1.jpg" alt=""/>
				</div>
			</div>
			<p>Since the buffer is smaller than<a id="_idIndexMarker1260"/> the message, it was only partially received – the rest of the message is lost. That’s why we<a id="_idIndexMarker1261"/> increase the buffer size to 30. Also, we can create an infinite loop and let the receiver run indefinitely (see the <strong class="source-inline">UdpReceiver2</strong> class):</p>
			<pre class="source-code">public class UdpReceiver2 {</pre>
			<pre class="source-code"> public static void main(String[] args){</pre>
			<pre class="source-code">    try(DatagramSocket ds = new DatagramSocket(3333)){</pre>
			<pre class="source-code">       DatagramPacket dp = </pre>
			<pre class="source-code">                          new DatagramPacket(new byte[30], 30);</pre>
			<pre class="source-code">       while(true){</pre>
			<pre class="source-code">          ds.receive(dp);</pre>
			<pre class="source-code">          for(byte b: dp.getData()){</pre>
			<pre class="source-code">              System.out.print(Character.toString(b));</pre>
			<pre class="source-code">          }</pre>
			<pre class="source-code">          System.out.println(); //added here to have end-of-</pre>
			<pre class="source-code">             // line after receiving (and printing) the message</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">    } catch (Exception ex){</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>By doing so, we can run the sender several times. Here is what the receiver <strong class="source-inline">UdpReceiver2</strong> prints if we run the sender three times:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B18388_Figure_11.2.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, all three messages are received. If you run the receiver <strong class="source-inline">UdpReceiver2</strong>, do not forget to stop it manually after you don’t need to run it anymore. Otherwise, it continues running indefinitely.</p>
			<p>So, this is the basic idea of the UDP protocol. The sender sends a message to a certain address and port even if no socket <em class="italic">listens</em> on this address and port. It does not require establishing any kind of connection before sending the message, which makes the UDP protocol faster and more lightweight than the TCP protocol (which requires you to establish the connection first). This way, the TCP protocol<a id="_idIndexMarker1262"/> takes message sending to another level of reliability by making<a id="_idIndexMarker1263"/> sure that the destination exists and that the message can be delivered.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor251"/>TCP-based communication</h1>
			<p>TCP was designed by the <strong class="bold">Defense Advanced Research Projects Agency</strong> (<strong class="bold">DARPA</strong>) in the 1970s for use in the <strong class="bold">Advanced Research Projects Agency Network</strong> (<strong class="bold">ARPANET</strong>). It complements IP and, thus, is also referred to as TCP/IP. The TCP<a id="_idIndexMarker1264"/> protocol, even<a id="_idIndexMarker1265"/> by its name, indicates that it provides<a id="_idIndexMarker1266"/> reliable (that is, error-checked or controlled) data<a id="_idIndexMarker1267"/> transmission. It allows<a id="_idIndexMarker1268"/> the ordered delivery of bytes in an IP network and is widely used by the web, email, secure shell, and file transfer. </p>
			<p>An application that uses TCP/IP is not even aware of all the handshaking that takes place between the socket and the transmission details – such as network congestion, traffic load balancing, duplication, and even the loss of some IP packets. The underlying protocol implementation of the transport layer detects these problems, resends the data, reconstructs the order of the sent packets, and minimizes network congestion. </p>
			<p>In contrast to the UDP protocol, TCP/IP-based communication is focused on accurate delivery at the expense of the delivery period. That’s why it is not used for real-time applications, such as voice over IP, where reliable delivery and correct sequential ordering are required. However, if every bit needs to arrive exactly as it was sent and in the same sequence, then TCP/IP is irreplaceable. </p>
			<p>To support such behavior, TCP/IP communication maintains a session throughout the communication. The session is identified by the client address and port. Each session is represented by an entry in a table on the server. This contains all the metadata about the session: the client IP address and port, the connection status, and the buffer parameters. However, these details are usually hidden from the application developer, so we won’t go into any more detail here. Instead, we will turn to the Java code.</p>
			<p>Similar to the UDP protocol, the TCP/IP protocol<a id="_idIndexMarker1269"/> implementation in Java uses<a id="_idIndexMarker1270"/> sockets. But instead of the <strong class="source-inline">java.net.DatagramSocket</strong> class that implements the UDP protocol, the TCP/IP-based sockets are represented by the <strong class="source-inline">java.net.ServerSocket</strong> and <strong class="source-inline">java.net.Socket</strong> classes. They allow messages to be sent and received between two applications, one of them being a server and the other a client.</p>
			<p>The <strong class="source-inline">ServerSocket</strong> and <strong class="source-inline">SocketClass</strong> classes perform very similar jobs. The only difference is that the <strong class="source-inline">ServerSocket</strong> class has the <strong class="source-inline">accept()</strong> method, which <em class="italic">accepts</em> the request from the client. This means that the server has to be up and ready to receive the request first. Then, the connection is initiated by the client that creates its own socket that sends the connection request (from the constructor of the <strong class="source-inline">Socket</strong> class). The server then accepts the request and creates a local socket connected to the remote socket (on the client side).</p>
			<p>After establishing the connection, data transmission can occur using I/O streams as described in <a href="B18388_05_ePub.xhtml#_idTextAnchor121"><em class="italic">Chapter 5</em></a>, <em class="italic">Strings, Input/Output, and Files</em>. The <strong class="source-inline">Socket</strong> object has the <strong class="source-inline">getOutputStream()</strong> and <strong class="source-inline">getInputStream()</strong> methods that provide access to the socket’s data streams. Data from the <strong class="source-inline">java.io.OutputStream</strong> object on the local computer appears as coming from the <strong class="source-inline">java.io.InputStream</strong> object on the remote machine.</p>
			<p>Let’s now take a closer look at the <strong class="source-inline">java.net.ServerSocket</strong> and <strong class="source-inline">java.net.Socket</strong> classes and then run some examples of their usage.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor252"/>The java.net.ServerSocket class</h2>
			<p>The <strong class="source-inline">java.net.ServerSocket</strong> class has<a id="_idIndexMarker1271"/> four<a id="_idIndexMarker1272"/> constructors:</p>
			<ul>
				<li><strong class="source-inline">ServerSocket()</strong>: This creates a server socket<a id="_idIndexMarker1273"/> object that is not bound to a particular address and port. It requires the use of the <strong class="source-inline">bind()</strong> method to bind the socket.</li>
				<li><strong class="source-inline">ServerSocket(int port)</strong>: This creates a server socket object bound to the provided port. The <strong class="source-inline">port</strong> value must be between <strong class="source-inline">0</strong> and <strong class="source-inline">65535</strong>. If the port number is specified as a value of <strong class="source-inline">0</strong>, this means that the port number needs to be bound automatically. This port <a id="_idIndexMarker1274"/>number can then be retrieved by calling <strong class="source-inline">getLocalPort()</strong>. By default, the maximum queue length for incoming connections is <strong class="source-inline">50</strong>. This means that the maximum parallel incoming connections are <strong class="source-inline">50</strong> by default. Exceeding connections will be refused.</li>
				<li><strong class="source-inline">ServerSocket(int port, int backlog)</strong>: This provides the same functionality as the <strong class="source-inline">ServerSocket(int port)</strong> constructor and allows you to set the maximum queue length for incoming connections by means of the <strong class="source-inline">backlog</strong> parameter.</li>
				<li><strong class="source-inline">ServerSocket(int port, int backlog, InetAddress bindAddr)</strong>: This creates a server socket object that is similar to the preceding constructor, but also bound to the IP address provided. When the <strong class="source-inline">bindAddr</strong> value is <strong class="source-inline">null</strong>, it will default to accepting connections on any or all local addresses.</li>
			</ul>
			<p>The following four methods<a id="_idIndexMarker1275"/> of the <strong class="source-inline">ServerSocket</strong> class are the most commonly used, and they are essential for establishing a socket’s connection:</p>
			<ul>
				<li><strong class="source-inline">void bind(SocketAddress endpoint)</strong>: This binds the <strong class="source-inline">ServerSocket</strong> object to a specific IP address and port. If the provided address is <strong class="source-inline">null</strong>, then the system will pick up a port and a valid local address automatically (which can be later retrieved using the <strong class="source-inline">getLocalPort()</strong>, <strong class="source-inline">getLocalSocketAddress()</strong>, and <strong class="source-inline">getInetAddress()</strong> methods). Additionally, if the <strong class="source-inline">ServerSocket</strong> object was created by the constructor without any parameters, then this method, or the following <strong class="source-inline">bind()</strong> method, needs to be invoked before a connection can be established.</li>
				<li><strong class="source-inline">void bind(SocketAddress endpoint, int backlog)</strong>: This acts in a similar way to the preceding method; the <strong class="source-inline">backlog</strong> argument is the maximum number of pending connections on the socket (that is, the size of the queue). If the <strong class="source-inline">backlog</strong> value is less than or equal to <strong class="source-inline">0</strong>, then an implementation-specific default will be used.</li>
				<li><strong class="source-inline">void setSoTimeout(int timeout)</strong>: This sets the value (in milliseconds) of how long the<a id="_idIndexMarker1276"/> socket waits for a client after the <strong class="source-inline">accept()</strong> method<a id="_idIndexMarker1277"/> is called. If the client has not called and the timeout expires, a <strong class="source-inline">java.net.SocketTimeoutException</strong> exception is thrown, but the <strong class="source-inline">ServerSocket</strong> object remains valid and can be reused. The <strong class="source-inline">timeout</strong> value of <strong class="source-inline">0</strong> is interpreted as an infinite timeout (the <strong class="source-inline">accept()</strong> method blocks until a client calls).</li>
				<li><strong class="source-inline">Socket accept()</strong>: This blocks until a client calls or the timeout period (if set) expires.</li>
			</ul>
			<p>Other methods of the class allow you to set<a id="_idIndexMarker1278"/> or get other properties of the <strong class="source-inline">Socket</strong> object and they can be used for better dynamic management of the socket connection. You can refer to the online documentation of the class to understand the available options in more detail.</p>
			<p>The following code is an example of a server implementation using the <strong class="source-inline">ServerSocket</strong> class:</p>
			<pre class="source-code">public class TcpServer {</pre>
			<pre class="source-code">  public static void main(String[] args){</pre>
			<pre class="source-code">    try(Socket s = new ServerSocket(3333).accept();</pre>
			<pre class="source-code">      DataInputStream dis = </pre>
			<pre class="source-code">                      new DataInputStream(s.getInputStream());</pre>
			<pre class="source-code">      DataOutputStream dout = </pre>
			<pre class="source-code">                     new DataOutputStream(s.getOutputStream());</pre>
			<pre class="source-code">      BufferedReader console = </pre>
			<pre class="source-code">        new BufferedReader(new InputStreamReader(System.in))){</pre>
			<pre class="source-code">        while(true){</pre>
			<pre class="source-code">           String msg = dis.readUTF();</pre>
			<pre class="source-code">           System.out.println("Client said: " + msg);</pre>
			<pre class="source-code">           if("end".equalsIgnoreCase(msg)){</pre>
			<pre class="source-code">               break;</pre>
			<pre class="source-code">           }</pre>
			<pre class="source-code">           System.out.print("Say something: ");</pre>
			<pre class="source-code">           msg = console.readLine();</pre>
			<pre class="source-code">           dout.writeUTF(msg);</pre>
			<pre class="source-code">           dout.flush();</pre>
			<pre class="source-code">           if("end".equalsIgnoreCase(msg)){</pre>
			<pre class="source-code">               break;</pre>
			<pre class="source-code">           }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    } catch(Exception ex) {</pre>
			<pre class="source-code">      ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Let’s walk through the preceding code. In the try-with-resources statement, we create <strong class="source-inline">Socket</strong>, <strong class="source-inline">DataInputStream</strong>, and <strong class="source-inline">DataOutputStream</strong> objects based on our newly created socket, and the <strong class="source-inline">BufferedReader</strong> object to read the user input from the console (we will use it to enter the data). While creating the socket, the <strong class="source-inline">accept()</strong> method blocks until a client tries to connect to port <strong class="source-inline">3333</strong> of the local server. </p>
			<p>Then, the code enters an infinite loop. First, it reads the bytes sent by the client as a Unicode character string encoded in a modified UTF-8 format by using the <strong class="source-inline">readUTF()</strong> method of <strong class="source-inline">DataInputStream</strong>. The result is printed with the <strong class="source-inline">"Client said: "</strong> prefix. If the received message is an <strong class="source-inline">"end"</strong> string, then the code exits the loop and the server’s program exits. If the message is not <strong class="source-inline">"end"</strong>, then the <strong class="source-inline">"Say something: "</strong> prompt is displayed on the console and the <strong class="source-inline">readLine()</strong> method blocks until a user types something and clicks <em class="italic">Enter</em>. </p>
			<p>The server takes the input from the screen and writes it as a Unicode character string to the output stream using the <strong class="source-inline">writeUtf()</strong> method. As we mentioned already, the output stream of the server is connected to the input stream of the client. If the client reads from the input stream, it receives the message sent by the server. If the sent message is <strong class="source-inline">"end"</strong>, then the sever exits the loop and the program. If not, then the loop body is executed again.</p>
			<p>The described algorithm<a id="_idIndexMarker1279"/> assumes that the client exits only<a id="_idIndexMarker1280"/> when it sends or receives the <strong class="source-inline">"end"</strong> message. Otherwise, the client generates an exception if it tries to send a message to the server afterward. This demonstrates the difference between the UDP and TCP protocols that we mentioned already – TCP is based on the session that is established between the server and client sockets. If one side drops it, the other side immediately encounters an error.</p>
			<p>Now, let’s review an example of a TCP-client implementation.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/>The java.net.Socket class</h2>
			<p>The <strong class="source-inline">java.net.Socket</strong> class should now be familiar to you<a id="_idIndexMarker1281"/> since it was used<a id="_idIndexMarker1282"/> in the preceding example. We used it to access the input and output streams of the connected sockets. Now we are going to review the <strong class="source-inline">Socket</strong> class systematically and explore how it can be used to create a TCP client. The <strong class="source-inline">Socket</strong> class has five constructors:</p>
			<ul>
				<li><strong class="source-inline">Socket()</strong>: This creates<a id="_idIndexMarker1283"/> an unconnected socket. It uses the <strong class="source-inline">connect()</strong> method to establish a connection of this socket with a socket on a server.</li>
				<li><strong class="source-inline">Socket(String host, int port)</strong>: This creates a socket and connects it to the provided port on the <strong class="source-inline">host</strong> server. If it throws an exception, the connection to the server<a id="_idIndexMarker1284"/> is not established; otherwise; you can start sending data to the server.</li>
				<li><strong class="source-inline">Socket(InetAddress address, int port)</strong>: This acts similarly to the preceding constructor, except that the host is provided as an <strong class="source-inline">InetAddress</strong> object.</li>
				<li><strong class="source-inline">Socket(String host, int port, InetAddress localAddr, int localPort)</strong>: This works similarly to the preceding constructor, except that it also allows you to bind the socket to the provided local address and port (if the program is run on a machine with multiple IP addresses). If the provided <strong class="source-inline">localAddr</strong> value is <strong class="source-inline">null</strong>, any local address is selected. Alternatively, if the provided <strong class="source-inline">localPort</strong> value is <strong class="source-inline">null</strong>, then the system picks up a free port in the bind operation.</li>
				<li><strong class="source-inline">Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</strong>: This acts similarly to the preceding constructor, except that the local address is provided as an <strong class="source-inline">InetAddress</strong> object.</li>
			</ul>
			<p>Here are the following two methods of the <strong class="source-inline">Socket</strong> class<a id="_idIndexMarker1285"/> that we have used already:</p>
			<ul>
				<li><strong class="source-inline">InputStream getInputStream()</strong>: This returns an object that represents the source (the remote socket) and brings the data (inputs them) into the program (the local socket).</li>
				<li><strong class="source-inline">OutputStream getOutputStream()</strong>: This returns an object that represents<a id="_idIndexMarker1286"/> the source (the local socket) and sends the data (outputs them) to a remote socket.</li>
			</ul>
			<p>Let’s now examine the TCP-client code, as follows:</p>
			<pre class="source-code">public class TcpClient {</pre>
			<pre class="source-code">  public static void main(String[] args) {</pre>
			<pre class="source-code">    try(Socket s = new Socket("localhost",3333);</pre>
			<pre class="source-code">      DataInputStream dis = </pre>
			<pre class="source-code">                       new DataInputStream(s.getInputStream());</pre>
			<pre class="source-code">      DataOutputStream dout = </pre>
			<pre class="source-code">                     new DataOutputStream(s.getOutputStream());</pre>
			<pre class="source-code">      BufferedReader console = </pre>
			<pre class="source-code">         new BufferedReader(new InputStreamReader(System.in))){</pre>
			<pre class="source-code">         String prompt = "Say something: ";</pre>
			<pre class="source-code">         System.out.print(prompt);</pre>
			<pre class="source-code">         String msg;</pre>
			<pre class="source-code">         while ((msg = console.readLine()) != null) {</pre>
			<pre class="source-code">             dout.writeUTF( msg);</pre>
			<pre class="source-code">             dout.flush();</pre>
			<pre class="source-code">             if (msg.equalsIgnoreCase("end")) {</pre>
			<pre class="source-code">                 break;</pre>
			<pre class="source-code">             }</pre>
			<pre class="source-code">             msg = dis.readUTF();</pre>
			<pre class="source-code">             System.out.println("Server said: " +msg);</pre>
			<pre class="source-code">             if (msg.equalsIgnoreCase("end")) {</pre>
			<pre class="source-code">                 break;</pre>
			<pre class="source-code">             }</pre>
			<pre class="source-code">             System.out.print(prompt);</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">    } catch(Exception ex){</pre>
			<pre class="source-code">          ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>The preceding <strong class="source-inline">TcpClient</strong> code looks almost exactly the same as the <strong class="source-inline">TcpServer</strong> code we reviewed. The only principal difference is that the <strong class="source-inline">new Socket("localhost", 3333)</strong> constructor attempts to establish a connection with the <strong class="source-inline">"localhost:3333"</strong> server immediately, so it expects that the <strong class="source-inline">localhost</strong> server is up and listening on port <strong class="source-inline">3333</strong>; the rest is the same as the server code.</p>
			<p>Therefore, the only reason we need to use the <strong class="source-inline">ServerSocket</strong> class is to allow the server to run while waiting for the client to connect to it; everything else can be done using only the <strong class="source-inline">Socket</strong> class.</p>
			<p>Other methods of the <strong class="source-inline">Socket</strong> class allow you <a id="_idIndexMarker1287"/>to set or get other properties of the <strong class="source-inline">socket</strong> object, and they<a id="_idIndexMarker1288"/> can be used for better dynamic management of the socket connection. You can read the online documentation of the class to understand the available options in more detail.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor254"/>Running the examples</h2>
			<p>Let’s now run<a id="_idIndexMarker1289"/> the <strong class="source-inline">TcpServer</strong> and <strong class="source-inline">TcpClient</strong> programs. If we<a id="_idIndexMarker1290"/> start <strong class="source-inline">TcpClient</strong> first, we get <strong class="source-inline">java.net.ConnectException</strong> with the <strong class="bold">Connection refused</strong> message. So, we launch the <strong class="source-inline">TcpServer</strong> program first. When it starts, no messages are displayed. Instead, it just waits until the client connects. So, we then start <strong class="source-inline">TcpClient</strong> and see the following message on the screen:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B18388_Figure_11.3.jpg" alt=""/>
				</div>
			</div>
			<p>We type <strong class="source-inline">Hello!</strong> and then press <em class="italic">Enter</em>:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B18388_Figure_11.4.jpg" alt=""/>
				</div>
			</div>
			<p>Now let’s look at the server-side screen:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B18388_Figure_11.5.jpg" alt=""/>
				</div>
			</div>
			<p>We type <strong class="source-inline">Hi!</strong> on the server-side screen and press <em class="italic">Enter</em>:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B18388_Figure_11.6.jpg" alt=""/>
				</div>
			</div>
			<p>On the client-side screen, we see the following messages:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B18388_Figure_11.7.jpg" alt=""/>
				</div>
			</div>
			<p>We can continue this dialog indefinitely until the server or the client sends the message <strong class="source-inline">end</strong>. Let’s make the client do it; the client says <strong class="source-inline">end</strong> and then exits:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B18388_Figure_11.8.jpg" alt=""/>
				</div>
			</div>
			<p>Then, the server follows suit:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B18388_Figure_11.9.jpg" alt=""/>
				</div>
			</div>
			<p>That’s all we wanted<a id="_idIndexMarker1291"/> to demonstrate while<a id="_idIndexMarker1292"/> discussing the TCP protocol. Now let’s review the differences between the UDP and TCP protocols.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor255"/>UDP versus TCP protocols</h1>
			<p>The differences between<a id="_idIndexMarker1293"/> the UDP and TCP/IP protocols<a id="_idIndexMarker1294"/> can be listed as follows:</p>
			<ul>
				<li>UDP simply sends data, whether the data receiver is up and running or not. That’s why UDP is better suited to sending data compared to many other clients using multicast distribution. TCP, on the other hand, requires establishing the connection between the client and the server first. The TCP client sends a special control message; the server receives it and responds with a confirmation. The client then sends a message to the server that acknowledges the server confirmation. Only after this is data transmission between the client and server possible. </li>
				<li>TCP guarantees message delivery or raises an error, while UDP does not, and a datagram packet may be lost.</li>
				<li>TCP guarantees the preservation of the order of messages on delivery, while UDP does not.</li>
				<li>As a result of these provided guarantees, TCP is slower than UDP. </li>
				<li>Additionally, protocols require headers to be sent along with the packet. The header size of a TCP packet is 20 bytes, while a datagram packet is 8 bytes. The UDP header contains <strong class="source-inline">Length</strong>, <strong class="source-inline">Source Port</strong>, <strong class="source-inline">Destination Port</strong>, and <strong class="source-inline">Checksum</strong>, while the TCP header contains <strong class="source-inline">Sequence Number</strong>, <strong class="source-inline">Ack Number</strong>, <strong class="source-inline">Data Offset</strong>, <strong class="source-inline">Reserved</strong>, <strong class="source-inline">Control Bit</strong>, <strong class="source-inline">Window</strong>, <strong class="source-inline">Urgent Pointer</strong>, <strong class="source-inline">Options</strong>, and <strong class="source-inline">Padding</strong>, in addition to the UDP headers. </li>
				<li>Different <a id="_idIndexMarker1295"/>application<a id="_idIndexMarker1296"/> protocols<a id="_idIndexMarker1297"/> are<a id="_idIndexMarker1298"/> based<a id="_idIndexMarker1299"/> on the TCP<a id="_idIndexMarker1300"/> or UDP<a id="_idIndexMarker1301"/> protocols. The <strong class="bold">TCP</strong>-based<a id="_idIndexMarker1302"/> protocols are <strong class="bold">HTTP</strong>, <strong class="bold">HTTPS</strong>, <strong class="bold">Telnet</strong>, <strong class="bold">FTP</strong>, and <strong class="bold">SMTP</strong>. The <strong class="bold">UDP</strong>-based protocols are <strong class="bold">Dynamic Host Configuration Protocol</strong> (<strong class="bold">DHCP</strong>), <strong class="bold">DNS</strong>, <strong class="bold">Simple Network Management Protocol</strong> (<strong class="bold">SNMP</strong>), <strong class="bold">Trivial File Transfer Protocol</strong> (<strong class="bold">TFTP</strong>), <strong class="bold">Bootstrap Protocol</strong> (<strong class="bold">BOOTP</strong>), and early versions of the <strong class="bold">Network File System</strong> (<strong class="bold">NFS</strong>).</li>
			</ul>
			<p>We can capture the difference<a id="_idIndexMarker1303"/> between UDP and TCP in one<a id="_idIndexMarker1304"/> sentence: the UDP protocol is faster and more lightweight than TCP, but less reliable. As with many things in life, you have to pay a higher price for additional services. However, not all these services will be needed in all cases, so think about the task at hand and decide which protocol to use based on your application requirements.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor256"/>URL-based communication</h1>
			<p>Nowadays, it seems<a id="_idIndexMarker1305"/> that everybody has some notion of a URL; those<a id="_idIndexMarker1306"/> who use a browser on their computers or smartphones will see URLs every day. In this section, we will briefly explain the different parts that make up a URL and demonstrate how it can be used programmatically to request data from a website (or a file) or to send (post) data to a website.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor257"/>The URL syntax</h2>
			<p>Generally<a id="_idIndexMarker1307"/> speaking, the URL syntax<a id="_idIndexMarker1308"/> complies with the syntax of a <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>) that has the following<a id="_idIndexMarker1309"/> format:</p>
			<pre class="source-code">scheme:[//authority]path[?query][#fragment]</pre>
			<p>The square brackets indicate that the component is optional. This means that a URI will consist of <strong class="source-inline">scheme:path</strong> at the very least. The <strong class="source-inline">scheme</strong> component can be <strong class="source-inline">http</strong>, <strong class="source-inline">https</strong>, <strong class="source-inline">ftp</strong>, <strong class="source-inline">mailto</strong>, <strong class="source-inline">file</strong>, <strong class="source-inline">data</strong>, or another value. The <strong class="source-inline">path</strong> component consists of a sequence of path segments separated by a slash (<strong class="source-inline">/</strong>). Here is an example of a URL consisting only of <strong class="source-inline">scheme</strong> and <strong class="source-inline">path</strong>:</p>
			<pre class="source-code">file:src/main/resources/hello.txt</pre>
			<p>The preceding URL points to a file on a local filesystem that is relative to the directory where this URL is used. And here are examples that you are more familiar with: <a href="https://www.google.com">https://www.google.com</a>, <a href="https://www.packtpub.com">https://www.packtpub.com</a>. We will demonstrate how it works shortly. </p>
			<p>The <strong class="source-inline">path</strong> component can be empty, but then the URL would seem useless. Nevertheless, an empty path is often used in conjunction with <strong class="source-inline">authority</strong>, which has the following format:</p>
			<pre class="source-code">[userinfo@]host[:port]</pre>
			<p>The only required component of authority is <strong class="source-inline">host</strong>, which can be either an IP address (<strong class="source-inline">137.254.120.50</strong>, for example) or a domain name (<strong class="source-inline">oracle.com</strong>, for example).</p>
			<p>The <strong class="source-inline">userinfo</strong> component is typically used with the <strong class="source-inline">mailto</strong> value of the <strong class="source-inline">scheme</strong> component, so <strong class="source-inline">userinfo@host</strong> represents an email address.</p>
			<p>The <strong class="source-inline">port</strong> component, if omitted, assumes a default value. For example, if the <strong class="source-inline">scheme</strong> value is <strong class="source-inline">http</strong>, then the default <strong class="source-inline">port</strong> value is <strong class="source-inline">80</strong>, and if the <strong class="source-inline">scheme</strong> value is <strong class="source-inline">https</strong>, then the default <strong class="source-inline">port</strong> value is <strong class="source-inline">443</strong>.</p>
			<p>An optional <strong class="source-inline">query</strong> component of a URL<a id="_idIndexMarker1310"/> is a sequence of key-value<a id="_idIndexMarker1311"/> pairs separated by a delimiter (<strong class="source-inline">&amp;</strong>):</p>
			<pre class="source-code">key1=value1&amp;key2=value2</pre>
			<p>Finally, the optional <strong class="source-inline">fragment</strong> component is an identifier of a section of an HTML document, meaning that a browser can scroll this section into view.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is necessary to mention that Oracle's online documentation uses slightly different terminology:</p>
			<ul>
				<li class="callout"><strong class="source-inline">protocol</strong> instead of <strong class="source-inline">scheme</strong></li>
				<li class="callout"><strong class="source-inline">reference</strong> instead of <strong class="source-inline">fragment</strong></li>
				<li class="callout"><strong class="source-inline">file</strong> instead of <strong class="source-inline">path[?query][#fragment]</strong></li>
				<li class="callout"><strong class="source-inline">resource</strong> instead of <strong class="source-inline">host[:port]path[?query][#fragment]</strong></li>
			</ul>
			<p>So, from the Oracle documentation perspective, the URL is composed of <strong class="source-inline">protocol</strong> and <strong class="source-inline">resource</strong> values.</p>
			<p>Let’s now take a look at the programmatic usage of URLs in Java.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor258"/>The java.net.URL class</h2>
			<p>In Java, a URL is represented by<a id="_idIndexMarker1312"/> an object of the <strong class="source-inline">java.net.URL</strong> class that has six constructors:</p>
			<ul>
				<li><strong class="source-inline">URL(String spec)</strong>: This creates a <strong class="source-inline">URL</strong> object<a id="_idIndexMarker1313"/> from the URL as a string.</li>
				<li><strong class="source-inline">URL(String protocol, String host, String file)</strong>: This creates a <strong class="source-inline">URL</strong> object from the provided values of <strong class="source-inline">protocol</strong>, <strong class="source-inline">host</strong>, and <strong class="source-inline">file</strong> (<strong class="source-inline">path</strong> and <strong class="source-inline">query</strong>), and the default port number based on the <strong class="source-inline">protocol</strong> value provided.</li>
				<li><strong class="source-inline">URL(String protocol, String host, int port, String path)</strong>: This creates a <strong class="source-inline">URL</strong> object from the provided values of <strong class="source-inline">protocol</strong>, <strong class="source-inline">host</strong>, <strong class="source-inline">port</strong>, and <strong class="source-inline">file</strong> (<strong class="source-inline">path</strong> and <strong class="source-inline">query</strong>). A <strong class="source-inline">port</strong> value of <strong class="source-inline">-1</strong> indicates<a id="_idIndexMarker1314"/> that the default port number<a id="_idIndexMarker1315"/> needs to be used based on the <strong class="source-inline">protocol</strong> value provided.</li>
				<li><strong class="source-inline">URL(String protocol, String host, int port, String file, URLStreamHandler handler)</strong>: This acts in the same way as the preceding constructor and additionally allows you to pass in an object of the particular protocol handler; all the preceding constructors load default handlers automatically.</li>
				<li><strong class="source-inline">URL(URL context, String spec)</strong>: This creates a <strong class="source-inline">URL</strong> object that extends the <strong class="source-inline">URL</strong> object provided or overrides its components using the <strong class="source-inline">spec</strong> value provided, which is a string representation of a URL or some of its components. For example, if the scheme is present in both parameters, the scheme value from <strong class="source-inline">spec</strong> overrides the scheme value in <strong class="source-inline">context</strong> and many others.</li>
				<li><strong class="source-inline">URL(URL context, String spec, URLStreamHandler handler)</strong>: This acts in the same way as the preceding constructor and additionally allows you to pass in an object of the particular protocol handler.</li>
			</ul>
			<p>Once created, a <strong class="source-inline">URL</strong> object allows you to get the values of various components of the underlying URL. The <strong class="source-inline">InputStream openStream()</strong> method provides access to the stream of data received from the URL. In fact, it is implemented as <strong class="source-inline">openConnection.getInputStream()</strong>. The <strong class="source-inline">URLConnection openConnection()</strong> method of the <strong class="source-inline">URL</strong> class returns a <strong class="source-inline">URLConnection</strong> object with many methods that provide details about the connection to the URL, including the <strong class="source-inline">getOutputStream()</strong> method that allows you to send data to the URL.</p>
			<p>Let’s take a look at the <strong class="source-inline">UrlFileReader</strong> code example that reads data from a <strong class="source-inline">hello.txt</strong> file, which is a local file<a id="_idIndexMarker1316"/> that we created in <a href="B18388_05_ePub.xhtml#_idTextAnchor121"><em class="italic">Chapter 5</em></a>, <em class="italic">Strings, Input/Output, and Files</em>. The file contains<a id="_idIndexMarker1317"/> only one line: <strong class="source-inline">Hello!</strong>; here is the code that reads it:</p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">  ClassLoader classLoader = </pre>
			<pre class="source-code">              Thread.currentThread().getContextClassLoader(); </pre>
			<pre class="source-code">  String file = classLoader.getResource("hello.txt").getFile(); </pre>
			<pre class="source-code">  URL url = new URL(file);</pre>
			<pre class="source-code">     try(InputStream is = url.openStream()){</pre>
			<pre class="source-code">        int data = is.read();</pre>
			<pre class="source-code">        while(data != -1){</pre>
			<pre class="source-code">            System.out.print((char) data); //prints: Hello!</pre>
			<pre class="source-code">            data = is.read();</pre>
			<pre class="source-code">        }            </pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">} catch (Exception e) {</pre>
			<pre class="source-code">    e.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, we used a class loader to access the resource (<strong class="source-inline">hello.txt</strong> file) and construct a URL that points to it. </p>
			<p>The rest of the preceding code is opening an input stream of data from a file and prints the incoming bytes as characters. The result is shown in the inline comment.</p>
			<p>Now, let’s demonstrate how Java code can read data from the URL that points to a source on the internet. Let’s call the Google search engine with the <strong class="source-inline">Java</strong> keyword (the <strong class="source-inline">UrlSiteReader</strong> class):</p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">   URL url = </pre>
			<pre class="source-code">       new URL("https://www.google.com/search?q=Java&amp;num=10");</pre>
			<pre class="source-code">   System.out.println(url.getPath()); //prints: /search</pre>
			<pre class="source-code">   System.out.println(url.getFile()); </pre>
			<pre class="source-code">                               //prints: /search?q=Java&amp;num=10</pre>
			<pre class="source-code">   URLConnection conn = url.openConnection();</pre>
			<pre class="source-code">   conn.setRequestProperty("Accept", "text/html");</pre>
			<pre class="source-code">   conn.setRequestProperty("Connection", "close");</pre>
			<pre class="source-code">   conn.setRequestProperty("Accept-Language", "en-US");</pre>
			<pre class="source-code">   conn.setRequestProperty("User-Agent", "Mozilla/5.0");</pre>
			<pre class="source-code">   try(InputStream is = conn.getInputStream();</pre>
			<pre class="source-code">    BufferedReader br = </pre>
			<pre class="source-code">            new BufferedReader(new InputStreamReader(is))){</pre>
			<pre class="source-code">      String line;</pre>
			<pre class="source-code">      while ((line = br.readLine()) != null){</pre>
			<pre class="source-code">         System.out.println(line);</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">} catch (Exception e) {</pre>
			<pre class="source-code">  e.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>Here, we came up with the <a href="https://www.google.com/search?q=Java&amp;num=10">https://www.google.com/search?q=Java&amp;num=10</a> URL and requested the properties after some research<a id="_idIndexMarker1318"/> and experimentation. There is no guarantee<a id="_idIndexMarker1319"/> that it will always work, so do not be surprised if it does not return the same data we describe. Besides, it is a live search, so the result may change at any time. When it works, Google will return pages of data.</p>
			<p>The preceding code also demonstrates the difference in the values returned by the <strong class="source-inline">getPath()</strong> and <strong class="source-inline">getFile()</strong> methods. You can view the inline comments in the preceding code example.</p>
			<p>In comparison to the example of using a file URL, the Google search example used the <strong class="source-inline">URLConnection</strong> object because we need to set the request header fields:</p>
			<ul>
				<li><strong class="source-inline">Accept</strong> tells the server what type of content the caller requests (<strong class="source-inline">understands</strong>).</li>
				<li><strong class="source-inline">Connection</strong> tells the server that the connection will be closed after the response is received.</li>
				<li><strong class="source-inline">Accept-Language</strong> tells the server which language the caller requests (<strong class="source-inline">understands</strong>).</li>
				<li><strong class="source-inline">User-Agent</strong> tells the server information about the caller; otherwise, the Google search engine (<strong class="source-inline">www.google.com</strong>) responds with a 403 (forbidden) HTTP code.</li>
			</ul>
			<p>The remaining code in the preceding example<a id="_idIndexMarker1320"/> just reads from the input<a id="_idIndexMarker1321"/> stream of data (HTML code) coming from the URL and prints it, line by line. We captured the result (copied it from the screen), pasted it into the online HTML Formatter (<a href="https://jsonformatter.org/html-pretty-print">https://jsonformatter.org/html-pretty-print</a>), and ran it. The result is presented in the following screenshot and this may be different when you run it since Google functionality is evolving over time:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B18388_Figure_11.10.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, it looks like a typical<a id="_idIndexMarker1322"/> page with the search results, except there is no Google image in the upper-left corner<a id="_idIndexMarker1323"/> with the returned HTML. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Beware that if you execute this code many times, Google may block your IP address. </p>
			<p>Similarly, it is possible to send (post) data to a URL. Here is an example code:</p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    URL url = new URL("http://localhost:3333/something");</pre>
			<pre class="source-code">    URLConnection conn = url.openConnection();</pre>
			<pre class="source-code">    conn.setRequestProperty("Method", "POST");</pre>
			<pre class="source-code">    conn.setRequestProperty("User-Agent", "Java client");</pre>
			<pre class="source-code">    conn.setDoOutput(true);</pre>
			<pre class="source-code">    OutputStream os = conn.getOutputStream()</pre>
			<pre class="source-code">    OutputStreamWriter osw = new OutputStreamWriter(os);</pre>
			<pre class="source-code">    osw.write("parameter1=value1&amp;parameter2=value2");</pre>
			<pre class="source-code">    osw.flush();</pre>
			<pre class="source-code">    osw.close();</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    InputStream is = conn.getInputStream();</pre>
			<pre class="source-code">    BufferedReader br = </pre>
			<pre class="source-code">               new BufferedReader(new InputStreamReader(is));</pre>
			<pre class="source-code">    String line;</pre>
			<pre class="source-code">    while ((line = br.readLine()) != null) {</pre>
			<pre class="source-code">        System.out.println(line);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    br.close();</pre>
			<pre class="source-code">} catch (Exception e) {</pre>
			<pre class="source-code">    e.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The preceding code expects a server running on the <strong class="source-inline">localhost</strong> server on port <strong class="source-inline">3333</strong> that can process the <strong class="source-inline">POST</strong> request with the <strong class="source-inline">"/something"</strong> path. If the server does not check the method (is it <strong class="source-inline">POST</strong> or any other HTTP method) and it does not check the <strong class="source-inline">User-Agent</strong> value, there is no need to specify any of it. So, we comment the settings out and keep them there just to demonstrate how these, and similar, values can be set if required.</p>
			<p>Notice that we used the <strong class="source-inline">setDoOutput()</strong> method to indicate that output has to be sent; by default, it is set to <strong class="source-inline">false</strong>. Then, we let the output stream send the query parameters to the server. </p>
			<p>Another important aspect of the preceding<a id="_idIndexMarker1324"/> code is that the output stream has<a id="_idIndexMarker1325"/> to be closed before the input stream is opened. Otherwise, the content of the output stream will not be sent to the server. While we did it explicitly, a better way to do it is by using the try-with-resources block that guarantees the <strong class="source-inline">close()</strong> method is called, even if an exception was raised anywhere in the block.</p>
			<p>Here is a better version of the preceding example (using try-with-resources blocks) in the <strong class="source-inline">UrlPost</strong> class:</p>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    URL url = new URL("http://localhost:3333/something");</pre>
			<pre class="source-code">    URLConnection conn = url.openConnection();</pre>
			<pre class="source-code">    conn.setRequestProperty("Method", "POST");</pre>
			<pre class="source-code">    conn.setRequestProperty("User-Agent", "Java client");</pre>
			<pre class="source-code">    conn.setDoOutput(true);</pre>
			<pre class="source-code">    try (OutputStream os = conn.getOutputStream();</pre>
			<pre class="source-code">         OutputStreamWriter osw = new OutputStreamWriter(os)) {</pre>
			<pre class="source-code">       osw.write("parameter1=value1&amp;parameter2=value2");</pre>
			<pre class="source-code">       osw.flush();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    try (InputStream is = conn.getInputStream();</pre>
			<pre class="source-code">         BufferedReader br = </pre>
			<pre class="source-code">                new BufferedReader(new InputStreamReader(is))) {</pre>
			<pre class="source-code">       String line;</pre>
			<pre class="source-code">       while ((line = br.readLine()) != null) {</pre>
			<pre class="source-code">           System.out.println(line);  //prints server response </pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, this code calls the <strong class="source-inline">localhost</strong> server on port <strong class="source-inline">3333</strong> with the URI <strong class="source-inline">something</strong>, and the query parameters <strong class="source-inline">parameter1=value1&amp;parameter2=value2</strong>. Then, it immediately reads the response from the server, prints it, and exits.</p>
			<p>To demonstrate how this example<a id="_idIndexMarker1326"/> works, we also created a simple<a id="_idIndexMarker1327"/> server that listens on port <strong class="source-inline">3333</strong> of <strong class="source-inline">localhost</strong> and has a handler assigned to process all the requests that come with the <strong class="source-inline">"/something"</strong> path (refer to the <strong class="source-inline">Server</strong> class in a separate project in the <strong class="source-inline">server</strong> folder):</p>
			<pre class="source-code">private static Properties properties;</pre>
			<pre class="source-code">public static void main(String[] args){</pre>
			<pre class="source-code">   ClassLoader classLoader =  </pre>
			<pre class="source-code">                Thread.currentThread().getContextClassLoader();</pre>
			<pre class="source-code">   properties = Prop.getProperties(classLoader, </pre>
			<pre class="source-code">                                             "app.properties");</pre>
			<pre class="source-code">   int port = Prop.getInt(properties, "port");</pre>
			<pre class="source-code">   try {</pre>
			<pre class="source-code">      HttpServer server = </pre>
			<pre class="source-code">             HttpServer.create(new InetSocketAddress(port), 0);</pre>
			<pre class="source-code">      server.createContext("/something", new PostHandler());</pre>
			<pre class="source-code">      server.setExecutor(null);</pre>
			<pre class="source-code">      server.start();</pre>
			<pre class="source-code">   } catch (IOException e) {</pre>
			<pre class="source-code">        e.printStackTrace();</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">} </pre>
			<pre class="source-code">private static class PostHandler implements HttpHandler {</pre>
			<pre class="source-code">    public void handle(HttpExchange exch) {</pre>
			<pre class="source-code">       System.out.println(exch.getRequestURI());   </pre>
			<pre class="source-code">                                        //prints: /something  </pre>
			<pre class="source-code">       System.out.println(exch.getHttpContext().getPath());</pre>
			<pre class="source-code">                                        //prints: /something</pre>
			<pre class="source-code">       try (InputStream is = exch.getRequestBody();</pre>
			<pre class="source-code">            BufferedReader in = </pre>
			<pre class="source-code">               new BufferedReader(new InputStreamReader(is));</pre>
			<pre class="source-code">            OutputStream os = exch.getResponseBody()){</pre>
			<pre class="source-code">          System.out.println("Received as body:");</pre>
			<pre class="source-code">          in.lines().forEach(l -&gt; System.out.println(</pre>
			<pre class="source-code">                                                    "  " + l));</pre>
			<pre class="source-code">          String confirm = "Got it! Thanks.";</pre>
			<pre class="source-code">          exch.sendResponseHeaders(200, confirm.length());</pre>
			<pre class="source-code">          os.write(confirm.getBytes());</pre>
			<pre class="source-code">       } catch (Exception ex){</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>To implement the server, we used<a id="_idIndexMarker1328"/> the classes of the <strong class="source-inline">com.sun.net.httpserver</strong> package that comes<a id="_idIndexMarker1329"/> with the JDK in the Java class library. It starts listening on port <strong class="source-inline">3333</strong> and blocks until the request comes with the <strong class="source-inline">"/something"</strong> path.</p>
			<p>We used the <strong class="source-inline">common</strong> library (a separate project in the <strong class="source-inline">common</strong> folder) that includes the <strong class="source-inline">Prop</strong> class, which provides access to the properties file in the <strong class="source-inline">resources</strong> folder. Please note how references to this library are included as the dependency in the <strong class="source-inline">pom.xml</strong> file of the <strong class="source-inline">server</strong> project:</p>
			<pre class="source-code">        &lt;dependency&gt; </pre>
			<pre class="source-code">            &lt;groupId&gt;com.packt.learnjava&lt;/groupId&gt; </pre>
			<pre class="source-code">            &lt;artifactId&gt;common&lt;/artifactId&gt; </pre>
			<pre class="source-code">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; </pre>
			<pre class="source-code">        &lt;/dependency&gt; </pre>
			<p>The <strong class="source-inline">Prop</strong> class includes two methods:</p>
			<pre class="source-code">public static Properties getProperties(ClassLoader classLoader,</pre>
			<pre class="source-code">                                               String fileName){</pre>
			<pre class="source-code">    String file = classLoader.getResource(fileName).getFile();</pre>
			<pre class="source-code">    Properties properties = new Properties();</pre>
			<pre class="source-code">    try(FileInputStream fis = new FileInputStream(file)){</pre>
			<pre class="source-code">         properties.load(fis);</pre>
			<pre class="source-code">    } catch (Exception ex) {</pre>
			<pre class="source-code">         ex.printStackTrace();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return properties;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">public static int getInt(Properties properties, String name){</pre>
			<pre class="source-code">    return Integer.parseInt(properties.getProperty(name));</pre>
			<pre class="source-code">}</pre>
			<p>We use the <strong class="source-inline">Prop</strong> class to get the value of the <strong class="source-inline">port</strong> property from the <strong class="source-inline">app.properties</strong> file of the <strong class="source-inline">server</strong> project. </p>
			<p>The implementation<a id="_idIndexMarker1330"/> of the internal <strong class="source-inline">PostHandler</strong> class in the <strong class="source-inline">server</strong> project demonstrates<a id="_idIndexMarker1331"/> that the URL comes without parameters: we print the URI and the path. They both have the same <strong class="source-inline">"/something"</strong> value; the parameters come from the body of the request.</p>
			<p>After the request is processed, the server sends back the message <em class="italic">“Got it! Thanks.”</em> Let’s see how it works; we first run the server. This can be done in two ways:</p>
			<ol>
				<li>Just run the <strong class="source-inline">main()</strong> method in the <strong class="source-inline">Server</strong> class using your IDE. Click any of the two green triangles, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B18388_Figure_11.11.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="2">Go to the <strong class="source-inline">common</strong> folder and execute the following Maven command:<p class="source-code"><strong class="bold">mvn clean package</strong></p></li>
			</ol>
			<p>This command compiles<a id="_idIndexMarker1332"/> code in the <strong class="source-inline">common</strong> project and builds the <strong class="source-inline">common-1.0-SNAPSHOT.jar</strong> file in the <strong class="source-inline">target</strong> subdirectory. Now, repeat the same command in the <strong class="source-inline">server</strong> folder and run the following command in the <strong class="source-inline">server</strong> folder:</p>
			<p class="source-code"><strong class="bold">java -cp target/server-1.0-SNAPSHOT.jar:          \</strong></p>
			<p class="source-code"><strong class="bold">         ../common/target/common-1.0-SNAPSHOT.jar \</strong></p>
			<p class="source-code"><strong class="bold">         com.packt.learnjava.network.http.Server</strong></p>
			<p>As you can see, the preceding command lists on the classpath two <strong class="source-inline">.jar</strong> files (those we have just built) and runs the <strong class="source-inline">main()</strong> method of the <strong class="source-inline">Server</strong> class.</p>
			<p>The outcome is that the server is waiting for the client code to call it. </p>
			<p>Now, let’s execute the client (the <strong class="source-inline">UrlPost</strong> class). We can also do this in two ways:</p>
			<ol>
				<li value="1">Just run the <strong class="source-inline">main()</strong> method<a id="_idIndexMarker1333"/> in the <strong class="source-inline">UrlPost</strong> class using your<a id="_idIndexMarker1334"/> IDE. Click any of the two green triangles, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B18388_Figure_11.12.jpg" alt=""/>
				</div>
			</div>
			<ol>
				<li value="2">Go to the <strong class="source-inline">examples</strong> folder and execute the following Maven command:<p class="source-code"><strong class="bold">mvn clean package</strong></p></li>
			</ol>
			<p>This command compiles code in the <strong class="source-inline">examples</strong> project and builds a <strong class="source-inline">examples-1.0-SNAPSHOT.jar</strong> file in the <strong class="source-inline">target</strong> subdirectory. </p>
			<p>Now, run the following command in the <strong class="source-inline">examples</strong> folder:</p>
			<p class="source-code"><strong class="bold">java -cp target/examples-1.0-SNAPSHOT.jar:       \</strong></p>
			<p class="source-code"><strong class="bold">         com.packt.learnjava.ch11_network.UrlPost</strong></p>
			<p>After running the client code, observe the following output on the server-side screen:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B18388_Figure_11.13.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the server received the parameters (or any other message for that matter) successfully. Now it can parse them and use them as needed.</p>
			<p>If we look at the client-side screen, we will see the following output:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B18388_Figure_11.14.jpg" alt=""/>
				</div>
			</div>
			<p>This means that the client received the message from the server and exited as expected. </p>
			<p>Notice that the server in our example does not exit automatically and has to be stopped manually.</p>
			<p>Other methods of the <strong class="source-inline">URL</strong> and <strong class="source-inline">URLConnection</strong> classes allow you to set/get other properties and can be used for more dynamic management of the client-server communication. There is also the <strong class="source-inline">HttpUrlConnection</strong> class (and other classes) in the <strong class="source-inline">java.net</strong> package that<a id="_idIndexMarker1335"/> simplifies and enhances URL-based communication. You can read<a id="_idIndexMarker1336"/> the online documentation of the <strong class="source-inline">java.net</strong> package to understand the available options better.</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor259"/>Using the HTTP 2 Client API</h1>
			<p>The HTTP Client API was introduced with Java 9 as an<a id="_idIndexMarker1337"/> incubating API<a id="_idIndexMarker1338"/> in the <strong class="source-inline">jdk.incubator.http</strong> package. In Java 11, it was standardized and moved to the <strong class="source-inline">java.net.http</strong> package. It is a far richer and easier-to-use<a id="_idIndexMarker1339"/> alternative to the <strong class="source-inline">URLConnection</strong> API. In addition to all the basic connection-related functionality, it provides non-blocking (asynchronous) requests and responses using <strong class="source-inline">CompletableFuture</strong> and supports both HTTP 1.1 and HTTP 2.</p>
			<p>HTTP 2 added the following new capabilities to the HTTP protocol:</p>
			<ul>
				<li>The ability to send data in a binary format rather than textual format; the binary format is more efficient for parsing, more compact, and less susceptible to various errors.</li>
				<li>It is fully multiplexed, thus allowing multiple requests and responses to be sent concurrently using just one connection.</li>
				<li>It uses header compression, thus reducing the overhead.</li>
				<li>It allows a server to push a response to the client’s cache if the client indicates that it supports HTTP 2.</li>
			</ul>
			<p>The package contains<a id="_idIndexMarker1340"/> the following classes:</p>
			<ul>
				<li><strong class="source-inline">HttpClient</strong>: This is used to send requests and receive responses both synchronously and asynchronously. An instance can be created using the static <strong class="source-inline">newHttpClient()</strong> method with default settings or by using the <strong class="source-inline">HttpClient.Builder</strong> class (returned by the static <strong class="source-inline">newBuilder()</strong> method) that allows you to customize the client configuration. Once created, the instance is immutable and can be used multiple times.</li>
				<li><strong class="source-inline">HttpRequest</strong>: This creates and represents an HTTP request with the destination URI, headers, and other related information. An instance can be created using the <strong class="source-inline">HttpRequest.Builder</strong> class (returned by the static <strong class="source-inline">newBuilder()</strong> method). Once created, the instance is immutable and can be sent multiple times.</li>
				<li><strong class="source-inline">HttpRequest.BodyPublisher</strong>: This publishes a body (for the <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> methods) from a certain source, such as a string, a file, an input stream, or a byte array.</li>
				<li><strong class="source-inline">HttpResponse</strong>: This represents an HTTP response received by the client after an HTTP request has been sent. It contains the origin URI, headers, message body, and other related information. Once created, the instance can be queried multiple times.</li>
				<li><strong class="source-inline">HttpResponse.BodyHandler</strong>: This is a functional interface that accepts the response and returns an instance of <strong class="source-inline">HttpResponse.BodySubscriber</strong> that can process the response body.</li>
				<li><strong class="source-inline">HttpResponse.BodySubscriber</strong>: This receives the response body (its bytes) and transforms it into a string, a file, or a type.</li>
			</ul>
			<p>The <strong class="source-inline">HttpRequest.BodyPublishers</strong>, <strong class="source-inline">HttpResponse.BodyHandlers</strong>, and <strong class="source-inline">HttpResponse.BodySubscribers</strong> classes are factory classes that create instances of the corresponding<a id="_idIndexMarker1341"/> classes. For example, the <strong class="source-inline">BodyHandlers.ofString()</strong> method creates a <strong class="source-inline">BodyHandler</strong> instance that processes the response body bytes as a string, while the <strong class="source-inline">BodyHandlers.ofFile()</strong> method creates a <strong class="source-inline">BodyHandler</strong> instance that saves the response body in a file.</p>
			<p>You can read the online documentation of the <strong class="source-inline">java.net.http</strong> package to learn more about these and other related classes and interfaces. Next, we will take a look at and discuss some examples of HTTP API usage.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor260"/>Blocking HTTP requests</h2>
			<p>The following code<a id="_idIndexMarker1342"/> is an example of a simple HTTP client that sends a <strong class="source-inline">GET</strong> request to an HTTP server (see the <strong class="source-inline">get()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">HttpClient httpClient = HttpClient.newBuilder()</pre>
			<pre class="source-code">     .version(HttpClient.Version.HTTP_2) // default</pre>
			<pre class="source-code">     .build();</pre>
			<pre class="source-code">HttpRequest req = HttpRequest.newBuilder()</pre>
			<pre class="source-code">     .uri(URI.create("http://localhost:3333/something"))</pre>
			<pre class="source-code">     .GET()        // default</pre>
			<pre class="source-code">     .build();</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code"> HttpResponse&lt;String&gt; resp = </pre>
			<pre class="source-code">          httpClient.send(req, BodyHandlers.ofString());</pre>
			<pre class="source-code"> System.out.println("Response: " + </pre>
			<pre class="source-code">               resp.statusCode() + " : " + resp.body());</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">   ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>We created a builder to configure an <strong class="source-inline">HttpClient</strong> instance. However, since we used default settings only, we can do it with the same result, as follows:</p>
			<pre class="source-code">HttpClient httpClient = HttpClient.newHttpClient();</pre>
			<p>To demonstrate<a id="_idIndexMarker1343"/> the client’s functionality, we will use the same <strong class="source-inline">Server</strong> class that we used already. As a reminder, this is how it processes the client’s request and responds with <strong class="source-inline">"Got it! Thanks."</strong>:</p>
			<pre class="source-code">try (InputStream is = exch.getRequestBody();</pre>
			<pre class="source-code">     BufferedReader in = </pre>
			<pre class="source-code">            new BufferedReader(new InputStreamReader(is));</pre>
			<pre class="source-code">     OutputStream os = exch.getResponseBody()){</pre>
			<pre class="source-code">   System.out.println("Received as body:");</pre>
			<pre class="source-code">   in.lines().forEach(l -&gt; System.out.println("  " + l));</pre>
			<pre class="source-code">   String confirm = "Got it! Thanks.";</pre>
			<pre class="source-code">   exch.sendResponseHeaders(200, confirm.length());</pre>
			<pre class="source-code">   os.write(confirm.getBytes());</pre>
			<pre class="source-code">   System.out.println();</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>If we launch this server and run the preceding client’s code, the server prints the following message on its screen:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B18388_Figure_11.15.jpg" alt=""/>
				</div>
			</div>
			<p>The client did not send a message because it used the HTTP <strong class="source-inline">GET</strong> method. Nevertheless, the server responds, and the client’s screen shows the following message:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B18388_Figure_11.16.jpg" alt=""/>
				</div>
			</div>
			<p>The <strong class="source-inline">send()</strong> method of the <strong class="source-inline">HttpClient</strong> class is blocked until the response has come back from the server. </p>
			<p>Using the HTTP <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, or <strong class="source-inline">DELETE</strong> methods produces similar results; let’s run the following code now (see the <strong class="source-inline">post()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">HttpClient httpClient = HttpClient.newBuilder()</pre>
			<pre class="source-code">        .version(Version.HTTP_2)  // default</pre>
			<pre class="source-code">        .build();</pre>
			<pre class="source-code">HttpRequest req = HttpRequest.newBuilder()</pre>
			<pre class="source-code">        .uri(URI.create("http://localhost:3333/something"))</pre>
			<pre class="source-code">        .POST(BodyPublishers.ofString("Hi there!"))</pre>
			<pre class="source-code">        .build();</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    HttpResponse&lt;String&gt; resp = </pre>
			<pre class="source-code">                 httpClient.send(req, BodyHandlers.ofString());</pre>
			<pre class="source-code">    System.out.println("Response: " + </pre>
			<pre class="source-code">                      resp.statusCode() + " : " + resp.body());</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, this time<a id="_idIndexMarker1344"/> the client posts the message <strong class="source-inline">Hi there!</strong> and the server’s screen shows the following:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B18388_Figure_11.17.jpg" alt=""/>
				</div>
			</div>
			<p>The <strong class="source-inline">send()</strong> method of the <strong class="source-inline">HttpClient</strong> class is blocked until the same response has come back from the server:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B18388_Figure_11.18.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p>So far, the demonstrated functionality was not much different from the URL-based communication that we saw in the previous section. Now we are going to use the <strong class="source-inline">HttpClient</strong> methods that are not available in the URL streams.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor261"/>Non-blocking (asynchronous) HTTP requests</h2>
			<p>The <strong class="source-inline">sendAsync()</strong> method<a id="_idIndexMarker1345"/> of the <strong class="source-inline">HttpClient</strong> class allows you to send a message to a server without blocking. To demonstrate how it works, we will execute the following code (see the <strong class="source-inline">getAsync1()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">HttpClient httpClient = HttpClient.newHttpClient();</pre>
			<pre class="source-code">HttpRequest req = HttpRequest.newBuilder()</pre>
			<pre class="source-code">        .uri(URI.create("http://localhost:3333/something"))</pre>
			<pre class="source-code">        .GET()   // default</pre>
			<pre class="source-code">        .build();</pre>
			<pre class="source-code">CompletableFuture&lt;Void&gt; cf = httpClient</pre>
			<pre class="source-code">        .sendAsync(req, BodyHandlers.ofString())</pre>
			<pre class="source-code">        .thenAccept(resp -&gt; System.out.println("Response: " +</pre>
			<pre class="source-code">                   resp.statusCode() + " : " + resp.body()));</pre>
			<pre class="source-code">System.out.println("The request was sent asynchronously...");</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    System.out.println("CompletableFuture get: " +</pre>
			<pre class="source-code">                                cf.get(5, TimeUnit.SECONDS));</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Exit the client...");</pre>
			<p>In comparison to the example with the <strong class="source-inline">send()</strong> method (which returns the <strong class="source-inline">HttpResponse</strong> object), the <strong class="source-inline">sendAsync()</strong> method returns an instance of the <strong class="source-inline">CompletableFuture&lt;HttpResponse&gt;</strong> class. If you read the documentation of the <strong class="source-inline">CompletableFuture&lt;T&gt;</strong> class, you will see that it implements the <strong class="source-inline">java.util.concurrent.CompletionStage</strong> interface, which provides many methods that can<a id="_idIndexMarker1346"/> be chained and allows you to set various functions to process the response.</p>
			<p>To give you an idea, here is the list of the methods declared in the <strong class="source-inline">CompletionStage</strong> interface: <strong class="source-inline">acceptEither</strong>, <strong class="source-inline">acceptEitherAsync</strong>, <strong class="source-inline">acceptEitherAsync</strong>, <strong class="source-inline">applyToEither</strong>, <strong class="source-inline">applyToEitherAsync</strong>, <strong class="source-inline">applyToEitherAsync</strong>, <strong class="source-inline">handle</strong>, <strong class="source-inline">handleAsync</strong>, <strong class="source-inline">handleAsync</strong>, <strong class="source-inline">runAfterBoth</strong>, <strong class="source-inline">runAfterBothAsync</strong>, <strong class="source-inline">runAfterBothAsync</strong>, <strong class="source-inline">runAfterEither</strong>, <strong class="source-inline">runAfterEitherAsync</strong>, <strong class="source-inline">runAfterEitherAsync</strong>, <strong class="source-inline">thenAccept</strong>, <strong class="source-inline">thenAcceptAsync</strong>, <strong class="source-inline">thenAcceptAsync</strong>, <strong class="source-inline">thenAcceptBoth</strong>, <strong class="source-inline">thenAcceptBothAsync</strong>, <strong class="source-inline">thenAcceptBothAsync</strong>, <strong class="source-inline">thenApply</strong>, <strong class="source-inline">thenApplyAsync</strong>, <strong class="source-inline">thenApplyAsync</strong>, <strong class="source-inline">thenCombine</strong>, <strong class="source-inline">thenCombineAsync</strong>, <strong class="source-inline">thenCombineAsync</strong>, <strong class="source-inline">thenCompose</strong>, <strong class="source-inline">thenComposeAsync</strong>, <strong class="source-inline">thenComposeAsync</strong>, <strong class="source-inline">thenRun</strong>, <strong class="source-inline">thenRunAsync</strong>, <strong class="source-inline">thenRunAsync</strong>, <strong class="source-inline">whenComplete</strong>, <strong class="source-inline">whenCompleteAsync</strong>, and <strong class="source-inline">whenCompleteAsync</strong>.</p>
			<p>We will talk about functions and how they can be passed as parameters in <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>. For now, we will just mention that the <strong class="source-inline">resp -&gt; System.out.println("Response: " + resp.statusCode() + " : " + resp.body())</strong> construction represents the same functionality as the following method:</p>
			<pre class="source-code">void method(HttpResponse resp){</pre>
			<pre class="source-code">    System.out.println("Response: " + </pre>
			<pre class="source-code">                      resp.statusCode() + " : " + resp.body());</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">thenAccept()</strong> method applies the passed-in functionality to the result returned by the previous method of the chain.</p>
			<p>After the <strong class="source-inline">CompletableFuture&lt;Void&gt;</strong> instance is returned, the preceding code prints <strong class="source-inline">The request was sent asynchronously...</strong> message and blocks it on the <strong class="source-inline">get()</strong> method of the <strong class="source-inline">CompletableFuture&lt;Void&gt;</strong> object. This method has an overloaded version <strong class="source-inline">get(long timeout, TimeUnit unit)</strong>, with two parameters,  <strong class="source-inline">TimeUnit unit</strong> and <strong class="source-inline">long</strong> <strong class="source-inline">timeout</strong>, which specify the number of the units, indicating how long the method should wait for the task that is represented by the <strong class="source-inline">CompletableFuture&lt;Void&gt;</strong> object to complete. In our case, the task is to send a message to the server<a id="_idIndexMarker1347"/> and to get back the response (and process it using the function provided). If the task is not completed in the allotted time, the <strong class="source-inline">get()</strong> method is interrupted (and the stack trace is printed in the <strong class="source-inline">catch</strong> block).</p>
			<p>The <strong class="source-inline">Exit the client...</strong> message should appear on the screen either in 5 seconds (in our case) or after the <strong class="source-inline">get()</strong> method returns.</p>
			<p>If we run the client, the server’s screen shows the following message again with the blocking HTTP <strong class="source-inline">GET</strong> request:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B18388_Figure_11.19.jpg" alt=""/>
				</div>
			</div>
			<p>The client’s screen displays the following message:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B18388_Figure_11.20.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, <strong class="bold">The request was sent asynchronously...</strong> message appears before the response came back from the server. This is the point of an asynchronous call; the request to the server was sent and the client is free to continue to do anything else. The passed-in function will be applied to the server response. At the same time, you can pass the <strong class="source-inline">CompletableFuture&lt;Void&gt;</strong> object around and call it at any time to get the result. In our case, the result is <strong class="source-inline">void</strong>, so the <strong class="source-inline">get()</strong> method simply indicates that the task was completed. </p>
			<p>We know that the server returns the message, and so we can take advantage of it by using another method of the <strong class="source-inline">CompletionStage</strong> interface. We have chosen the <strong class="source-inline">thenApply()</strong> method, which accepts a function that returns a value:</p>
			<pre class="source-code">CompletableFuture&lt;String&gt; cf = httpClient</pre>
			<pre class="source-code">                .sendAsync(req, BodyHandlers.ofString())</pre>
			<pre class="source-code">                .thenApply(resp -&gt; "Server responded: " + </pre>
			<pre class="source-code">                 resp.body());</pre>
			<p>Now, the <strong class="source-inline">get()</strong> method returns the value produced by the <strong class="source-inline">resp -&gt; "Server responded: " + resp.body()</strong> function, so it should return the server message body; let’s run this code (see the <strong class="source-inline">getAsync2()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class) and see the result: </p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B18388_Figure_11.21.jpg" alt=""/>
				</div>
			</div>
			<p>Now, the <strong class="source-inline">get()</strong> method<a id="_idIndexMarker1348"/> returns the server’s message as expected, and it is presented by the function and passed as a parameter to the <strong class="source-inline">thenApply()</strong> method.</p>
			<p>Similarly, we can use the HTTP <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, or <strong class="source-inline">DELETE</strong> methods for sending a message (see the <strong class="source-inline">postAsync()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">HttpClient httpClient = HttpClient.newHttpClient();</pre>
			<pre class="source-code">HttpRequest req = HttpRequest.newBuilder()</pre>
			<pre class="source-code">        .uri(URI.create("http://localhost:3333/something"))</pre>
			<pre class="source-code">        <strong class="bold">.POST(BodyPublishers.ofString("Hi there!"))</strong></pre>
			<pre class="source-code">        .build();</pre>
			<pre class="source-code">CompletableFuture&lt;String&gt; cf = httpClient</pre>
			<pre class="source-code">        .sendAsync(req, BodyHandlers.ofString())</pre>
			<pre class="source-code">        .thenApply(resp -&gt; "Server responded: " + resp.body());</pre>
			<pre class="source-code">System.out.println("The request was sent asynchronously...");</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    System.out.println("CompletableFuture get: " +</pre>
			<pre class="source-code">                                cf.get(5, TimeUnit.SECONDS));</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Exit the client...");</pre>
			<p>The only difference from the previous<a id="_idIndexMarker1349"/> example is that the server now displays the received client’s message:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B18388_Figure_11.22.jpg" alt=""/>
				</div>
			</div>
			<p>The client’s screen displays the same message as in the case of the <strong class="source-inline">GET</strong> method:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B18388_Figure_11.23.jpg" alt=""/>
				</div>
			</div>
			<p>The advantage of asynchronous requests is that they can be sent quickly and without needing to wait for each of them to complete. The HTTP 2 protocol supports it by multiplexing; for example, let’s send three requests as follows (see the <strong class="source-inline">postAsyncMultiple()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">HttpClient httpClient = HttpClient.newHttpClient();</pre>
			<pre class="source-code">List&lt;CompletableFuture&lt;String&gt;&gt; cfs = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">List&lt;String&gt; nums = List.of("1", "2", "3");</pre>
			<pre class="source-code">for(String num: nums){</pre>
			<pre class="source-code">    HttpRequest req = HttpRequest.newBuilder()</pre>
			<pre class="source-code">           .uri(URI.create("http://localhost:3333/something"))</pre>
			<pre class="source-code">           .POST(BodyPublishers.ofString("Hi! My name is " </pre>
			<pre class="source-code">                                               + num + "."))</pre>
			<pre class="source-code">           .build();</pre>
			<pre class="source-code">    CompletableFuture&lt;String&gt; cf = httpClient</pre>
			<pre class="source-code">           .sendAsync(req, BodyHandlers.ofString())</pre>
			<pre class="source-code">           .thenApply(rsp -&gt; "Server responded to msg " + num + </pre>
			<pre class="source-code">                 ": " + rsp.statusCode() + " : " + rsp.body());</pre>
			<pre class="source-code">    cfs.add(cf);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("The requests were sent asynchronously...");</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    for(CompletableFuture&lt;String&gt; cf: cfs){</pre>
			<pre class="source-code">        System.out.println("CompletableFuture get: " + </pre>
			<pre class="source-code">                                  cf.get(5, TimeUnit.SECONDS));</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Exit the client...");</pre>
			<p>The server’s screen shows the following messages:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B18388_Figure_11.24.jpg" alt=""/>
				</div>
			</div>
			<p>Notice the arbitrary sequence<a id="_idIndexMarker1350"/> of the incoming requests; this is because the client uses a pool of <strong class="source-inline">Executors.newCachedThreadPool()</strong> threads to send the messages. Each message is sent by a different thread, and the pool has its own logic for using the pool members (threads). If the number of messages is large, or if each of them consumes a significant amount of memory, it may be beneficial to limit the number of threads run concurrently. </p>
			<p>The <strong class="source-inline">HttpClient.Builder</strong> class allows you to specify the pool that is used for acquiring the threads that send the messages (see the <strong class="source-inline">postAsyncMultipleCustomPool()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">ExecutorService pool = Executors.newFixedThreadPool(2);</pre>
			<pre class="source-code">HttpClient httpClient = HttpClient.newBuilder().executor(pool).build();</pre>
			<pre class="source-code">List&lt;CompletableFuture&lt;String&gt;&gt; cfs = new ArrayList&lt;&gt;();</pre>
			<pre class="source-code">List&lt;String&gt; nums = List.of("1", "2", "3");</pre>
			<pre class="source-code">for(String num: nums){</pre>
			<pre class="source-code">    HttpRequest req = HttpRequest.newBuilder()</pre>
			<pre class="source-code">          .uri(URI.create("http://localhost:3333/something"))</pre>
			<pre class="source-code">          .POST(BodyPublishers.ofString("Hi! My name is " </pre>
			<pre class="source-code">                                                + num + "."))</pre>
			<pre class="source-code">          .build();</pre>
			<pre class="source-code">    CompletableFuture&lt;String&gt; cf = httpClient</pre>
			<pre class="source-code">          .sendAsync(req, BodyHandlers.ofString())</pre>
			<pre class="source-code">          .thenApply(rsp -&gt; "Server responded to msg " + num + </pre>
			<pre class="source-code">                 ": " + rsp.statusCode() + " : " + rsp.body());</pre>
			<pre class="source-code">    cfs.add(cf);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("The requests were sent asynchronously...");</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    for(CompletableFuture&lt;String&gt; cf: cfs){</pre>
			<pre class="source-code">        System.out.println("CompletableFuture get: " + </pre>
			<pre class="source-code">                                  cf.get(5, TimeUnit.SECONDS));</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Exit the client...");</pre>
			<p>If we run the preceding<a id="_idIndexMarker1351"/> code, the results will be the same, but the client will use only two threads to send messages. The performance may be a bit slower (in comparison to the previous example) as the number of messages grows. So, as is often the case in a software system design, you need to balance the amount of memory used and the performance.</p>
			<p>Similar to the executor, several other objects can be set on the <strong class="source-inline">HttpClient</strong> object to configure the connection <a id="_idIndexMarker1352"/>to handle authentication, request redirection, cookie management, and more.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor262"/>Server push functionality</h2>
			<p>The second (after multiplexing) significant<a id="_idIndexMarker1353"/> advantage of the HTTP 2 protocol over HTTP 1.1 is allowing the server to push the response into the client’s cache if the client indicates that it supports HTTP 2. Here is the client code that takes advantage of this feature (see the <strong class="source-inline">push()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">HttpClient httpClient = HttpClient.newHttpClient();</pre>
			<pre class="source-code">HttpRequest req = HttpRequest.newBuilder()</pre>
			<pre class="source-code">   .uri(URI.create("http://localhost:3333/something"))</pre>
			<pre class="source-code">    .GET()</pre>
			<pre class="source-code">    .build();</pre>
			<pre class="source-code">CompletableFuture cf = httpClient</pre>
			<pre class="source-code">    .sendAsync(req, BodyHandlers.ofString(), </pre>
			<pre class="source-code">       (PushPromiseHandler) HttpClientDemo::applyPushPromise);</pre>
			<pre class="source-code">System.out.println("The request was sent asynchronously...");</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    System.out.println("CompletableFuture get: " + </pre>
			<pre class="source-code">                                cf.get(5, TimeUnit.SECONDS));</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.println("Exit the client...");</pre>
			<p>Notice the third parameter of the <strong class="source-inline">sendAsync()</strong> method. It is a function that handles the push response<a id="_idIndexMarker1354"/> if one comes from the server. It is up to the client developer to decide how to implement this function; here is one possible example:</p>
			<pre class="source-code">void applyPushPromise(HttpRequest initReq, HttpRequest pushReq,</pre>
			<pre class="source-code"> Function&lt;BodyHandler, CompletableFuture&lt;HttpResponse&gt;&gt; </pre>
			<pre class="source-code"> acceptor){</pre>
			<pre class="source-code">  CompletableFuture&lt;Void&gt; cf = </pre>
			<pre class="source-code">   acceptor.apply(BodyHandlers.ofString())</pre>
			<pre class="source-code">  .thenAccept(resp -&gt; System.out.println("Got pushed response " </pre>
			<pre class="source-code">                                                + resp.uri()));</pre>
			<pre class="source-code">  try {</pre>
			<pre class="source-code">        System.out.println("Pushed completableFuture get: " + </pre>
			<pre class="source-code">                                  cf.get(1, TimeUnit.SECONDS));</pre>
			<pre class="source-code">  } catch (Exception ex) {</pre>
			<pre class="source-code">        ex.printStackTrace();</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  System.out.println("Exit the applyPushPromise function...");</pre>
			<pre class="source-code">}</pre>
			<p>This implementation of the function does not do much. It just prints out the URI of the push origin. But, if necessary, it can be used to receive the resources from the server (for example, images that support the provided HTML) without requesting them. This solution saves the round-trip request-response model and shortens the time of the page loading. It also can be used for updating the information on the page.</p>
			<p>You can find many code examples of a server that sends push requests; all major browsers support this feature too.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor263"/>WebSocket support</h2>
			<p>HTTP is based on the request-response<a id="_idIndexMarker1355"/> model. A client requests a resource, and<a id="_idIndexMarker1356"/> the server provides a response to this request. As we have demonstrated several times, the client initiates the communication. Without it, the server cannot send anything to the client. To get over this limitation, the idea was first introduced as a TCP connection in the HTML5 specification and, in 2008, the first version of the WebSocket protocol was designed.</p>
			<p>It provides a full-duplex communication channel between the client and the server. After the connection is established, the server can send a message to the client at any time. Together with JavaScript and HTML5, the WebSocket protocol support allows web applications to present a far more dynamic user interface.</p>
			<p>The WebSocket protocol<a id="_idIndexMarker1357"/> specification defines WebSocket (<strong class="source-inline">ws</strong>) and WebSocket Secure (<strong class="source-inline">wss</strong>) as two schemes that are used for unencrypted and encrypted connections, respectively. The protocol does not support fragmentation, but allows all the other URI components described in the <em class="italic">URL syntax</em> section.</p>
			<p>All the classes that support the WebSocket protocol<a id="_idIndexMarker1358"/> for a client are located in the <strong class="source-inline">java.net</strong> package. To create a client, we need to implement the <strong class="source-inline">WebSocket.Listener</strong> interface, which has the following methods: </p>
			<ul>
				<li><strong class="source-inline">onText()</strong>: Invoked when textual data has been received</li>
				<li><strong class="source-inline">onBinary()</strong>: Invoked when binary data has been received</li>
				<li><strong class="source-inline">onPing()</strong>: Invoked when a ping message has been received</li>
				<li><strong class="source-inline">onPong()</strong>: Invoked when a pong message has been received</li>
				<li><strong class="source-inline">onError()</strong>: Invoked when an error has happened</li>
				<li><strong class="source-inline">onClose()</strong>: Invoked when a close message has been received</li>
			</ul>
			<p>All the methods of this interface are <strong class="source-inline">default</strong>. This means that you do not need to implement all of them, but only those that the client requires for a particular task (see the private <strong class="source-inline">WsClient</strong> class in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">class WsClient implements WebSocket.Listener {</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public void onOpen(WebSocket webSocket) {</pre>
			<pre class="source-code">        System.out.println("Connection established.");</pre>
			<pre class="source-code">        webSocket.sendText("Some message", true);</pre>
			<pre class="source-code">        Listener.super.onOpen(webSocket);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public CompletionStage onText(WebSocket webSocket, </pre>
			<pre class="source-code">                             CharSequence data, boolean last) {</pre>
			<pre class="source-code">        System.out.println("Method onText() got data: " + </pre>
			<pre class="source-code">                                                         data);</pre>
			<pre class="source-code">        if(!webSocket.isOutputClosed()) {</pre>
			<pre class="source-code">            webSocket.sendText("Another message", true);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        return Listener.super.onText(webSocket, data, last);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public CompletionStage onClose(WebSocket webSocket, </pre>
			<pre class="source-code">                               int statusCode, String reason) {</pre>
			<pre class="source-code">        System.out.println("Closed with status " + </pre>
			<pre class="source-code">                           statusCode + ", reason: " + reason);</pre>
			<pre class="source-code">        return Listener.super.onClose(webSocket, </pre>
			<pre class="source-code">                                           statusCode, reason);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>A server can be implemented<a id="_idIndexMarker1359"/> in a similar way, but server implementation<a id="_idIndexMarker1360"/> is beyond the scope of this book. To demonstrate the preceding client code, we are going to use a WebSocket server provided by the <strong class="source-inline">echo.websocket.events</strong> website. It allows a WebSocket connection and sends<a id="_idIndexMarker1361"/> the received message back; such a server is typically called an <strong class="bold">echo server</strong>.</p>
			<p>We expect that our client will send the message after the connection is established. Then, it will receive (the same) message from the server, display it, and send back another message, and so on, until it is closed. The following code invokes the client that we created (see the <strong class="source-inline">webSocket()</strong> method in the <strong class="source-inline">HttpClientDemo</strong> class):</p>
			<pre class="source-code">HttpClient httpClient = HttpClient.newHttpClient();</pre>
			<pre class="source-code">WebSocket webSocket = httpClient.newWebSocketBuilder()</pre>
			<pre class="source-code">    .buildAsync(URI.create("ws://echo.websocket.events"), </pre>
			<pre class="source-code">                           new WsClient()).join();</pre>
			<pre class="source-code">System.out.println("The WebSocket was created and ran asynchronously.");</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    TimeUnit.MILLISECONDS.sleep(200);</pre>
			<pre class="source-code">} catch (InterruptedException ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">webSocket.sendClose(WebSocket.NORMAL_CLOSURE, "Normal closure")</pre>
			<pre class="source-code">         .thenRun(() -&gt; System.out.println("Close is sent."));</pre>
			<p>The preceding code creates a <strong class="source-inline">WebSocket</strong> object using the <strong class="source-inline">WebSocket.Builder</strong> class. The <strong class="source-inline">buildAsync()</strong> method returns the <strong class="source-inline">CompletableFuture</strong> object. The <strong class="source-inline">join()</strong> method of the <strong class="source-inline">CompletableFuture</strong> class returns<a id="_idIndexMarker1362"/> the result value when<a id="_idIndexMarker1363"/> complete, or throws an exception. If an exception is not generated, then, as we mentioned already, the <strong class="source-inline">WebSocket</strong> communication continues<a id="_idIndexMarker1364"/> until either side sends a <strong class="bold">Close</strong> message. That is why our client waits for 200 milliseconds, and then sends the <strong class="bold">Close</strong> message and exits. If we run this code, we will see the following messages:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B18388_Figure_11.25.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p>As you can see, the client behaves as expected. To finish our discussion, we would like to mention the fact that all modern web browsers support the WebSocket protocol.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor264"/>Summary</h1>
			<p>In this chapter, you were presented with a description of the most popular network protocols: UDP, TCP/IP, and WebSocket. The discussion was illustrated with code examples using JCL. We also reviewed URL-based communication and the latest Java HTTP 2 Client API.</p>
			<p>Now you can use the basic internet protocols to send/receive messages between client and server, and also know how to create a server as a separate project and how to create and use a common shared library.</p>
			<p>The next chapter provides an overview of Java GUI technologies and demonstrates a GUI application using JavaFX, including code examples with control elements, charts, CSS, FXML, HTML, media, and various other effects. You will learn how to use JavaFX to create a GUI application.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor265"/>Quiz</h1>
			<ol>
				<li value="1">Name five network protocols of the application layer. </li>
				<li>Name two network protocols of the transport layer.</li>
				<li>Which Java package includes classes that support the HTTP protocol?</li>
				<li>Which protocol is based on exchanging datagrams?</li>
				<li>Can a datagram be sent to the IP address where there is no server running?</li>
				<li>Which Java package contains classes that support UDP and TCP protocols?</li>
				<li>What does TCP stand for?</li>
				<li>What is common between the TCP and TCP/IP protocols?</li>
				<li>How is a TCP session identified?</li>
				<li>Name one principal difference between the functionality of <strong class="source-inline">ServerSocket</strong> and <strong class="source-inline">Socket</strong>.</li>
				<li>Which is faster, TCP or UDP?</li>
				<li>Which is more reliable, TCP or UDP?</li>
				<li>Name three TCP-based protocols.</li>
				<li>Which of the following are the components of a URI? Select all that apply:<ol><li>Fragment</li><li>Title</li><li>Authority</li><li>Query</li></ol></li>
				<li>What is the difference between <strong class="source-inline">scheme</strong> and <strong class="source-inline">protocol</strong>?</li>
				<li>What is the difference between a URI and a URL?</li>
				<li>What does the following code print?<p class="source-code">  URL url = new URL("http://www.java.com/something?par=42");</p><p class="source-code">  System.out.print(url.getPath());  </p><p class="source-code">  System.out.println(url.getFile());   </p></li>
				<li>Name two new features that HTTP 2 has that HTTP 1.1 does not.</li>
				<li>What is the fully qualified name of the <strong class="source-inline">HttpClient</strong> class?</li>
				<li>What is the fully qualified name of the <strong class="source-inline">WebSocket</strong> class?</li>
				<li>What is the difference between <strong class="source-inline">HttpClient.newBuilder().build()</strong> and <strong class="source-inline">HttpClient.newHttpClient()</strong>?</li>
				<li>What is the fully qualified name of the <strong class="source-inline">CompletableFuture</strong> class?</li>
			</ol>
		</div>
	</body></html>