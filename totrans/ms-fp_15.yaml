- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: Specify what you want to do without specifying how exactly to do it.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定你想做什么，而不指定如何确切地做。
- en: Don't Repeat Yourself.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要重复自己。
- en: Goto is a lower-level primitive used to construct higher-level logic. All the
    logic that can be done with goto is doable with loops and other control structures.
    Declaring that you want to have a chunk of code looped excludes the possibility
    of bugs you would have if you tried to implement that loop by yourself, via goto.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Goto 是一个较低级的原语，用于构建高级逻辑。所有可以用 goto 实现的逻辑都可以用循环和其他控制结构实现。声明你想要一段代码循环执行，排除了如果你尝试通过
    goto 实现该循环时可能出现的错误。
- en: Chapter 2
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: As behaviors of their objects.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为它们对象的行为。
- en: As mathematical functions. Computations of a value based on some input values
    without side effects.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为数学函数。基于一些输入值计算值而不产生副作用。
- en: Functions that accept other functions as their inputs.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受其他函数作为输入的函数。
- en: One application is to write control structures.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个应用是编写控制结构。
- en: Chapter 3
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: You specify what needs to be done algorithmically, with the help of the low-level
    operations defined in the imperative collections.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用在命令式集合中定义的低级操作来指定需要算法执行的任务。
- en: You specify your program as an expression, with the help of high-level operations
    defined in the functional collections.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用在函数式集合中定义的高级操作将你的程序指定为一个表达式。
- en: All the algorithms you may need are already implemented in the framework. You
    only need to call them by name when you need them. All the programs you may want
    to write can be expressed as a combination of the high-level operations implemented
    in the framework.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要的所有算法都已经在前端框架中实现。你只需要在需要时按名称调用它们。你可能想要编写的所有程序都可以表达为框架中实现的高级操作的组合。
- en: Understand the program as a mathematical expression rather than an algorithm.
    An expression is a structure that consists of operands (data) bound together by
    operators (behavior).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将程序视为一个数学表达式，而不是一个算法。表达式是一个由操作符（行为）连接的操作数（数据）的结构。
- en: Lesser mental load on the programmer's mind. Algebraic programs usually remove
    side effects such as errors or time from the equation. So you do not need to think
    about them. This is in contrast to imperative programs where side effects occur
    freely and you need to keep them all in mind.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对程序员心智的负担更小。代数程序通常从方程中移除副作用，如错误或时间。因此，你不需要考虑它们。这与命令式程序形成对比，在命令式程序中，副作用是自由发生的，你需要记住所有这些副作用。
- en: They reify side effects. Reification means turning phenomena into data. For
    example, instead of throwing an exception (phenomenon), we can return a data structure
    with that exception object from a method.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们具体化了副作用。具体化意味着将现象转化为数据。例如，我们可以在方法中返回一个包含异常对象的数据结构，而不是抛出异常（现象）。
- en: Chapter 4
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: For this book, side effects are defined as modifications and interactions with
    the environment outside the scope of the current unit of logic (function).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这本书，副作用被定义为对当前逻辑单元（函数）作用域之外的环境的修改和交互。
- en: It is a data that can be changed by the program.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是可以被程序改变的数据。
- en: They cause extra mental load on your mind, which may lead to bugs. There are
    much more things to keep in mind with side effects and mutable state. The scope
    of your attention must extend much further than the piece of logic that you are
    working on at the moment.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们会在你的脑海中增加额外的认知负担，这可能导致错误。与副作用和可变状态相关的事情还有很多需要记住。你的注意力范围必须远远超出你目前正在工作的逻辑部分。
- en: It is a function that does not produce any side effects.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是一个不产生任何副作用的函数。
- en: The ability to substitute a call to a function with the result of that call
    in code without changing the semantics of that code.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能够在代码中用函数调用的结果替换对函数的调用，而不改变代码的语义。
- en: Decrease the mental load you face. Hence decrease the possibility of bugs.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少你面临的认知负担。因此，减少出现错误的可能性。
- en: Errors, an absence of a result, delayed competition, logging, input-output operations.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误、结果缺失、延迟竞争、日志记录、输入输出操作。
- en: Yes, it is. Programming in the purely functional style is just a matter of understanding
    the concepts of side effects, understanding how they are harmful, being able to
    see the side effects and their harm in code, and knowledge on how to abstract
    them away. It is possible to write abstractions for side effects in modern imperative
    programming languages.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，是这样的。在纯函数式风格中编程只是理解副作用的概念，理解它们是如何有害的，能够看到代码中的副作用及其危害，以及如何抽象它们的知识。在现代命令式编程语言中，可以编写用于副作用抽象的抽象。
- en: It is the presence of the infrastructure to support you. Most of the abstractions
    you may need are already present in the language. Most of the libraries are functional.
    The community is also likely to be oriented to the functional style.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是支持你的基础设施的存在。你可能需要的绝大多数抽象在语言中已经存在。大多数库都是函数式的。社区也倾向于函数式风格。
- en: Chapter 5
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: The first order reality is the reality of their business domain. The reality
    of the business domain is the reality in which the programming is solving their
    business task. The second-order reality is the reality of writing and running
    a program.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一阶现实是他们业务领域的现实。业务领域的现实是编程解决他们业务任务的现实。第二阶现实是编写和运行程序的现实。
- en: It provides a set of techniques to abstract away the phenomena of the second-order
    reality.  First, you need to identify a repeating phenomenon. Then, you need to
    create a data structure to abstract away this phenomenon. The idea is to abstract
    away the phenomena by describing them, without actually making them happen.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供了一套技术来抽象掉第二阶现实的现象。首先，你需要识别一个重复的现象。然后，你需要创建一个数据结构来抽象掉这个现象。想法是通过描述它们来抽象掉现象，而实际上并不让它们发生。
- en: The control over how the program runs and how its codebase is structured.  If
    left without control, the complexity of the second-order reality can overwhelm
    you and cause mental load.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对程序运行方式和代码库结构的控制。如果缺乏控制，第二阶现实的复杂性可能会压倒你，造成心理负担。
- en: Chapter 6
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Asynchronous computations.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步计算。
- en: Try represents the erroneous case as an exception. Exceptions may not always
    be desirable in a functional context since they make sense only when we want to
    throw them. Functional programming discourages throwing exceptions since they
    are side effects. Hence, we have a more general type called Either that is capable
    of representing an alternative between any two values.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Try将错误情况表示为异常。在函数式环境中，异常可能并不总是期望的，因为它们只有在我们要抛出它们时才有意义。函数式编程不鼓励抛出异常，因为它们是副作用。因此，我们有一个更通用的类型叫做Either，它能够表示两个值之间的替代。
- en: One way of representing dependency injection in functional programming is via
    the Reader type. It is an abstraction of the fact that a computation depends on
    some value and cannot be executed without it. Reader is basically a function.
    However, it has a more concise signature, and the concept of continuation with
    flatmap is applied to it the same way as to any other effect type.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程中表示依赖注入的一种方式是通过Reader类型。它是对这样一个事实的抽象：一个计算依赖于某些值，没有它无法执行。Reader基本上是一个函数。然而，它有一个更简洁的签名，并且将flatmap的概念应用于它，就像应用于任何其他效果类型一样。
- en: Flatmap allows you to sequentially compose side-effecting computations that
    use effect types to represent side effects.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flatmap允许你按顺序组合使用效果类型表示副作用的效果计算。
- en: Chapter 7
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: In Scala, Rich Wrapper is a pattern that allows you to simulate method injection
    into classes.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Scala中，Rich Wrapper是一种模式，允许你模拟将方法注入到类中。
- en: The pattern is implemented in Scala using the implicit conversions mechanism.
    Whenever you are trying to call a method on a class that doesn't have this method,
    the compiler tries to convert the instance of that class into another class that
    has this method.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该模式在Scala中使用隐式转换机制实现。每次你尝试在缺少该方法的类上调用方法时，编译器都会尝试将该类的实例转换为具有该方法的另一个类的实例。
- en: See the explanation in the Intuition section in Chapter 7.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅第7章直觉部分的解释。
- en: The motivation behind the type class pattern is to separate the effect types
    from their behaviour so that it is possible to define new behaviours and inject
    them into existing type classes based on different scenarios that arise when performing
    functional programming.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型类模式背后的动机是将效果类型与其行为分离，以便能够根据执行函数式编程时出现的不同场景定义新的行为并将它们注入到现有的类型类中。
- en: Yes, imperative languages do have type classes. However, in general, they lack
    mechanisms for their convenient usage.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，命令式语言确实有类型类。然而，通常它们缺乏方便使用的机制。
- en: Chapter 8
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: The type classes repeat from project to project. Hence, it makes sense to unify
    them into libraries.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型类在项目之间重复。因此，将它们统一到库中是有意义的。
- en: '`foldLeft`, `foldRight`, `traverse`.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`foldLeft`, `foldRight`, `traverse`.'
- en: Composition of a list of effectful computations.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一系列有影响计算的组合。
- en: '`flatMap`, `pure`, `tailRecM`.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flatMap`、`pure`、`tailRecM`。'
- en: Sequential composition of two computations, one of which depends on the result
    of another.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个计算的顺序组合，其中一个依赖于另一个的结果。
- en: Core package with type classes, `syntax` package with rich wrappers to inject
    syntax into effect types, `instances` package with the type class implementations
    for some effect types, `data` package with effect types for functional programming.
    Also, Cats has some auxiliary packages for more specific tasks not discussed in
    the book. Consult Cats documentation to learn about these.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心包包含类型类，`syntax` 包包含丰富的包装器，可以将语法注入到效果类型中，`instances` 包包含某些效果类型的类型类实现，`data`
    包包含用于函数式编程的效果类型。此外，Cats还有一些用于书中未讨论的更具体任务的辅助包。请参阅Cats文档了解这些信息。
- en: Chapter 9
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: Blocking computations block the thread they are using in case they need to wait
    for some event to happen. Non-blocking computations release the thread if they
    don't need it. Released threads can be reused by other tasks.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阻塞计算在需要等待某些事件发生时将阻塞它们所使用的线程。非阻塞计算在不需要时释放线程。释放的线程可以被其他任务重用。
- en: You need asynchronous programming so that the threads are utilized doing useful
    work and not waiting upon an event to happen.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要异步编程，以便线程可以利用进行有用的工作，而不是等待事件发生。
- en: You can separate the business logic from the strategy of concurrent execution.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将业务逻辑与并发执行策略分开。
- en: '`IO`  is an effect type which encapsulates the side effect of delayed computations.
    It uses the computation-as-a-value approach, and thus is a specification of the
    computation to be performed.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IO` 是一种封装延迟计算副作用的效果类型。它使用计算作为值的方法，因此是对要执行的计算的规范。'
- en: '`start` to start `IO` asynchronously from a monadic flow. `flatMap` to compose `IO`
    with other `IO`s sequentially. Please see API documentation of `IO` for the full
    list.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `start` 从单调流异步启动 `IO`。使用 `flatMap` 顺序组合 `IO`。请参阅 `IO` 的 API 文档以获取完整列表。
- en: Chapter 10
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: Monad Transformers are used to combine two effect types into one.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Monad Transformers用于将两种效果类型组合成一种。
- en: Tagless Final allows to delay the choice of an effect type and compose the program
    in terms of the capabilities this effect type must have.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无标签最终允许延迟选择效果类型，并使用该效果类型必须具备的能力来组合程序。
- en: Type-level computations allow to identify more errors on compile time, hence
    increasing compile-time safety.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型级计算允许在编译时识别更多错误，从而提高编译时安全性。
- en: Chapter 11
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: Whenever a thread needs to access a non-thread-safe resource, it takes a monitor
    on this resource. Monitor guarantees that only the thread that owns this monitor
    can work with his resource.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当线程需要访问非线程安全资源时，它都会对这个资源采取监视器。监视器保证只有拥有这个监视器的线程可以与其资源一起工作。
- en: A Deadlock is a situation when two threads depend on the progress of one another,
    and neither of them can't progress until the other thread does. So both threads
    stagnate. See chapter 11 for an example of how a deadlock can occur.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死锁是一种情况，当两个线程依赖于另一个线程的进度，并且它们中的任何一个都不能在没有另一个线程之前进展。因此，两个线程都停滞不前。请参阅第11章了解死锁如何发生的一个示例。
- en: An actor is a concurrency primitive. It has a mailbox where it can accept messages
    from other actors. It can send messages to other actors. It is defined in terms
    of reactions to the messages of other actors. Only one message can be processed
    at a time by a given actor. It is guaranteed that if an actor owns a non-thread-safe
    resource, no other actor is allowed to own it.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个actor是一个并发原语。它有一个邮箱，它可以接受来自其他actor的消息。它可以向其他actor发送消息。它是在其他actor的消息反应的术语中定义的。一个actor一次只能处理一个消息。保证如果一个actor拥有非线程安全资源，则不允许其他actor拥有它。
- en: Since only one actor controls a non-thread safe resource, there is no danger
    of race conditions or deadlocks. Whenever other actors need access to the resource
    in question, they do so by asking the owner actor. The operation is performed
    indirectly by the owner actor of the resource, and the resource itself is never
    exposed to the outer world.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于只有一个actor控制一个非线程安全资源，因此不存在竞态条件或死锁的危险。每当其他actor需要访问相关资源时，它们会通过请求拥有该资源的actor来访问。操作由资源的所有者actor间接执行，资源本身永远不会暴露给外部世界。
- en: Chapter 12
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: Encapsulation with Actors—mutable state is only accessible from one actor, one
    thread. Actors are organized in hierarchies, and parents supervise children to
    achieve fault tolerance.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Actor进行封装——可变状态只能从一个actor或一个线程中访问。Actor以层次结构组织，父母监督子女以实现容错性。
- en: We do so by extending the `Actor` class and implementing the `receive` method.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过扩展`Actor`类并实现`receive`方法来实现这一点。
- en: We do so by calling the `actorOf` method on `ActorSystem` or `ActorContext`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在`ActorSystem`或`ActorContext`上调用`actorOf`方法来实现这一点。
- en: Using the `!` operator on an `ActorRef`—`targetActor ! message`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ActorRef`上使用`!`运算符——`targetActor ! message`。
- en: 'The `!` operator implements a `fire-and-forget` type of message sending. It
    sends a message and returns immediately. Ask pattern involves sending a message
    using `?` operator instead, which returns a `Future[Any]` which will complete
    once the target actor responds—`val futureMessage: Future[Any] = targetActor ?
    message`.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`!`运算符实现了`fire-and-forget`类型的消息发送。它发送消息后立即返回。询问模式涉及使用`?`运算符发送消息，该运算符返回一个`Future[Any]`，该`Future`将在目标actor响应后完成——`val
    futureMessage: Future[Any] = targetActor ? message`。'
- en: The Pipe pattern instructs a `Future` to send a message to an actor upon completion
    of the `Future`'s computation—`future pipeTo targetActor`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道模式指示`Future`在`Future`的计算完成后向actor发送消息——`future pipeTo targetActor`。
