- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specify what you want to do without specifying how exactly to do it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don't Repeat Yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Goto is a lower-level primitive used to construct higher-level logic. All the
    logic that can be done with goto is doable with loops and other control structures.
    Declaring that you want to have a chunk of code looped excludes the possibility
    of bugs you would have if you tried to implement that loop by yourself, via goto.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As behaviors of their objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mathematical functions. Computations of a value based on some input values
    without side effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions that accept other functions as their inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One application is to write control structures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You specify what needs to be done algorithmically, with the help of the low-level
    operations defined in the imperative collections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You specify your program as an expression, with the help of high-level operations
    defined in the functional collections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the algorithms you may need are already implemented in the framework. You
    only need to call them by name when you need them. All the programs you may want
    to write can be expressed as a combination of the high-level operations implemented
    in the framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understand the program as a mathematical expression rather than an algorithm.
    An expression is a structure that consists of operands (data) bound together by
    operators (behavior).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lesser mental load on the programmer's mind. Algebraic programs usually remove
    side effects such as errors or time from the equation. So you do not need to think
    about them. This is in contrast to imperative programs where side effects occur
    freely and you need to keep them all in mind.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They reify side effects. Reification means turning phenomena into data. For
    example, instead of throwing an exception (phenomenon), we can return a data structure
    with that exception object from a method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this book, side effects are defined as modifications and interactions with
    the environment outside the scope of the current unit of logic (function).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a data that can be changed by the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They cause extra mental load on your mind, which may lead to bugs. There are
    much more things to keep in mind with side effects and mutable state. The scope
    of your attention must extend much further than the piece of logic that you are
    working on at the moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a function that does not produce any side effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ability to substitute a call to a function with the result of that call
    in code without changing the semantics of that code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrease the mental load you face. Hence decrease the possibility of bugs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Errors, an absence of a result, delayed competition, logging, input-output operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, it is. Programming in the purely functional style is just a matter of understanding
    the concepts of side effects, understanding how they are harmful, being able to
    see the side effects and their harm in code, and knowledge on how to abstract
    them away. It is possible to write abstractions for side effects in modern imperative
    programming languages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is the presence of the infrastructure to support you. Most of the abstractions
    you may need are already present in the language. Most of the libraries are functional.
    The community is also likely to be oriented to the functional style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first order reality is the reality of their business domain. The reality
    of the business domain is the reality in which the programming is solving their
    business task. The second-order reality is the reality of writing and running
    a program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It provides a set of techniques to abstract away the phenomena of the second-order
    reality.  First, you need to identify a repeating phenomenon. Then, you need to
    create a data structure to abstract away this phenomenon. The idea is to abstract
    away the phenomena by describing them, without actually making them happen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The control over how the program runs and how its codebase is structured.  If
    left without control, the complexity of the second-order reality can overwhelm
    you and cause mental load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous computations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try represents the erroneous case as an exception. Exceptions may not always
    be desirable in a functional context since they make sense only when we want to
    throw them. Functional programming discourages throwing exceptions since they
    are side effects. Hence, we have a more general type called Either that is capable
    of representing an alternative between any two values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One way of representing dependency injection in functional programming is via
    the Reader type. It is an abstraction of the fact that a computation depends on
    some value and cannot be executed without it. Reader is basically a function.
    However, it has a more concise signature, and the concept of continuation with
    flatmap is applied to it the same way as to any other effect type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flatmap allows you to sequentially compose side-effecting computations that
    use effect types to represent side effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala, Rich Wrapper is a pattern that allows you to simulate method injection
    into classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pattern is implemented in Scala using the implicit conversions mechanism.
    Whenever you are trying to call a method on a class that doesn't have this method,
    the compiler tries to convert the instance of that class into another class that
    has this method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the explanation in the Intuition section in Chapter 7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The motivation behind the type class pattern is to separate the effect types
    from their behaviour so that it is possible to define new behaviours and inject
    them into existing type classes based on different scenarios that arise when performing
    functional programming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, imperative languages do have type classes. However, in general, they lack
    mechanisms for their convenient usage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type classes repeat from project to project. Hence, it makes sense to unify
    them into libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`foldLeft`, `foldRight`, `traverse`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Composition of a list of effectful computations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`flatMap`, `pure`, `tailRecM`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sequential composition of two computations, one of which depends on the result
    of another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Core package with type classes, `syntax` package with rich wrappers to inject
    syntax into effect types, `instances` package with the type class implementations
    for some effect types, `data` package with effect types for functional programming.
    Also, Cats has some auxiliary packages for more specific tasks not discussed in
    the book. Consult Cats documentation to learn about these.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blocking computations block the thread they are using in case they need to wait
    for some event to happen. Non-blocking computations release the thread if they
    don't need it. Released threads can be reused by other tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need asynchronous programming so that the threads are utilized doing useful
    work and not waiting upon an event to happen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can separate the business logic from the strategy of concurrent execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IO`  is an effect type which encapsulates the side effect of delayed computations.
    It uses the computation-as-a-value approach, and thus is a specification of the
    computation to be performed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`start` to start `IO` asynchronously from a monadic flow. `flatMap` to compose `IO`
    with other `IO`s sequentially. Please see API documentation of `IO` for the full
    list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monad Transformers are used to combine two effect types into one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tagless Final allows to delay the choice of an effect type and compose the program
    in terms of the capabilities this effect type must have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type-level computations allow to identify more errors on compile time, hence
    increasing compile-time safety.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a thread needs to access a non-thread-safe resource, it takes a monitor
    on this resource. Monitor guarantees that only the thread that owns this monitor
    can work with his resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Deadlock is a situation when two threads depend on the progress of one another,
    and neither of them can't progress until the other thread does. So both threads
    stagnate. See chapter 11 for an example of how a deadlock can occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An actor is a concurrency primitive. It has a mailbox where it can accept messages
    from other actors. It can send messages to other actors. It is defined in terms
    of reactions to the messages of other actors. Only one message can be processed
    at a time by a given actor. It is guaranteed that if an actor owns a non-thread-safe
    resource, no other actor is allowed to own it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since only one actor controls a non-thread safe resource, there is no danger
    of race conditions or deadlocks. Whenever other actors need access to the resource
    in question, they do so by asking the owner actor. The operation is performed
    indirectly by the owner actor of the resource, and the resource itself is never
    exposed to the outer world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation with Actors—mutable state is only accessible from one actor, one
    thread. Actors are organized in hierarchies, and parents supervise children to
    achieve fault tolerance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do so by extending the `Actor` class and implementing the `receive` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do so by calling the `actorOf` method on `ActorSystem` or `ActorContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `!` operator on an `ActorRef`—`targetActor ! message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `!` operator implements a `fire-and-forget` type of message sending. It
    sends a message and returns immediately. Ask pattern involves sending a message
    using `?` operator instead, which returns a `Future[Any]` which will complete
    once the target actor responds—`val futureMessage: Future[Any] = targetActor ?
    message`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Pipe pattern instructs a `Future` to send a message to an actor upon completion
    of the `Future`'s computation—`future pipeTo targetActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
