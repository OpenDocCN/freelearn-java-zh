<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Security Enhancements</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>In the last chapter, we</span> <span>covered concurrency enhancements introduced with the Java 9 platform. We took an in-depth look at concurrency both as a core Java concept and as a series of enhancements for Java 9. We also explored the <kbd>Flow</kbd> class API that</span> <span>supports Reactive Programming, a new concept in Java 9. In addition, we explored concurrency enhancements and the new Spin-Wait hints introduced in Java 9.</span></p>
<p>In this chapter, we will look at several small changes made to the JDK that involve security. The size of these changes does not reflect their significance. The security enhancements introduced with the Java 9 platform provide developers with a greater ability to write and maintain applications that are more secure than previously possible.</p>
<p>Specifically, we will review the following content areas in this chapter:</p>
<ul>
<li>Datagram Transport Layer Security</li>
<li>Creating PKCS12 keystores</li>
<li>Improving security application performance</li>
<li>TLS application-layer protocol negotiation extension</li>
<li>Leveraging CPU instructions for GHASH and RSA</li>
<li>OCSP stapling for TLS</li>
<li>DRBG-based <kbd>SecureRandom</kbd> implementations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Datagram Transport Layer Security</h1>
                </header>
            
            <article>
                
<p><strong>Datagram Transport Layer Security</strong> (<strong>DTLS</strong>), is a communications protocol. The protocol provides a layer of security for datagram-based applications. DTLS permits secure communications and is based on the <strong>Transport Layer Security</strong> (<strong>TLS</strong>) protocol. Embedded security helps ensure messages are not forged, tampered with, or eavesdropped.</p>
<p>Let's review the relevant terminology:</p>
<ul>
<li><strong>Communication protocol</strong>: A set of rules that govern how information is transmitted.</li>
<li><strong>Datagram</strong>: A structured transfer unit.</li>
<li><strong>Eavesdropping</strong>: Undetected listening to in-transit data packets.</li>
<li><strong>Forgery</strong>: Transmission of a packet with falsified sender.</li>
<li><strong>Network packet</strong>: A formatted unit of data for transmission.</li>
<li><strong>Tampering</strong>: The altering of data packets after the sender transmits them and before the intended receiver receives them.</li>
<li><strong>TLS protocol</strong>: The most common network security protocol. Uses, as an example, IMPA and POP for email.</li>
</ul>
<p>The DTLS Java Enhancement Proposal 219 is aimed at creating an API for the DTLS versions 1.0 and 1.2.</p>
<p>In the sections that follow, we will look at each of the DTLS versions, 1.0 and 1.2, and then review the changes to the Java 9 platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DTLS protocol version 1.0</h1>
                </header>
            
            <article>
                
<p>DTLS protocol version 1.0 was established in 2006 and provides communications security for datagram protocols. Here are the basic characteristics:</p>
<ul>
<li>Permits client/server applications to communicate without permitting:
<ul>
<li>Eavesdropping</li>
<li>Tampering</li>
<li>Message forgery</li>
</ul>
</li>
<li>Based on the TLS protocol</li>
<li>Provides security guarantees</li>
<li>The DLS protocol's datagram semantics are preserved</li>
</ul>
<p>The following diagram illustrates where the <strong>Transport Layer</strong> fits into the overall schema of <strong>SSL/TLS</strong> protocol layers and protocols for each layer:</p>
<div class="CDPAlignCenter CDPAlign"><img height="146" width="437" src="assets/1e3ce359-125e-4d4e-a6bf-60d6e972cdd5.png"/></div>
<p><span>DTLS protocol version 1.0 provides detailed specifications with the major areas of coverage listed as follows:</span></p>
<ul>
<li>Ciphers:
<ul>
<li>Anti-replay block cipher</li>
<li>New cipher suites</li>
<li>Standard (or null) stream cipher</li>
</ul>
</li>
<li>Denial of service countermeasures</li>
<li>Handshake:
<ul>
<li>Message format</li>
<li>Protocol</li>
<li>Reliability</li>
</ul>
</li>
<li><span>Messages:</span>
<ul>
<li><span>Fragmentation and reassembly</span></li>
<li>Loss-insensitive messaging</li>
<li><span>Size</span></li>
<li>Timeout and retransmission</li>
<li>Packet loss</li>
</ul>
</li>
<li><strong>Path Maximum Transition Unit</strong> (<strong>PMTU</strong>) discovery</li>
<li>Record layer</li>
<li>Record payload protection</li>
<li>Reordering</li>
<li>Replay detection</li>
<li>Transport layer mapping</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DTLS protocol version 1.2</h1>
                </header>
            
            <article>
                
<p><span>DTLS protocol version 1.2 was published in January 2012 and is copyrighted by the <strong>Internet Engineering Task Force</strong> (<strong>IETF</strong>). This section shares code samples that illustrate the changes in version 1.2.</span></p>
<p><span>The following code illustrates the TLS 1.2 handshake message header. This format supports:</span></p>
<ul>
<li><span>Message fragmentation</span></li>
<li><span>Message loss</span></li>
<li><span>Reordering</span></li>
</ul>
<pre><span>    // Copyright (c) 2012 IETF Trust and the persons identified as<br/>       authors of the code. All rights reserved.<br/></span>
    struct <br/>    {
      HandshakeType msg_type;
      uint24 length;
      uint16 message_seq;                           // New field
      uint24 fragment_offset;                       // New field
      uint24 fragment_length;                       // New field
      select (HandshakeType) <br/>      {
        case hello_request: HelloRequest;
        case client_hello:  ClientHello;
        case hello_verify_request: HelloVerifyRequest;  // New type
        case server_hello:  ServerHello;
        case certificate:Certificate;
        case server_key_exchange: ServerKeyExchange;
        case certificate_request: CertificateRequest;
        case server_hello_done:ServerHelloDone;
        case certificate_verify:  CertificateVerify;
        case client_key_exchange: ClientKeyExchange;
        case finished: Finished;
      } body;<br/>    } Handshake;</pre>
<div class="packt_infobox">The code presented in this section is from the DTLS protocol documentation and is republished here in accordance with IETF's <em>Legal Provisions Relating to IETF Documents</em>.</div>
<p>The record layer contains the information that we intend to send into records. The information starts off inside a <kbd>DTLSPlaintext</kbd> structure and then, after the handshake takes place, the records are encrypted and are eligible to be sent by the communication stream. The record layer format follows with new fields in version 1.2 annotated with the <kbd>// New field</kbd> in-code comments as follows:</p>
<pre class="newpage">    // Copyright (c) 2012 IETF Trust and the persons identified<br/>       as authors of the code. All rights reserved.<br/><br/><br/>    struct <br/>    {
      ContentType type;
      ProtocolVersion version;
      uint16 epoch;                                 // New field
      uint48 sequence_number;                       // New field
      uint16 length;
      opaque fragment[DTLSPlaintext.length];
    } DTLSPlaintext;

    struct <br/>    {
       ContentType type;
       ProtocolVersion version;
       uint16 epoch;                                 // New field
       uint48 sequence_number;                       // New field
       uint16 length;
       opaque fragment[DTLSCompressed.length];<br/>    } DTLSCompressed;

    struct <br/>    {
       ContentType type;
       ProtocolVersion version;
       uint16 epoch;                                 // New field
       uint48 sequence_number;                       // New field
       uint16 length;
       select (CipherSpec.cipher_type) <br/>       {
          case block:  GenericBlockCipher;
          case aead:   GenericAEADCipher;             // New field
       } fragment;
    } DTLSCiphertext;</pre>
<p>Finally, here is the updated handshake protocol:</p>
<pre class="newpage">    // Copyright (c) 2012 IETF Trust and the persons identified<br/>       as authors of the code. All rights reserved.<br/><br/>    enum {
      hello_request(0), client_hello(1),<br/>       server_hello(2),
      hello_verify_request(3),                       // New field
      certificate(11), server_key_exchange (12),
      certificate_request(13), server_hello_done(14),
      certificate_verify(15), client_key_exchange(16),
      finished(20), (255) } HandshakeType;

      struct {
        HandshakeType msg_type;
        uint24 length;
        uint16 message_seq;                            // New field
        uint24 fragment_offset;                        // New field
        uint24 fragment_length;                        // New field
        select (HandshakeType) {
          case hello_request: HelloRequest;
          case client_hello:  ClientHello;
          case server_hello:  ServerHello;
          case hello_verify_request: HelloVerifyRequest;  // New field
          case certificate:Certificate;
          case server_key_exchange: ServerKeyExchange;
          case certificate_request: CertificateRequest;
          case server_hello_done:ServerHelloDone;
          case certificate_verify:  CertificateVerify;
          case client_key_exchange: ClientKeyExchange;
          case finished: Finished;
        } body; } Handshake;

      struct {
        ProtocolVersion client_version;
        Random random;
        SessionID session_id;
        opaque cookie&lt;0..2^8-1&gt;;                          // New field
        CipherSuite cipher_suites&lt;2..2^16-1&gt;;
        CompressionMethod compression_methods&lt;1..2^8-1&gt;; } ClientHello;

      struct {
        ProtocolVersion server_version;
        opaque cookie&lt;0..2^8-1&gt;; } HelloVerifyRequest;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DTLS support in Java 9</h1>
                </header>
            
            <article>
                
<p>Java 9's implementation of the DTLS API is transport-independent and light-weight. The design considerations for the API were as follows:</p>
<ul>
<li>Read timeouts will not be managed</li>
<li>The implementation will use a single TLS record for each wrap/unwrap operation</li>
<li>The application, not the API, will be required to:
<ul>
<li>Determine timeout values</li>
<li>Assemble out-of-order application data</li>
</ul>
</li>
</ul>
<p>The DTLS is a protocol used to secure data from the application layer before that data is passed to a transport layer protocol. DTLS is a good solution for encrypting and transmitting real-time data. Caution should be exercised so that we do not introduce vulnerabilities in our application's implementation. Here are security considerations specific to implementing DTLS in your Java 9 applications:</p>
<ul>
<li>Implement DTLS v1.2, since that is the latest version supported by Java 9.</li>
<li>Avoid <strong>Rivest-Shamir-Adleman</strong> (<strong>RSA</strong>) encryption. If RSA must be used, add addition security to your private keys since this is a weak point for RSA.</li>
<li>Use 192 bits or more when using the <strong>Elliptic Curve Diffie-Hellman</strong> (<strong>ECDH</strong>) anonymous key agreement protocol. The 192-bit value is based on a <strong>National Institute of Standards and Technology</strong> (<strong>NIST</strong>) recommendation.</li>
<li>The use of <strong>Authenticated Encryption with Associated Data</strong> (<strong>AEAD</strong>), a form of encryption, is highly recommended. AEAD provides authenticity, confidentiality, and integrity assurances on the data being encrypted and decrypted.</li>
<li>Always implement the <kbd>renegotiation_info</kbd> extension when implementing handshake renegotiation.</li>
<li>Establish a <span><strong>Forward Secrecy</strong> (<strong>FS</strong>) capability in all Java applications using a communication protocol. Implementing FS</span> ensures past session encryption keys are not compromised when long-term encryption keys are compromised. Ideally a <strong>Perfect Forward Secrecy</strong> (<strong>PFS</strong>), where each key is only valid for a single session, would be used in the Java applications that call for the greatest security of transmitted data.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating PKCS12 keystores</h1>
                </header>
            
            <article>
                
<p>The Java 9 platform provides increased security for keystores. In order to appreciate the changes ushered in by Java Enhancement Proposal 229, create PKCS12 keystores by default, we will first review the concept of keystores, look at the <kbd>KeyStore</kbd> class, and then look at the changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keystore primer</h1>
                </header>
            
            <article>
                
<p>The concept of a <kbd>KeyStore</kbd> is relatively simple. It is essentially a database file, or data repository file, that stores public key certificates and private keys. The <kbd>Keystore</kbd> will be stored in the <kbd>/jre/lib/security/cacerts</kbd> folder. As you will see in the next section, this database is managed by Java's <kbd>java.security.KeyStore</kbd> class methods.</p>
<p><kbd>KeyStore</kbd> features include:</p>
<ul>
<li>Contains one of the following entry types:
<ul>
<li>Private keys</li>
<li>Public key certificates</li>
</ul>
</li>
<li>Unique alias string names for every entry</li>
<li>Password protection for each key</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java Keystore (JKS)</h1>
                </header>
            
            <article>
                
<p><span>The</span> <kbd>java.security.KeyStore</kbd> <span>class is the storage facility for cryptographic keys and certificates. This class extends <kbd>java.lang.Object</kbd>, see as follows:</span></p>
<pre>    public class KeyStore extends Object</pre>
<p><span>There are three types of entries managed by a <kbd>KeyStore</kbd>, each implements the <kbd>KeyStore.Entry</kbd> interface, one of the three interfaces provided by the <kbd>KeyStore</kbd> class. The</span> Entry implementations are defined in the following table:</p>
<table>
<tbody>
<tr>
<td><strong>Implementation</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>KeyStore.PrivateKeyEntry</kbd></td>
<td>
<ul>
<li>Contains the <kbd>PrivateKey</kbd> and can store it in a protected format</li>
<li>Contains the certificate chain for the public key</li>
</ul>
</td>
</tr>
<tr>
<td><kbd>KeyStore.SecretKeyEntry</kbd></td>
<td>
<ul>
<li>Contains the <kbd>SecretKey</kbd> and can store it in a protected format</li>
</ul>
</td>
</tr>
<tr>
<td><kbd>KeyStore.TrustedCertifcateEntry</kbd></td>
<td>
<ul>
<li>Contains a single public key <kbd>Certificate</kbd> from an external source</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>This class has been part of the Java platform since version 1.2. It has one constructor, three interfaces, six sub-classes, and several methods. The constructor definition is:</p>
<pre>    protected KeyStore(KeyStoreSpi keyStoresSpi,<br/>     Provider provider, String type)</pre>
<p><span>The</span> <kbd>KeyStore</kbd> <span>class</span> contains the following interfaces:</p>
<ul>
<li><kbd>public static interface KeyStore.Entry</kbd>:
<ul>
<li>This interface serves as a marker for <kbd>KeyStore</kbd> entry types and contains no methods.</li>
</ul>
</li>
<li><kbd>public static interface KeyStore.LoadStoreParameter</kbd>:
<ul>
<li>This interface serves as a marker for load and store parameters and has the following method that returns null or the parameter used to protect the <kbd>KeyStore</kbd> data:
<ul>
<li><kbd>getProtectionParameter()</kbd></li>
</ul>
</li>
</ul>
</li>
<li><kbd>public static interface KeyStore.ProtectionParameter</kbd>:
<ul>
<li>This interface serves as a marker for <kbd>KeyStore</kbd> protection parameters and contains no methods.</li>
</ul>
</li>
</ul>
<p><span>The</span> <kbd>java.security.KeyStore</kbd> <span>class also contains the six nested classes listed as follows.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Builder</h1>
                </header>
            
            <article>
                
<p>The <kbd>KeyStore.Builder</kbd> class is used when you want to defer the instantiation of a <kbd>KeyStore</kbd>:</p>
<pre>    public abstract static class KeyStore.Builder extends Object</pre>
<p>This class provides the necessary information for instantiating a <kbd>KeyStore</kbd> object. The class has the following methods:</p>
<ul>
<li><kbd>public abstract KeyStore getKeyStore() throws KeyStoreException</kbd></li>
<li><kbd>public abstractKeyStore.ProtectionParameter getProjectionParameter(String alias) throws KeyStoreException</kbd></li>
<li>Three options for <kbd>newInstance</kbd>:
<ul>
<li><kbd>public static KeyStore.Builder newInstance(KeyStore keyStore, KeyStore.ProtectionParameter protectionParameter)</kbd></li>
<li><kbd>public static KeyStore.Builder newInstance(String type, Provider provider, File file, KeyStore.ProtectionParameter protection)</kbd></li>
<li><kbd>public static KeyStore.Builder newInstance(String type, Provider provider, KeyStore.ProtectionParameter protection)</kbd></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The CallbackHandlerProtection class</h1>
                </header>
            
            <article>
                
<p>The <kbd>KeyStore.CallbackHandlerProtection</kbd> class definition is as follows:</p>
<pre>    public static class KeyStore.CallbackHandlerProtection extends<br/>     Object implements KeyStore.ProtectionParameter</pre>
<p>This class provides a <kbd>ProtectionParameter</kbd> to encapsulate a <kbd>CallbackHandler</kbd> and has the following method:</p>
<pre>    public CallbackHandler getCallbackHandler()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The PasswordProtection class</h1>
                </header>
            
            <article>
                
<p>The <kbd>KeyStore.PasswordProtection</kbd> class definition is as follows:</p>
<pre>    public static class KeyStore.PasswordProtection extends Object <br/>     implements KeyStore.ProtectionParameter, Destroyable</pre>
<p>This call provides an implementation of <kbd>ProtectionParameter</kbd> that is password-based. The class has the following methods:</p>
<ul>
<li><kbd>public void destroy() throws DestroyFailedException</kbd>:
<ul>
<li>This method clears the password</li>
</ul>
</li>
<li><kbd>public char[] getPassword()</kbd>:
<ul>
<li>Returns a reference to the password</li>
</ul>
</li>
<li><kbd>public boolean isDestroyed()</kbd>:
<ul>
<li>Returns true if the password was cleared</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The PrivateKeyEntry class</h1>
                </header>
            
            <article>
                
<p><span>The</span> <kbd>KeyStore.PrivateKeyEntry</kbd> <span>class definition is as follows:</span></p>
<pre>    public static final class KeyStore.PrivateKeyEntry extends<br/>     Object implements KeyStore.Entry</pre>
<p>This creates an entry to hold a <kbd>PrivateKey</kbd> and the corresponding <kbd>Certificate</kbd> chain. This class has the following methods:</p>
<ul>
<li><kbd>public Certificate getCertificate()</kbd>:
<ul>
<li>Returns the <strong>end entity</strong> <kbd>Certificate</kbd> from the <kbd>Certificate</kbd> chain</li>
</ul>
</li>
<li><kbd>public Certificate[] getCertificateChain()</kbd>:
<ul>
<li>Returns the <kbd>Certificate</kbd> chain as an array of <kbd>Certificates</kbd></li>
</ul>
</li>
<li><kbd>public PrivateKey getPrivateKey()</kbd>:
<ul>
<li>Returns the <kbd>PrivateKey</kbd> from the current entry</li>
</ul>
</li>
<li><kbd>public String toString()</kbd>:
<ul>
<li>Returns the <kbd>PrivateKeyEntry</kbd> as a <kbd>String</kbd></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The SecretKeyEntry class</h1>
                </header>
            
            <article>
                
<p><span>The</span> <kbd>KeyStore.SecretKeyEntry</kbd> <span>class definition is as follows:</span></p>
<pre>    public static final class KeyStore.SecretKeyEntry extends<br/>     Object implements KeyStore.Entry</pre>
<p>This class holds a <kbd>SecretKey</kbd> and has the following methods:</p>
<ul>
<li><kbd>public SecretKey getSecretKey()</kbd>:
<ul>
<li>Returns the entry's <kbd>SecretKey</kbd></li>
</ul>
</li>
<li><kbd>public String toString()</kbd>:
<ul>
<li>Returns the <kbd>SecretKeyEntry</kbd> as a <kbd>String</kbd>.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The TrustedCertificateEntry class</h1>
                </header>
            
            <article>
                
<p><span>The</span> <kbd>KeyStore.TrustedCertificateEntry</kbd> <span>class definition is as follows:</span></p>
<pre>    public static final class KeyStore.TrustedCertificateEntry extends<br/>     Object implements KeyStore.Entry</pre>
<p>This class holds a trusted <kbd>Certificate</kbd> and has the following methods:</p>
<ul>
<li><kbd>public Certificate getTrustedCertificate()</kbd>:
<ul>
<li>Returns the entry's trusted <kbd>Certificate</kbd></li>
</ul>
</li>
<li><kbd>public String toString()</kbd>:
<ul>
<li>Returns the entry's trusted <kbd>Certificate</kbd> as a <kbd>String</kbd></li>
</ul>
</li>
</ul>
<p>The key to using this class is understanding the flow. First, we must load the <kbd>KeyStore</kbd>, using the <kbd>getInstance</kbd> method. Next we request access to the <kbd>KeyStore</kbd> instance. Then, we have access to read and write to the <kbd>Object</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="104" width="166" src="assets/5a27e979-4b5c-4979-9eb1-ed8035aaf9d5.png"/></div>
<p>The following code snippet shows the load-request-access implementation:</p>
<pre>    . . . <br/><br/>    try {<br/>      // KeyStore implementation will be returned for the default type<br/>      KeyStore myKS = KeyStore.getInstance(KeyStore.getDefaultType());<br/><br/>      // Load<br/>      myKS.load(null, null);<br/>  <br/>      // Instantiate a KeyStore that holds a trusted certificate<br/>      TrustedCertificateEntry myCertEntry =<br/>        new TrustedCertificateEntry(generateCertificate());<br/><br/>      // Assigns the trusted certificate to the "pack.pub" alias<br/>      myKS.setCertificateEntry("packt.pub",<br/>       myCertEntry.getTrustedCertificate());<br/>  <br/>      return myKS;<br/>    } <br/>    catch (Exception e) {<br/>      throw new AssertionError(e);<br/>    }<br/>  }<br/>  . . .</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PKCS12 default in Java 9</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, the default <kbd>KeyStore</kbd> type was <strong>Java KeyStore</strong> (<strong>JKS</strong>). The Java 9 platform now uses PKCS as the default <kbd>KeyStore</kbd> type, more specifically, PKCS12.</p>
<div class="packt_infobox"><strong>PKCS</strong> is the acronym for <strong>Public Key Cryptography Standards</strong>.</div>
<p>This change to PKCS provides stronger cryptographic algorithms as compared to JKS. As you would expect, JDK 9 will still be compatible with JKS to support previously developed systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving security application performance</h1>
                </header>
            
            <article>
                
<p>Java Enhancement Proposal 232, titled <em>Improving Security Application Performance</em>, was focused on performance improvements when running applications with a security manager installed. Security managers can result in processing overhead and less than ideal application performance.</p>
<p>This is an impressive undertaking as current CPU overhead when running security managers is estimated to result in 10-15% performance degradation. It is not feasible to completely remove the CPU overhead as some CPU processing is required to run the security manager. That being said, the intention of this proposal (JEP-232) was to decrease the overhead percentage as much as possible.</p>
<p>This effort resulted in the following optimizations, each detailed in subsequent sections:</p>
<ul>
<li>Security policy enforcement</li>
<li>Permission evaluation</li>
<li>Hash code</li>
<li>Package checking algorithm</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security policy enforcement</h1>
                </header>
            
            <article>
                
<p>JDK 9 uses <kbd>ConcurrentHashMap</kbd> for mapping <kbd>ProtectionDomain</kbd> to <kbd>PermissionCollection</kbd>. <kbd>ConcurrentHashMap</kbd> is typically used for high concurrency in applications. It has the following characteristics:</p>
<ul>
<li>Thread safe</li>
<li>Enter map does not need to be synchronized</li>
<li>Fast reads</li>
<li>Writes use locks</li>
<li>No object-level locking</li>
<li>Locking at a very granular level</li>
</ul>
<p>The <kbd>ConcurrentHashMap</kbd> class definition follows:</p>
<pre>    public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; <br/>     implements ConcurrentMap&lt;K, V&gt;, Serializable</pre>
<p>In the preceding class definition, <kbd>K</kbd> refers to the type of keys maintained by the hash map and <kbd>V</kbd> indicates the type of mapped values. There is a <kbd>KeySetView</kbd> sub-class and several methods.</p>
<p>There are three additional classes related to enforcing security policy--<kbd>ProtectionDomain</kbd><span>,</span> <kbd>PermissionCollection</kbd><span>, and <kbd>SecureClassLoader</kbd>:</span></p>
<ul>
<li>The <kbd>ProtectionDomain</kbd> class is used to encapsulate a group of classes so that permissions can be granted to the domain.</li>
<li>The <kbd>PermissionCollection</kbd> class represents a collection of permission objects.</li>
<li>The <kbd>SecureClassLoader</kbd> class, which extends the <kbd>ClassLoader</kbd> class, provides additional functionality for defining classes with permissions for retrieval by the system policy. In Java 9, this class uses <kbd>ConcurrentHashMap</kbd> for increased security.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Permission evaluation</h1>
                </header>
            
            <article>
                
<p>Under the category of permission evaluation, three optimizations were made:</p>
<ul>
<li>The <kbd>identifyPolicyEntries</kbd> list previously had policy provider code for synchronization. This code has been removed in JDK 9.</li>
<li><kbd>PermissionCollection</kbd> entries are now stored in a <kbd>ConcurrentHashMap</kbd>. They were previously stored as a <kbd>HashMap</kbd> in a <kbd>Permission</kbd> class.</li>
<li>Permissions are now stored in concurrent collections in subclasses of <kbd>PermissionCollection</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The java.Security.CodeSource package</h1>
                </header>
            
            <article>
                
<p>A hash code is an object-generated number that is stored in a hash table for rapid storage and retrieval. Every object in Java has a hash code. Here are some characteristics and rules for hash codes:</p>
<ul>
<li>Hash codes are the same for equal objects within a running process</li>
<li>Hash codes can change between execution cycles</li>
<li>Hash codes should not be used as keys</li>
</ul>
<p>The Java 9 platform includes a modified <kbd>hashCode</kbd> method of <kbd>java.security.CodeSource</kbd> to optimize DNS lookups. These can be processor intensive, so a String version of the code source URL is used to compute hash codes.</p>
<p>The <kbd>CodeSource</kbd> class definition follows:</p>
<pre>    public class CodeSource extends Object implements Serializable</pre>
<p>This class has the following methods:</p>
<ul>
<li><kbd>public boolean equals(Object obj)</kbd>: Returns <kbd>true</kbd> if the objects are equal. This overrides the <kbd>equals</kbd> method in the <kbd>Object</kbd> class.</li>
<li><kbd>public final Certificate[] getCertificates()</kbd>: Returns an array of certificates.</li>
<li><kbd>public final CodeSigner[] getCodeSigners()</kbd>: Returns an array of the code signers associated with the <kbd>CodeSource</kbd>.</li>
<li><kbd>public final URL getLocation()</kbd>: Returns the URL.</li>
<li><kbd>public int hashCode()</kbd>: Returns the hash code value for the current object.</li>
<li><kbd>public boolean implies(CodeSource codesource)</kbd>: Returns true if the given code source meets the following criteria:
<ul>
<li>is not null</li>
<li>object's certificates are not null</li>
<li>object's location is not null</li>
</ul>
</li>
<li><kbd>public String toString()</kbd>: Returns a <kbd>String</kbd> with information about the <kbd>CodeSource</kbd> to include the location and certificates.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Package checking algorithm</h1>
                </header>
            
            <article>
                
<p>Java 9's final <span>performance improvement when running applications with a security manager installed, came in the form of the <kbd>java.lang.SecurityManager</kbd> package enhancements. Specifically, the <kbd>checkPackageAccess</kbd> method's package checking algorithm was modified.</span></p>
<p><span>The</span> <kbd>java.lang.SecurityManager</kbd> <span>class allows applications to implement security policy on specific operations. The <kbd>public void checkPackageAccess(String pkg)</kbd> method, of this class receives a comma-delimited list of restricted packages from the the <kbd>getProperty</kbd> method. As illustrated here, depending on the evaluation, the <kbd>checkPackageAccess</kbd> method can throw one of two exceptions:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="329" width="637" src="assets/02a1e840-2470-4f19-8d65-62d5253a66aa.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TLS application-layer protocol negotiation extension</h1>
                </header>
            
            <article>
                
<p>Java Enhancement Proposal 244, simply enhanced the <kbd>javax.net.ssl</kbd> package so that it supports the <strong>Transport Layer Security</strong> (<strong>TLS</strong>) <strong>ALPN</strong> (<strong>Application Layer Protocol Negotiation</strong>) extension. This extension permits application protocol negotiation for TLS connections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TLS ALPN extension</h1>
                </header>
            
            <article>
                
<p>The ALPN is a TLS extension and can be used to negotiate which protocol to implement when using a secure connection. ALPN represents an efficient means of negotiating protocols. As indicated in the following diagram, there are five basic steps to TLS handshakes:</p>
<div class="CDPAlignCenter CDPAlign"><img height="284" width="328" src="assets/e5960953-09f0-44c4-bfe3-86d7135a8496.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The javax.net.ssl package</h1>
                </header>
            
            <article>
                
<p>The <kbd>java.net.ssl</kbd> package contains classes relating to secure socket packages. This permits us to use SSL as an example, for the reliable detection of errors introduced to the network byte stream. It also provides the ability to encrypt the data as well as provide authentication of client and server.</p>
<p>This package includes the following interfaces:</p>
<ul>
<li><kbd>public interface HandshakeCompletedListener extends EventListener</kbd></li>
<li><kbd>public interface HostnameVerifier</kbd></li>
<li><kbd>public interface KeyManager</kbd></li>
<li><kbd><kbd>public interface ManagerFactoryParameters</kbd></kbd></li>
<li><kbd>public interface SSLSession</kbd></li>
<li><kbd>public interface SSLSessionBindingListener extends EventListener</kbd></li>
<li><kbd>public interface SSLSessionContext</kbd></li>
<li><kbd>public interace TrustManager</kbd></li>
<li><kbd>public interface X509KeyManager extends KeyManager</kbd></li>
<li><kbd>public interface X509TrustManager extends TrustManager</kbd></li>
</ul>
<p>The <span><kbd>java.net.ssl</kbd></span> package also has the following sub-classes:</p>
<ul>
<li><kbd>public class CertPathTrustManagerParameters extends Object implements ManagerFactoryParameters</kbd></li>
<li><kbd>public abstract class ExtendedSSLSession extends Object implements SSLSession</kbd></li>
<li><kbd>public class HandshakeCompleteEvent extends EventObject</kbd></li>
<li><kbd>public abstract class HttpsURLConnection extends HttpURLConnection</kbd></li>
<li><kbd>public class KeyManagerFactory extends Object</kbd></li>
<li><kbd>public abstract class KeyManagerFactorySpi</kbd></li>
<li><kbd>public class KeyStoreBuilderParameters extends Object implements ManagerFactoryParameters</kbd></li>
<li><kbd>public class SSLContext extends Object</kbd></li>
<li><kbd>public abstract class SSLContextSpi extends Object</kbd></li>
<li><kbd>public abstract class SSLEngine extends Object</kbd></li>
<li><kbd>public class SSLEngineResult extends Object</kbd></li>
<li><kbd>public class SSLParameters extends Object</kbd></li>
<li><kbd>public final class SSLPermission extends BasicPermission</kbd></li>
<li><kbd>public abstract class SSLServerSocket extends ServerSocket</kbd></li>
<li><kbd>public abstract class SSLServerSocketFactory extends ServerSocketFactory</kbd></li>
<li><kbd>public class SSLSessionBindingEvent extends EventObject</kbd></li>
<li><kbd>public abstract class SSLSocket extends Socket</kbd></li>
<li><kbd>public abstract class SSLSocketFactory extends SocketFactory</kbd></li>
<li><kbd>public class TrustManagerFactory extends Object</kbd></li>
<li><kbd><kbd>public abstract class TrustManagerFactorySpi extends Object</kbd></kbd></li>
<li><kbd>public abstract class X509ExtendedKeyManager extends Object implements X509KeyManager</kbd></li>
<li><kbd>public abstract class X509ExtendedTrustManager extends Object implements x509TrustManager</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The java.net.ssl package extension</h1>
                </header>
            
            <article>
                
<p>The change to the <kbd>java.net.ssl</kbd> package in the Java 9 platform is that it now supports the TLS ALPN extension. Key benefits of this change are:</p>
<ul>
<li>TLS clients and servers can now use multiple application-layer protocols, which may or may not use the same transport-layer port</li>
<li>The ALPN extension permits clients to prioritize application-layer protocols it supports</li>
<li>Servers can select a client protocol and for the TLS connection</li>
<li>Supports HTTP/2</li>
</ul>
<p>The following illustration was previously presented as the <span>five basic steps to TLS handshakes. Updated for Java 9 and presented here, the illustration indicates where the protocol names are shared between the client and server:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="288" width="386" src="assets/42c76c76-1288-44d0-bbd9-0adcc2fd66a9.png"/></div>
<p>Once the client's list of application layer protocols is received, the server can s<span>elect the server's preferred intersection value and e</span><span>xternally scan initial plain text <kbd>ClientHellos</kbd> and select an ALPN protocol. An application server will do one of the following:</span></p>
<ul>
<li>Select any of the supported protocols</li>
<li>Decide that the ALPN values (remotely offered and locally supported) are mutually exclusive</li>
<li>Ignore the ALPN extension</li>
</ul>
<p>Other key behaviors with regards to the ALPN extension:</p>
<ul>
<li>The server can alter connection parameters</li>
<li>After the SSL/TLS handshake starts, the application can query to see if an ALPN value has been selected yet</li>
<li>After the SSL/TLS handshake ends, the application can review which protocol was used</li>
</ul>
<p>A <kbd>ClientHello</kbd> is the first message in the TLS handshake. It has the following structure:</p>
<pre><span class="k">    struct</span> <span class="p">{</span>
      <span class="n">ProtocolVersion</span> <span class="n">client_version</span><span class="p">;</span>
      <span class="n">Random</span> <span class="n">random</span><span class="p">;</span>
      <span class="n">SessionID</span> <span class="n">session_id</span><span class="p">;</span>
      <span class="n">CipherSuite</span> <span class="n">cipher_suites</span><span class="o">&lt;</span><span class="mf">2..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="n">CompressionMethod</span> <span class="n">compression_methods</span><span class="o">&lt;</span><span class="mf">1..2</span><span class="o">^</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="n">Extension</span> <span class="n">extensions</span><span class="o">&lt;</span><span class="mf">0..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">    }</span> <span class="n">ClientHello</span><span class="p">;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveraging CPU instructions for GHASH and RSA</h1>
                </header>
            
            <article>
                
<p>The self-descriptive title of Java Enhancement Proposal (JEP) 246, <strong>Leverage CPU Instructions for GHASH and RSA</strong>, provides great insight into its goal. The point of this JEP was to improve the performance of cryptographic operations, specifically GHASH and RSA. The performance improvement has been achieved in Java 9 by leveraging the newest SPARC and Intel x64 CPU instructions.</p>
<p>This enhancement did not require new or modified APIs as part of the Java 9 platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hashing</h1>
                </header>
            
            <article>
                
<p><span><strong>Galois HASH</strong> (<strong>GHASH</strong>) and <strong>Rivest-Shamir-Adleman</strong> (<strong>RSA</strong>) are crypto systems hashing algorithms.</span> Hashes are a fixed length string or number generated from a string of text. Algorithms, specifically hashing algorithms, are devised so that the resultant hashes cannot be reverse engineered. We use hashing to store passwords that are generated with a salt.</p>
<div class="packt_infobox">Salts, in cryptology, are random data used as an input to a hashing function to generate a password. Salts help protect against rainbow table attacks and dictionary attacks.</div>
<p>The following graphic illustrates the basics of how hashing works:</p>
<div class="CDPAlignCenter CDPAlign"><img height="148" width="455" src="assets/bc2ff319-1c01-4195-9366-1dd7da6f55ec.png"/></div>
<p>As you can see, the hashing algorithm is fed plain text and a salt resulting in a new hashed password and the salt being stored. Here is the same graphic with sample input/output to demonstrate the functionality:</p>
<div class="CDPAlignCenter CDPAlign"><img height="143" width="458" src="assets/29cc5f24-4616-4f12-aed1-c6938e3872da.png"/></div>
<p>The validation process, the following diagram starts with the user entering their plain text password. The hashing algorithm takes that plain text and rehashes it with the stored salt. Then the resulting hashed password is compared to the stored one:</p>
<div class="CDPAlignCenter CDPAlign"><img height="201" width="487" src="assets/4cd20fe9-147d-4554-8d9f-dcffb007bbab.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OCSP stapling for TLS</h1>
                </header>
            
            <article>
                
<p><strong>Online Certificate Status Protocol</strong> (<strong>OCSP</strong>) stapling is a method of checking the revocation status of digital certificates. The OCSP stapling approach for determining an SSL certificate's validity is assessed as being both safe and quick. The determination speed is achieved by permitting web servers to provide the validity information on its organic certificates instead of the lengthier process of requesting validating information from the certificate's issuing vendor.</p>
<div class="packt_infobox"><span><strong>Online Certificate Status Protocol</strong> (<strong>OCSP</strong>) stapling was previously referred to as the <strong>Transport Layer Security</strong> (<strong>TLS</strong>) certificate status request extension.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OCSP stapling primer</h1>
                </header>
            
            <article>
                
<p>THE OCSP stapling process involves several components and validity checks. The following graphic illustrates the OCSP stapling process:</p>
<div class="CDPAlignCenter CDPAlign"><img height="371" width="573" src="assets/17dee8ba-f60f-49b5-84f6-f52dfa36c695.png"/></div>
<p>As you can see, the process starts when the user attempts to open an SSL-encrypted website via their browser. The browser queries the web server to ensure the SSL-encrypted website has a valid certificate. The web server queries the certificate's vendor and is provided with both the certificate status and the digital signed time-stamp. The web server takes those two components (certificate status and digital signed time-stamp), staples them together, and returns the stapled set to the requesting browser. The browser can then check the validity of the time-stamp and decide whether to display the SSL-encrypted website or to display an error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changes for the Java 9 platform</h1>
                </header>
            
            <article>
                
<p>Java Enhancement Proposal 249, <strong>OCSP Stapling for TLS</strong>, implements OCSP stapling via the TLS certificate status request extension. OSCP stapling checks the validity of X.509 certificates.</p>
<div class="packt_infobox">X.509 certificates are digital certificates that use the X509 <strong>Public Key Infrastructure</strong> (<strong>PKI</strong>).</div>
<p>Prior to Java 9, the certificate validity check (really, the check to see if the certificate has been revoked) can be enabled on the client side and has the following inefficiencies:</p>
<ul>
<li>OCSP responder performance bottlenecks</li>
<li>Performance degradation based on multiple passes</li>
<li>Additional performance degradation if OCSP checking is performed client side</li>
<li>False <strong>fails</strong> when browsers do not connect to an OCSP responder</li>
<li>Susceptibility of denial of service attacks on OCSP responders</li>
</ul>
<p>The new OCSP stapling for TLS includes the following system property changes for the Java 9 platform:</p>
<ul>
<li><kbd>jdk.tls.client.enableStatusRequestExtension</kbd>:
<ul>
<li>Default setting: true</li>
<li>Enables <kbd>status_request</kbd> extension</li>
<li>Enables <kbd>status_request_v2</kbd> extension</li>
<li>Enables processing <kbd>CertificateStatus</kbd> messages from server</li>
</ul>
</li>
<li><kbd><span>jdk.tls.server.enableStatusRequestExtension</span></kbd>:
<ul>
<li>Default setting: false</li>
<li>Enables OCSP stapling support server-side</li>
</ul>
</li>
<li><kbd><span>jdk.tls.stapling.responseTimeout</span></kbd>:
<ul>
<li>Default setting: 5000 milliseconds</li>
<li>Controls maximum time allocated by server to obtain OCSP responses</li>
</ul>
</li>
<li><kbd><span>jdk.tls.stapling.cacheSize</span></kbd>:
<ul>
<li>Default setting: 256</li>
<li>Controls maximum number of cache entries</li>
<li>Can set maximum to zero eliminates ceiling</li>
</ul>
</li>
<li><kbd><span>jdk.tls.stapling.cacheLifetime</span></kbd>:
<ul>
<li>Default setting: 3600 seconds (1 hour)</li>
<li>Controls maximum lifetime of a cached response</li>
<li>Can set value to zero in order to disable cache lifetime</li>
</ul>
</li>
<li><kbd><span>jdk.tls.stapling.responderURI</span></kbd>:
<ul>
<li>Default setting: none</li>
<li>Can set a default URI for certificates without the <strong>Authority Info Access</strong> (<strong>AIA</strong>) extension</li>
<li>Does not override the AIA extension unless <kbd>jdk.tls.stapling.Override</kbd> property is set</li>
</ul>
</li>
<li><kbd><span>jdk.tls.stapling.respoderOverride</span></kbd>:
<ul>
<li>Default setting: false</li>
<li>Allows a <kbd>jdk.tls.stapling.responderURI</kbd> provided property to override AIA extension values</li>
</ul>
</li>
<li><kbd><span>jdk.tls.stapling.ignoreExtensions</span></kbd>:
<ul>
<li>Default setting: false</li>
<li>Disables OCSP extension forwarding as specified in <kbd>status_request</kbd> or <kbd>status_request_v2</kbd> TLS extensions.</li>
</ul>
</li>
</ul>
<p>The <kbd>status_request</kbd> and <kbd>status_request_v2</kbd> TLS hello extensions are now supported by both client and server-side Java implementations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DRBG-based SecureRandom implementations</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, the JDK had two approaches to generating secure random numbers. One method, written in Java, used SHA1-based random number generation and was not terribly strong. The other method was platform-dependent and used preconfigured libraries.</p>
<p><strong>Deterministic Random Bit Generator</strong> (<strong>DRBG</strong>) is a method for generating random numbers. It has been approved by the <strong>National Institute of Standards and Technology</strong> (<strong>NIST</strong>), a branch of the U.S. Department of Commerce. DRBG methodologies include modern and stronger algorithms for generating secure random numbers.</p>
<p>Java Enhancement Proposal 273, <strong>DRBG-Based SecureRandom Implementations</strong> aimed to implement three specific DRBG mechanisms. These mechanisms are listed as follows:</p>
<ul>
<li><kbd>Hash_DRBG</kbd></li>
<li><kbd>HMAC_DRBG</kbd></li>
<li><kbd>CTR_DRBG</kbd></li>
</ul>
<div class="packt_tip">You can learn specifics about each of the DRBG mechanisms at <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf</a></div>
<p>Here are the three new APIs:</p>
<ul>
<li><kbd>SecureRandom</kbd>: New methods allowing the configuration of <kbd>SecureRandom</kbd> objects with the below listed configurable properties:<br/>
<ul>
<li>seeding</li>
<li>reseeding</li>
<li>random-bit-generation</li>
</ul>
</li>
<li><kbd>SecureRandomSpi</kbd>: new methods to implement the <kbd>SecureRandom</kbd> methods</li>
<li><kbd>SecureRandomParameter</kbd>: new interface so input can be passed to the new <kbd>SecureRandom</kbd> methods</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked a<span>t several small, but significant changes to the JDK that involve security. The featured security enhancements that are part of the Java 9 platform provide developers with the distinct ability to write and maintain applications that implement security. Specifically, we covered DTLS</span>, keystores, improving security application performance, the TLS application-layer protocol negotiation extension, leveraging CPU instructions for GHASH and RSA, OCSP stapling for TLS, and DRBG-based <kbd>SecureRandom</kbd> implementations.</p>
<p>In the next chapter we will explore the new command-line flags used in Java 9 as well as changes to various command-line tools. Our coverage will include managing the Java JVM run-time and compiler using the new command-line options and flags.</p>


            </article>

            
        </section>
    </body></html>