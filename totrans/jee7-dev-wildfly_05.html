<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Combining Persistence with CDI"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Combining Persistence with CDI</h1></div></div></div><p class="calibre8">In the earlier chapters, we discussed Java EE, combining several technologies such as CDI. The examples so far, however, are based on a false assumption that all the information can be stored in memory. In this chapter, we will show how to use a persistent data store for our application in the form of a standard relational database.</p><p class="calibre8">The <span class="strong"><strong class="calibre9">Enterprise JavaBeans</strong></span> (<span class="strong"><strong class="calibre9">EJB</strong></span>) 3.2 specification<a id="id502" class="calibre1"/> includes a reference to a persistence specification called the <span class="strong"><strong class="calibre9">Java Persistence API</strong></span> (<span class="strong"><strong class="calibre9">JPA</strong></span>). It is an API to create, remove, and query Java objects <a id="id503" class="calibre1"/>called <span class="strong"><strong class="calibre9">entities</strong></span> that can be used within both a compliant <a id="id504" class="calibre1"/>EJB 3.x container and a standard Java SE environment. In Java EE 7, it has been updated to Version 2.1. You can check out the current version of the specification I<a id="id505" class="calibre1"/> the JSR 338 at <a class="calibre1" href="https://jcp.org/en/jsr/detail?id=338">https://jcp.org/en/jsr/detail?id=338</a>.</p><p class="calibre8">We need to warn you that in this chapter, you have a lot of things to learn and hence concepts will be coming at you from every direction. However, at the end of it, you will be able to appreciate exactly how to create and deploy a complete Java EE 7 application.</p><p class="calibre8">Specifically, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The key features of JPA</li><li class="listitem">How to create your entities and database schema</li><li class="listitem">How to manipulate the entities using CDI Beans and EJBs</li><li class="listitem">Delivering a frontend tier for our application using JSF and Facelets technology</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Combining Persistence with CDI">
<div class="book" title="Data persistence meets the standard"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec25" class="calibre1"/>Data persistence meets the standard</h1></div></div></div><p class="calibre8">The arrival of an Enterprise Java Persistence standard based on the <span class="strong"><strong class="calibre9">Plain Old Java Object</strong></span> (<span class="strong"><strong class="calibre9">POJO</strong></span>) development model fills a substantial gap in the Java EE platform. The previous <a id="id506" class="calibre1"/>attempt (the EJB 2.x specification) missed the mark and <a id="id507" class="calibre1"/>created a stereotype of EJB entity beans that was awkward to develop and too heavy for many applications. Therefore, it never achieved widespread adoption or general approval in many sectors of the industry.</p><p class="calibre8">Software developers knew what they wanted, but many could not find it in the existing standards, so they decided to look elsewhere. What they found was lightweight persistence frameworks, both in the commercial and open source domains.</p><p class="calibre8">In contrast<a id="id508" class="calibre1"/> to EJB 2.x entity beans, the EJB 3.0 <span class="strong"><strong class="calibre9">Java Persistence API</strong></span> (<span class="strong"><strong class="calibre9">JPA</strong></span>) is a metadata driven POJO technology, that is, to save the data held in Java objects in a database, our objects are not required to implement an interface, extend a class, or fit into a framework pattern.</p><p class="calibre8">Another key feature of JPA is the query language called the <span class="strong"><strong class="calibre9">Java Persistence Query Language</strong></span> (<span class="strong"><strong class="calibre9">JPQL</strong></span>), which <a id="id509" class="calibre1"/>gives you a way to define the queries in a portable way, independent of the particular database you use in an enterprise environment. JPA queries resemble SQL queries by syntax but operate against entity objects rather than directly with database tables.</p></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Combining Persistence with CDI">
<div class="book" title="Data persistence meets the standard">
<div class="book" title="Working with JPA"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec36" class="calibre1"/>Working with JPA</h2></div></div></div><p class="calibre8">Inspired<a id="id510" class="calibre1"/> by ORM frameworks such as Hibernate, JPA<a id="id511" class="calibre1"/> uses annotations to map objects to a relational database. JPA entities are POJOs that do not extend any class nor implement any interface. You don't even need XML descriptors for your mapping. Actually, the JPA API is made up of annotations and only a few classes and interfaces. For example, we will mark the <code class="email">Company</code> class as <code class="email">@Entity</code>, shown as follows:</p><div class="informalexample"><pre class="programlisting">import javax.persistence.Entity;
import javax.persistence.Id;

<span class="strong"><strong class="calibre9">@Entity</strong></span>
public class Company {

    // Some code

    @Id
    private String companyName;

    public Company () {  }

    // Some code

}</pre></div><p class="calibre8">The preceding<a id="id512" class="calibre1"/> piece of code shows the minimal<a id="id513" class="calibre1"/> requirements for a class to be persistent, which are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It must be identified as an entity using the <code class="email">@javax.persistence.Entity</code> annotation</li><li class="listitem">It must have an identifier attribute annotated with <code class="email">@javax.persistence.Id</code></li><li class="listitem">It must have a no-argument constructor in at least the protected scope</li></ul></div><p class="calibre8">Since you will learn better with an example, we will show how to create and deploy a sample JPA application in WildFly in the next section.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Adding persistence to our application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec26" class="calibre1"/>Adding persistence to our application</h1></div></div></div><p class="calibre8">In<a id="id514" class="calibre1"/> order to persist data, JPA needs a relational database; we<a id="id515" class="calibre1"/> will use the PostgreSQL database, which<a id="id516" class="calibre1"/> is pretty popular among developers and can be downloaded for free from <a class="calibre1" href="http://www.postgresql.org/download/">http://www.postgresql.org/download/</a>. It is recommended to download the latest stable release of PostgreSQL 9.x and install it using the simple installation wizard. If you don't need a full-blown database, then keep in mind that later we will also show you how to use an in-memory database provided by WildFly, which can be a really useful alternative during development.</p></div>

<div class="book" title="Adding persistence to our application">
<div class="book" title="Setting up the database"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec37" class="calibre1"/>Setting up the database</h2></div></div></div><p class="calibre8">We will <a id="id517" class="calibre1"/>create a database named <code class="email">ticketsystem</code>; we<a id="id518" class="calibre1"/> will then add a user named <code class="email">jboss</code> and assign him/her all privileges on the schemas.</p><p class="calibre8">Open a shell under the <code class="email">bin</code> folder of your PostgreSQL installation and launch the executable <code class="email">psql –U postgres</code>. Once logged in with the password from your installation, execute the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">CREATE DATABASE ticketsystem;</strong></span>
<span class="strong"><strong class="calibre9">CREATE USER jboss WITH PASSWORD 'jboss';</strong></span>
<span class="strong"><strong class="calibre9">GRANT ALL PRIVILEGES ON DATABASE ticketsystem TO jboss;</strong></span>
</pre></div><p class="calibre8">Our simple schema will be made up of two tables: the <code class="email">SEAT</code> table, which contains the list of all the available seats in the theatre, and the <code class="email">SEAT_TYPE</code> table, which is used to categorize the seat types. The two tables are in a <span class="strong"><em class="calibre10">1-n</em></span> relationship and the <code class="email">SEAT</code> table hosts a foreign key that relates to the ID of the <code class="email">SEAT_TYPE</code> table. We will, however, let JPA generate <a id="id519" class="calibre1"/>the schema for us, based on our class hierarchy, which<a id="id520" class="calibre1"/> we will model in a moment.</p></div></div>

<div class="book" title="Adding persistence to our application">
<div class="book" title="Installing the JDBC driver in WildFly"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec38" class="calibre1"/>Installing the JDBC driver in WildFly</h2></div></div></div><p class="calibre8">Database <a id="id521" class="calibre1"/>connectivity is carried out in<a id="id522" class="calibre1"/> Java using JDBC drivers, which are used <a id="id523" class="calibre1"/>either directly in your applications or behind the <a id="id524" class="calibre1"/>scenes in JPA. The PostgreSQL JDBC driver can be downloaded for free from <a class="calibre1" href="http://jdbc.postgresql.org/download.html">http://jdbc.postgresql.org/download.html</a>.</p><p class="calibre8">Once the download is complete, place the <code class="email">postgresql-9.X-X.jdbc41.jar</code> file at a convenient location on your filesystem. We will now see how to install the JDBC driver in WildFly.</p><p class="calibre8">In JBoss AS 5 and 6, you used to install the JDBC driver in the <code class="email">common/lib</code> folder of your server distribution. In the new modular server architecture (introduced in JBoss AS 7), you have more than one option to install your JDBC driver. The recommended approach consists of installing the driver as a module.</p><p class="calibre8">The procedure to install a new module requires creating a module path under <code class="email">JBOSS_HOME/modules</code> and placing the <code class="email">.jar</code> libraries and the <code class="email">module.xml</code> file (that declares the module name and its dependencies) there.</p><p class="calibre8">In our example, we will add the following units to our filesystem:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">JBOSS_HOME/modules/org/postgresql/main/postgresql-9.3-1101.jdbc41.jar</code></li><li class="listitem"><code class="email">JBOSS_HOME/modules/org/postgresql/main/module.xml</code></li></ul></div><p class="calibre8">Start by simply creating the required directories in your WildFly installation (to which the <code class="email">JBOSS_HOME</code> variable points), and copying the downloaded JAR file to them.</p><p class="calibre8">Now, in the main folder, add a file named <code class="email">module.xml</code>. This file contains the actual module definition; the most interesting part of it is the module name (<code class="email">org.postgresql</code>), which corresponds to the module attribute defined in your data source.</p><p class="calibre8">Next, you need to state the path to the JDBC driver resource and the module dependencies, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;module  name="org.postgresql"&gt; 
  &lt;resources&gt;
    &lt;resource-root path=<span class="strong"><strong class="calibre9">"postgresql-9.3-1101.jdbc41.jar</strong></span>"/&gt;
  &lt;/resources&gt;
  &lt;dependencies&gt;
    &lt;module name="javax.api"/&gt;
    &lt;module name="javax.transaction.api"/&gt;
  &lt;/dependencies&gt;
&lt;/module&gt;</pre></div><p class="calibre8">We are done with the module installation. Now we need to define a data source in our configuration that will use this module and hold a pool of connections in our PostgreSQL database. In order to do this, you can edit <code class="email">standalone.xml/domain.xml</code>, adding a driver <a id="id525" class="calibre1"/>element <a id="id526" class="calibre1"/>to<a id="id527" class="calibre1"/> the data source's subsystem (be sure to merge this configuration with any existing data sources in your configuration):</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
 &lt;datasources&gt;
  &lt;datasource jta="false" 
      jndi-name="java:jboss/datasources/wflydevelopment" 
      pool-name="wflydevelopment" enabled="true"&gt;
          &lt;connection-url&gt;
           jdbc:postgresql://localhost:5432/ticketsystem
          &lt;/connection-url&gt;
          &lt;driver-class&gt;org.postgresql.Driver&lt;/driver-class&gt;
          &lt;driver&gt;postgresql&lt;/driver&gt;
          &lt;security&gt;
               &lt;user-name&gt;jboss&lt;/user-name&gt;
               &lt;password&gt;jboss&lt;/password&gt;
          &lt;/security&gt;
  &lt;/datasource&gt;
  &lt;drivers&gt;
         &lt;driver name="postgresql" module="org.postgresql"/&gt;
  &lt;/drivers&gt;
 &lt;/datasources&gt;
&lt;/subsystem&gt;</pre></div><p class="calibre8">As you can see, the new configuration file borrows the same XML schema definition from the earlier JBoss AS configurations, so it should not be difficult to migrate to the new schema. Basically, you will define the connection path to the database using the <code class="email">connection-url</code> string and the JDBC driver class with the <code class="email">driver</code> section.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note28" class="calibre1"/>Note</h3><p class="calibre8">Since JBoss AS 7.1.0, it's mandatory that the data source be bound to the <code class="email">java:/</code> or <code class="email">java:jboss/</code> JNDI namespace. This will standardize the resources definition among developers, avoiding bizarre JNDI bindings.</p></div><div class="book" title="Using the command-line interface to create a new data source"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec35" class="calibre1"/>Using the command-line interface to create a new data source</h3></div></div></div><p class="calibre8">The<a id="id528" class="calibre1"/> application <a id="id529" class="calibre1"/>server provides more than one option to add a data source to your configuration. We will just mention the command-line interface approach, which can be quite useful, especially if you plan to modify your configuration using script files.</p><p class="calibre8">Launch the <code class="email">jboss-cli.sh</code> script (or <code class="email">jboss-cli.bat</code>) and connect to the application server, as follows:</p><div class="informalexample"><pre class="programlisting">[disconnected /] connect
[standalone@localhost:9990 /]</pre></div><p class="calibre8">Now issue the <a id="id530" class="calibre1"/>following command, which <a id="id531" class="calibre1"/>actually creates a new <a id="id532" class="calibre1"/>data source, accomplishing the same goal we obtained by editing the configuration file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">/subsystem=datasources/data-source=wflydevelopment:add(jndi-name=java:jboss/datasources/wflydevelopment, driver-name=postgresql, connection-url= jdbc:postgresql://localhost:5432/ticketsystem,user-name="jboss",password="jboss")</strong></span>
</pre></div><p class="calibre8">The CLI should respond with a <code class="email">success</code> message if everything goes well.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating the Maven project"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec27" class="calibre1"/>Creating the Maven project</h1></div></div></div><p class="calibre8">The <a id="id533" class="calibre1"/>application that we're going to create in this chapter will require only standard Java EE 7 APIs from us. Having knowledge from previous chapters, you should be able to set up a project for this chapter by yourself! Just use your favorite IDE and create a Maven project with <code class="email">war</code> type. Remember to include the configuration for Java SE 8, <code class="email">beans.xml</code> and <code class="email">faces-config.xml</code> files. If you face any problems, remember that code samples available with this book contain a full project based on this example.</p></div>

<div class="book" title="Creating the Maven project">
<div class="book" title="Adding the Maven configuration"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec39" class="calibre1"/>Adding the Maven configuration</h2></div></div></div><p class="calibre8">Now that <a id="id534" class="calibre1"/>your Maven skeleton is set up, we<a id="id535" class="calibre1"/> will include the required dependencies so that Eclipse will be able to compile your classes as you code them. The only dependency you will need for this type is <code class="email">javaee-api</code>:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
        &lt;groupId&gt;javax&lt;/groupId&gt;
        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
        &lt;version&gt;7.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;</pre></div></div></div>

<div class="book" title="Creating the Maven project">
<div class="book" title="Cooking entities"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec40" class="calibre1"/>Cooking entities</h2></div></div></div><p class="calibre8">Now that we're <a id="id536" class="calibre1"/>done with the configuration part, we will add <a id="id537" class="calibre1"/>our entities to the project. Some valuable options exist to autogenerate our entities, starting with the database schema. For example, the Eclipse's <span class="strong"><strong class="calibre9">File</strong></span> menu includes an option <span class="strong"><strong class="calibre9">JPA Entities from Table</strong></span> that (once a connection has been set up in the database) allows you to reverse your DB schema (or a part of it) into Java entities.</p><p class="calibre8">If you are willing to try this option, remember that you need to activate the <span class="strong"><strong class="calibre9">Eclipse JPA</strong></span> facet in your project, from <span class="strong"><strong class="calibre9">Project Properties</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00045.jpeg" alt="Cooking entities" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">One more option is mentioned in <a class="calibre1" title="Appendix A. Rapid Development Using JBoss Forge" href="part0067_split_000.html#page">Appendix</a>, <span class="strong"><em class="calibre10">Rapid Development Using JBoss Forge</em></span>, which discusses JBoss Forge, a powerful, rapid application development (aimed at Java EE) and project comprehension tool.</p><p class="calibre8">In this chapter, we will focus on generating SQL scripts from Java classes. Whatever your strategy is, the expected outcome needs to conform to the following entities. Here is the first one, <code class="email">SeatType</code>, which maps the table <code class="email">SEAT_TYPE</code>:</p><div class="informalexample"><pre class="programlisting">@Entity [1]
@Table(name="seat_type") [2]
public class SeatType implements Serializable {

    @Id  [3]
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;

    private String description;

    private int price;

    private int quantity;

    //bi-directional many-to-one association to Seat
<span class="strong"><strong class="calibre9">    @OneToMany(mappedBy="seatType", fetch=FetchType.EAGER) [4]</strong></span>
<span class="strong"><strong class="calibre9">    private List&lt;Seat&gt; seats;</strong></span>

    // Getters and Setters omitted for brevity
}</pre></div><p class="calibre8">The first<a id="id538" class="calibre1"/> meaningful annotation is <code class="email">@Entity [1]</code>, which<a id="id539" class="calibre1"/> declares the class <code class="email">Entity</code>. The <code class="email">@Table [2]</code> annotation is used to map the bean class with a database table.</p><p class="calibre8">The <code class="email">@Id</code> annotation, <code class="email">[3]</code>, is a mandatory one; it describes the primary key of the table. Along <a id="id540" class="calibre1"/>with <code class="email">@Id</code>, there is the <code class="email">@GeneratedValue</code> annotation. This is used to declare that the database is in charge of generating the value. You can check the Javadoc of this class to explore other strategies for value generation.</p><p class="calibre8">Moving <a id="id541" class="calibre1"/>along, the <code class="email">@OneToMany</code> annotation <code class="email">[4]</code> defines an association with one-to-many cardinality. Actually, the <code class="email">SeatType</code> class has many seats. The corresponding <code class="email">Seat</code> reference is contained in a list collection. We define the <code class="email">mappedBy</code> attribute<a id="id542" class="calibre1"/> in order to set the field, which owns the relationship on the many side.</p><p class="calibre8">The <code class="email">fetch</code> attribute<a id="id543" class="calibre1"/> defines that JPA should fetch the list of seats whenever a <code class="email">seat</code> type is loaded from the database. A lazy configuration for a relationship would cause the list to be fetched on the first call to that field.</p><p class="calibre8">Finally, note that we have not included here, for the sake of brevity, the field getters and setters that have been generated.</p><p class="calibre8">Let's take a look at the <code class="email">Seat</code> entity:</p><div class="informalexample"><pre class="programlisting">@Entity
public class Seat implements Serializable {

    private static final long serialVersionUID = 89897231L;

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;

    private boolean booked;

    //bi-directional many-to-one association to SeatType
<span class="strong"><strong class="calibre9">    @ManyToOne [1]</strong></span>
<span class="strong"><strong class="calibre9">    @JoinColumn(name="seat_id") [2]</strong></span>
    private SeatType seatType;

    // Getters and Setters omitted for brevity

}</pre></div><p class="calibre8">As you<a id="id544" class="calibre1"/> can<a id="id545" class="calibre1"/> see, the <code class="email">Seat</code> entity has the corresponding <code class="email">@ManyToOne [1]</code> annotation, which naturally complements the <code class="email">@OneToMany</code> relationship. The <code class="email">@JoinColumn [2]</code> notifies the JPA engine that the <code class="email">seatType</code> field is mapped through the foreign key of the database's seat ID.</p></div></div>

<div class="book" title="Creating the Maven project">
<div class="book" title="Adding Bean Validation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec41" class="calibre1"/>Adding Bean Validation</h2></div></div></div><p class="calibre8"><span class="strong"><strong class="calibre9">Bean Validation (JSR-303)</strong></span> is a validation model available as part of the Java EE 6 platform. The<a id="id546" class="calibre1"/> new 1.1 version (<span class="strong"><strong class="calibre9">JSR-349</strong></span>) is a part <a id="id547" class="calibre1"/>of Java EE 7. The Bean Validation model is supported <a id="id548" class="calibre1"/>by constraints in the form of annotations placed on a field, method, or class of a JavaBeans component, such as a managed bean.</p><p class="calibre8">In our example, the <code class="email">SeatType</code> entity will be created using an input form; therefore, we will need to validate the data that has been entered by the user.</p><p class="calibre8">In our example, we will place a <code class="email">@javax.validation.constraints.NotNull</code> constraint in every field that is part of the <code class="email">SeatType</code> entry form, and a more complex constraint in the <code class="email">description</code> field, which will set the maximum size for the seat description to <code class="email">25</code> (the <code class="email">@javax.validation.constraints.Size</code> constraint) and allow just letters and spaces in it (the <code class="email">@javax.validation.constraints.Pattern</code> constraint):</p><div class="informalexample"><pre class="programlisting">@Entity
@Table(name="seat_type)
public class SeatType implements Serializable {

    private static final long serialVersionUID = 3643635L;

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;

<span class="strong"><strong class="calibre9">    @NotNull</strong></span>
<span class="strong"><strong class="calibre9">    @Size(min = 1, max = 25, message = "You need to enter a Seat Description (max 25 char)")</strong></span>
<span class="strong"><strong class="calibre9">    @Pattern(regexp = "[A-Za-z ]*", message = "Description must contain only letters and spaces")</strong></span>
    private String description;

<span class="strong"><strong class="calibre9">    @NotNull</strong></span>
    private Integer price;

<span class="strong"><strong class="calibre9">    @NotNull</strong></span>
    private Integer quantity;

<span class="strong"><strong class="calibre9">    private SeatPosition position;</strong></span>

    // Getters/Setters here
}</pre></div><p class="calibre8">As you <a id="id549" class="calibre1"/>can see, we can also place a description <a id="id550" class="calibre1"/>on a constraint, which can be used to provide a customized error message to the JSF layer should the data fail to pass the constraint. You can check the Oracle <a id="id551" class="calibre1"/>documentation for a full list of constraints available at <a class="calibre1" href="http://docs.oracle.com/javaee/7/tutorial/doc/bean-validation001.htm#GIRCZ">http://docs.oracle.com/javaee/7/tutorial/doc/bean-validation001.htm#GIRCZ</a>.</p><p class="calibre8">We also have added a seat position information to our seat type. It is a simple enum:</p><div class="informalexample"><pre class="programlisting">public enum SeatPosition {
    ORCHESTRA("Orchestra", "orchestra"), BOX("Box", "box"), BALCONY("Balcony", "balcony");

    private final String label;
    private final String dbRepresentation;

    private SeatPosition(String label, String dbRepresentation) {
        this.label = label;
        this.dbRepresentation = dbRepresentation;

    }

    public String getDatabaseRepresentation() {
        return dbRepresentation;
    }

    public String getLabel() {
        return label;
    }
}</pre></div><p class="calibre8">When we save our <code class="email">SeatType</code> entity in the database, we will also store the enum value with it. Earlier versions of JPA gave us two options to address it automatically (besides manually managing their status), <code class="email">@Enumarated(EnumType.STRING)</code> and <code class="email">@Enumarated(EnumType.ORDINAL)</code>; both had their flaws. The first one is sensitive towards enum renaming; the entities in the database will have the full name of the enum stored (which sometimes is also a waste of the storage space). The second one could create<a id="id552" class="calibre1"/> problems when the order of enums would be<a id="id553" class="calibre1"/> changed (because it stored the index of the enum value). From JPA 2.1, we can create a converter, which will automatically convert our enum attributes to specific entries in the database. We only need to create an annotated class, which implements the <code class="email">AttributeConverter</code> interface:</p><div class="informalexample"><pre class="programlisting">import javax.persistence.AttributeConverter;
import javax.persistence.Converter;

@Converter(autoApply = true)
public class SeatPositionConverter implements AttributeConverter&lt;SeatPosition, String&gt; {

    @Override
    public String convertToDatabaseColumn(SeatPosition attribute) {
        return attribute.getDatabaseRepresentation();
    }

    @Override
    public SeatPosition convertToEntityAttribute(String dbData) {
        for (SeatPosition seatPosition : SeatPosition.values()) {
            if (dbData.equals(seatPosition.getDatabaseRepresentation())) {
                return seatPosition;
            }
        }
        throw new IllegalArgumentException("Unknown attribute value " + dbData);
    }
}</pre></div><p class="calibre8">That's all, no <a id="id554" class="calibre1"/>additional configuration is required. The <code class="email">autoApply</code> attribute set to <code class="email">true</code> signals JPA to take care of all of our <code class="email">SeatPosition</code> enums in entities.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Configuring persistence"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec28" class="calibre1"/>Configuring persistence</h1></div></div></div><p class="calibre8">The Entity <a id="id555" class="calibre1"/>API looks great and is very intuitive, but how does the server know which database is supposed to store/query the entity objects? The <code class="email">persistence.xml</code> file, which will be placed under <code class="email">src/main/resources/META-INF</code> of your project, is the standard JPA configuration file. By configuring this file, you can easily switch from one persistence provider to another and thus, also from one application server to another (believe it or not, this is a huge leap towards application server compatibility).</p><p class="calibre8">In the <code class="email">persistence.xml</code> file, we will basically need to specify the persistence provider and the underlying data source used. Simply create the following file under <code class="email">src/main/resources/persistence.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence 
             
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
             version="2.1"&gt;
<span class="strong"><strong class="calibre9">    &lt;persistence-unit name="primary"&gt;</strong></span>
<span class="strong"><strong class="calibre9">        &lt;jta-data-source&gt;java:jboss/datasources/ExampleDS&lt;/jta-data-source&gt;</strong></span>
        &lt;class&gt;com.packtpub.wflydevelopment.chapter5.entity.Seat&lt;/class&gt;
        &lt;class&gt;com.packtpub.wflydevelopment.chapter5.entity.SeatType&lt;/class&gt;
        &lt;properties&gt;
<span class="strong"><strong class="calibre9">            &lt;property name="javax.persistence.schema-generation.database.action" value="drop-and-create"/&gt;</strong></span>
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre></div><p class="calibre8">We have highlighted the most important attributes in <code class="email">persistence.xml</code>. The <code class="email">name</code> attribute<a id="id556" class="calibre1"/> is a mandatory element, which will be used to reference the persistence unit from our Enterprise JavaBeans.</p><p class="calibre8">In the <a id="id557" class="calibre1"/>example code, we use the WildFly built-in memory H2 database (<a class="calibre1" href="http://www.h2database.com/">http://www.h2database.com/</a>) available by default at <code class="email">java:jboss/datasources/ExampleDS</code> (so that it is possible to run the example without any setup). However, you can use a configured PostgreSQL connection here, <code class="email">java:jboss/datasources/wflydevelopment</code>, which we created earlier. In Java EE 7, you could even omit the whole <code class="email">jta-data-source</code> tag. Every container is now obliged to provide a default data source for applications to use. For WildFly, it would be the aforementioned H2 database.</p><p class="calibre8">We also define the classes that should be considered as entities. This is an optional step; if the entities are in the same archive as the <code class="email">persistence.xml</code> file, they will be autodiscovered.</p><p class="calibre8">In previous JPA versions, almost every configuration needed some provider-specific properties. In JPA 2.1, a number of standard properties were added, such as presented <code class="email">javax.persistence.schema-generation.database.action</code>. The <code class="email">drop-and-create</code> value<a id="id558" class="calibre1"/> can be used to create and drop your database tables each time you deploy your application. This can be an advantage if you want to start with a clean storage each time you deploy the application.</p><p class="calibre8">However, it <a id="id559" class="calibre1"/>is also possible to instruct JPA to generate SQL scripts for you, so you can manually apply them to the database. Simply add the following entries to your <code class="email">persistence-unit</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;property name="javax.persistence.schema-generation-target" value="scripts"/&gt;
&lt;property name="javax.persistence.ddl-create-script-target" value="createSeats.sql"/&gt;
&lt;property name="javax.persistence.ddl-drop-script-target" value="dropSeats.sql"/&gt;</pre></div><p class="calibre8">If you don't specify the location by specifying an additional property, then the generated scripts will be placed in the <code class="email">JBOSS_HOME/bin</code> directory, with the names that you provided in the configuration. The names can be absolute paths, so you can get the scripts to any place in your filesystem (if WildFly is permitted to write them there of course).</p></div>

<div class="book" title="Configuring persistence">
<div class="book" title="Adding producer classes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec42" class="calibre1"/>Adding producer classes</h2></div></div></div><p class="calibre8">Producer<a id="id560" class="calibre1"/> classes have been introduced in the earlier<a id="id561" class="calibre1"/> chapter as a means of providing some resources through CDI to our application. In this example, we will use it to produce many resources, such as the JPA Entity Manager and the list of objects that are transferred to the JSF views. For this reason, we provided the <code class="email">LoggerProducer</code>, <code class="email">FacesContextProducer</code>, and <code class="email">EntityManagerProducer</code> classes that contain some general-purpose resources and single instances of the <code class="email">SeatProducer</code> and <code class="email">SeatTypeProducer</code> classes, which will be used to produce collections of entities.</p><p class="calibre8">Here's the content of the three basic producer classes:</p><div class="informalexample"><pre class="programlisting">public class LoggerProducer {

    @Produces
    public Logger produceLoger(InjectionPoint injectionPoint) {
        return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName());
    }
} 


public class FacesContextProducer {

    @Produces
    @RequestScoped
    public FacesContext produceFacesContext() {
        return FacesContext.getCurrentInstance();
    }
} 

public class EntityManagerProducer {

    @Produces
    @PersistenceContext
    private EntityManager em;
}</pre></div><p class="calibre8">As you<a id="id562" class="calibre1"/> can see, these classes will be the factory for the<a id="id563" class="calibre1"/> following three kinds of resources:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">EntityManager</code>: This <a id="id564" class="calibre1"/>will resolve the primary persistence unit since there is just one persistence unit defined</li><li class="listitem"><code class="email">java.util.Logger</code>: This <a id="id565" class="calibre1"/>will trace some information on the server console</li><li class="listitem"><code class="email">FacesContext</code>: This<a id="id566" class="calibre1"/> will be used to output some JSF messages on the screen</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Producers versus the Java EE 5 @Resource injection</strong></span></p><p class="calibre8">If you have never used the dependency injections framework before, you might wonder what the benefit of adding an extra layer to produce some container resources is. The reason becomes evident once you need to change some configuration elements, such as the persistence unit. With the older Java EE 5 approach, you will be forced to change the <code class="email">@Resource</code> injection's details wherever they are used; however, using a producer method for it will centralize resource creation, making changes trivial.</p></div><p class="calibre8">Next, we will add some entity producers; let's add the <code class="email">SeatTypeProducer</code> and <code class="email">SeatProducer</code> classes:</p><div class="informalexample"><pre class="programlisting">@javax.enterprise.context.RequestScoped
public class SeatTypeProducer {

    @Inject
    private SeatTypeDao seatTypeDao;

    private List&lt;SeatType&gt; seatTypes;

    @PostConstruct
    public void retrieveAllSeatTypes() {
        seatTypes = seatTypeDao.findAll();
    }

    @Produces
    @Named
    public List&lt;SeatType&gt; getSeatTypes() {
        return seatTypes;
    }

    public void onListChanged(@Observes(notifyObserver = Reception.IF_EXISTS) final SeatType member) {
        retrieveAllSeatTypes();
    }
}</pre></div><p class="calibre8">If you <a id="id567" class="calibre1"/>have gone through our example in <a class="calibre1" title="Chapter 4. Learning Context and Dependency Injection" href="part0028_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre10">Learning Context and Dependency Injection</em></span>, you will find nothing new here; as you can <a id="id568" class="calibre1"/>see, the class will merely produce a collection of <code class="email">seatTypes</code>, which is tagged as <code class="email">@Named</code> so that they can be accessed from JSF EL as well. Additionally, the class contains an <code class="email">observer</code> handler method (<code class="email">onListChanged</code>), which will be fired when data in the collection is changed.</p><p class="calibre8">The collection <a id="id569" class="calibre1"/>data is filled using the <code class="email">retrieveAllSeatTypes</code> method (loaded the first and only time when the class is constructed) of the <code class="email">SeatTypeDao</code> CDI Bean. We will define this bean in a moment; right now, we will add the last producer class used in this example, the <code class="email">SeatProducer</code> bean:</p><div class="informalexample"><pre class="programlisting">@javax.enterprise.context.RequestScoped
public class SeatProducer implements Serializable {

    @Inject
    private SeatDao seatDao;
  
    private List&lt;Seat&gt; seats;

    @PostConstruct
    public void retrieveAllSeats() {
        seats = seatDao.findAllSeats();
    }

    @Produces
    @Named
    public List&lt;Seat&gt; getSeats() {
      return seats;
    }

    public void onMemberListChanged(@Observes(notifyObserver = Reception.IF_EXISTS) final Seat member) {
      retrieveAllSeats();
    }
}</pre></div><p class="calibre8">The<a id="id570" class="calibre1"/> preceding bean will be used to produce the<a id="id571" class="calibre1"/> list of <code class="email">Seat</code> objects that will actually be available for booking.</p></div></div>

<div class="book" title="Configuring persistence">
<div class="book" title="Coding queries for your application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec43" class="calibre1"/>Coding queries for your application</h2></div></div></div><p class="calibre8">As you <a id="id572" class="calibre1"/>can see from the earlier code, the <a id="id573" class="calibre1"/>producer<a id="id574" class="calibre1"/> classes make use of beans named <code class="email">SeatDao</code> and <code class="email">SeatTypeDao</code> to fill their collections of data. These beans perform some simple finds on the <code class="email">Seat</code> and <code class="email">SeatType</code> objects, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class SeatDao extends AbstractDao&lt;Seat&gt; {

    public SeatDao() {
        super(Seat.class);
    }
}

@Stateless
public class SeatTypeDao extends AbstractDao&lt;SeatType&gt; {

    public SeatTypeDao() {
        super(SeatType.class);
    }
}

@TransactionAttribute(TransactionAttributeType.REQUIRED)
public abstract class AbstractDao&lt;T extends Serializable&gt; implements Serializable {

    private final Class&lt;T&gt; clazz;

    @Inject
    private EntityManager em;

    public AbstractDao(Class&lt;T&gt; clazz) {
        this.clazz = clazz;
    }

    public T find(Object id) {
        return em.find(clazz, id);
    }

    public void persist(final T entity) {
        em.persist(entity);
    }

    public List&lt;T&gt; findAll() {
        final CriteriaQuery&lt;T&gt; criteriaQuery = em.getCriteriaBuilder().createQuery(clazz);
        criteriaQuery.select(criteriaQuery.from(clazz));
        return em.createQuery(criteriaQuery).getResultList();
    }

    public void deleteAll() {
        final CriteriaDelete&lt;T&gt; criteriaDelete = em.getCriteriaBuilder().createCriteriaDelete(clazz);
        criteriaDelete.from(clazz);
        em.createQuery(criteriaDelete).executeUpdate();
    }
}</pre></div><p class="calibre8">As <a id="id575" class="calibre1"/>you <a id="id576" class="calibre1"/>can <a id="id577" class="calibre1"/>see, both <code class="email">SeatDao</code> and <code class="email">SeatTypeDao</code> beans extend the generic <code class="email">AbstractDao</code> class. It wraps <code class="email">EntityManager</code> and provides basic type-safe CRUD operations such as <code class="email">findAll</code>, <code class="email">persist</code>, and so on using the JPA Criteria API. JPA allows execution of the following three types of queries:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Native SQL</strong></span>: These <a id="id578" class="calibre1"/>queries use the standard SQL language. When<a id="id579" class="calibre1"/> using this type of queries, you have to remember queries can be incompatible when migrating between different databases.</li><li class="listitem"><span class="strong"><strong class="calibre9">Java Persistence Query Language</strong></span> (<span class="strong"><strong class="calibre9">JPQL</strong></span>): These queries can be formed using<a id="id580" class="calibre1"/> special language similar to SQL. In practice, this method is often hard to maintain without good IDE support, especially during refactoring. These queries can also be compiled at startup, which means that they are not resolved multiple times. Finally, they can be used by a caching mechanism to avoid unnecessary database operations for queries that are called frequently. You can define a query and its name in the entity in the <code class="email">@NamedQuery(name="…", query="…")</code> annotation.</li><li class="listitem"><span class="strong"><strong class="calibre9">Criteria API</strong></span>: These <a id="id581" class="calibre1"/>queries can be formed by simply <a id="id582" class="calibre1"/>executing Java methods and the usage of appropriate objects. Since JPA 2.1, it's possible to perform bulk updates and deletions through this API.</li></ul></div><p class="calibre8">Let's make a simple comparison of these three methods using an example. We want to just get all the objects of a given type. Using native SQL, this query would look like this:</p><div class="informalexample"><pre class="programlisting">entityManager.createNativeQuery("SELECT * from seat_type").getResultList()</pre></div><p class="calibre8">As you can see, it uses standard SQL in the form of a string. Now let's look at JPQL:</p><div class="informalexample"><pre class="programlisting">entityManager.createQuery("select seatType from SeatType seatType").getResultList(); </pre></div><p class="calibre8">It's easy<a id="id583" class="calibre1"/> to <a id="id584" class="calibre1"/>notice <a id="id585" class="calibre1"/>its similarity to SQL but a bit different. It uses, for example, class name instead of table name. However, again, it's a query in a string. The last example is the Criteria API:</p><div class="informalexample"><pre class="programlisting">final CriteriaQuery&lt;SeatType&gt; criteriaQuery = 
                em.getCriteriaBuilder().createQuery(SeatType.class);
criteriaQuery.select(criteriaQuery.from(SeatType.class));
em.createQuery(criteriaQuery).getResultList(); </pre></div><p class="calibre8">At first glance, it looks like the most complicated one, but it has some advantage, that is, it does not use any strings (which are usually error-prone and hard to refactor). Both JPQL and Criteria API have many improvements in the newest JPA version, concerning join operations using the <code class="email">on</code> condition, database functions support, and arithmetic subqueries.</p><p class="calibre8">You may ask yourself, "Which one should I use?" It's a hard question because all of them have their pros and cons so it depends on the specific case. Basically, Criteria query and named queries are normally a safe bet. Native SQL should have a really good justification, as it's usually not portable between different vendors and cannot be validated by JPA before the execution.</p></div></div>

<div class="book" title="Configuring persistence">
<div class="book" title="Adding services to your application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec44" class="calibre1"/>Adding services to your application</h2></div></div></div><p class="calibre8">Until <a id="id586" class="calibre1"/>now, we coded all the information<a id="id587" class="calibre1"/> that will be visible to the user through <a id="id588" class="calibre1"/>the application screen. What is obviously missing here is all the business logic that translates ultimately into inserting data or updating the existing data. For this reason, we will now add two classes; first, under <code class="email">com.packtpub.wflydevelopment.chapter5.control</code> package and second under <code class="email">com.packtpub.wflydevelopment.chapter5.controller</code>. The first one is <code class="email">TicketService</code>, which is a stateless EJB that will be used to perform the core business logic of this application, and the second one is our <code class="email">stateful</code> EJB's counterpart, the <code class="email">BookerService</code> class. Let's start with the stateless EJB:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class TicketService {

    @Inject
    private Logger log;

    @Inject
    private Event&lt;SeatType&gt; seatTypeEventSrc;

    @Inject
    private Event&lt;Seat&gt; seatEventSrc;

    @Inject
    private SeatDao seatDao;

    @Inject
    private SeatTypeDao seatTypeDao;

    public void createSeatType(SeatType seatType) throws Exception {
        log.info("Registering " + seatType.getDescription());
        seatTypeDao.persist(seatType);
        seatTypeEventSrc.fire(seatType);
    }

    public void createTheatre(List&lt;SeatType&gt; seatTypes) {
        for (SeatType type : seatTypes) {
            for (int ii = 0; ii &lt; type.getQuantity(); ii++) {
                final Seat seat = new Seat();
                seat.setBooked(false);
                seat.setSeatType(type);
                seatDao.persist(seat);
            }
        }
    }

    public void bookSeat(long seatId) {
        final Seat seat = seatDao.find(seatId);
        seat.setBooked(true);
        seatDao.persist(seat);
        seatEventSrc.fire(seat);
    }

    public void doCleanUp() {
        seatDao.deleteAll();
        seatTypeDao.deleteAll();
    }
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Why has this component been coded as an EJB instead of a CDI Bean?</strong></span></p><p class="calibre8">One of the main advantages of using EJBs is that they are inherently transactional components. However, in Java EE 7, we can use CDI Beans with an additional <code class="email">@Transactional</code> annotation. The choice now is up to the developer, but EJBs can still prove useful in some cases, even for local calls; for example, we can easily demarcate security for them (which we will do in the future chapters).</p></div><p class="calibre8">This<a id="id589" class="calibre1"/> service is made up of four methods. The <a id="id590" class="calibre1"/>first is the <code class="email">createSeatType</code> method, which<a id="id591" class="calibre1"/> will be used in the first application screen to <a id="id592" class="calibre1"/>add a new <code class="email">SeatType</code> object to our theatre. The next method, <code class="email">createTheatre</code>, will be invoked once we are done with setting up our theatre; so we create the list of seats that will be available for booking in the next screen.</p><p class="calibre8">Next in the list is the <code class="email">bookSeat</code> method, which, as you might have guessed, will be used to book a<a id="id593" class="calibre1"/> seat. Finally, the <code class="email">doCleanUp</code> method is actually used to perform <a id="id594" class="calibre1"/>a cleanup if you want to restart the application.</p><p class="calibre8">The last piece of our puzzle is the <code class="email">BookerService</code> class, which adds a tiny session layer to your application:</p><div class="informalexample"><pre class="programlisting">@Named
<span class="strong"><strong class="calibre9">@javax.faces.view.ViewScoped</strong></span>
public class BookerService implements Serializable {

    private static final long serialVersionUID = -4121692677L;

    @Inject
    private Logger logger;

    @Inject
    private TicketService ticketService;

    @Inject
    private FacesContext facesContext;

    private int money;

    @PostConstruct
    public void createCustomer() {
        this.money = 100;
    }

    public void bookSeat(long seatId, int price) {
        logger.info("Booking seat " + seatId);

        if (price &gt; money) {
            final FacesMessage m = new FacesMessage(FacesMessage.SEVERITY_ERROR, "Not enough Money!",
                    "Registration successful");
            facesContext.addMessage(null, m);
            return;
        }

        ticketService.bookSeat(seatId);

        final FacesMessage m = new FacesMessage(FacesMessage.SEVERITY_INFO, "Registered!", "Registration successful");
        facesContext.addMessage(null, m);
        logger.info("Seat booked.");

        money = money - price;
    }

    public int getMoney() {
        return money;
    }
}</pre></div><p class="calibre8">The <a id="id595" class="calibre1"/>preceding<a id="id596" class="calibre1"/> class <a id="id597" class="calibre1"/>uses the view scope, which we already described in the previous chapters.</p></div></div>

<div class="book" title="Configuring persistence">
<div class="book" title="Adding a controller to drive user requests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec45" class="calibre1"/>Adding a controller to drive user requests</h2></div></div></div><p class="calibre8">The<a id="id598" class="calibre1"/> link<a id="id599" class="calibre1"/> between <a id="id600" class="calibre1"/>the persistence layer and the user's view falls on the <code class="email">TheatreSetupService</code> bean, which will drive requests to the actual services exposed by our application. Since this bean will be bound to <code class="email">RequestScope</code> and we need to expose it to our views as well (using <code class="email">@Named</code>), we can use the convenient <code class="email">@Model</code> annotation for it, which is a sum of the following two attributes:</p><div class="informalexample"><pre class="programlisting">@Model
public class TheatreSetupService {

    @Inject
    private FacesContext facesContext;

    @Inject
    private TicketService ticketService;

    @Inject
    private List&lt;SeatType&gt; seatTypes;

<span class="strong"><strong class="calibre9">    @Produces [1]</strong></span>
<span class="strong"><strong class="calibre9">    @Named</strong></span>
<span class="strong"><strong class="calibre9">    private SeatType newSeatType;</strong></span>

    @PostConstruct
    public void initNewSeatType() {
        newSeatType = new SeatType();
    }

    public String createTheatre() {
        ticketService.createTheatre(seatTypes);
        return "book";
    }

    public String restart() {
        ticketService.doCleanUp();
        return "/index";  [4]
    }

    public void addNewSeats() throws Exception {
        try {
            ticketService.createSeatType(newSeatType);

            final FacesMessage m = new FacesMessage(FacesMessage.SEVERITY_INFO, "Done!", "Seats Added");
            facesContext.addMessage(null, m);
            initNewSeatType();
        } catch (Exception e) {
            final String errorMessage = getRootErrorMessage(e);
            FacesMessage m = new FacesMessage(FacesMessage.SEVERITY_ERROR, errorMessage, "Error while saving data");
            facesContext.addMessage(null, m);
        }
    }

    private String getRootErrorMessage(Exception e) {
        // Default to general error message that registration failed.
        String errorMessage = "Registration failed. See server log for more information";
        if (e == null) {
            // This shouldn't happen, but return the default messages
            return errorMessage;
        }

        // Start with the exception and recurse to find the root cause
        Throwable t = e;
        while (t != null) {
            // Get the message from the Throwable class instance
            errorMessage = t.getLocalizedMessage();
            t = t.getCause();
        }
        // This is the root cause message
        return errorMessage;
    }

    public List&lt;SeatPosition&gt; getPositions() {
        return Arrays.asList(SeatPosition.values());
    }

}</pre></div><p class="calibre8">The <code class="email">TheatreSetupService</code> class is expected to complete the following tasks:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">At<a id="id601" class="calibre1"/> first, the <code class="email">TheatreSetupService</code> class <a id="id602" class="calibre1"/>produces<a id="id603" class="calibre1"/> a <code class="email">SeatType</code> object <code class="email">[1]</code> and exposes it to the JSF View layer using the <code class="email">@Named</code> annotation.<div class="note" title="Note"><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">This technique is a great addition provided by CDI since it removes the need to create a boilerplate object, <code class="email">SeatType</code>, to transport the information from the view to the <a id="id604" class="calibre1"/>services. The <code class="email">SeatType</code> object is produced by the controller and will be populated by the JSF view and persisted by the <code class="email">TheatreSetupService</code> class.</p></div></li><li class="listitem" value="2">It then drives user navigation between the application screens by returning to the home page <code class="email">[4]</code>.</li><li class="listitem" value="3">We are done with the Java classes. You should now check to make sure that your project structure matches the following screenshot:<div class="mediaobject"><img src="../images/00046.jpeg" alt="Adding a controller to drive user requests" class="calibre11"/></div><p class="calibre14"> </p></li></ol><div class="calibre16"/></div></div></div>

<div class="book" title="Configuring persistence">
<div class="book" title="Coding the JSF view"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec46" class="calibre1"/>Coding the JSF view</h2></div></div></div><p class="calibre8">Now <a id="id605" class="calibre1"/>that our middle tier is completed, we just need to add<a id="id606" class="calibre1"/> a couple of JSF views to our application in the <code class="email">views</code> folder of our web app. The first view, named <code class="email">setup.xhtml</code>, will set up our theatre and the second one, named <code class="email">book.xhtml</code>, will be used to book tickets, borrowing some of its code from the earlier chapter.</p><p class="calibre8">However, this time we would like to make our application a little bit more graphically appealing. To<a id="id607" class="calibre1"/> keep it simple, we will use <span class="strong"><strong class="calibre9">Bootstrap</strong></span>, a very popular frontend framework that will nicely integrate with our JSF views. It heavily relies on JavaScript and CSS, but we will only need to use basic HTML to get it up and running in our application. Incorporating a strict frontend framework to our application will be an opportunity to show how to use Java EE 7 with the newest web technologies.</p><p class="calibre8">You can get the latest <a id="id608" class="calibre1"/>version of Bootstrap from <a class="calibre1" href="http://getbootstrap.com/">http://getbootstrap.com/</a> and just place all files in the resources directory; however, we won't do it here. We will use the WebJars, which are simply JARs that pack client-side <a id="id609" class="calibre1"/>web libraries. You can find dependencies at <a class="calibre1" href="http://www.webjars.org/">http://www.webjars.org/</a>, which after adding to your <code class="email">pom.xml</code> file will work just like manually adding static files to the project. However, thanks to WebJars, we get Maven to control our versions, and don't need to worry about polluting our codebase with external code.</p><p class="calibre8">Now, we need Bootstrap and jQuery, so we will add the following dependencies:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;
    &lt;version&gt;3.2.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;1.11.0&lt;/version&gt;
&lt;/dependency&gt;</pre></div><p class="calibre8">Now, when we have the Bootstrap's libraries in place, we have to link them to our code. We will add them to our <code class="email">WEB-INF/templates/default.xhtml</code> file along with a simple navigation bar:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html 
      
      &gt;
&lt;h:head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
    &lt;title&gt;#{app.applicationName}&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta name="description" content="" /&gt;
    &lt;meta name="author" content="" /&gt;

    &lt;h:outputStylesheet name="/webjars/bootstrap/3.2.0/css/bootstrap.css " /&gt;
    &lt;h:outputStylesheet name="/webjars/bootstrap/3.2.0/css/bootstrap-theme.css " /&gt;

    &lt;!-- Le HTML5 shim, for IE6-8 support of HTML5 elements --&gt;
    &lt;!--[if lt IE 9]&gt;
      &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
    &lt;![endif]--&gt;

&lt;style&gt;
    body {
        padding-top: 60px;
    }
    &lt;/style&gt;
&lt;/h:head&gt;
&lt;h:body&gt;
    &lt;div class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt;
    &lt;div class="container"&gt;
    &lt;div class="navbar-header"&gt;
        &lt;h:link outcome="/index" class="navbar-brand" value="Ticket Agency" /&gt;
    &lt;/div&gt;
    &lt;div class="collapse navbar-collapse"&gt;
        &lt;ul class="nav navbar-nav"&gt;
        &lt;li class="#{view.viewId =='/views/setup.xhtml' ? 'active':''}"&gt;
&lt;h:link outcome="/views/setup" value="Theatre setup" /&gt;&lt;/li&gt;
        &lt;li class="#{view.viewId =='/views/book.xhtml' ? 'active':''}"&gt;
&lt;h:link  outcome="/views/book" value="Book tickets" /&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="container"&gt;
        &lt;ui:insert name="content"&gt;
            [Template content will be inserted here]
        &lt;/ui:insert&gt;
        &lt;hr /&gt;
        &lt;footer&gt;
        &lt;p class="text-muted"&gt;&amp;copy; Company 2014&lt;/p&gt;
        &lt;/footer&gt;
    &lt;/div&gt;
    &lt;h:outputScript name="/webjars/jquery/1.11.0/jquery.js" /&gt;
    &lt;h:outputScript name="/webjars/bootstrap/3.2.0/js/bootstrap.js " /&gt;
&lt;/h:body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">Next, we <a id="id610" class="calibre1"/>will <a id="id611" class="calibre1"/>move to the content in <code class="email">setup.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;ui:composition 
                
                
                
                template="/WEB-INF/templates/default.xhtml"
                &gt;
&lt;div class="jumbotron"&gt;
    &lt;h1&gt;Theatre Setup&lt;/h1&gt;
    &lt;p&gt;Enter the information about Seats&lt;/p&gt;
&lt;/div&gt;

&lt;div class="row"&gt;
&lt;div class="col-md-6"&gt;
    &lt;div class="panel panel-default"&gt;
        &lt;div class="panel-heading"&gt;
            &lt;h3 class="panel-title"&gt;Add seats&lt;/h3&gt;
        &lt;/div&gt;
        &lt;div class="panel-body"&gt;
            &lt;h:form id="reg" role="form"&gt;
        &lt;div class="form-group has-feedback #{!desc.valid? 'has-error' : ''}"&gt;
            &lt;h:outputLabel for="desc" value="Description"
                        styleClass="control-label" /&gt;
            &lt;h:inputText id="desc" value="#{newSeatType.description}"
            p:placeholder="Enter a description here" class="form-control"
                        binding="#{desc}" /&gt;
            &lt;span class="#{!desc.valid ? 'glyphicon glyphicon-remove form-control-feedback' : ''}" /&gt;
            &lt;h:message for="desc" errorClass="control-label has-error" /&gt;
        &lt;/div&gt;
        &lt;div class="form-group  #{!price.valid and facesContext.validationFailed? 'has-error' : ''}"&gt;
&lt;h:outputLabel for="price" value="Price:"
                        styleClass="control-label" /&gt;
            &lt;div class="input-group  has-feedback"&gt;
            &lt;span class="input-group-addon"&gt;$&lt;/span&gt;
            &lt;h:inputText id="price" value="#{newSeatType.price}"
            class="form-control" p:placeholder="Enter a price"
                            binding="#{price}" /&gt;
            &lt;span class="#{!price.valid ? 'glyphicon glyphicon-remove input-group-feedback input-group-addon' : ''}" /&gt;
            &lt;/div&gt;
            &lt;h:message for="price" errorClass="control-label has-error" /&gt;
        &lt;/div&gt;
        &lt;div class="form-group has-feedback #{!quantity.valid and facesContext.validationFailed? 'has-error' : ''}"&gt;
            &lt;h:outputLabel for="quantity" value="Number of Seats:"
                    styleClass="control-label" /&gt;
            &lt;h:inputText id="quantity" value="#{newSeatType.quantity}"
                class="form-control" p:placeholder="Enter quantity"
                        binding="#{quantity}" /&gt;
            &lt;span class="#{!quantity.valid ? 'glyphicon glyphicon-remove form-control-feedback' : ''}" /&gt;
            &lt;h:message for="quantity" errorClass="control-label has-error" /&gt;
        &lt;/div&gt;
        &lt;div class="form-group"&gt;
            &lt;h:outputLabel for="position" value="Position:"
                styleClass="control-label" /&gt;
            &lt;h:selectOneMenu value="#{newSeatType.position}" id="position"
                class="form-control"&gt;
            &lt;f:selectItems value="#{theatreSetupService.positions}"
                var="pos" itemValue="#{pos}" itemLabel="#{pos.label}" /&gt;
            &lt;/h:selectOneMenu&gt;
        &lt;/div&gt;

            &lt;div class="form-group"&gt;
&lt;h:commandButton id="Add" action = "#{theatreSetupService. addNewSeats}" value="Add styleClass="btn btn-primary" /&gt;
            &lt;/div&gt;
            &lt;h:messages styleClass="messages" style="list-style: none; padding:0; margin:0;" errorClass="alert alert-error" infoClass="alert alert-success"
            warnClass="alert alert-warning" globalOnly="true" /&gt;
            &lt;/h:form&gt;
        &lt;/div&gt;
    &lt;/div&gt; 
&lt;/div&gt;
// some code
&lt;/div&gt;
&lt;/ui:define&gt;
&lt;/ui:composition&gt;</pre></div><p class="calibre8">As you can see, the preceding view contains a form to enter a new seat type in the topmost section. The highlighted input text will actually pass data to the <code class="email">SeatType</code> object, which will be transferred to the <code class="email">TheatreSetupService</code> CDI Bean and ultimately persisted when the user clicks on the <span class="strong"><strong class="calibre9">Add</strong></span> button.</p><p class="calibre8">You may <a id="id612" class="calibre1"/>also notice many <code class="email">class</code> attributes on the tags. These<a id="id613" class="calibre1"/> attributes refer to the CSS classes defined by Bootstrap; we use them to visualize our validation. If a user places some invalid data in a form input, a proper CSS class is assigned to it (Bootstrap's <code class="email">has-error</code> method in our case). This is, however, a strictly frontend-related addition. The JSF validation message will be shown with or without it thanks to the <code class="email">h:messages</code> tag and the Bean Validation constraints defined in the earlier part of this chapter.</p><p class="calibre8">An interesting addition is the fact that we use one of the JSF 2.2 features, which eases integration with HTML5 frontend frameworks, the <code class="email">pass-through</code> attributes. By using the <code class="email">xmlns:p=http://xmlns.jcp.org/jsf/passthrough</code> namespacein <code class="email">p:placeholder</code>, we instruct JSF to ignore an unknown attribute and pass it straight to the renderer. Then, Bootstrap's internal mechanisms can interpret the attribute, and provide our input controls with placeholder text, which disappears after a control gains focus.</p><p class="calibre8">The next part of the <code class="email">setup.xhtml</code> file is available in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;div class="col-md-6"&gt;
    &lt;div class="panel panel-default"&gt;
        &lt;div class="panel-heading"&gt;
            &lt;h2 class="panel-title"&gt;Seats List&lt;/h2&gt;
        &lt;/div&gt;
        &lt;div class="panel-body"&gt;
            &lt;h:form id="reg2"&gt;
                &lt;h:commandButton id="Finish"
                    action="#{theatreSetupService.createTheatre}"
                    value="Finalize the theatre setup"
                    styleClass="btn btn-default  btn-block" /&gt;
            &lt;/h:form&gt;
        &lt;/div&gt;
        &lt;h:panelGroup rendered="#{empty seatTypes}"&gt;
            &lt;em&gt;No Seats Added.&lt;/em&gt;
        &lt;/h:panelGroup&gt;
        &lt;h:dataTable var="seatType" value="#{seatTypes}"
            rendered="#{not empty seatTypes}"
            styleClass="table table-hover table-striped "&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Id&lt;/f:facet&gt;
                 #{seatType.id}
             &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
                 #{seatType.description}
             &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Position&lt;/f:facet&gt;
                 #{seatType.position.label}
             &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Price&lt;/f:facet&gt;
                 $ #{seatType.price}
             &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Quantity&lt;/f:facet&gt;
                 #{seatType.quantity}
             &lt;/h:column&gt;
        &lt;/h:dataTable&gt;

    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/ui:define&gt;</pre></div><p class="calibre8">Each time <a id="id614" class="calibre1"/>you add a new block of seats to your theatre, the <a id="id615" class="calibre1"/>
<code class="email">dataTable</code> method contained in the lower part of the screen will be updated. When you are done with your setup, click on the <span class="strong"><strong class="calibre9">Finish</strong></span> button, which will recall the <code class="email">finish</code> method of the <code class="email">TheatreSetupService</code> CDI Bean, creating the list of seats.</p><p class="calibre8">This action will also redirect you to the next view, named <code class="email">book.xhtml</code>, which is used to book seats:</p><div class="informalexample"><pre class="programlisting">    &lt;ui:define name="content"&gt;
    &lt;div class="page-header"&gt;
        &lt;h2&gt;TicketBooker Machine&lt;/h2&gt;
    &lt;/div&gt;

    &lt;h3&gt;Money: $ #{bookerService.money}&lt;/h3&gt;

    &lt;h:form id="reg"&gt;
        &lt;h:messages styleClass="messages"
            style="list-style: none; padding:0; margin:0;"
            errorClass="alert alert-error" infoClass="alert alert-success"
            warnClass="alert alert-warning" globalOnly="true" /&gt;

        &lt;h:commandButton id="restart" action="#{theatreSetupService.restart}"
            value="Restart Application" class="btn btn-default" /&gt;

        &lt;h:dataTable var="seat" value="#{seats}"
            rendered="#{not empty seats}"
            styleClass="table table-hover table-striped "&gt;

            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Id&lt;/f:facet&gt;
                    #{seat.id}
            &lt;/h:column&gt;

            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Description&lt;/f:facet&gt;
                    #{seat.seatType.description}
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Price&lt;/f:facet&gt;
                    #{seat.seatType.price}$
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Position&lt;/f:facet&gt;
                    #{seat.seatType.position.label}
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Booked&lt;/f:facet&gt;
                &lt;span class="glyphicon glyphicon-#{seat.booked ? 'ok' :'remove'}"&gt;&lt;/span&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
                &lt;h:commandButton id="book" 
                    action="#{bookerService.bookSeat(seat.id, seat.seatType.price)}" 
                    disabled="#{seat.booked}" class="btn btn-primary"   
                    value="#{seat.booked ? 'Reserved' : 'Book'}" /&gt;
            &lt;/h:column&gt;
        &lt;/h:dataTable&gt;
    &lt;/h:form&gt;
&lt;/ui:define&gt;</pre></div><p class="calibre8">Here's a snapshot of the project, expanded at the <span class="strong"><strong class="calibre9">webapp</strong></span> level (as you can see, we have also included a basic <code class="email">index.html</code> screen and an <code class="email">index.xhtml</code> screen to redirect the user to<a id="id616" class="calibre1"/> the <a id="id617" class="calibre1"/>initial screen, <code class="email">setup.xhtml</code>):</p><div class="mediaobject"><img src="../images/00047.jpeg" alt="Coding the JSF view" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="Configuring persistence">
<div class="book" title="Running the example"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec47" class="calibre1"/>Running the example</h2></div></div></div><p class="calibre8">Deploying<a id="id618" class="calibre1"/> the application requires, as usual, packaging it<a id="id619" class="calibre1"/> using the following Maven goal:</p><div class="informalexample"><pre class="programlisting">mvn package
[INFO] Scanning for projects...
[INFO]
[INFO] ---------------------------------------------------------------
[INFO] Building ticket-agency-jpa 1.0 
[INFO] ---------------------------------------------------------------
[INFO] Building war: C:\chapter5\ticket-agency-jpa\target\ticket-agency-jpa.war
. . . . 
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ---------------------------------------------------------------
[INFO] Total time: 1.799s</pre></div><p class="calibre8">Finally, provided that you have installed the WildFly Maven plugin, you can deploy your application using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn wildfly:deploy</strong></span>
</pre></div><p class="calibre8">Once the deployment has successfully completed, visit <code class="email">http://localhost:8080/ticket-agency-jpa/</code> to view the application's welcome page, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00048.jpeg" alt="Running the example" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Congratulations! You're <a id="id620" class="calibre1"/>done. By clicking on the <span class="strong"><strong class="calibre9">Setup Theatre</strong></span> link, you can start creating places in the <code class="email">setup.xhtml</code> page. Feel free to experiment with the inputs, and try to fill some letters in the price box or numbers in the description, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="Running the example" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Once <a id="id621" class="calibre1"/>you <a id="id622" class="calibre1"/>click on the <span class="strong"><strong class="calibre9">Finalize the theatre setup</strong></span> button, you will be redirected to the last screen, which performs seat booking in <code class="email">book.xhtml</code>:</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Running the example" class="calibre11"/></div><p class="calibre12"> </p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec29" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">The aim of the new Java Persistence API is to simplify the development of persistent entities. It meets this objective through a simple POJO-based persistence model, which reduces the number of required classes and interfaces.</p><p class="calibre8">In this chapter, we covered a lot of ground, starting with the database schema that we reverse engineered using the JBoss tools plugins for Eclipse. Next, we coded the set of layers (producers, services, and controllers) that are part of the application, along with the JSF Facelets.</p><p class="calibre8">In the next chapter, we will discuss developing applications using <span class="strong"><strong class="calibre9">JBoss Messaging Provider</strong></span> (<span class="strong"><strong class="calibre9">HornetQ</strong></span>) by introducing examples with message-driven beans using the new simplified Java EE 7 API.</p></div></body></html>