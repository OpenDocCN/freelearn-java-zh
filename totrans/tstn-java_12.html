<html><head></head><body>
		<div id="_idContainer063">
			<h1 id="_idParaDest-222" class="chapter-number"><a id="_idTextAnchor244"/>12</h1>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor245"/>BigDecimal and Unit Testing</h1>
			<p>We begin this chapter by addressing the problem with floating point representation that is found in most languages. The problem revolves around the inability to represent every decimal fraction as a binary fraction, as pointed out in <a href="B19088_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Language Fundamentals – Data Types and Variables</em>. In most situations, it can be accurate enough. But what happens if you must guarantee accuracy and precision? You must abandon floating point primitives and use the <span class="No-Break"><strong class="source-inline">BigDecimal</strong></span><span class="No-Break"> class.</span></p>
			<p>How do you know that the code you have just written works? The compiler can spot syntax errors. An error-free compilation only tells you that the compiler is happy. But does it work? How does your code handle invalid input, lost connections to a database, or edge cases? Always be aware that for most projects you work on, the most unreliable component of the systems you code for is the end users. You cannot fix them, but you need to design and implement your code to handle the unexpected. Unit testing is one technique for validating your code while you <span class="No-Break">write it.</span></p>
			<p>Unit testing is not the<a id="_idIndexMarker813"/> same as <strong class="bold">quality assurance</strong> (<strong class="bold">QA</strong>). This is a process carried out to ensure that the program is meeting the specifications it was coded for. QA is<a id="_idIndexMarker814"/> about programs that run. Unit testing is about the performance of individual methods. Sometimes objects and methods that work together must be tested, which is called<a id="_idIndexMarker815"/> integration testing, but the testing techniques are similar. This testing is the responsibility of <span class="No-Break">the programmer.</span></p>
			<p>In this chapter, we will look at how we write unit tests using the JUnit 5 framework. What is significant about this framework is that you can test any method in your code without the need for a main method. We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Using </span><span class="No-Break"><strong class="source-inline">BigDecimal</strong></span></li>
				<li>What is <span class="No-Break">JUnit 5?</span></li>
				<li>Testing with <span class="No-Break">JUnit 5</span></li>
				<li>Performing <span class="No-Break">parametrized testing</span></li>
			</ul>
			<p>In the advanced Java courses that I have taught, unit testing was mandatory. If a student could not demonstrate that the code they wrote passed unit tests, then I could not be bothered to even look at the code. A submission was expected to run its tests before the program itself was executed. If there were no tests, then it was an automatic failure. I may have been harsh, but the result was that I had confidence that what they coded <span class="No-Break">could work.</span></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor246"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li>A <span class="No-Break">text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
			</ul>
			<p>The sample code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter12"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter12</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor247"/>Using BigDecimal</h1>
			<p>The <strong class="source-inline">BigDecimal</strong> class, which<a id="_idIndexMarker816"/> is a member of the <strong class="source-inline">java.math</strong> library, is a fixed-precision representation of floating point numbers. This means that values represented as <strong class="source-inline">BigDecimal</strong> do not suffer from the problem of approximation that <a id="_idIndexMarker817"/>can and does occur when calculations are carried out by the hardware <strong class="bold">floating point unit</strong> (<strong class="bold">FPU</strong>) of <span class="No-Break">most CPUs.</span></p>
			<p>The <strong class="source-inline">BigDecimal</strong> class shares an important characteristic with a string. They are both immutable. This means that when a value becomes a <strong class="source-inline">BigDecimal</strong> object, it cannot be changed. Any operation on a <strong class="source-inline">BigDecimal</strong> object returns a new <span class="No-Break"><strong class="source-inline">BigDecimal</strong></span><span class="No-Break"> object.</span></p>
			<p>Let us look at an application that can calculate loan payments for money borrowed. The formula for this calculation is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B19088_12_001.jpg" alt=""/>
				</div>
			</div>
			<p><span class="No-Break">Here:</span></p>
			<ul>
				<li><em class="italic">rate</em> = the interest rate <span class="No-Break">per period</span></li>
				<li><em class="italic">n</em> = the number <span class="No-Break">of periods</span></li>
				<li><em class="italic">PV</em> = present value (amount <span class="No-Break">of loan)</span></li>
				<li><em class="italic">PMT</em> = payment (the <span class="No-Break">monthly payment)</span></li>
			</ul>
			<p>If we use <a id="_idIndexMarker818"/>doubles for all the values, the Java bean data object will look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public class FinancialData {
    private double amountBorrowed;
    private double annualRate;
    private double term;
    private double monthlyPayment;
    public FinancialData(double amountBorrowed,
            double annualRate,
            double term) {
        this.amountBorrowed = amountBorrowed;
        this.annualRate = annualRate;
        this.term = term;
        this.monthlyPayment = 0.0;
    }
    public FinancialData() {
        this(0.0, 0.0, 0.0);
    }
    public double getAnnualRate() {
        return annualRate;
    }
    public void setAnnualRate(double annualRate) {
        this.annualRate = annualRate;
    }
// There are setters and getters for
// the other three fields.</pre>
			<p>The <strong class="source-inline">Object</strong> superclass<a id="_idIndexMarker819"/> has a method named <strong class="source-inline">toString</strong> that will return the address at which the object is stored as a string. We override it to display the values in all the fields. This can be quite useful in debugging, so I advise you to always have a <strong class="source-inline">toString</strong> method in any <span class="No-Break">data class:</span></p>
			<pre class="source-code">
    @Override
    public String toString() {
            return "FinancialData{" + "amountBorrowed=" +
            amountBorrowed + ", annualRate=" +
            annualRate + ", term=" + term +
            ", monthlyPayment=" + monthlyPayment + '}';
    }</pre>
			<p>The formula to calculate the result is as follows. It has been broken up to reflect each part of the final calculation, although it could be written as a single line as done in the <strong class="source-inline">CompoundInterest</strong> examples. The comments describe each part of <span class="No-Break">the formula:</span></p>
			<pre class="source-code">
public class Calculation {
    public void loanCalculator(FinancialData data) {
        // Convert APR to monthly rate because payments are
        // monthly
        var monthlyRate = data.getAnnualRate() / 12.0;
        // (1+rate)
        var temp = 1.0 + monthlyRate;
        // (1+rate)^term
        temp = Math.pow(temp, -data.getTerm());
        // 1 - (1+rate)^-term
        temp = 1 - temp;
        // rate / (1 - (1+rate)^-term)
        temp = monthlyRate / temp;
        // pv * (rate / 1 - (1+rate)^-term)
        temp = data.getAmountBorrowed() * temp;
        data.setMonthlyPayment(Math.abs(temp));
    }
}</pre>
			<p>If we<a id="_idIndexMarker820"/> borrowed $5,000 at 5% annual interest for 60 months, the answer will be $94.35616822005495. So, the result should be $94.36. The issue here is that all calculations are being done to 14 decimal places when they should only be done with values that have two decimal places except for the monthly interest rate. Interest rates may have more than two decimal places. Dividing the annual interest rate by 12, for 12 payments a year, results in a value where the first two decimal places are 0. In most cases, the result will be accurate, but not always. This is a serious issue if you are writing what is referred to as an accounting problem. The solution is to use <strong class="source-inline">BigDecimal</strong>. Here is the <span class="No-Break">data object:</span></p>
			<pre class="source-code">
public class FinancialData {
    private BigDecimal amountBorrowed;
    private BigDecimal annualRate;
    private BigDecimal term;
    private BigDecimal monthlyPayment;
    public FinancialData(BigDecimal amountBorrowed,
            BigDecimal annualRate,
            BigDecimal term) {
        this.amountBorrowed = amountBorrowed;
        this.annualRate = annualRate;
        this.term = term;.</pre>
			<p>There are convenience objects in <strong class="source-inline">BigDecimal</strong>, one of which is <strong class="source-inline">BigDecimal.ZERO</strong>, which returns a <strong class="source-inline">BigDecimal</strong> object initialized <span class="No-Break">to 0:</span></p>
			<pre class="source-code">
        this.monthlyPayment = BigDecimal.ZERO;
    }</pre>
			<p>The default <a id="_idIndexMarker821"/>constructor is using this non-default constructor and passes it three <strong class="source-inline">BigDecimal</strong> objects initialized <span class="No-Break">to 0:</span></p>
			<pre class="source-code">
    public FinancialData() {
        this(BigDecimal.ZERO, BigDecimal.ZERO,
             BigDecimal.ZERO);
    }
    public BigDecimal getAnnualRate() {
        return annualRate;
    }
    public void setAnnualRate(BigDecimal annualRate) {
        this.annualRate = annualRate;
    }
// There are setters and getters for the other three
// fields along with a toString method.</pre>
			<p>The <strong class="source-inline">Calculation</strong> class using <strong class="source-inline">BigDecimal</strong> now looks <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public class Calculation {
    public void loanCalculation(FinancialData data)
                 throws ArithmeticException {
        var monthlyRate = data.getAnnualRate().
                      divide(new BigDecimal("12"),
                      MathContext.DECIMAL64);
        // (1+rate)
        var temp = BigDecimal.ONE.add(monthlyRate);
        // (1+rate)^term
        temp = temp.pow(data.getTerm().intValueExact());
        // BigDecimal pow does not support negative
        // exponents so divide 1 by the result</pre>
			<p>Division is an<a id="_idIndexMarker822"/> operation that could result in an infinitely repeating sequence. If this is detected, then an exception is thrown. To prevent this exception, we limit the number of decimal places with <strong class="source-inline">MathContext.DECIMAL64</strong>. This will limit the number to 16 <span class="No-Break">decimal places:</span></p>
			<pre class="source-code">
        temp = BigDecimal.ONE.divide(
                   temp, MathContext.DECIMAL64);
        // 1 - (1+rate)^-term
        temp = BigDecimal.ONE.subtract(temp);
        // rate / (1 - (1+rate)^-term)
        temp = monthlyRate.divide(
                   temp, MathContext.DECIMAL64);
        // pv * (rate / 1 - (1+rate)^-term)
        temp = data.getAmountBorrowed().multiply(temp);</pre>
			<p>Here, we use <strong class="source-inline">setScale</strong> to restrict the output to two decimal places. We also define how rounding should occur. Many of you will have been taught that 1 to 4 round down and 5 to 9 round up. This is not how it is done in accounting. Banks use <strong class="source-inline">HALF_EVEN</strong>. For example, 27.555 will round to 27.56. If the value is 27.565, it will round to 27.56. If the value of the last requested decimal place is an even number and the value that follows is exactly 5, then it rounds down. If it is an odd number, it rounds up. Over time, you and the bank will break even. Without <strong class="source-inline">HALF_EVEN</strong>, you will probably lose money to <span class="No-Break">the bank:</span></p>
			<pre class="source-code">
        temp = temp.setScale(2, RoundingMode.HALF_EVEN);</pre>
			<p>Some financial calculations return a negative answer. This tells you which way the money flows, to you or to the bank. I am using the <strong class="source-inline">BigDecimal</strong> absolute method to eliminate <span class="No-Break">the sign:</span></p>
			<pre class="source-code">
        data.setMonthlyPayment(temp.abs());
    }
}</pre>
			<p>The question <a id="_idIndexMarker823"/>now is how we can test this code to ensure it is giving us the right answer. We could write code in the <strong class="source-inline">main</strong> method to test it, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    public static void main(String[] args) {
        var data = new FinancialData(
               new BigDecimal("5000.0"),
               new BigDecimal("0.05"),
               new BigDecimal("60.0"));
        new Calculation().loanCalculation(data);</pre>
			<p>As already noted in <a href="B19088_08.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Arrays, Collections, Generics, Functions, and Streams</em>, you cannot use operators such as +, &gt;, and ==, with objects. Instead, you use methods such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">equals</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        if (data.getMonthlyPayment().equals(
                 new BigDecimal("94.36"))) {
            System.out.printf("Test passed%n");
        } else {
            System.out.printf("Test failed: %.2f %s%n",
                   data.getMonthlyPayment(), "94.36");
        }
    }</pre>
			<p>What if you<a id="_idIndexMarker824"/> want to test many values? The <strong class="source-inline">loanCalculation</strong> method shows that it could throw <strong class="source-inline">ArithmeticException</strong>. How can you test that this exception is thrown when appropriate? The answer is <span class="No-Break">unit testing.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor248"/>What is JUnit 5?</h1>
			<p>JUnit 5 is<a id="_idIndexMarker825"/> an open source library and not part of the Java Development Kit library. It is licensed using the Eclipse Public License v2.0. This simply means that you are free to use this library and distribute it with your work for either open source or commercial software without having to make any payments. So, what does <span class="No-Break">it do?</span></p>
			<p>This unit testing framework allows you to instantiate any class in your project and call upon any non-private method. These non-private methods, such as <strong class="source-inline">public</strong> and <strong class="source-inline">package</strong>, can be executed from within what is called a test class. These are classes that are instantiated by the JUnit framework. A test class contains methods that can instantiate any class in the project and call upon a method in <span class="No-Break">the class.</span></p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor249"/>Testing with JUnit 5</h1>
			<p>Test classes<a id="_idIndexMarker826"/> are not part of the usual source code folder, <strong class="source-inline">src/main/java</strong>. Instead, they are placed in <strong class="source-inline">src/test/java</strong>. They can and should be organized into packages. You can also have resources that are just used by the test classes, such as <strong class="source-inline">logging.properties</strong> or <strong class="source-inline">log4j2.xml</strong>. They will be placed <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">src/test/resources</strong></span><span class="No-Break">.</span></p>
			<p>We will need to add <a id="_idIndexMarker827"/>new components to our Maven <strong class="source-inline">pom.xml</strong> file. The first is the dependency for JUnit 5. The first addition is<a id="_idIndexMarker828"/> the <strong class="bold">bill of materials</strong> (<strong class="bold">BOM</strong>), in a section <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">dependencyManagement</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.junit&lt;/groupId&gt;
                &lt;artifactId&gt;junit-bom&lt;/artifactId&gt;
                &lt;version&gt;5.9.1&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;</pre>
			<p>All dependencies<a id="_idIndexMarker829"/> and plugins in a Maven-based project require a <a id="_idIndexMarker830"/>version value. One way you can ensure that the version value for all dependencies of a given library is correct is to use, if available, a BOM. Now, it is no longer necessary to include version values for <span class="No-Break">each library.</span></p>
			<p>Next is the dependency specifically for JUnit 5. This dependency supports both single test methods and parameterized tests. Notice also that the scope of these dependencies is <strong class="source-inline">test</strong>, which means that they are not included in the final packaging of the code. The test classes are also not included in the final packaging of <span class="No-Break">your code:</span></p>
			<pre class="source-code">
    &lt;dependency&gt;
        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
        &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;</pre>
			<p>The next change is to add the Maven <strong class="source-inline">surefire</strong> plugin. This plugin will run all unit tests. The results of the test will appear in the console, a text file, and an XML file. These files can be found in <strong class="source-inline">target/surefire-reports</strong>. This folder will be created for you when you run the tests. Existing test reports will be overwritten when the tests <span class="No-Break">are rerun:</span></p>
			<pre class="source-code">
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;
                      maven-surefire-plugin
                &lt;/artifactId&gt;
                &lt;version&gt;2.22.2&lt;/version&gt;
            &lt;/plugin&gt;</pre>
			<p>The <a id="_idIndexMarker831"/>example code does not have a <strong class="source-inline">main</strong> method as it represents a project in progress. It cannot be run but it can be unit tested. To just run the tests when you use <strong class="source-inline">mvn</strong>, set <strong class="source-inline">defaultGoal</strong> in the <span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> section:</span></p>
			<pre class="source-code">
&lt;defaultGoal&gt;test&lt;/defaultGoal&gt;</pre>
			<p>Let’s create <a id="_idIndexMarker832"/>a basic unit test. The first thing you will need is to add the <strong class="source-inline">test/java</strong> and <strong class="source-inline">test/resources</strong> folders to the Maven project you are writing unit tests for. This is what the folder structure looks like for my example project. I have also added a package called <strong class="source-inline">com.kenfogel.calculationtest</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">test/java</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B19088_12_01.jpg" alt="Figure 12.1 – Folder structure for unit tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Folder structure for unit tests</p>
			<p>Now, let us look at our test class. The code examples in the book up to this point have not shown the required imports. They can be found in the code samples in the GitHub repo for the book. These examples will look at imports. Here is the <span class="No-Break"><strong class="source-inline">SimpleTest.java</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
package com.kenfogel.calculationtest;</pre>
			<p>These two imports make the <strong class="source-inline">Calculation</strong> and <strong class="source-inline">FinancialData</strong> classes available to <span class="No-Break">this class:</span></p>
			<pre class="source-code">
import
  com.kenfogel.loanbigdecimalunittest.business.Calculation;
import
  com.kenfogel.loanbigdecimalunittest.data.FinancialData;</pre>
			<p>Here are the imports for what we will use from <span class="No-Break">JUnit 5:</span></p>
			<pre class="source-code">
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;</pre>
			<p>This<a id="_idIndexMarker833"/> last <strong class="source-inline">static</strong> import allows us to use <strong class="source-inline">assertEquals</strong> without <a id="_idIndexMarker834"/>needing to show the whole package structure <span class="No-Break">seen here:</span></p>
			<pre class="source-code">
import
  static org.junit.jupiter.api.Assertions.assertEquals;</pre>
			<p>Finally, we have the import <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">BigDecimal</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.math.BigDecimal;
public class SimpleTest {
    private Calculation calc;
    private FinancialData data;</pre>
			<p>The <strong class="source-inline">@BeforeEach</strong> annotation is used to define methods that must be run before each test method. It has a companion <strong class="source-inline">@AfterEach</strong> annotation. There are also <strong class="source-inline">@BeforeAll</strong> and <strong class="source-inline">@AfterAll</strong>, which are methods run once before all testing begins or after all testing ends. The best practice in testing is to always instantiate the objects you will use for testing for each test. Avoid reusing an object that was used in a previous test as it can result in unexpected errors in tests that depend <span class="No-Break">upon it:</span></p>
			<pre class="source-code">
    @BeforeEach
    public void init() {
        calc = new Calculation();
        data = new FinancialData();
    }</pre>
			<p>Here is the test annotated with <strong class="source-inline">@Test</strong>. It sets the three variables in <strong class="source-inline">FinancialData</strong> and calls upon the <strong class="source-inline">Calculation</strong> class to calculate the loan payment. It ends with <strong class="source-inline">assertEquals</strong> to compare the result with the <span class="No-Break">known answer:</span></p>
			<pre class="source-code">
    @Test
    public void knownValueLoanCalculationTest () {
        data.setAmountBorrowed(new BigDecimal("5000"));
        data.setAnnualRate(new BigDecimal("0.05"));
        data.setTerm(new BigDecimal("60"));
        calc.loanCalculation(data);
        assertEquals(new BigDecimal("94.36"),
            data.getMonthlyPayment());
    }
}</pre>
			<p>To<a id="_idIndexMarker835"/> run<a id="_idIndexMarker836"/> the test with the default goal set to <strong class="source-inline">test</strong>, you just need to run <strong class="source-inline">mvn</strong> at the command line in the root folder of the project. Here is the output of the test in <span class="No-Break">the console:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B19088_12_02.jpg" alt="Figure 12.2 – The test result"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – The test result</p>
			<p>You can also test <a id="_idIndexMarker837"/>that an expected exception is thrown. Here is the method rewritten but with <strong class="source-inline">term</strong> set to <strong class="source-inline">0</strong>. This should result in <strong class="source-inline">ArithmeticException</strong> with a message of <strong class="source-inline">Division by zero</strong>. Asserting on the message is important as there are two possible reasons for <strong class="source-inline">ArithmeticException</strong>. The first is division by zero. The second<a id="_idIndexMarker838"/> occurs when a calculation using <strong class="source-inline">BigDecimal</strong> has an infinitely <span class="No-Break">repeating sequence.</span></p>
			<p>First, we need another <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span></p>
			<pre class="source-code">
import static
     org.junit.jupiter.api.Assertions.assertThrowsExactly;</pre>
			<p>Now we can write <span class="No-Break">the test:</span></p>
			<pre class="source-code">
    @Test
    public void knownValueLoanExceptionTest() {
        data.setAmountBorrowed(new BigDecimal("5000"));
        data.setAnnualRate(new BigDecimal("0.05"));
        data.setTerm(new BigDecimal("0"));</pre>
			<p>Here, we are calling the method we expect to throw an exception in <strong class="source-inline">assertThrowsExactly</strong>. This method begins with the name of the exception class we are expecting followed by a lambda expression to invoke the method we expect to throw <strong class="source-inline">ArithmeticException</strong>. The <strong class="source-inline">assertThrowsExactly</strong> method returns the exception object that was thrown, and we assign it to an <strong class="source-inline">ArithmeticException</strong> object. We can <a id="_idIndexMarker839"/>now use the <strong class="source-inline">assertEquals</strong> method to determine whether division by zero was the <a id="_idIndexMarker840"/>cause of this exception. If no exception is thrown or a different message is found, then the test <span class="No-Break">will fail:</span></p>
			<pre class="source-code">
        ArithmeticException ex =
            assertThrowsExactly(ArithmeticException.class,
            () -&gt; {calc.loanCalculation(data);});
        assertEquals("Division by zero", ex.getMessage());
    }</pre>
			<p>This concludes our look at basic unit testing where each test runs just once. Ideally, a unit test should be run with a range of values and not just one. This is what we will look <span class="No-Break">at next.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor250"/>Performing parameterized testing</h1>
			<p>This<a id="_idIndexMarker841"/> leaves one more type of testing to look at, a parameterized test. As you may have realized, if you want to run a test to determine whether the result is accurate for several values, then you will need one method per set of values. JUnit 5 simplifies this task by allowing you to create a list of values. Let’s see how this works. Here is the new parameterized <span class="No-Break">test class:</span></p>
			<pre class="source-code">
public class ParameterizedTests {
    private Calculation calc;
    private FinancialData data;</pre>
			<p>We will not instantiate the <strong class="source-inline">FinancialData</strong> object here as we did in the previous example. It will be created by a private <span class="No-Break">helper method:</span></p>
			<pre class="source-code">
    @BeforeEach
    public void init() {
        calc = new Calculation();
    }</pre>
			<p>The <a id="_idIndexMarker842"/>first annotation declares that this will be a parameterized test. This means that this method will be run once for every row of data listed as part <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">@CsvSource</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    @ParameterizedTest
    @CsvSource({
        "5000, 0.05, 60, 94.36",
        "3000, 0.05, 24, 131.61",
        "20000, 0.05, 72, 322.10"
    })</pre>
			<p>The <strong class="source-inline">ArgumentsAccessor</strong> parameter will contain the current row of data to test. This method will be called for every row <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">@CsvSource</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    public void knownValueLoanCalculationTest_param (
                     ArgumentsAccessor args) {</pre>
			<p>Our data class wants <strong class="source-inline">BigDecimal</strong> values. To accomplish this, we have a private method called <strong class="source-inline">buildBean</strong> that receives an object of type <strong class="source-inline">ArgumentsAccessor</strong> and then converts that into a <span class="No-Break"><strong class="source-inline">FinancialData</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
        data = buildBean(args);
        calc.loanCalculation(data);</pre>
			<p>Each row of CSV data has the answer as the last element. We are comparing the result stored in <strong class="source-inline">monthlyPayment</strong> with the <span class="No-Break">last parameter:</span></p>
			<pre class="source-code">
        assertEquals(new BigDecimal(args.getString(3)),
                      data.getMonthlyPayment());
    }</pre>
			<p>Our helper method constructs a <strong class="source-inline">FinancialData</strong> object from the first three items in the <span class="No-Break"><strong class="source-inline">ArgumentsAccessor</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
   private FinancialData buildBean(ArgumentsAccessor args){
      return
       new FinancialData(new BigDecimal(args.getString(0)),
                        new BigDecimal(args.getString(1)),
                        new BigDecimal(args.getString(2)));
    }
}</pre>
			<p>There is still <a id="_idIndexMarker843"/>more to learn about unit testing. If a test depends on a specific object supplying a specific value to the test method but is not considered to be a point of failure, you can fake it. This is called mocking an object. You create the mock and what its method must return. See the <em class="italic">Further reading</em> section for a link to one of the widely used mocking libraries, <span class="No-Break">called Mockito.</span></p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor251"/>Summary</h1>
			<p>The first topic we covered in this chapter was the <strong class="source-inline">BigDecimal</strong> class. Floating point values as processed by modern FPUs have issues when moving from decimal to binary and back again. This can be critical in the field of accounting where every penny must balance. As a class, <strong class="source-inline">BigDecimal</strong> objects are not as easy to use as primitives, but it is the need for absolute accuracy that mandates <span class="No-Break">their use.</span></p>
			<p>As I stated at the start of this chapter, testing is a critical task that every programmer should be doing. You should be delivering code that works as expected in almost every situation it is used for. Unit tests do not prove that the program’s logic is necessarily correct. This is usually tested by the QA team who are testing the execution of <span class="No-Break">the program.</span></p>
			<p>While writing this book, I came across a research paper that looked at unit testing. You can find the link in the <em class="italic">Further reading</em> section. It focused on Java and C# developers who used integrated development environments such as Visual Studio or IntelliJ. What the paper discovered is that less than half the developers in the study did any kind of software testing despite the ease with which it can be written in an IDE. Please do not be in the <span class="No-Break">wrong half.</span></p>
			<p>In this chapter, we looked at two separate concepts. The first was how we can perform calculations, such as in accounting, that must be accurate to a specific number of decimal places. We accomplish this by using the <strong class="source-inline">BigDecimal</strong> class to represent floating point numbers rather than <strong class="source-inline">float</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">.</span></p>
			<p>The second concept introduced software testing using unit tests. As a programmer, you need to be able to show that the public methods you write perform as expected. This is what unit testing is about. I wrote in the previous chapter that commenting and logging were mandatory. I add unit testing to the list of mandatory tasks a programmer is expected <span class="No-Break">to perform.</span></p>
			<p>Next, let us move on and look at the <strong class="bold">user experience</strong>, also referred to as <strong class="bold">UX</strong>. Up until now, sample code used a console UX akin to the output of a typewriter. In the coming chapter, we will look at the graphical user interface UX that Java has available <span class="No-Break">for us.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor252"/>Further reading</h1>
			<ul>
				<li>JUnit <span class="No-Break">5: </span><a href="https://junit.org/junit5/"><span class="No-Break">https://junit.org/junit5/</span></a></li>
				<li><em class="italic">Developer Testing in The IDE – Patterns, Beliefs, And Behavior</em>: <a href="https://repository.tudelft.nl/islandora/object/uuid:a63e79e0-e0e4-48cd-81ed-87f163810538/datastream/OBJ/download">https://repository.tudelft.nl/islandora/object/uuid:a63e79e0-e0e4-48cd-81ed-87f163810538/datastream/OBJ/download</a> (this is a PDF file and not a <span class="No-Break">web page)</span></li>
				<li>Mokito – Tasty mocking framework for unit tests in <span class="No-Break">Java: </span><a href="https://site.mockito.org/"><span class="No-Break">https://site.mockito.org/</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer064" class="Content">
			<h1 id="_idParaDest-231"><a id="_idTextAnchor253"/>Part 3:GUI and Web Coding in Java</h1>
			<p>With the fundamentals out of the way, it is time to look at a Java application. In this part, we see how a business process used in the previous section can be used in programs that share the logic but that use a different GUI library from desktop application to <span class="No-Break">web application.</span></p>
			<p>This part contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19088_13.xhtml#_idTextAnchor254"><em class="italic">Chapter 13</em></a>, <em class="italic">Desktop Graphical User Interface Coding with Swing and JavaFX</em></li>
				<li><a href="B19088_14.xhtml#_idTextAnchor281"><em class="italic">Chapter 14</em></a>, <em class="italic">Server-Side Coding with Jakarta</em></li>
				<li><a href="B19088_15.xhtml#_idTextAnchor301"><em class="italic">Chapter 15</em></a>, <em class="italic">Jakarta Faces Application</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer065">
			</div>
		</div>
		<div>
			<div id="_idContainer066">
			</div>
		</div>
	</body></html>