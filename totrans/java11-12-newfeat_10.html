<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">ZGC</h1>
                </header>
            
            <article>
                
<p>Java 11 includes a lot of improvements and changes in the GC domain. With <strong>Z Garbage Collector</strong> (<strong>ZGC</strong>), Java is bringing another GC for you—scalable, with low latency. It is a completely new GC, written from scratch. It can work with heap memory, ranging from KBs to a large TB memory. As a concurrent garbage collector, ZGC promises not to exceed application latency by 10 milliseconds, even for bigger heap sizes. It is also easy to tune.</p>
<p>It was released with Java 11 as an experimental GC. Work is in progress on this GC in OpenJDK and you can expect more changes to it over time.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Why ZGC is required</li>
<li>Features of ZGC</li>
<li>Examples of working with ZGC</li>
<li>ZGC use cases</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can use the ZGC with Java 11 and with Linux/x64 systems. ZGC is an experimental GC. All of the code in this chapter can be accessed by going to this book's GitHub repository at: <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a>.</p>
<p>Let's get started by assessing why we need ZGC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The motivation</h1>
                </header>
            
            <article>
                
<p>One of the features that resulted in the rise of Java in the early days was its automatic memory management with its GCs, which freed developers from manual memory management and lowered memory leaks.</p>
<p class="mce-root"/>
<p>However, with unpredictable timings and durations, garbage collection can (at times) do more harm to an application than good. Increased latency directly affects the throughput and performance of an application. With eve-decreasing hardware costs and programs engineered to use largish memories, applications are demanding lower latency and higher throughput from garbage collectors.</p>
<p>ZGC promises a latency of no more than 10 milliseconds, which doesn't increase with heap size or a live set. This is because its stop-the-world pauses are limited to root scanning.</p>
<div class="packt_infobox">ZGC is a scalable, low latency GC, which promises up to 10 milliseconds of latency, even for large heap memory (terabytes in size).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Features of ZGC</h1>
                </header>
            
            <article>
                
<p>Written from scratch, ZGC brings in a lot of features, which have been instrumental in its proposal, design, and implementation.</p>
<p>One of the most outstanding features of ZGC is that it is a concurrent GC. It can mark memory and copy and relocate it, all concurrently. It also has a concurrent reference processor. This essentially means that you can add all sort of references, such as weak references, soft references, phantom references, or finalizers (these are deprecated now). Even then, ZGC won't add more GC pauses for you (since it will clean or reclaim the memory concurrently).</p>
<p>As opposed to the store barriers that are used by another HotSpot GCs, ZGC uses load barriers. The load barriers are used to keep track of heap usage. One of the intriguing features of ZGC is the usage of load barriers with colored pointers. This is what enables ZGC to perform concurrent operations when Java threads are running, such as object relocation or relocation set selection.</p>
<p>ZGC is a region-based garbage collector. However, if you compare it to the G1 garbage collector, ZGC is more flexible in configuring its size and scheme. Compared to G1, ZGC has better ways to deal with very large object allocations.</p>
<p>ZGC is a single-generation GC. It also supports partial compaction. ZGC is also highly performant when it comes to reclaiming memory and reallocating it.</p>
<p>ZGC is NUMA-aware, which essentially means that it has a NUMA-aware memory allocator.</p>
<p class="mce-root"/>
<div class="packt_infobox">An experimental garbage collector, ZGC is only available on Linux/x64. More platform support will be added in the future if there is a considerable demand for it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with ZGC</h1>
                </header>
            
            <article>
                
<p>Working with ZGC involves multiple steps. You should install the JDK binary, which is specific to Linux/x64, and build and start it. You can use the following commands to download ZGC and build it on your system:</p>
<pre><strong>$ hg clone http://hg.openjdk.java.net/jdk/jdk</strong>
<strong>$ cd zgc</strong>
<strong>$ sh configure --with-jvm-features=zgc</strong>
<strong>$ make images</strong></pre>
<p>After execution of the preceding commands, you can find the JDK root directory in the following location:</p>
<pre><strong>g./build/linux-x86_64-normal-server-release/images/jdk</strong>  </pre>
<p>Java tools, such as <kbd>java</kbd>, <kbd>javac</kbd>, and others can be found in the <kbd><span>/bin</span></kbd> subdirectory of the preceding path (its usual location).</p>
<div class="packt_infobox"><span class="packt_screen">Spoiler alert</span>: You won't be able to work with ZGC unless you have Linux/x64.</div>
<p>Let's create a basic <kbd>HelloZGC</kbd> class, as follows:</p>
<pre>class HelloZGC { 
    public static void main(String[] args) { 
        System.out.println("Say hello to new low pause GC - ZGC!"); 
    } 
} </pre>
<p>You can use the following command to enable ZGC and use it:</p>
<pre><strong>java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC HelloZGC</strong></pre>
<p>Since ZGC is an experimental GC, you need to unlock it using the runtime option, that is, <kbd>XX:+UnlockExperimentalVMOptions</kbd>.</p>
<p class="mce-root"/>
<p>For enabling basic GC logging, you can add the <kbd>-Xlog:gc</kbd> option. Let's modify the preceding code, as follows:</p>
<pre><strong>java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xlog:gc HelloZGC</strong></pre>
<p>Detailed logging is helpful when you are fine-tuning your application. You can enable it by using the <kbd>-Xlog:gc*</kbd> <span>option </span> as follows:</p>
<pre><strong>java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xlog:gc* HelloZGC</strong></pre>
<p>The previous command will output all the logs to the console, which could make it difficult to search for specific content. You can specify the logs to be written to a file as follows:</p>
<pre><strong>java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xlog:gc:mylog.log* HelloZGC</strong>  </pre>
<div class="packt_infobox">When compared with G1 and parallel GCs, ZGC performs better in terms of lower latency and higher application throughput.</div>
<p>Let's take a sneak peek into how ZGC arranges the heap for object allocation (in short, let's start with exploring the secret sauce of ZGC).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ZGC heap</h1>
                </header>
            
            <article>
                
<p>ZGC divides memory into regions, also called <strong>ZPages</strong>. ZPages can be dynamically created and destroyed. These can also be dynamically sized (unlike the G1 GC), which are multiples of 2 MB. Here are the size groups of heap regions:</p>
<ul>
<li>Small (2 MB)</li>
<li>Medium (32 MB)</li>
<li>Large (<em>N *</em> 2 MB)</li>
</ul>
<p class="mce-root"/>
<p>ZGC heap can have multiple occurrences of these heap regions. The medium and large regions are allocated contiguously, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f39ecb71-53bb-4779-b4e2-42c64f9856ba.png"/></p>
<p>Unlike other GCs, the physical heap regions of ZGC can map into a bigger heap address space (which can include virtual memory). This can be crucial to combat memory fragmentation issues. Imagine that you can allocate a really big object in memory, but you can't do so due to unavailability of contiguous space in memory.</p>
<p>This often leads to multiple GC cycles to free up enough contiguous space. If none are available, even after (multiple) GC cycle(s), your JVM will shut down with <kbd>OutOfMemoryError</kbd>. However, this particular use case is not an issue with the ZGC. Since the physical memory maps to a bigger address space, locating a bigger contiguous space is feasible.</p>
<div class="packt_infobox">ZPages are a multiple of the same number, say, 2 MB on an Intel machine. It could vary, to, say, 4 MB on an <em>S</em> machine.</div>
<p class="mce-root"/>
<p>Now, let's see how the ZGC reclaims the memory from its regions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ZGC phases</h1>
                </header>
            
            <article>
                
<p>A GC cycle of ZGC includes multiple phases:</p>
<ul>
<li>Pause Mark Start</li>
<li>Pause Mark End</li>
<li>Pause Relocate Start</li>
</ul>
<p>In the first phase, Pause Mark Start, ZGC marks objects that have been pointed to by roots. This includes walking through the live set of objects, and then finding and marking them. This is by far one of the most heavy-duty workloads in the ZGC GC cycle.</p>
<p>Once this completes, the next cycle is Pause Mark Start, which is used for synchronization and starts with a short pause of 1 ms. In this second phase, ZGC starts with reference processing and moves to week-root cleaning. It also includes the relocation set selection. ZGC marks the regions it wants to compact.</p>
<p>The next step, Pause Relocate Start, triggers the actual region compaction. It begins with root scanning pointing into the location set, followed by the concurrent reallocation of objects in the relocation set.</p>
<p>The first phase, that is, Pause Mark Start, also includes remapping the live data. Since marking and remap of live data is the most heavy-duty GC operation, it isn't executed as a separate one. Remap starts after Pause Relocate Start but overlaps with the Pause Mark Start phase of the next GC cycle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Colored pointers</h1>
                </header>
            
            <article>
                
<p>Colored pointers are one of the core concepts of ZGC. It enables ZGC to find, mark, locate, and remap the objects. It doesn't support x32 platforms. Implementation of colored points needs virtual address masking, which could be accomplished either in the hardware, operating system, or software. The following diagram shows the 64-bit pointer layout:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/caffda24-905f-4ef1-8271-d83de904e81a.png" style="width:47.67em;height:15.17em;"/></p>
<p>As shown in the preceding diagram, the 64-bit object reference is divided as follows:</p>
<ul>
<li>18 bits: <strong>Unused bits</strong></li>
<li>1-bit: <strong>Finalizable</strong></li>
<li>1-bit: <strong>Remapped</strong></li>
<li>1-bit: <strong>Marked1</strong></li>
<li>1-bit: <strong>Marked0</strong></li>
<li>42 bits: <strong>Object Address</strong></li>
</ul>
<p>The first 18 bits are reserved for future use. The 42 bits can address up to 4 TB of address space. Now comes the remaining, intriguing, 4 bits. The <kbd>Marked1</kbd> and <kbd>Marked0</kbd><span> bits </span>are used to mark objects for garbage collection. By setting the single bit for <strong>Remapped</strong>, an object can be marked not pointing to into the relocation set. The last 1-bit for finalizing relates to concurrent reference processing. It marks that an object can only be reachable through a finalizer.</p>
<p>When you run ZGC on a system, you'll notice that it uses a lot of virtual memory space, which, as you know, is not the same as the physical memory space. This is due to heap multi-mapping. It specifies how the objects with the colored pointers are stored in the virtual memory.</p>
<p>As an example, for a colorless pointer, say, <kbd>0x0000000011111111</kbd>, its colored pointers would be <kbd>0x0000<strong>10</strong>0011111111</kbd> (remapped bit set), <kbd>0x00000<strong>8</strong>0011111111</kbd> (<kbd>Marked1</kbd> bit set), and <kbd>0x00000<strong>4</strong>0011111111</kbd> (<kbd>Marked0</kbd> bit set). The same physical heap memory would map to three different locations in address space, each corresponding to the colored pointer. This would be implemented differently when the mapping is handled differently.</p>
<p>Let's explore other important JVM runtime parameters, which you can use to tune ZGC.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuning ZGC</h1>
                </header>
            
            <article>
                
<p>Let's look at a couple of options to fine-tune ZGC (this chapter covers just a few basic ones). Let's start with the most basic option of setting the max heap size. We can do this by using the following JVM runtime option:</p>
<pre><strong>-Xmx&lt;size&gt;</strong></pre>
<p>To get the optimal performance, you must set a heap size that can not only store the live set of your application but also has enough space to service the allocations.</p>
<p>ZGC is a concurrent garbage collector. By setting the amount of CPU time that should be assigned to ZGC threads, you can control how often the GC kicks in. You can do so by using the following option:</p>
<pre><strong>-XX:ConcGCThreads=&lt;number&gt; </strong></pre>
<p>A higher value for the <kbd>ConcGCThreads</kbd> <span>option </span>will leave less amount of CPU time for your application. On the other hand, a lower value may result in your application struggling for memory; your application might generate more garbage than what is collected by ZGC. ZGC can also use default values for <kbd>ConcGCThreads</kbd>. To fine-tune your application on this parameter, you might prefer to execute against test values.</p>
<p>For advanced ZGC tuning, you can also enable large pages for enhanced performance of your application. You can do this by using the following option:</p>
<pre><strong>-XX:+UseLargePages</strong></pre>
<div class="packt_infobox">The preceding command needs root privileges. Please refer to <a href="https://wiki.openjdk.java.net/display/zgc">https://wiki.openjdk.java.net/display/zgc</a> for detailed steps.</div>
<p>Instead of enabling large pages, you can also enable transparent huge pages by using the following option:</p>
<pre><strong>-XX:+UseTransparentHugePage</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding option also includes additional settings and configurations, which can be accessed by using ZGC's official wiki page, hosted at <a href="https://wiki.openjdk.java.net/display/zgc">https://wiki.openjdk.java.net/display/zgc</a>.</p>
<p>ZGC is a NUMA-aware GC. Applications executing on the NUMA machine can result in a noticeable performance gain. By default, NUMA support is enabled for ZGC. However, if the JVM realizes that it is bound to a subset in the JVM, this feature can be disabled. To override a JVM's decision, you can use the following option:</p>
<pre><strong>-XX:+UseNUMA</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered a scalable, low latency GC for OpenJDK—ZGC. It is an experimental GC, which has been written from scratch. As a concurrent GC, it promises max latency to be less than 10 milliseconds, which doesn't increase with heap size or live data.</p>
<p>At present, it only works with Linux/x64. More platforms can be supported in the future, if there is considerable demand for it.</p>
<p>In the next chapter, you'll discover how you can use <strong>Java Flight Recorder</strong> (<strong>JFR</strong>) and <strong>Mission Control</strong> (<strong>MC</strong>) to capture the OS and JVM events in a file and analyze them.</p>


            </article>

            
        </section>
    </body></html>