<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Wiring Beans using the Dependency Injection Pattern</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, you learned about the <strong>Gang of Four</strong> (<strong>GOF</strong>) design patterns with examples and use cases of each. Now, we will go into more detail about injecting beans and the configuration of dependencies in a Spring application, where you will see the various ways of configuring dependencies in a Spring application. This includes configuration with XML, Annotation, Java, and Mix.</p>
<p>Everyone loves movies, right? Well, if not movies, how about plays, or dramas, or theatre? Ever wondered what would happen if the different team members didn't speak to each other? By team I don't just mean the actors, but the sets team, make-up personnel, audio-visual guys, sound system guys, and so on. It is needless to say that every member has an important contribution towards the end product, and an immense amount of coordination is required between these teams.</p>
<p>A blockbuster movie is a product of hundreds of people working together toward a common goal. Similarly, great software is an application where several objects work together to meet some business target. As a team, every object must be aware of the other, and communicate with each other to get their jobs done.</p>
<p>In a banking system, the money transfer service must be aware of the account service, and the account service must be aware of the accounts repository, and so on. All these components work together to make the banking system workable. In <a href="18f63847-961b-45a2-bef0-30602dcabed3.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Getting Started with Framework 5.0 and Design Patterns</em>, you saw the same banking example created with the traditional approach, that is, creating objects using construction and direct object initiation. This traditional approach leads to complicated code, is difficult to reuse and unit test, and is also highly coupled to one another.</p>
<p>But in Spring, objects have a responsibility to do their jobs without the need to find and create the other dependent objects that are required in their jobs. The Spring container takes the responsibility to find or create the other dependent objects, and to collaborate with their dependencies. In the previous example of the banking system, the transfer service depends on the account service, but it doesn't have to create the account service, so the dependency is created by the container, and is handed over to the dependent objects in the application.</p>
<p>In this chapter, we will discuss the behind-the-scenes story of the Spring-based application with reference to the <strong>dependency injection</strong> (<strong>DI</strong>) pattern, and how it works. By the end of this chapter, you will understand how the objects of your Spring-based application create associations between them, and how Spring wires these objects for a job done. You will also learn many ways to wire beans in Spring.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>The dependency injection pattern</li>
<li>Types of dependency injection patterns</li>
<li>Resolving dependency using the Abstract Factory pattern</li>
<li>Lookup-method injection pattern</li>
<li>Configuring beans using the Factory pattern</li>
<li>Configuring dependencies</li>
<li>Common best practices for configuring dependencies in an application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The dependency injection pattern</h1>
                </header>
            
            <article>
                
<p>In any enterprise application, coordination between the working objects is very important for a business goal. The relationship between objects in an application represents the dependency of an object, so each object would get the job done with coordination of the dependent objects in the application. Such required dependencies between the objects tend to be complicated and with tight-coupled programming in the application. Spring provides a solution to the tight-coupling code of an application by using the dependency injection pattern. Dependency injection is a design pattern, which promotes the loosely coupled classes in the application. This means that the classes in the system depend on the behavior of others, and do not depend on instantiation of object of the classes. The dependency injection pattern also promotes programming to interface instead of programming to implementation. Object dependencies should be on an interface, and not on concrete classes, because a loosely coupled structure offers you greater reusability, maintainability, and testability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solving problems using the dependencies injection pattern</h1>
                </header>
            
            <article>
                
<p>In any enterprise application, a common problem to handle is how to configure and wire together the different elements to achieve a business goal--for example, how to bind together the controllers at the web layer with the services and repository interfaces written by different members of the team without knowing about the controllers of the web layers. So, there are a number frameworks that provide a solution for this problem by using lightweight containers to assemble the components from different layers. Examples of such types of frameworks are PicoContainer and Spring Framework.</p>
<p>The containers of PicoContainer and Spring use a number of design patterns to solve the problem of assembling the different components of different layers. Here, I am going to discuss one of these design patterns--the dependency injection pattern. Dependency injection provides us with a decoupled and loosely coupled system. It ensures construction of the dependent object. In the following example, we'll demonstrate how the dependency injection pattern solves the common problems related to collaboration between the various layered components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Without dependency injection</h1>
                </header>
            
            <article>
                
<p>In the following Java example, first of all, let's see what is a dependency between two classes? Take a look at the following class diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/83147f64-2d22-4553-b1d9-a3fb6118fd9f.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">TransferService has dependencies with AccountRepository and TransferRepository for transferAmount() method with Direct Instantiation of repositories classes.</div>
<p>As seen in the preceding diagram, the <strong>TransferService</strong> class contains two member variables, <strong>AccountRepository</strong> and <strong>TransferRepository.</strong> These are initialized by the <strong>TransferService</strong> constructor. <strong>TransferService</strong> controls which implementation of the repositories is used. It also controls their construction. In this situation, <strong>TransferService</strong> is said to have a hard-coded dependency on the following example:</p>
<p>Following is the <kbd>TransferServiceImpl.java</kbd> file:</p>
<pre>    public class TransferServiceImpl implements TransferService { 
      AccountRepository accountRepository; 
      TransferRepository transferRepository; 
      public TransferServiceImpl(AccountRepository accountRepository, <br/>      TransferRepository transferRepository) { 
        super(); <br/>        // Specify a specific implementation in the constructor <br/>        instead of using dependency injection<br/>        this.accountRepository = new JdbcAccountRepository(); 
        this.transferRepository = new JdbcTransferRepository(); 
      } <br/>      // Method within this service that uses the accountRepository and <br/>      transferRepository<br/>      @Override 
      public void transferAmmount(Long a, Long b, Amount amount) { 
        Account accountA = accountRepository.findByAccountId(a); 
        Account accountB = accountRepository.findByAccountId(b); 
        transferRepository.transfer(accountA, accountB, amount); 
      } 
    }   </pre>
<p>In the preceding example, the <kbd>TransferServiceImpl</kbd> class has dependencies of two classes, that is <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>. The <kbd>TransferServiceImpl</kbd> class has two member variables of the dependent classes, and initializes them through its constructor by using the JDBC implementation of repositories such as <kbd>JdbcAccountRepository</kbd> and <kbd>JdbcTransferRepository</kbd>. The <kbd>TransferServiceImpl</kbd> class is tightly coupled with the JDBC implementation of repositories; in case the JDBC implementation is changed to a JPA implementation, you have to change your <kbd>TransferServiceImpl</kbd> class as well.</p>
<p>According to the SOLID (Single Responsibility Principle, Open Closed Principle, Liskov's Substitution Principle, Interface Segregation Principle, Dependency Inversion Principle) principles, a class should have a single responsibility in the application, but in the preceding example, the <kbd>TransferServiceImpl</kbd> class is also responsible for constructing the objects of <kbd>JdbcAccountRepository</kbd> and <kbd>JdbcTransferRepository</kbd> classes. We can't use direction instantiation of objects in the class.</p>
<p>In our first attempt to avoid the direct instantiation logic in the <kbd>TransferServiceImpl</kbd> class, we can use a <kbd>Factory</kbd> class that creates instances of <kbd>TransferServiceImpl</kbd>. According to this idea, <kbd>TransferServiceImpl</kbd> minimizes the dependency from <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>--earlier we had a tightly coupled implementation of the repositories, but now it refers only to the interface, as shown in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/e37d550f-2329-49ce-a6f7-d7dfd3f42b95.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">TransferService has dependencies with AccountRepository and TransferRepository for transferAmount() method with Factory of repositories classes.</div>
<p>But the <kbd>TransferServiceImpl</kbd> class is, again, tightly coupled with the implementation of the <kbd>RepositoryFactory</kbd> class. Moreover, this process is not suitable for cases where we have more number of dependencies, which increases either the <kbd>Factory</kbd> classes or the complexity of the <kbd>Factory</kbd> class. The repository classes can also have other dependencies.</p>
<p>The following code uses the <kbd>Factory</kbd> class to get the <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> classes:</p>
<p>Following is the <kbd>TransferServiceImpl.java</kbd> file:</p>
<pre><span>    package com.packt.patterninspring.chapter4.bankapp.service;</span><br/>    public class TransferServiceImpl implements TransferService { 
      AccountRepository accountRepository; 
      TransferRepository transferRepository; 
      public TransferServiceImpl(AccountRepository accountRepository,<br/>      TransferRepository transferRepository) { 
        this.accountRepository = RepositoryFactory.getInstance(); 
        this.transferRepository = RepositoryFactory.getInstance(); 
      }<br/>    <span>@Override<br/></span>    public void transferAmount(Long a, Long b, Amount amount) { 
      Account accountA = accountRepository.findByAccountId(a); 
      Account accountB = accountRepository.findByAccountId(b); 
      transferRepository.transfer(accountA, accountB, amount); 
    } 
   } </pre>
<p>In the preceding code example, we have minimized tight coupling, and removed direction object instantiation from the <kbd>TransferServiceImpl</kbd> class, but this is not the optimal solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">With dependency injection pattern</h1>
                </header>
            
            <article>
                
<p>The Factory idea avoids direct instantiation of an object of a class, and we also have to create another module that is responsible for wiring the dependencies between classes. This module is known as a <strong>dependency injector</strong>, and is based on the <strong>Inversion of Control</strong> (<strong>IoC</strong>) <span>pattern</span>. According to the IoC Framework, the Container it is responsible for object instantiation, and to resolve the dependencies among classes in the application. This module has its own life cycle of construction and destruction for the object defined under its scope.</p>
<p>In the following diagram, we have used the dependency injection pattern to resolve the dependencies of the <kbd>TransferServiceImpl</kbd> class:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="241" width="523" src="assets/ea8d76c4-43fb-4780-8434-8d772021c8e5.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Using dependency injection design pattern to resolve dependencies for TransferService.</div>
<p>In the following example, we have used an interface to resolve the dependencies:</p>
<p>Following is the <kbd>TransferServiceImpl.java</kbd> file:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.service; 
    public class TransferServiceImpl implements TransferService { 
      AccountRepository accountRepository; 
      TransferRepository transferRepository; 
      public TransferServiceImpl(AccountRepository accountRepository, <br/>      TransferRepository transferRepository) { 
        this.accountRepository = accountRepository; 
        this.transferRepository = transferRepository; 
     } 
     @Override 
     public void transferAmmount(Long a, Long b, Amount amount) { 
       Account accountA = accountRepository.findByAccountId(a); 
       Account accountB = accountRepository.findByAccountId(b); 
       transferRepository.transfer(accountA, accountB, amount); 
     } 
    } </pre>
<p>In the <kbd>TransferServiceImpl</kbd> class, we passed references of the <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> interfaces to the constructor. Now the <kbd>TransferServiceImpl</kbd> class is loosely coupled with the implementation repository class (use any flavor, either JDBC or JPA implementation of repository interfaces), and the framework is responsible for wiring the dependencies with the involved dependent class. Loose coupling offers us greater reusability, maintainability, and testability.</p>
<p>The Spring Framework implements the dependency injection pattern to resolve dependencies among the classes in a Spring application. Spring DI is based on the IoC concept, that is, the Spring Framework has a container where it creates, manages, and destructs the objects; it is known as a Spring IoC container. The objects lying within the Spring container are known as <strong>Spring beans</strong>. There are many ways to wire beans in a Spring application. Let's take a look at the three most common approaches for configuring the Spring container.</p>
<p>In the following section, we'll look at the types of the dependency injection pattern; you can configure the dependencies by using either one of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of dependency injection patterns</h1>
                </header>
            
            <article>
                
<p>The following are the types of dependency injections that could be injected into your application:</p>
<ul>
<li>Constructor-based dependency injection</li>
<li>Setter-based dependency injection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructor-based dependency injection pattern</h1>
                </header>
            
            <article>
                
<p>Dependency injection is a design pattern to resolve the dependencies of dependent classes, and dependencies are nothing but object attributes. The injector has to be constructed for the dependent objects by using one of the ways constructor injection or setter injection. A constructor injection is one of the ways of fulfilling these object attributes at the time of creation to instantiate the object. An object has a public constructor that takes dependent classes as constructor arguments to inject the dependencies. You can declare more than one constructor into the dependent class. Earlier, only the PicoContainer Framework is used a constructor-based dependency injection to resolve dependencies. Currently, the Spring Framework also supports constructor injections to resolve dependencies.</p>
<p><strong>Advantages of the constructor injection pattern</strong></p>
<p>The following are the advantages if you use a constructor injection in your Spring application:</p>
<ul>
<li>Constructor-based dependency injection is more suitable for mandatory dependencies, and it makes a strong dependency contract</li>
<li>Constructor-based dependency injection provides a more compact code structure than others</li>
<li>It supports testing by using the dependencies passed as constructor arguments to the dependent class</li>
<li>It favors the use of immutable objects, and does not break the information hiding principle</li>
</ul>
<p><strong>Disadvantages of constructor injection pattern</strong></p>
<p>The following is the only drawback of this constructor-based injection pattern:</p>
<ul>
<li>It may cause circular dependency. (Circular dependency means that the dependent and the dependency class are also dependents on each other, for example, class A depends on Class B and Class B depends on Class A)</li>
</ul>
<p><strong>Example of constructor-based dependency injection</strong> <strong>pattern</strong></p>
<p>Let's see the following example for constructor-based dependency injection. In the following code, we have a <kbd>TransferServiceImpl</kbd> class, and its constructor takes two arguments:</p>
<pre>    public class TransferServiceImpl implements TransferService { 
      AccountRepository accountRepository; 
      TransferRepository transferRepository; 
      public TransferServiceImpl(AccountRepository accountRepository,    <br/>      TransferRepository transferRepository) { 
        this.accountRepository = accountRepository; 
        this.transferRepository = transferRepository; 
      } 
      // ... <br/>    }</pre>
<p>The repositories will also be managed by the Spring container, and, as such, will have the <kbd>datasource</kbd> object for database configuration injected into them by the container, as follows:</p>
<p>Following is the <kbd>JdbcAccountRepository.java</kbd> file:</p>
<pre>    public class JdbcAccountRepository implements AccountRepository{ 
      JdbcTemplate jdbcTemplate; 
      public JdbcAccountRepository(DataSource dataSource) { 
        this.jdbcTemplate = new JdbcTemplate(dataSource); 
      } 
      // ... <br/>    }</pre>
<p>Following is the <kbd>JdbcTransferRepository.java</kbd> file:</p>
<pre>    public class JdbcTransferRepository implements TransferRepository{ 
      JdbcTemplate jdbcTemplate; 
      public JdbcTransferRepository(DataSource dataSource) { 
        this.jdbcTemplate = new JdbcTemplate(dataSource); 
      } 
       // ... <br/>    }</pre>
<p>You can see in the preceding code the JDBC implementation of the repositories as <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>. These classes also have one argument constructor to inject the dependency with the <kbd>DataSource</kbd> class.</p>
<p>Let's see another way of implementing a dependency injection in the enterprise application, which is setter injection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setter-based dependency injection</h1>
                </header>
            
            <article>
                
<p>The injector of the container has another way to wire the dependency of the dependent object. In setter injection, one of the ways to fulfil these dependencies is by providing a setter method in the dependent class. Object has a public setter methods that takes dependent classes as method arguments to inject dependencies. For setter-based dependency injection, the constructor of the dependent class is not required. There are no changes required if you change the dependencies of the dependent class. Spring Framework and PicoContainer Framework support setter injection to resolve the dependencies.</p>
<p><strong>Advantages of setter injection</strong></p>
<p>The following are the advantages if you use the setter injection pattern in your Spring application:</p>
<ul>
<li>Setter injection is more readable than the constructor injection</li>
<li>Setter injection solves the circular dependency problem in the application</li>
<li>Setter injection allows costly resources or services to be created as late as possible, and only when required</li>
<li>Setter injection does not require the constructor to be changed, but dependencies are passed through public properties that are exposed</li>
</ul>
<p><strong>Disadvantage of the setter injection</strong></p>
<p>The following are the drawbacks of the setter injection pattern:</p>
<ul>
<li>Security is lesser in the setter injection pattern, because it can be overridden</li>
<li>A setter-based dependency injection does not provide a code structure as compact as the constructor injection</li>
<li>Be careful whenever you use setter injection, because it is not a required dependency</li>
</ul>
<p><strong>Example of a setter-based dependency injection</strong></p>
<p>Let's see the following example for setter-based dependency injection. The following <kbd>TransferServiceImpl</kbd> class, has setter methods with one argument of the repository type:</p>
<p>Following is the <kbd>TransferServiceImpl.java</kbd> file:</p>
<pre>    public class TransferServiceImpl implements TransferService { 
      AccountRepository accountRepository; 
      TransferRepository transferRepository; 
    
      public void setAccountRepository(AccountRepository <br/>      accountRepository) { 
        this.accountRepository = accountRepository; 
      } 
      public void setTransferRepository(TransferRepository  <br/>      transferRepository) { 
        this.transferRepository = transferRepository; 
      } 
      // ... 
    } </pre>
<p>Similarly, let's define a setter for the repositories' implementations as follows:</p>
<p>Following is the <kbd>JdbcAccountRepository.java</kbd> file:</p>
<pre>    public class JdbcAccountRepository implements AccountRepository{ 
      JdbcTemplate jdbcTemplate; 
      public setDataSource(DataSource dataSource) { 
        this.jdbcTemplate = new JdbcTemplate(dataSource); 
    } 
     // ... 
   } </pre>
<p>Following is the <kbd>JdbcTransferRepository.java</kbd> file:</p>
<pre>    public class JdbcTransferRepository implements TransferRepository{ 
      JdbcTemplate jdbcTemplate; 
      public setDataSource(DataSource dataSource) { 
        this.jdbcTemplate = new JdbcTemplate(dataSource); 
   } 
    // ... 
  } </pre>
<p>You can see in the preceding code the JDBC implementation of the repositories as <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>. These classes have a setter method with one argument to inject the dependency with the <kbd>DataSource</kbd> class.</p>
<p><strong>Constructor versus setter injection and best practices</strong></p>
<p>The Spring Framework provides support for both types of dependency injection patterns. Both, the constructor and setter injection pattern, assemble the elements in the system. The choice between the setter and constructor injections depends on your application requirement, and the problem at hand. Let's see the following table, which lists some differences between the constructor and setter injections, and some best practices to select which one is suitable in your application.</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Constructors injection</strong></p>
</td>
<td>
<p><strong>Setter injection</strong></p>
</td>
</tr>
<tr>
<td>
<p>A class with constructor takes arguments; it is very compact sometimes, and clear to understand what it creates.</p>
</td>
<td>
<p>Here, the object is constructed, but it is not clear whether its attributes are initialized or not.</p>
</td>
</tr>
<tr>
<td>
<p>This is a better choice when the dependency is mandatory.</p>
</td>
<td>
<p>This is suitable when the dependency is not mandatory.</p>
</td>
</tr>
<tr>
<td>
<p>It allows you to hide the object attributes that are immutable, because it does not have setters for these object attributes. To ensure the immutable nature of the object, use the constructor injection pattern instead of the setter injection.</p>
</td>
<td>
<p>It doesn't ensure the immutable nature of the object.</p>
</td>
</tr>
<tr>
<td>
<p>It creates circular dependency in your application.</p>
</td>
<td>
<p>It solves the problem of circular dependency in your application. In this case, the setter injection is a better choice than constructor.</p>
</td>
</tr>
<tr>
<td>
<p>It is not suitable for scalar value dependencies in the application.</p>
</td>
<td>
<p>If you have simple parameters such as strings and integers as dependencies, the setter injection is better to use, because each setter name indicates what the value is supposed to do.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In the next section, you'll learn how to configure the injector to find the beans and wire them together, and how the injector manages the beans. Here, I will use the Spring configuration for the dependency injection pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the dependency injection pattern with Spring</h1>
                </header>
            
            <article>
                
<p>In this section, I will explain the process required to configure dependencies in an application. The mainstream injectors are Google Guice, Spring, and Weld. In this chapter, I am using the Spring Framework, so, we will see the Spring configuration here. The following diagram is a high-level view of how Spring works:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="204" width="247" class=" image-border" src="assets/a7eab42c-5110-40fe-a583-bd11022f3c74.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">How Spring works using dependency injection pattern</div>
<p>In the preceding diagram, the <strong>Configuration Instruction</strong> is the meta configuration of your application. Here, we define the dependencies in <strong>Your Application Classes (POJOs)</strong>, and initialize the Spring container to resolve the dependency by combining the POJOs and <strong>Configuration Instructions</strong>, and finally, you have a fully configured and executable system or application.</p>
<p>As you have seen in the preceding diagram, the Spring container creates the beans in your application, and assembles them for relationships between those objects via the DI pattern. The Spring container creates the beans based on the configuration that we give to the framework, so, it's your responsibility to tell Spring which beans to create, and how to wire them together.</p>
<p>Spring is very flexible in configuring the dependency of Spring beans. The following are three ways to configure the metadata of your application:</p>
<ol>
<li><strong>Dependency injection pattern with Java-based configuration</strong>—it is an explicit configuration in Java.</li>
<li><strong>Dependency injection pattern with Annotation-based configuration</strong>—it is an implicit bean discovery, and automatic wiring.</li>
<li><strong>Dependency injection pattern with XML-based configuration</strong>—it is an explicit configuration in XML.</li>
</ol>
<p>Spring provides three choices to wire beans in Spring. You must select one of the choices, but no single choice is the best match for any application. It depends on your application, and you can also mix and match these choices into a single application. Let's now discuss the dependency injection pattern with Java-based configuration in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency injection pattern with Java-based configuration</h1>
                </header>
            
            <article>
                
<p>As of Spring 3.0, it provides a Java-based Spring configuration to wire the Spring beans. Take a look at the following Java configuration class (<kbd>AppConfig.java</kbd>) to define the Spring bean and their dependencies. The Java-based configuration for dependency injection is a better choice, because it is more powerful and type-safe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Java configuration class - AppConfig.java</h1>
                </header>
            
            <article>
                
<p>Let's create an <kbd>AppConfig.java</kbd> configuration class for our example:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.config; 
    import org.springframework.context.annotation.Configuration; 
    @Configuration 
    public class AppConfig { 
         //.. 
    } </pre>
<p>The preceding <kbd>AppConfig</kbd> <span>class</span> is annotated with the <kbd>@Configuration</kbd> annotation, which indicates that it is a configuration class of the application that contains the details on bean definitions. This file will be loaded by the Spring application context to create beans for your application.</p>
<p>Let's now see how you can declare the <kbd>TransferService</kbd>, <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> beans in <kbd>AppConfig</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring Spring beans into configuration class</h1>
                </header>
            
            <article>
                
<p>To declare a bean in a Java-based configuration, you have to write a method for the desired type object creation in the configuration class, and annotate that method with <kbd>@Bean</kbd>. Let's see the following changes made in the <kbd>AppConfig</kbd> class to declare the beans:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.config; 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.Configuration; 
    @Configuration 
    public class AppConfig { 
      @Bean 
      public TransferService transferService(){ 
        return new TransferServiceImpl(); 
      } 
     @Bean 
     public AccountRepository accountRepository() { 
       return new JdbcAccountRepository(); 
     } 
     @Bean 
     public TransferRepository transferRepository() { 
       return new JdbcTransferRepository(); 
     } 
   } </pre>
<p>In the preceding configuration file, I declared three methods to create instances for <kbd>TransferService</kbd>, <kbd>AccountRepository</kbd>, and <kbd>TransferRepository</kbd>. These methods are annotated with the <kbd>@Bean</kbd> annotation to indicate that they are responsible for instantiating, configuring, and initializing a new object to be managed by the Spring IoC container. Each bean in the container has a unique bean ID; by default, a bean has an ID same as the <kbd>@Bean</kbd> annotated method name. In the preceding case, the beans will be named as <kbd>transferService</kbd>, <kbd>accountRepository</kbd>, and <kbd>transferRepository</kbd>. You can also override that default behavior by using the name attribute of the <kbd>@Bean</kbd> annotation as follows:</p>
<pre>    @Bean(name="service") 
    public TransferService transferService(){ 
     return new TransferServiceImpl(); 
    } </pre>
<p>Now <kbd>"service"</kbd> is the bean name of that bean <kbd>TransferService</kbd>.</p>
<p>Let's see how you can inject dependencies for the <kbd>TransferService</kbd>, <kbd>AccountRepository</kbd>, and <kbd>TransferRepository</kbd> beans in <kbd>AppConfig</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting Spring beans</h1>
                </header>
            
            <article>
                
<p>In the preceding code, I declared the beans <kbd>TransferService</kbd>, <kbd>AccountRepository</kbd>, and <kbd>TransferRepository</kbd>; these beans had no dependencies. But, actually, the <kbd>TransferService</kbd> bean depends on <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>. Let's see the following changes made in the <kbd>AppConfig</kbd> class to declare the beans:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.config; 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.Configuration; 
    @Configuration 
    public class AppConfig { 
      @Bean 
      public TransferService transferService(){ 
        return new TransferServiceImpl(accountRepository(), <br/>        transferRepository()); 
     } 
     @Bean 
     public AccountRepository accountRepository() { 
       return new JdbcAccountRepository(); 
     } 
     @Bean 
     public TransferRepository transferRepository() { 
       return new JdbcTransferRepository(); 
     } 
    } </pre>
<p>In the preceding example, the simplest way to wire up beans in a Java-based configuration is to refer to the referenced bean's method. The <kbd>transferService()</kbd> method constructs the instance of the <kbd>TransferServiceImpl</kbd> class by calling the arguments constructor that takes <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>. Here, it seems that the constructor of the <kbd>TransferServiceImpl</kbd> class is calling the <kbd>accountRepository()</kbd> and <kbd>transferRepository()</kbd> methods to create instances of <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> respectively, but it is not an actual call to create instances. The Spring container creates instances of <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>, because the <kbd>accountRepository()</kbd> and <kbd>transferRepository()</kbd> methods are annotated with the <kbd>@Bean</kbd> annotation. Any call to the bean method by another bean method will be intercepted by Spring to ensure the default singleton scope (this will be discussed further in <a href="d0375506-d940-4fe5-bc09-d1033eed2986.xhtml" target="_blank">Chapter 5</a>, <em>Understanding the Bean Life cycle and Used Patterns</em>) of the Spring beans by that method is returned rather than allowing it to be invoked again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best approach to configure the dependency injection pattern with Java</h1>
                </header>
            
            <article>
                
<p>In the previous configuration example, I declared the <kbd>transferService()</kbd> bean method to construct an instance of the <kbd>TransferServiceImpl</kbd> class by using its arguments constructor. The bean methods, <kbd>accountRepository()</kbd> and <kbd>transferRepository()</kbd>, are passed as arguments of the constructor. But in an enterprise application, a lot of configuration files depend on the layers of the application architecture. Suppose the service layer and t<span>he infrastructure layer</span> have their own configuration files. That means that the <kbd>accountRepository()</kbd> and <kbd>transferRepository()</kbd> methods may be in different configuration files, and the <kbd>transferService()</kbd> bean method may be in another configuration file. Passing bean methods into the constructor is not a good practice for configuration of the dependency injection pattern with Java. Let's see a different and the best approach to configuring the dependency injection:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.config; 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.Configuration; 
    @Configuration 
    public class AppConfig { 
      @Bean 
      public TransferService transferService(AccountRepository <br/>      accountRepository, TransferRepository transferRepository){ 
        return new TransferServiceImpl(accountRepository, <br/>        transferRepository); 
     } 
     @Bean 
     public AccountRepository accountRepository() { 
       return new JdbcAccountRepository(); 
     } 
     @Bean 
     public TransferRepository transferRepository() { 
       return new JdbcTransferRepository(); 
     } 
    } </pre>
<p>In the preceding code, the <kbd>transferService()</kbd> method asks for <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> as parameters. When Spring calls <kbd>transferService()</kbd> to create the <kbd>TransferService</kbd> bean, it autowires <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> into the configuration method. With this approach, the <kbd>transferService()</kbd> method can still inject <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> into the constructor of <kbd>TransferServiceImpl</kbd> without explicitly referring to the <kbd>accountRepository()</kbd> and <kbd>transferRepository()</kbd><kbd>@Bean</kbd> methods.</p>
<p>Let's now take a look at dependency injection pattern with XML-based configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency injection pattern with XML-based configuration</h1>
                </header>
            
            <article>
                
<p>Spring provides dependency injection with XML-based configuration from the very beginning. It is the primary way of configuring a Spring application. According to me, every developer should have an understanding of how to use XML with a Spring application. In this section, I am going to explain the same example as discussed in the previous section of Java-based configuration with reference to XML-based configuration.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an XML configuration file</h1>
                </header>
            
            <article>
                
<p>In the section on Java-based configuration, we had created an <kbd>AppConfig</kbd> class annotated with the <kbd>@Configuration</kbd> annotation. Similarly, for XML-based configuration, we will now create an <kbd>applicationContext.xml</kbd> file rooted with a <kbd>&lt;beans&gt;</kbd> element. The following simplest possible example shows the basic structure of XML-based configuration metadata:</p>
<p>Following is the <kbd>applicationContext.xml</kbd> file:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
      
     xsi:schemaLocation="http://www.springframework.org/schema/beans   <br/>     http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 
    
     &lt;!-- Configuration for bean definitions go here --&gt; 
    
    &lt;/beans&gt; </pre>
<p>The preceding XML file is a configuration file of the application which contains the details on bean definitions. This file is also loaded by the XML-flavored implementation of <kbd>ApplicationContext</kbd> to create beans for your application. Let's see how you can declare the <kbd>TransferService</kbd>, <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd> beans in the preceding XML file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring Spring beans in an XML file</h1>
                </header>
            
            <article>
                
<p>As with Java, we have to declare a class as a Spring bean into Spring's XML-based configuration by using an element of the Spring-beans schema as a <kbd>&lt;bean&gt;</kbd> element. The <kbd>&lt;bean&gt;</kbd> element is the XML analogue to JavaConfig's <kbd>@Bean</kbd> annotation. We add the following configuration to the XML-based configuration file:</p>
<pre>    &lt;bean id="transferService"    <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.service.TransferServiceImpl"/&gt; 
    &lt;bean id="accountRepository"   <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcAccountRepository"/&gt; 
    &lt;bean id="transferService"   <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcTransferRepository"/&gt; </pre>
<p>In the preceding code, I have created a very simple bean definition. In this configuration, the <kbd>&lt;bean&gt;</kbd> element has an <kbd>id</kbd> attribute to identify the individual bean definition. The <kbd>class</kbd> attribute is expressed as the fully qualified class name to create this bean. The value of the <kbd>id</kbd> attribute refers to collaborating objects. So let's see how to configure the collaborating beans to resolve the dependencies in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting Spring beans</h1>
                </header>
            
            <article>
                
<p>Spring provides these two ways to define the DI pattern to inject the dependency with the dependent bean in an application:</p>
<ul>
<li>Using constructor injection</li>
<li>Using setter injection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using constructor injection</h1>
                </header>
            
            <article>
                
<p>For the DI pattern with the construction injection, Spring provides you two basic options as the <kbd>&lt;constructor-arg&gt;</kbd> element and c-namespace introduced in Spring 3.0. c-namespace has less verbosity in the application, which is the only difference between them--you can choose any one. Let's inject the collaborating beans with the construction injection as follows:</p>
<pre>    &lt;bean id="transferService"   <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.service.TransferServiceImpl"&gt; 
     &lt;constructor-arg ref="accountRepository"/&gt; 
     &lt;constructor-arg ref="transferRepository"/&gt; 
    &lt;/bean&gt; <br/>    &lt;bean id="accountRepository"    <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcAccountRepository"/&gt; <br/>    &lt;bean id="transferRepository"       <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcTransferRepository"/&gt; </pre>
<p>In the preceding configuration, the <kbd>&lt;bean&gt;</kbd> element of <kbd>TransferService</kbd> has two <kbd>&lt;constructor-arg&gt;.</kbd> This tells it to pass a reference to the beans whose IDs are <kbd>accountRepository</kbd> and <kbd>transferRepository</kbd> to the constructor of <kbd>TransferServiceImpl</kbd>.</p>
<p>As of Spring 3.0, the c-namespace, <span>similarly,</span> has a more succinct way of expressing constructor args in XML. For using this namespace, we have to add its schema in the XML file, as follows:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
      
      
     xsi:schemaLocation="http://www.springframework.org/schema/beans<br/>     http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 
    
    &lt;bean id="transferService"    <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.service.TransferServiceImpl"  
     c:accountRepository-ref="accountRepository" c:transferRepository-<br/>     ref="transferRepository"/&gt; <br/>    &lt;bean id="accountRepository"    <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcAccountRepository"/&gt; <br/>    &lt;bean id="transferRepository"    <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcTransferRepository"/&gt; 
    
     &lt;!-- more bean definitions go here --&gt; 
    
    &lt;/beans&gt; </pre>
<p>Let's see how to set up these dependencies with the setter injection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using setter injection</h1>
                </header>
            
            <article>
                
<p>Using the injection, Spring also provides you with two basic options as the <kbd>&lt;property&gt;</kbd> element and p-namespace introduced in Spring 3.0. The p-namespace also reduced verbosity of code in the application, which is the only difference between them, you can choose any one. Let's inject the collaborating beans with the setter injection as follows:</p>
<pre>    &lt;bean id="transferService"       <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.service.TransferServiceImpl"&gt; 
     &lt;property name="accountRepository"  ref="accountRepository"/&gt; 
     &lt;property name="transferRepository" ref="transferRepository"/&gt; 
    &lt;/bean&gt; <br/>    &lt;bean id="accountRepository"      <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcAccountRepository"/&gt; <br/>    &lt;bean id="transferRepository"   <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcTransferRepository"/&gt; </pre>
<p>In the preceding configuration, the <kbd>&lt;bean&gt;</kbd> element of <kbd>TransferService</kbd> has two <kbd>&lt;property&gt;</kbd> elements which tell it to pass a reference to the beans whose IDs are <kbd>accountRepository</kbd> and <kbd>transferRepository</kbd> to the setter methods of <kbd>TransferServiceImpl</kbd>, as follows:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.service; 
 
    import com.packt.patterninspring.chapter4.bankapp.model.Account; 
    import com.packt.patterninspring.chapter4.bankapp.model.Amount; 
    import com.packt.patterninspring.chapter4.bankapp.<br/>     repository.AccountRepository; 
    import com.packt.patterninspring.chapter4.bankapp.<br/>     repository.TransferRepository; 
 
    public class TransferServiceImpl implements TransferService { 
      AccountRepository accountRepository; 
      TransferRepository transferRepository; 
    
      public void setAccountRepository(AccountRepository   <br/>      accountRepository) { 
        this.accountRepository = accountRepository; 
      } 
      public void setTransferRepository(TransferRepository <br/>      transferRepository) { 
         this.transferRepository = transferRepository; 
      } 
      @Override 
      public void transferAmmount(Long a, Long b, Amount amount) { 
        Account accountA = accountRepository.findByAccountId(a); 
        Account accountB = accountRepository.findByAccountId(b); 
        transferRepository.transfer(accountA, accountB, amount); 
      } 
    } </pre>
<p>In the preceding file, if you use this Spring bean without setter methods, the properties <kbd>accountRepository</kbd> and <kbd>transferRepository</kbd> will be initialized as null without injecting the dependency.</p>
<p>As of Spring 3.0, the p-namespace, <span>similarly,</span> has a more succinct way of expressing property in XML. For using this namespace, we have to add its schema in the XML file as follows:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
       
       
      xsi:schemaLocation="http://www.springframework.org/schema/beans <br/>      http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 
    
    &lt;bean id="transferService"    <br/>     class="com.packt.patterninspring.chapter4.bankapp.<br/>     service.TransferServiceImpl"  
     p:accountRepository-ref="accountRepository" p:transferRepository-<br/>     ref="transferRepository"/&gt; <br/>    &lt;bean id="accountRepository"   <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcAccountRepository"/&gt; <br/>    &lt;bean id="transferRepository"   <br/>     class="com.packt.patterninspring.chapter4.<br/>     bankapp.repository.jdbc.JdbcTransferRepository"/&gt; 
    
    &lt;!-- more bean definitions go here --&gt; 
    
    &lt;/beans&gt; </pre>
<p>Let's now take a look at the dependency injection pattern with Annotation-based configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency injection pattern with Annotation-based configuration</h1>
                </header>
            
            <article>
                
<p>As discussed in the previous two sections, we defined the DI pattern with Java-and XML-based configurations, and these two options define dependencies explicitly. It creates the Spring beans by using either the <kbd>@Bean</kbd> annotated method in the <kbd>AppConfig</kbd> Java file, or the <kbd>&lt;bean&gt;</kbd> element tag in the XML configuration file. By these methods, you can also create the bean for those classes which lie outside the application, that is, classes that exist in third-party libraries. Now let's discuss another way to create Spring beans, and define the dependencies between them by using implicit configuration through the Stereotype annotations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are Stereotype annotations?</h1>
                </header>
            
            <article>
                
<p>The Spring Framework provides you with some special annotations. These annotations are used to create Spring beans automatically in the application context. The main stereotype annotation is <kbd>@Component</kbd>. By using this annotation, Spring provides more Stereotype meta annotations such as <kbd>@Service</kbd>, used to create Spring beans at the Service layer, <kbd>@Repository</kbd>, which is used to create Spring beans for the repositories at the DAO layer, and <kbd>@Controller</kbd>, which is used to create Spring beans at the controller layer. This is depicted in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="149" width="394" class=" image-border" src="assets/6fd97786-73e6-4b3d-841d-8954bd1658b4.png"/></div>
<p>By using these annotations, Spring creates automatic wiring in these two ways:</p>
<ul>
<li><strong>Component scanning:</strong> In this, Spring automatically searches the beans to be created in the Spring IoC container</li>
<li><strong>Autowiring:</strong> In this, Spring automatically searches the bean dependencies in the Spring IoC container</li>
</ul>
<p>Implicitly, the DI pattern configuration reduces the verbosity of an application, and minimizes explicit configuration. Let's demonstrate component scanning and autowiring in the same example as discussed previously. Here, Spring will create the beans for <kbd>TransferService</kbd>, <kbd>TransferRepository</kbd>, and <kbd>AccountRepository</kbd> by discovering them, and automatically inject them to each other as per the defined dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating auto searchable beans using Stereotype annotations</h1>
                </header>
            
            <article>
                
<p>Let's see the following <kbd>TransferService</kbd> interface. Its implementation is annotated with <kbd>@Component</kbd>. Please refer to the following code:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.service; 
    public interface TransferService { 
      void transferAmmount(Long a, Long b, Amount amount); 
    } </pre>
<p>The preceding interface is not important for this approach of configuration--I have taken it just for loose coupling in the application. Let's see its implementation, which is as follows:</p>
<pre>    package com.packt.patterninspring.chapter1.bankapp.service; 
    import org.springframework.stereotype.Component; 
    @Component 
    public class TransferServiceImpl implements TransferService { 
      @Override 
      public void transferAmmount(Long a, Long b, Amount amount) { 
         //business code here 
      } 
   } </pre>
<p>You can see in the preceding code that <kbd>TransferServiceImpl</kbd> is annotated with the <kbd>@Component</kbd> annotation. This annotation is used to identify this class as a component class, which means, it is eligible to scan and create a bean of this class. Now there is no need to configure this class explicitly as a bean either by using XML or Java configuration--Spring is now responsible for creating the bean of the <kbd>TransferServiceImpl</kbd> class, because it is annotated with <kbd>@Component</kbd>.</p>
<p>As mentioned earlier, Spring provides us meta annotations for the <kbd>@Component</kbd> annotation as <kbd>@Service</kbd>, <kbd>@Repository</kbd>, and <kbd>@Controller</kbd>. These annotations are based on a specific responsibility at different layers of the application. Here, <kbd>TransferService</kbd> is the service layer class; <em>as a best practice of Spring configuration</em>, we have to annotate this class with the specific annotation, <kbd>@Service</kbd>, rather than with the generic annotation, <kbd>@Component</kbd>, to create the bean of this class. The following is the code for the same class annotated with the <kbd>@Service</kbd> annotation:</p>
<pre>    package com.packt.patterninspring.chapter1.bankapp.service; 
    import org.springframework.stereotype.Service; 
    @Service 
    public class TransferServiceImpl implements TransferService { 
      @Override 
      public void transferAmmount(Long a, Long b, Amount amount) { 
         //business code here 
      } 
    } </pre>
<p>Let's see other classes in the application--these are the <kbd>implementation</kbd> classes of <kbd>AccountRepository</kbd>--and the <kbd>TransferRepository</kbd> interfaces are the repositories working at the DAO layer of the application. <em>As a best practice</em><em>,</em> these classes should be annotated with the <kbd>@Repository</kbd> annotation rather than using the <kbd>@Component</kbd> annotation as shown next.</p>
<p><kbd>JdbcAccountRepository.java</kbd> implements the <kbd>AccountRepository</kbd> interface:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.repository.jdbc; 
    import org.springframework.stereotype.Repository; 
    import com.packt.patterninspring.chapter4.bankapp.model.Account; 
    import com.packt.patterninspring.chapter4.bankapp.model.Amount; 
    import com.packt.patterninspring.chapter4.bankapp.repository.<br/>      AccountRepository; 
    @Repository 
    public class JdbcAccountRepository implements AccountRepository { 
      @Override 
      public Account findByAccountId(Long accountId) { 
        return new Account(accountId, "Arnav Rajput", new   <br/>        Amount(3000.0)); 
      } 
    } </pre>
<p>And <kbd>JdbcTransferRepository.java</kbd> implements the <kbd>TransferRepository</kbd> interface:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.repository.jdbc; 
    import org.springframework.stereotype.Repository; 
    import com.packt.patterninspring.chapter4.bankapp.model.Account; 
    import com.packt.patterninspring.chapter4.bankapp.model.Amount; 
    import com.packt.patterninspring.chapter4.bankapp.<br/>      repository.TransferRepository; 
    @Repository 
    public class JdbcTransferRepository implements TransferRepository { 
      @Override 
      public void transfer(Account accountA, Account accountB, Amount <br/>      amount) { 
        System.out.println("Transfering amount from account A to B via <br/>        JDBC implementation"); 
      } 
    } </pre>
<p>In Spring, you have to enable component scanning in your application, because it is not enabled by default. You have to create a configuration Java file, and annotate it with <kbd>@Configuration</kbd> and <kbd>@ComponentScan</kbd>. This class is used to search out classes annotated with <kbd>@Component</kbd>, and to create beans from them.</p>
<p>Let's see how Spring scans the classes which are annotated with any stereotype annotations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Searching beans using component scanning</h1>
                </header>
            
            <article>
                
<p>The following minimum configuration is required to search beans using component scanning in a Spring application:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.config; 
 
    import org.springframework.context.annotation.ComponentScan; 
    import org.springframework.context.annotation.Configuration; 
 
    @Configuration 
    @ComponentScan 
    public class AppConfig { 
    
    } </pre>
<p>The <kbd>AppConfig</kbd> class defines a Spring wiring configuration class same as the Java-based Spring configuration in the previous section. There is one thing to be observed here--the <kbd>AppConfig</kbd> file has one more <kbd>@ComponentScan</kbd>, as earlier it had only the <kbd>@Configuration</kbd> annotation. The configuration file <kbd>AppConfig</kbd> is annotated with <kbd>@ComponentScan</kbd> to enable component scanning in Spring. The <kbd>@ComponentScan</kbd> annotation scans those classes that are annotated with <kbd>@Component</kbd> by default in the same package as the configuration class. Since the <kbd>AppConfig</kbd> class is in the <kbd>com.packt.patterninspring.chapter4.bankapp.config</kbd> package, Spring will scan only this package and its sub packages. But our component application classes are in the <kbd>com.packt.patterninspring.chapter1.bankapp.service</kbd> and <kbd>com.packt.patterninspring.chapter4.bankapp.repository.jdbc</kbd> packages, and these are not subpackages of <kbd>com.packt.patterninspring.chapter4.bankapp.config</kbd>. In this case, Spring allows to override the default package scanning of the <kbd>@ComponentScan</kbd> annotation by setting a base package for component scanning. Let's specify a different base package. You only need to specify the package in the <kbd>value</kbd> attribute of <kbd>@ComponentScan</kbd>, as shown here:</p>
<pre>    @Configuration 
    @ComponentScan("com.packt.patterninspring.chapter4.bankapp") 
    public class AppConfig { 
    
    } </pre>
<p>Or you can define the base packages with the <kbd>basePackages</kbd> attribute, as follows:</p>
<pre>    @Configuration 
    @ComponentScan(basePackages="com.packt.patterninspring.<br/>    chapter4.bankapp") 
    public class AppConfig { 
    
    } </pre>
<p>In the <kbd>@ComponentScan</kbd> annotation, the <kbd>basePackages</kbd> attribute can accept an array of Strings, which means that we can define multiple base packages to scan component classes in the application. In the previous configuration file, Spring will scan all classes of <kbd>com.packt.patterninspring.chapter4.bankapp package</kbd>, and all the subpackages underneath this package. <em>As a best practice,</em> always define the specific base packages where the components classes exist. For example, in the following code, I define the base packages for the service and repository components:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.config; 
    import org.springframework.context.annotation.ComponentScan; 
    import org.springframework.context.annotation.Configuration; 
    @Configuration 
    @ComponentScan(basePackages=       <br/>    {"com.packt.patterninspring.chapter4.<br/>    bankapp.repository.jdbc","com.packt.patterninspring.<br/>    chapter4.bankapp.service"}) 
    public class AppConfig { 
    
    } </pre>
<p>Now Spring scans only <kbd>com.packt.patterninspring.chapter4.bankapp.repository.jdbc</kbd> and <kbd>com.packt.patterninspring.chapter4.bankapp.service packages</kbd>, and its subpackages if they exist. instead of doing a wide range scanning like in the earlier examples.</p>
<p>Rather than specify the packages as simple String values of the <kbd>basePackages</kbd> attribute of <kbd>@ComponentScan</kbd>, Spring allows you to specify them via classes or interfaces as follows:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.config; 
    import org.springframework.context.annotation.ComponentScan; 
    import org.springframework.context.annotation.Configuration; 
    import com.packt.patterninspring.chapter4.bankapp.<br/>     repository.AccountRepository; 
    import com.packt.patterninspring.chapter4.<br/>     bankapp.service.TransferService; 
    @Configuration 
    @ComponentScan(basePackageClasses=   <br/>    {TransferService.class,AccountRepository.class}) 
    public class AppConfig { 
 
    } </pre>
<p>As you can see in the preceding code, the <kbd>basePackages</kbd> attribute has been replaced with <kbd>basePackageClasses</kbd>. Now Spring will identify the component classes in those packages where <kbd>basePackageClasses</kbd> will be used as the base package for component scanning.</p>
<p>It should find the <kbd>TransferServiceImpl</kbd>, <kbd>JdbcAccountRepository</kbd>, and <kbd>JdbcTransferRepository</kbd> classes, and automatically create the beans for these classes in the Spring container. Explicitly, there is no need to define the bean methods for these classes to create Spring beans. Let's turn on component scanning via XML configuration, then you can use the <kbd>&lt;context:component-scan&gt;</kbd> element from Spring's context namespace. Here is a minimal XML configuration to enable component scanning:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
     
     
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd 
    http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context.xsd"&gt; 
    &lt;context:component-scan base-    <br/>    package="com.packt.patterninspring.chapter4.bankapp" /&gt; 
    &lt;/beans&gt; </pre>
<p>In the preceding XML file, the <kbd>&lt;context:component-scan&gt;</kbd> element is same the <kbd>@ComponentScan</kbd> annotation in the Java-based configuration for component scanning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Annotating beans for autowiring</h1>
                </header>
            
            <article>
                
<p>Spring provides support for automatic bean wiring. This means that Spring automatically resolves the dependencies <span>that are required by the dependent bean</span> by finding other collaborating beans in the application context. Bean Autowiring is another way of DI pattern configuration. It reduces verbosity in the application, but the configuration is spread throughout the application. Spring's <kbd>@Autowired</kbd> annotation is used for auto bean wiring. This <kbd>@Autowired</kbd> annotation indicates that autowiring should be performed for this bean.</p>
<p>In our example, we have <kbd>TransferService</kbd> which has dependencies of <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>. Its constructor is annotated with <kbd>@Autowired</kbd> indicating that when Spring creates the <kbd>TransferService</kbd> bean, it should instantiate that bean by using its annotated constructor, and pass in two other beans, <kbd>AccountRepository</kbd> and <kbd>TransferRepository</kbd>, which are dependencies of the <kbd>TransferService</kbd> bean. Let's see the following code:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.service; 
    import org.springframework.beans.factory.annotation.Autowired; 
    import org.springframework.stereotype.Service; 
    import com.packt.patterninspring.chapter4.bankapp.model.Account; 
    import com.packt.patterninspring.chapter4.bankapp.model.Amount; 
    import com.packt.patterninspring.chapter4.bankapp.<br/>     repository.AccountRepository; 
    importcom.packt.patterninspring.chapter4.<br/>     bankapp.repository.TransferRepository; 
    @Service 
    public class TransferServiceImpl implements TransferService { 
      AccountRepository accountRepository; 
      TransferRepository transferRepository; 
    @Autowired 
    public TransferServiceImpl(AccountRepository accountRepository, <br/>    TransferRepository transferRepository) { 
      super(); 
      this.accountRepository = accountRepository; 
      this.transferRepository = transferRepository; 
    } 
    @Override 
    public void transferAmmount(Long a, Long b, Amount amount) { 
      Account accountA = accountRepository.findByAccountId(a); 
      Account accountB = accountRepository.findByAccountId(b); 
      transferRepository.transfer(accountA, accountB, amount); 
    } 
   } </pre>
<div class="packt_infobox">Note--As of Spring 4.3, the <kbd>@Autowired</kbd> annotation is no more required if you define only one construct with arguments in that class. If class has multiple argument constructors, then you have to use the <kbd>@Autowired</kbd> annotation on any one of them.</div>
<p>The <kbd>@Autowired</kbd> annotation is not limited to the construction; it can be used with the setter method, and can also be used directly in the field, that is, an <kbd>autowired</kbd> class property directly. Let's see the following line of code for setter and field injection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using @Autowired with setter method</h1>
                </header>
            
            <article>
                
<p>Here you can annotate the setter method's <kbd>setAccountRepository</kbd> and <kbd>setTransferRepository</kbd> with the <kbd>@Autowired</kbd> annotation. This annotation can be used with any method. There is no specific reason to use it with the setter method only. Please refer to the following code:</p>
<pre>    public class TransferServiceImpl implements TransferService { 
      //... 
      @Autowired 
      public void setAccountRepository(AccountRepository  <br/>      accountRepository) { 
        this.accountRepository = accountRepository; 
      } 
      @Autowired 
      public void setTransferRepository(TransferRepository <br/>      transferRepository) { 
        this.transferRepository = transferRepository; 
      } 
      //... 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using @Autowired with the fields</h1>
                </header>
            
            <article>
                
<p>Here you can annotate those class properties which are required for this class to achieve a business goal. Let's see the following code:</p>
<pre>    public class TransferServiceImpl implements TransferService { 
      @Autowired 
      AccountRepository accountRepository; 
      @Autowired 
      TransferRepository transferRepository; 
      //... 
    } </pre>
<p>In the preceding code, the <kbd>@Autowired</kbd> annotation resolves the dependency by <kbd>type</kbd> and then by <kbd>name</kbd> if the property name is the same as the bean name in the Spring container. By default, the <kbd>@Autowired</kbd> dependency is a required dependency--it raises an exception if the dependency is not resolved, it doesn't matter whether we have used it with a constructor or with the setter method. You can override the required behavior of the <kbd>@Autowired</kbd> annotation by using the <kbd>required</kbd> attribute of this annotation. You can set this attribute with the Boolean value <kbd>false</kbd> as follows:</p>
<pre>    @Autowired(required = false) 
    public void setAccountRepository(AccountRepository<br/>    accountRepository) { 
      this.accountRepository = accountRepository; 
    }  </pre>
<p>In the preceding code, we have set the required attribute with the Boolean value <kbd>false</kbd>. In this case, Spring will attempt to perform autowiring, but if there are no matching beans, it will leave the bean unwired. But as a best practice of code, you should avoid setting its value as false until it is absolutely necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Autowiring DI pattern and disambiguation</h1>
                </header>
            
            <article>
                
<p>The <kbd>@Autowiring</kbd> annotation reduces verbosity in the code, but it may create some problems when two of the same type of beans exist in the container. Let's see what happens in that situation, with the following example:</p>
<pre>    @Service 
    public class TransferServiceImpl implements TransferService { 
    @Autowired 
    public TransferServiceImpl(AccountRepository accountRepository) { <br/>    ... } 
    } </pre>
<p>The preceding snippet of code shows that the <kbd>TransferServiceImpl</kbd> class has a dependency with a bean of type <kbd>AccountRepository</kbd>, but the Spring container contains two beans of the same type, that is, the following:</p>
<pre>    @Repository 
    public class JdbcAccountRepository implements AccountRepository <br/>    {..} 
   @Repository 
   public class JpaAccountRepository implements AccountRepository {..} </pre>
<p>As seen from the preceding code, there are two implementations of the <kbd>AccountRepository</kbd> interface--one is <kbd>JdbcAccountRepository</kbd> and another is <kbd>JpaAccountRepository</kbd>. In this case, the Spring container will throw the following exception at startup time of the application:</p>
<pre>    At startup: NoSuchBeanDefinitionException, no unique bean of type 
    [AccountRepository] is defined: expected single bean but found 2... </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resolving disambiguation in Autowiring DI pattern</h1>
                </header>
            
            <article>
                
<p>Spring provides one more annotation, <kbd>@Qualifier</kbd>, to overcome the problem of disambiguation in autowiring DI. Let's see the following snippet of code with the <kbd>@Qualifier</kbd> annotation:</p>
<pre>    @Service 
    public class TransferServiceImpl implements TransferService { 
    @Autowired 
    public TransferServiceImpl( @Qualifier("jdbcAccountRepository")<br/>    AccountRepository accountRepository) { ... } </pre>
<p>Now I have wired the dependency by name rather than by type by using the <kbd>@Qualifier</kbd> annotation. So, Spring will search the bean dependency with the name <kbd>"jdbcAccountRepository"</kbd> for the <kbd>TransferServiceImpl</kbd> class. I have given the names of the beans as follows:</p>
<pre>    @Repository("jdbcAccountRepository") 
    public class JdbcAccountRepository implements AccountRepository <br/>    {..} 
    @Repository("jpaAccountRepository") 
    public class JpaAccountRepository implements AccountRepository {..} </pre>
<p><kbd>@Qualifier</kbd>, also available with the method injection and field injection component names, should not show implementation details unless there are two implementations of the same interface.</p>
<p>Let's now discuss some best practices to choose the DI pattern configuration for your Spring application.</p>
<p><strong>Resolving dependency with Abstract Factory pattern</strong></p>
<p>If you want to add the <kbd>if...else</kbd> conditional configuration for a bean, you can do so, and also add some custom logic if you are using Java configuration. But in the case of an XML configuration, it is not possible to add the <kbd>if...then...else</kbd> conditions. Spring provides the solution for conditions in an XML configuration by using the Abstract Factory Pattern. Use a factory to create the bean(s) you want, and use any complex Java code that you need in the factory's internal logic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Abstract Factory Pattern in Spring (FactoryBean interface)</h1>
                </header>
            
            <article>
                
<p>The Spring Framework provides the <kbd>FactoryBean</kbd> interface as an implementation of the Abstract Factory Pattern. A <kbd>FactoryBean</kbd> is a pattern to encapsulate interesting object construction logic in a class. The <kbd>FactoryBean</kbd> interface provides a way to customize the Spring IoC container's instantiation logic. You can implement this interface for objects that are themselves factories. Beans implementing <kbd>FactoryBean</kbd> are auto-detected.</p>
<p>The definition of this interface is as follows:</p>
<pre>    public interface FactoryBean&lt;T&gt; { 
     T getObject() throws Exception; 
     Class&lt;T&gt; getObjectType(); 
     boolean isSingleton(); 
   } </pre>
<p>As per the preceding definition of this interface, the dependency injection using the FactoryBean and it causes <kbd>getObject()</kbd> to be invoked transparently. The <kbd>isSingleton()</kbd> method returns <kbd>true</kbd> for singleton, else it returns <kbd>false</kbd>. The <kbd>getObjectType()</kbd> method returns the object type of the object returned by the <kbd>getObject()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation of FactoryBean interface in Spring</h1>
                </header>
            
            <article>
                
<p><kbd>FactoryBean</kbd> is widely used within Spring as the following:</p>
<ul>
<li><kbd>EmbeddedDatabaseFactoryBean</kbd></li>
<li><kbd>JndiObjectFactoryBean</kbd></li>
<li><kbd>LocalContainerEntityManagerFactoryBean</kbd></li>
<li><kbd>DateTimeFormatterFactoryBean</kbd></li>
<li><kbd>ProxyFactoryBean</kbd></li>
<li><kbd>TransactionProxyFactoryBean</kbd></li>
<li><kbd>MethodInvokingFactoryBean</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sample implementation of FactoryBean interface</h1>
                </header>
            
            <article>
                
<p>Suppose you have a <kbd>TransferService</kbd> class whose definition is thus:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.service; 
    import com.packt.patterninspring.chapter4.<br/>     bankapp.repository.IAccountRepository; 
    public class TransferService { 
      IAccountRepository accountRepository; 
      public TransferService(IAccountRepository accountRepository){ 
        this.accountRepository = accountRepository; 
      } 
      public void transfer(String accountA, String accountB, Double <br/>      amount){ 
        System.out.println("Amount has been tranferred"); 
      } 
    } </pre>
<p>And you have a <kbd>FactoryBean</kbd> whose definition is thus:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.repository; 
    import org.springframework.beans.factory.FactoryBean; 
    public class AccountRepositoryFactoryBean implements <br/>    FactoryBean&lt;IAccountRepository&gt; { 
      @Override 
      public IAccountRepository getObject() throws Exception { 
        return new AccountRepository(); 
      } 
      @Override 
      public Class&lt;?&gt; getObjectType() { 
        return IAccountRepository.class; 
      } 
      @Override 
      public boolean isSingleton() { 
        return false; 
      } 
    }  </pre>
<p>You could wire up an <kbd>AccountRepository</kbd> instance using a hypothetical <kbd>AccountRepositoryFactoryBean</kbd> like this:</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
     
     
    xsi:schemaLocation="http://www.springframework.org/schema/beans <br/>    http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; 
    
    &lt;bean id="transferService" class="com.packt.patterninspring.<br/>     chapter4.bankapp.service.TransferService"&gt; 
     &lt;constructor-arg ref="accountRepository"/&gt; 
    &lt;/bean&gt; 
    &lt;bean id="accountRepository"    <br/>     class="com.packt.patterninspring.chapter4.<br/>      bankapp.repository.AccountRepositoryFactoryBean"/&gt; 
    &lt;/beans&gt; </pre>
<p>In the preceding example, the <kbd>TransferService</kbd> class depends on the <kbd>AccountRepository</kbd> bean, but in the XML file, we have defined <kbd>AccountRepositoryFactoryBean</kbd> as an <kbd>accountRepository</kbd> bean. The <kbd>AccountRepositoryFactoryBean</kbd> class implements the <kbd>FactoryBean</kbd> interface of Spring. The result of the <kbd>getObject</kbd> method of <kbd>FactoryBean</kbd> will be passed, and not the actual <kbd>FactoryBean</kbd> itself. Spring injects that object returned by <kbd>FactoryBean</kbd>'s <kbd>getObjectType()</kbd> method, and the object type returned by <kbd>FactoryBean</kbd>'s <kbd>getObjectType()</kbd>; the scope of this bean is decided by the <kbd>FactoryBean</kbd>'s <kbd>isSingleton()</kbd> method.</p>
<p>The following is the same configuration for the <kbd>FactoryBean</kbd> interface in a Java Configuration:</p>
<pre>    package com.packt.patterninspring.chapter4.bankapp.config; 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.Configuration; 
    import com.packt.patterninspring.chapter4.bankapp.<br/>     repository.AccountRepositoryFactoryBean; 
    import com.packt.patterninspring.chapter4.<br/>     bankapp.service.TransferService; 
    @Configuration 
    public class AppConfig { 
      public TransferService transferService() throws Exception{ 
        return new TransferService(accountRepository().getObject()); 
      } 
    @Bean 
    public AccountRepositoryFactoryBean accountRepository(){ 
      return new AccountRepositoryFactoryBean(); 
    } 
    } </pre>
<p>As other normal beans in the Spring container, the Spring <kbd>FactoryBean</kbd> also has all the other characteristics of any other Spring bean, including the life cycle hooks and services that all beans in the Spring container enjoy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best practices for configuring the DI pattern</h1>
                </header>
            
            <article>
                
<p>The following are the best practices for configuring the DI pattern:</p>
<ul>
<li>Configuration files should be separated categorically. Application beans should be separate from infrastructure beans. Currently, it's a bit difficult to follow.</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="238" width="400" class=" image-border" src="assets/0eb74c9e-0a6f-4709-8d4b-76723d2651c5.png"/></div>
<ul>
<li>Always specify the component name; never rely on generated names by the container.</li>
<li>It is a best practice to give a name along with a description of what the pattern does, where to apply it, and the problems it addresses.</li>
<li>The best practices for component scanning are as follows:
<ul>
<li>The components are scanned at startup, and it scans the JAR dependencies as well.</li>
<li><strong>Bad practice:</strong> It scans all the packages of <kbd>com</kbd> and <kbd>org</kbd>. It increases the startup time of the application. Avoid such type of component scanning:</li>
</ul>
</li>
</ul>
<pre>                @ComponenttScan (( {{ "org", "com" }} ))</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Optimized:</strong> It scans only the specific packages as defined by us.</li>
</ul>
</li>
</ul>
<pre>                 @ComponentScan ( {  <br/>                  "com.packt.patterninspring.chapter4.<br/>                  bankapp.repository", 
                 "com.packt.patterninspring.chapter4.bankapp.service"} <br/>                  ) </pre>
<ul>
<li>Best practices in choosing implicit configuration:
<ul>
<li>Choose annotation-based configurations for frequently changing beans</li>
<li>It allows for very rapid development</li>
<li>It is a single place to edit the configuration</li>
</ul>
</li>
<li>Best practices in choosing explicit via Java configuration:
<ul>
<li>It is centralized in one place</li>
<li>Strong type checking enforced by the compiler</li>
<li>Can be used for all classes</li>
</ul>
</li>
<li>Spring XML Best Practices: XML has been around for a long time, there are many shortcuts and useful techniques available in XML configuration as well, they are listed follow:
<ul>
<li>factory-method and factory-bean attributes</li>
<li>Bean Definition Inheritance</li>
<li>Inner Beans</li>
<li>p and c namespaces</li>
<li>Using collections as Spring beans</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>After reading this chapter, you should now have a good idea about DI design patterns, and the best practices for applying those patterns. Spring deals with the plumbing part, so, you can focus on solving the domain problem by using the dependency injection pattern. The DI pattern frees the object of the burden of resolving its dependencies. Your object is handed everything that it needs to work. The DI pattern simplifies your code, improves code reusability, and testability. It promotes programming to interfaces, and conceals the implementation details of dependencies. The DI pattern allows for centralized control over the object's life cycle. You can configure DI via two ways--explicit configuration and implicit configuration. Explicit configuration can be configured through XML-or Java-based configuration; it provides centralized configuration. But implicit configuration is based on annotations. Spring provides stereotype annotations for Annotation-based configuration. This configuration reduces the verbosity of code in the application, but it spreads out across the application files.<br/></p>
<p>In the upcoming <a href="d0375506-d940-4fe5-bc09-d1033eed2986.xhtml" target="_blank">Chapter 5</a>, <em>Understanding the Bean Life Cycle and Used Patterns</em>, we will explore the life cycle of the Spring bean in the container.</p>


            </article>

            
        </section>
    </body></html>