- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: 'Java I/O: Context-Specific Deserialization Filters'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java I/O：上下文特定反序列化过滤器
- en: This chapter includes 13 problems related to Java serialization/deserialization
    processes. We start with classical problems like serializing/deserializing objects
    to `byte[]`, `String`, and XML. We continue with JDK 9 deserialization filters
    meant to prevent deserialization vulnerabilities, and we finish with JDK 17 (JEP
    415, final) context-specific deserialization filters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括与 Java 序列化/反序列化过程相关的 13 个问题。我们首先从经典的将对象序列化/反序列化为 `byte[]`、`String` 和 XML
    的问题开始。然后，我们继续介绍旨在防止反序列化漏洞的 JDK 9 反序列化过滤器，最后以 JDK 17（JEP 415，最终版）的上下文特定反序列化过滤器结束。
- en: At the end of this chapter, you’ll be skilled in solving almost any problem
    related to serializing/deserializing objects in Java.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够解决与 Java 中序列化/反序列化对象相关的几乎所有问题。
- en: Problems
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess on Java serialization/deserialization.
    I strongly encourage you to give each problem a try before you turn to the solutions
    and download the example programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在 Java 序列化/反序列化方面的编程能力。我强烈建议你在查看解决方案并下载示例程序之前，尝试解决每个问题：
- en: '**Serializing objects to byte arrays**: Write a Java application that exposes
    two helper methods for serializing/deserializing objects to/from `byte[]`.'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将对象序列化为字节数组**：编写一个 Java 应用程序，该程序公开两个辅助方法，用于将对象序列化/反序列化为 `byte[]`。'
- en: '**Serializing objects to strings**: Write a Java application that exposes two
    helper methods for serializing/deserializing objects to/from `String`.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将对象序列化为字符串**：编写一个 Java 应用程序，该程序公开两个辅助方法，用于将对象序列化/反序列化为 `String`。'
- en: '**Serializing objects to XML**: Exemplify at least two approaches for serializing/deserializing
    objects to/from XML format.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将对象序列化为 XML**：举例说明至少两种将对象序列化/反序列化为 XML 格式的方案。'
- en: '**Introducing JDK 9 deserialization filters**: Provide a brief introduction
    to JDK 9 deserialization filters including some insights into the `ObjectInputFilter`
    API.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 JDK 9 反序列化过滤器**：简要介绍 JDK 9 反序列化过滤器，包括对 `ObjectInputFilter` API 的见解。'
- en: '**Implementing a custom pattern-based ObjectInputFilter**: Provide an example
    of implementing and setting a custom pattern-based filter via the `ObjectInputFilter`
    API.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现基于模式的自定义 ObjectInputFilter**：提供一个通过 `ObjectInputFilter` API 实现和设置自定义模式过滤器的示例。'
- en: '**Implementing a custom class ObjectInputFilter**: Exemplify the creation of
    an `ObjectInputFilter` via a class implementation.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现自定义类 ObjectInputFilter**：举例说明通过类实现创建 `ObjectInputFilter`。'
- en: '**Implementing a custom method ObjectInputFilter**: Exemplify the creation
    of an `ObjectInputFilter` via a method implementation.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现自定义方法 ObjectInputFilter**：举例说明通过方法实现创建 `ObjectInputFilter`。'
- en: '**Implementing a custom lambda ObjectInputFilter**: Exemplify the creation
    of an `ObjectInputFilter` via a lambda expression.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现自定义 lambda ObjectInputFilter**：举例说明通过 lambda 表达式创建 `ObjectInputFilter`。'
- en: '**Avoiding StackOverflowError at deserialization**: First, write a snippet
    of code that can be successfully serialized but, in the deserialization phase,
    causes a `StackOverflowError`. Second, write a filter that avoids this unpleasant
    scenario.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**避免反序列化时的 StackOverflowError**：首先，编写一段可以成功序列化的代码片段，但在反序列化阶段会导致 `StackOverflowError`。其次，编写一个过滤器以避免这种不愉快的场景。'
- en: '**Avoiding DoS attacks at deserialization**: First, write a snippet of code
    that can be successfully serialized but, in the deserialization phase, causes
    a DoS attack. Second, write a filter that avoids this unpleasant scenario.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**避免反序列化时的 DoS 攻击**：首先，编写一段可以成功序列化的代码片段，但在反序列化阶段会导致 DoS 攻击。其次，编写一个过滤器以避免这种不愉快的场景。'
- en: '**Introducing JDK 17 easy filter creation**: Explain and exemplify the usage
    of the JDK 17 `allowFilter()` and `rejectFilter()` methods.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 JDK 17 简化过滤器创建**：解释并举例说明使用 JDK 17 的 `allowFilter()` 和 `rejectFilter()`
    方法。'
- en: '**Tackling context-specific deserialization filters**: Explain and exemplify
    the usage of JDK 17 Filter Factories.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理上下文特定反序列化过滤器**：解释并举例说明使用 JDK 17 过滤器工厂。'
- en: '**Monitoring deserialization via JFR**: Exemplify the usage of **Java Flight
    Recorder** (**JFR**) for monitoring a deserialization event.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过 JFR 监控反序列化**：举例说明使用 **Java Flight Recorder** （**JFR**）监控反序列化事件。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter06).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节描述了前面问题的解决方案。记住，通常没有一种唯一正确的方法来解决特定的问题。此外，记住这里显示的解释只包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节并实验程序，请访问
    [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter06)。
- en: 131\. Serializing objects to byte arrays
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 131. 将对象序列化为字节数组
- en: In *Chapter 4*, *Problem 94*, we talked about the serialization/deserialization
    of Java records, so you should be pretty familiar with these operations. In a
    nutshell, serialization is the process of transforming an in-memory object into
    a stream of bytes that can also be stored in memory or written to a file, network,
    database, external storage, and so on. Deserialization is the reverse process,
    that is, recreating the object state in memory from the given stream of bytes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章*，*问题 94* 中，我们讨论了 Java 记录的序列化和反序列化，所以你应该对这些操作相当熟悉。简而言之，序列化是将内存中的对象转换成可以存储在内存中或写入文件、网络、数据库、外部存储等字节数流的过程。反序列化是相反的过程，即从给定的字节数流中重新创建对象状态。
- en: A Java object is serializable if its class implements `java.io.Serializable`
    (or, `java.io.Externalizable`). Accomplishing serialization/deserialization takes
    place via the `java.io.ObjectOutputStream` and `java.io.ObjectInputStream` classes
    and `writeObject()`/`readObject()` methods.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Java 对象如果是可序列化的，那么它的类必须实现 `java.io.Serializable` 接口（或者 `java.io.Externalizable`
    接口）。完成序列化和反序列化的操作是通过 `java.io.ObjectOutputStream` 和 `java.io.ObjectInputStream`
    类以及 `writeObject()`/`readObject()` 方法来实现的。
- en: 'For instance, let’s assume the following `Melon` class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设以下 `Melon` 类：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And, an instance of `Melon`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Melon` 的一个实例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Serializing the `melon` instance into a byte array can be accomplished as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `melon` 实例序列化为字节数组可以按照以下方式完成：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of course, we can use this helper to serialize any other object, but for the
    `melon` instance, we call it as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用这个辅助工具来序列化任何其他对象，但对于 `melon` 实例，我们调用它的方式如下：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Deserialization is done via another helper that uses `readObject()` as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化是通过另一个辅助工具完成的，该工具使用 `readObject()` 如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use this helper to deserialize any other object from a byte array, but
    for the `melonSer`, we call it as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个辅助工具从字节数组反序列化任何其他对象，但对于 `melonSer`，我们调用它的方式如下：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The returned `melonDeser` restores the initial object state even if it is not
    the same instance. In the bundled code, you can also see an approach based on
    Apache Commons Lang.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 `melonDeser` 即使不是相同的实例，也能恢复初始对象状态。在捆绑的代码中，你还可以看到基于 Apache Commons Lang 的方法。
- en: 132\. Serializing objects to strings
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 132. 将对象序列化为字符串
- en: 'In the previous problem, you saw how to serialize objects to byte arrays. If
    we work a little bit on a byte array, we can obtain a string representation of
    serialization. For instance, we can rely on `java.util.Base64` to encode a byte
    array to `String` as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个问题中，你看到了如何将对象序列化为字节数组。如果我们稍微处理一下字节数组，我们可以获得序列化的字符串表示。例如，我们可以依赖 `java.util.Base64`
    将字节数组编码为 `String`，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A possible output looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And, the code to obtain such a String is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 获取此类字符串的代码如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The reverse process relies on the `Base64` decoder as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 反向过程依赖于 `Base64` 解码器如下所示：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Calling this method is straightforward:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法很简单：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `melonDeser` object is the result of deserializing the previous string.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`melonDeser` 对象是反序列化前一个字符串的结果。'
- en: 133\. Serializing objects to XML
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 133. 将对象序列化为 XML
- en: 'Serializing/deserializing objects to XML via the JDK API can be accomplished
    via `java.beans.XMLEncoder`, respectively `XMLDecoder`. The `XMLEncoder` API relies
    on Java Reflection to discover the object’s fields and write them in XML format.
    This class can encode objects that respect the Java Beans contract ([https://docs.oracle.com/javase/tutorial/javabeans/writing/index.html](https://docs.oracle.com/javase/tutorial/javabeans/writing/index.html)).
    Basically, the object’s class should contain a public no-arguments constructor
    and public getters and setters for `private`/`protected` fields/properties. Implementing
    `Serializable` is not mandatory for `XMLEncoder`/`XMLDecoder`, so we can serialize/deserialize
    objects that don’t implement `Serializable`. Here, it is a helper method that
    encodes the given `Object` to XML:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 JDK API 将对象序列化/反序列化为XML可以通过 `java.beans.XMLEncoder` 和 `XMLDecoder` 实现。`XMLEncoder`
    API 依赖于Java反射来发现对象的字段并将它们写入XML格式。此类可以编码遵守Java Beans契约的对象（[https://docs.oracle.com/javase/tutorial/javabeans/writing/index.html](https://docs.oracle.com/javase/tutorial/javabeans/writing/index.html)）。基本上，对象的类应该包含一个公共的无参数构造函数和公共的
    `private`/`protected` 字段/属性的获取器和设置器。对于 `XMLEncoder`/`XMLDecoder`，实现 `Serializable`
    不是强制性的，因此我们可以序列化/反序列化没有实现 `Serializable` 的对象。这里是一个将给定的 `Object` 编码为XML的辅助方法：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The reverse process (deserialization) uses the `XMLDecoder` as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 反向过程（反序列化）使用 `XMLDecoder` 如下所示：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `XMLEncoder`/`XMLDecoder` is much more flexible than the `writeObject()`/`readObject()`
    API. For instance, if a field/property is added/removed/renamed or its type has
    changed, then the decoding process skips everything it cannot decode and tries
    to decode as much as possible without throwing an exception.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLEncoder`/`XMLDecoder` 比起 `writeObject()`/`readObject()` API 更灵活。例如，如果一个字段/属性被添加/删除/重命名或其类型已更改，那么解码过程会跳过它无法解码的所有内容，并尽可能多地尝试解码而不抛出异常。'
- en: 'Another common approach relies on the third-party library Jackson 2.x, which
    comes with `XmlMapper`. This library should be added as a dependency (of course,
    if you don’t have it already present in your project):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的方法依赖于第三方库Jackson 2.x，该库包含 `XmlMapper`。此库应作为依赖项添加（当然，如果您项目中尚未添加）：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we create an instance of `XmlMapper`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `XmlMapper` 的实例：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Via `XmlMapper`, we can serialize objects as XML as follows (there is no problem
    if the object’s class doesn’t implement `Serializable` and/or it doesn’t contain
    setters):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `XmlMapper`，我们可以将对象序列化为XML，如下所示（如果对象的类没有实现 `Serializable` 或不包含设置器，则没有问题）：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Calling this method can be done as follows (`melon` is an instance of the `Melon`
    class):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法可以如下进行（`melon` 是 `Melon` 类的一个实例）：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The reverse process can rely on `readValue()` as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 反向过程可以依赖于 `readValue()` 如下所示：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Calling this method can be done as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法可以如下进行：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Take your time to explore the `XmlMapper` API since it has a lot more to offer.
    For now, consider running the bundled code to see the XML produced by each of
    these two approaches.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细探索 `XmlMapper` API，因为它还有更多功能。现在，考虑运行捆绑的代码，以查看这两种方法各自产生的XML。
- en: If you plan to serialize/deserialize an object to JSON, then consider *Java
    Coding Problems*, *First Edition*, *Problem 141*, for a comprehensive set of examples
    based on JSONB, Jackson, and Gson.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划将对象序列化/反序列化为JSON，那么请考虑 *Java编码问题*，*第一版*，*问题141*，它提供了一套基于JSONB、Jackson和Gson的全面示例。
- en: 134\. Introducing JDK 9 deserialization filters
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 134. 介绍 JDK 9 反序列化过滤器
- en: As you know from *Chapter 4*, *Problem 94*, deserialization is exposed to vulnerabilities
    that may cause serious security issues. In other words, between serialization–deserialization
    cycles, an untrusted process (attacker) can modify/alter the serialization form
    to execute arbitrary code, sneak in malicious data, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 *第4章*，*问题94* 中所知，反序列化会暴露于可能导致严重安全问题的漏洞。换句话说，在序列化-反序列化周期之间，一个不受信任的过程（攻击者）可以修改/更改序列化形式以执行任意代码，偷偷植入恶意数据等。
- en: In order to prevent such vulnerabilities, JDK 9 has introduced the possibility
    of creating restrictions via filters meant to accept/reject deserialization based
    on specific predicates. A deserialization filter intercepts a stream that expects
    to be deserialized and applies to it one or more predicates that should be successfully
    passed in order to proceed with deserialization. If a predicate fails, then deserialization
    doesn’t even start and the stream is rejected.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止此类漏洞，JDK 9 引入了通过过滤器创建限制的可能性，这些过滤器旨在根据特定的谓词接受/拒绝反序列化。反序列化过滤器拦截一个期望被反序列化的流，并应用一个或多个谓词，只有成功通过这些谓词才能继续反序列化。如果谓词失败，则反序列化甚至不会开始，流将被拒绝。
- en: 'There are two kinds of filters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的过滤器：
- en: '**JVM-wide filters**: Filters applied to every deserialization that takes place
    in the JVM. The behavior of these filters is tightly coupled with how they are
    combined with other filters (if any).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM 全局过滤器**：应用于 JVM 中发生的每个反序列化的过滤器。这些过滤器的行为与它们如何与其他过滤器（如果有）结合紧密相关。'
- en: '**Stream filters**: Filters that operate on all `ObjectInputStream` instances
    of an application (*stream-global filters*) or on certain `ObjectInputStream`
    instances (*stream-specific filters*).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流过滤器**：操作应用程序中所有 `ObjectInputStream` 实例的过滤器（*流全局过滤器*）或操作某些 `ObjectInputStream`
    实例的过滤器（*流特定过滤器*）。'
- en: 'We can create the following types of filters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建以下类型的过滤器：
- en: 'Filters based on patterns (known as *pattern-based filters*): These filters
    can be used to filter modules, packages, or classes via string patterns. They
    can be applied without touching the code (as JVM-wide filters) or they can be
    created via the `ObjectInputFilter` API (as *pattern-based stream filters*).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模式的过滤器（称为 *模式过滤器*）：这些过滤器可以通过字符串模式来过滤模块、包或类。它们可以在不接触代码的情况下应用（作为 JVM 全局过滤器）或通过
    `ObjectInputFilter` API 创建（作为 *模式流过滤器*）。
- en: 'Filters based on the `ObjectInputFilter` API: This API allows us to define
    filters directly in code. Usually, such filters are defined based on string patterns
    or Java Reflection.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 `ObjectInputFilter` API 的过滤器：此 API 允许我们在代码中直接定义过滤器。通常，此类过滤器基于字符串模式或 Java
    反射定义。
- en: Pattern-based filters
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式过滤器
- en: 'Let’s see several filters based on string patterns. For instance, this filter
    accepts all classes from the `foo` package (and from any other package that is
    not `buzz`) and rejects all classes from the `buzz` package (a class that passes
    a pattern that starts with `!` is rejected):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基于字符串模式的几个过滤器。例如，这个过滤器接受来自 `foo` 包的所有类（以及来自任何其他不是 `buzz` 的包）的所有类，并拒绝来自
    `buzz` 包的所有类（一个通过以 `!` 开头的模式的类会被拒绝）：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Patterns are delimited via semicolons (`;`) and white spaces are considered
    as part of the pattern.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模式通过分号（`;`）分隔，空白被认为模式的一部分。
- en: 'The following filter rejects only the `modern.challenge.Melon` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过滤器仅拒绝 `modern.challenge.Melon` 类：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following filter rejects the `Melon` class from the `modern.challenge`
    package and accepts all other classes from this package (the `*` is the wildcard
    used to represent unspecified class/package/module names):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过滤器拒绝 `modern.challenge` 包中的 `Melon` 类，并接受该包中的所有其他类（`*` 是用于表示未指定的类/包/模块名称的通配符）：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following filter accepts all classes from the `foo` package and its sub-packages
    (notice the `**` wildcard):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过滤器接受 `foo` 包及其子包中的所有类（注意 `**` 通配符）：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following filter accepts all classes starting with `Hash`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过滤器接受所有以 `Hash` 开头的类：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Besides filtering classes, packages, and modules, we can also define the so-called
    *resource filters*, which allow us to accept/reject resources based on an object’s
    graph complexity and size. In this context, we have `maxdepth` (the maximum graph
    depth), `maxarray` (the maximum array size), `maxrefs` (the maximum number of
    references between objects of a graph), and `maxbytes` (the maximum number of
    stream bytes). Here is an example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了过滤类、包和模块之外，我们还可以定义所谓的 *资源过滤器*，它允许我们根据对象的图复杂性和大小来接受/拒绝资源。在此上下文中，我们有 `maxdepth`（最大图深度）、`maxarray`（最大数组大小）、`maxrefs`（图中对象之间的最大引用数）和
    `maxbytes`（最大流字节数）。以下是一个示例：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, let’s see how we can use such filters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用这样的过滤器。
- en: Applying a pattern-based filter per application
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为每个应用程序应用基于模式的过滤器
- en: 'If we want to apply a *pattern-based filter* to a single run of an application,
    then we can rely on the `jdk.serialFilter` system property. Without touching the
    code, we use this system property at the command line as in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对一个应用程序的单次运行应用基于模式的过滤器，那么我们可以依赖`jdk.serialFilter`系统属性。在不接触代码的情况下，我们可以在命令行中使用这个系统属性，如下面的示例所示：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A system property replaces a Security Property value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 系统属性替换安全属性值。
- en: Applying a pattern-based filter to all applications in a process
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将基于模式的过滤器应用于进程中的所有应用程序
- en: 'To apply a *pattern-based filter* to all applications in a process, we should
    follow two steps (again, we don’t touch the application code):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要将基于模式的过滤器应用于进程中的所有应用程序，我们应该遵循两个步骤（再次强调，我们不接触应用程序代码）：
- en: In an editor (for instance, Notepad or Wordpad), open the `java.security` file.
    In JDK 6-8, this file is located in `$JAVA_HOME/lib/security/java.security`, while
    in JDK 9+, it is in `$JAVA_HOME/conf/security/java.security`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器（例如，记事本或写字板）中打开`java.security`文件。在JDK 6-8中，此文件位于`$JAVA_HOME/lib/security/java.security`，而在JDK
    9+中，它位于`$JAVA_HOME/conf/security/java.security`。
- en: Edit this file by appending the pattern to the `jdk.serialFilter` Security Property.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将模式追加到`jdk.serialFilter`安全属性来编辑此文件。
- en: Done!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: ObjectInputFilter-based filters
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于ObjectInputFilter的过滤器
- en: Via the `ObjectInputFilter` API, we can create custom filters based on string
    patterns and Java Reflection. These filters can be applied to certain streams
    (*stream-specific filters*) or to all streams (*stream-global filters*) and can
    be implemented as *pattern-based filters*, as classes, methods, or lambda expressions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ObjectInputFilter` API，我们可以根据字符串模式和Java反射创建自定义过滤器。这些过滤器可以应用于某些流（*流特定过滤器*）或所有流（*流全局过滤器*），并且可以作为基于模式的过滤器、类、方法或lambda表达式实现。
- en: First, we implement the filter via the `ObjectInputFilter` API. Second, we set
    the filter on all/certain `ObjectInputStream` instances. Setting the filter as
    a *stream-global filter* is done via `ObjectInputFilter.Config.setSerialFilter(ObjectInputFilter
    filter)`. On the other hand, setting the filter as a *stream-specific filter*
    can be done via `ObjectInputStream.setObjectInputFilter(ObjectInputFilter filter)`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过`ObjectInputFilter` API实现过滤器。其次，我们在所有/某些`ObjectInputStream`实例上设置过滤器。将过滤器作为*流全局过滤器*设置是通过`ObjectInputFilter.Config.setSerialFilter(ObjectInputFilter
    filter)`完成的。另一方面，将过滤器作为*流特定过滤器*可以通过`ObjectInputStream.setObjectInputFilter(ObjectInputFilter
    filter)`完成。
- en: For instance, creating a *pattern-based filter* via this API can be done by
    calling the `Config.createFilter(String pattern)` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过此API创建一个基于模式的过滤器可以通过调用`Config.createFilter(String pattern)`方法实现。
- en: A custom filter defined as a class is done by implementing the `ObjectInputFilter`
    functional interface and overriding the `Status checkInput(FilterInfo filterInfo)`
    method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将过滤器定义为类的自定义过滤器是通过实现`ObjectInputFilter`功能接口并重写`Status checkInput(FilterInfo
    filterInfo)`方法来完成的。
- en: A custom filter defined as a method is commonly done via a static method as
    `static ObjectInputFilter.Status someFilter(FilterInfo info) {…}`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将过滤器定义为方法的自定义过滤器通常通过静态方法`static ObjectInputFilter.Status someFilter(FilterInfo
    info) {…}`来实现。
- en: And, a custom filter defined as a lambda expression is commonly expressed as
    `ois.setObjectInputFilter(f -> (…))`, where `f` is `ObjectInputFilter` and `ois`
    is an instance of `ObjectInputStream`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将过滤器定义为lambda表达式通常表示为`ois.setObjectInputFilter(f -> (…))`，其中`f`是`ObjectInputFilter`，`ois`是`ObjectInputStream`的一个实例。
- en: A filter returns a *status* (`java.io.ObjectInputFilter.Status`), which can
    be `ALLOWED`, `REJECTED`, or `UNDECIDED`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器返回一个*状态*（`java.io.ObjectInputFilter.Status`），可以是`ALLOWED`、`REJECTED`或`UNDECIDED`。
- en: In the next problems, we will explore these statements via examples.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的问题中，我们将通过示例来探索这些语句。
- en: 135\. Implementing a custom pattern-based ObjectInputFilter
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 135. 实现自定义的基于模式的ObjectInputFilter
- en: Let’s assume that we already have the `Melon` class and the helper methods for
    serializing/deserializing objects to/from byte arrays from *Problem 131*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有`Melon`类和从*问题131*中序列化/反序列化对象到/从字节数组的辅助方法。
- en: 'Creating a *pattern-based filter* via the `ObjectInputFilter` API can be done
    by calling the `Config.createFilter(String pattern)` method. For instance, the
    following filter rejects the `modern.challenge.Melon` class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ObjectInputFilter` API创建一个基于模式的过滤器可以通过调用`Config.createFilter(String pattern)`方法实现。例如，以下过滤器拒绝`modern.challenge.Melon`类：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can set this filter as a *stream-global filter* via `setSerialFilter()`
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`setSerialFilter()`将其作为*流全局过滤器*设置，如下所示：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we need to get access to a *stream-global filter*, then we can call `getSerialFilter()`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要获取对 *流全局过滤器* 的访问权限，那么我们可以调用 `getSerialFilter()`：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Any stream deserialization in this application will pass through this filter,
    which will reject any instance of `modern.challenge.Melon`. You can practice this
    filter in the bundled code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中的任何流反序列化都将通过此过滤器，该过滤器将拒绝 `modern.challenge.Melon` 的任何实例。你可以在捆绑的代码中练习这个过滤器。
- en: 'On the other hand, if we want to set this on a specific stream, then we can
    modify our `Converters.bytesToObject()` method to accept a filter as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想在一个特定流上设置它，那么我们可以修改我们的 `Converters.bytesToObject()` 方法以接受一个过滤器如下所示：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we pass `null` as `filter`, then the filter will not be applied. Otherwise,
    the passed filter will be applied to the current stream:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递 `null` 作为 `filter`，则不会应用过滤器。否则，传递的过滤器将应用于当前流：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, the `melonFilter` will reject deserialization and the output
    will be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`melonFilter` 将拒绝反序列化，输出如下所示：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can also practice this filter in the bundled code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在捆绑的代码中练习这个过滤器。
- en: 136\. Implementing a custom class ObjectInputFilter
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 136. 实现自定义类 ObjectInputFilter
- en: Let’s assume that we already have the `Melon` class and the helper methods for
    serializing/deserializing objects to/from byte arrays from *Problem 131*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有 `Melon` 类以及从 *问题 131* 中序列化和反序列化对象到/从字节数组的辅助方法。
- en: 'An `ObjectInputFilter` can be written via a dedicated class by implementing
    the `ObjectInputFilter` functional interface as in the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过实现 `ObjectInputFilter` 功能接口并通过以下示例中的专用类编写 `ObjectInputFilter`：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This filter is exactly the same as the *pattern-based filter*, `!modern.challenge.Melon`,
    only that it is expressed via Java Reflection.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器与基于模式的过滤器 `!modern.challenge.Melon` 完全相同，只是它通过 Java 反射表达。
- en: 'We can set this filter as a *stream-global filter* as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样设置这个过滤器作为 *流全局过滤器*：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or, as a *stream-specific filter* as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为一个 *流特定过滤器* 如下所示：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Of course, the `bytesToObject()` accepts an argument of type `ObjectInputFilter`
    and sets this filter accordingly (`ois` is the specific `ObjectInputStream`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`bytesToObject()` 接受类型为 `ObjectInputFilter` 的参数，并相应地设置此过滤器（`ois` 是特定的 `ObjectInputStream`）：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, the `MelonFilter` will reject deserialization and the output
    will be as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`MelonFilter` 将拒绝反序列化，输出如下所示：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can practice both approaches (*stream-global* and *stream-specific*) in
    the bundled code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习这两种方法（*流全局* 和 *流特定*）。
- en: 137\. Implementing a custom method ObjectInputFilter
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 137. 实现自定义方法 ObjectInputFilter
- en: Let’s assume that we already have the `Melon` class and the helper methods for
    serializing/deserializing objects to/from byte arrays from *Problem 131*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有 `Melon` 类以及从 *问题 131* 中序列化和反序列化对象到/从字节数组的辅助方法。
- en: 'An `ObjectInputFilter` can be written via a dedicated method as in the following
    example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下示例中的专用方法编写 `ObjectInputFilter`：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Of course, you can add more filters in this class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在这个类中添加更多过滤器。
- en: 'We can set this filter as a *stream-global filter* as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样设置这个过滤器作为 *流全局过滤器*：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or, as a *stream-specific filter* as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为一个 *流特定过滤器* 如下所示：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Of course, the `bytesToObject()` accepts an argument of type `ObjectInputFilter`
    and sets this filter accordingly (`ois` is the specific `ObjectInputStream`):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`bytesToObject()` 接受类型为 `ObjectInputFilter` 的参数，并相应地设置此过滤器（`ois` 是特定的 `ObjectInputStream`）：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this example, the `Filters::melonFilter` will reject deserialization and
    the output will be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Filters::melonFilter` 将拒绝反序列化，输出如下所示：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can check out both approaches (*stream-global* and *stream-specific*) in
    the bundled code. Moreover, you can also practice another example that rejects
    all instances of `Melon` and its subclasses based on a *stream-global filter*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中检查这两种方法（*流全局* 和 *流特定*）。此外，你还可以练习另一个基于 *流全局过滤器* 拒绝 `Melon` 及其所有子类的示例。
- en: 138\. Implementing a custom lambda ObjectInputFilter
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 138. 实现自定义 lambda ObjectInputFilter
- en: Let’s assume that we already have the `Melon` class and the helper methods for
    serializing/deserializing objects to/from byte arrays from *Problem 131*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有 `Melon` 类以及从 *问题 131* 中序列化和反序列化对象到/从字节数组的辅助方法。
- en: 'An `ObjectInputFilter` can be written via a dedicated lambda and set as a *stream-global
    filter* as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过一个专门的 lambda 表达式编写 `ObjectInputFilter` 并将其设置为如下所示的 *流全局过滤器*：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or, as a *stream-specific filter* as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为一个 *流特定过滤器* 如下所示：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can practice these examples in the bundled code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习这些示例。
- en: 139\. Avoiding StackOverflowError at deserialization
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 139. 避免反序列化时的 StackOverflowError
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We plan to serialize the `mapOfSets` object as follows (I assume that `Converters.objectToBytes()`
    is well-known from the previous problems):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划如下序列化 `mapOfSets` 对象（我假设 `Converters.objectToBytes()` 在之前的问题中是已知的）：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Everything works just fine until we try to deserialize `mapSer`. At that moment,
    instead of a valid object, we will get a `StackOverflowError` as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一切工作正常，直到我们尝试反序列化 `mapSer`。在那个时刻，，我们不会得到一个有效的对象，而是一个 `StackOverflowError`，如下所示：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The deserialization process got stuck in the `hashCode()` method of `Set`.
    The solution is to create a filter that will reject deserialization if the object
    has a graph depth bigger than 2\. This can be a *pattern-based filter* as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化过程卡在了 `Set` 的 `hashCode()` 方法上。解决方案是创建一个过滤器，如果对象图深度大于 2，则拒绝反序列化。这可以是一个如下所示的基于模式的过滤器：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, call the deserialization process with this filter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用此过滤器调用反序列化过程：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I assume that `Converters.bytesToObject()` is well-known from the previous problems.
    This time, instead of getting `StackOverflowError`, the deserialization is rejected
    by the filter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设 `Converters.bytesToObject()` 在之前的问题中是已知的。这次，反序列化被过滤器拒绝，而不是得到 `StackOverflowError`。
- en: 140\. Avoiding DoS attacks at deserialization
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 140. 避免反序列化时的 DoS 攻击
- en: '**Denial-of-service** (**DoS**) attacks are typically malicious actions meant
    to trigger, in a short period of time, a lot of requests to a server, application,
    and so on. Generally speaking, a DoS attack is any kind of action that intentionally/accidentally
    overwhelms a process and forces it to slow down or even crash. Let’s see a snippet
    of code that is a good candidate for representing a DoS attack in the deserialization
    phase:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**拒绝服务**（**DoS**）攻击通常是恶意行为，旨在短时间内触发对服务器、应用程序等的大量请求。一般来说，DoS 攻击是任何故意或意外地使进程过载并迫使它减速或甚至崩溃的行为。让我们看看一个代码片段，它是一个在反序列化阶段表示
    DoS 攻击的好候选：'
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We plan to serialize the `startList` object as follows (I assume that `Converters.objectToBytes()`
    is well-known from the previous problems):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划如下序列化 `startList` 对象（我假设 `Converters.objectToBytes()` 在之前的问题中是已知的）：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Everything works just fine until we try to deserialize `startListSer`. At that
    moment, instead of a valid object, we will get…nothing! Actually, the application
    starts normally, but it just hangs there in the deserialization phase. The system
    slows down and, after a while, it will eventually crash.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一切工作正常，直到我们尝试反序列化 `startListSer`。在那个时刻，我们不会得到一个有效的对象，而是一无所获！实际上，应用程序会正常启动，但它只是在反序列化阶段挂起。系统变慢，过一段时间后，它最终会崩溃。
- en: 'The object graph is too deep to be deserialized and that leads to a behavior
    similar to a DoS attack. The solution is to create a filter that will reject deserialization
    if the object has a graph depth bigger than a safe value. This can be a *pattern-based
    filter* as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对象图太深，无法反序列化，这会导致类似拒绝服务（DoS）攻击的行为。解决方案是创建一个过滤器，如果对象图深度大于一个安全值，则拒绝反序列化。这可以是一个如下所示的基于模式的过滤器：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, call the deserialization process with this filter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用此过滤器调用反序列化过程：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: I assume that `Converters.bytesToObject()` is well-known from the previous problems.
    This time, the deserialization is rejected by the filter and the DoS attack is
    prevented.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设 `Converters.bytesToObject()` 在之前的问题中是已知的。这次，反序列化被过滤器拒绝，从而防止了 DoS 攻击。
- en: 141\. Introducing JDK 17 easy filter creation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 141. 引入 JDK 17 简易过滤器创建
- en: 'Starting with JDK 17, we can express filters more intuitively and readably
    via two convenient methods named `allowFilter()` and `rejectFilter()`. And, since
    the best way to learn is with an example, here is a usage case of these two convenient
    methods:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 17 开始，我们可以通过两个名为 `allowFilter()` 和 `rejectFilter()` 的方便方法更直观、更易读地表达过滤器。而且，最好的学习方法是通过例子，以下是对这两个方便方法的用法示例：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `allowMelonFilter()` relies on `ObjectInputFilter.allowFilter()` to allow
    only objects that are instances of `Melon` or subclasses of `Melon`. The `rejectMuskmelonFilter()`
    relies on `ObjectInputFilter.rejectFilter()` to reject all objects that are instances
    of `Muskmelon` or subclasses of `Muskmelon`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowMelonFilter()` 方法依赖于 `ObjectInputFilter.allowFilter()` 来允许只有 `Melon`
    或其子类的实例对象。`rejectMuskmelonFilter()` 方法依赖于 `ObjectInputFilter.rejectFilter()` 来拒绝所有
    `Muskmelon` 或其子类的实例对象。'
- en: 'We can use each of these filters as you already know from the previous problems,
    so let’s tackle another use case. Let’s assume that we have the following hierarchy
    of classes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1.png](img/B19665_06_01.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: An arbitrary hierarchy of classes'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we want to deserialize only objects that are instances of
    `Melon` or subclasses of `Melon` but they are not `Muskmelon` or subclasses of
    `Muskmelon`. In other words, we allow deserializing instances of `Melon` and `Cantaloupe`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: If we apply the `allowMelonFilter()`, then we will deserialize instances of
    `Melon`, `Muskmelon`, `Cantaloupe`, `HoneyDew`, and `Persian` since all these
    are `Melon`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we apply `rejectMuskmelonFilter()`, then we will deserialize
    instances of `Melon`, `Cantaloupe`, and `Pumpkin` since these are not `Muskmelon`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: But, if we apply `rejectMuskmelonFilter()` after applying `allowMelonFilter()`,
    then we will deserialize only `Melon` and `Cantaloupe`, which is exactly what
    we want.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Intuitively, we may think to chain our filters by writing something like this
    (`ois` is the current `ObjectInputStream`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But, this will not work! It will cause a `java.lang.IllegalStateException`:
    *filter cannot be set more than once*.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution relies on `ObjectInputFilter.merge(filter, anotherFilter)`, which
    returns a filter that merges the status of these two filters by applying the following
    logic:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Call `filter` and get the returned `status`
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the returned `status` is `REJECTED`, then return it
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `anotherFilter` and get the returned `otherStatus`
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `anotherStatus` is `REJECTED`, then return it
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either `status` or `otherStatus` is `ALLOWED`, then return `ALLOWED`
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, return `UNDECIDED`
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nevertheless, if `anotherFilter` is `null`, the filter is returned.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this logic, we can merge the status of `Filters.allowMelonFilter()`
    with the status of `Filters.rejectMuskmelonFilter()` as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Next, let’s talk about JDK 17 Filter Factories.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 142\. Tackling context-specific deserialization filters
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 17 enriched the deserialization filter capabilities with the implementation
    of JEP 415, *Context-Specific Deserialization Filters*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Practically, JDK 17 added the so-called Filter Factories. Depending on the context,
    a Filter Factory can dynamically decide what filters to use for a stream.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Applying a Filter Factory per application
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to apply a Filter Factory to a single run of an application, then
    we can rely on the `jdk.serialFilterFactory` system property. Without touching
    the code, we use this system property at the command line as in the following
    example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `FilterFactoryName` is the fully qualified name of the Filter Factory, which
    is a public class that can be accessed by the application class loader, and it
    was set before the first deserialization.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Applying a Filter Factory to all applications in a process
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To apply a Filter Factory to all applications in a process, we should follow
    two steps (again, we don’t touch the application code):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In an editor (for instance, Notepad or Wordpad), open the `java.security` file.
    In JDK 6-8, this file is located in `$JAVA_HOME/lib/security/java.security`, while
    in JDK 9+, it is in `$JAVA_HOME/conf/security/java.security`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit this file by appending the Filter Factory to the `jdk.serialFilterFactory` Security
    Property.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying a Filter Factory via ObjectInputFilter.Config
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, a Filter Factory can be set directly in code via `ObjectInputFilter.Config`
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `FilterFactoryInstance` argument is an instance of a Filter Factory. This
    Filter Factory will be applied to all streams from the current application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Filter Factory
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Filter Factory is implemented as a `BinaryOperator<ObjectInputFilter>`. The
    `apply(ObjectInputFilter current, ObjectInputFilter next)` method provides the
    *current filter* and the *next* or *requested filter*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see how it works, let’s assume that we have the following three
    filters:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `Filters.allowMelonFilter()` is set as a *stream-global filter* as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `Filters.rejectMuskmelonFilter()` is set as a *stream-specific filter*
    as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And, the `Filters.packageFilter()` is set in the Filter Factory as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `MelonFilterFactory` is set via `ObjectInputFilter.Config` before any deserialization
    takes place:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now that everything is in place, let’s see what’s happening. The `apply()`
    method is called twice. The first time it is called is when the `ObjectInputStream
    ois` is created, and we obtain the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The *current filter* is `null`, and the *requested filter* is `Filters.allowMelonFilter()`.
    Since the *current filter* is `null` and the *requested filter* is not `null`,
    we decided to return a filter as the result of merging the status of the *requested
    filter* with the status of the `Filters.packageFilter()`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The second time the `apply()` method is called happens when the `ois.setObjectInputFilter(filter)`
    is called in `Converters.bytesToObject(byte[] bytes, ObjectInputFilter filter)`.
    We have the following output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This time, the *current* and *requested filters* are not `null`, so we merge
    their statuses again. Finally, all filters are successfully passed and the deserialization
    takes place.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 143\. Monitoring deserialization via JFR
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Flight Recorder** (**JFR**) is an event-based tool for the diagnosis
    and profiling of Java applications. This tool was initially added in JDK 7 and,
    since then, it has been constantly improved. For instance, in JDK 14, JFR was
    enriched with event streaming, and in JDK 19, with filtering event capabilities,
    and so on. You can find all JFR events listed and documented per JDK version at
    [https://sap.github.io/SapMachine/jfrevents/](https://sap.github.io/SapMachine/jfrevents/).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Among its rich list of events, JFR can monitor and record deserialization events
    (the deserialization event). Let’s assume a simple application like the one from
    *Problem 131* (the first problem of this chapter). We start configuring JFR for
    monitoring the deserialization of this application by adding `deserializationEvent.jfc`
    into the root folder of the application:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Practically, this file instructs JFR to monitor and record the deserialization
    events.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use `-XX:StartFlightRecording=filename=recording.jfr` to instruct JFR
    to record output in a file named `recording.jfr`, and we continue with `settings=deserializationEvent.jfc`
    to point out the configuration file listed previously.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the final command is the one from this figure:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2.png](img/B19665_06_02.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Running JFR'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'After this command is executed, you’ll see an output as in *Figure 6.3*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3.png](img/B19665_06_03.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The output of our application'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'JFR has produced a file named `recording.jfr`. We can easily view the content
    of this file via the JFR CLI. The command (`jfr print recording.jfr`) and the
    output are available in *Figure 6.4*:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4.png](img/B19665_06_04.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The output of JFR containing deserialization information'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: JFR produced a single deserialization event since our application has performed
    a single serialization/deserialization cycle of a `Melon` object. You can see
    the type of the object (here, `Melon`) via the `type` field. Since the `Melon`
    instance is not an array, the `arrayLength` was set to `-1`, which means that
    arrays are not applicable. The `objectReferences` represents the first object
    reference in the stream (so, `1`) and the `bytesRead` represents the number of
    bytes read from this stream (in this case, `78` bytes). We also see that there
    was no filter present, `filterConfigured = false`, and `filterStatus = N/A` (not
    applicable). Moreover, `exceptionType` and `exceptionMessage` are `N/A`. They
    are not applicable because there is no filter present. They are useful for capturing
    any exceptions caused by a potential filter.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Besides the JFR CLI, you can use more powerful tools for consuming the deserialization
    event such as JDK Mission Control ([https://www.oracle.com/java/technologies/jdk-mission-control.html](https://www.oracle.com/java/technologies/jdk-mission-control.html))
    and the well-known Advanced Management Console ([https://www.oracle.com/java/technologies/advancedmanagementconsole.html](https://www.oracle.com/java/technologies/advancedmanagementconsole.html)).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a bunch of problems dedicated to handling Java serialization/deserialization
    processes. We started with classical problems and moved on to cover JDK 17 context-specific
    deserialization filters passing through JDK 9 deserialization filters on the way.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ)'
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1139613064111216156.png)'
