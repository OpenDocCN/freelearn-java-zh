- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java I/O: Context-Specific Deserialization Filters'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter includes 13 problems related to Java serialization/deserialization
    processes. We start with classical problems like serializing/deserializing objects
    to `byte[]`, `String`, and XML. We continue with JDK 9 deserialization filters
    meant to prevent deserialization vulnerabilities, and we finish with JDK 17 (JEP
    415, final) context-specific deserialization filters.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you’ll be skilled in solving almost any problem
    related to serializing/deserializing objects in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following problems to test your programming prowess on Java serialization/deserialization.
    I strongly encourage you to give each problem a try before you turn to the solutions
    and download the example programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serializing objects to byte arrays**: Write a Java application that exposes
    two helper methods for serializing/deserializing objects to/from `byte[]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Serializing objects to strings**: Write a Java application that exposes two
    helper methods for serializing/deserializing objects to/from `String`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Serializing objects to XML**: Exemplify at least two approaches for serializing/deserializing
    objects to/from XML format.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing JDK 9 deserialization filters**: Provide a brief introduction
    to JDK 9 deserialization filters including some insights into the `ObjectInputFilter`
    API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing a custom pattern-based ObjectInputFilter**: Provide an example
    of implementing and setting a custom pattern-based filter via the `ObjectInputFilter`
    API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing a custom class ObjectInputFilter**: Exemplify the creation of
    an `ObjectInputFilter` via a class implementation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing a custom method ObjectInputFilter**: Exemplify the creation
    of an `ObjectInputFilter` via a method implementation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implementing a custom lambda ObjectInputFilter**: Exemplify the creation
    of an `ObjectInputFilter` via a lambda expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Avoiding StackOverflowError at deserialization**: First, write a snippet
    of code that can be successfully serialized but, in the deserialization phase,
    causes a `StackOverflowError`. Second, write a filter that avoids this unpleasant
    scenario.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Avoiding DoS attacks at deserialization**: First, write a snippet of code
    that can be successfully serialized but, in the deserialization phase, causes
    a DoS attack. Second, write a filter that avoids this unpleasant scenario.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing JDK 17 easy filter creation**: Explain and exemplify the usage
    of the JDK 17 `allowFilter()` and `rejectFilter()` methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling context-specific deserialization filters**: Explain and exemplify
    the usage of JDK 17 Filter Factories.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitoring deserialization via JFR**: Exemplify the usage of **Java Flight
    Recorder** (**JFR**) for monitoring a deserialization event.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: 131\. Serializing objects to byte arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 4*, *Problem 94*, we talked about the serialization/deserialization
    of Java records, so you should be pretty familiar with these operations. In a
    nutshell, serialization is the process of transforming an in-memory object into
    a stream of bytes that can also be stored in memory or written to a file, network,
    database, external storage, and so on. Deserialization is the reverse process,
    that is, recreating the object state in memory from the given stream of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: A Java object is serializable if its class implements `java.io.Serializable`
    (or, `java.io.Externalizable`). Accomplishing serialization/deserialization takes
    place via the `java.io.ObjectOutputStream` and `java.io.ObjectInputStream` classes
    and `writeObject()`/`readObject()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s assume the following `Melon` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And, an instance of `Melon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Serializing the `melon` instance into a byte array can be accomplished as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can use this helper to serialize any other object, but for the
    `melon` instance, we call it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Deserialization is done via another helper that uses `readObject()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this helper to deserialize any other object from a byte array, but
    for the `melonSer`, we call it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The returned `melonDeser` restores the initial object state even if it is not
    the same instance. In the bundled code, you can also see an approach based on
    Apache Commons Lang.
  prefs: []
  type: TYPE_NORMAL
- en: 132\. Serializing objects to strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous problem, you saw how to serialize objects to byte arrays. If
    we work a little bit on a byte array, we can obtain a string representation of
    serialization. For instance, we can rely on `java.util.Base64` to encode a byte
    array to `String` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the code to obtain such a String is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse process relies on the `Base64` decoder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this method is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `melonDeser` object is the result of deserializing the previous string.
  prefs: []
  type: TYPE_NORMAL
- en: 133\. Serializing objects to XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serializing/deserializing objects to XML via the JDK API can be accomplished
    via `java.beans.XMLEncoder`, respectively `XMLDecoder`. The `XMLEncoder` API relies
    on Java Reflection to discover the object’s fields and write them in XML format.
    This class can encode objects that respect the Java Beans contract ([https://docs.oracle.com/javase/tutorial/javabeans/writing/index.html](https://docs.oracle.com/javase/tutorial/javabeans/writing/index.html)).
    Basically, the object’s class should contain a public no-arguments constructor
    and public getters and setters for `private`/`protected` fields/properties. Implementing
    `Serializable` is not mandatory for `XMLEncoder`/`XMLDecoder`, so we can serialize/deserialize
    objects that don’t implement `Serializable`. Here, it is a helper method that
    encodes the given `Object` to XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse process (deserialization) uses the `XMLDecoder` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `XMLEncoder`/`XMLDecoder` is much more flexible than the `writeObject()`/`readObject()`
    API. For instance, if a field/property is added/removed/renamed or its type has
    changed, then the decoding process skips everything it cannot decode and tries
    to decode as much as possible without throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common approach relies on the third-party library Jackson 2.x, which
    comes with `XmlMapper`. This library should be added as a dependency (of course,
    if you don’t have it already present in your project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an instance of `XmlMapper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Via `XmlMapper`, we can serialize objects as XML as follows (there is no problem
    if the object’s class doesn’t implement `Serializable` and/or it doesn’t contain
    setters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this method can be done as follows (`melon` is an instance of the `Melon`
    class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse process can rely on `readValue()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this method can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Take your time to explore the `XmlMapper` API since it has a lot more to offer.
    For now, consider running the bundled code to see the XML produced by each of
    these two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to serialize/deserialize an object to JSON, then consider *Java
    Coding Problems*, *First Edition*, *Problem 141*, for a comprehensive set of examples
    based on JSONB, Jackson, and Gson.
  prefs: []
  type: TYPE_NORMAL
- en: 134\. Introducing JDK 9 deserialization filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know from *Chapter 4*, *Problem 94*, deserialization is exposed to vulnerabilities
    that may cause serious security issues. In other words, between serialization–deserialization
    cycles, an untrusted process (attacker) can modify/alter the serialization form
    to execute arbitrary code, sneak in malicious data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In order to prevent such vulnerabilities, JDK 9 has introduced the possibility
    of creating restrictions via filters meant to accept/reject deserialization based
    on specific predicates. A deserialization filter intercepts a stream that expects
    to be deserialized and applies to it one or more predicates that should be successfully
    passed in order to proceed with deserialization. If a predicate fails, then deserialization
    doesn’t even start and the stream is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JVM-wide filters**: Filters applied to every deserialization that takes place
    in the JVM. The behavior of these filters is tightly coupled with how they are
    combined with other filters (if any).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stream filters**: Filters that operate on all `ObjectInputStream` instances
    of an application (*stream-global filters*) or on certain `ObjectInputStream`
    instances (*stream-specific filters*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create the following types of filters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Filters based on patterns (known as *pattern-based filters*): These filters
    can be used to filter modules, packages, or classes via string patterns. They
    can be applied without touching the code (as JVM-wide filters) or they can be
    created via the `ObjectInputFilter` API (as *pattern-based stream filters*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filters based on the `ObjectInputFilter` API: This API allows us to define
    filters directly in code. Usually, such filters are defined based on string patterns
    or Java Reflection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern-based filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see several filters based on string patterns. For instance, this filter
    accepts all classes from the `foo` package (and from any other package that is
    not `buzz`) and rejects all classes from the `buzz` package (a class that passes
    a pattern that starts with `!` is rejected):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Patterns are delimited via semicolons (`;`) and white spaces are considered
    as part of the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following filter rejects only the `modern.challenge.Melon` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following filter rejects the `Melon` class from the `modern.challenge`
    package and accepts all other classes from this package (the `*` is the wildcard
    used to represent unspecified class/package/module names):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following filter accepts all classes from the `foo` package and its sub-packages
    (notice the `**` wildcard):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following filter accepts all classes starting with `Hash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides filtering classes, packages, and modules, we can also define the so-called
    *resource filters*, which allow us to accept/reject resources based on an object’s
    graph complexity and size. In this context, we have `maxdepth` (the maximum graph
    depth), `maxarray` (the maximum array size), `maxrefs` (the maximum number of
    references between objects of a graph), and `maxbytes` (the maximum number of
    stream bytes). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s see how we can use such filters.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a pattern-based filter per application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to apply a *pattern-based filter* to a single run of an application,
    then we can rely on the `jdk.serialFilter` system property. Without touching the
    code, we use this system property at the command line as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A system property replaces a Security Property value.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a pattern-based filter to all applications in a process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To apply a *pattern-based filter* to all applications in a process, we should
    follow two steps (again, we don’t touch the application code):'
  prefs: []
  type: TYPE_NORMAL
- en: In an editor (for instance, Notepad or Wordpad), open the `java.security` file.
    In JDK 6-8, this file is located in `$JAVA_HOME/lib/security/java.security`, while
    in JDK 9+, it is in `$JAVA_HOME/conf/security/java.security`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit this file by appending the pattern to the `jdk.serialFilter` Security Property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Done!
  prefs: []
  type: TYPE_NORMAL
- en: ObjectInputFilter-based filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Via the `ObjectInputFilter` API, we can create custom filters based on string
    patterns and Java Reflection. These filters can be applied to certain streams
    (*stream-specific filters*) or to all streams (*stream-global filters*) and can
    be implemented as *pattern-based filters*, as classes, methods, or lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we implement the filter via the `ObjectInputFilter` API. Second, we set
    the filter on all/certain `ObjectInputStream` instances. Setting the filter as
    a *stream-global filter* is done via `ObjectInputFilter.Config.setSerialFilter(ObjectInputFilter
    filter)`. On the other hand, setting the filter as a *stream-specific filter*
    can be done via `ObjectInputStream.setObjectInputFilter(ObjectInputFilter filter)`.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, creating a *pattern-based filter* via this API can be done by
    calling the `Config.createFilter(String pattern)` method.
  prefs: []
  type: TYPE_NORMAL
- en: A custom filter defined as a class is done by implementing the `ObjectInputFilter`
    functional interface and overriding the `Status checkInput(FilterInfo filterInfo)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: A custom filter defined as a method is commonly done via a static method as
    `static ObjectInputFilter.Status someFilter(FilterInfo info) {…}`.
  prefs: []
  type: TYPE_NORMAL
- en: And, a custom filter defined as a lambda expression is commonly expressed as
    `ois.setObjectInputFilter(f -> (…))`, where `f` is `ObjectInputFilter` and `ois`
    is an instance of `ObjectInputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: A filter returns a *status* (`java.io.ObjectInputFilter.Status`), which can
    be `ALLOWED`, `REJECTED`, or `UNDECIDED`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next problems, we will explore these statements via examples.
  prefs: []
  type: TYPE_NORMAL
- en: 135\. Implementing a custom pattern-based ObjectInputFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that we already have the `Melon` class and the helper methods for
    serializing/deserializing objects to/from byte arrays from *Problem 131*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a *pattern-based filter* via the `ObjectInputFilter` API can be done
    by calling the `Config.createFilter(String pattern)` method. For instance, the
    following filter rejects the `modern.challenge.Melon` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set this filter as a *stream-global filter* via `setSerialFilter()`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to get access to a *stream-global filter*, then we can call `getSerialFilter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Any stream deserialization in this application will pass through this filter,
    which will reject any instance of `modern.challenge.Melon`. You can practice this
    filter in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we want to set this on a specific stream, then we can
    modify our `Converters.bytesToObject()` method to accept a filter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass `null` as `filter`, then the filter will not be applied. Otherwise,
    the passed filter will be applied to the current stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `melonFilter` will reject deserialization and the output
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can also practice this filter in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 136\. Implementing a custom class ObjectInputFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that we already have the `Melon` class and the helper methods for
    serializing/deserializing objects to/from byte arrays from *Problem 131*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ObjectInputFilter` can be written via a dedicated class by implementing
    the `ObjectInputFilter` functional interface as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This filter is exactly the same as the *pattern-based filter*, `!modern.challenge.Melon`,
    only that it is expressed via Java Reflection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set this filter as a *stream-global filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, as a *stream-specific filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the `bytesToObject()` accepts an argument of type `ObjectInputFilter`
    and sets this filter accordingly (`ois` is the specific `ObjectInputStream`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `MelonFilter` will reject deserialization and the output
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can practice both approaches (*stream-global* and *stream-specific*) in
    the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 137\. Implementing a custom method ObjectInputFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that we already have the `Melon` class and the helper methods for
    serializing/deserializing objects to/from byte arrays from *Problem 131*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ObjectInputFilter` can be written via a dedicated method as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can add more filters in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set this filter as a *stream-global filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, as a *stream-specific filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the `bytesToObject()` accepts an argument of type `ObjectInputFilter`
    and sets this filter accordingly (`ois` is the specific `ObjectInputStream`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `Filters::melonFilter` will reject deserialization and
    the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can check out both approaches (*stream-global* and *stream-specific*) in
    the bundled code. Moreover, you can also practice another example that rejects
    all instances of `Melon` and its subclasses based on a *stream-global filter*.
  prefs: []
  type: TYPE_NORMAL
- en: 138\. Implementing a custom lambda ObjectInputFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume that we already have the `Melon` class and the helper methods for
    serializing/deserializing objects to/from byte arrays from *Problem 131*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ObjectInputFilter` can be written via a dedicated lambda and set as a *stream-global
    filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, as a *stream-specific filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 139\. Avoiding StackOverflowError at deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We plan to serialize the `mapOfSets` object as follows (I assume that `Converters.objectToBytes()`
    is well-known from the previous problems):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything works just fine until we try to deserialize `mapSer`. At that moment,
    instead of a valid object, we will get a `StackOverflowError` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The deserialization process got stuck in the `hashCode()` method of `Set`.
    The solution is to create a filter that will reject deserialization if the object
    has a graph depth bigger than 2\. This can be a *pattern-based filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, call the deserialization process with this filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: I assume that `Converters.bytesToObject()` is well-known from the previous problems.
    This time, instead of getting `StackOverflowError`, the deserialization is rejected
    by the filter.
  prefs: []
  type: TYPE_NORMAL
- en: 140\. Avoiding DoS attacks at deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Denial-of-service** (**DoS**) attacks are typically malicious actions meant
    to trigger, in a short period of time, a lot of requests to a server, application,
    and so on. Generally speaking, a DoS attack is any kind of action that intentionally/accidentally
    overwhelms a process and forces it to slow down or even crash. Let’s see a snippet
    of code that is a good candidate for representing a DoS attack in the deserialization
    phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We plan to serialize the `startList` object as follows (I assume that `Converters.objectToBytes()`
    is well-known from the previous problems):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Everything works just fine until we try to deserialize `startListSer`. At that
    moment, instead of a valid object, we will get…nothing! Actually, the application
    starts normally, but it just hangs there in the deserialization phase. The system
    slows down and, after a while, it will eventually crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object graph is too deep to be deserialized and that leads to a behavior
    similar to a DoS attack. The solution is to create a filter that will reject deserialization
    if the object has a graph depth bigger than a safe value. This can be a *pattern-based
    filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, call the deserialization process with this filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: I assume that `Converters.bytesToObject()` is well-known from the previous problems.
    This time, the deserialization is rejected by the filter and the DoS attack is
    prevented.
  prefs: []
  type: TYPE_NORMAL
- en: 141\. Introducing JDK 17 easy filter creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JDK 17, we can express filters more intuitively and readably
    via two convenient methods named `allowFilter()` and `rejectFilter()`. And, since
    the best way to learn is with an example, here is a usage case of these two convenient
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `allowMelonFilter()` relies on `ObjectInputFilter.allowFilter()` to allow
    only objects that are instances of `Melon` or subclasses of `Melon`. The `rejectMuskmelonFilter()`
    relies on `ObjectInputFilter.rejectFilter()` to reject all objects that are instances
    of `Muskmelon` or subclasses of `Muskmelon`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use each of these filters as you already know from the previous problems,
    so let’s tackle another use case. Let’s assume that we have the following hierarchy
    of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1.png](img/B19665_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: An arbitrary hierarchy of classes'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we want to deserialize only objects that are instances of
    `Melon` or subclasses of `Melon` but they are not `Muskmelon` or subclasses of
    `Muskmelon`. In other words, we allow deserializing instances of `Melon` and `Cantaloupe`.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply the `allowMelonFilter()`, then we will deserialize instances of
    `Melon`, `Muskmelon`, `Cantaloupe`, `HoneyDew`, and `Persian` since all these
    are `Melon`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we apply `rejectMuskmelonFilter()`, then we will deserialize
    instances of `Melon`, `Cantaloupe`, and `Pumpkin` since these are not `Muskmelon`.
  prefs: []
  type: TYPE_NORMAL
- en: But, if we apply `rejectMuskmelonFilter()` after applying `allowMelonFilter()`,
    then we will deserialize only `Melon` and `Cantaloupe`, which is exactly what
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intuitively, we may think to chain our filters by writing something like this
    (`ois` is the current `ObjectInputStream`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'But, this will not work! It will cause a `java.lang.IllegalStateException`:
    *filter cannot be set more than once*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution relies on `ObjectInputFilter.merge(filter, anotherFilter)`, which
    returns a filter that merges the status of these two filters by applying the following
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `filter` and get the returned `status`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the returned `status` is `REJECTED`, then return it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `anotherFilter` and get the returned `otherStatus`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `anotherStatus` is `REJECTED`, then return it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either `status` or `otherStatus` is `ALLOWED`, then return `ALLOWED`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, return `UNDECIDED`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nevertheless, if `anotherFilter` is `null`, the filter is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this logic, we can merge the status of `Filters.allowMelonFilter()`
    with the status of `Filters.rejectMuskmelonFilter()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s talk about JDK 17 Filter Factories.
  prefs: []
  type: TYPE_NORMAL
- en: 142\. Tackling context-specific deserialization filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 17 enriched the deserialization filter capabilities with the implementation
    of JEP 415, *Context-Specific Deserialization Filters*.
  prefs: []
  type: TYPE_NORMAL
- en: Practically, JDK 17 added the so-called Filter Factories. Depending on the context,
    a Filter Factory can dynamically decide what filters to use for a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a Filter Factory per application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to apply a Filter Factory to a single run of an application, then
    we can rely on the `jdk.serialFilterFactory` system property. Without touching
    the code, we use this system property at the command line as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `FilterFactoryName` is the fully qualified name of the Filter Factory, which
    is a public class that can be accessed by the application class loader, and it
    was set before the first deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a Filter Factory to all applications in a process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To apply a Filter Factory to all applications in a process, we should follow
    two steps (again, we don’t touch the application code):'
  prefs: []
  type: TYPE_NORMAL
- en: In an editor (for instance, Notepad or Wordpad), open the `java.security` file.
    In JDK 6-8, this file is located in `$JAVA_HOME/lib/security/java.security`, while
    in JDK 9+, it is in `$JAVA_HOME/conf/security/java.security`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit this file by appending the Filter Factory to the `jdk.serialFilterFactory` Security
    Property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying a Filter Factory via ObjectInputFilter.Config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, a Filter Factory can be set directly in code via `ObjectInputFilter.Config`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `FilterFactoryInstance` argument is an instance of a Filter Factory. This
    Filter Factory will be applied to all streams from the current application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Filter Factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Filter Factory is implemented as a `BinaryOperator<ObjectInputFilter>`. The
    `apply(ObjectInputFilter current, ObjectInputFilter next)` method provides the
    *current filter* and the *next* or *requested filter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see how it works, let’s assume that we have the following three
    filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Filters.allowMelonFilter()` is set as a *stream-global filter* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Filters.rejectMuskmelonFilter()` is set as a *stream-specific filter*
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the `Filters.packageFilter()` is set in the Filter Factory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MelonFilterFactory` is set via `ObjectInputFilter.Config` before any deserialization
    takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that everything is in place, let’s see what’s happening. The `apply()`
    method is called twice. The first time it is called is when the `ObjectInputStream
    ois` is created, and we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The *current filter* is `null`, and the *requested filter* is `Filters.allowMelonFilter()`.
    Since the *current filter* is `null` and the *requested filter* is not `null`,
    we decided to return a filter as the result of merging the status of the *requested
    filter* with the status of the `Filters.packageFilter()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second time the `apply()` method is called happens when the `ois.setObjectInputFilter(filter)`
    is called in `Converters.bytesToObject(byte[] bytes, ObjectInputFilter filter)`.
    We have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This time, the *current* and *requested filters* are not `null`, so we merge
    their statuses again. Finally, all filters are successfully passed and the deserialization
    takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 143\. Monitoring deserialization via JFR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Flight Recorder** (**JFR**) is an event-based tool for the diagnosis
    and profiling of Java applications. This tool was initially added in JDK 7 and,
    since then, it has been constantly improved. For instance, in JDK 14, JFR was
    enriched with event streaming, and in JDK 19, with filtering event capabilities,
    and so on. You can find all JFR events listed and documented per JDK version at
    [https://sap.github.io/SapMachine/jfrevents/](https://sap.github.io/SapMachine/jfrevents/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Among its rich list of events, JFR can monitor and record deserialization events
    (the deserialization event). Let’s assume a simple application like the one from
    *Problem 131* (the first problem of this chapter). We start configuring JFR for
    monitoring the deserialization of this application by adding `deserializationEvent.jfc`
    into the root folder of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Practically, this file instructs JFR to monitor and record the deserialization
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use `-XX:StartFlightRecording=filename=recording.jfr` to instruct JFR
    to record output in a file named `recording.jfr`, and we continue with `settings=deserializationEvent.jfc`
    to point out the configuration file listed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the final command is the one from this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2.png](img/B19665_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Running JFR'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this command is executed, you’ll see an output as in *Figure 6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3.png](img/B19665_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The output of our application'
  prefs: []
  type: TYPE_NORMAL
- en: 'JFR has produced a file named `recording.jfr`. We can easily view the content
    of this file via the JFR CLI. The command (`jfr print recording.jfr`) and the
    output are available in *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4.png](img/B19665_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The output of JFR containing deserialization information'
  prefs: []
  type: TYPE_NORMAL
- en: JFR produced a single deserialization event since our application has performed
    a single serialization/deserialization cycle of a `Melon` object. You can see
    the type of the object (here, `Melon`) via the `type` field. Since the `Melon`
    instance is not an array, the `arrayLength` was set to `-1`, which means that
    arrays are not applicable. The `objectReferences` represents the first object
    reference in the stream (so, `1`) and the `bytesRead` represents the number of
    bytes read from this stream (in this case, `78` bytes). We also see that there
    was no filter present, `filterConfigured = false`, and `filterStatus = N/A` (not
    applicable). Moreover, `exceptionType` and `exceptionMessage` are `N/A`. They
    are not applicable because there is no filter present. They are useful for capturing
    any exceptions caused by a potential filter.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the JFR CLI, you can use more powerful tools for consuming the deserialization
    event such as JDK Mission Control ([https://www.oracle.com/java/technologies/jdk-mission-control.html](https://www.oracle.com/java/technologies/jdk-mission-control.html))
    and the well-known Advanced Management Console ([https://www.oracle.com/java/technologies/advancedmanagementconsole.html](https://www.oracle.com/java/technologies/advancedmanagementconsole.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a bunch of problems dedicated to handling Java serialization/deserialization
    processes. We started with classical problems and moved on to cover JDK 17 context-specific
    deserialization filters passing through JDK 9 deserialization filters on the way.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1139613064111216156.png)'
  prefs: []
  type: TYPE_IMG
