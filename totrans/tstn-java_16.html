<html><head></head><body>
		<div id="_idContainer091">
			<h1 id="_idParaDest-285" class="chapter-number"><a id="_idTextAnchor315"/>16</h1>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor316"/>Deploying Java in Standalone Packages and Containers</h1>
			<p>In this last chapter, we will look at different ways to package and distribute a Java application. We have already seen JAR files for desktop applications and WAR files for web applications, along with how to deploy them. While this approach can be sufficient for deployment, there are situations where this traditional approach can be <span class="No-Break">improved upon.</span></p>
			<p>Java is big. There are numerous libraries in the Java SE distribution, although it is likely that your application only needs some of them. The same can be said for third-party or external libraries. Modern packaging using the Java module approach allows you to produce JAR or WAR files that only contain parts of a library that you <span class="No-Break">will use.</span></p>
			<p>In the case of web applications, this type of packaging can reduce the size of a WAR file to contain only the required modules from a required external library, rather than the entire library. In the case of desktop applications, it is required that the Java language must already be installed on a computer. The Java runtime is now modularized. This allows you to create executable applications that do not require an installed version of Java to run but, rather, include it as part of the <span class="No-Break">packaged installer.</span></p>
			<p>Finally, we will <a id="_idIndexMarker997"/>look at the Docker container system. Imagine a team of developers, each with different <strong class="bold">operating systems</strong> (<strong class="bold">OSes</strong>), working on an application. While Java is <em class="italic">write once, run anywhere</em>, it is sometimes advantageous to have every developer working in an identical environment. Docker containers help meet this need. Furthermore, you can deploy these containers to a cloud. While we will not look at cloud deployment, understanding how containers work prepares you for working within <span class="No-Break">the cloud.</span></p>
			<p>We will cover the following in <span class="No-Break">this chapter:</span><a id="_idTextAnchor317"/></p>
			<ul>
				<li>Exploring what modular <span class="No-Break">Java is</span></li>
				<li>Creating a custom JRE <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">jlink</strong></span></li>
				<li>Packaging with an installer <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">jpackage</strong></span></li>
				<li>Using the Docker <span class="No-Break">container system</span></li>
				<li>Working with <span class="No-Break">Docker images</span></li>
				<li>Creating a <span class="No-Break">Docker image</span></li>
				<li>Publishing <span class="No-Break">an image</span></li>
			</ul>
			<p>We will use a modified version of <strong class="source-inline">BankSwing</strong>, originally from <a href="B19088_13.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Desktop Graphical User Interface Coding with Swing and JavaFX</em>, and now renamed <strong class="source-inline">BankSwingJUL</strong> in this chapter, to explore modules and packages. To look at Docker, we will use <strong class="source-inline">JSF_FinancialCalculator</strong>, unchanged from the <span class="No-Break">previous chapter.</span></p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor318"/>Technical requirements</h1>
			<p>You’ll need the following for <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Java 17.</span></li>
				<li>A <span class="No-Break">text editor.</span></li>
				<li>Maven 3.8.6 or a <span class="No-Break">newer version.</span></li>
				<li><span class="No-Break">For </span><span class="No-Break"><strong class="source-inline">jpackage</strong></span><span class="No-Break">:</span><ul><li><strong class="bold">Windows</strong>: The WiX <span class="No-Break">toolset (</span><a href="https://wixtoolset.org/"><span class="No-Break">https://wixtoolset.org/</span></a><span class="No-Break">)</span></li><li><strong class="bold">Red Hat Linux</strong>: The <span class="No-Break"><strong class="source-inline">rpm-build</strong></span><span class="No-Break"> package</span></li><li><strong class="bold">Ubuntu Linux</strong>: The <span class="No-Break"><strong class="source-inline">fakeroot</strong></span><span class="No-Break"> package</span></li><li><strong class="bold">macOS</strong>: Xcode <span class="No-Break">command-line tools</span></li></ul></li>
				<li>Docker Desktop <a href="https://www.docker.com/">(https://www.docker.com</a>/). To use Docker, you will need to create an account. The free Personal account is sufficient. Once you have an account, you can download Docker Desktop. There is a version for <span class="No-Break">every OS.</span></li>
			</ul>
			<p>The sample code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter16"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter16</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor319"/>Exploring what modular Java is</h1>
			<p>Up to this point, we saw code in classes that consists of class fields and methods. Then, we grouped these <a id="_idIndexMarker998"/>classes into packages and, finally, as a JAR or WAR file. Modular Java <a id="_idIndexMarker999"/>introduces a new grouping called <strong class="bold">modules</strong>. A module is a JAR file but with a module descriptor. There is also an automatic <a id="_idIndexMarker1000"/>module that has a module name in its manifest file. This feature of Java is called the <strong class="bold">Java Platform Module </strong><span class="No-Break"><strong class="bold">System</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JPMS</strong></span><span class="No-Break">).</span></p>
			<p>Up until now, we used Maven to build our applications. Maven is a build tool that downloads any libraries we need and ensures that our code will compile successfully. What it does not do is determine whether all the required external libraries, such as Java itself, are present. Its primary job ends when the code successfully compiles. The JPMS, on the other hand, focuses on the libraries required to successfully run a program. Unlike Maven, JPMS checks that libraries coded as modules are present or will be present when the code runs. This leads to the question, what is <span class="No-Break">a module?</span></p>
			<p>A module is a JAR file. There are minor differences between a regular JAR file and a module JAR file. At a minimum, a module file must have a file named <strong class="source-inline">module-info.java</strong> in the <strong class="source-inline">src/main/java</strong> folder. One purpose of this file is to list the required modules. There may not be any required modules, but the presence of this file denotes that this project can be a module. Not every library coded in Java has been recoded to be a module, but many new libraries are coded this way. A module file can be used as an ordinary JAR file or as a module when using JPMS tools. You do not need two versions of <span class="No-Break">a library.</span></p>
			<p>At one time, there were two versions of Java available to users. There is the JDK that contains the JVM and all the required developer tools, such as the Java compiler. The second <a id="_idIndexMarker1001"/>version was the <strong class="bold">Java Runtime Edition</strong> (<strong class="bold">JRE</strong>). As its name implies, the JRE contains all the necessary libraries to run almost any Java program. The JRE was significantly smaller, coming in at around 90 MB, while the full JDK is around 300 MB. With the introduction of the JPMS, the JRE was no longer available as a download. Times change, and some Java distributions now contain a <span class="No-Break">JRE again.</span></p>
			<p>With the JRE significantly smaller than the JDK, what can modules do for us? The reason is related to why the JRE was dropped from Java distributions. With the JPMS, you can construct your own custom JRE, including only those modules you need. So, what are the modules in the Java language? In a terminal/console window, enter <span class="No-Break">the following:</span></p>
			<pre class="console">
java --list-modules</pre>
			<p>You will now get a list of every module. On my Windows 11 system, there are 71 modules listed – 22 that begin with <strong class="source-inline">java</strong> and 49 that begin with <strong class="source-inline">jdk</strong>. To build a custom JRE, you need <a id="_idIndexMarker1002"/>to know which modules your program uses. Retrieve from this chapter’s GitHub the <strong class="source-inline">BankSwingJUL</strong> project. The only difference from the <a href="B19088_13.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic">Chapter 13</em></span></a> version is that <strong class="source-inline">JUL</strong> replaces <strong class="source-inline">log4j2</strong>. I have done this to reduce the number of modules required to just those in the Java distribution. Build the project, and you should find in the <strong class="source-inline">target</strong> folder a JAR file named <strong class="source-inline">BankSwingJUL-0.1-SNAPSHOT.jar</strong>. Open a terminal/console window in the <strong class="source-inline">target</strong> folder and enter <span class="No-Break">the following:</span></p>
			<pre class="console">
jdeps BankSwingJUL-0.1-SNAPSHOT.jar</pre>
			<p>The output will begin with a summary of the Java modules you <span class="No-Break">will need:</span></p>
			<pre class="source-code">
BankSwingJUL-0.1-SNAPSHOT.jar -&gt; java.base
BankSwingJUL-0.1-SNAPSHOT.jar -&gt; java.desktop
BankSwingJUL-0.1-SNAPSHOT.jar -&gt; java.logging</pre>
			<p>The remainder of the output looks at every class in the project, showing you what Java classes you are using and what module they belong to. The <strong class="source-inline">java.base</strong> module is the home to the core set of classes. The <strong class="source-inline">java.desktop</strong> module is the home of Swing, while <strong class="source-inline">java.logging</strong> module is the home of JUL. Now, it’s time to create our <span class="No-Break">custom JRE.</span></p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor320"/>Creating a custom JRE with jlink</h1>
			<p>We will <a id="_idIndexMarker1003"/>use the <strong class="source-inline">jlink</strong> tool that is part of the Java JDK to <a id="_idIndexMarker1004"/>create our custom JRE. We will begin by creating a JRE that contains all the <span class="No-Break">required modules:</span></p>
			<pre class="console">
jlink --add-modules ALL-MODULE-PATH -<a id="_idTextAnchor321"/>-output jdk-17.0.2-jre
      --strip-debug --no-man-pages --no-header-files
      --compress=2</pre>
			<p>This is one line. In Linux, you can enter a multiline command using the backslash (<strong class="source-inline">\</strong>), while in Windows, you use the caret (<strong class="source-inline">^</strong>). The output of this command will be a folder named <strong class="source-inline">jdk-17.0.2-jre</strong> that contains a JRE of only 76 MB. This is smaller than the original JRE, but we do not want all the Java modules; we just need three. Here is our <span class="No-Break">new command:</span></p>
			<pre class="console">
jlink --add-modules java.base,java.desktop,java.logging
      --output jdk-17.0.2-minimaljre --strip-debug
      --no-man-pages --no-header-files --compress=2</pre>
			<p>We will now have a new JRE in the <strong class="source-inline">jdk-17.0.2-minimaljre</strong> folder that is only 41 MB. Now, we need <a id="_idIndexMarker1005"/>to use our custom JRE with our application. To test whether our JRE is working, you can execute the application by first opening <a id="_idIndexMarker1006"/>a terminal/console window in the <strong class="source-inline">bin</strong> folder of the custom JRE you have created. Issue the following command to run your code. Take note that the paths are for Windows, so they must be adjusted for Linux <span class="No-Break">or Mac:</span></p>
			<pre class="console">
java.exe -jar C:\dev\Packt\16\BankSwingJUL\target\
  BankSwingJUL-0.1-SNAPSHOT.jar</pre>
			<p>This is a single-line command. If all is well, your <strong class="source-inline">BankSwingJUL</strong> app will run. Now, it’s time to wrap up the application into a single executable file that contains both our application and the JRE. This will allow us to distribute our applications without requiring the recipient of our program to first <span class="No-Break">inst<a id="_idTextAnchor322"/>all Java.</span></p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor323"/>Packaging with an installer using jpackage</h1>
			<p>With our custom JRE created, we are now ready to create a custom installable package. You can <a id="_idIndexMarker1007"/>create these for Windows, Linux, or Mac. You must <a id="_idIndexMarker1008"/>use the OS that is the target of your package. In addition, there are additional steps for <span class="No-Break">each OS.</span></p>
			<p>Windows requires you to install the WiX toolset. You can find this at <a href="https://wixtoolset.org/">https://wixtoolset.org/</a>. Download the latest version and install it. When you run <strong class="source-inline">jpackage</strong>, it will produce an EXE file. You can distribute this file, and when run, it will install all that is necessary to run the program in the <strong class="source-inline">C:\Program Files</strong> directory. An executable EXE file will be in the folder, and this is how you will run <span class="No-Break">your program.</span></p>
			<p>Linux users, depending on the version they are using, will need the <strong class="source-inline">rpm-build</strong> or <strong class="source-inline">fakeroot</strong> package. When you run <strong class="source-inline">jpackage</strong>, it will produce a DEB file for Debian Linux or an RPM file for other distros. You can distribute this file, and when run, it will install all that is necessary to run the program in the <strong class="source-inline">/opt/application-name</strong> directory. An executable file will be in the folder, and this is how you will run <span class="No-Break">your program.</span></p>
			<p>Mac users <a id="_idIndexMarker1009"/>require the Xcode command-line tools. When you run <strong class="source-inline">jpackage</strong>, it will produce a DMG file. You can distribute this file, and when <a id="_idIndexMarker1010"/>run, it will install all that is necessary to run the program in the <strong class="source-inline">/Applications/application-name</strong> directory. An executable file will be in the folder, and this is how you will run <span class="No-Break">your program.</span></p>
			<p>In all three cases, it is not necessary to have Java installed. Even if you do, you will be using the <span class="No-Break">custom JRE.</span></p>
			<p>To create an installer package with <strong class="source-inline">jpackage</strong>, you simply enter the following on the <span class="No-Break">command line:</span></p>
			<pre class="console">
jpackage --name BankSwingJUL
  --input C:\dev\Packt\16\BankSwingJUL\target
  --main-jar BankSwingJUL-0.1-SNAPSHOT.jar
  --runtime-image C:\dev\Packt\16\jre\jdk-17.0.2-minimaljre
  --dest C:\temp</pre>
			<p>This is a single-line command. Here is a rundown of <span class="No-Break">the parameters:</span></p>
			<ul>
				<li><strong class="source-inline">--name</strong>: The name of the executable file with <strong class="source-inline">-1.0</strong> added. Use <strong class="source-inline">–app-version</strong> followed by a version designation to <span class="No-Break">override this.</span></li>
				<li><strong class="source-inline">--input</strong>: The location of the JAR file you <span class="No-Break">are packaging.</span></li>
				<li><strong class="source-inline">--main-jar</strong>: The name of the JAR file that contains the class with the <strong class="source-inline">main</strong> method. If you do not have a <strong class="source-inline">MANIFEST.MF</strong> file in your JAR file that lists the class with a <strong class="source-inline">main</strong> method, you can use <strong class="source-inline">–main-class</strong>, followed by the name of the class that contains the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> method.</span></li>
				<li><strong class="source-inline">--runtime-image</strong>: This is the path and name of the JRE folder you created <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">jlink</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">--dest</strong>: By default, the packaged application will be found in whatever folder you issued the <strong class="source-inline">jpackage</strong> command. You can choose the folder you want with <span class="No-Break">this parameter.</span></li>
			</ul>
			<p>Upon the <a id="_idIndexMarker1011"/>successful conclusion of this command, you will <a id="_idIndexMarker1012"/>have an executable package that will install your program, with an executable file to <span class="No-Break">run it.</span></p>
			<p>Web applications depend on an application server and not the JRE to run. For this reason, we cannot use <strong class="source-inline">jpackage</strong>. This is where our next choice for packaging comes in, the <span class="No-Break">Docker container.</span></p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor324"/>Using the Docker container system</h1>
			<p>Docker is a platform-as-a-service system that allows you to construct an image of a running application that can run in a virtualized Linux container. These images can be run on any <a id="_idIndexMarker1013"/>computer that supports Docker containers. This includes Windows and Linux distributions. This image can contain everything necessary to run the program. In this section, we will create an image with a Java application server, a Java JDK, and our <strong class="source-inline">JSF_FinancialCalculator</strong> web application and deploy it in a container. Why this is significant is that most cloud providers, such as AWS, support the deployment of cloud applications in Docker containers. We will not be discussing cloud deployment, as the various cloud providers work differently. What they share is the use <span class="No-Break">of Docker.</span></p>
			<p>The first step is to install the Docker system. The easiest way is to download and install the Docker <a id="_idIndexMarker1014"/>Desktop system from <a href="https://www.docker.com/">https://www.docker.com/</a>. There is a version each for Windows, Mac, and Linux, and they contain a GUI interface as well as command-line tools. On a Windows 10 or 11 system that supports WSL2, the command-line tools are available in both, a Windows terminal and a WSL2 Linux Terminal. This means that, except for how paths to files are described, all commands work the same on all OSes. Now, take a moment and <span class="No-Break">install Docker.</span></p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor325"/>Working with Docker images</h1>
			<p>While we could build an image from scratch, there is another way. Many organizations that create <a id="_idIndexMarker1015"/>software that is destined for the cloud make available pre-built images. To these images, we can add our application. In our case, we want a pre-built image with Java 17 and an application server. We will use an image from Payara. This company provides a server based on GlassFish, with enhancements in both an open source community version and a commercial <span class="No-Break">paid version.</span></p>
			<p>Images on Docker Hub may have been created for malicious reasons. While Docker provides a service to scan for vulnerabilities, you should also scan any executable files in an image for potentially malicious behavior. The Docker plan you have signed up for determines how many images you can pull from or push to the Hub. With the free Personal subscription, you may have an unlimited number of public repositories you can push, but you are restricted to no more than 400 image pulls a day. The commercial subscriptions increase the number of pulls from the repository and can carry out vulnerability scans on <span class="No-Break">your image.</span></p>
			<p>Start Docker Desktop. It comes with an image and container that contains a basic web server that has the documentation pages for Docker. We will do most of our setup on the command line, while the desktop GUI is useful for seeing what the state of Docker images and <span class="No-Break">containers are.</span></p>
			<p>The first step is to download the image we will modify by adding the <strong class="source-inline">JSF_FinancialCalculator</strong> application. We will use this program unchanged from the previous chapter. Here is <span class="No-Break">the command:</span></p>
			<pre class="console">
<a id="_idTextAnchor326"/>docker pull payara/server-full:6.2023.2-jdk17</pre>
			<p>If you visit <a href="https://hub.docker.com/r/payara/server-full/tags">https://hub.docker.com/r/payara/server-full/tags</a>, you can see all the versions of the Payara server available. As you can see from the previous command, we are pulling the <strong class="source-inline">server-full:6.2023.2-jdk17</strong> image that contains both the server and Java 17. In Docker, a successful command returns a long stream <span class="No-Break">of digits.</span></p>
			<p>Now, we need to run this image in a container. While you can run multiple containers, network applications that use TCP ports can result in conflicts. For this reason, I recommend stopping any containers that are currently running. Using the Docker Desktop, select the container list from the menu and look for any containers listed as <strong class="bold">Running</strong>, and then stop them by clicking on the square button in the <strong class="bold">Actions</strong> column. You can also stop a container by entering the following at the <span class="No-Break">command line:</span></p>
			<pre class="console">
docker stop my_container</pre>
			<p>Here, <strong class="source-inline">my_container</strong> is replaced by the name of a running container <span class="No-Break">or image.</span></p>
			<p>We now want to wrap this image in a container and run <span class="No-Break">the image:</span></p>
			<pre class="console">
docker run --name finance -p 8080:8080 -p 4848:4848
            payara/server-full:6.2023.2-jdk17</pre>
			<p>This is a single-line command. The <strong class="source-inline">--name</strong> switch allows you to assign a name to the container. If you leave this switch out, Docker will assign a random name. The <strong class="source-inline">-p</strong> switch maps a port <a id="_idIndexMarker1016"/>in the container to a port of the computer. In this example, we are mapping to the same port. The name of the image is the same as the name of the image we pulled down. Assuming that there were no errors, you can now test the container. Go to your browser and first visit the Payara home page by entering <strong class="source-inline">http://localhost:8080</strong>. Next, visit the admin console page at <strong class="source-inline">https://localhost:4848</strong>. You may get a warning from your browser, as the TLS certificate is self-signed. Ignore the warning and you should get to the sign-in page. The username and password are <span class="No-Break">both </span><span class="No-Break"><strong class="source-inline">admin</strong></span><span class="No-Break">.</span></p>
			<p>Under <strong class="bold">Payara Server Console – Common Tasks</strong>, look for the <strong class="bold">Deployment</strong> section and select <strong class="bold">Deploy an Application</strong>. Other than some changes in the background colors, the admin console is practically identical to GlassFish. When you select <strong class="bold">Deploy</strong>, you can select <strong class="bold">Choose File</strong> under <strong class="bold">Packaged File to Be Uploaded to the Server</strong>. You want to upload the WAR file from the <strong class="source-inline">JSF_FinancialCalculator</strong> example in the previous chapter, which you can find in the project’s <span class="No-Break"><strong class="source-inline">target</strong></span><span class="No-Break"> folder.</span></p>
			<p>You can now verify that the application has been properly deployed by entering in your browser <strong class="source-inline">http://localhost:8080/JSF_FinancialCalculator</strong>. The name of the project must match the name of the WAR file. If all works and the calculator opens in your browser, you can now create your own container based on the <strong class="source-inline">payara/server-full:6.2023.2-jdk17</strong> image, which will contain the calculator app insta<a id="_idTextAnchor327"/>lled on <span class="No-Break">the server.</span></p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor328"/>Creating a Docker image</h1>
			<p>Now, we are <a id="_idIndexMarker1017"/>ready to create our own image. First, we need to stop the container we <span class="No-Break">just used:</span></p>
			<pre class="console">
docker stop finance</pre>
			<p>In a terminal/console, enter the following command to create your new container, which will contain the <span class="No-Break">Payara image:</span></p>
			<pre class="console">
docker create --name transition -p 8080:8080
         -p 4848:4848 payara/server-full:6.2023.2-jdk17</pre>
			<p>The name <strong class="source-inline">transition</strong> is arbitrary and can be anything you want. You now have a new container based on the Payara image. We want to modify this container to include the calculator application. The first step is to run this <span class="No-Break">new container:</span></p>
			<pre class="console">
docker start transition</pre>
			<p>The most common error that occurs here is if another container is listening to the same ports. Ensure that any containers or images with Payara are not running. The Docker Desktop app can show you which containers or images <span class="No-Break">are running.</span></p>
			<p>Just as we did when we tested the Payara image, use your browser to open the admin console of Payara. Now, deploy the <strong class="source-inline">JSF_FinancialCalculator</strong> WAR file to the server. Verify that it is running successfully by visiting the application’s <span class="No-Break">web page.</span></p>
			<p>Now, make the change to the image in the container, the addition of the web app, permanent by entering <span class="No-Break">the following:</span></p>
			<pre class="console">
docker commit transition</pre>
			<p>There is one last step. Enter <span class="No-Break">the following:</span></p>
			<pre class="console">
docker images</pre>
			<p>You will see an entry with <strong class="source-inline">&lt;none&gt;</strong> for both <strong class="source-inline">REPOSITORY</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">TAG</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
REPOSITORY  TAG     IMAGE ID       CREATED          SIZE
&lt;none&gt;      &lt;none&gt;  c0236a80bba3   52 minutes ago   618MB</pre>
			<p>To resolve this, and as the final step in creating an image, assign a tag name and image ID by entering <span class="No-Break">the following:</span></p>
			<pre class="console">
docker tag c0236a80bba3  transition-image</pre>
			<p>Take note that <a id="_idIndexMarker1018"/>the hexadecimal number that must be used can be found in the table from the previous <strong class="source-inline">docker images</strong> command. When you run <strong class="source-inline">docker images</strong> after <strong class="source-inline">docker tag</strong>, the table will show <span class="No-Break">the following:</span></p>
			<pre class="source-code">
REPOSITORY        TAG     IMAGE ID    CREATED      SIZE
transition-image  latest  c0236a80bba 32 hours ago 618MB</pre>
			<p>You now have a configured image in your local repository. For anyone to use your image, you must publish it on the Docker <span class="No-Break">Hub website.</span></p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor329"/>Publishing an image</h1>
			<p>As already noted, for security reasons, any image you use as the basis of a new image must be scanned <a id="_idIndexMarker1019"/>for vulnerabilities, especially any executable code in the image. The free Personal tier allows you to have an unlimited number of public images. The paid tiers support private images. The first step in publishing is to create a repository on the Hub. To do this, open your browser and go to <a href="https://hub.docker.com/">https://hub.docker.com/</a>. Sign into your account <span class="No-Break">if needed.</span></p>
			<p>Next, select <strong class="bold">Repositories</strong> from the choices at the top of the web page. You will now see any repositories you may have already created. Click on <strong class="bold">Create repository</strong>. On this page, you must fill in the form, entering a name for the container along with an optional description. It also shows your Docker username. Ensure that <strong class="bold">Public</strong> is the choice for the <span class="No-Break">repo type.</span></p>
			<p>Now, you can push your image to the Hub. There are <span class="No-Break">three steps:</span></p>
			<ol>
				<li>Log in to <span class="No-Break">Docker Hub:</span><pre class="source-code">
<strong class="bold">docker login --username my_username</strong></pre></li>
			</ol>
			<p>Replace <strong class="source-inline">my_username</strong> with your Docker username. You will now be asked for your password. You will receive confirmation of a <span class="No-Break">successful login.</span></p>
			<ol>
				<li value="2">Next, you need to change the tag for your image, <strong class="source-inline">transition-image</strong>, to match the name of the repository you created, <strong class="source-inline">omniprof/transitioning_to_java</strong>. The name consists of your username and the name of <span class="No-Break">the repository:</span><pre class="source-code">
<strong class="bold">docker tag transition-image omniprof/</strong>
<strong class="bold">  transitioning_to_java</strong></pre></li>
				<li>Now comes the final step, pushing your image into <span class="No-Break">the Hub:</span><pre class="source-code">
<strong class="bold">docker push omniprof/transitioning_to_java</strong></pre></li>
			</ol>
			<p>To determine <a id="_idIndexMarker1020"/>whether you were successful, visit Docker Hub and select <strong class="bold">Repositories</strong>. This time, you will see your repository <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">omniprof/transitioning_to_java</strong></span><span class="No-Break">.</span></p>
			<p>You now have a Docker image that can be shared with your team <span class="No-Break">or clients.</span></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor330"/>Summary</h1>
			<p>In this chapter, we looked at what modular Java means. We took advantage of the fact that Java itself has been modularized. This allows you to construct a JRE with <strong class="source-inline">jlink</strong> that is significantly smaller than the JDK. You can even make it smaller by only including the modules your code <span class="No-Break">depends on.</span></p>
			<p>We then looked at two ways to distribute your code. The first employed <strong class="source-inline">jpackage</strong> to create an installer for your application. The installer can include your custom JRE and will install your program, along with an executable file to run the application. This is usually the best way to distribute <span class="No-Break">desktop applications.</span></p>
			<p>The second distribution method uses the Docker container system. Docker allows us to construct and publish an image that includes not only our code and a JDK but also any other programs required. In our example, the extra program was an application server to which the finance application was installed. The images we construct are published to a repository, such as Docker Hub. Anyone running Docker on any OS can now pull our image and have it run in a <span class="No-Break">Docker container.</span></p>
			<p>This also leads us to the end of this book. My goal was to provide a reference to experienced developers in need of learning about and understanding Java. There is still much to learn, but my hope is that this book has put you on the <span class="No-Break">right path.</span></p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor331"/>Further reading</h1>
			<ul>
				<li><em class="italic">Multi-Module Maven Application with Java </em><span class="No-Break"><em class="italic">Modules</em></span><span class="No-Break">: </span><a href="https://www.baeldung.com/maven-multi-module-project-java-jpms"><span class="No-Break">https://www.baeldung.com/maven-multi-module-project-java-jpms</span></a></li>
				<li><em class="italic">Java Platform, Standard Edition – Packaging Tool User’s </em><span class="No-Break"><em class="italic">Guide</em></span><span class="No-Break">: </span><a href="https://docs.oracle.com/en/java/javase/14/jpackage/packaging-tool-user-guide.pdf"><span class="No-Break">https://docs.oracle.com/en/java/javase/14/jpackage/packaging-tool-user-guide.pdf</span></a></li>
				<li><em class="italic">Docker </em><span class="No-Break"><em class="italic">docs</em></span><span class="No-Break">: </span><a href="https://docs.docker.com/"><span class="No-Break">https://docs.docker.com/</span></a></li>
			</ul>
		</div>
	</body></html>