- en: 'Chapter 5: Exploring the Most Common Development Models'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will position some of the notions we have discussed so far
    into a more complete picture. We are going to elaborate on the most common development
    models. We've already seen the importance of designing proper architectures, how
    to collect requirements, and how to translate the architectural ideas into code
    solutions that answer those requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The software development models that we will see in this chapter revolve around
    all of those aspects (and some more), arranging them in proper and tested ways,
    to achieve different results or emphasize certain areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Code and Fix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Glancing at the Waterfall model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Agile methodology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Lean software development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Scrum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about other Agile practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding DevOps and its siblings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When discussing development models today, everybody goes all-in with **DevOps**
    and **Agile** techniques. While I do endorse all this enthusiasm for those approaches,
    my personal experience says that it's not that easy to apply them correctly in
    all the different contexts. For this reason, it's important to know many different
    approaches and try to get the crucial lessons from each one. Even if you do not
    have the ideal conditions for working with DevOps, it doesn't mean that you cannot
    use some of the good ideas associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will have an overview of the most widespread
    development models, along with their pros and cons. This will help you choose
    the right model, depending on your project needs.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let's start with the naive development model (or a *non-model*, if
    you want), that is, **Code and Fix**.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Code and Fix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me get to the point as soon as possible – Code and Fix is not a model. It
    is something more akin to anarchy. The whole concept here is about diving into
    coding with no planning at all. For this reason, it is called Code and Fix. In
    this, you completely skip all the crucial phases highlighted hitherto (requirements
    collection, architectural design, modeling, and so on) and start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Then, if things go wrong, such as there are bugs or the software does not behave
    as expected, you start fixing. There is no dedicated time for writing documentation,
    nor for **automation** and **unit testing**. Versioning of the code is naive,
    and so is the dependency between modules (or maybe everything is stuck in just
    one huge module).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, there are few, if any, advantages to adopting this non-model.
    Let''s start with the (obvious) disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You are basically working against whoever will maintain the code (perhaps your
    future self). All the quick fixes and workarounds that you will stick into your
    code will come back to bite you when you need to touch it again. This phenomenon
    is usually known as **technical debt**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since you are not analyzing requirements properly, you risk wasting effort working
    on a feature that does not provide any value to the customer and the final user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration between developers in the team, and with external teams, is hard,
    as there is no clear separation of duties (hence, Code and Fix is also known as
    **cowboy coding**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's hard to estimate the time needed to complete a release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, it''s easy to say that adopting Code and Fix is not advisable at all. But
    surprisingly enough, it is still very widespread. These are the main reasons for
    its widespread application:'
  prefs: []
  type: TYPE_NORMAL
- en: Small teams with no dedicated roles (or with just one developer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lack of skills and experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lack of time (not a good excuse at all, as a bit of structure will probably
    save time anyway)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, Code and Fix can be partially justified when working on very small
    projects that will not require any maintenance or evolution, such as prototypes
    or projects with a defined, short lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth noticing, before diving into more complex and complete techniques,
    that embracing such methodologies is not a warranty of a successful project, and
    implementing Scrum, DevOps, or whatever you like is not going to be the perfect
    way to avoid a technical debt. Indeed, the software development methodologies
    are suggestions on how to give cadence on a project and what are the meaningful
    splits of roles and responsibilities, as seen in other projects. But it's ultimately
    the responsibility of the project team (and yours, as an architect) to ensure
    that the methodology (if any) is correctly used and that no pieces are left behind,
    in terms of technical debt, code quality, and project scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, the natural step after Code and Fix is to provide a bit of structure,
    sequentially, which is known as the **Waterfall** model.
  prefs: []
  type: TYPE_NORMAL
- en: Glancing at the Waterfall model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As has been said, the Waterfall model is a structured development model based
    on a sequence of different phases. This means that each phase begins when the
    previous one has ended.
  prefs: []
  type: TYPE_NORMAL
- en: The Waterfall model probably stems from the application of project management
    practices coming from other kinds of projects, such as constructing buildings
    or manufacturing objects. Indeed, while I am no expert on them, it's easy to understand
    that in order to build a house, you have to precisely follow a sequence of steps,
    such as calculating the materials and weights, building foundations, and constructing
    walls.
  prefs: []
  type: TYPE_NORMAL
- en: The Waterfall model originated from a number of different articles and lectures
    (with the most important coming from Winston Royce) and has also been ratified
    in an official document by the **US Department of Defense**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The phases in the Waterfall model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirement management**: You probably have a very good idea of what this
    phase entails, as per [*Chapter 2*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034),
    *Software Requirements – Collecting, Documenting, Managing*. In the Waterfall
    model, the requirement specification must be completed and formally accepted before
    proceeding with the next phase, while we discussed how, usually, an iterative
    approach is more natural.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analysis/design**: Sometimes defined as two different phases, the goal is
    to start from system requirements and then define the solution architecture to
    satisfy them. As in the previous phases, whoever is in charge of the next phase
    must formally accept the deliverables coming from this phase (such as system blueprints,
    diagrams, and pseudocode) in order for the process to continue. This basically
    means that developers must clearly understand what they are supposed to implement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation**: In this phase, the development team, starting from requirements
    and from the deliverables produced in the previous phase, must write the code
    to implement a proper software solution. This phase is, of course, crucial, and
    the correct completion of this phase basically means the success of the whole
    project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: As seen before, the acceptance of the deliverables coming from
    the preceding step is part of each phase. With testing, the approval is so important
    (and so complex) that it overlaps with the whole phase. The Waterfall model does
    not specifically distinguish between different kinds of testing, but this phase
    is commonly intended as **user acceptance testing**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations/maintenance**: This is the final step, facilitated by technical
    activities ensuring the proper setup of the solution in a production environment,
    as well as all the planned and unplanned activities to keep it operating properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates the phases of the Waterfall model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The Waterfall phases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – The Waterfall phases
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Waterfall model is a big jump when starting from Code and
    Fix, as we are starting to see a clearer distinction of what should be done in
    each phase.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages of the Waterfall model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Waterfall software development model is still widely used. Some of the
    advantages of this model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a clear definition of phases, hence planning is rather easier. Even
    though the phases should not overlap, it flows sequentially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mechanism encourages a proper handover between teams, including a formal
    acceptance between one phase and the following, giving greater control over planning
    and project quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, as you probably already know, there are some disadvantages to this
    methodology:'
  prefs: []
  type: TYPE_NORMAL
- en: The first and most evident disadvantage is the lack of flexibility. If you implement
    the Waterfall model entirely, you should not start implementing it before requirements
    have been collected in their entirety and the design has been carried out in full.
    In the real world, this is unlikely to happen; as we have seen, the requirement
    collection keeps flowing and the architecture design evolves while we face (and
    resolve) implementation issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, the software that we are building is seen and tested once implementation
    is complete. This means that you will not receive feedback on your code until
    very late in the project (maybe too late).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this reason, the Waterfall model has undergone several transformations,
    usually shortening the feedback loop, or cycling and jumping between phases (such
    as adding more requirements while implementing or managing defects identified
    during the testing phase). But while this model is still used, more flexible methodologies
    are now widespread, as they offer a less risky approach to development, and it
    all starts with Agile methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Agile methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Agile** methodology is a galaxy of best practices and techniques. A lot
    of still widely used methodologies inspired Agile (such as **Scrum** and **Kanban**),
    but the official birth of the movement stems from the *Agile Manifesto*, published
    in 2001\. The four very popular key concepts (values) of the *Agile Manifesto*
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Individuals and interactions* over processes and tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working software* over comprehensive documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Customer collaboration* over contract negotiation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Responding to change* over following a plan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While some of the preceding points can be misinterpreted and result in bad
    behaviors, such as ditching documentation and planning, it''s enlightening to
    think about such simple but powerful advice. Also, be careful that the manifesto
    itself advocates against complete anarchy as a result of the following note:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"While there is value in the items on the right, we value the items on the
    left more."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: The values on the left here are the ones mentioned at the beginning of each
    value and refer to *freedom* (such as working software), while the ones on the
    right are the ones at the end, referring to *discipline* (such as comprehensive
    documentation).
  prefs: []
  type: TYPE_NORMAL
- en: This part is often foreseen by teams looking into Agile methodologies as an
    excuse to skip the boring parts of the development process. The Agile process
    appreciates freedom but does not preclude some level of order.
  prefs: []
  type: TYPE_NORMAL
- en: There is moreover a very important observation to make while introducing the
    topic of Agile. The Agile methodology, and all its implementations described in
    this chapter, consider it crucial to have the customer (or the business owner,
    in other words, who is paying for the project) be aware of the methodology and
    willing to be part of it. Indeed, it's common to see in the following *The Agile
    principles* section the advice and principles involving the customers, as they're
    an active part of the software development project by providing inputs and feedbacks
    in many steps of the process. For such a reason, the adoption of an Agile practice
    will not be possible if the customer does not agree (implicitly or explicitly)
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: The *Agile Manifesto* further details the basic values of Agile by providing
    a list of principles.
  prefs: []
  type: TYPE_NORMAL
- en: The Agile principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As opposed to Waterfall, Agile bets everything on collaboration (within the
    team, and with customers too) and releases small chunks of working software often
    with a view to getting feedback early and adapting planning if necessary. Instead
    of trying to foresee everything and plan accordingly, Agile teams focus on quickly
    adapting to changing conditions and acting subsequently. This is well detailed
    in the Agile principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Our highest priority is to satisfy the customer through early and continuous
    delivery of valuable software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Welcome changing requirements, even late in development. Agile processes harness
    change for the customer's competitive advantage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deliver working software frequently, from a couple of weeks to a couple of months,
    with a preference for the shorter timescale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business people and developers must work together daily throughout the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build projects around motivated individuals. Give them the environment and support
    they need and trust them to get the job done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most efficient and effective method of conveying information to and within
    a development team is face-to-face conversation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working software is the primary measure of progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agile processes promote sustainable development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sponsors, developers, and users should be able to maintain a constant pace indefinitely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous attention to technical excellence and good design enhances agility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplicity – the art of maximizing the amount of work not done – is essential.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best architectures, requirements, and designs emerge from self-organizing
    teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At regular intervals, the team reflects on how to become more effective and
    then tunes and adjusts its behavior accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may see, other best practices are stressed in these principles, such
    as focusing on good architecture, privileging simple solutions, and building motivated
    teams. Of course, those are the general ideas. Before and after the publishing
    of the manifesto, a number of practices have been built around similar topics.
    In the next section, we will talk about Lean software development, a practice
    often associated with Agile development, which has its roots in the manufacturing
    industry.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Lean software development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lean software development** is a framework developed after the manufacturing
    method of the same name, which, in turn, is derived from the **Toyota Production
    System**. The interesting concept regarding this topic, indeed, is how it translates
    best practices from industrial production into software production. This is also
    due to the experience of one of the authors (Mary Poppendieck) in this context.
    She worked in the manufacturing industry and had the opportunity to learn about
    the production processes in a factory context directly.'
  prefs: []
  type: TYPE_NORMAL
- en: We will quickly cover a selection of the principles of Lean software development
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating waste
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Waste is a concept directly mutated from the Toyota Production System. Basically,
    waste is everything that costs resources without giving any value to the finished
    product.
  prefs: []
  type: TYPE_NORMAL
- en: Taking it to the extreme, in software development, everything that is not related
    to analysis or coding could be a waste. This can be seen as another point of view
    in the **simplicity** Agile principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify waste in software development, Lean software development suggests
    looking into its seven main areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partially done work**: This area relates to non-completed or non-released
    features. This means accumulating code, which has to be maintained, without providing
    any utility to the final customer. Moreover, since incomplete work is never proven
    in production, you can never be 100% sure that everything works as expected. You
    can also take into account the fact that releasing the software, which we are
    building in production, is the only way to understand whether such code is valuable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A famous paper by Ron Kohavi states that just one-third of the implemented features
    provide positive impacts, while the rest are neutral or even negative. The only
    way to figure it out is to release the code in production and see the feedback
    of real customers using it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra Processes**: This refers to bureaucracy. This means paperwork, approval
    processes, and similar issues. We all know that there are things that just can''t
    be skipped, such as security checklists and handoff documents for production release.
    Often, however, those processes are overcomplicated and overengineered. This area
    should be looked at for simplifications or even automation where relevant. Instead
    of manually answering security-related questions, maybe you could just run automated
    tests, as an example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extra features**: This is a very common pitfall. Perhaps in the requirement
    analysis, we are just pushing more and more features without any specific thoughts
    on whether those are useful or not. Or maybe, when implementing a new feature,
    it''s just so easy to add a similar one, which nobody is asking for but *can be
    useful sooner or later*. This is just wrong. Even if the code is easy to add,
    it must be maintained, or else it can potentially introduce bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task switching**: Now, it''s common sense to know that context switches are
    time-consuming. That is particularly true in software development, where you have
    a lot of things to sort out, from setting up your environment (although this can,
    and should, be automated), to focusing on project structure and code standards,
    and recalling the team dynamics and latest updates. It is basically as painful
    as it seems, yet very tempting to juggle multiple projects at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Waiting**: This is a very common thing to relate to. We end up waiting for
    a number of reasons, such as the environment being created and an analysis being
    completed. While the technical stuff can be mitigated by automation, from a project
    management standpoint, it is way harder to plan everything to ensure synchronized
    handoffs between teams. To act against waiting, you may be tempted (or forced)
    to help out on other tasks and projects, while this can easily transform into
    other waste (as per the previous point, task switching is not the best idea).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motion**: As introduced previously, we have handoffs between different teams.
    That''s the concept of motion. The longer it takes, the more waste you will have.
    This includes having a huge amount of back and forth, or simply too many teams
    cooperating. Handoffs not only include the exchange of artifacts (such as source
    code) but knowledge in general (such as documents or simply answers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defects**: Everybody knows what a bug is and how much time it can take to
    find the causes and solve it. Of course, it''s just impossible to write software
    without any bugs. But there are things you can do to reduce the impact of bugs,
    such as improving test coverage (including code analysis), which will end up saving
    time by identifying issues before they move into a snowball effect. Also, as has
    already been discussed, the sooner you go into production, the sooner you will
    find bugs (and have the opportunity to enrich your test suite).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify waste in your software production cycle, the Lean software development
    framework provides a very useful tool called **Value Stream Mapping**.
  prefs: []
  type: TYPE_NORMAL
- en: Value Stream Mapping is used to observe the software development process from
    an external point of view, mapping all the steps necessary (and the waiting time
    between them) for a requirement to go from inception to production release (usually
    known as the time to market).
  prefs: []
  type: TYPE_NORMAL
- en: You are supposed to track down this simply with paper and pencil. After tracking
    down the whole software cycle, you usually end up figuring out that the majority
    of the time is lost in waiting or in other types of waste, as per the previous
    list. Now that you have some quantitative data, with good executive sponsorship,
    you can act by changing the flow to maximize the time spent delivering value and
    minimizing waste. This will usually include simplifying approval processes and
    automating manual steps. The efficiency that can be attained here is mind-blowing.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding as late as possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is all about being open to changes. Especially when making expensive
    choices, it is good to defer the decision as much as possible, as more information
    may come to light to support the choice. Moreover, making a decision later will
    reduce the risk of having to get back to redoing part of the work owing to a wrong
    decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are more subtle implications in this principle. What comes to
    my mind is the mythical quote from Donald Knuth:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Premature optimization is the root of all evil."*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that if you make choices (especially hard to undo choices) too soon,
    you may end up making the wrong choice because of a lack of information, or simply
    wasting time with a topic that will end up not being that relevant. So, one strong
    piece of advice from the Lean software development framework is that you shouldn't
    commit to everything unless you have to, stay open and flexible, and defer from
    making complex decisions until you have no alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Translated in the software world, there are a number of different ways to do
    this, such as using stubs instead of real systems (before deciding which system
    to use), defining modular options (to facilitate the switching of different implementations),
    and using feature flags (to elicit specific behaviors directly in production).
    Just make sure that you find the right trade-off to avoid piling up waste. Implementing
    tens of different behaviors because you don't know what the final decision will
    be is, of course, not an option, but there are middle grounds.
  prefs: []
  type: TYPE_NORMAL
- en: A rule of thumb is usually to avoid planning for years or even months in advance.
    It's better to end up with very detailed planning for the upcoming weeks, which
    will become less and less detailed going forward in time.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering as fast as possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a concept that I've emphasized a lot, so I will keep it as concise as
    possible. Organizing the delivery work in small chunks is key. That's what *fast*
    refers to. You have to plan for releasing often. This will do for having feedback
    early and perfecting your strategy on the go.
  prefs: []
  type: TYPE_NORMAL
- en: There are several pieces of advice here, such as having a regular rate of release
    (both in terms of the time window and in terms of the number of features) and
    moving from a push to a pull approach (there will be more on this when we discuss
    it in the *Kanban board* section). Personally, I think the most important thing
    is to avoid keeping the team overloaded. Having some spare capacity will allow
    the team to work more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the whole product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated previously, optimization is tempting but not necessarily always the
    answer. The thinking here is about approaching the process (and the system) as
    a whole. Optimizing just one of the subparts (or the subprocess) may indeed have
    adverse effects on the final result. Let me explain this with the aid of two practical
    examples (in the process and system area):'
  prefs: []
  type: TYPE_NORMAL
- en: It may be tempting to reduce the testing phase to improve the time to market.
    However, if you have a holistic approach, the time spent on fixing bugs will probably
    be bigger than the saving. And we are not taking into account the impacts of bugs,
    such as downtimes, bad reputation, and customer churn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may consider optimizing the disk usage of your application in many ways,
    such as compressing files or using special formats (such as binary). But this
    may, of course, come at the cost of a slower reading so, overall, it may not be
    a good idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros and cons of Lean development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen, Lean is the first practical implementation of the Agile concepts.
    For that reason, the advantages over more structured methodologies (such as the
    Waterfall model, which we have already seen) are evident:'
  prefs: []
  type: TYPE_NORMAL
- en: A greater flexibility, meaning that changes in the planning and requirements
    are better tolerated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced freedom for the teams, where they may choose what works for them locally,
    that is, both technologically and from an organizational point of view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shorter feedback cycle, which means faster time to market and understanding
    sooner how your software performs (as discussed in [*Chapter 4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089),
    *Best Practices for Design and Development*, when talking about Minimum Viable
    Products)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages of Lean development will definitely vary, based on the team
    composition and the project complexity. Some common ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lean is more of a set of principles (part of the broader set of Agile principles),
    rather than a structured methodology. This means that the outcome may be less
    predictable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a further consequence, it doesn't usually work well with less-skilled teams,
    as it requires high maturity and greatly delegates decisions to each team member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of big projects, the modularization for being worked by many small
    lean teams is accomplished, while the methodology can scale well. It's also hard
    to keep track of the greater picture and synchronize between each team and subproject.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding as late as possible means that some architectural decisions are delayed
    too much. As a consequence, from time to time, some rework may happen (because
    of wrong choices or simply the lack of any choice).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned about Lean software development, which is a framework
    full of good ideas, practices, and tools.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen a walk-through of a lot of valuable ideas, such as waste reduction,
    openness to changes, holistic optimization, and fast feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that there is a bit of overlap and mutual influence between the
    different philosophies in the Agile spectrum. Let's now switch to another well-known
    one – Scrum.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Scrum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Scrum** methodology was launched by Ken Schwaber and Jeff Sutherland in
    a paper published in 1995\. The authors were also involved in the creation of
    the *Agile Manifesto* a bit later, so some of those ideas are directly linked.
  prefs: []
  type: TYPE_NORMAL
- en: Scrum differs slightly from Lean software development because, more than principles
    and high-level advice, it focuses directly on roles, project cadence (via the
    so-called *events*), and rules. The authors stress the fact that while you can
    customize the technique a bit, Scrum is intended to be *all or nothing*, meaning
    that you should accept and practice all the key components before embarking on
    a Scrum project.
  prefs: []
  type: TYPE_NORMAL
- en: Scrum refers to a phase of rugby and is regarded as an analogy for a cohesive,
    cross-functional team, pushing together to pursue a common objective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will see the fundamental elements of Scrum: the team composition
    (roles and responsibilities), the events (meetings and other key appointments
    of a Scrum project), and artifacts (the tool supporting the Scrum methodology).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the team setting.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Scrum teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Scrum teams are kind of a self-sufficient ecosystem. This means having
    all the skills needed to deliver tasks (or, in other words, being a cross-functional
    team), and being self-organized (as long as the team satisfies expectations, it
    can follow its own rules). The Scrum methodology identifies three main roles:
    the **Scrum master**, the **product owner**, and the members of the development
    team.'
  prefs: []
  type: TYPE_NORMAL
- en: Development team
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The development team, as you can imagine, is the one that will *hands-on* complete
    the assigned tasks, in the form of implemented and testable features. It is, by
    design, a flat team (no hierarchy or sub-teams are allowed) and has all the skills
    needed to complete the tasks (meaning that you can suppose it will not only include
    developers but also security experts, DBAs, and everyone else that should be needed).
  prefs: []
  type: TYPE_NORMAL
- en: As said, the development team is autonomous in terms of technical choices but
    is accountable (as a whole) for the outcomes of those choices. One of the main
    discussions centers on development teams when Scrum is applied to large enterprise
    environments. Indeed, often, the enterprise has guidelines and policies that have
    to be respected and, in this sense, are limiting the development team's freedom.
    Moreover, the need for different kinds of skills may lead to variability in the
    team's composition (with people temporarily moving between different projects),
    and that is a mechanism that needs to be sometimes facilitated and monitored,
    as schedule clashes may occur.
  prefs: []
  type: TYPE_NORMAL
- en: Product owner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **product owner** is essentially responsible for the development pace. The
    product owner is the person committed to selecting the working items from a bunch
    of to-dos (also known as the Product Backlog, as we have briefly seen in [*Chapter
    4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089), *Best Practices for Design
    and Development*, when talking about User Story Mapping), and understand which
    items must be implemented and when.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about the Product Backlog soon, in the *Understanding Scrum
    artifacts* section, but for now, you can imagine how crucial this task is in terms
    of customer expectations, and how important it is to choose tasks with the right
    rationales to maximize overall throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Scrum Master
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Scrum Master** is basically the sponsor and advocate of the Scrum methodology,
    both internally to the team and externally to the rest of the organization. Their
    role is to mentor the junior members of the team and, generally, anyone who is
    not an expert in the methodology.
  prefs: []
  type: TYPE_NORMAL
- en: If the organization is adopting Scrum at scale, all Scrum Masters create community-exchanging
    best practices on how to achieve results better. Scrum Masters are responsible
    for facilitating the jobs of the other members of the team by circumventing the
    blockers that prevent the team from performing at their full potential. The Scrum
    Master and the product owner are two different roles, and they should be filled
    by different individuals.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll be looking at Scrum Events.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Scrum Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scrum Events** are the institutionalized project''s recurring appointments
    that set the pace of overall implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Scrum Events are instrumental to a project's success by providing the opportunity
    for the planning, execution, and reviewing of the work that needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: The basic unit of measure of this pace in Scrum is the Sprint.
  prefs: []
  type: TYPE_NORMAL
- en: Sprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **Sprint** in Scrum is a recurrent iteration, time-boxing a set of development
    activities. A Sprint is usually considered a mini project, with a fixed timeframe
    of 2–4 weeks. During the Sprint, there is a fixed set of goals that cannot be
    changed, and they are picked from the development team in the way they want.
  prefs: []
  type: TYPE_NORMAL
- en: A Sprint is essentially used to implement Agile best practices for working iteratively
    by releasing working software often and in small batches. This is, of course,
    very useful in reducing risks. If there is a shift in priorities, or something
    else goes wrong, your biggest risk in terms of resources is to lose one Sprint's
    worth of effort.
  prefs: []
  type: TYPE_NORMAL
- en: Sprint planning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sprint planning** is, of course, the meeting at which the whole Scrum team
    reunites to choose what will be done during a particular Sprint. The product owner
    clarifies the priorities and the features to be implemented by looking at the
    Product Backlog. Then, in accordance with the development team (and facilitated
    by the Scrum Master), the **Sprint Goal** is defined.'
  prefs: []
  type: TYPE_NORMAL
- en: The Sprint goal is usually one or more consistent features, representing the
    objectives for the Sprint. The Sprint goal is then defined as a set of workable
    items, picked from the Product Backlog. Those items, and the way to achieve them
    (which is the responsibility of the development team to define), constitute the
    Sprint Backlog.
  prefs: []
  type: TYPE_NORMAL
- en: Daily Scrum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **daily Scrum** is a short meeting held every day of the Sprint by the development
    team. It's usually set up at the beginning of the workday, with a duration of
    15 minutes (this is just a rule-of-thumb time slot; it may more or less depend
    on the team size and project complexity). The Scrum Master and product owner can
    join, but the meeting is led by the development team.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to stick to Sprint planning. While there is no fixed agenda, it
    is usually aimed at reviewing the activities from the day before, planning activities
    for the current day, and addressing any issue that may put the Sprint goal at
    risk. Ideally, the daily Scrum should be the only sync meeting for the day, thereby
    boosting the development team's productivity. However, in the real world, it is
    not unusual for development teams to have follow-up meetings to address particularly
    complex issues.
  prefs: []
  type: TYPE_NORMAL
- en: The daily Scrum is also called a *standup meeting*, a naming that is also used
    in other Agile project methodologies. The reason behind it is that (in theory)
    it should be done standing up, giving further motivation to the participants to
    make it quicker (it will be uncomfortable to stand up for an hour during a boring
    meeting) and to stay active and participate during the meeting.
  prefs: []
  type: TYPE_NORMAL
- en: Sprint review
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Sprint review** is a recurrent meeting held at the end of each Sprint.
    The entire Scrum team participates, and relevant business stakeholders are invited
    by the product owner. The development team has a demo of what was implemented
    during the Sprint, if possible. There is then a question-and-answer session to
    address doubts and discuss any issues that arose, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This is also an opportunity to discuss Product Backlog based on current circumstances.
    This may also include changing priorities. Other *all hands* discussions may occur
    as well, such as budget, planning, resources, and similar topics. All those interactions
    usually provide valuable inputs for the next Sprint planning.
  prefs: []
  type: TYPE_NORMAL
- en: Sprint retrospective
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Sprint retrospective** is a meeting lasting a few hours that takes place
    after the Sprint review and before the Sprint planning. The meeting involves the
    entire Scrum team. The goal is to focus on what went well and what needs to improve
    by looking at the previous Sprint. This meeting is usually focused more on processes,
    tools, and team interactions. This is also often used as a team-building activity.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noticing that there is a difference between the review and the retrospective.
    The Sprint review is focused on what has been implemented (the product); it includes
    a demo, and the business stakeholders are present and an active part of it. The
    focus is then on *what* we have done. In the retrospective, the business stakeholders
    may or may not be invited, and the focus is on *how* we have done whatever we
    have done. In other words, the spotlight is on the Scrum team, the interactions,
    and the processes. We may discuss the adopted tools, the choice of frameworks,
    the architecture, or simply what we liked and didn't like about how we worked
    in our last Sprint.
  prefs: []
  type: TYPE_NORMAL
- en: The Sprint retrospective meets a common goal of most Agile methodologies, which
    is continuous improvement. We will come back to this concept later when talking
    about Kaizen.
  prefs: []
  type: TYPE_NORMAL
- en: Backlog refinement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Backlog refinement** is usually a continuous process, more than a fixed appointment.
    The objective of refinement is reviewing items in the Product Backlog (the project''s
    to-do list; there will be more on this in the *Understanding Scrum artifacts*
    section). This is done by the product owner and the development team (or part
    of the development team). They cooperate to detail the items (basically, analyzing
    technical aspects and revisiting requisites) and refine the estimation (which
    is the responsibility of the development team).'
  prefs: []
  type: TYPE_NORMAL
- en: Priority shifting may happen. Usually, the items with the highest priority (which
    are likely to happen in the next one or two Sprints) are supposed to be the clearer
    ones, while the lower-priority items are expected to be reviewed again. In practice,
    those activities are completed by the team in one or two fixed appointments per
    Sprint. Scrum suggests using less than 10% of the team's capacity in this sense.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be learning about Scrum artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Scrum artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scrum artifacts** are tools supporting the Scrum activities. This methodology
    refers to such tools as a way to implement transparency. In this sense, those
    artifacts should be available to all the teams and the relevant stakeholders.'
  prefs: []
  type: TYPE_NORMAL
- en: While digital supports are commonly used, the use of physical items (such as
    whiteboards and sticky notes) to encourage brainstorming and in-person collaboration
    is also widespread. The work produced with physical tools should then be digitized
    for tracking and sharing purposes. Let's now see what those tools are, starting
    with the Product Backlog, followed by the Spring Backlog.
  prefs: []
  type: TYPE_NORMAL
- en: Product Backlog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already referred to the **Product Backlog** a couple of times, so by
    now you probably already have an idea of what it is, more or less. In simple terms,
    the Product Backlog is the single source of truth for each thing that should happen
    in the product, meaning new features, bug fixes, and other developments (improvements,
    refactoring, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: These are categorized, including a description, unique ID, priority, and the
    effort required. The effort is constantly evaluated and refined by the development
    team. Items in the Product Backlog may be attached to test cases and other details,
    such as mockups and more. The product owner is ultimately accountable for the
    Product Backlog.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Product Backlog is the funnel ingesting requests to be implemented
    by the development team, it can be regarded as an *infinite scroll*, meaning that
    new items will continuously be added to it. As already discussed in [*Chapter
    4*](B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089), *Best Practices for Design
    and Development*, the **User Story Mapping** technique can be considered a variation
    or evolution of the Product Backlog, adding more information and dimensions to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Sprint Backlog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Sprint Backlog** is the chunk of work to be done during each Sprint.
    It comprises the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Sprint goal**, being the feature (sub-feature, or set of features) that
    we aim to add to the product as a result of the Sprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of items selected from the Product Backlog that need to be implemented
    in order to achieve the Sprint goal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A plan for implementing those items during the Sprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's the way to keep work structured at a consistent pace in Scrum.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages of Scrum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be evident, at this point, that Scrum is a very well-structured methodology
    (while still being flexible and adhering to Agile principles). For this reason,
    it is so widespread, up to the point that there are professional certifications
    available and plenty of job positions for experienced Scrum professionals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantages of adopting Scrum could be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The roles and responsibilities are very well defined, leaving less room for
    conflicts and misunderstandings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a defined timetable and some predictable moments in which updates (and
    deliverables) are shared with the rest of the team (and made visible to management).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easier to do the planning (even with some expected flexibility and inaccuracy)
    and have visibility on what's completed and what is left almost constantly (also
    thanks to the concept of backlog and, in general, to the Scrum artifacts).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Scrum disadvantages are similar to the ones in the other Agile and Lean
    methodologies. The following comes to mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The structured process flow and events could be seen as boring and time-intensive,
    especially when working with highly experienced teams or in long-term projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The coordination of multiple Scrum teams working on different projects may be
    complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bigger teams (with more than nine people) usually don't work well in a Scrum
    setup (hence, they should be modularized into smaller teams, and coordination
    will be a downside, as per the previous point).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you have learned in this section, Scrum is a simple but disciplined way to
    structure the software development process. And due to its simplicity and effectiveness,
    it has become widespread. So, I hope the information shared in this section has
    motivated you to learn more and to apply Scrum principles to your projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see some more Agile practices that are not directly
    linked with Scrum or any other particular framework but are often used complementarily.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about other Agile practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen the Agile methodologies and had a quick overview of the
    Lean software development principles and the Scrum framework. All of those ideas
    are often complemented by a number of practices and tools useful for completing
    specific phases.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll learn about some of those tools, namely, Kaizen, Planning
    Poker, Kanban boards, and Burndown charts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with Kaizen.
  prefs: []
  type: TYPE_NORMAL
- en: Kaizen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Kaizen** is a principle directly borrowed from the Toyota Production System,
    which, as we have seen, is a core inspiration for Lean software development. *Kaizen*
    comes from the Japanese word for *continuous improvement*.'
  prefs: []
  type: TYPE_NORMAL
- en: This simple concept is the essence of Kaizen, which articulates it with a comprehensive
    and elegant philosophy, embodying the concepts of humanization of the workplace,
    constant change (the opposite of big-bang, huge transformations). It is also responsible
    for identifying and removing waste (as we discussed in the *Introducing Lean software
    development* section), encouraging valuable feedback (both internal and external),
    involving all individuals in the organization (from top managers to lower levels),
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Another core concept of Kaizen (again, very close to some of the Agile principles
    seen so far) is the shift in the testing process (in a broad sense, as in inspecting
    the quality of the product) from the end of production to an ongoing process,
    once again getting feedback early to minimize drift and facilitate constant optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kaizen is often orchestrated as a loop of five recurring phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observe**: This phase is used to understand what issues should be solved
    (or which aspect can be improved).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Plan**: This phase is used for setting measurable objectives for achievement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do**: This phase is used for putting into practice actions to meet those
    measurable objectives.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Check**: This phase is used for comparing actual results with expected objectives.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Act**: This phase is used for adjusting (or complementing) the plan to enhance
    the results and start the loop again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates these phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The OPDCA loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – The OPDCA loop
  prefs: []
  type: TYPE_NORMAL
- en: While nicely summarized by the *continuous improvement* concept as seen, Kaizen
    contains a lot of sage advice and ideas, very close to the whole idea of Lean
    and Agile.
  prefs: []
  type: TYPE_NORMAL
- en: Planning Poker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Planning Poker** is an estimation technique, often used as part of the Scrum
    framework (but not a mandatory part of the framework itself). When used in Scrum,
    Planning Poker is done as part of Sprint planning to estimate (or refine the estimation
    of) the items from the Backlog.'
  prefs: []
  type: TYPE_NORMAL
- en: Planning Poker is a way of getting an estimation of the effort of a given item,
    and it works by inciting the participant to provide a size with no influence from
    the other team members.
  prefs: []
  type: TYPE_NORMAL
- en: Poker is played by a team of estimators (usually the development team, which
    will then implement the features), a moderator, and a responsible project participant
    (which is usually the product owner if the Scrum methodology is used, or otherwise
    someone with a knowledge of the overall project and roadmap, such as a project
    manager or other senior staff).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each estimator team member has a deck of cards (or, commonly, a mobile app)
    used to represent a difficulty grade. There is no standard here; it is common
    to use a Fibonacci progression, but your mileage may vary. The Fibonacci sequence
    has a reasoning behind it: the more the number grows, the more distant they are
    from each other, and so your choice must be more thoughtful. Another commonly
    used unit is the t-shirt size (*S*, *M*, *L*, *XL*, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: Also, the expressed value (being a card, a number, or a t-shirt size) may directly
    map to time (as in days to implement) or not.
  prefs: []
  type: TYPE_NORMAL
- en: When the meeting starts, the moderator acts as a note-taker and master of ceremonies.
    They read each feature to estimate and start a discussion to clarify the meaning
    by including estimators and the product owner. Then, the estimators select a unit
    (by drawing a card, picking a number, or a size) simultaneously (to avoid influencing
    each other), indicating the estimated difficulty. If there is no consensus, the
    owner of the highest and lowest estimation has to explain their point of view.
    Then, everybody again draws a card until a consensus is reached. Consensus rules
    can be customized, such as having a defined maximum gap from a perfect average
    or having team members that will own that development to agree on what's an acceptable
    stop.
  prefs: []
  type: TYPE_NORMAL
- en: Kanban board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Kanban board**, in the software development world, is a visual way to represent
    the flow of items, from the ingestion to the development team to the implementation.
    It is a subset of the **Value Stream Map** (as seen in the *Introducing Lean software
    development* section). Kanban is indeed inspired by, and adapted from, the Toyota
    Production System.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplistic implementation, a Kanban board is a whiteboard (physical
    or digital), with three vertical swim lanes splitting it into **TO DO**, **DOING**,
    and **DONE**. Each item is represented as a sticky note moving between those lanes.
    However, it is common to customize it by adding different columns (such as splitting
    **DOING** into **Design**, **Code**, and **Test**), or horizontal swim lanes (to
    represent concepts such as priority by having a kind of fast lane for urgent things
    such as production issues). The following diagram illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A Kanban Board'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – A Kanban board
  prefs: []
  type: TYPE_NORMAL
- en: Kanban boards are just an artifact part of a bigger philosophy (Kanban), which
    is applied both to software development and industrial production (as Lean).
  prefs: []
  type: TYPE_NORMAL
- en: While describing the entire philosophy is beyond the scope of this book, there
    are at least a couple of concepts worth mentioning. The first is **Work In Progress**
    (**WIP**). This is the number of open items that the team is working on. WIP is
    easily tracked and visualized on the board. As per the Lean methodology, Kanban
    advises against using context switching; hence, a constraint on WIP should be
    present at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept is **pull**. Basically, the Kanban approach puts the
    working items at disposal of the development team (in the **TO DO** column). As
    opposed to the push paradigm, the team chooses (pulls) what to do at their own
    pace. This avoids hogging the team and maximizes throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Burndown chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Burndown chart** is a common artifact (physical or digital) to clearly show
    a project's progression. It is very useful, regardless of which Agile methodology
    is used, because it gives real-time insights into planning. As has been mentioned,
    Agile is against detailed, advanced planning, so having a current snapshot of
    the project's progression (and maybe some forecasting) is precious for management.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Burndown chart plots the tasks (usually as a sum of the required effort)
    as the vertical axis and the timeline as the horizontal axis. Drawing a line from
    the top left (project start) to the bottom right (project completion) provides
    an ideal, linear progression. At regular times (such as every day, or at the end
    of each Scrum Sprint), a dot is plotted that crosses the implemented tasks and
    the current moment in time. The following diagram is an example of a Burndown
    chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A Burndown chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – A Burndown chart
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, by drawing a line over those dots, you can compare the ideal
    project progression versus the actual project's progression. Roughly speaking,
    if the real project progression is above the ideal one, you are probably late,
    whereas if it's below, you are ahead. Having minimal deviations from the ideal
    progression means staying on track, and it's usually a good indicator of a project's
    health. Also, it gives good hints on when the project (or, at least, the represented
    list of tasks) will be completed.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen a nice list of tools that can provide you with
    support in Agile software development. Regardless of the methodology you are using,
    if any, such tools can be useful in addressing common use cases, such as optimizing
    processes and estimating development effort.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about a very hot and debated topic, which
    seems to be getting all the attention lately – DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding DevOps and its siblings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, **DevOps** is an overinflated term. It is seen as a
    silver bullet for every development problem, and a mandatory prerequisite for
    being considered cool. I'm not going to decrease the hype about DevOps, as I truly
    believe it's a precious technique useful for ensuring functional and high-performing
    teams. However, it must be said that DevOps is more a set of best practices, rather
    than a well-codified, magic recipe. And, as is common in these cases, one size
    does not fit all.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps can be seen as essentially an extension of Agile methodologies. Indeed,
    the adoption of Agile practices (not one specifically) can be seen as a prerequisite
    of DevOps. And, in turn, DevOps is considered to be an essential condition for
    the adoption of cutting-edge approaches such as **microservices** (more on this
    in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230), *Designing Cloud-Native
    Architectures*).
  prefs: []
  type: TYPE_NORMAL
- en: The essential characteristic of DevOps is cooperation between different roles.
    This commonly means, in practical terms, a small team, encompassing all the different
    skills needed to build and maintain a software product in production.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover some core aspects of the DevOps movement, such
    as team composition, roles and responsibilities, and variants of DevOps, which
    are about including more functions in this collaboration method. But let's start
    with a common consideration covered in DevOps regarding team size.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps team size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to team size, the Scrum guide says that a team should be small
    enough to stay lean but large enough to develop a reasonable number of features
    in each Sprint. A common rule of thumb is to have a team of around 10 or fewer
    people.
  prefs: []
  type: TYPE_NORMAL
- en: This rule of thumb is commonly accepted and has echoes in other stories, such
    as the famous two pizzas team, which states that it should be possible to feed
    the team with two large pizzas (so, again, roughly fewer than 10 people).
  prefs: []
  type: TYPE_NORMAL
- en: This depends on the logic of links. In a functional team, each team member should
    have a link with the others. This means that in a team of 10 people, you will
    have 90 links. That's the reason why the team should not grow much above 10, or
    else you will have too many internal interactions to manage, which quickly impacts
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: '*But what about the internal team''s responsibility?*'
  prefs: []
  type: TYPE_NORMAL
- en: Roles and responsibilities in a DevOps team
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As is obvious from the name, DevOps aims at blurring the responsibilities between
    developers and operations. This does not mean that everybody should be capable
    of doing everything; it is more about having a shared goal.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most hateful dynamics in IT teams is the lack of accountability in
    case of issues.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly involved teams are Ops, who are the operations and system
    engineers responsible for the infrastructure (and for the uptime of production
    systems), and Devs, which are, well, the developers, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Ops will always blame Devs' buggy code when something goes wrong in production,
    and Devs will throw code at Ops for releasing without caring about the release
    outcome, to the battle cry of *works on my machine*.
  prefs: []
  type: TYPE_NORMAL
- en: While these dynamics are purposefully exaggerated, you can agree that the relationship
    between Devs and Ops is not always the best. DevOps starts here. Everybody is
    accountable for production – *you build it, you run it*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the team (and the individuals) must shift from a skill perspective
    (I'm a specialist only accountable for my limited piece) to a product perspective
    (my first responsibility is to have a fully functional product in production,
    and I will use my skills for this goal). The goal of this is to build high-quality
    products (everybody is committed to a fully functional production service) in
    less time (you eliminate handovers between different departments).
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking apart the philosophy and motivations behind DevOps, there are some direct
    technological impacts, which can be seen both as a prerequisite and fundamental
    benefit of adopting DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pervasive automation**, also known as **infrastructure as code**: Everything,
    including environment definitions, should be declarative, versioned (usually in
    a code versioning system such as **Git**), and repeatable. This avoids drifting
    (environments strictly adhere to the expected configurations) and reduces the
    time for recovering from failures (it''s easy to spin up new copies of the environment).
    This is something usually driven by the team members with prevalent Ops skills.
    It is common, in this regard, to see a shift toward **Site reliability engineering**
    practices, meaning that Ops will intentionally use an increasing part of their
    time to develop automation and other production support tools, instead of doing
    exclusively production-related tasks (even manually).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shifting quality into software development**: This means embedding all the
    feedback coming from production exposure into software development. This often
    means increasing observability (to support troubleshooting and performance tuning
    in production), improving code testing (to reduce the defects found in production),
    and everything that''s necessary for safer, high-quality production releases (such
    as automated rollbacks in case of failures, supporting auto-scaling, and modularizing
    releases).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is now safe to try to extend this philosophy beyond Devs and Ops.
  prefs: []
  type: TYPE_NORMAL
- en: Devs, Ops, and more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is natural to try to extend such good practices, such as borderless collaboration
    (breaking silos) and tooling support (automating everything) beyond development
    and operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**DevSecOps** is a clear example of that. This is all about shifting security
    concerns into all phases of product development. This means, of course, integrating
    security specialists in the DevOps team. Very often, the approach to security
    is to run specific tests against the finished product soon before (or shortly
    after) the production release. The result is that, often, it''s too late and maybe
    you don''t have the time (or it''s costly) to fix the security findings.'
  prefs: []
  type: TYPE_NORMAL
- en: At the opposite end, DevSecOps impacts the production process in several ways.
    The first is to embed best practices in the development of code, then to automate
    testing against security principles and rules, and lastly, continuously check
    compliance with those principles as part of production operation practices. This
    extension is particularly well accepted in highly regulated environments (such
    as banks, government institutions, and healthcare), and it has a positive impact
    in terms of the time to market and overall security.
  prefs: []
  type: TYPE_NORMAL
- en: '**BizDevOps** is another variant, breaking another wall and making business
    owners (analysts, budget owners, and even marketing) part of the team. The collaboration
    model used here is less structured than with Devs and Ops (and security, if you
    want), since some of the activities are not perfectly overlapped, nor comprehensible
    between technicians and business people.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you think about it, Agile methodologies (and DevOps, by extension)
    inherently encourage cooperation with business by emphasizing short and frequent
    feedback loops, and openness to changes in the product life cycle. What's probably
    a distinct characteristic of BizDevOps is the crossed visibility on KPIs.
  prefs: []
  type: TYPE_NORMAL
- en: This includes the technical team having insights into business KPIs (things
    such as budget, the number of users, sales trends, and more) in order to try to
    figure out how technical choices (new releases, changes in the infrastructure,
    and resource efficiency) impact on it. And it's also true the other way around;
    that is, the business team could have a look at the technical teams' *tuning wheels*
    (the size of the team, resources, and the number of changes) and how they impact
    the end-to-end process, in terms of development speed, costs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, **NoOps** is a trending topic, gaining visibility as a result of the
    assonance with DevOps. As it's easy to imagine, the idea here is to get rid of
    the Operations team completely. While it is theoretically possible, as a result
    of using heavily automated environments such as **Platform as a Service** and
    **Cloud** (there is more on this in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*), to have developers capable of basic Ops
    tasks, such as the provisioning of new environments and deployments, *I strongly
    believe NoOps is a dead end (at least for the foreseeable future)*. It can be
    applied when reducing Ops resources in small contexts (such as serverless applications;
    this topic will be discussed in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*), but this seems more like outsourcing.
    You basically do not need to care about the infrastructure because someone else
    is taking care of it for you (a cloud provider, or maybe another department).
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I feel such an approach is completely the opposite of DevOps. You
    will end up having a huge gap between platform users (Devs) and the team running
    the infrastructure (Ops, which are indeed not even part of the project).
  prefs: []
  type: TYPE_NORMAL
- en: DevOps and the bigger organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A model that is commonly seen as a large-scale implementation of DevOps is the
    **Spotify** development model, which is famous because it has been created and
    used in the homonym company building the music streaming app.
  prefs: []
  type: TYPE_NORMAL
- en: Even though, in their seminal work, theorized in a publicly available paper
    entitled *Scaling Agile @ Spotify*, there is no mention of the word *DevOps*,
    you can recognize some common principles.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the link to the full paper in the *Further reading* section. For
    now, it's enough to consider that DevOps must solve the conflicting needs of having
    a multidisciplinary team focused on delivery (and production quality) with knowledge
    and best practice sharing. In the Spotify model, this is resolved with a matrix
    organization, in which individuals belong to one team (so-called *squads* and
    *tribes*) with product-delivery purposes but share interests with people of the
    same skills (such as DBAs or frontend developers) for knowledge sharing and personal
    growth purposes (in the so-called *chapters* and *guilds*).
  prefs: []
  type: TYPE_NORMAL
- en: The Spotify model suggests a number of other mechanisms for boosting collaboration.
    It's an interesting point of view and gives some practical advice. However, considering
    that every organization is different, and has different challenges and strengths,
    so the first piece of advice is flexibility. No model will simply work out of
    the box; you have to look at the company's objectives and people skills and keep
    adapting to changing conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We anticipated some impacts of DevOps, both in positive and negative ways,
    in the previous sections. However, to summarize, here are some advantages of adopting
    a DevOps model:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a high-performance methodology, meaning that, when working properly, it
    enables us to deliver high-quality software frequently. Hence, it's rapidly responding
    to changing conditions, such as new requirements or production issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It copes well (and often is seen as a requirement) with modern architectures,
    such as cloud-based and microservices applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's challenging and rewarding for team members, meaning that there is a lot
    of room for learning, as each team member can easily enrich his/her skills and
    responsibilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The disadvantages can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a huge paradigm shift and can be hard to accept for more traditional organizations,
    as it requires many people to get out of their comfort zone and start thinking
    about their role in a different way (stretching everybody's responsibilities).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may be difficult to map from an organizational point of view, as it will
    require breaking the traditional silos and setting up cross-department, product-oriented
    teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires highly skilled and motivated team members. It may be stressful in
    the long term.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this section, we have completed our overview of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen what the founding principles of such a methodology are and why
    it claims to boost efficiency, along with some of the variants, such as DevSecOps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will have a look at some examples and case studies.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies and examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will model an ideal Product Backlog in the Scrum way, applied
    to our mobile payments example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official Scrum guide does not provide any example of a Product Backlog,
    and there are no standards as regards the fields that should be included. Based
    on my personal experience, a Product Backlog should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Mobile payments Product Backlog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B16354.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Mobile payments Product Backlog
  prefs: []
  type: TYPE_NORMAL
- en: 'This is, of course, just a small subset, but several considerations can be
    made:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Items are identified by ID and DESCRIPTION**: Most likely, **ID** will link
    to a detailed requirements document or at least a more detailed description. Also,
    every item is likely categorized as part of a bigger user **STORY**. As discussed
    previously, User Story Mapping is a different way to visualize this kind of relationship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Items are categorized**: Usually, at least features and fixes are categorized,
    while more types, such as enhancements and technical terms (for things such as
    refactoring and other internal tasks), may be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: This is a way to help choose items through the links to other
    items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effort**: This is something that may be roughly evaluated when adding items
    to the backlog. However, this is likely to change over time when more details
    will be known.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see some similarities with the requirements template seen in [*Chapter
    2*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034), *Software Requirements –
    Collecting, Documenting, Managing*, and indeed the goals are similar. However,
    a different level of detail is evident, as those two artifacts have different
    goals in the project cycle.
  prefs: []
  type: TYPE_NORMAL
- en: With this simple example, we have covered all the topics relevant to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen a complete overview of the development models.
    Starting with the more traditional approaches, such as Code and Fix and Waterfall,
    we then moved to the core of the chapter, focusing on Agile.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, Agile is a broad term, including more structured frameworks
    (such as Scrum) and other tools and best practices (such as Lean and some other
    techniques, such as Kanban), which can be mixed and matched to better suit the
    needs of other projects. As a last big topic, we discussed DevOps (and some extensions
    of it). While not being a well-codified practice, the huge potential of this approach
    is clear, which is now seeing widespread adoption in many innovative projects.
    DevOps, indeed, is the prerequisite for some advanced architectures that we will
    see in the forthcoming chapters, such as microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on Java architectural patterns. We will cover
    some essential topics, including multi-tier architectures, encapsulation, and
    practical tips regarding performance and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The pros and cons of Waterfall Software Development* ([https://www.dcsl.com/pros-cons-waterfall-software-development/](https://www.dcsl.com/pros-cons-waterfall-software-development/)),
    DCSL GuideSmiths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Waterfall Model: Advantages, disadvantages, and when you should use it*
    ([https://developer.ibm.com/articles/waterfall-model-advantages-disadvantages/](https://developer.ibm.com/articles/waterfall-model-advantages-disadvantages/)),
    by Aiden Gallagher, Jack Dunleavy, and Peter Reeves'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Waterfall model: Advantages and disadvantages* ([https://www.blocshop.io/blog/waterfall-advantages-disadvantages/](https://www.blocshop.io/blog/waterfall-advantages-disadvantages/)),
    Blocshop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Agile Manifesto ([https://agilemanifesto.org](https://agilemanifesto.org)),
    by Kent Beck, Mike Beedle, Arie van Bennekum, Alistair Cockburn, Ward Cunningham,
    Martin Fowler, James Grenning, Jim Highsmith, Andrew Hunt, Ron Jeffries, Jon Kern,
    Brian Marick, Robert C. Martin, Steve Mellor, Ken Schwaber, Jeff Sutherland, and
    Dave Thomas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lean Software Development: An Agile Toolkit*, *Mary Poppendieck and Tom Poppendieck*,
    *Pearson Education* (2003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing Lean Software Development: From Concept to Cash*, *Mary and Tom
    Poppendieck*, *Pearson Education* (2006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lean Software Development in Action*, *Andrea Janes and Giancarlo Succi*,
    *Springer Berlin Heidelberg* (2014)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Agile Metrics in Action: How to measure and improve team performance*, *Christopher
    Davis*, *Manning Publications* (2015)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Surprising Power of Online Experiments* ([https://hbr.org/2017/09/the-surprising-power-of-online-experiments](https://hbr.org/2017/09/the-surprising-power-of-online-experiments)),
    by Ron Kohavi and Stefan Thomke'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Art of Lean Software Development*, *Curt Hibbs, Steve Jewett, and Mike
    Sullivan*, *O''Reilly Media* (2009).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scrum guide ([https://www.scrumguides.org](https://www.scrumguides.org)),
    by Jeff Sutherland and Ken Schwaber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scrum: The Art of Doing Twice the Work in Half the Time*, *Jeff Sutherland*,
    *Random House* (2014)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*9 retrospective techniques that won''t bore your team to death* ([https://www.atlassian.com/blog/teamwork/revitalize-retrospectives-fresh-techniques](https://www.atlassian.com/blog/teamwork/revitalize-retrospectives-fresh-techniques)),
    by Sarah Goff-Dupont'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*6 Effective Sprint Retrospective Techniques* ([https://www.parabol.co/resources/agile-sprint-retrospective-ideas](https://www.parabol.co/resources/agile-sprint-retrospective-ideas)),
    Parabol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DevOpsCulture* ([https://martinfowler.com/bliki/DevOpsCulture.html](https://martinfowler.com/bliki/DevOpsCulture.html)),
    by Rouan Wilsenach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scaling Agile @ Spotify with Tribes, Squads, Chapters & Guilds* ([https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf](https://blog.crisp.se/wp-content/uploads/2012/11/SpotifyScaling.pdf)),
    by Henrik Kniberg and Anders Ivarsson'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Create Your Successful Agile Project: Collaborate, Measure, Estimate, Deliver*,
    *Johanna Rothman*, *Pragmatic Bookshelf* (2017)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Operations Anti-Patterns, DevOps Solutions*, *Jeffery D. Smith*, *Manning
    Publications* (2020)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
