["```java\ncurl -O https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein\n# The next step just set up the lein script in your path, you can do it any way you wish\nmv lein ~/bin\necho \"export PATH=$PATH:~/bin/\">> ~/.bashrc\nsource ~/.bashrc\n# Everything should be running now, let's test it\nlein help\n\n```", "```java\nlein repl\n\n```", "```java\nnREPL server started on port 55995 on host 127.0.0.1 - nrepl://127.0.0.1:55995\nREPL-y 0.3.5, nREPL 0.2.6\n\n```", "```java\nlein repl :connect localhost:55995\n\n```", "```java\n\"Hello world\"\n```", "```java\n(println \"Hello world\")\n```", "```java\nuser=> (javadoc java.util.List)\n;; Should open the javadoc for java.util.List\n\nuser=> (doc doc)\n-------------------------\nclojure.repl/doc\n([name])\nMacro\n  Prints documentation for a var or special form given its name\nnil\n\nuser=> (source doc)\n(defmacro doc\n\"Prints documentation for a var or special form given its name\"\n  {:added \"1.0\"}\n  [name]\n  (if-let [special-name ('{& fn catch try finally try} name)]\n    (#'print-doc (#'special-doc special-name))\n    (cond\n      (special-doc-map name) `(#'print-doc (#'special-doc '~name))\n      (find-ns name) `(#'print-doc (#'namespace-doc (find-ns '~name)))\n      (resolve name) `(#'print-doc (meta (var ~name))))))\nnil\n```", "```java\nuser=> 2\n2\nuser=> 3\n3\nuser=> 4\n4\nuser=> (* *1 *2 *3) ;; We are multiplying over here the last three values\n24 ;;We get 24!\nuser=> (/ 1 0) ;; Let's try dividing by zero\nArithmeticException Divide by zero clojure.lang.Numbers.divide (Numbers.java:156)\nuser=> *e\n#<ArithmeticException java.lang.ArithmeticException: Divide by zero>\n\nuser=> (.getMessage *e)\n\"Divide by zero\"\n```", "```java\nlein new app getting-started\ncd getting-started\nlein run\n# Hello, world!\n\n```", "```java\nlein uberjar\njava -jar target/uberjar/getting-started-0.1.0-SNAPSHOT-standalone.jar\n# Hello, World!\n\n```", "```java\n(1 2 3 4)\n(println \"Hello world\")\n(one two three)\n(\"one\" two three)\n```", "```java\n(println \"Hello world\")\n(one two three)\n```", "```java\n(defn some-function [times parameter]\n\"Prints a string certain number of times\"\n  (dotimes [x times]\n    (println parameter)))\n```", "```java\n(println parameter)\n(dotimes [x times] (println parameter))\n(defn some-function [times parameter] (dotimes [x times] (println parameter)))\n```", "```java\n(* 1 2 3)\n(+ 5 9 7)\n(/ 4 5)\n(- 2 3 4)\n(map inc [1 2 3 4 5 6])\n```", "```java\n(op parameter-1parameter-2 ….)\n```", "```java\n(+ 1 2 3)\n```", "```java\n(map inc [1 2 3 4 5 6])\n```", "```java\n(defn some-function [times parameter]\n\"Prints a string certain number of times\"\n  (dotimes [x times]\n    (println parameter)))\n```", "```java\n(defn hello\n  ([] (hello \"Clojure\"))\n  ([name] (str \"Hello \" name)))\n```", "```java\n(ns getting-started.core\n  (:gen-class))\n\n(defn hello\n  ([] (hello \"Clojure\"))\n  ([name] (str \"Hello \" name)))\n\n(defn -main\n\"I don't do a whole lot ... yet.\"\n  [& args]\n  (println \"Hello, World!\")\n  (println (hello))\n  (println (hello \"Edu\")))\n```", "```java\njava:\n    lang:\n        String.class\n        ….\n    io:\n        IOException.class\n        …\n    util:\n        List.class\n```", "```java\nlein new app ns-playground\n\n```", "```java\n(ns ns-playground.core\n  (:gen-class))\n\n(defn -main\n\"I don't do a whole lot ... yet.\"\n  [& args]\n  (println \"Hello, World!\"))\n;; Code for src/ns_playground/core.clj\n```", "```java\n(ns ns-playground.hello)\n```", "```java\n(:import java.util.List)\n```", "```java\n(:import [java.util ArrayList HashMap])\n```", "```java\n(:require [some.package :refer [a-function another-function]])\n```", "```java\n(:require [some.package :refer [:all]])\n```", "```java\n(:require [some.package :as s])\n\n;; And then use everything in the package like this:\n\n(s/a-function 5)\n```", "```java\n(:require [some.package :as s :refer [a-function]])\n```", "```java\n(ns ns-playground.hello\n  (:import [java.util Date]))\n\n(def addition +)\n\n(defn current-date []\n\"Returns the current date\"\n  (new Date))\n\n(defn <3 [love & loved-ones]\n\"Creates a sequence of all the {loved-ones} {loved} loves\"\n  (for [loved-one loved-ones]\n    (str love \" love \" loved-one)))\n\n(defn sum-something [something & nums]\n\"Adds something to all the remaining parameters\"\n  (apply addition something nums))\n\n(def sum-one (partial sum-something 1))\n```", "```java\n*ns*\n=> #<Namespace ns-playground.core>\n```", "```java\n(in-ns 'ns-playground.hello)\n=> #<Namespace ns-playground.hello>\n```", "```java\n(str \"Hello\"\"\"\"world\")\n=>\"Hello world\"\n```", "```java\n(for [el [\"element1\"\"element2\"\"element3\"]] el)\n=> (\"element1\"\"element2\"\"element3\")\n\n(for [el [\"element1\"\"element2\"\"element3\"]]\n  (str \"Hello \" el))\n=> (\"Hello element1\"\"Hello element2\"\"Hello element3\")\n```", "```java\n(<3 \"They\"\"tea\")\n=> (\"They love tea\")\n\n(clojure.repl/doc <3)\nns-playground.hello/<3\n([& loved-ones])\n  Creates a sequence of all the {loved-ones} {loved} loves\n```", "```java\nuser=user\ntest=password\nsample=5\n```", "```java\n(require '[clojure.java.io :as io])\n(io/resource \"test.properties\")\n=> #<URL file:/Users/iamedu/Clojure4Java/ns-playground/resources/test.properties>\n(io/input-stream (io/resource \"test.properties\"))\n=> #<BufferedInputStream java.io.BufferedInputStream@2f584e71>\n;; Let's now load it into a properties object\n(import [java.util Properties])\n=> java.util.Properties\n(def props (Properties.)) ;; Don't worry about the weird syntax, we will look it soon.\n=> #'ns-playground.core/props\n(.load props (io/input-stream (io/resource \"test.properties\")))\nprops\n=> {\"user\"\"user\", \"sample\"\"5\", \"test\"\"password\"}\n```", "```java\n(defn read-properties [path]\n  (let [resource (io/resource path)\n        is (io/input-stream resource)\n        props (Properties.)]\n    (.load props is)\n    (.close is)\n    props))\n=> #'ns-playground.core/read-properties\n(read-properties \"test.properties\")\n=> {\"user\"\"user\", \"sample\"\"5\", \"test\"\"password\"}\n```", "```java\n(ns ns-playground.hello\n  (:require [clojure.java.io :as io])\n  (:import [java.util Date Properties]))\n\n(def addition +)\n\n(defn current-date []\n\"Returns the current date\"\n  (new Date))\n\n(defn <3 [love & loved-ones]\n\"Creates a sequence of all the {loved-ones} {loved} loves\"\n  (for [loved-one loved-ones]\n    (str love \" love \" loved-one)))\n\n(defn sum-something [something & nums]\n\"Adds something to all the remaining parameters\"\n  (apply addition something nums))\n\n(defn read-properties [path]\n  (let [resource (io/resource path)\n        is (io/input-stream resource)\n        props (Properties.)]\n    (.load props is)\n    props))\n\n(def sum-one (partial sum-something 1))\n```", "```java\n(ns ns-playground.core-test\n  (:require [clojure.test :refer :all]\n            [ns-playground.core :refer :all]))\n(deftest a-test\n  (testing \"FIXME, I fail.\"\n(is (= 0 1))))\n```", "```java\nlein test\n\n```", "```java\nlein test ns-playground.core-test\n\nlein test :only ns-playground.core-test/a-test\n\nFAIL in (a-test) (core_test.clj:7)\nFIXME, I fail.\nexpected: (= 0 1)\n  actual: (not (= 0 1))\n\nRan 1 tests containing 1 assertions.\n1 failures, 0 errors.\nTests failed.\n```", "```java\n    (ns ns-playground.hello-test\n      (:import [java.util Date])\n      (:require [clojure.test :refer :all]\n                [ns-playground.hello :as hello :refer [<3]]\n                [ns-playground.core :refer :all]))\n\n    (defn- lazy-contains? [col element]\n      (not (empty? (filter #(= element %) col))))\n\n    (deftest a-test\n      (testing \"DONT FIXME, I don't fail.\"\n        (is (= 42 42))))\n\n    (deftest current-date-is-date\n      (testing \"Test that the current date is a date\"\n        (is (instance? Date (hello/current-date)))))\n\n    (deftest check-loving-collection\n      (testing \"Check that I love clojure and you\"\n        (let [loving-seq (<3 \"I\"\"Clojure\"\"you\"\"doggies\"\"chocolate\")]\n          (is (not (lazy-contains? loving-seq \"I love Vogons\")))\n          (is (lazy-contains? loving-seq \"I love Clojure\"))\n          (is (lazy-contains? loving-seq \"I love doggies\"))\n          (is (lazy-contains? loving-seq \"I love chocolate\"))\n          (is (lazy-contains? loving-seq \"I love you\")))))\n    ```", "```java\n(ns ns-playground.core-test\n  (:import [java.util Date])\n  (:require [clojure.test :refer :all]\n            [ns-playground.hello :as hello :refer [<3]]\n            [ns-playground.core :refer :all]))\n```", "```java\n    (defn- lazy-contains? [col element]\n      (not (empty? (filter #(= element %) col))))\n    ```", "```java\n#(= element %)\n```", "```java\n(fn [e1]\n  (= element e1))\n```", "```java\n(filter #(= element %) col)\n```", "```java\n;; This returns only the even numbers in the collection\n(filter even? [1 2 3 4])\n;;=> (2 4)\n```", "```java\n(empty? (filter #(= element %) col))\n```", "```java\n(not (empty? (filter #(= element %) col)))\n```", "```java\nList<T> filteredElements = new ArrayList<T>();\nfor(T e1 : col) {\n    if(e1 == element) {\n        filteredElements.add(e1);\n    }\n}\nreturn !filteredElements.isEmpty();\n```", "```java\n(deftest current-date-is-date\n  (testing \"Test that the current date is a date\"\n    (is (instance? Date (hello/current-date)))))\n```", "```java\n(deftest check-loving-collection\n  (testing \"Check that I love clojure and you\"\n    (let [loving-seq (<3 \"I\"\"Clojure\"\"you\"\"doggies\"\"chocolate\")]\n      (is (not (lazy-contains? loving-seq \"I love Vogons\")))\n      (is (lazy-contains? loving-seq \"I love Clojure\"))\n      (is (lazy-contains? loving-seq \"I love doggies\"))\n      (is (lazy-contains? loving-seq \"I love chocolate\"))\n      (is (lazy-contains? loving-seq \"I love you\")))))\n```", "```java\nlein new thumbnails\n\n```", "```java\n(defproject thumbnails \"0.1.0-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"http://example.com/FIXME\"\n  :license {:name \"Eclipse Public License\"\n            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n  :dependencies [[org.clojure/clojure \"1.6.0\"]])\n```", "```java\n(defproject thumbnails \"0.1.0-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"http://example.com/FIXME\"\n  :license {:name \"Eclipse Public License\"\n            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n  :dependencies [[org.clojure/clojure \"1.6.0\"]\n                 [org.imgscalr/imgscalr-lib \"4.2\"]])\n```", "```java\n(defproject thumbnails \"0.1.0-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"http://example.com/FIXME\"\n  :license {:name \"Eclipse Public License\"\n            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n  :dependencies [[org.clojure/clojure \"1.6.0\"]\n                 [org.imgscalr/imgscalr-lib \"4.2\"]]\n  :repositories [[\"jcenter\" \"http://jcenter.bintray.com/\"]])\n```", "```java\nlein deps\n\n```", "```java\nlein deps :tree\n\n```", "```java\n [clojure-complete \"0.2.3\" :scope \"test\" :exclusions [[org.clojure/clojure]]]\n [org.clojure/clojure \"1.6.0\"]\n [org.clojure/tools.nrepl \"0.2.6\" :scope \"test\" :exclusions [[org.clojure/clojure]]]\n [org.imgscalr/imgscalr-lib \"4.2\"]\n```", "```java\n(def a (new java.util.ArrayList 20))\n```", "```java\n(def a (ArrayList.))\n```", "```java\n(. add a 5)\n```", "```java\n(. instance method-name args*)\n```", "```java\n(.method-name instance args*)\n```", "```java\n(java.util.Collections/emptyMap)\n```", "```java\n(java.util.AbstractMap.SimpleEntry. \"key\" \"value\")\n```", "```java\n(java.util.AbstractMap$SimpleEntry. \"key\" \"value\")\n```", "```java\n(ns thumbnails.image\n  (:require [clojure.java.io :as io])\n  (:import [javax.imageio ImageIO]\n           [java.awt.image BufferedImageOp]\n           [org.imgscalr Scalr Scalr$Mode]))\n```", "```java\n(def image-stream (io/input-stream \"http://imgs.xkcd.com/comics/angular_momentum.jpg\"))(def image (ImageIO/read image-stream))\nimage\n(.getWidth image)\n```", "```java\n(ns thumbnails.image\n  (:require [clojure.java.io :as io])\n  (:import [javax.imageio ImageIO]\n           [java.awt.image BufferedImageOp]\n           [org.imgscalr Scalr Scalr$Mode]))\n\n(defn load-image [image-stream]\n  (ImageIO/read image-stream))\n\n(defn save-image [image path]\n  (ImageIO/write image \"PNG\" (io/output-stream path)))\n\n(defn image-size [image]\n  [(.getWidth image) (.getHeight image)])\n\n(defn generate-thumbnail [image size]\n  (Scalr/resize image Scalr$Mode/FIT_TO_WIDTH size (into-array BufferedImageOp [])))\n\n(defn get-image-width [image-path]\n  (let [image (load-image image-path)\n        [w _] (image-size image)]\n    w))\n```", "```java\n(into-array BufferedImageOp [])\n```", "```java\n(ns thumbnails.thumbnail-test\n  (:require [clojure.test :refer :all]\n            [clojure.java.io :as io]\n            [thumbnails.image :refer :all]))\n\n(deftest test-image-width\n  (testing \"We should be able to get the image with\"\n    (let [image-stream (io/input-stream \"http://imgs.xkcd.com/comics/angular_momentum.jpg\")\n          image (load-image image-stream)]\n      (save-image image \"xkcd-width.png\")\n      (is (= 600 (get-image-width (io/input-stream \"xkcd-width.png\")))))))\n\n(deftest test-load-image\n  (testing \"We should be able to generate thumbnails\"\n    (let [image-stream (io/input-stream \"http://imgs.xkcd.com/comics/angular_momentum.jpg\")\n          image (load-image image-stream)\n          thumbnail-image (generate-thumbnail image 50)]\n      (save-image thumbnail-image \"xkcd.png\")\n      (is (= 50 (get-image-width (io/input-stream \"xkcd.png\")))))))\n```", "```java\n(let [x 42] x)\n```", "```java\n(let [x 42\n      y (* x x)]\n  (println \"x is \" x \" and y \" y))\n```", "```java\n(let [x 42]\n  (let [y (* x x)]\n    (println \"x is \" x \" and y \" y)))\n```", "```java\n(let [x 42]\n  (let [y (* x x)]\n    (let [x 41]\n      (println \"x is \" x \" and y \" y))))\n```", "```java\nimage (load-image image-path)\n```", "```java\n[w _] (image-size image)\n```", "```java\n(let [v [1 2 3]] [(first v) (nth v 2)]) ;; [1 3]\n```", "```java\n(let [[f s t] [1 2 3]] [f t]) ;; [1 3]\n```", "```java\n(let [[f s] [1 2]] f) ;; 1\n(let [[f s t] [1 2 3]] [f t]) ;; [1 3]\n(let [[f] [1 2]] f);; 1\n(let [[f s t] [1 2]] t);; nil\n(let [[f & t [1 2]] t);; (2)\n(let [[f & t [1 2 3]] t);; (2 3)\n(let [[f & t [1 2 3]] t);; (2 3)\n(let [[f & [_ t]] [1 2 3]] [f t])\n```", "```java\n(defn func [[f _ t]]\n  (+ f t))\n(func [1 2 3]) ;; 4\n```", "```java\n(let [{a-value a} {: a-value  5}] a-value) ;; 5\n(let [{a-value :a c-value :c} {:a 5 :b 6 :c 7}] c-value) ;; 7\n(let [{:keys [a c]} {:a 5 :b 6 :c 7}] c) ;; 7\n(let [{:syms [a c]} {'a 5 :b 6 'c 7}] c) ;; 7\n(let [{:strs [a c]} {:a 5 :b 6 :c 7 \"a\" 9}] [a c]) ;; [9 nil]\n(let [{:strs [a c] :or {c 42}} {:a 5 :b 6 :c 7 \"a\" 9}] [a c]) ;; [9 42]\n```", "```java\n(defn get-image-width [image-path]\n  (let [image (load-image image-path)\n        [w _] (image-size image)]\n    w))\n```", "```java\n (deftest test-load-image\n  (testing \"We should be able to generate thumbnails\"\n    (let [image-stream    (io/input-stream \"http://imgs.xkcd.com/comics/angular_momentum.jpg\")\n          image           (load-image image-stream)\n          thumbnail-image (generate-thumbnail image 50)]\n      (save-image thumbnail-image \"xkcd.png\")\n      (is (= 50 (get-image-width (io/input-stream \"xkcd.png\")))))))\n```", "```java\n(ns thumbnails.image-java\n  (:require [thumbnails.image :as img])\n  (:gen-class\n    :methods [[loadImage [java.io.InputStream] java.awt.image.BufferedImage]\n              [saveImage [java.awt.image.BufferedImage String] void]\n              [generateThumbnail [java.awt.image.BufferedImage int] java.awt.image.BufferedImage]]\n    :main false\n    :name thumbnails.ImageProcessor))\n\n(defn -loadImage [this image-stream]\n  (img/load-image image-stream))\n\n(defn -saveImage [this image path]\n  (img/save-image image path))\n\n(defn -generateThumbnail [this image size]\n  (img/generate-thumbnail image size))\n```", "```java\n(:gen-class\n    :methods [[loadImage [java.io.InputStream] java.awt.image.BufferedImage]\n              [saveImage [java.awt.image.BufferedImage String] void]\n              [generateThumbnail [java.awt.image.BufferedImage int] java.awt.image.BufferedImage]]\n    :main false\n    :name thumbnails.ImageProcessor)\n```", "```java\n$ lein install\n\n```", "```java\napply plugin: 'java'\napply plugin: 'groovy'\n\nrepositories {\n  jcenter()\n  mavenLocal()\n}\n\ndependencies {\n  compile \"thumbnails:thumbnails:0.1.0-SNAPSHOT\"\n  testCompile \"org.spockframework:spock-core:0.7-groovy-2.0\"\n}\n```", "```java\npackage imaging.java\n\nimport thumbnails.ImageProcessor\nimport spock.lang.*\n\nclass ImageSpec extends Specification {\n  def \"Test we can use imaging tools\"() {\n    setup:\n      def processor = new ImageProcessor()\n      def imageStream = getClass().getResourceAsStream(\"/test.png\")\n\n    when:\n      def image = processor.loadImage(imageStream)\n      def thumbnail = processor.generateThumbnail(image, 100)\n\n    then:\n      thumbnail.getWidth() == 100\n  }\n}\n```", "```java\ngradle test\n```", "```java\n(import '(javax.swing JFrame JLabel JTextField JButton)\n        '(java.awt.event ActionListener)\n        '(java.awt GridLayout))\n(defn sample []\n  (let [frame (JFrame. \"Simple Java Integration\")\n        sample-button (JButton. \"Hello\")]\n    (.addActionListener\n     sample-button\n     (reify ActionListener\n            (actionPerformed\n             [_ evt]\n             (println \"Hello world\"))))\n    (doto frame\n      (.add sample-button)\n      (.setSize 100 40)\n      (.setVisible true))))\n(sample)\n```", "```java\nbutton.addActionListener(new ActionListener() {\n  public void actionPerformed(ActionEvent e) {\n    System.out.println(\"Hello world\")'\n  }\n})\n```", "```java\n  (reify ActionListener\n            (actionPerformed\n             [_ evt]\n             (println \"Hello world\")))\n```", "```java\n(reify InterfaceOrProtocol\n  (method [self parameter-list]\n    method-body)\n  (method2 [self parameter-list]\n    method-body))\n```", "```java\npublic void payRent(BigDecimal amount) {\n  User user = getCurrentUser();\n  if(user.payAmount != amount) {\n    System.out.println(\"Cannot pay\");\n  } else {\n    user.money -= amount;\n  }\n}\n```", "```java\npublic boolean payRent(User user, BigDecimal amount, ValidateStrategy strategy) {\n  if(strategy.validatePayment(user, amount)) {\n    user.money -= amount;\n    return true;\n  } else {\n    return false;\n  }\n}\n```", "```java\n(def sample-coll [:one :two :three])\n(def second-sample-coll (conj sample-coll :four))\n(def third-sample-coll (replace {:one 1} sample-coll))\n\nsample-coll ;; [:one :two :three]\nsecond-sample-coll ;; [:one :two :three :four]\nthird-sample-coll ;; [1 :two :three :four]\n```", "```java\n    (def c [1 1 2 2 3 3 4 4 1 1])\n    (distinct c) ;; (1 2 3 4)\n    ```", "```java\n    (take 5 c) ;; (1 1 2 2 3)\n    ```", "```java\n    (map #(+ % 1) c) ;; (2 2 3 3 4 4 5 5 2 2)\n    ```", "```java\n (->> c\n  (distinct)\n  (take 5)\n  (reverse)) ;; (4 3 2 1)\n\n;; This is known as a threading macro, it applies distinct, then take 5 then reverse to the\n;; collection c so this is the same as writing:\n;; (reverse (take 5 (distinct c))) but much more readable\n```", "```java\n[42 4 2 3 4 4 5 5]\n```", "```java\n(vec (range 4)) ;; [0 1 2 3]\n```", "```java\n(def f [some-param & some-other-params] …)\n\n(let [one 1 two (f p p-2 p-3)] …)\n```", "```java\n    (def v [42 24 13 2 11 \"a\"])\n    (v 0) ;; 42\n    (v 99) ;; java.lang.IndexOutOfBoundsException\n    ```", "```java\n    (nth v 0) ;; 42\n    (nth v 99 :not-found) ;; :not-found\n    (nth v 99) ;; java.lang.IndexOutOfBoundsException\n    ```", "```java\n    (get v 0) ;; 42\n    (get v 99 :not-found) ;; :not-found\n    (get v 99) ;; nil\n    ```", "```java\n    {:one 1 :two 2}\n    (hash-map :one 1 :two 2)\n    ```", "```java\n    (sorted-map :sample 5 :map :6) ;; {:sample 5, :map 6}\n    (sorted-map-by > 1 :one 5 :five 3 :three) ;; {5 :five, 3 :three, 1 :one}\n    ```", "```java\n    (def m #{:one 1 :two 2 :three 3})\n    (m :one) ;; 1\n    (m 1) ;; nil\n    ```", "```java\n    (let [{:keys [a b c d]} #{:a 5}]\n      [a b]) ;\n    ; [:a nil]\n    ```", "```java\n    (get m :one) ;; 1\n    (get m 1) ;; nil\n    (get m 1 :not-found) ;; :not-found\n    ```", "```java\n(seq {:one 1 42 :forty-two :6 6}) ;; ([:one 1] [:6 6] [42 :forty-two])\n(doseq [[k v] (seq {:one 1 42 :forty-two :6 6})]\n  (println k v))\n;; :one 1\n;; :6 6\n;; 42 :forty-two\n```", "```java\n    (body-that-uses x))\n```", "```java\n    (doseq [x (->> (sorted-set :b :c :d)\n                            (map name))]\n        (println x))\n    ;; b\n    ;; c\n    ;; d\n    ```", "```java\n    (#{:a :b :c :d} :a);; :a\n    (#{:a :b :c :d} :e);; nil\n    ```", "```java\n    (let [{:keys [b]} #{:b}] b);; :b\n    (let [{:keys [c]} #{:b}] b);; nil\n    (let [{:keys [c]} (sorted-set :b)] c);; nil\n    (let [{:keys [b]} (sorted-set :b)] b);; :b\n    ```", "```java\n    (get #{:a :b :c :d} :e :not-found) ;; :not-found\n    (get #{:a :b :c :d} :a) ;; :a\n    (get #{:a :b :c :d} :e) ;; nil\n    ```", "```java\n(def a #{:a :b :c :d :e})\n(def b #{:a :d :h :i :j :k})\n\n(require '[clojure.set :as s])\n\n(s/union a b) ;; #{:e :k :c :j :h :b :d :i :a}\n(s/difference a b) ;; #{:e :c :b}\n(s/intersection a b) ;; #{:d :a}\n```", "```java\nint factorial(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n```", "```java\nList l = new ArrayList();\ndoSomething(l);\nSystem.out.println(l.size());\n```", "```java\n(map str [1 2 3 4 5 6]) ;; (\"1\" \"2\" \"3\" \"4\" \"5\" \"6\")\n\n(defn factorial [n]\n  (reduce * (range 1 (inc n))))\n\n(factorial 5) ;; 120\n```", "```java\n(def r (range))\n```", "```java\n(take 1 r);; (0)\n(take 5 r);; (0 1 2 3 4)\n```", "```java\n(def odd-numbers (filter odd? r))\n(take 1 odd-numbers)  ;; (1)\n(take 2 odd-numbers)  ;; (1 3)\n(take 3 odd-numbers)  ;; (1 3 5)\n```", "```java\n(defn logging-odd? [number]\n    (println number) ;; This is terrible, it is a side effect and a source for problems\n                     ;; Clojure encourages you to avoid side effects, but it is pragmatic\n                     ;; and relies on you knowing what you are doing\n    (odd? number))\n\n(def odd-numbers (filter logging-odd? r))\n\n(take 1 odd-numbers)\n;; 0\n;; 1\n;; 2\n;; 3\n;; 4\n;; 5\n;; 6\n;; 7\n;; 8\n;; 9\n;; 10\n;; 11\n;; 12\n;; 13\n;; 14\n;; 15\n;; 16\n;; 17\n;; 18\n;; 19\n;; 20\n;; 21\n;; 22\n;; 23\n;; 24\n;; 25\n;; 26\n;; 27\n;; 28\n;; 29\n;; 30\n;; 31\n;; => (1)\n\n(take 1 odd-numbers)\n;; => (1)\n\n(take 2 odd-numbers)\n;; => (1 3)\n\n(take 3 odd-numbers)\n;; => (1 3 5)\n\n(take 4 odd-numbers)\n;; => (1 3 5 7)\n\n(take 10 odd-numbers)\n;; => (1 3 5 7 9 11 13 15 17 19)\n```", "```java\npackage shapes;\n\npublic interface Shape {\n  public double getArea();\n}\n\npublic class Square implements Shape {\n  private double side;\n  public Square(double side) {\nthis.side = side;\n  }\n\n  public double getArea() {\n    return side * side;\n  }\n\n}\n\npublic class Circle implements Shape {\n  private double radius;\n  public Circle(double radius) {\nthis.radius = radius;\n  }\n\n  public double getArea() {\n    return Math.PI * radius * radius;\n  }\n\n}\n```", "```java\n(defmulti name docstring? attr-map? dispatch-fn& options)\n```", "```java\n(defmultiarea :shape)\n\n(defmethodarea :square [{:keys [side]}] (* side side))\n\n(area {:shape :square :side 5})\n;;=> 25\n```", "```java\n(defmultifunction-name dispatch-function)\n```", "```java\n(defmethodfunction-name dispatch-key [params] function-body)\n```", "```java\n(:shape {:shape :square :side 5})\n;; :square\n```", "```java\n(defmethodarea :circle [{:keys [radius]}]\n(* Math/PI radius radius))\n\n(defmultiperimeter :shape)\n\n(defmethodperimeter :square [{:keys [side]}] (* side 4))\n\n(defmethodperimeter :circle [{:keys [radius]}] (* 2 Math/PI radius))\n```", "```java\n(derive ::hominid ::primate)\n```", "```java\n(walk {:type ::hominid})\n;; Primate Walk\n```", "```java\n(derive ::hominid ::animal)\n\n(walk {:type ::hominid})\n;;java.lang.IllegalArgumentException: Multiple methods in multimethod 'walk' match dispatch value: :boot.user/hominid -> :boot.user/animal and :boot.user/primate, and neither is preferred\n```", "```java\n(prefer-method walk ::hominid ::primate)\n(walk {:type ::hominid})\n; Primate walk\n```", "```java\n(defmethodwalk ::hominid [_] \"Walk in two legs\")\n\n(walk {:type ::hominid})\n;; Walk in two legs\n```", "```java\n(isa? java.util.ArrayListjava.util.List)\n;;=> true\n\n(isa? ::hominid ::animal)\n;;=> true\n\n(isa? ::animal ::primate)\n;;=> false\n```", "```java\n(parents java.util.ArrayList)\n;;=> #{java.io.Serializablejava.util.Listjava.lang.Cloneablejava.util.RandomAccessjava.util.AbstractList}\n\n(parents ::hominid)\n#{:user/primate :user/animal}\n```", "```java\n(descendants ::animal)\n;;=> #{:boot.user/hominid}\n```", "```java\n(underive ::hominid ::animal)\n;;=> (isa? ::hominid ::animal)\n```", "```java\n(defn dispatch-func [arg1 arg2]\n  [arg2 arg1])\n```", "```java\n(defmulti sample-multimethod dispatch-func)\n;; Here we are saying that we want to use dispatch-func to calculate the dispatch-key\n\n(defmethod sample-multimethod [:second :first] [first second] [:normal-params first second])\n(defmethod sample-multimethod [:first :second] [first second] [:switch-params second first])\n\n(sample-multimethod :first :second)\n;;=> [:normal-params :first: second]\n\n(sample-multimethod :second :first)\n;; =>[:switch-params :first: second]\n```", "```java\n(defprotocol Shape\n  \"This is a protocol for shapes\"\n  (perimeter [this] \"Calculates the perimeter of this shape\")\n  (area [this] \"Calculates the area of this shape\"))\n```", "```java\n(defrecord Square [side]\n  Shape\n  (perimeter [{:keys [side]}] (* 4 side))\n  (area [{:keys [side]}] (* side side)))\n```", "```java\n(Square. 5)\n;;=> #user/Square{:size 5}\n\n(def square (Square. 5))\n\n(let [{side :side} square] side)\n;;=> 5\n\n(let [{:keys [side]} square] side)\n;;=> 5\n\n(doseq [[k v] (Square. 5)] (println k v))\n;; :side 5\n```", "```java\n(assoc (Square. 5) :hello :world)\n```", "```java\n(perimeter square)\n;;=> 20\n\n(area square)\n;;=> 25\n```", "```java\n(defrecord Circle [radius]\n  Shape\n  (perimeter [{:keys [radius]}] (* Math/PI 2 radius))\n  (area [{:keys [radius]}] (* Math/PI radius radius)))\n\n(def circle (Circle. 5))\n\n(perimeter circle)\n;;=> 31.41592653589793\n\n(area circle)\n;;=> 78.53981633974483\n```", "```java\n(defprotocolShapeProperties\n  (num-sides [this] \"How many sides a shape has\"))\n```", "```java\n(extend-type Square\nShapeProperties\n  (num-sides [this] 4))\n\n(extend-type Circle\nShapeProperties\n  (num-sides [this] Double/POSITIVE_INFINITY))\n\n(num-sides square)\n;;=> 4\n\n(num-sides circle)\n;;=> Infinity\n```", "```java\n(defprotocolListOps\n  (positive-values [list])\n  (negative-values [list])\n  (non-zero-values [list]))\n\n(extend-type java.util.List\nListOps\n  (positive-values [list]\n    (filter #(> % 0) list))\n  (negative-values [list]\n    (filter #(< % 0) list))\n  (non-zero-values [list]\n    (filter #(not= % 0) list)))\n```", "```java\n(positive-values [-1 0 1])\n;;=> (1)\n\n(negative-values [-1 0 1])\n;;=> (-1)\n\n(no-zero-values [-1 0 1])\n;;=> (-1 1)\n```", "```java\n(ns clojure-concurrency.core)\n\n(defn start-thread [func]\n  (.start (Thread. func)))\n```", "```java\njava -XX:+PrintFlagsFinal -version | grep ThreadStackSize\n\n```", "```java\n (defproject clojure-concurrency \"0.1.0-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"http://example.com/FIXME\"\n  :license {:name \"Eclipse Public License\"\n            :url \"http://www.eclipse.org/legal/epl-v10.html\"}\n            :dependencies [[org.clojure/clojure \"1.6.0\"]\n            [co.paralleluniverse/pulsar \"0.6.2\"]]\n  :java-agents [[co.paralleluniverse/quasar-core \"0.6.2\"]])\n```", "```java\n (clojure.core/use 'co.paralleluniverse.pulsar.core)\n(def p1 (promise))\n(def p2 (promise))\n(def p3 (promise))\n(spawn-fiber #(clojure.core/deliver p2 (clojure.core/+ @p1 5)))\n(spawn-fiber #(clojure.core/deliver p3 (clojure.core/+ @p1 @p2)))\n(spawn-thread #(println @p3))\n(clojure.core/deliver p1 99)\n;; 203\n```", "```java\n(def f (future (Thread/sleep 20000) \"Hello world\"))\n(println @f)\n```", "```java\n(def account (ref 20000))\n(dosync (ref-set account 10))\n(deref account)\n\n(defn test []\n  (dotimes [n 5]\n    (println n @account)\n    (Thread/sleep 2000))\n  (ref-set account 90))\n\n(future (dosync (test)))\n(Thread/sleep 1000)\n(dosync (ref-set account 5))\n```", "```java\n(def account (ref 20000))\n\n(defn test []\n  (println \"Transaction started\")\n  (dotimes [n 5]\n    (println n @account)\n    (Thread/sleep 2000))\n  (ref-set account 90))\n\n(future (dosync (test)))\n(future (dosync (Thread/sleep 4000) (ref-set account 5)))\n```", "```java\n(def account-a (ref 10000))\n(def account-b (ref 2000))\n(def started (clojure.core/promise))\n\n(defn move [acc1 acc2 amount]\n  (dosync\n    (let [balance1 @acc1\n           balance2 @acc2]\n      (println \"Transaction started\")\n      (clojure.core/deliver started true)\n      (Thread/sleep 5000)\n      (when (> balance1 amount)\n        (alter acc1 - amount)\n        (alter acc2 + amount))\n      (println \"Transaction finished\"))))\n\n(future (move account-a account-b 50))\n@started\n(dosync (ref-set account-a 20))\n```", "```java\n(alter ref fun arg1 arg2)\n```", "```java\n(ref-set ref (fun @ref arg1 arg2))\n```", "```java\n(def account (ref 1000))\n(def secured (ref false))\n(def started (promise))\n\n(defn withdraw [account amount secured]\n  (dosync\n    (let [secured-value @secured]\n      (deliver started true)\n      (Thread/sleep 5000)\n      (println :started)\n      (when-not secured-value\n        (alter account - amount))\n      (println :finished))))\n\n(future (withdraw account 500 secured))\n@started\n(dosync (ref-set secured true))\n```", "```java\n (ensure secured)\n;; instead of\n@secured\n\n(def account (ref 1000))\n(def secured (ref false))\n(def started (promise))\n\n(defn withdraw [account amount secured]\n  (dosync\n    (let [secured-value (ensure secured)]\n      (deliver started true)\n      (Thread/sleep 5000)\n      (println :started)\n      (when-not secured-value\n        (alter account - amount))\n      (println :finished))))\n\n(future (withdraw account 500 secured))\n@started\n(dosync (ref-set secured true))\n```", "```java\n(clojure.core/use 'co.paralleluniverse.pulsar.core)\n(def events (atom []))\n(defn log-events [count event-id]\n  (dotimes [_ count]\n    (swap! events conj event-id)))\n(dotimes [n 5]\n  (spawn-fiber #(log-events 500 n)))\n```", "```java\n(conj events event-id)\n```", "```java\n(count (filter #(= 0 %) @events))\n;; 500\n(count (filter #(= 1 %) @events))\n;; 500\n(count (filter #(= 2 %) @events))\n;; 500\n(count (filter #(= 3 %) @events))\n;; 500\n(count (filter #(= 4 %) @events))\n;; 500\n```", "```java\n(def agt (agent 0))\n(defn sum [& nums]\n  (Thread/sleep 5000)\n  (println :done)\n  (apply + nums))\n(send agt sum 10) ;; You can replace send with send-off\n                  ;; if you want this to be executed in a different thread\n@agt\n```", "```java\n(def v (atom 0))\n(set-validator! v #(< % 5))\n(swap! v + 10)\n\n;; IllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\n```", "```java\n(swap! v + 4)\n;; 4\n```", "```java\n(def v (agent 0))\n(set-validator! v #(< % 5))\n(swap! v + 10)\n;; THERE IS NO EXCEPTION\n```", "```java\n(def v (atom 0))\n(add-watch v :sample (fn [k i old-value new-value] (println (= i v) k old-value new-value)))\n(reset! v 5)\n```", "```java\ntrue :sample 0 5\n```", "```java\n(ns test\n  (:require [clojure.core.async :refer [go]]))\n\n(go\n  (println \"Running in a goblock!\"))\n```", "```java\n (ns test\n  (:require [clojure.core.async :refer [go chan >! <!]]))\n\n(let [c (chan)]\n  (go (println (str \"The data in the channel is\" (<! c))))\n  (go (>! c 6)))\n```", "```java\n(ns test\n  (:require [clojure.core.async.lab :refer [broadcast]]\n            [clojure.core.async :refer [chan <! >!! go-loop]])\n\n(let [c1 (chan 5)\n      c2 (chan 5)\n      bc (broadcast c1 c2)]\n  (go-loop []\n    (println \"Getting from the first channel\" (<! c1))\n    (recur))\n  (go-loop []\n    (println \"Getting from the second channel\" (<! C2))\n    (recur))\n  (>!! bc 5)\n  (>!! bc 9))\n```", "```java\n(let [odd-counts (comp (map count)\n                       (filter odd?))\n      vs [[1 2 3 4 5 6]\n          [:a :c :d :e]\n          [:test]]]\n  (sequence odd-counts vs))\n```", "```java\n(let [odd-counts (comp (map count)\n                       (filter odd?))\n      input (chan)\n      output (chan 5 odd-counts)]\n  (go-loop []\n    (let [x (<! output)]\n      (println x))\n      (recur))\n  (>!! input [1 2 3 4 5 6])\n  (>!! input [:a :c :d :e])\n  (>!! input [:test]))\n```", "```java\npackage macros.java;\n\npublic aspect SampleJavaAspect {\npointcutanyOperation() : execution(public * *.*(..));\n\n    Object around() : anyOperation() {\nSystem.out.println(\"We are about to execute this \" + thisJoinPointStaticPart.getSignature());\n       Object ret = proceed();\n       return ret;\n    }\n}\n```", "```java\n@TupleConstructor\nclass SampleData {\nint size\n  String color\nboolean big\n}\n\nnew SampleData(5, \"red\", false\") // We didn't write this constructor\n```", "```java\nlog.info'hello world'\n```", "```java\n3 + 5\n```", "```java\nif(a > 120) {\n  a = a / 5\n} else {\n  a = 1200 \n}\n```", "```java\n            private Expression transformMethodCallExpression(Expression exp) {\nMethodCallExpressionmce = (MethodCallExpression) exp;\n                if (!(mce.getObjectExpression() instanceofVariableExpression)) {\n                    return exp;\n                }\nVariableExpressionvariableExpression = (VariableExpression) mce.getObjectExpression();\n                if (!variableExpression.getName().equals(logFieldName)\n                        || !(variableExpression.getAccessedVariable() instanceofDynamicVariable)) {\n                    return exp;\n                }\n                String methodName = mce.getMethodAsString();\n                if (methodName == null) return exp;\n                if (usesSimpleMethodArgumentsOnly(mce)) return exp;\n\nvariableExpression.setAccessedVariable(logNode);\n\n                if (!loggingStrategy.isLoggingMethod(methodName)) return exp;\n\n                return loggingStrategy.wrapLoggingMethodCall(variableExpression, methodName, exp);\n            }\n```", "```java\n(if (> a 120)\n  (/ a 5)\n  1200)\n```", "```java\n(def a 150)\n\n(my-if (> a 200)\n  (println\"Bigger than 200\")\n  (println\"Smaller than 200\"))\n```", "```java\n(defn my-if [cond positive negative]\n  (if cond\n    positive\n    negative))\n```", "```java\nBigger than 200\nSmaller than 200\nNil\n```", "```java\n      (def a 500)\n(my-if (> a 200)\n  (do\n    (println\"Bigger than 200\")\n    :bigger)\n  (do\n    (println\"Smaller than 200\")\n    :smaller))\n```", "```java\nBigger than 200\nSmaller than 200\n:bigger\n```", "```java\n(defn my-if [cond positive negative]\n  (if cond\n    (positive)\n    (negative)))\n\n      (def a 500)\n(my-if (> a 200)\n  #(do\n    (println\"Bigger than 200\")\n    :bigger)\n  #(do\n    (println\"Smaller than 200\")\n    :smaller))\n```", "```java\n(defmacro my-if [test positive negative]\n  (list 'if test positive negative))\n\n(my-if (> a 200)\n  (do\n    (println\"Bigger than 200\")\n    :bigger)\n  (do\n    (println\"Smaller than 200\")\n    :smaller))\n```", "```java\n;; Bigger than 200\n;; :bigger\n```", "```java\n(macroexpand-1\n'(my-if (> a 200)\n    (do\n      (println\"Bigger than 200\")\n      :bigger)\n    (do\n      (println\"Smaller than 200\")\n      :smaller)))\n\n;; (if (> a 200) (do (println\"Bigger than 200\") :bigger) (do (println\"Smaller than 200\") :smaller))\n```", "```java\n(defmacro my-if [test positive negative]\n  (list 'if test positive negative))\n```", "```java\n(defmacro my-if [test positive negative]\n  '(if test positive negative))\n\n(macroexpand-1\n'(my-if (> a 200)\n    (do\n      (println\"Bigger than 200\")\n      :bigger)\n    (do\n      (println\"Smaller than 200\")\n      :smaller)))\n\n;; (if clojure.core/test user/positive user/negative)\n```", "```java\n(defmacro my-if [test positive negative]\n(if ~test ~positive ~negative))\n```", "```java\n(defmacro>-macro [&params]\n  '(> ~params))\n\n(macroexpand'(>-macro 5 4 3))\n```", "```java\n(defmacro>-macro [&params]\n  '(> ~@params)) ;; In the end this works as if you had written\n                 ;; (> 5 4 3)\n\n(macroexpand'(>-macro 5 4 3))\n```", "```java\n(def a-var\"hello world\")\n\n(defmacro error-macro [&params]\n  '(let [a-var\"bye world\"]\n     (println a-var)))\n\n;; (macroexpand-1 '(error-macro))\n;; (clojure.core/let [user/a-var user/\"bye user/world\"] (clojure.core/println user/a-var))\n```", "```java\n(defmacro error-macro [&params]\n  (let [a-var-name (gensym'a-var)]\n    `(let [~a-var-name \"bye world\"]\n       (println ~a-var-name))))\n```", "```java\n(clojure.core/let [a-var922\"bye world\"] (clojure.core/println a-var922))\n```", "```java\n(macroexpand-1 '(defn sample [a] (println a)))\n\n;; (def sample (clojure.core/fn ([a] (println a))))\n```"]