- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inverting Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the talk about layered architecture in the previous chapter, you’re right
    to expect this chapter to discuss an alternative approach. We’ll start by discussing
    two of the **SOLID**[1](#footnote-015) principles and then apply them to create
    a *Clean* or *Hexagonal* Architecture that addresses the problems of a layered
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-015-backlink) SOLID stands for Single Responsibility Principle,
    Open-Closed Principle, Liskov Substitution Principle, Interface Segregation Principle,
    and Dependency Inversion Principle. You can read more about these Principles in
    *Clean Architecture* by Robert C. Martin or on Wikipedia at [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).'
  prefs: []
  type: TYPE_NORMAL
- en: The Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everyone in software development probably knows the **Single Responsibility
    Principle** (**SRP**) or at least assumes to know it. A common interpretation
    of this principle is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A component should do only one thing and do* *it right.*'
  prefs: []
  type: TYPE_NORMAL
- en: That’s good advice, but not the actual intent of the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: '*Doing only one thing* is actually the most obvious interpretation of “single
    responsibility,” so it’s no wonder that the SRP is frequently interpreted like
    this. Let’s just observe that the name of the SRP is misleading.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the actual definition of the SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A component should have only one reason* *to change.*'
  prefs: []
  type: TYPE_NORMAL
- en: As we see, “responsibility” should actually be translated to “reason to change”
    instead of “do only one thing.” Perhaps we should rename the SRP to the “Single
    Reason to Change Principle.”
  prefs: []
  type: TYPE_NORMAL
- en: If a component has only one reason to change, it might end up doing only one
    thing, but the more important part is that it has only this one reason to change.
  prefs: []
  type: TYPE_NORMAL
- en: What does that mean for our architecture?
  prefs: []
  type: TYPE_NORMAL
- en: If a component has only one reason to change, we don’t have to worry about this
    component at all if we change the software for any other reason because we know
    that it will still work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, it’s very easy for a reason to change to propagate through code via the
    dependencies of a component to other components (see *Figure 3**.1*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Each dependency of a component is a possible reason to change
    this component, even if it is only a transitive dependency (dashed arrows)](img/Figure_03.1_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Each dependency of a component is a possible reason to change this
    component, even if it is only a transitive dependency (dashed arrows)
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, component **A** depends on many other components (either
    directly or transitively) while component **E** has no dependencies at all.
  prefs: []
  type: TYPE_NORMAL
- en: The only reason to change component **E** is when the functionality of **E**
    must change due to some new requirement. Component **A**, however, might have
    to change when any of the other components change because it depends on them.
  prefs: []
  type: TYPE_NORMAL
- en: Many code bases grow harder – and thus more expensive – to change over time
    because the SRP is violated. Over time, components collect more and more reasons
    to change. Having collected many reasons to change, changing one component might
    cause another component to fail.
  prefs: []
  type: TYPE_NORMAL
- en: A tale about side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I once was part of a project where my team inherited a ten-year-old code base
    built by another software shop. The client had decided to replace the development
    team to reduce the ongoing maintenance costs and improve the development speed
    for new features. So, we got the contract.
  prefs: []
  type: TYPE_NORMAL
- en: As was to be expected, it was not easy to gain an understanding of what the
    code actually did, and the changes we made in one area of the code base often
    had side effects in other areas. But we managed by testing exhaustively, adding
    automated tests, and refactoring a lot.
  prefs: []
  type: TYPE_NORMAL
- en: After some time of successfully maintaining and extending the code base, the
    client requested a new feature. And they wanted us to build it in a way that was
    very awkward for the users of the software. So, I proposed to do it in a more
    user-friendly way that was even less expensive to implement since it needed fewer
    overall changes. It needed a small change in a certain very central component,
    however.
  prefs: []
  type: TYPE_NORMAL
- en: The client declined and ordered the more awkward and expensive solution. When
    I asked for the reason, they said that they were afraid of the side effects because
    changes made to that one component by the previous development team had always
    broken something else in the past.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, this is an example of how you can indoctrinate your client to pay extra
    for modifying badly architected software. Luckily, most clients will not play
    along with this game, so let’s try to build well-architected software instead.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency Inversion Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our layered architecture, the cross-layer dependencies always point down
    to the next layer. When we apply the Single Responsibility Principle on a high
    level, we notice that the upper layers have more reasons to change than the lower
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, due to the domain layer’s dependency on the persistence layer, each change
    in the persistence layer potentially requires a change in the domain layer. But
    the domain code is the most important code in our application! We don’t want to
    have to change it when something changes in the persistence code!
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we get rid of this dependency?
  prefs: []
  type: TYPE_NORMAL
- en: The **Dependency Inversion Principle** (**DIP**) provides the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to the SRP, the DIP means what the name suggests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*We can turn around (invert) the direction of any dependency within our* *code
    base**[2](#footnote-014)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-014-backlink) Actually, we can only invert dependencies when
    we have control over the code on both ends of the dependency. If we have a dependency
    on a third-party library, we cannot invert it, since we don''t control the code
    of that library.'
  prefs: []
  type: TYPE_NORMAL
- en: How does that work? Let’s try to invert the dependency between our domain and
    persistence code so that the persistence code depends on the domain code, reducing
    the number of reasons to change the domain code.
  prefs: []
  type: TYPE_NORMAL
- en: We start with a structure like that in *Figure 2**.2* from [*Chapter 2*](B19916_03.xhtml),
    *What’s Wrong with Layers?* We have a service in the domain layer that works with
    entities and repositories from the persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we want to pull up the entities into the domain layer because
    they represent our domain objects and our domain code pretty much revolves around
    changing the state of those entities.
  prefs: []
  type: TYPE_NORMAL
- en: But now, we have a circular dependency between both layers since the repository
    from the persistence layer depends on the entity, which is now in the domain layer.
    This is where we apply the DIP. We create an interface for the repository in the
    domain layer and let the actual repository in the persistence layer implement
    it. The result is something like that in *Figure 3**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – By introducing an interface in the domain layer, we can invert
    the dependency so that the persistence layer depends on the domain layer](img/Figure_03.2_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – By introducing an interface in the domain layer, we can invert
    the dependency so that the persistence layer depends on the domain layer
  prefs: []
  type: TYPE_NORMAL
- en: With this trick, we have liberated our domain logic from the oppressive dependency
    on the persistence code. This is a core feature of the two architectural styles
    we’re going to discuss in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Robert C. Martin coined the term “**Clean Architecture**” in his book with the
    same name.[3](#footnote-013) In a Clean Architecture, in his opinion, the business
    rules are testable by design and independent of frameworks, databases, UI technologies,
    and other external applications or interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[3](#footnote-013-backlink) *Clean Architecture* by Robert C. Martin, Prentice
    Hall, 2017, *Chapter 22*.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the domain code must not have any outward-facing dependencies.
    Instead, with the help of the DIP, all dependencies point toward the domain code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.3* shows what such an architecture might look like on an abstract
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – In a Clean Architecture, all dependencies point inward toward
    the domain logic (Source: Clean Architecture by Robert C. Martin)](img/Figure_03.3_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3 – In a Clean Architecture, all dependencies point inward toward
    the domain logic (Source: Clean Architecture by Robert C. Martin)'
  prefs: []
  type: TYPE_NORMAL
- en: The layers in this architecture are wrapped around each other in concentric
    circles. The main rule in such an architecture is the “**Dependency Rule**,” which
    states that all dependencies between those layers must point inward.
  prefs: []
  type: TYPE_NORMAL
- en: The core of the architecture contains the domain entities, which are accessed
    by the surrounding use cases. The use cases are what we have called services earlier,
    but are more fine-grained to have a single responsibility (i.e., a single reason
    to change), thus avoiding the problem of *broad services*, as we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Around this core, we can find all the other components of our application that
    support the business rules. This support can mean providing persistence or providing
    a UI, for example. Also, the outer layers may provide adapters to any other third-party
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Since the domain code knows nothing about which persistence or UI framework
    is used, it cannot contain any code specific to those frameworks and will concentrate
    on the business rules. We have all the freedom we can wish for to model the domain
    code. We could, for example, apply **Domain-Driven Design** (**DDD**) in its purest
    form. Not having to think about persistence or UI-specific problems makes that
    so much easier.
  prefs: []
  type: TYPE_NORMAL
- en: As we might expect, Clean Architecture comes at a cost. Since the domain layer
    is completely decoupled from the outer layers such as the persistence and UI layers,
    we have to maintain a model of our application’s entities in each of the layers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume, for instance, that we’re using an **object-relational mapping**
    (**ORM**) framework in our persistence layer. An ORM framework usually expects
    specific entity classes that contain metadata describing the database structure
    and the mapping of object fields to database columns. Since the domain layer doesn’t
    know the persistence layer, we cannot use the same entity classes in the domain
    layer and have to create them in both layers. This means that the persistence
    layer needs to map the domain entities to its own representation. A similar mapping
    applies between the domain layer and other outer layers.
  prefs: []
  type: TYPE_NORMAL
- en: But that’s a good thing! This decoupling is exactly what we wanted to achieve
    to free the domain code from framework-specific problems. The Java Persistence
    API (the standard object-relational API in the Java world), for instance, requires
    the ORM-managed entities to have a default constructor without arguments that
    we might want to avoid in our domain model. In [*Chapter 9*](B19916_09.xhtml#_idTextAnchor081),
    *Mapping* *b**etween Boundaries*, we’ll talk about different mapping strategies,
    including a *no-mapping* strategy that just accepts the coupling between the domain
    and persistence layers.
  prefs: []
  type: TYPE_NORMAL
- en: Since *Clean Architecture* by Robert C. Martin is somewhat abstract, let’s go
    a level of detail deeper and look at *Hexagonal Architecture*, which gives the
    *Clean Architecture* principles a more concrete shape.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **Hexagonal Architecture** stems from Alistair Cockburn and has been
    around for quite some time.[4](#footnote-012) It applies the same principles that
    Robert C. Martin later described in more general terms in *Clean Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: '[4](#footnote-012-backlink) The primary source for the term "Hexagonal Architecture"
    seems to be an article on Alistair Cockburn''s website at [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – A Hexagonal Architecture is also called a “Ports and Adapters”
    architecture since the application core provides specific ports for each adapter
    to interact with](img/Figure_03.4_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – A Hexagonal Architecture is also called a “Ports and Adapters”
    architecture since the application core provides specific ports for each adapter
    to interact with
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.4* shows what a Hexagonal Architecture might look like. The application
    core is represented as a hexagon, giving this architectural style its name. The
    hexagon shape has no meaning, however, so we might just as well draw an octagon
    and call it “Octagonal Architecture.” According to legend, the hexagon was simply
    used instead of the common rectangle to show that an application can have more
    than four sides connecting it to other systems or adapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the hexagon, we find our domain entities and the use cases that work
    with those entities. Note that the hexagon has no outgoing dependencies so the
    Dependency Rule from Martin’s Clean Architecture holds true. Instead, all dependencies
    point toward the center.
  prefs: []
  type: TYPE_NORMAL
- en: Outside the hexagon, we find various **adapters** that interact with the application.
    There might be a web adapter that interacts with a web browser, some adapters
    interacting with external systems, and an adapter that interacts with a database
    for persistence.
  prefs: []
  type: TYPE_NORMAL
- en: The adapters on the left side are adapters that drive our application (because
    they call our application core) while the adapters on the right side are driven
    by our application (because they are called by our application core).
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow communication between the application core and the adapters, the application
    core provides specific **ports**. For driving adapters, such a port might be an
    interface that is implemented by one of the use case classes in the core and called
    by the adapter. For a driven adapter, it might be an interface that is implemented
    by the adapter and called by the core. We might even have multiple adapters implementing
    the same port: one for communicating with a real external system, and one for
    communicating with a mock to be used in testing, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: To clearly call out a central attribute of Hexagonal Architecture, *the application
    core (the hexagon) defines and owns the interface to the outside* (*the ports*).
    The adapters then work with this interface. This is the Dependency Inversion Principle
    applied at the architecture level.
  prefs: []
  type: TYPE_NORMAL
- en: Due to its central concepts, this architecture style is also known as a **Ports
    and** **Adapters** architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Just like Clean Architecture, we can organize this Hexagonal Architecture into
    layers. The outermost layer consists of the adapters that translate between the
    application and other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can combine the ports and use case implementations to form the application
    layer because they define the interface of our application. The final layer contains
    the domain entities implementing the business rules.
  prefs: []
  type: TYPE_NORMAL
- en: The business logic is implemented in the use case classes and entities. The
    use case classes are narrow **domain services**, implementing just a single use
    case. We can choose to combine multiple use cases to a broader domain service,
    of course, but ideally, we do this only when the use cases are often used together,
    to increase maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Potentially, we will want to introduce the concept of application services,
    too. An **application service** is a service that coordinates calls to use cases
    (**domain services**), as shown in *Figure 3**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A Hexagonal Architecture using the DDD concepts of application
    and domain services](img/Figure_03.5_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – A Hexagonal Architecture using the DDD concepts of application
    and domain services
  prefs: []
  type: TYPE_NORMAL
- en: Here, the application services translate between the input and output ports
    and the domain services, shielding the domain services from the outside world,
    and potentially coordinating between the domain services. The **Domain Service**
    boxes are synonymous with the **Use Case** boxes from *Figure 3**.4*; we’re just
    now using terminology borrowed from DDD.
  prefs: []
  type: TYPE_NORMAL
- en: As this discussion implies, we’re free to design our application code as we
    see fit inside the hexagon. We can go simple or sophisticated, matching the complexity
    and size of our application. We will learn more about managing code within our
    hexagon in [*Chapter 13*](B19916_13.xhtml#_idTextAnchor112), *Managing Multiple*
    *Bounded Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll discuss a way to organize such an architecture in
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Call it “Clean Architecture,” “Hexagonal Architecture,” or “Ports and Adapters
    Architecture” – by inverting our dependencies so that the domain code has no dependencies
    on the outside, we can decouple our domain logic from all those persistence- and
    UI-specific problems and reduce the number of reasons to make changes throughout
    the code base. And fewer reasons to change lead to better maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: The domain code is free to be modeled as best fits the business problems, while
    the persistence and UI code are free to be modeled as best fits the persistence
    and UI problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this book, we’ll apply the Hexagonal Architecture style to a
    web application. We’ll start by creating the package structure of our application
    and discussing the role of dependency injection.
  prefs: []
  type: TYPE_NORMAL
