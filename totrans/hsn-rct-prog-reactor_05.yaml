- en: SpringWebFlux for Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we have discussed Reactor as a standalone framework. We
    have also seen how we can build publishers and subscribe to them. Reactor is well
    suited to handling the exchanging of large volumes of data, but it is important
    to note that Reactor is not limited to standalone programming only; it can also
    be used to build web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, we built enterprise-grade web applications using the SpringMVC
    framework, a synchronous and blocking framework from the Spring ecosystem. SpringMVC
    can also serve asynchronous non-blocking data using Servlet 3.1, but then it moves
    away from the concepts of request mappers and filters. This makes the framework
    quite difficult to work with. Furthermore, when building microservice architecture
    for high performance, the framework may not be the optimum choice. With such an
    architecture, we would like to have independent, scalable, and resilient services.
    SpringMVC doesn't define any of these characteristics. As discussed in [Chapter
    1](56427f5d-9ba0-4582-be2a-1b7f3f116287.xhtml), *Getting Started with Reactive
    Streams,* the previously discussed non-functional requirements are the characteristics
    of the Reactive Manifesto.
  prefs: []
  type: TYPE_NORMAL
- en: Noticing this gap, the Spring community came up with the SpringWebFlux framework.
    This framework is based on Reactor and enables the creation of web-based microservices.
    Not just non-blocking, SpringWebFlux is a functional framework, which allows us
    to use Java 8 lambda functions as web endpoints. The framework offers a complete
    solution for non-blocking web stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Standard Edition, JDK 8 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA IDE 2018.1 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to SpringWebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable us to build web-based services, SpringWebFlux offers the following
    programming models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Annotations**: Annotations were originally part of the SpringMVC stack. These
    annotations are also supported by the SpringWebFlux framework. This is the easiest
    way of getting started with the SpringWebFlux stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional endpoints**: This model allows us to build Java 8 functions as
    web endpoints. The application can be configured as a set of routes, handlers,
    and filters. It then enables passing all of these as lambda functions in order
    to build the application in a functional paradigm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to work with SpringWebFlux, we need to configure an underlying server.
    While writing this book, Netty, Tomcat, Jetty, and Undertow are the choices currently
    offered here. Netty is often used as the standard choice because it performs well
    for asynchronous, non-blocking applications. It is also a non-servlet-based server,
    unlike Tomcat and Jetty. The following diagram depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d262aa1a-cecf-41cc-b454-11fba6e16c16.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SpringWebFlux supports annotation-based controllers. This is in line with SpringMVC.
    There are two annotations used to create controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Controller`: The annotation defines a generic web component. Given a request,
    it creates a model object and generates a dynamic view response for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RestController`: The annotation defines a RESTful web service. Given a request,
    it returns a response as JSON or XML. This is unlike the generic controller, which
    is capable of generating a dynamic web page for a request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the controllers serves a request pattern. The following are annotations
    that can be used to define the request patterns served by a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping`: This annotation is used to mark a controller. It defines
    a request pattern prefix. It can also be used to define request headers, media
    types, HTTP methods, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping`: This annotation is specific to the `GET` HTTP method. It can
    be used to define a `GET` HTTP request URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PostMapping`: This annotation is specific to the `POST` HTTP method. It can
    be used to define a `POST` HTTP request URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PutMapping`: This annotation is specific to the `PUT` HTTP method. It can
    be used to define a `PUT` HTTP request URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DeleteMapping`: This annotation is specific to the `DELETE` HTTP method.
    It can be used to define a `DELETE` HTTP request URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PatchMapping`: This annotation is specific to the `PATCH` HTTP method. It
    can be used to define a `PATCH` HTTP request URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that `@RequestMapping` matches all HTTP request methods,
    unlike the rest of the specific method annotations.
  prefs: []
  type: TYPE_NORMAL
- en: SpringBoot Starter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's try to define a RESTful Fibonacci web service using the previously
    discussed annotations support. To do this, we are going to use Spring Boot as
    it offers a quick way to create enterprise-grade Spring applications. The Spring
    Boot project provides starter dependencies for all Spring modules. Each starter
    has assumed default conventions to ensure that a project is up and running without
    a fuss.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use SpringWebFlux, we need to add the `spring-boot-starter-webflux`
    dependency to our project. Let''s revisit our `build.gradle`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `build.gradle`, we have the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `spring-boot` plugin has been added to our `gradle` build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `spring-boot-dependency` plugin has been added to our `gradle` build. The
    plugin adds a Maven-like dependency management capability to our `gradle` build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spring-boot-starter-webflux` has been added as a dependency. This project
    brings in transitive dependencies for other `webflux`-related projects, such as
    `webflux`, `netty-core`, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `spring-boot-gradle` plugin has been added under the plugins configuration.
    This enables us to run the Spring application from the command line using the
    `gradlew bootrun` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, `Spring-boot-start-webflux` will bring a Netty dependency. If we
    decide to use Tomcat or any other server, we would exclude `spring-boot-starter-reactor-netty`
    and include said server dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add a controller that can serve Fibonacci numbers. As discussed
    in the preceding sections, we need to add a class with the `@RestController` annotation.
    Let''s look at the following controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding class, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added `@RestController` to the `ReactiveController` class. This enables the
    class as a RESTful web service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Added `@GetMapping` to the `fibonacciSeries` method. This allows us to invoke
    the method on receiving a HTTP `GET` request for the `/fibonacci` URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to note here that the `fibonacciSeries` method returns a `Flux<Long>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we also need to add a `Main` class, which can run `SpringApplication`.
    The `Main` class must be annotated with `@EnableWebFlux` to ensure that the Spring
    context instantiates and registers SpringWebFlux-related classes. This is depicted
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application using the `gradlew bootrun` command. This will start the
    Netty server on port `8080`. Lastly, look up `http://localhost:8080/fibonacci`
    to receive the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e5eb5b5-51b0-4239-a8e3-b9073d10773d.png)'
  prefs: []
  type: TYPE_IMG
- en: Method parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding code, the `fibonacciSeries` request method did not accept
    any arguments. This is because we did not expect any input. In case we foresee
    any input parameters, they can be bound with the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@PathVariable`: This annotation is used to access values for URI template
    variables. These templates are automatically converted into an appropriate type.
    If no matching type is found, a `TypeMismatchException` is raised:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`@RequestParam`: The annotation is used to determine values passed as query
    parameters. Here, data type conversion is also performed automatically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`@RequestHeader`: The annotation is used to determine values passed in request
    headers. Data type conversion into the target type is performed automatically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`@RequestBody`: The annotation is used to determine values passed in the request
    body. Data type conversion into the target type is performed automatically. SpringWebFlux
    supports reading data as reactive types of Flux and `Mono`, and thus performs
    a non-blocking read:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`@CookieValue`: This annotation is used to determine the HTTP cookie value
    as part of the request. Data type conversion into the target type is performed
    automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ModelAttribute`: This annotation is used to determine an attribute from the
    request model or instantiate one if not present. Once created, property values
    of the attribute are initialized using the query parameters passed and the submitted
    form fields:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`@SessionAttribute`: This annotation is used to determine preexisting session
    attributes. Data type conversion into the target type is performed automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestAttribute`: This annotation is used to determine preexisting request
    attributes created by a previous filter execution. Data type conversion into the
    target type is performed automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the method parameters, there is `@ResponseBody`, which is used to
    serialize the `return` method using the appropriate HTTP writer. This can be used
    to return JSON and XML type responses from the request method.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applications often raise exceptions while processing requests. These exceptions
    must be handled properly, otherwise they will send back a HTTP 500 error to the
    requesting client. SpringWebFlux supports exception handling by creating methods
    that are annotated with `@ExceptionHandler`. These exception handlers can have
    the exception raised as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: An exception handler can have the same return types as request methods. Optionally,
    we would like to set the HTTP status as part of exception handling, but Spring
    does not do this automatically. It can be accomplished by returning a `ResponseEntity`,
    which contains the response body as well as the required HTTP status code.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we configured SpringWebFlux using the traditional
    annotation approach. Now, we will see how we can use Java 8 lambdas to configure
    SpringWebFlux in a functional manner. Let's looks at the key components required
    to get this up and running.
  prefs: []
  type: TYPE_NORMAL
- en: The handler function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The handler function is responsible for serving a given request. It takes the
    request in the form of a `ServerRequest` class and generates the response as `ServerResponse`.
    Both `ServerRequest` and `ServerResponse` are immutable Java 8 classes. These
    classes support reactive types of `Mono` and Flux for reading/writing data passed
    in the body of the request/response. Let''s try to build our first `hello-world`
    example using the preceding components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda takes a `ServerRequest` input request type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It tries to determine whether a `name` query parameter has been passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function returns the OK(HTTP 200) response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response body contains `Hello to the world`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This was only a simple example but it clearly demonstrates what can be accomplished
    using Java 8 lambdas. We can add a query to a reactive database such as Mongo,
    or an external invocation, and return the response as Mono or Flux. If we look
    closely at `ServerRequest`, the following methods have been provided to convert
    request-body as reactive type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bodyToMono(Class<T> type)`: This reads a single object of the specified type
    as a Mono response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bodyToFlux(Class<T> type)`: This reads multiple objects of the specified type
    as a Flux response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we look at the preceding code, we have used the `BodyInserters.fromObject()`
    static method to write to the response body. This is not the only method to do
    this. There are many methods to write back the response body, some of which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fromObject`: This method writes back data as an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromPublisher`: This method writes back data from a given Reactive Streams
    publisher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromFormData`: This method writes back the given key-value pair and form data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromMultipartData`: This method writes back the given data as multipart data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handler functions written as lambdas are quite convenient but they become difficult
    to read and maintain in the long run. It is often recommended to group the handler
    functions for a particular functionality in one single handler class.
  prefs: []
  type: TYPE_NORMAL
- en: The router function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The router function is responsible for routing incoming requests to the correct
    handler function. If we compare this to the annotation approach, then it is analogous
    to the `@RequestMapping` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A request is matched using `RequestPredicate`, which tries to validate the
    intended matching criteria. Our previously created `helloHandler` can be configured
    in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It registers a predicate for the `/hello` path
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a request matches this path, the router invokes `helloHandler`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we look at `RequestPredicate`, this is a functional interface in which we
    need to implement the test method only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, implementing `RequestPredicate` is not required. The framework provides
    the `RequestPredicates` utility class with most commonly used predicates. The
    utility provides routing based on HTTP methods, HTTP headers, query parameters,
    URL path, and so on. Let''s looks at the methods offered by the `RequestPredicates`
    utils class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods** | **Match** |'
  prefs: []
  type: TYPE_TB
- en: '| `path(String pattern)` | Predicate matches the passed URL |'
  prefs: []
  type: TYPE_TB
- en: '| `patternDELETE(String pattern)` | Predicate matches the passed URL pattern
    when HTTP method is `DELETE` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `GET` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `PUT` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `PATCH` |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `HEAD` |'
  prefs: []
  type: TYPE_TB
- en: '| `method(HttpMethod method)` | Predicate determines if the request method
    is the same as that passed |'
  prefs: []
  type: TYPE_TB
- en: '| `oneaccept(MediaType type)` | Predicate determines if the request accepts
    header contains the given `MediaType` |'
  prefs: []
  type: TYPE_TB
- en: '| `contentType(mediaType type)` | Predicate determines if the request''s `contentType`
    header contains the given `MediaType` |'
  prefs: []
  type: TYPE_TB
- en: '| `headers(Predicate headerPredicate)` | Predicate determines if the request
    header matches the predicate query |'
  prefs: []
  type: TYPE_TB
- en: '| `Param(String name, String value)` | Predicate determines if the request
    query parameters contain the key-value pair |'
  prefs: []
  type: TYPE_TB
- en: '| `all()` | Predicate always matches the request |'
  prefs: []
  type: TYPE_TB
- en: 'We can combine one or more of these predicates to build composite matching
    criteria. The criteria can be combined using the following methods of `RequestPredicate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RequestPredicate.and(RequestPredicate)`: Builds the logical `AND` criteria,
    where both must match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RequestPredicate.or(RequestPredicate)`: Builds the logical `OR` criteria,
    where either can match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RequestPredicate.negate()`: Builds the logical `NOT` criteria, which it must
    not match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RequestPredicates` are configured using the `Route` functions from the `RouterFunctions`
    utility class. Additional routes can be configured using the following methods
    from `RouterFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterFunctions.router(predicate,handler)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RouterFunction.andRoute(predicate,handler)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HandlerFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HandlerFilter` is analogous to the Servlet filter. This executes before the
    request gets processed by `HandlerFunction`. There could be chain filters that
    get executed before the request gets served. If a filter sends back a `ServerResponse`,
    then the request is terminated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a filter to `helloRoute` using the `filter()` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The filter takes a request and the next handler function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating whether or not the request headers contain the `UTF-8` charset in
    the Accept-Language header
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, forward the request to the next function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If not, then build a `ServerResponse` with the status as `BAD_REQUEST`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/da920649-70ec-46c0-a396-7fed5ef78992.png)'
  prefs: []
  type: TYPE_IMG
- en: HttpHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have mapped a request using the handler and router, the only step
    left is to start the server. SpringWebFlux enables us to programmatically start
    the server. In order to do so, we have to get `HttpHandler` from `RouterFunction`
    and then start the required server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is specific to Netty, as we are using `reactor-netty` in
    our current example. In the preceding code, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting the `helloRoute` to a `HttpHandler` using `RoterFunctions.toHttpHandler`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating Netty's `ReactorHttpHandlerAdapter` and using it to configure
    the Netty `HttpServer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we block to listen for incoming requests and serve them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding configuration is specific to the underlying server. While working
    with `Undertow`, the configuration can be built using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is applicable to Tomcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can leave all this configuration to Spring and use the Spring
    `DispatcherHandler`-based configuration to start the server. The configuration
    is Java annotation-based. The configuration automatically registers the following
    additional components to support functional endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterFunctionMapping`: â€‰This determines the list of `RouterFunction` `<?>`
    beans in the Spring configuration. This combines them and routes the request to
    the correct `RouterFunction`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HandlerFunctionAdapter`: This invokes the correct `HandlerFunction` when a
    request is received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerResponseResultHandler`: This writes back the `ServerResponse` from the
    `HandlerFunction` invocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding components are registered by Spring when we use the `@EnableWebFlux`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci functional router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have seen the basics of functional mappings, let''s try to render
    the Fibonacci series using them. We will use the same Fibonacci generator developed
    in the previous section. We have seen that we can write a Reactive Stream publisher
    into `ServerResponse`, as demonstrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a `FibonacciGenerator` to generate the series
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configured a route for `/fibonacci` and then sent back the response of Fibonacci
    numbers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method is annotated with `@Bean`, which will automatically register this
    route with `SpringContext`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is annotated with `@Configuration`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, all that remains is to configure SpringWebFlux to pick this configuration.
    This is done by creating a `Main` class and annotating it with the required annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class is exactly the same as we used to work with annotations
    in SpringWebFlux. Now, let''s run the server using the `spring-boot` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings up Netty on port `8080`. Let''s submit the `http://localhost:8080/fibonacci`
    URL to determine the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9b25ad7-bdeb-44b4-bd2b-1f3df4240645.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at using the SpringWebFlux framework to build web-based
    microservices. We also discussed the various server options offered by the project
    and looked at the traditional annotation-based approach to building microservices.
    We discovered that all annotations from the SpringMVC project are supported by
    the SpringWebFlux project. Next, we took the functional approach to building microservices.
    We configured the router and handler functions to build the Fibonacci web service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at ways to add other web features, such as
    web page templates, security, and much more, to a SpringWebFlux-based web service.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we configure the SpringWebFlux project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What `MethodParameter` annotations are supported by SpringWebFlux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of `ExceptionHandler`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of `HandlerFunction`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of `RouterFunction`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the use of `HandlerFilter`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
