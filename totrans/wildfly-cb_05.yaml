- en: Chapter 5. Managing the Datasource Subsystems with the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a non JDBC-4 compliant driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and removing a datasource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the datasource connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the datasource's statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a connection pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and removing XA-Datasource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to manage WildFly datasource subsystems
    with the CLI. This is independent of the WildFly operation mode. For this reason
    and to facilitate the configuration, we will be running WildFly in the standalone
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: A datasource is the component used by applications to connect to the database.
    The datasource, in turn, uses a driver to communicate with the underlying database
    properly. Hence, for WildFly to provide database integration, it needs a driver
    and a datasource.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly comes with a default configuration, which is the `ExampleDS` datasource,
    bound to the "H2" driver. H2 is a Java SQL database, used mainly as an in-memory
    DB for testing purpose with SQL support.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly automatically recognizes any JDBC 4 compliant driver. For this reason,
    a driver can be installed as a module (that is, static deployment) or it can be
    deployed as any normal application.
  prefs: []
  type: TYPE_NORMAL
- en: In the first method, you will have to replicate the driver module installation
    in all the hosts where the applications and configuration require such a driver.
    On the other hand, by using dynamic deployment in the domain mode, the driver
    can be spread to all server groups, and thus to all available hosts, with just
    one command or a click.
  prefs: []
  type: TYPE_NORMAL
- en: A datasource can also be deployed in the old fashioned way by using a `-ds.xml`
    file. Even though this alternative is very helpful when migrating from JBoss 5
    and JBoss 6, it is not the best choice when configuring a production environment.
    That's because the datasource cannot be altered via a management interface, such
    as CLI and Web Admin Console. Also, the datasource cannot be configured to take
    advantage of the security concerns, such as security domains and password vaults
    (we will discuss these topics later in the book).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a non JDBC-4 compliant driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to make a JDBC driver compliant to version
    4\. This is needed to install the driver and to make it available for your datasources,
    and hence to your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you already have a JDBC 4 compliant driver, you can skip this recipe; otherwise,
    I assume that you do not have a JDBC driver and I'll refer to it as `non-jdbc-4-driver.jar`,
    throughout the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make your driver JDBC 4 compliant, you just need to add a file into it,
    as described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a temporary folder and navigate into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place your `non-jdbc-4-driver.jar` driver file into it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `META-INF/services` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file named `java.sql.Driver` and place it into the folder specified
    in step 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the file `java.sqlDriver` and enter one line containing the fully qualified
    name of the class implementing the driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Starting from the empty folder as per step `1`, update the file `non-jdbc-4-driver.jar`
    using the JAR tool as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are now ready to install or deploy your new JDBC 4 compliant driver.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and removing a datasource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most used features that an application comes with is the possibility
    to persist states (such as user information, orders, and so on) into a database.
    In this recipe, we will learn how to configure datasources and a JDBC 4 compliant
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we begin, we need to have a running database installed on our computer,
    or on a remote server. In this recipe, we will use a MySQL database running locally
    and listening on port `3306`—the installation and configuration of the MySQL database
    server is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a new datasource consists of two separate steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the JDBC driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the datasource itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step can be done in two different ways. You can install a JDBC driver
    by deploying it as a normal artifact, or you can install it as a WildFly module.
  prefs: []
  type: TYPE_NORMAL
- en: First, download the latest version (which, as per this writing, is "5.1.35")
    of the MySQL JDBC connector from [http://dev.mysql.com/downloads/connector/j/](http://dev.mysql.com/downloads/connector/j/),
    and place it into your WildFly Cookbook directory `WFC`, under your `home` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a JDBC driver as a WildFly module, we need to perform the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the modules folder `$WILDFLY_HOME/modules/system/layers/base` and create
    a subfolder structure that matches your module name as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Place the `~/WFC/mysql-connector-java-5.1.35-bin.jar` file, that you downloaded
    previously, into the `main` folder .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `main` folder, create a file named `module.xml` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, I've emphasized the name of the module which matched the subfolders
    structure—except for the main folder which just corresponds to the `version`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! Now we are ready to add the driver to the datasource subsystem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start WildFly and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we can continue, please create a database on your running MySQL server
    instance named `wildflycookbook`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have the JDBC driver installed, we are ready to configure our datasource.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a running WildFly server, open your command-line tool and connect to the
    CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, on listing the available datasources, you should find our newly created
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to remove a datasource, invoke `remove` next to it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, configuring a datasource is not that tough, but what it needs
    to get there is a lot of work. The datasource itself is just a reference to the
    database, which involves a connector, that is, the driver. In fact, in the DS
    configuration, I emphasized the `driver-name` attribute that matches the driver
    that we defined in the *Getting ready* section. Furthermore, I emphasized the
    `password` attribute that you should change with regard to your database configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Datasource configuration comes with more parameters such as defining and sizing
    a connection pool, but we will see that later in this chapter with a dedicated
    recipe. You will also learn that you can have an XA-Datasource, which actually
    enables distributed transaction across different transactional systems.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the datasource connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you might see errors in your log's application because of something
    going wrong with your persistence storage. The first thing to do in that case,
    is to check if the database is up and running by testing its connection; you may
    even realize that you are pointing to a wrong one or you misspelled the connection
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is based on the previous one, where we have configured a datasource
    which connects to a local MySQL database, so we will test our database connection
    with the WildFlyCookBookDS datasource. You can test the connection with a datasource
    of your choice as long as you provide the correct configuration as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a running WildFly server, open your command-line tool and connect to the
    CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! Wasn't it easy?
  prefs: []
  type: TYPE_NORMAL
- en: Reading the datasource's statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to enable the statistics of the datasource
    to check whether we are getting the most out of it, or if we need to tune something
    with the datasource, or at worst, scale with the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get an idea of what is going on with our datasource, let''s generate some
    traffic towards the database. In this case, we will use the application named
    `datasource-traffic-generator`. To obtain the artifact to deploy, please refer
    to the *Software prerequisites* recipe in [Chapter 1](ch01.html "Chapter 1. Welcome
    to WildFly!"), *Welcome to WildFly!*. Furthermore, in the source code of the application,
    you can find an Apache JMeter (also JMeter) project, available at the following
    path: `datasource-traffic-generator/src/main/resources/HTTP Request Defaults.jmx`.'
  prefs: []
  type: TYPE_NORMAL
- en: Briefly, Apache JMeter is a testing tool used to make a stress test; as a matter
    of fact, we will stress the `datasource-traffic-generator` application, which
    inserts some data into the DB.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can download the Apache JMeter binary, from [http://jmeter.apache.org/download_jmeter.cgi](http://jmeter.apache.org/download_jmeter.cgi).
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation is quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Just unzip the downloaded package `apache-jmeter-2.13.zip`, into the `~/WFC`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run it, from the command line, navigate to the JMeter folder and issue the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything goes well, you should see the JMeter tool as depicted in the
    following image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Getting ready](img/3744_05_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Apache JMeter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Furthermore, the database that we are going to use is MySQL. In that, create
    a database named `wildflycookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, create a table named `USER`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a running WildFly server, open your command-line tool and connect to the
    CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, deploy the `datasource-traffic-generator.war` bundle as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable JDBC and Pool statistics with the following commands on the CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `datasource-traffic-generator/src/main/resources/HTTP Request Defaults.jmx`
    JMeter project and hit the start button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As soon as you hit the play button in JMeter, in the WIldFLy CLI, execute the
    following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is depicted in the following image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/3744_05_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, we executed two commands, one to retrieve information at the
    `jdbc` level, and one to retrieve information about the `pool` configured within
    the datasource.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of executing two commands within the CLI, you can use just one command
    to retrieve a lot more information. This can be helpful in parsing the data outside
    the CLI; also keep in mind that the output is very similar to the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, you can execute a CLI command outside the CLI using a bash-script,
    python, or Java and then parse the result to retrieve just the information you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a CLI command using the bash-shell, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Setting a connection pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous recipe, sometimes we need to extract some information regarding
    the behavior of database integration. Many times, when your application's concurrent
    users are in the order of hundreds or thousands, you have to serve multiple DB
    connections at a time. This is exactly what we will learn in this recipe, using
    the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of a connection pool like a bucket pre-filled with a minimum number of
    ready-to-use connections for your application. There is also an upper bound limit
    that defines the maximum number of connections that the pool can hold. The default
    values for the minimum and maximum size of the pool are `0` and `20` respectively,
    with the `prefill` attribute set to `false` by default. This means that when a
    datasource is started up, its connection pool is created with `0` active and valid
    connections, and that it can hold up to 20 connections.
  prefs: []
  type: TYPE_NORMAL
- en: Why would you use a connection pool? Because creating a connection involves
    a lot of things under the hood, so having it ready helps you with the performance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a running WildFly server, open your command line tool and connect to the
    CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previously mentioned commands created a pool for our connections, so that
    we can count to a series of available connections that goes from 10 to 20.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more option that we can use to boost our database connection is to have
    our connection pool pre-filled with connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we need set the `pool-prefill` attribute to `true`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, not all changes are made at runtime; we often need to reload
    the WildFly configuration, like in this case. To reload the server (we had a recipe
    for that, both standalone and domain mode), execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following image shows the `WildFlyCookbookDS` datasource with its new Pool
    configuration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![There''s more…](img/3744_05_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There is also one more important aspect, which is worth mentioning about the
    datasource connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you pre-fill your pool with valid connections and then the database
    crashes or it gets restarted? Well, your connections might look valid in the pool,
    but the reference to the underlying database has changed, thus they will not be
    able to query your data. Fortunately, there are a few parameters that can help
    you solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you need to choose a mechanism to validate your connection. You
    can opt for a time based approach, or decide to check your connection every time
    it is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first approach consists of setting the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`background-validation=true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`background-validation-millis=30000`—default is `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the second approach consists of setting the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate-on-match=true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whichever approach you use, always set the other one to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have chosen the validation mechanism, you need to specify how to check
    if the connection is valid. You can achieve this by using one of the following
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`check-valid-connection-sql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid-connection-checker-class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both the attributes are database specific. The first one must contain a valid
    SQL code (for example `SELECT 1` or `SELECT 1 FROM DUAL`). The second one delegates
    its check algorithm to a class. WildFly provides checker classes for the most
    used databases, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Checker class** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.db2.DB2ValidConnectionChecker` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.mssql.MSSQLValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLReplicationValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.novendor.GoodForSecondsValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.novendor.JDBC4ValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.novendor.NullValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.novendor.SQLExceptionValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.oracle.OracleValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.sybase.SybaseValidConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Last, but not the least, you can count on two other attributes that help you
    clean up connections: `stale-connection-checker-class-name` and `exception-sorter-class-name`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one provides you with an easy way to clean up stale connections;
    you can rely on a generic class, and DB2 and Oracle specific classes, as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Generic/specific class** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.novendor.AlwaysStaleConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.novendor.NullStaleConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.db2.DB2StaleConnectionChecker` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.oracle.OracleStaleConnectionChecker`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The second attribute provides you with an easy way to clean up connections
    that threw a `FATAL` exception, and relative to your database, you can rely on
    the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.db2.DB2ExceptionSorter` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.informix.InformixExceptionSorter`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLExceptionSorter` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.mssql.MSSQLExceptionSorter` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.novendor.AlwaysExceptionSorter` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.novendor.NullExceptionSorter` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.oracle.OracleExceptionSorter` |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `org.jboss.jca.adapters.jdbc.extensions.sybase.SybaseExceptionSorter` |'
  prefs: []
  type: TYPE_TB
- en: Creating and removing XA-Datasource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XA-Datasources are just like normal datasources, except that they need a different
    `driver-class-name` and they support distributed transaction across heterogeneous
    transactional systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the classical example of an online store: a user buys an item, the
    item is removed from the stock database and an amount of money is subtracted from
    the user''s bank account, which is an external system. Both the operations must
    succeed in order to proceed with payment and shipment.'
  prefs: []
  type: TYPE_NORMAL
- en: This was just an example to give you the idea; we will not go any further.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prerequisite of this recipe is the *Getting ready* section of the *Creating
    and removing a datasource* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a running WildFly server, open your command-line tool and connect to the
    CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, on listing the available datasources you should find our newly created
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you need to remove a datasource, invoke `remove` next to it, as depicted
    in the following image:![How to do it…](img/3744_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first created an XA-DataSource with just the required information and then
    added the other ones, all in batch mode. By doing this, we are able to split the
    configuration process and eventually see where we are going wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we specified the `xa-datasource-class` class, because XA-DataSource
    needs a special class that implements and supports distributed transactions. The
    driver is the same, just specify a different driver class implementation.
  prefs: []
  type: TYPE_NORMAL
