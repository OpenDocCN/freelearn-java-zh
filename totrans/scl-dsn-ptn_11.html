<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Applying What We Have Learned</h1>
                </header>
            
            <article>
                
<p class="mce-root">We have already come a long way in Scala and in learning about the various design patterns in the language. Now, you should be at a stage where you are confident about when to use specific design patterns and when to avoid them. You saw some of the specifics and nice features of Scala that lead to its expressiveness. We went through the <em>Gang of Four</em> design patterns as well as some important functional programming concepts, such as monads. Throughout this book, we have tried to keep mathematical theories to a really basic level, and we have tried to avoid some scary Greek letters in formulas that are hard to understand for non-mathematicians, who may also want to use a functional programming language to its full potential.</p>
<p>The aim of this and the next chapter is to look at Scala from a more practical point of view. Knowing about a language and some design patterns is not always enough for a developer to see the whole picture and the potential of language possibilities. In this chapter, we will show how some of the concepts we presented before can be combined to write even more powerful and cleaner programs. We will look at the following topics:</p>
<ul>
<li>The lens design pattern</li>
<li>The cake design pattern</li>
<li>The pimp my library design pattern</li>
<li>The stackable traits design pattern</li>
<li>The type class design pattern</li>
<li>Lazy evaluation</li>
<li>Partial functions</li>
<li>Implicit injection</li>
<li>Duck typing</li>
<li>Memoization</li>
</ul>
<p>Some of the sections in this chapter will show concepts that we haven't seen before. Others will combine some of the features of Scala and the design patterns we have learned so far in order to achieve something else. In all the cases, though, these concepts will deal with either a specific language feature or a limitation we have already seen, or help in achieving something commonly seen in actual software engineering projects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The lens design pattern</h1>
                </header>
            
            <article>
                
<p>We have already mentioned that, in Scala, objects are immutable. You can, of course, make sure that a specific class has its fields declared as <kbd>vars</kbd>, but this is discouraged and considered bad practice. After all, immutability is good and we should try to aim for it.</p>
<p>The lens design pattern was created specifically for that purpose and allows us to overcome the immutability limitation and at the same time preserve the code's readability. In the following subsections, we will start with some code that doesn't use the lens design pattern and we will go step by step to show how to use it and how it improves our applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lens example</h1>
                </header>
            
            <article>
                
<p>In order to show the lens design pattern in practice, we will create a class hierarchy that is usually seen in enterprise applications. Let's imagine that we are building a system for a library that can be used by the employees of different companies. We might end up with the following classes:</p>
<pre><span>case class </span>Country(name: <span>String</span><span>, </span>code: <span>String</span>)<br/><span>case class </span>City(name: <span>String</span><span>, </span>country: Country)<br/><span>case class </span>Address(number: <span>Int, </span>street: <span>String</span><span>, </span>city: City)<br/><span>case class </span>Company(name: <span>String</span><span>, </span>address: Address)<br/><span>case class </span>User(name: <span>String</span><span>, </span>company: Company<span>, </span>address: Address)</pre>
<p>The representation of these classes as a class diagram will look like the following figure:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9aa271bd-7711-4ae2-9d7f-8e63019437ee.png" style="width:28.00em;height:22.92em;" width="785" height="643"/></div>
<p>The diagram is pretty clear and it doesn't need too much explanation. We basically have a <kbd>User</kbd> class that has other information about the user. Other classes contain others and so on. There is absolutely no challenge in using our classes if we don't want to modify anything. However, as soon as we go on to modify something, it becomes complicated.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Without the lens design pattern</h1>
                </header>
            
            <article>
                
<p>In this subsection, we will see how to use our classes if we want to modify some of their properties.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Immutable and verbose</h1>
                </header>
            
            <article>
                
<p>Without getting into too much detail, let's see what an example application would look like:</p>
<pre><span>object </span>UserVerboseExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>uk = <span>Country</span>(<span>"United Kingdom"</span><span>, </span><span>"uk"</span>)<br/>    <span>val </span>london = <span>City</span>(<span>"London"</span><span>, </span>uk)<br/>    <span>val </span>buckinghamPalace = <span>Address</span>(<span>1</span><span>, </span><span>"Buckingham Palace Road"</span><span>, </span>london)<br/>    <span>val </span>castleBuilders = <span>Company</span>(<span>"Castle Builders"</span><span>, </span>buckinghamPalace)<br/>    <span>val </span>switzerland = <span>Country</span>(<span>"Switzerland"</span><span>, </span><span>"CH"</span>)<br/>    <span>val </span>geneva = <span>City</span>(<span>"geneva"</span><span>, </span>switzerland)<br/>    <span>val </span>genevaAddress = <span>Address</span>(<span>1</span><span>, </span><span>"Geneva Lake"</span><span>, </span>geneva)<br/>    <span>val </span>ivan = <span>User</span>(<span>"Ivan"</span><span>, </span>castleBuilders<span>, </span>genevaAddress)<br/>    System.<span>out</span>.println(ivan)<br/>    System.<span>out</span>.println(<span>"Capitalize UK code..."</span>)<br/>    <strong>val ivanFixed = ivan.copy(</strong><br/><strong>      company = ivan.company.copy(</strong><br/><strong>        address = ivan.company.address.copy(</strong><br/><strong>          city = ivan.company.address.city.copy(</strong><br/><strong>            country = ivan.company.address.city.country.copy(</strong><br/><strong>              code = ivan.company.address.city.country.code.toUpperCase</strong><br/><strong>            )</strong><br/><strong>          )</strong><br/><strong>        )</strong><br/><strong>      )</strong><br/><strong>    )</strong><br/>    System.<span>out</span>.println(ivanFixed)<br/>  }<br/>}</pre>
<p>The preceding application creates one user for our library and then decides to change the company country code, as we initially created it in lowercase characters. The output of the application looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c6b7b500-1d33-4ee4-bc5b-e7132d736473.png" width="724" height="183"/></div>
<p>Our application works correctly but as you can see in the highlighted code, it is extremely verbose and long and making a mistake is really easy. We don't want to write code like this, as it will be hard to maintain and change in the future.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using mutable properties</h1>
                </header>
            
            <article>
                
<p>The first thought that might come into your head is to change the classes and make the properties variable. Here is how our case classes would change:</p>
<pre><span>case class </span>Country(<span>var </span>name: <span>String</span><span>, </span><span>var </span>code: <span>String</span>)<br/><span>case class </span>City(<span>var </span>name: <span>String</span><span>, </span><span>var </span>country: Country)<br/><span>case class </span>Address(<span>var </span>number: <span>Int, </span><span>var </span>street: <span>String</span><span>, </span><span>var </span>city: City)<br/><span>case class </span>Company(<span>var </span>name: <span>String</span><span>, </span><span>var </span>address: Address)<br/><span>case class </span>User(<span>var </span>name: <span>String</span><span>, </span><span>var </span>company: Company<span>, </span><span>var </span>address: Address)</pre>
<p>After this, using these classes will be as easy as this:</p>
<pre><span>object </span>UserBadExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>uk = <span>Country</span>(<span>"United Kingdom"</span><span>, </span><span>"uk"</span>)<br/>    <span>val </span>london = <span>City</span>(<span>"London"</span><span>, </span>uk)<br/>    <span>val </span>buckinghamPalace = <span>Address</span>(<span>1</span><span>, </span><span>"Buckingham Palace Road"</span><span>, </span>london)<br/>    <span>val </span>castleBuilders = <span>Company</span>(<span>"Castle Builders"</span><span>, </span>buckinghamPalace)<br/>    <span>val </span>switzerland = <span>Country</span>(<span>"Switzerland"</span><span>, </span><span>"CH"</span>)<br/>    <span>val </span>geneva = <span>City</span>(<span>"geneva"</span><span>, </span>switzerland)<br/>    <span>val </span>genevaAddress = <span>Address</span>(<span>1</span><span>, </span><span>"Geneva Lake"</span><span>, </span>geneva)<br/>    <span>val </span>ivan = <span>User</span>(<span>"Ivan"</span><span>, </span>castleBuilders<span>, </span>genevaAddress)<br/>    System.<span>out</span>.println(ivan)<br/>    System.<span>out</span>.println(<span>"Capitalize UK code..."</span>)<br/>    <strong>ivan.company.address.city.country.code = ivan.company.address.city.country.code.toUpperCase</strong><br/>    System.<span>out</span>.println(ivan)<br/>  }<br/>}</pre>
<div class="packt_tip">In the preceding code example, we could have also changed the country code using this—<kbd>uk.code = uk.code.toUpperCase</kbd>. This would work, because we use a reference of the country in our <kbd>User</kbd> object.</div>
<p>The preceding example will produce absolutely the same output. However, here we broke the rule that everything in Scala is immutable. This might not look like a big deal in the current example but, in reality, it goes against the Scala principles. This is considered bad code and we should try to avoid it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">With the lens design pattern</h1>
                </header>
            
            <article>
                
<p>In the previous subsection, we saw how complicated something such as changing one property of a nested class can be. We are going after nice, clean, and correct code, and we also don't want to go against the principles of Scala.</p>
<p>Luckily for us, cases such as the one we just mentioned previously are exactly the reason for the creation of the lens design pattern. In this chapter, we will see the Scalaz library for the first time in this book. It defines many functional programming abstractions for us, and we can <span>easily</span><span> </span><span>use them straight away without worrying whether they follow some specific set of rules or not.</span></p>
<p>So, what are lenses anyway? We won't get too deep into the theoretical aspects here, as this is out of the scope of this book. It is enough for us to know what they are used for, and if you want to know more, there is plenty of material on lenses, store, and comonads online, which can make these concepts clearer. A simple way to represent a lens is the following:</p>
<pre><span>case class </span>Lens[<span>X</span><span>, </span><span>Y</span>](get: <span>X </span>=&gt; <span>Y</span><span>, </span>set: (<span>X</span><span>, </span><span>Y</span>) =&gt; <span>X</span>)</pre>
<p>This basically lets us get and set different properties of an object of the <kbd>X</kbd> type. This means that, in our case, we will have to define different lenses for the different properties we want to set:</p>
<pre><span>import scalaz.Lens<br/><br/>object </span>User {<br/>  <span>val </span><span>userCompany </span>= Lens.lensu[User<span>, </span>Company](<br/>    (u<span>, </span>company) =&gt; u.copy(company = company)<span>, </span>_.company<br/>  )<br/>  <span>val </span><span>userAddress </span>= Lens.lensu[User<span>, </span>Address](<br/>    (u<span>, </span>address) =&gt; u.copy(address = address)<span>, </span>_.address<br/>  )<br/>  <span>val </span><span>companyAddress </span>= Lens.lensu[Company<span>, </span>Address](<br/>    (c<span>, </span>address) =&gt; c.copy(address = address)<span>, </span>_.address<br/>  )<br/>  <span>val </span><span>addressCity </span>= Lens.lensu[Address<span>, </span>City](<br/>    (a<span>, </span>city) =&gt; a.copy(city = city)<span>, </span>_.city<br/>  )<br/><br/>  <span>val </span><span>cityCountry </span>= Lens.lensu[City<span>, </span>Country](<br/>    (c<span>, </span>country) =&gt; c.copy(country = country)<span>, </span>_.country<br/>  )<br/>  <span>val </span><span>countryCode </span>= Lens.lensu[Country<span>, </span><span>String</span>](<br/>    (c<span>, </span>code) =&gt; c.copy(code = code)<span>, </span>_.code<br/>  )<br/>  <strong>val userCompanyCountryCode = userCompany &gt;=&gt; companyAddress &gt;=&gt; addressCity &gt;=&gt; cityCountry &gt;=&gt; </strong><span><strong>countryCode</strong><br/></span>}</pre>
<p>The preceding code is a companion object to our <kbd>User</kbd> class. There are a lot of things going on here, so we will explain this. You can see the calls to <kbd>Lens.lensu[A, B]</kbd>. They create actual lenses so that for an object of the <kbd>A</kbd> type, the calls get and set a value of the <kbd>B</kbd> type. There is nothing special about them really, and they simply look like boilerplate code. The interesting part here is the highlighted code—it uses the <kbd>&gt;=&gt;</kbd> operator, which is an alias for <kbd>andThen</kbd>. This allows us to compose lenses and this is exactly what we will do. We will define a composition that allows us to go from a <kbd>User</kbd> object through the chain and set the country code of the country of the <kbd>Company</kbd>. We could have used <kbd>compose</kbd> as well, which has an alias of <kbd>&lt;=&lt;</kbd> because <kbd>andThen</kbd> internally calls <kbd>compose</kbd> and it would look like the following:</p>
<pre><span>val </span><span>userCompanyCountryCodeCompose </span>= <span>countryCode </span>&lt;=&lt; <span>cityCountry </span>&lt;=&lt; addressCity &lt;=&lt; companyAddress &lt;=&lt; userCompany</pre>
<p>The latter, however, is not as intuitive as the former.</p>
<p>Using our lens is now very easy. We need to make sure to import our companion object and then we can simply use the following code where we change the country code to uppercase:</p>
<pre>val ivanFixed = userCompanyCountryCode.mod(_.toUpperCase, ivan)</pre>
<p>You saw how the lens design pattern allows us to cleanly set properties of our case class without breaking the immutability rule. We simply need to define the right lenses and then use them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Minimizing the boilerplate</h1>
                </header>
            
            <article>
                
<p>The preceding example showed quite a lot of boilerplate code. It is not complicated, but it requires us to write quite a lot of extra stuff, and then any refactoring will likely affect these manually defined lenses. There has been an effort in creating libraries that automatically generate lenses for all user-defined classes that can then be used easily. One example of a library that seems to be maintained well is Monocle: <a href="http://julien-truffaut.github.io/Monocle/">https://github.com/julien-truffaut/Monocle</a>. It is <span>well-</span><span>documented and can be used so that we don't have to write any boilerplate code. It has its limitations though, and users should make sure they are okay with what the library provides. It also provides other optics concepts that could be useful.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The cake design pattern</h1>
                </header>
            
            <article>
                
<p>Actual software projects will usually combine multiple components that will have to be used together. Most of the time, these components will depend on others, which in turn depend on other components, and so on. This makes creating objects in an application hard because we also need to create the objects they depend on and so on. This is where dependency injection comes in handy.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependency injection</h1>
                </header>
            
            <article>
                
<p>So, what exactly is dependency injection? It turns out to be something really simple—every single class that has an object as a parameter in their constructor <span>is</span><span> </span><span>actually an example of a dependency injection. The reason is that the dependency is injected into the class rather than instantiated inside it. Developers should actually try to use this kind of approach instead of creating objects inside a constructor. There are many reasons for this, but one of the most important ones is the fact that components can become tightly coupled and practically untestable.</span></p>
<p>Dependency injection, however, could degrade the code quality if implemented using constructor parameters. This would make constructors take a large number of parameters and, as a consequence, it will become really difficult to use the constructors. Of course, using the factory design pattern could help, but there are other approaches that are much more common in enterprise applications. In the following subsections, we will briefly mention the alternatives and show how, using only the features of Scala, we can easily implement dependency injection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependency injection libraries and Scala</h1>
                </header>
            
            <article>
                
<p>Many developers with a background in Java might be already familiar with some of the famous dependency injection libraries. Some popular examples are Spring (<a href="https://spring.io/">https://spring.io/</a>) and Guice (<a href="https://github.com/google/guice">https://github.com/google/guice</a>). In Spring, dependencies are usually managed in an XML file, where they are described, and the file tells the framework how to create instances and where to inject the objects into classes. Some of the terms used are beans.</p>
<p>On the other hand, Guice uses annotations that are then evaluated and replaced with the right objects. These are quite popular frameworks and they can also be used in Scala pretty easily. Those of you familiar with Play Framework will know that it uses exactly Guice to wire things up.</p>
<p>Using external libraries, however, adds dependencies to projects, increases the jar size, and so on. Nowadays, this is not really an issue. Scala, however, is quite an expressive language, as we have already seen, and we can implement dependency injection natively without any extra libraries. We will see how this can be done in the following subsections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependency injection in Scala</h1>
                </header>
            
            <article>
                
<p>In order to implement dependency injection in Scala, we can use a special design pattern. It is called the cake design pattern. Without getting into too much detail, let's create an application. The application that we are creating will need to have a bunch of classes that depend on each other so that we can demonstrate how injection works.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing our code</h1>
                </header>
            
            <article>
                
<p>We will create an application that can read from a database data about people, classes, and who has signed up to which classes. We will have a user service which will implement some simple business logic with the data, and a service that will access the data. It will be a small application, but it will clearly show how dependency injection works.</p>
<p>Let's start with the simple stuff. We will need to have a model for the objects that we will be representing:</p>
<pre><span>case class </span>Class(id: <span>Int, </span>name: <span>String</span>)<br/><span>case class </span>Person(id: <span>Int, </span>name: <span>String</span><span>, </span>age: <span>Int</span>)</pre>
<p>In the preceding code, we have two classes that will be used in our application. There is nothing special about them, so let's go further.</p>
<p>We said that we want our application to be able to read data from a database. There are different databases—MySQL, PostgreSQL, Oracle, and so on. If we want to use any of these, however, you will need to install some extra software that will require extra knowledge and will be tricky. Luckily, there is an in-memory database engine called H2 (<a href="https://www.h2database.com/html/main.html">https://www.h2database.com/html/main.html</a>) that we can use instead. Using this is as simple as adding a dependency to our <kbd>pom.xml</kbd> or <kbd>build.sbt</kbd> file and then using the database. We will see how this all works really soon.</p>
<p>Also, let's make things more interesting and make sure that a different database engine could easily be plugged in. For this to work, we will need some kind of interface that will be implemented by different database services:</p>
<pre><span>trait </span>DatabaseService {<br/>  <span>val </span>dbDriver: <span>String<br/></span><span>  </span><span>val </span>connectionString: <span>String<br/></span><span>  </span><span>val </span>username: <span>String<br/></span><span>  </span><span>val </span>password: <span>String<br/></span><span>  </span><span>val </span><span>ds </span>= {<br/>    JdbcConnectionPool.create(connectionString<span>, </span>username<span>, </span>password)<br/>  }<br/><br/>  <span>def </span><span>getConnection</span>: Connection = <span>ds</span>.getConnection<br/>}</pre>
<p>In the preceding code, we used a trait and will extend this trait whenever we want to create an H2 database service, or an Oracle database service, and so on. Everything in the preceding code seems to be quite straightforward and doesn't need additional explanation.</p>
<div class="packt_tip"><span class="packt_screen">The order of the vals</span><br/>
<br/>
In the preceding code, listing the order of the variable definitions matters. This means that if we had declared <kbd>ds</kbd> first and then everything else, we would have faced a <kbd>NullPointerException</kbd>. This can be easily overcome using a <kbd>lazy val</kbd> instead.</div>
<p>For our example, we will be implementing a service for the H2 database engine, as follows:</p>
<pre><span>trait </span>DatabaseComponent {<br/>  <span>val </span>databaseService: DatabaseService<br/>  <br/>  <span>class </span>H2DatabaseService(<span>val </span>connectionString: <span>String</span><span>, </span><span>val </span>username: <span>String</span><span>, </span><span>val </span>password: <span>String</span>) <span>extends </span>DatabaseService {<br/>    <span>val </span><span>dbDriver </span>= <span>"org.h2.Driver"<br/></span><span>  </span>}<br/>}</pre>
<p>The actual implementation of the database service is in the nested <kbd>H2DatabaseService</kbd> class. Nothing special about it. But what about the <kbd>DatabaseComponent</kbd> trait? It is simple—we want to have a database component that we will mix in our classes and it will provide functionality to connect to the databases. The <kbd>databaseService</kbd> variable is left to be abstract and will have to be implemented when the component is mixed in.</p>
<p>Having a database component by itself is not useful at all. We will need to use it in some way. Let's create another component, which creates our database and its tables and fills them up with data. Obviously, it will depend on the database component mentioned previously:</p>
<pre><span>trait </span>MigrationComponent {<br/><strong>  this: DatabaseComponent =&gt;</strong><br/><br/>  <span>val </span>migrationService: MigrationService<br/><br/>  <span>class </span>MigrationService() {<br/>    <span>def </span><span>runMigrations</span>(): <span>Unit </span>= {<br/>      <span>val </span>connection = databaseService.getConnection<br/>      <span>try </span>{<br/>        <span>// create the database<br/></span><span>        </span>createPeopleTable(connection)<br/>        createClassesTable(connection)<br/>        createPeopleToClassesTable(connection)<br/>        <span>// populate<br/></span><span>        </span>insertPeople(<br/>          connection<span>,<br/></span><span>          </span><span>List</span>(<span>Person</span>(<span>1</span><span>, </span><span>"Ivan"</span><span>, </span><span>26</span>)<span>, </span><span>Person</span>(<span>2</span><span>, </span><span>"Maria"</span><span>, </span><span>25</span>)<span>,<br/>           </span><span>Person</span>(<span>3</span><span>, </span><span>"John"</span><span>, </span><span>27</span>))<br/>        )<br/>        insertClasses(<br/>          connection<span>,<br/></span><span>          </span><span>List</span>(<span>Class</span>(<span>1</span><span>, </span><span>"Scala Design Patterns"</span>)<span>, </span><span>Class</span>(<span>2</span><span>,<br/>           </span><span>"JavaProgramming"</span>)<span>, </span><span>Class</span>(<span>3</span><span>, </span><span>"Mountain Biking"</span>))<br/>        )<br/>        signPeopleToClasses(<br/>          connection<span>,<br/></span><span>          </span><span>List</span>((<span>1</span><span>, </span><span>1</span>)<span>, </span>(<span>1</span><span>, </span><span>2</span>)<span>, </span>(<span>1</span><span>, </span><span>3</span>)<span>, </span>(<span>2</span><span>, </span><span>1</span>)<span>, </span>(<span>3</span><span>, </span><span>1</span>)<span>, </span>(<span>3</span><span>, </span><span>3</span>))<br/>        )<br/>      } <span>finally </span>{<br/>        connection.close()<br/>      }<br/>    }<br/><br/>    <span>private def </span><span>createPeopleTable</span>(connection: Connection): <span>Unit </span>= {<br/>      <span>// implementation<br/></span><span>    </span>}<br/><br/>    <span>private def </span><span>createClassesTable</span>(connection: Connection): <span>Unit </span>= {<br/>      <span>// implementation<br/></span><span>    </span>}<br/><br/>    <span>private def </span><span>createPeopleToClassesTable</span>(connection: Connection):<br/>    <span>Unit </span>= {<br/>      <span>// implementation<br/></span><span>    </span>}<br/><br/>    <span>private def </span><span>insertPeople</span>(connection: Connection<span>, </span>people: <span>List</span>[Person]): <span>Unit </span>= {<br/>      <span>// implementation<br/></span><span>    </span>}<br/><br/>    <span>// Other methods<br/></span><span>  </span>}<br/><br/>}</pre>
<p>Now this is a lot of code! There is nothing scary about it, though. Let's go through it and try to understand it. First, we followed the same pattern as before—we created a component trait with an abstract variable, in this case, called <kbd>migrationService</kbd>. We don't need to have multiple different migrations, so we simply created a class inside the component trait.</p>
<p>The interesting part here is the first line that we highlighted—<kbd>this: DatabaseComponent =&gt;</kbd>. What does this mean? Luckily, we have already seen this syntax before in the book—it is nothing more than a <strong>self type annotation</strong>. What it does, however, is really interesting—it tells the compiler that whenever we mix in the <kbd>MigrationComponent</kbd>, we also need to mix in the <kbd>DatabaseComponent</kbd>. And this is exactly the piece of the puzzle that tells Scala that the migration component will depend on the database component. As a consequence, we are now able to run the code in the second highlighted row. And if we look carefully, it actually accesses <kbd>databaseService</kbd>, which is a part of <kbd>DatabaseComponent</kbd>.</p>
<p>In the preceding code, we've skipped most of the other implementations, but they are straightforward and have nothing to do with the cake design pattern. Let's see two of them:</p>
<pre><span>private def </span><span>createPeopleTable</span>(connection: Connection): <span>Unit </span>= {<br/>  <span>val </span>statement = connection.prepareStatement(<br/>    <span>"""</span><span><br/></span><span>      |CREATE TABLE people(</span><span><br/></span><span>      | id INT PRIMARY KEY,</span><span><br/></span><span>      | name VARCHAR(255) NOT NULL,</span><span><br/></span><span>      | age INT NOT NULL</span><span><br/></span><span>      |)</span><span><br/></span><span>    """</span>.stripMargin<br/>  )<br/>  <span>try </span>{<br/>    statement.executeUpdate()<br/>  } <span>finally </span>{<br/>    statement.close()<br/>  }<br/>}<br/><br/><span>private def </span><span>insertPeople</span>(connection: Connection<span>, </span>people: <span>List</span>[Person]): <span>Unit </span>= {<br/>  <span>val </span>statement = connection.prepareStatement(<br/>    <span>"INSERT INTO people(id, name, age) VALUES (?, ?, ?)"</span><span><br/></span><span>  </span>)<br/>  <span>try </span>{<br/>    people.foreach {<br/>      <span>case </span>person =&gt;<br/>        statement.setInt(<span>1</span><span>, </span>person.id)<br/>        statement.setString(<span>2</span><span>, </span>person.name)<br/>        statement.setInt(<span>3</span><span>, </span>person.age)<br/>        statement.addBatch()<br/>    }<br/>    statement.executeBatch()<br/>  } <span>finally </span>{<br/>    statement.close()<br/>  }<br/>}</pre>
<p>The preceding code is just database code that creates a table and inserts data into it. The rest of the methods in the class are similar, but they differ in the table definitions and what is inserted into them. The full code can be seen in the examples that are provided with this book. Here, we will just extract the statements that create the database model so that you can have an idea of how the database is structured and what we can do with it:</p>
<pre><span>CREATE TABLE </span>people(<br/>  <span>id </span><span>INT PRIMARY KEY</span><span>,<br/></span><span>  </span><span>name </span><span>VARCHAR</span>(<span>255</span>) <span>NOT NULL</span><span>,<br/></span><span>  </span><span>age </span><span>INT NOT NULL<br/></span>)<br/><br/><span>CREATE TABLE </span>classes(<br/>  <span>id </span><span>INT PRIMARY KEY</span><span>,<br/></span><span>  </span><span>name </span><span>VARCHAR</span>(<span>255</span>) <span>NOT NULL</span><span>,<br/></span>)<br/><br/><span>CREATE TABLE </span>people_classes(<br/>  <span>person_id </span><span>INT NOT NULL</span><span>,<br/></span><span>  </span><span>class_id </span><span>INT NOT NULL</span><span>,<br/></span></pre>
<pre><span>  </span><span>PRIMARY KEY</span>(<span>person_id</span><span>, </span><span>class_id</span>)<span>,<br/></span><span>  </span><span>FOREIGN KEY</span>(<span>person_id</span>) <span>REFERENCES </span>people(<span>id</span>) <span>ON DELETE CASCADE ON UPDATE CASCADE</span><span>,<br/></span><span>  </span><span>FOREIGN KEY</span>(<span>class_id</span>) <span>REFERENCES </span>classes(<span>id</span>) <span>ON DELETE CASCADE ON UPDATE CASCADE<br/></span>)</pre>
<p>Our migration service in the preceding code simply creates tables in a database and inserts some information into them so that we can then use the service. We saw that this migration service depends on the database service, and we also saw how this dependency is implemented.</p>
<p>Just by having these classes, our application will not be that useful. We need to be able to interact with the data and do something interesting with it. We can say that the migration component just makes sure we have the data. In real-world scenarios, we might already have a prepopulated database and we will need to work with what is inside this database. Whatever the case, we will need to have a data access layer to retrieve what we need. We have created the following component:</p>
<pre><span>trait </span>DaoComponent {<br/>  <span>this</span>: DatabaseComponent =&gt;<br/>  <span>val </span>dao: Dao<br/><br/>  <span>class </span>Dao() {<br/>    <span>def </span><span>getPeople</span>: <span>List</span>[Person] = {<br/>      <span>// skipped<br/></span><span>    </span>}<br/><br/>    <span>def </span><span>getClasses</span>: <span>List</span>[Class] = {<br/>      <span>// skipped<br/></span><span>    </span>}<br/><br/>    <span>def </span><span>getPeopleInClass</span>(className: <span>String</span>): <span>List</span>[Person] = {<br/>      <span>val </span>connection = databaseService.getConnection<br/>      <span>try </span>{<br/>        <span>val </span>statement = connection.prepareStatement(<br/>          <span>"""<br/></span><span>            |SELECT p.id, p.name, p.age<br/></span><span>            |FROM people p<br/></span><span>            | JOIN people_classes pc ON p.id = pc.person_id<br/></span><span>            | JOIN classes c ON c.id = pc.class_id<br/></span><span>            |WHERE c.name = ?<br/></span><span>          """</span>.stripMargin<br/>        )<br/>        statement.setString(<span>1</span><span>, </span>className)<br/>        executeSelect(statement) {<br/>          rs =&gt;<br/>            readResultSet(rs) {<br/>              row =&gt;<br/>                <span>Person</span>(row.getInt(<span>1</span>)<span>, </span>row.getString(<span>2</span>)<span>, </span>row.getInt(<span>3</span>))<br/>            }<br/>        }<br/>      } <span>finally </span>{<br/>        connection.close()<br/>      }<br/>    }<br/><br/>    <span>private def </span><span>executeSelect</span>[<span>T</span>](preparedStatement: PreparedStatement)(f: (ResultSet) =&gt; <span>List</span>[<span>T</span>]): <span>List</span>[<span>T</span>] =<br/>      <span>try </span>{<br/>        f(preparedStatement.executeQuery())<br/>      } <span>finally </span>{<br/>        preparedStatement.close()<br/>      }<br/><br/>    <span>private def </span><span>readResultSet</span>[<span>T</span>](rs: ResultSet)(f: ResultSet =&gt; <span>T</span>): <span>List</span>[<span>T</span>] =<br/>      <span>Iterator</span>.<span>continually</span>((rs.next()<span>, </span>rs)).takeWhile(_._1).map {<br/>        <span>case </span>(_<span>, </span>row) =&gt; f(rs)<br/>      }.toList<br/>  }<br/>}</pre>
<p>This <kbd>DaoComponent</kbd> is similar to the <kbd>DatabaseComponent</kbd> in terms of its dependency. It just defines queries to retrieve data. We've skipped the simple <kbd>select</kbd> statements. It could, of course, define even more methods for insertions, updates, and deletes. It nicely hides the complexity of dealing with data from a database, and now we can actually create something useful in our application.</p>
<p>What is commonly seen in enterprise applications is different services that could access data in a database, perform some business logic on it, return results, and write it back into the database. We have created a simple service that deals with users:</p>
<pre><span>trait </span>UserComponent {<br/>  <span>this</span>: DaoComponent =&gt;<br/>  <span>val </span>userService: UserService<br/><br/>  <span>class </span>UserService {<br/>    <span>def </span><span>getAverageAgeOfUsersInClass</span>(className: <span>String</span>): <span>Double </span>= {<br/>      <span>val </span>(ageSum<span>, </span>peopleCount) = dao.getPeopleInClass(className).foldLeft((<span>0</span><span>, </span><span>0</span>)) {<br/>          <span>case </span>((sum<span>, </span>count)<span>, </span>person) =&gt;<br/>            (sum + person.age<span>, </span>count + <span>1</span>)<br/>        }<br/>      <span>if </span>(peopleCount != <span>0</span>) {<br/>        ageSum.toDouble / peopleCount.toDouble<br/>      } <span>else </span>{<br/>        <span>0.0<br/></span><span>      </span>}<br/>    }<br/>  }<br/>}</pre>
<p>In our <kbd>UserComponent</kbd>, we follow the same pattern we already know, but this time our dependency is on <kbd>DaoComponent</kbd>. We can then have other components that depend on this component and on others as well. We haven't shown any example here in which a component depends on multiple ones at the same time, but this is not hard to do at all. We just use the following:</p>
<pre>this: Component1 with Component2 with Component3 … =&gt;</pre>
<p>We can have dependencies on as many components as we want, and this is where the cake design pattern starts to shine and shows its benefits.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Wiring it all up</h1>
                </header>
            
            <article>
                
<p>In the preceding code, we saw a bunch of components with their implementations that declare dependencies to others. We still haven't seen how everything will be used together. By defining our components as traits, we can just mix them in together and they will be available to us. This is how we have done it:</p>
<pre><span>object </span>ApplicationComponentRegistry<br/>  <span>extends </span>UserComponent<br/>    <span>with </span>DaoComponent<br/>    <span>with </span>DatabaseComponent<br/>    <span>with </span>MigrationComponent {<br/>  <span>override val </span><span>dao</span>: ApplicationComponentRegistry.Dao = <span>new </span>Dao<br/>  <span>override val </span><span>databaseService</span>: DatabaseService = <span>new </span>H2DatabaseService(<span>"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"</span><span>, </span><span>""</span><span>, </span><span>""</span>)<br/>  <span>override val </span><span>migrationService</span>: ApplicationComponentRegistry.MigrationService = <span>new </span>MigrationService<br/>  <span>override val </span><span>userService</span>: ApplicationComponentRegistry.UserService = <span>new </span>UserService<br/>}</pre>
<p>In the preceding code, the <kbd>ApplicationComponentRegistry</kbd> can be a class as well, instead of a Scala object. It mixes the components in and, since each of them had an abstract variable, it forces us to assign actual values to them. The nicest part of this is that, if we know that our application will need a <kbd>UserComponent</kbd>, the compiler will tell us that we also need a <kbd>DaoComponent</kbd>, and so on, down the chain. The compiler will basically make sure that we have the entire dependency chain available during compilation, and it won't let us run our application until we have done things properly. This is extremely useful. In other libraries, this is not the case and we often find out that our dependency graph is not built properly at runtime. Also, this way of wiring things up makes sure we have only one instance of each.</p>
<div class="packt_infobox">If we had used a class instead of an object for the <kbd>ApplicationComponentRegistry</kbd>, the statement about having only one instance of each component doesn't automatically become true. We need to take extra care, otherwise each instance of the registry might have different instances of the components.</div>
<p>After we have created our component registry, we can easily use everything in our application:</p>
<pre><span>object </span>Application {<br/><br/>  <span>import </span>ApplicationComponentRegistry._<br/><br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>migrationService</span>.runMigrations()<br/>    System.<span>out</span>.println(<span>dao</span>.getPeople)<br/>    System.<span>out</span>.println(<span>dao</span>.getClasses)<br/>    System.<span>out</span>.println(<span>dao</span>.getPeopleInClass(<span>"Scala Design Patterns"</span>))<br/>    System.<span>out</span>.println(<span>dao</span>.getPeopleInClass(<span>"Mountain Biking"</span>))<br/>    System.<span>out</span>.println(<span>s"Average age of everyone in Scala Design Patterns: </span><span>$</span>{<span>userService</span>.getAverageAgeOfUsersInClass(<span>"Scala Design Patterns"</span>)}<span>"</span>)<br/>  }<br/>}</pre>
<p>In the preceding code, we simply imported everything from the registry and then we used it. The output of this application is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/222041ae-860d-4500-9e09-cac4f3ac0dc7.png" style="width:50.17em;height:11.33em;" width="722" height="163"/></div>
<p>This is how easy it is to use the cake design pattern in Scala.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Unit testing our application</h1>
                </header>
            
            <article>
                
<p>Testing is an important part of every application. We need to make sure that the changes we add do not negatively affect the other parts of our system and that every unit behaves correctly. Testing with the cake design pattern is also really simple to achieve.</p>
<p>The cake design pattern allows us to easily create different environments. This is why we can create the following test environment:</p>
<pre><span>trait </span>TestEnvironment<br/>  <span>extends </span>UserComponent<br/>    <span>with </span>DaoComponent<br/>    <span>with </span>DatabaseComponent<br/>    <span>with </span>MigrationComponent<br/>    <span>with </span>MockitoSugar {<br/>  <span>override val </span><span>dao</span>: Dao = mock[Dao]<br/>  <span>override val </span><span>databaseService</span>: DatabaseService = mock[DatabaseService]<br/>  <span>override val </span><span>migrationService</span>: MigrationService = mock[MigrationService]<br/>  <span>override val </span><span>userService</span>: UserService = mock[UserService]<br/>}</pre>
<p>The preceding code simply contains every component and mocks every service with Mockito. Let's write a test class for our <kbd>UserComponent</kbd> using our new test environment:</p>
<pre><span>class </span>UserComponentTest <span>extends </span>FlatSpec <span>with </span>Matchers <span>with </span>MockitoSugar <span>with </span>TestEnvironment {<br/>  <span>val </span><span>className </span>= <span>"A"<br/></span><span>  </span><span>val </span><span>emptyClassName </span>= <span>"B"<br/></span><span>  </span><span>val </span><span>people </span>= <span>List</span>(<br/>    <span>Person</span>(<span>1</span><span>, </span><span>"a"</span><span>, </span><span>10</span>)<span>,<br/></span><span>    </span><span>Person</span>(<span>2</span><span>, </span><span>"b"</span><span>, </span><span>15</span>)<span>,<br/></span><span>    </span><span>Person</span>(<span>3</span><span>, </span><span>"c"</span><span>, </span><span>20</span>)<br/>  )<br/>  <span>override val </span><span>userService </span>= <span>new </span>UserService<br/>  <br/>  when(<span>dao</span>.getPeopleInClass(<span>className</span>)).thenReturn(<span>people</span>)<br/>  when(<span>dao</span>.getPeopleInClass(<span>emptyClassName</span>)).thenReturn(<span>List</span>())<br/>  <br/>  <span>"getAverageAgeOfUsersInClass" </span>should <span>"properly calculate the average of all ages." </span>in {<br/>    <span>userService</span>.getAverageAgeOfUsersInClass(<span>className</span>) should equal(<span>15.0</span>)<br/>  }<br/>  <br/>  it should <span>"properly handle an empty result." </span>in {<br/>    <span>userService</span>.getAverageAgeOfUsersInClass(<span>emptyClassName</span>) should equal(<span>0.0</span>)<br/>  }<br/>}</pre>
<p>In the preceding code, we override the <kbd>userService</kbd> to be an actual implementation and then we use it for the tests. We use Mockito to simulate our database access and then we simply write a test that checks whether things work correctly. We have decided to simulate our database access. However, in some cases, people have test databases or use H2 for tests. Using our test environment, we have the flexibility to do whatever we decide.</p>
<p>Running the tests we wrote previously can be achieved with the <kbd>mvn clean test</kbd> or <kbd>sbt test</kbd> command.</p>
<p>Our test environment allows us to enable as many components in our tests as we want. We could simply override multiple such components in our test classes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other dependency injection alternatives</h1>
                </header>
            
            <article>
                
<p>One thing about the cake design pattern that we presented previously is the amount of boilerplate code that we need to write in order to wire everything up properly. In large applications, this could become an issue, so there are other alternatives that can be used to deal with this. We will briefly discuss here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicits for dependency injection</h1>
                </header>
            
            <article>
                
<p>Using implicits is something that removes the requirement of having the component traits and self type annotations of the cake design pattern. Implicits, however, can quickly complicate method definitions because every method has to declare implicit parameters to whatever components it depends on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reader monad for dependency injection</h1>
                </header>
            
            <article>
                
<p>The <kbd>Reader</kbd> monad is available in the Scalaz library. The way dependency injection works with it is that we make each method return a function wrapped in the <kbd>Reader</kbd> monad, for example:</p>
<pre><span>def </span><span>getAverageAgeOfUsersInClass</span>(className: <span>String</span>) =<br/>  Reader((userService: UserService) =&gt; userService.getAverageAgeOfUsersInClass(className))</pre>
<p>In the preceding code, we only expose <kbd>getAverageAgeOfUsersInClass(className: String)</kbd> to the users. Typically, for monads, computation here is built, but nothing is done until the last moment. We can build complex operations, use <kbd>map</kbd>, <kbd>flatMap</kbd>, and for comprehensions. We defer injecting the dependencies until the last moment, where we can simply call <kbd>apply</kbd> on a reader with the actual component or components it needs. The preceding explanation might sound a bit abstract, but things are pretty simple and can be seen in many places online.</p>
<p>In some cases, this method is used together with the cake design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The pimp my library design pattern</h1>
                </header>
            
            <article>
                
<p>In our daily job as developers, we often use different libraries. They, however, are usually made to be generic and allow many people to use them, so sometimes we need to do something extra that is specific to our use case in order to make things work properly. The fact that we cannot really modify the original library code means that we have to do something different. We have already looked at the decorator and the adapter design patterns. Well, pimp my library achieves something similar, but it does this in the Scala way and some of the extra work is given to the compiler to deal with.</p>
<p>The pimp my library design pattern is really similar to extension methods in C#. We will see some examples in the following subsections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using pimp my library</h1>
                </header>
            
            <article>
                
<p>The pimp my library design pattern is really easy to use. Let's see an example in which we want to add some useful methods to the standard <kbd>String</kbd> class. Of course, we cannot modify its code, so we need to do something else:</p>
<pre><span>package object </span>pimp {<br/>  <span>implicit class </span>StringExtensions(<span>val </span>s: <span>String</span>) <span>extends </span>AnyVal {<br/>    <span>def </span><span>isAllUpperCase</span>: <span>Boolean </span>=<br/>      !(<span>0 </span>until s.length).exists {<br/>        <span>case </span>index =&gt;<br/>          s.charAt(index).isLower<br/>      }<br/>  }<br/>}</pre>
<p class="mce-root">In the preceding code, we have a package object. It gives us the convenience to not do anything extra in order to be able to access its members from the classes in the same package in Scala. It can be a simple object, but then we will have to <kbd>import ObjectName._</kbd> in order to gain access to the members.</p>
<p class="mce-root">The preceding object is just a detail and is not related to the design pattern. The pimp my library code is the internal class. There are a few important things about this:</p>
<ul>
<li>It is implicit</li>
<li>It extends <kbd>AnyVal</kbd></li>
</ul>
<p>These features allow us to write the following application:</p>
<pre><span>object </span>PimpExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"Is 'test' all upper case:<br/>     </span><span>$</span>{<span>"test"</span>.isAllUpperCase}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Is 'Tes' all upper case:<br/>     </span><span>$</span>{<span>"Test"</span>.isAllUpperCase}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Is 'TESt' all upper case:<br/>     </span><span>$</span>{<span>"TESt"</span>.isAllUpperCase}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Is 'TEST' all upper case:<br/>     </span><span>$</span>{<span>"TEST"</span>.isAllUpperCase}<span>"</span>)<br/>  }<br/>}</pre>
<p>We basically added an extension method to the standard string that checks whether the entire string is in uppercase or not. The only thing we need to do is make sure that the implicit class is available in the scope where we want to use the methods defined by it.</p>
<p>The output of the preceding application is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7cdb1e83-bc57-468a-8b3f-aa8428a5d2f3.png" style="width:41.42em;height:7.33em;" width="722" height="128"/></div>
<p>In our example, we didn't have to write code that wraps strings in our extension class. Our code shows the type as a normal string; however, we can just do extra things with it. Additionally, the decorator design pattern will suffer in the cases where the class we are trying to decorate is final. Here, there is no issue. Again, all the magic happens because we have an implicit class, and the Scala compiler automatically figures out that it can wrap and unwrap a string depending on the methods we call on it.</p>
<p>We can, of course, add more methods to the <kbd>StringExtensions</kbd> class and they will be available to all the strings where the implicit class is available. We can also add other classes:</p>
<pre><span>implicit class </span>PersonSeqExtensions(<span>val </span>seq: <span>Iterable</span>[Person]) <span>extends </span>AnyVal {<br/>  <span>def </span><span>saveToDatabase</span>(): <span>Unit </span>= {<br/>    seq.foreach {<br/>      <span>case </span>person =&gt;<br/>        System.<span>out</span>.println(<span>s"Saved: </span><span>$</span>{person}<span> to the database."</span>)<br/>    }<br/>  }<br/>}</pre>
<p>The preceding code is capable of saving an entire collection of the <kbd>Person</kbd> type to a database (even though, in the example, we just print the collection to the standard output). For completeness, our <kbd>Person</kbd> model class is defined as follows:</p>
<pre><span>case class </span>Person(name: <span>String</span><span>, </span>age: <span>Int</span>)</pre>
<p>Using the new extension is then similar to the earlier extension:</p>
<pre><span>object </span>PimpExample2 {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>people = <span>List</span>(<br/>      <span>Person</span>(<span>"Ivan"</span><span>, </span><span>26</span>)<span>,<br/></span><span>      </span><span>Person</span>(<span>"Maria"</span><span>, </span><span>26</span>)<span>,<br/></span><span>      </span><span>Person</span>(<span>"John"</span><span>, </span><span>25</span>)<br/>    )<br/>    people.saveToDatabase()<br/>  }<br/>}</pre>
<p>The preceding example will produce the expected result, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/56be3880-216f-49c3-9aba-80be954171a9.png" width="722" height="110"/></div>
<p>We can also apply the pimp my library design pattern to our custom classes if we need to and if it makes sense.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pimp my library in real life</h1>
                </header>
            
            <article>
                
<p>As you can see from the preceding section, the pimp my library design pattern is extremely easy to use. This is seen quite often, especially when a decorator or adapter design pattern is needed. We can, of course, figure out ways to deal with issues without this library design but, in reality, it helps us to avoid boilerplate code. It also really helps in making our code more readable. Last but not least, it can be used to simplify the use of specific libraries.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The stackable traits design pattern</h1>
                </header>
            
            <article>
                
<p>There are sometimes cases where we want to be able to provide different implementations for a method of a class. We might not even know all the possibilities that could exist at the moment of writing, but we can add them later and combine them or we can allow someone else to do this instead. This is another use case of the decorator design pattern, which for this purpose could be implemented with the stackable traits design pattern. We have already seen this pattern before in this book in <a href="263a83d5-a022-4678-9dcc-030c898373d6.xhtml" target="_blank">Chapter 7</a>, <em>Structural Design Patterns</em>, but we used it to read data, which adds a really important catch there. We will see another example here, which will make sure everything is completely clear.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using stackable traits</h1>
                </header>
            
            <article>
                
<p>The stackable traits design pattern is based on mixin composition—something we became familiar with in the early chapters of this book. We usually have an abstract class or a trait that defines an interface, a base implementation, and traits that extend the abstract class to stack modifications on it.</p>
<p>For our example, let's implement the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/db03b0a7-ae6c-431a-9ab9-cde8c7c50ef3.png" style="width:46.25em;height:16.25em;" width="1311" height="461"/></div>
<p>The preceding diagram is of a really simple application. We have a base <kbd>StringWriter</kbd> class, which has a basic implementation (<kbd>BasicStringWriter</kbd>) that just returns a message containing the string. On the right-hand side, we have traits that can add stackable modifications to the <kbd>StringWriter</kbd>.</p>
<p>Let's see the following code:</p>
<pre><span>abstract class </span>StringWriter {<br/>  <span>def </span><span>write</span>(data: <span>String</span>): <span>String<br/></span>}<br/><br/><span>class </span>BasicStringWriter <span>extends </span>StringWriter {<br/>  <span>override def </span><span>write</span>(data: <span>String</span>): <span>String </span>=<br/>    <span>s"Writing the following data: </span><span>$</span>{data}<span>"<br/></span>}</pre>
<p>The preceding code is of the abstract class and the basic implementation. There is nothing special about these. Now, let's look at the stackable traits:</p>
<pre><span>trait </span>CapitalizingStringWriter <span>extends </span>StringWriter {<br/>  <span>abstract override def </span><span>write</span>(data: <span>String</span>): <span>String </span>= {<br/>    <span>super</span>.write(data.split(<span>"</span><span>\\</span><span>s+"</span>).map(_.capitalize).mkString(<span>""</span>))<br/>  }<br/>}<br/><br/><span>trait </span>UppercasingStringWriter <span>extends </span>StringWriter {<br/>  <span>abstract override def </span><span>write</span>(data: <span>String</span>): <span>String </span>= {<br/>    <span>super</span>.write(data.toUpperCase)<br/>  }<br/>}<br/><br/><span>trait </span>LowercasingStringWriter <span>extends </span>StringWriter {<br/>  <span>abstract override def </span><span>write</span>(data: <span>String</span>): <span>String </span>= {<br/>    <span>super</span>.write(data.toLowerCase)<br/>  }<br/>}</pre>
<p>The whole magic in the preceding code happens because of the <kbd>abstract override</kbd> modifier on the methods. It allows us to call <kbd>super</kbd> on an abstract method of the <kbd>super</kbd> class. This would otherwise fail, but here it just requires us to mix the traits in with a class or a trait that has <kbd>write</kbd> implemented. If we don't, we won't be able to compile our code.</p>
<p>Let's see an example use of our traits:</p>
<pre><span>object </span>Example {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>writer1 = <span>new </span>BasicStringWriter<br/>      <span>with </span>UppercasingStringWriter<br/>      <span>with </span>CapitalizingStringWriter<br/>    <span>val </span>writer2 = <span>new </span>BasicStringWriter<br/>      <span>with </span>CapitalizingStringWriter<br/>      <span>with </span>LowercasingStringWriter<br/>    <span>val </span>writer3 = <span>new </span>BasicStringWriter<br/>      <span>with </span>CapitalizingStringWriter<br/>      <span>with </span>UppercasingStringWriter<br/>      <span>with </span>LowercasingStringWriter<br/>    <span>val </span>writer4 = <span>new </span>BasicStringWriter<br/>      <span>with </span>CapitalizingStringWriter<br/>      <span>with </span>LowercasingStringWriter<br/>      <span>with </span>UppercasingStringWriter<br/>    System.<span>out</span>.println(<span>s"Writer 1: '</span><span>$</span>{writer1.write(<span>"we like learning<br/>     scala!"</span>)}<span>'"</span>)<br/>    System.<span>out</span>.println(<span>s"Writer 2: '</span><span>$</span>{writer2.write(<span>"we like learning<br/>     scala!"</span>)}<span>'"</span>)<br/>    System.<span>out</span>.println(<span>s"Writer 3: '</span><span>$</span>{writer3.write(<span>"we like learning<br/>     scala!"</span>)}<span>'"</span>)<br/>    System.<span>out</span>.println(<span>s"Writer 4: '</span><span>$</span>{writer4.write(<span>"we like learning<br/>     scala!"</span>)}<span>'"</span>)<br/>  }<br/>}</pre>
<p>In the preceding code, we simply stack modifications together using mixin composition. In the current example, they are just illustrations that don't do anything smart, but, in reality, we can have variations that will provide powerful modifications. The following figure shows the output of our example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7da9e5ef-1e63-44bc-b81b-571e6a49a340.png" width="722" height="128"/></div>
<p>The modifications we have in our code would depend on the order in which they are applied. For example, if we put everything in uppercase first, then capitalization will not have any effect. Let's see the code and the relevant output and try to figure out how the modifications are applied. If you look at all the examples and outputs, you will see that the modifications are applied <em>from right to left</em> in the order we have mixed the traits in.</p>
<p>If we look back at the example in <a href="263a83d5-a022-4678-9dcc-030c898373d6.xhtml" target="_blank">Chapter 7</a>, <em>Structural Design Patterns</em>, however, we will see that the actual modifications are reversed. The reason for this is that each trait does <kbd>super.readLines</kbd> and then maps. Well, this actually means that we will be pushing calls on the stack until we get to the basic implementation, and then we will be going back to do all the mappings. So in <a href="263a83d5-a022-4678-9dcc-030c898373d6.xhtml" target="_blank">Chapter 7</a>, <em>Structural Design Patterns</em>, the modifications are also applied from right to left, but because we just get the output and don't pass anything on, things are applied in left to right order.</p>
<div class="packt_tip"><span class="packt_screen">The stackable traits order of execution</span><br/>
<br/>
Stackable traits are always executed from the right mixin to the left. Sometimes, however, if we only get output and it doesn't depend on what is passed to the method, we simply end up with method calls on a stack, which then get evaluated and it will appear as if things are applied from left to right.</div>
<p>Understanding the preceding explanation is really important for using stackable traits. It actually perfectly matches what we saw about linearization in <a href="39295d70-43a1-4c6c-b019-2723f048bf96.xhtml" target="_blank">Chapter 2</a>, <em>Traits and Mixin Compositions</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The type class design pattern</h1>
                </header>
            
            <article>
                
<p>A lot of times when we write software, we encounter similarities between different implementations. An important principle of good code design is to avoid repetition and it is known as <strong>do not repeat yourself</strong> (<strong>DRY</strong>). There are multiple ways that help us to avoid repetitions—inheritance, generics, and so on.</p>
<p>One way to make sure we do not repeat ourselves is through type classes.</p>
<div class="packt_infobox">The purpose of type classes is to define some behavior in terms of operations that a type must support in order to be considered a member of the type class.</div>
<p class="mce-root">A concrete example would be <kbd>Numeric</kbd>. We can say that it is a type class and defines the operations—addition, subtraction, multiplication, and so on, for the <kbd>Int</kbd>, <kbd>Double</kbd>, and such other classes. We have actually already encountered type classes earlier in this book in <a href="31807099-24ea-49c2-8dc1-8dcc978987d7.xhtml" target="_blank">Chapter 4</a>, <em>Abstract and Self Types</em>. Type classes are the ones that allow us to implement ad hoc polymorphism.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type class example</h1>
                </header>
            
            <article>
                
<p>Let's see an actual example that is also somehow useful to developers in this case. In machine learning, developers tend to use some statistical functions quite often in their work. There are statistical libraries and, if we try them out, we will see that these functions exist for different numeric types—<kbd>Int</kbd>, <kbd>Double</kbd>, and so on. Now, we could come up with something simple and implement these functions for all the numeric types we think about. This, however, is not feasible and makes our library impossible to extend. Moreover, statistical functions have the same definitions, no matter the type, so we don't want to repeat our code as many times as there are numeric types.</p>
<p>So let's first define our type class:</p>
<pre><span>trait </span>Number[<span>T</span>] {<br/>  <span>def </span><span>plus</span>(x: <span>T</span><span>, </span>y: <span>T</span>): <span>T<br/></span><span>  </span><span>def </span><span>minus</span>(x: <span>T</span><span>, </span>y: <span>T</span>): <span>T<br/></span><span>  </span><span>def </span><span>divide</span>(x: <span>T</span><span>, </span>y: <span>Int</span>): <span>T<br/></span><span>  </span><span>def </span><span>multiply</span>(x: <span>T</span><span>, </span>y: <span>T</span>): <span>T<br/></span><span>  </span><span>def </span><span>sqrt</span>(x: <span>T</span>): <span>T<br/></span>}</pre>
<p>The preceding is just a trait that defines some operations that will require numbers to support it.</p>
<div class="packt_tip"><span class="packt_screen">Numeric in Scala</span><br/>
<br/>
The Scala programming language has a <kbd>Numeric</kbd> trait that defines many of the previously mentioned operations.</div>
<p>If we had used the <kbd>Numeric</kbd> trait in the preceding code, we could have saved ourselves from some code writing, but for the sake of this example, let's use our custom type.</p>
<p>After we have defined a trait for the numbers, we can now write our library as follows:</p>
<pre><span>object </span>Stats {<br/>  <span>// same as<br/></span><span>  // def mean[T](xs: Vector[T])(implicit ev: Number[T]): T =<br/></span><span>  // ev.divide(xs.reduce(ev.plus(_, _)), xs.size)<br/></span><span>  </span><span>def </span><span>mean</span>[<span>T</span>: Number](xs: <span>Vector</span>[<span>T</span>]): <span>T </span>=<br/>    <span>implicitly</span>[Number[<span>T</span>]].divide(<br/>      xs.reduce(<span>implicitly</span>[Number[<span>T</span>]].plus(_<span>, </span>_))<span>,<br/></span><span>      </span>xs.size<br/>    )<br/><br/>  <span>// assumes the vector is sorted<br/></span><span>  </span><span>def </span><span>median</span>[<span>T</span>: Number](xs: <span>Vector</span>[<span>T</span>]): <span>T </span>=<br/>    xs(xs.size / <span>2</span>)<br/><br/>  <span>def </span><span>variance</span>[<span>T</span>: Number](xs: <span>Vector</span>[<span>T</span>]): <span>T </span>= {<br/>    <span>val </span>simpleMean = <span>mean</span>(xs)<br/>    <span>val </span>sqDiff = xs.map {<br/>      <span>case </span>x =&gt;<br/>        <span>val </span>diff = <span>implicitly</span>[Number[<span>T</span>]].minus(x<span>, </span>simpleMean)<br/>        <span>implicitly</span>[Number[<span>T</span>]].multiply(diff<span>, </span>diff)<br/>    }<br/>    <span>mean</span>(sqDiff)<br/>  }<br/><br/>  <span>def </span><span>stddev</span>[<span>T</span>: Number](xs: <span>Vector</span>[<span>T</span>]): <span>T </span>=<br/>    <span>implicitly</span>[Number[<span>T</span>]].sqrt(<span>variance</span>(xs))<br/>}</pre>
<p>There is quite a lot of code in the preceding example. Defining the functions is pretty straightforward. Let's, however, explain the role of the <kbd>implicitly</kbd> keyword. It uses the so-called <strong>context bounds</strong> from Scala, and it is the crucial part that allows us to implement the type class design pattern. In order to use the preceding methods, it requires a type class member of <kbd>Number</kbd> for the <kbd>T</kbd> type to be implicitly available. As you can see in the comment above <kbd>mean</kbd>, we can alternatively have an implicit parameter to the methods.</p>
<p>Now, let's write some example code that will use the previously mentioned methods:</p>
<pre><span>import </span>Stats._<br/><br/><span>object </span>StatsExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>intVector = <span>Vector</span>(<span>1</span><span>, </span><span>3</span><span>, </span><span>5</span><span>, </span><span>6</span><span>, </span><span>10</span><span>, </span><span>12</span><span>, </span><span>17</span><span>, </span><span>18</span><span>, </span><span>19</span><span>, </span><span>30</span><span>, </span><span>36</span><span>, </span><span>40</span><span>, </span><span>42</span><span>, </span><span>66</span>)<br/>    <span>val </span>doubleVector = <span>Vector</span>(<span>1.5</span><span>, </span><span>3.6</span><span>, </span><span>5.0</span><span>, </span><span>6.6</span><span>, </span><span>10.9</span><span>, </span><span>12.1</span><span>, </span><span>17.3</span><span>, </span><span>18.4</span><span>, </span><span>19.2</span><span>, </span><span>30.9</span><span>, </span><span>36.6</span><span>, </span><span>40.2</span><span>, </span><span>42.3</span><span>, </span><span>66.0</span>)<br/>    System.<span>out</span>.println(<span>s"Mean (int): </span><span>$</span>{<span>mean</span>(intVector)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Median (int): </span><span>$</span>{<span>median</span>(intVector)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Std dev (int): </span><span>$</span>{<span>stddev</span>(intVector)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Mean (double): </span><span>$</span>{<span>mean</span>(doubleVector)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Median (double): </span><span>$</span>{<span>median</span>(doubleVector)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Std dev (double): </span><span>$</span>{<span>stddev</span>(doubleVector)}<span>"</span>)<br/>  }<br/>}</pre>
<p>Compiling the preceding code right now will not be successful and we will see error similar to the following:</p>
<pre>Error:(9, 44) could not find implicit value for evidence parameter of type com.ivan.nikolov.type_classes.Number[Int]<br/>    System.out.println(s"Mean (int): ${mean(intVector)}")<br/>                                            ^</pre>
<p>The reason for this is that we have not yet defined any implicitly available <kbd>Number</kbd> members for <kbd>Int</kbd> and <kbd>Double</kbd>. Let's define them in the companion object for the <kbd>Number</kbd> trait:</p>
<pre><span>import </span>Math.round<br/><br/><span>object </span>Number {<br/>  <span>implicit object </span>DoubleNumber <span>extends </span>Number[<span>Double</span>] {<br/>    <span>override def </span><span>plus</span>(x: <span>Double, </span>y: <span>Double</span>): <span>Double </span>= x + y<br/>    <span>override def </span><span>divide</span>(x: <span>Double, </span>y: <span>Int</span>): <span>Double </span>= x / y<br/>    <span>override def </span><span>multiply</span>(x: <span>Double, </span>y: <span>Double</span>): <span>Double </span>= x * y<br/>    <span>override def </span><span>minus</span>(x: <span>Double, </span>y: <span>Double</span>): <span>Double </span>= x - y<br/>    <span>override def </span><span>sqrt</span>(x: <span>Double</span>): <span>Double </span>= Math.<span>sqrt</span>(x)<br/>  }<br/>  <br/>  <span>implicit object </span>IntNumber <span>extends </span>Number[<span>Int</span>] {<br/>    <span>override def </span><span>plus</span>(x: <span>Int, </span>y: <span>Int</span>): <span>Int </span>= x + y<br/>    <span>override def </span><span>divide</span>(x: <span>Int, </span>y: <span>Int</span>): <span>Int </span>= <span>round</span>(x.toDouble / y.toDouble).toInt<br/>    <span>override def </span><span>multiply</span>(x: <span>Int, </span>y: <span>Int</span>): <span>Int </span>= x * y<br/>    <span>override def </span><span>minus</span>(x: <span>Int, </span>y: <span>Int</span>): <span>Int </span>= x - y<br/>    <span>override def </span><span>sqrt</span>(x: <span>Int</span>): <span>Int </span>= <span>round</span>(Math.<span>sqrt</span>(x)).toInt<br/>  }<br/>}</pre>
<p>Now, our code will compile successfully. But how did this whole thing work when we had just defined these implicits in a companion object in a completely different file? First of all, our nested objects are implicit, and second of all, they are available in the companion object.</p>
<div class="packt_tip"><span class="packt_screen">Defining your default type class members in the companion object</span><br/>
<br/>
The companion object of the implicit type class parameter is the last place the compiler looks for implicit values. This means that nothing extra has to be done and users can easily override our implementations.</div>
<p>We can now run our code easily:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/c4c8d624-3ba1-4544-90eb-7f0cafa4931b.png" style="width:44.67em;height:10.08em;" width="720" height="163"/></div>
<p>Of course, we can put our implicit values anywhere we want. If they are not in the companion object, however, we will have to do extra imports in order to make them available.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type class design pattern alternatives</h1>
                </header>
            
            <article>
                
<p>There are, of course, alternatives to the type class design pattern. We can use the adapter design pattern. It will, however, make it much harder to read our code because things will be wrapped all the time and they will be much more verbose. The type class design pattern takes advantage of the nice features of the Scala type system.</p>
<p>Looking at our preceding code, we can also see that there is a fair bit of boilerplate code. This can become problematic in bigger projects, or when we try to define more complex type classes. A library that was written specifically to deal with these issues can be found at <a href="https://github.com/mpilquist/simulacrum/">https://github.com/mpilquist/simulacrum/</a>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lazy evaluation</h1>
                </header>
            
            <article>
                
<p>Writing efficient code is an important part of software engineering. A lot of times, we will see cases where an expression is expensive to evaluate due to different possible reasons—database access, complex calculations, and so on. There are cases where we might even be able to exit the application without even evaluating these expensive expressions. This is where lazy evaluation becomes helpful.</p>
<div class="packt_infobox">Lazy evaluation makes sure that an expression is evaluated only once when it is actually needed.</div>
<p>Scala supports lazy evaluation in a couple of flavors—lazy variables and by-name parameters. We have already seen both in this book the former we saw when we looked at creational design patterns in <a href="9971ad44-53fa-4b20-a3a3-4417ffeac78f.xhtml" target="_blank">Chapter 6</a>, <em>Creational Design Patterns,</em> and more specifically, lazy initialization. We saw the latter in a few places, but we encountered it for the first time in <a href="706552cf-27de-4b8b-b5a3-e6e22412056d.xhtml" target="_blank">Chapter 8</a>, <em>Behavioral Design Patterns - Part 1</em>, where we showed you how to implement the command design pattern in a way that is closer to how Scala does it.</p>
<p>There is an important difference between lazy variables and by-name parameters. The lazy variables will be calculated only once, whereas the by-name parameters will be calculated every time they are referred to in a method. There is a really simple trick we will show here that will fix this issue.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Evaluating by-name parameters only once</h1>
                </header>
            
            <article>
                
<p>Let's imagine that we have an application that takes data about people from a database. The reading operation is something that is expensive, and it is a good candidate for lazy evaluation. For this example, we will simply simulate reading from the database. First of all, our model will be as simple as the following:</p>
<pre><span>case class </span>Person(name: <span>String</span><span>, </span>age: <span>Int</span>)</pre>
<p>Now, let's create a companion object that will have a method that simulates getting the data about people from a database:</p>
<pre><span>object </span>Person {<br/>  <span>def </span><span>getFromDatabase</span>(): <span>List</span>[Person] = {<br/>    <span>// simulate we're getting people from database by sleeping<br/></span><span>    </span>System.<span>out</span>.println(<span>"Retrieving people..."</span>)<br/>    Thread.<span>sleep</span>(<span>3000</span>)<br/>    <span>List</span>(<br/>      <span>Person</span>(<span>"Ivan"</span><span>, </span><span>26</span>)<span>,<br/></span><span>      </span><span>Person</span>(<span>"Maria"</span><span>, </span><span>26</span>)<span>,<br/></span><span>      </span><span>Person</span>(<span>"John"</span><span>, </span><span>25</span>)<br/>    )<br/>  }<br/>}</pre>
<p>The preceding code simply makes the current thread sleep for three seconds and returns a static result. Calling the <kbd>getFromDatabase</kbd> method multiple times will make our application slow, so we should consider lazy evaluation. Now, let's add the following method to our companion object:</p>
<pre><span>def </span><span>printPeopleBad</span>(people: =&gt; <span>List</span>[Person]): <span>Unit </span>= {<br/>  System.<span>out</span>.println(<span>s"Print first time: </span><span>$</span>{people}<span>"</span>)<br/>  System.<span>out</span>.println(<span>s"Print second time: </span><span>$</span>{people}<span>"</span>)<br/>}</pre>
<p>As you can see, we simply printed the list of data about people twice and we accessed the by-name parameter twice. This is bad because it will evaluate the function twice and we will have to wait for twice the amount of time. Let's write another version that will fix this issue:</p>
<pre><span>def </span><span>printPeopleGood</span>(people: =&gt; <span>List</span>[Person]): <span>Unit </span>= {<br/>  <span>lazy val </span>peopleCopy = people<br/>  System.<span>out</span>.println(<span>s"Print first time: </span><span>$</span>{peopleCopy}<span>"</span>)<br/>  System.<span>out</span>.println(<span>s"Print second time: </span><span>$</span>{peopleCopy}<span>"</span>)<br/>}</pre>
<p>This time, we will assign the by-name parameter to a <kbd>lazy val</kbd> and then use it instead. This will only evaluate the by-name parameter once and, again, if we end up not using it, it will not be evaluated at all.</p>
<p>Let's see an example:</p>
<pre><span>object </span>Example {<br/><br/>  <span>import </span>Person._<br/><br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>"Now printing bad."</span>)<br/>    <span>printPeopleBad</span>(<span>getFromDatabase</span>())<br/>    System.<span>out</span>.println(<span>"Now printing good."</span>)<br/>    <span>printPeopleGood</span>(<span>getFromDatabase</span>())<br/>  }<br/>}</pre>
<p>If we run this application, we will see the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/347d0943-321f-48a9-8fef-e09c7287b163.png" style="width:45.75em;height:13.67em;" width="722" height="216"/></div>
<p>As you can see from the program output, the first version of our method retrieves the by-name parameter value twice, while the second version does it only once. The fact that we use a <kbd>lazy val</kbd> inside the second method also has the possibility of not evaluating our expensive expression at all if we don't actually use it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Alternative lazy evaluation</h1>
                </header>
            
            <article>
                
<p>There is another way to implement lazy evaluations in Scala. It is through using anonymous functions and taking advantage of the fact that functions are a part of unifications in Scala and we can also pass them as parameters easily. This is done as follows—a value is represented as <kbd>() =&gt; value</kbd> rather than just the value itself. It is somewhat pointless, though, especially because we already have two mechanisms that can do quite a lot. Using anonymous functions for a lazy evaluation is not recommended.</p>
<p>Passing a function to a method can also be considered as a way of lazily evaluating some data. This, however, can be useful and should not be confused with what we just said about anonymous functions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partial functions</h1>
                </header>
            
            <article>
                
<p>In mathematics and, as a consequence, in programming, there are functions that are not defined for all possible inputs. A simple example is the square root function—it will only work for real numbers if they are non-negative. In this section, we will look at partial functions and how we can use them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partial functions are not partially applied functions</h1>
                </header>
            
            <article>
                
<p>There seems to be some confusion around what partial functions are and what they are not. It is important for you to understand that these functions are not partially applied functions. Partially applied functions are simply functions that might take multiple parameters and we've specified some of them and then they return functions with fewer parameters that we can specify. There is another term—<strong>curried functions</strong>—that is related to partially applied functions. In terms of functionality, they provide the same functionality. Let's see a quick example:</p>
<pre><span>/**<br/></span><span>  * Note that these are not partially defined functions!<br/></span><span>  */<br/></span><span>object </span>PartiallyAppliedFunctions {<br/>  <span>val </span><span>greaterOrEqual </span>= (a: <span>Int, </span>b: <span>Int</span>) =&gt; a &gt;= b<br/>  <span>val </span><span>lessOrEqual </span>= (a: <span>Int, </span>b: <span>Int</span>) =&gt; a &lt;= b<br/><br/>  <span>def </span><span>greaterOrEqualCurried</span>(b: <span>Int</span>)(a: <span>Int</span>) = a &gt;= b<br/><br/>  <span>def </span><span>lessOrEqualCurried</span>(b: <span>Int</span>)(a: <span>Int</span>) = a &lt;= b<br/><br/>  <span>val </span><span>greaterOrEqualCurriedVal</span>: (<span>Int</span>) =&gt; (<span>Int</span>) =&gt; <span>Boolean </span>= b =&gt; a =&gt; a &gt;= b<br/>  <span>val </span><span>lessOrEqualCurriedVal</span>: (<span>Int</span>) =&gt; (<span>Int</span>) =&gt; <span>Boolean </span>= b =&gt; a =&gt; a &lt;= b<br/>}</pre>
<p>In the preceding code, we have different definitions of greater and lesser or equal functions. First, we have them as normal functions. The second version is with multiple parameter lists and the last one is an actual curried function. Here is how to use them:</p>
<pre><span>object </span>PartiallyAppliedExample {<br/><br/>  <span>import </span>PartiallyAppliedFunctions._<br/><br/>  <span>val </span><span>MAX </span>= <span>20<br/></span><span>  </span><span>val </span><span>MIN </span>= <span>5<br/></span><span><br/></span><span>  </span><span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>numbers = <span>List</span>(<span>1</span><span>, </span><span>5</span><span>, </span><span>6</span><span>, </span><span>11</span><span>, </span><span>18</span><span>, </span><span>19</span><span>, </span><span>20</span><span>, </span><span>21</span><span>, </span><span>25</span><span>, </span><span>30</span>)<br/>    <span>// partially applied<br/></span><span>    </span><span>val </span>ge = <span>greaterOrEqual</span>(_: <span>Int, </span><span>MIN</span>)<br/>    <span>val </span>le = <span>lessOrEqual</span>(_: <span>Int, </span><span>MAX</span>)<br/>    <span>// curried<br/></span><span>    </span><span>val </span>geCurried = <span>greaterOrEqualCurried</span>(<span>MIN</span>) _<br/>    <span>val </span>leCurried = <span>lessOrEqualCurried</span>(<span>MAX</span>) _<br/>    <span>// won't work because of the argument order<br/></span><span>    // val geCurried = greaterOrEqual.curried(MIN)<br/></span><span>    // val leCurried = lessOrEqual.curried(MAX)<br/></span><span>    // will work normally<br/></span><span>    // val geCurried = greaterOrEqualCurriedVal(MIN)<br/></span><span>    // val leCurried = lessOrEqualCurriedVal(MAX)<br/></span><span>    </span>System.<span>out</span>.println(<span>s"Filtered list: </span><span>$</span>{numbers.filter(i =&gt; ge(i) &amp;&amp; le(i))}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Filtered list: </span><span>$</span>{numbers.filter(i =&gt; geCurried(i) &amp;&amp; leCurried(i))}<span>"</span>)<br/>  }<br/>}</pre>
<p>The way we use partially applied functions is as follows:</p>
<pre>greaterOrEqual(_: Int, MIN)</pre>
<p>This returns a function of <kbd>Int</kbd> to <kbd>Boolean</kbd>, which we can use to check whether the parameter is greater or equal to the <kbd>MIN</kbd> value. This is a partially applied function.</p>
<p>For the curried versions of these functions, as you can see, we have switched the parameters. The reason is that curried functions are simply a chain of single parameter functions and the parameters are applied in the order we see them. The line <kbd>greaterOrEqualCurried(MIN) _</kbd> partially applies the function and returns a curried function that we can use similarly to above. As you can see in the code comments, we can actually convert any multiple parameter function into a curried function. The reason for <kbd>greaterOrEqual</kbd> and <kbd>lessOrEqual</kbd> not working in our example is that the parameters are applied in the order they are seen. Finally, we have a pure curried version in <kbd>greaterOrEqualCurriedVal</kbd> and <kbd>lessOrEqualCurriedVal</kbd>. This type of function is returned when we partially apply a function with multiple parameter lists.</p>
<p>If we run the preceding example, we will see the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b16ef7c8-238b-46e3-b9a9-48ce1f2df8bb.png" style="width:43.75em;height:5.67em;" width="724" height="94"/></div>
<p>Choosing whether to use partially applied functions or curried functions depends on many things, including personal preference. In both cases, we can achieve the same objectives with a slightly different syntax. As you can see, we can go from a normal to a curried function using <kbd>.curried</kbd>. We can also go the other way round using the <kbd>Function.uncurried</kbd> call and passing the function to it. This call makes sense when the curried function has more than one function in the chain.</p>
<div class="packt_tip"><span class="packt_screen">Using partially applied functions for dependency injection</span><br/>
<br/>
Because of the way partially applied functions and curried functions work, we can use them for dependency injection. We can basically apply the dependencies to a function and then get another function, which we can use afterward.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Partially defined functions</h1>
                </header>
            
            <article>
                
<p>We already said that partial functions are only defined for specific subsets of all possible values the functions can get. This is quite useful, as we can basically perform <kbd>filter</kbd> and <kbd>map</kbd> at once. This means fewer CPU cycles and more readable code. Let's see an example:</p>
<pre><span>object </span>PartiallyDefinedFunctions {<br/>  <span>val </span><span>squareRoot</span>: PartialFunction[<span>Int, Double</span>] = {<br/>    <span>case </span>a <span>if </span>a &gt;= <span>0 </span>=&gt; Math.<span>sqrt</span>(a)<br/>  }<br/>}</pre>
<p>We defined a partial function from <kbd>Int</kbd> to <kbd>Double</kbd>. It checks whether a number is non-negative and returns the square root of that number. This partial function can be used as follows:</p>
<pre><span>object </span>PartiallyDefinedExample {<br/><br/>  <span>import </span>PartiallyDefinedFunctions._<br/><br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>items = <span>List</span>(-<span>1</span><span>, </span><span>10</span><span>, </span><span>11</span><span>, </span>-<span>36</span><span>, </span><span>36</span><span>, </span>-<span>49</span><span>, </span><span>49</span><span>, </span><span>81</span>)<br/>    System.<span>out</span>.println(<span>s"Can we calculate a root for -10:<br/>     </span><span>$</span>{<span>squareRoot</span>.isDefinedAt(-<span>10</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Square roots: </span><span>$</span>{items.collect(<span>squareRoot</span>)}<span>"</span>)<br/>  }<br/>}</pre>
<p>We are using the <kbd>collect</kbd> method that takes a partial function. We've also shown one of the methods that partial functions have—<kbd>isDefinedAt</kbd>, whose name tells us exactly what it does. The output of our program will be this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/872cb315-f536-4e25-bfb6-485a1951abcb.png" width="723" height="91"/></div>
<p>Our partial function filtered out the negative numbers and returned the square roots of the rest.</p>
<p>Partial functions can also be used to chain operations or do something different if one operation is not possible. They have the <kbd>orElse</kbd>, <kbd>andThen</kbd>, <kbd>runWith</kbd>, and such other methods. It is clear from their names what the first two methods do. The third method uses the results of the partially applied function and performs an action that could potentially cause side effects. Let's see an example of <kbd>orElse</kbd>:</p>
<pre><span>val </span><span>square</span>: PartialFunction[<span>Int, Double</span>] = {<br/>  <span>case </span>a <span>if </span>a &lt; <span>0 </span>=&gt; Math.<span>pow</span>(a<span>, </span><span>2</span>)<br/>}</pre>
<p>First, we define another partial function that squares negative numbers. Then, we can add some extra code to our example:</p>
<pre><span>object </span>PartiallyDefinedExample {<br/><br/>  <span>import </span>PartiallyDefinedFunctions._<br/><br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>items = <span>List</span>(-<span>1</span><span>, </span><span>10</span><span>, </span><span>11</span><span>, </span>-<span>36</span><span>, </span><span>36</span><span>, </span>-<span>49</span><span>, </span><span>49</span><span>, </span><span>81</span>)<br/>    System.<span>out</span>.println(<span>s"Can we calculate a root for -10:<br/>     </span><span>$</span>{<span>squareRoot</span>.isDefinedAt(-<span>10</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Square roots: </span><span>$</span>{items.collect(<span>squareRoot</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Square roots or squares:<br/>     </span><span>$</span>{items.collect(<span>squareRoot</span>.orElse(<span>square</span>))}<span>"</span>)<br/>  }<br/>}</pre>
<p>This will produce the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/38030e60-b8e4-4760-8624-1dec1a8e53f4.png" style="width:44.17em;height:7.75em;" width="722" height="127"/></div>
<p>We will basically square the negative numbers and square root the positive ones. It might not make much sense in terms of the operations we do in this example, but it shows how we can chain partial functions. If, after combining the different partial functions, we end up covering the whole possible input space, then it might make more sense to use pattern matching and a normal function. If we don't match all the possible values, however, we can get runtime exceptions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit injection</h1>
                </header>
            
            <article>
                
<p>We already saw implicits in a few places in this book. We used them in the type class design pattern and the pimp my library design pattern, and we also mentioned that they can be used for dependency injection. Implicits are also used for conversions from one type to another silently.</p>
<p>They are nothing more than some objects, values, or methods that the compiler knows about and injects for us into methods or places that need them. What we need to make sure is to make these implicits available to the scope of the methods that will use them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implicit conversions</h1>
                </header>
            
            <article>
                
<p>We have already mentioned that implicits can be used for silent conversions. Sometimes, it might be useful to be able to assign a <kbd>Double</kbd> to an <kbd>Int</kbd> and not get an error. Other times, we might want to wrap an object of one type into another and take advantage of the methods the new one provides:</p>
<pre><span>package object </span>implicits {<br/>  <span>implicit def </span><span>doubleToInt</span>(a: <span>Double</span>): <span>Int </span>= Math.<span>round</span>(a).toInt<br/>}</pre>
<p>In the preceding code listing, we have a package object that defines a method, which converts a <kbd>Double</kbd> to <kbd>Int</kbd>. This will allow us to write and successfully compile the following code:</p>
<pre><span>object </span>ImplicitExamples {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>number: Int = <span>7.6<br/></span><span>    </span>System.<span>out</span>.println(<span>s"The integer value for 7.6 is </span><span>$</span>{number}<span>"</span>)<br/>  }<br/>}</pre>
<p>We don't have to do anything extra, as long as the <kbd>ImplicitExamples</kbd> object is in the same package as our package object. Another alternative would be to define our implicit conversions inside an object and import the object in the scope we will need it in.</p>
<p>We can even wrap types in new objects. There are some examples in the <kbd>LowPriorityImplicits</kbd> class that is part of Scala, which can convert strings to sequences and so on. Now, let's add an implicit conversion that will convert a list of <kbd>Int</kbd> to a <kbd>String</kbd>:</p>
<pre><span>implicit def </span><span>intsToString</span>(ints: <span>List</span>[<span>Int</span>]): <span>String </span>= ints.map(_.toChar).mkString</pre>
<p>Now, we can use our implicit conversion in order to print a list of ASCII character codes as a <kbd>String</kbd>:</p>
<pre><span>object </span>ImplicitExamples {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>number: Int = <span>7.6<br/></span><span>    </span>System.<span>out</span>.println(<span>s"The integer value for 7.6 is </span><span>$</span>{number}<span>"</span>)<br/>    <span>// prints HELLO!<br/></span><span>    </span>printAsciiString(<span>List</span>(<span>72</span><span>, </span><span>69</span><span>, </span><span>76</span><span>, </span><span>76</span><span>, </span><span>79</span><span>, </span><span>33</span>))<br/>  }<br/><br/>  <span>def </span><span>printAsciiString</span>(s: <span>String</span>): <span>Unit </span>= {<br/>    System.<span>out</span>.println(s)<br/>  }<br/>}</pre>
<p>Running this example will produce the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/45d6f69e-a5de-431e-bb58-973850dcfa49.png" style="width:45.83em;height:5.67em;" width="723" height="89"/></div>
<p>There are a lot of useful things which we might need implicit conversions for. They could help in separating our code nicely, but we should be careful not to overuse them because debugging could be problematic and the code's readability might suffer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependency injection using implicits</h1>
                </header>
            
            <article>
                
<p>When we showed dependency injection using the cake design pattern, we also mentioned that it is possible to achieve it using implicits. The idea is that services are created in one place and then we can write methods that implicitly require what the services need. By now, you should have acquired enough knowledge to be able to get to the right solution alone, so here we will just show a subset of the big example we had previously:</p>
<pre><span>case class </span>Person(name: <span>String</span><span>, </span>age: <span>Int</span>)</pre>
<p>After we have a model defined, we can create a <kbd>DatabaseService</kbd> as follows:</p>
<pre><span>trait </span>DatabaseService {<br/>  <span>def </span><span>getPeople</span>(): <span>List</span>[Person]<br/>}<br/><br/><span>class </span>DatabaseServiceImpl <span>extends </span>DatabaseService {<br/>  <span>override def </span><span>getPeople</span>(): <span>List</span>[Person] = <span>List</span>(<br/>    <span>Person</span>(<span>"Ivan"</span><span>, </span><span>26</span>)<span>,<br/></span><span>    </span><span>Person</span>(<span>"Maria"</span><span>, </span><span>26</span>)<span>,<br/></span><span>    </span><span>Person</span>(<span>"John"</span><span>, </span><span>25</span>)<br/>  )<br/>}</pre>
<p>Our database service does not depend on anything. It simply simulates that it reads something from a database. Now, let's create a <kbd>UserService</kbd>, which will depend on the <kbd>DatabaseService</kbd>:</p>
<pre><span>trait </span>UserService {<br/>  <span>def </span><span>getAverageAgeOfPeople</span>()(<span>implicit </span>ds: DatabaseService): <span>Double<br/></span>}<br/><br/><span>class </span>UserServiceImpl <span>extends </span>UserService {<br/>  <span>override def </span><span>getAverageAgeOfPeople</span>()(<span>implicit </span>ds: DatabaseService): <span>Double </span>= {<br/>    <span>val </span>(s<span>, </span>c) = ds.getPeople().foldLeft((<span>0</span><span>, </span><span>0</span>)) {<br/>      <span>case </span>((sum<span>, </span>count)<span>, </span>person) =&gt;<br/>        (sum + person.age<span>, </span>count + <span>1</span>)<br/>    }<br/>    s.toDouble / c.toDouble<br/>  }<br/>}</pre>
<p>As you can see from the signature of the only method the user service provides, it requires an instance of <kbd>DatabaseService</kbd> to be implicitly available. We can also explicitly pass one and override the one we have for the purpose of testing. Now that we have these services, we can wire them up:</p>
<pre><span>package object </span>di {<br/>  <span>implicit val </span><span>databaseService </span>= <span>new </span>DatabaseServiceImpl<br/>  <span>implicit val </span><span>userService </span>= <span>new </span>UserServiceImpl<br/>}</pre>
<p>We have chosen to use a package object, but any object or class is fine, as long as we can import it wherever we need the object. Now, the use of our application is easy:</p>
<pre><span>object </span>ImplicitDIExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"The average age of the people is:<br/>     </span><span>$</span>{userService.getAverageAgeOfPeople()}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output will be the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1aa5069e-846c-494f-9179-4787d6ec14a3.png" style="width:46.50em;height:4.75em;" width="713" height="73"/></div>
<p>As you can see, now we have used less boilerplate code than in the cake design pattern. A drawback of this approach is the method signatures, which can get more complex when we have more dependencies. In real-world applications, there could be a huge amount of dependencies, and also code readability will be affected due to the implicit variables. A possible solution to this could be wrapping dependencies in objects and implicitly passing them instead. In the end, it's mostly a matter of personal preference as to which dependency injection strategy will be used, as the same things can be achieved with both.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing with implicit dependency injection</h1>
                </header>
            
            <article>
                
<p>Testing with implicit dependency injection is similar to testing with the cake design pattern. We can have a new object that creates mocks of the services and then makes them available to the test classes. When we want to use a concrete implementation of a service, we can just override it. We could also pass a dependency explicitly here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Duck typing</h1>
                </header>
            
            <article>
                
<p>A significant part of the work of a developer is to minimize the amount of code duplication. There are multiple different approaches to do this, including inheritance, abstraction, generics, type classes, and so on. There are cases, however, where strongly typed languages will require some extra work in order to minimize some of the duplication. Let's imagine that we have a method that can read and print the contents of a file. If we have two different libraries that allow us to read a file, in order to use our method, we will have to make sure the methods that read the file somehow become the same type. One way would be by wrapping them in a class that implements a specific interface. Provided that in both the libraries the read method has the same signature, which could easily happen, Scala can use duck typing instead, and this way it will minimize the extra work we will have to do.</p>
<div class="packt_infobox">Duck typing is a term that comes from dynamic languages and it allows us to treat different types of objects in a similar manner based on a common method they have.</div>
<p>Another name for duck typing is <strong>structural typing</strong>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Duck typing example</h1>
                </header>
            
            <article>
                
<p>Everything becomes clearer with an example. Let's imagine that we want to have a method which can take a parser and print every word that the parser detects. Our parsers will have a method with the following signature:</p>
<pre>def parse(sentence: String): Array[String]</pre>
<p>A good way of doing this would be to have a common interface and make all the parsers implement it. However, let's set a condition that we cannot do this. The parsers could be coming from two different libraries where we cannot modify or connect in any way.</p>
<p>We have defined two different parser implementations for this example. The first one is as follows:</p>
<pre><span>import </span>java.util.StringTokenizer<br/><br/><span>class </span>SentenceParserTokenize {<br/>  <span>def </span><span>parse</span>(sentence: <span>String</span>): Array[<span>String</span>] = {<br/>    <span>val </span>tokenizer = <span>new </span>StringTokenizer(sentence)<br/>    <span>Iterator</span>.<span>continually</span>({<br/>      <span>val </span>hasMore = tokenizer.hasMoreTokens<br/>      <span>if </span>(hasMore) {<br/>        (hasMore<span>, </span>tokenizer.nextToken())<br/>      } <span>else </span>{<br/>        (hasMore<span>, </span><span>null</span>)<br/>      }<br/>    }).takeWhile(_._1).map(_._2).toArray<br/>  }<br/>}</pre>
<p>This parser makes use of the <kbd>StringTokenizer</kbd> class and returns an array of all the words separated by spaces. Another implementation that does exactly the same is shown here:</p>
<pre><span>class </span>SentenceParserSplit {<br/>  <span>def </span><span>parse</span>(sentence: <span>String</span>): Array[<span>String</span>] = sentence.split(<span>"</span><span>\\</span><span>s"</span>)<br/>}</pre>
<p>Here, we just split the sentence using a regular expression for space.</p>
<p>As you can see, both the classes have a parse method with the same signature, but they have no connection with each other. We, however, want to be able to use them in a method and avoid code duplication. Here is how we can do this:</p>
<pre><span>object </span>DuckTypingExample {<br/>  <strong>def printSentenceParts(sentence: String, parser: {</strong><br/><strong>    def parse(sentence: String): Array[String]</strong><br/><strong>  })</strong> = parser.parse(sentence).foreach(<span>println</span>)<br/><br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>tokenizerParser = <span>new </span>SentenceParserTokenize<br/>    <span>val </span>splitParser = <span>new </span>SentenceParserSplit<br/>    <span>val </span>sentence = <span>"This is the sentence we will be splitting."<br/></span><span>    </span>System.<span>out</span>.println(<span>"Using the tokenize parser: "</span>)<br/>    <span>printSentenceParts</span>(sentence<span>, </span>tokenizerParser)<br/>    System.<span>out</span>.println(<span>"Using the split parser: "</span>)<br/>    <span>printSentenceParts</span>(sentence<span>, </span>splitParser)<br/>  }<br/>}</pre>
<p>In the preceding code, we passed both the parsers to the <kbd>printSentenceParts</kbd> method and everything compiles and works fine. The reason things work is because of duck typing and this can be seen in the highlighted part of our example. The output of our application is the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7ce57804-9bc9-4b25-9adc-03c7968c93c3.png" style="width:41.83em;height:22.00em;" width="720" height="379"/></div>
<p>We can use duck typing for requiring even more methods to be available for an object by just expanding the parameter signature.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Duck typing alternatives</h1>
                </header>
            
            <article>
                
<p>As you can see from the preceding code, duck typing saves us from some extra code writing and the need to define common interfaces. Other ways to achieve the same would involve creating wrappers, which implement a common interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">When to use duck typing</h1>
                </header>
            
            <article>
                
<p>Overusing duck typing can negatively affect code quality and application performance. You should not avoid creating common interfaces in favor of duck typing. It should be really only used in cases when we cannot implement a common interface between different types. The argument about limiting the use of duck typing is further enhanced by the fact that, under the hood, they use reflection, which is slower and negatively impacts performance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Memoization</h1>
                </header>
            
            <article>
                
<p>Writing high-performance programs is usually a mixture of using good algorithms and the smart usage of computer processing power. Caching is one mechanism that can help us, especially when a method takes time to calculate or it's called a lot of times in our application.</p>
<div class="packt_infobox">Memoization is a mechanism of recording a function result based on its arguments in order to reduce computation in consecutive calls.</div>
<p>Along with saving CPU cycles, memoization can also be useful to minimize the application memory footprint by only having one instance of each result. Of course, for this entire mechanism to work, we need to have a function that always returns the same result when the same arguments are passed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Memoization example</h1>
                </header>
            
            <article>
                
<p>There are different ways to achieve memoization. Some of them use imperative programming styles and it's pretty straightforward to get to them. Here, we will show an approach which is more suitable for Scala.</p>
<p>Let's imagine that we will need to hash strings millions of times. Each hashing takes some time, depending on the underlying algorithm, but if we store some results and reuse them for repeated strings, we can save some computation at the expense of having a table of results.</p>
<p>We will start with something as simple as this:</p>
<pre><span>import </span>org.apache.commons.codec.binary.Hex<br/><br/><span>class </span>Hasher <span>extends </span>Memoizer {<br/>  <span>def </span><span>md5</span>(input: <span>String</span>) = {<br/>    System.<span>out</span>.println(<span>s"Calling md5 for </span><span>$</span>input<span>."</span>)<br/>    <span>new </span>String(Hex.<span>encodeHex</span>(MessageDigest.<span>getInstance</span>(<span>"MD5"</span>).digest(input.getBytes)))<br/>  }<br/>}</pre>
<p>The preceding code is of a class that has a method called <kbd>md5</kbd>, which returns a hash of the string we pass to it. We have mixed in a trait called <kbd>Memoizer</kbd>, which has the following representation:</p>
<pre><span>import </span>scala.collection.mutable.Map<br/><br/><span>trait </span>Memoizer {<br/>  <span>def </span><span>memo</span>[<span>X</span><span>, </span><span>Y</span>](f: <span>X </span>=&gt; <span>Y</span>): (<span>X </span>=&gt; <span>Y</span>) = {<br/>    <span>val </span>cache = Map[<span>X</span><span>, </span><span>Y</span>]()<br/>    (x: <span>X</span>) =&gt; cache.getOrElseUpdate(x<span>, </span>f(x))<br/>  }<br/>}</pre>
<p>The preceding trait has a method called <kbd>memo</kbd>, which uses a mutable map to retrieve the result of a function based on its input parameters, or calls the actual function passed to it if the result is not already in the map. This method returns a new function, which actually uses the aforementioned map and has its results memoized.</p>
<div class="packt_tip">The preceding memoizer example is potentially not thread safe. Multiple threads could access the map in parallel and cause the function to be executed twice. It's up to the developer to make sure thread safety is in place, if it's needed.</div>
<p>The fact that we have used generics means that we can actually use this method to create a memoized version of any one-parameter function. Now, we can go back to our <kbd>Hasher</kbd> class and add the following line:</p>
<pre>val memoMd5 = memo(md5)</pre>
<p>This makes <kbd>memoMd5</kbd> a function that does exactly what <kbd>md5</kbd> does, but uses a map internally to try and retrieve results that we have already calculated. We can now use our <kbd>Hasher</kbd> in the following way:</p>
<pre><span>object </span>MemoizationExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>hasher = <span>new </span>Hasher<br/>    System.<span>out</span>.println(<span>s"MD5 for 'hello' is '</span><span>$</span>{hasher.<span>memoMd5</span>(<span>"hello"</span>)}<span>'."</span>)<br/>    System.<span>out</span>.println(<span>s"MD5 for 'bye' is '</span><span>$</span>{hasher.<span>memoMd5</span>(<span>"bye"</span>)}<span>'."</span>)<br/>    System.<span>out</span>.println(<span>s"MD5 for 'hello' is '</span><span>$</span>{hasher.<span>memoMd5</span>(<span>"hello"</span>)}<span>'."</span>)<br/>    System.<span>out</span>.println(<span>s"MD5 for 'bye1' is '</span><span>$</span>{hasher.<span>memoMd5</span>(<span>"bye1"</span>)}<span>'."</span>)<br/>    System.<span>out</span>.println(<span>s"MD5 for 'bye' is '</span><span>$</span>{hasher.<span>memoMd5</span>(<span>"bye"</span>)}<span>'."</span>)<br/>  }<br/>}</pre>
<p>The output of this example will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b9f1df58-2794-4348-b385-3a9c71711af9.png" style="width:38.67em;height:10.67em;" width="722" height="199"/></div>
<p>The preceding output proves that calling our memoized function for the same inputs actually retrieves the result from the map, instead of calling the part that processes the result again.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Memoization alternatives</h1>
                </header>
            
            <article>
                
<p>The <kbd>memo</kbd> method that we showed previously is quite neat and easy to use, but it's limiting. We can only get memoized versions of functions with one parameter (or we have to represent multiple parameters as a tuple). However, the Scalaz library already has support for memoization using the <kbd>Memo</kbd> object. We can simply do the following:</p>
<pre><span>val </span><span>memoMd5Scalaz</span>: <span>String </span>=&gt; <span>String </span>= Memo.immutableHashMapMemo {<br/>  md5<br/>}</pre>
<p>The preceding code can go into our <kbd>Hasher</kbd> class and then we can instead call <kbd>memoMd5Scalaz</kbd> in our example. This would not require us to write the extra <kbd>Memoizer</kbd> trait and it will produce absolutely the same result as what we showed previously. Moreover, the Scalaz version gives us much more flexibility in terms of the way we cache and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we saw how to apply some of the advanced concepts of the Scala programming language in order to tackle problems that commonly emerge in actual software projects. We looked at the lens design pattern, where we also had our first encounter with the brilliant Scalaz library. We saw how to implement dependency injection without any extra libraries in Scala, and what it is used for. We also learned how we can write extensions to the libraries which we don't have any modification access for. Last but not least, we looked at the type class design pattern, lazy evaluation in Scala, partial functions (also known as function currying), duck typing, memoization, and implicit injection. By now, you should have quite an extensive knowledge of the language possibilities of Scala as well as design patterns, which can be used together to write exceptional software.</p>
<p>In the next and last chapter of this book, we will focus a bit more on the Scalaz library, and we will show its support for some of the concepts we have already seen. We will also go through a final project that will combine our knowledge into something that can be used as production code. Finally, we will briefly summarize the content covered in this book and give useful pointers.</p>


            </article>

            
        </section>
    </div>



  </body></html>