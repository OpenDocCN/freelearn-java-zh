- en: A Rabbit Springs to Life
  prefs: []
  type: TYPE_NORMAL
- en: '**Messaging** or **message queuing** is a method of communication between applications
    or components. Thanks to message queues, these applications can remain completely
    separate as they process their individual tasks. Messages are typically small
    requests, replies, status updates, or even just information. A message queue provides
    a temporary place for these messages to stay, allowing applications to send and
    receive them as necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ is an open source message broker that acts as the intermediary or middleman
    for independent applications, giving them a common platform to communicate. RabbitMQ
    mainly uses an Erlang-based implementation of the **Advanced Message Queuing Protocol **(**AMQP**),
    which supports advanced features such as clustering and the complex routing of
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes information about how to get started with RabbitMQ, and
    why it would benefit an architecture. This book follows a fictitious taxi agency,
    **Complete Car** (**CC**), to demonstrate how they have implemented RabbitMQ into
    the architecture. This chapter shows how to install and configure RabbitMQ so
    that it's easy to get everything up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering AMQP and RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RabbitMQ in real life
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the benefits of message queuing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A RabbitMQ scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready for RabbitMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [h ttps://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: Explaining message queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Smoke signals, couriers, carrier pigeons, and semaphores: if this was a riddle,
    the word **messages **would immediately spring to mind. Humanity has always had
    the need to connect, finding new ways to defy challenges posed by the distance
    between the different groups of people needing to communicate. Humankind has come
    a long way with modern technologies, but essentially, the basics remain. Senders,
    recipients, and messages are at the core of all our communication infrastructures.'
  prefs: []
  type: TYPE_NORMAL
- en: Software applications have the same needs; systems need to communicate and send
    messages between each other. They sometimes need to be sure that the message that's
    been sent has reached its destination, and sometimes they need to receive an immediate
    response. In some cases, they may even need to receive more than one response.
    Based on these different needs, different styles of communication between systems
    have emerged.
  prefs: []
  type: TYPE_NORMAL
- en: AMQP, RabbitMQ's default protocol, is explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering AMQP and RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message queuing is a one-way communication style that provides asynchronous
    interaction between systems. As this chapter continues to describe how message
    queues work, the benefits will become clear. Some background on the request-response
    message exchange pattern will shed light on how RabbitMQ works.
  prefs: []
  type: TYPE_NORMAL
- en: The request-response message exchange pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many types of message exchange patterns, but the request-response
    style is the most common. A system, acting as a client, interacts with another
    remote system, which is acting as a server. The client sends a request for data,
    and the server responds to the request, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55761e1c-afc1-4fe2-8ffa-338ca2cfc21b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.1: The request-response interaction between the client and the server'
  prefs: []
  type: TYPE_NORMAL
- en: 'The request-response style is used when the client must have an immediate response
    or wants the service to complete a task without delay, such as being placed on
    hold when calling a restaurant to reserve a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71dd3f7d-9555-4fe8-a6fd-a21aca382a9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.2: Request-response between a client and a restaurant'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether it takes the form of a remote procedure call, a web service invocation,
    or consumption of a resource, the model is the same: one system sends a message
    to another and waits for the remote party to respond. Systems communicate with
    each other in a point-to-point manner, where events and processes occur simultaneously
    or have dependencies or events related to time; the interaction between the client
    and server is **synchronous**.'
  prefs: []
  type: TYPE_NORMAL
- en: One on hand, this request-response style gives developers a simple programming
    model as everything happens procedurally. On the other hand, the tight coupling
    between both parties has a deep impact on the architecture of the whole system
    as it is hard to evolve, hard to scale, and hard to ship in independent releases.
  prefs: []
  type: TYPE_NORMAL
- en: Message queuing exchange pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Message queuing is a one-way style of interaction where one system asynchronously
    interacts with another system via messages, generally through a message broker. A
    requesting system in asynchronous communication mode does not wait for an answer
    or require return information; it continues processing no matter what. The most
    common example of such an interaction is an email. The point is, asynchronous
    communication does not involve waiting for a response in order to continue processing.
    In fact, there may be no response or it may take some time for a response to be
    sent. Whatever the case, the system does not rely on a response to continue the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages flow in one direction, from the publisher to the broker and finally
    to the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e10308b6-e487-4927-8405-bcfbf5587839.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.3: Basic components of a one-way interaction with message queuing'
  prefs: []
  type: TYPE_NORMAL
- en: Systems and applications play both the role of message publishers (producers)
    and message consumers (subscribers). A publisher publishes a message to a broker
    that they rely on to deliver the data to the intended consumer. If a response
    is required, it will arrive at some point in time through the same mechanism,
    but reversed (the consumer and producer roles will be swapped).
  prefs: []
  type: TYPE_NORMAL
- en: A loosely coupled architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One big advantage of the messaging queuing approach is that systems become loosely
    coupled with each other. They do not need to know the location of other nodes
    on the network; a mere name is enough to reach them. Systems can, therefore, be
    evolved in an independent manner with no impact on each other as the reliability
    of message delivery is entrusted to a broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates a loose coupling between the publisher and
    the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a9fe21-6b50-4db2-8496-81930a935750.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.4: Message queuing enabling a loosely coupled architecture'
  prefs: []
  type: TYPE_NORMAL
- en: If one system is down for any reason, the other part of the system can still
    operate, and messages that are supposed to be sent between them wait in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture represented via message queuing allows for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The publishers or consumers can be updated one by one, without them impacting
    each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance of each side leaves the other side unaffected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The publishers or consumers are allowed to fail without impacting each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of instances of publishers and consumers to scale and to accommodate
    their workload in complete independence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technology mixing between consumer and publishers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main downside of this approach is that programmers cannot rely on the mental
    model of procedural programming where events occur one after another. In messaging,
    things happen over time. Systems must be programmed to deal with this.
  prefs: []
  type: TYPE_NORMAL
- en: If all this is a little blurry, use the example of a well-known protocol, **Simple
    Mail Transfer Protocol** (**SMTP**). In this protocol, emails are published (sent)
    to an SMTP server. This initial server then stores and forwards the email to the
    next SMTP server, and so on until the recipient email server is reached. At this
    point, the message is queued in an inbox, waiting to be picked up by the consumer
    (typically, via POP3 or IMAP). With SMTP, the publisher has no idea when the email
    will be delivered or whether it will eventually be delivered at all. In the case
    of a delivery failure, the publisher is notified of issues later down the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only sure fact is that the broker has successfully accepted the message
    that was initially sent. This entire process can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bd7cc21-3873-4dd2-9881-85803726d75f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.5: The email infrastructure as an analogy for message queuing'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if a response is needed, it will arrive asynchronously using the
    same delivery mechanism but with the publisher and consumer roles reversed.
  prefs: []
  type: TYPE_NORMAL
- en: With these fundamental notions established, it is the perfect time to delve
    into the messaging protocol that will be used in this book, which is AMQP.
  prefs: []
  type: TYPE_NORMAL
- en: Meet AMQP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AMQP** is an open standard protocol that defines how a system can exchange
    messages. The protocol defines a set of rules that needs to be followed by the
    systems that are going to communicate with each other. In addition to defining
    the interaction that happens between a consumer/producer and a broker, it also
    defines the representation of the messages and commands being exchanged. AMQP
    is truly interoperable as it specifies the wire format for messages, leaving nothing
    open to interpretation by a particular vendor or hosting platform. Since it is
    open source, the AMQP community is prolific and has broker and client implementations
    in a wide range of languages.'
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ is built upon the AMQP 0-9-1 specification, but plugins are available
    that support AMQP 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: The AMQP 0-9-1 specification can be downloaded at [http://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf](http://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the core concepts of AMQP, which will be explained
    in detail in upcoming chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Broker or message broker**: A broker is a piece of software that receives
    messages from one application or service, and delivers them to another application,
    service, or broker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual host, vhost**: A vhost exists within the broker. It''s a way to separate
    applications that are using the same RabbitMQ instance, similar to a logical container
    inside a broker; for example, separating working environments into development
    on one vhost and staging on another, keeping them within the same broker instead
    of setting up multiple brokers. Users, exchanges, queues, and so on are isolated
    on one specific vhost. A user connected to a particular vhost cannot access any
    resources (queue, exchange, and so on) from another vhost. Users can have different
    access privileges to different vhosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection**: Physical network (TCP) connection between the application (publisher/consumer)
    and a broker. When the client disconnects or a system failure occurs, the connection
    is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channel**: A channel is a **virtual connection** inside a **connection***.* It
    reuses a connection, forgoing the need to reauthorize and open a new TCP stream.
    When messages are published or consumed, it is done over a channel. Many channels
    can be established within a single connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exchange**: The exchange entity is in charge of applying routing rules for
    messages, making sure that messages are reaching their final destination. In other
    words, the exchange ensures that the received message ends up in the correct queues.
    Which queue the message ends up in depends on the rules defined by the exchange
    type. A queue needs to be bound to at least one exchange to be able to receive
    messages. Routing rules include direct (point-to-point), topic (publish-subscribe),
    fanout (multicast), and header exchanges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue**: A queue is a sequence of items; in this case, messages. The queue
    exists within the broker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding**: A binding is a virtual link between an exchange and a queue within
    the broker. It enables messages to flow from an exchange to a queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates an overview of some of the concepts in AMQP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb85d456-ba34-460a-ba06-4a916b6296f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.6: Overview of some of the concepts defined by the AMQP specification'
  prefs: []
  type: TYPE_NORMAL
- en: The open source broker shown in detailin this book has been built from the ground
    up to support AMQP, but many other protocols are also supported by RabbitMQ, such
    as MQTT, HTTP, and STOMP.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to turn the focus to RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: The RabbitMQ broker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RabbitMQ is an Erlang implementation of an AMQP broker. It implements Version
    0-9-1 of AMQP with custom extensions, as allowed by the protocol. Erlang has been
    chosen because of its intrinsic support for building highly reliable and distributed
    applications. Indeed, Erlang is used to run telecommunication switches in several
    large telecommunication systems, and a total system's availability of nine nines
    has been reported (that's only 32 milliseconds of downtime per year). Erlang is
    able to run on any operating system.
  prefs: []
  type: TYPE_NORMAL
- en: For data persistence, RabbitMQ relies on Mnesia, the in-memory/file-persisted
    embedded database of Erlang. Mnesia stores information about users, exchanges,
    queues, bindings, and so on. The queue index stores message positions and information
    on whether a message has been delivered or not. Messages are stored either in
    the queue index or in the message store, a key-value store shared among all queues.
  prefs: []
  type: TYPE_NORMAL
- en: For clustering, it mainly relies on Erlang's ingrained clustering abilities.
    RabbitMQ can easily be extended with the addition of plugins. For example, a web-based
    administration console can be deployed on RabbitMQ thanks to this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins can be used to extend the core broker functionality. There are many
    plugins available for RabbitMQ, and it's also possible to develop plugins, if
    needed: [https://www.rabbitmq.com/plugins.html](https://www.rabbitmq.com/plugins.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'RabbitMQ can be set up on a single, standalone instance, or as a cluster on
    multiple servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af1f86a8-0764-4632-afdd-1b618669a3e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.7: Standalone instance, or as a cluster on multiple servers'
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ brokers can be connected together using different techniques, such
    as federation and shovels, in order to form messaging topologies with smart message
    routing across brokers and the capacity to span multiple data centers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows federation between RabbitMQ brokers located
    in different places around the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d81c5d31-c38f-43fd-884c-797e97efe07e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.8: The RabbitMQ broker engaging in various topologies'
  prefs: []
  type: TYPE_NORMAL
- en: '**RabbitMQ supports AMQP 1.0 through plugins.**'
  prefs: []
  type: TYPE_NORMAL
- en: AMQP 1.0 was published at the end of 2011 after the development and maintenance
    of AMQP was transferred to OASIS. AMQP has been drastically revised between 0-9-1
    and 1.0\. This was so drastic that some core concepts, such as the exchange, no
    longer exist. Thus, AMQP 1.0 is a different protocol than 0-9-1, but there is
    no truly compelling reason to adopt it. It is not more capable than 0-9-1, and
    some would also argue that it has lost some of the key aspects that made it attractive
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: So, when or where is RabbitMQ used? The next section describes some common use
    cases for RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Using RabbitMQ in real life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common use case for RabbitMQ is a single producer, single consumer
    queue. Think of it as a pipe where one application puts messages into one end
    of the pipe and another application reads the messages that come out the other
    end. Messages are delivered in first in, first out order. These messages may be
    commands or contain important data. This sounds easy, but where could this type
    of architecture be applied? It's time to understand when and why message queuing
    shines!
  prefs: []
  type: TYPE_NORMAL
- en: Message queues between microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Message queues are often used in between microservices, but what does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architectural style divides the application into small services,
    with the finished application being the sum of its microservices. The services
    are not strictly connected to each other. Instead, they use, for example, message
    queues to keep in touch. One service asynchronously pushes messages to a queue
    and those messages are delivered to the correct destination when the consumer
    is ready.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture is often compared and contrasted with the monolith
    architecture, where the entire system is bundled together into one piece of software.
    One application is not only responsible for a particular task; it actually performs
    every step needed to complete a particular function. Monoliths communicate within
    the system since all the parts are running in the same process. This system is
    highly coupled since every function is reliant on the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an example of a webshop built on a monolith architecture style, one system
    handles all of the functions, including inventory, payments, reviews, and ratings
    and so on, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b1c0208-cfbf-47aa-ae97-71be171caf27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.9: A webshop built in a monolith architecture style'
  prefs: []
  type: TYPE_NORMAL
- en: 'A webshop built on the microservice architecture, on the other hand, means
    that each part of the system is an individual activity. One microservice handles
    reviews and ratings. Then, there''s another inventory, and then yet another for
    payments, and so on, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f23a3835-2ccf-4bfe-836a-69137a57861f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.10: A microservice architecture style where each part is focused on a
    single business capability'
  prefs: []
  type: TYPE_NORMAL
- en: Each pair of requests and responses communicates independently. This is known
    as stateless communication. While many microservices are involved, they are not
    directly dependent on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Another typical use case for RabbitMQ is as a task queue, which we'll cover
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Event and tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Events are notifications that tell applications when something has happened.
    One application can subscribe to events from another application and respond by
    creating and handling tasks for themselves. A typical use case is when RabbitMQ
    acts as a task queue that handles **slow** operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at two examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a social media application such as Instagram. Every time someone publishes
    a new post, the network (followers) needs to be informed about the new post. This
    could be a very time-consuming operation. Millions of people could be trying to
    perform the same task at the same time. The application can, with the use of message
    queues, enqueue a task onto the queue for each post as it arrives. When the worker
    receives the request, it retrieves a list of followers for the sender, and updates
    each of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As another example, think of an email newsletter campaign tool that is sending
    out thousands of emails to thousands of users. With a possible scenario where
    many users trigger bulk messages at the same time. The email newsletter campaign
    tool needs to be able to handle this volume of messages. All these emails can
    be added to a push queue with instructions to the worker regarding what to send
    and to whom. Every single email is handled, one by one, until all the emails have
    been sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows a task queue, where messages are first entering
    the queue, and then handled. New tasks are then added to another queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/768cecf3-08a9-46c0-a5b5-d41491b3b207.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.11: Event and task queue'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've looked at and reviewed two typical use cases. The benefits
    of RabbitMQ have been apparent in each. We'll make this even more evident by exploring
    the benefits of message queuing in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the benefits of message queuing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Communication between various applications plays an important role in distributed
    systems. There are many examples of when a message queue can be used, so let''s
    highlight some features and benefits of message queuing in microservice architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development and maintenance made easier**: Dividing an application across
    multiple services allows separate responsibilities and gives developers the freedom
    to write code for a specific service in any chosen language. It will be easier
    to maintain written code and make changes to the system; when updating a single
    authentication scheme, only the authentication module must have code added for
    testing, without it disrupting any other functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault isolation**: A fault can be isolated to a single module and will thereby
    not affect other services. For example, an application with a reporting service
    temporarily out of function will not affect the authenticate or payment services.
    As another example, making changes to the reporting service still allows customers
    to perform essential transactions, even when they aren''t able to view reports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced levels of speed and productivity**:Different developers are able
    to work on different modules at the same time. In addition to speeding up the
    development cycle, the testing phase is also impacted by the use of microservices
    and message queues. This is because each service can be tested on its own to determine
    the readiness of the overall system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved scalability**: Microservices also allow for effortless scale-out
    at will. It''s possible to add more consumers if the message queue is growing.
    Adding new components to just one service is easy to do without changing any other
    service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand**: Since each module in a microservice architecture represents
    a single functionality, getting to know the relevant details for a task is easy.
    For example, hiring a consultant for a single service does not require them to
    understand the entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that is enough knowledge to be dangerous, so it is a good time to dive into
    the RabbitMQ scenario company that sets the scene for the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: A RabbitMQ scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CC is a new taxi agency with huge potential. Today, the company has just two
    taxi drivers and two developers, but they want to expand a lot in the upcoming
    year. CC has already built a website in Ruby and started out with a backend, also
    written in Ruby, that stores CC trips in a database. CC also has some scripts,
    written in Python, that generate route reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, CC''s system runs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The company's website and blog runs on Ruby.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rich Internet Application that stores route data, such as the starting point
    and the endpoint of the trip, is written in Ruby.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a back-office that sends route updates to drivers and is written in
    Ruby.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple ad hoc Python scripts are used to extract and message data to generate
    route reports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taxi applications are written in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The old architecture is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31b397de-241d-45ae-af51-4b191c803e71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.12: CC software landscape'
  prefs: []
  type: TYPE_NORMAL
- en: Why is CC looking at adding RabbitMQ to an already busy environment? The main
    reason is because of a new feature CC wants to offer to their customers – they
    want to build a taxi application that handles reservations on the go. CC also
    wants to be able to scale painlessly. The plan is to build an app where users
    can book a car via a smartphone, receive booking confirmation, and view the car
    approaching the starting point of the trip.
  prefs: []
  type: TYPE_NORMAL
- en: Since CC already has some services in different languages, and since CC wants
    to be able to scale easily, they decided to use a ready-made message-oriented
    middleware such as RabbitMQ for asynchronous communication between the app, the
    client, and the backend.
  prefs: []
  type: TYPE_NORMAL
- en: As CC's knowledge and usage of RabbitMQ increases, they will discover new opportunities
    to leverage it in the environment. For now, let's follow CC as it gets started
    with its very first step into working with RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready for RabbitMQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, the following three installation and configuration steps need
    to be completed:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the RabbitMQ broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the management plugin (Web UI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the vhost and user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by installing the broker!
  prefs: []
  type: TYPE_NORMAL
- en: Installing the broker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CC runs its production servers on Ubuntu Linux. One developer has macOS and
    Linux, while the other one is all Windows. This heterogeneity is not a concern
    for RabbitMQ, which can run natively on all these operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'RabbitMQ provides complete online installation guides for all the supported
    operating systems, and they can be found here: [http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html).
    This book contains instructions for Debian/Ubuntu, where RabbitMQ is installed
    from the `apt` repository. It also contains instructions for Docker further down
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ installation on Ubuntu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are relatively few steps required to install RabbitMQ. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Update Ubuntu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and install the repository key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the key is in the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install RabbitMQ from the package repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that Ubuntu is up to date before starting the download process. Make
    sure that the operating system is using the latest versions of all software since
    outdated dependencies create security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `apt update` command to download the latest releases of the installed
    software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'RabbitMQ requires several software packages. Verify that `curl`, `apt-transport-https`,
    and `GnuPG` are on the system by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `-y` option accepts any licenses for these dependencies. Ubuntu installs
    all required sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Discover the name of the operating system by running any of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cat /etc/os-release`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lsb_release -a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostnamectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The release name is non-technical. Previous names include `focal` and `bionic`.
    Ubuntu does not include RabbitMQ by default, so it must be added to the repository
    key before you proceed. Execute the following set of commands in a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These commands download the key and add it to the repository list before adding
    the appropriate operating system packages for the broker and Erlang.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ is written in Erlang, a functional language that has robust built-in
    support for creating distributed networks. The developers maintain a list of minimum
    versions ([https://www.rabbitmq.com/which-erlang.html](https://www.rabbitmq.com/which-erlang.html))
    of the language for the latest supported releases of the broker. At the time of
    writing, RabbitMQ 3.8 supports Erlang 21.3 through 23.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ can now be installed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Though not absolutely required for using RabbitMQ, it is encouraged to discover
    this powerful language and platform. You can learn more about Erlang at [http://www.erlang.org/](http://www.erlang.org/).
    Alternatively, you can consider Elixir as an optional language for the Erlang
    **virtual machine** (**VM**). You can find out more about this at [http://elixir-lang.org](http://elixir-lang.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to install RabbitMQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `librabbitmq-dev` library includes a client for interacting with the broker.
    However, the server may be the only requirement.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ installation on Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Docker containers allow the separation and control of resources without risking
    corrupting the operating system. Instructions for installing Docker are available
    from the official website: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    With Docker installed, pull the RabbitMQ image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the broker with reasonable defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A Docker container needs to be created so that it's accessible from the `localhost`
    with the management console enabled. This will be discovered shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Starting RabbitMQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing the RabbitMQ server from the repository also installs a suite of
    command-line tools used to start the server for the first time. This is done by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The server starts in the foreground. To run the broker as a service, use the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `systemctl` command can also be used to manage services in Ubuntu. The output
    of the final command should show that the broker is running. Consult the RabbitMQ
    documentation ([https://www.rabbitmq.com/troubleshooting.html](https://www.rabbitmq.com/troubleshooting.html))
    if not.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the example code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Download all the example code files for this book. They can be purchased from [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, visit [http://www.packtpub.com/support](http://www.packtpub.com/support) and
    register to have the files emailed to you directly.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the RabbitMQ broker is running
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, verify that the RabbitMQ broker is actually working by using the `status
    service` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following line in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The default folders where the package has installed files are `/etc/rabbitmq`
    for configuration files, `/usr/lib/rabbitmq` for application files, and `/var/lib/rabbitmq`
    for data files (`mnesia`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the running processes for RabbitMQ and find both the service wrapper
    and the Erlang VM (also known as BEAM) that''s running, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is possible that, when RabbitMQ runs, a process named `epmd` is also running.
    This is the Erlang port mapper daemon, which is in charge of coordinating Erlang
    nodes in a cluster. It is expected to start even if the clustered RabbitMQ application
    is not running.
  prefs: []
  type: TYPE_NORMAL
- en: Note that by default, the broker service is configured to auto-start when the
    Linux host starts.
  prefs: []
  type: TYPE_NORMAL
- en: Skip the hassle of the installation and configuration of RabbitMQ and use a
    hosted RabbitMQ solution. CloudAMQP is the largest provider of hosted RabbitMQ
    clusters: [www.cloudamqp.com](https://www.cloudamqp.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the management plugin (Web UI)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RabbitMQ does not install a management console by default, but the optional
    web-based plugin used in this example makes it easy to peek into a running RabbitMQ
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Debian package installs several scripts. One of them is `rabbitmq-plugins`.
    Its purpose is to allow us to install and remove plugins. Use it to install the
    management plugin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it is that easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a web browser to reach the home page of the management console by navigating
    to `http://<hostname>:15672`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/280d4407-ed0a-4bf6-9167-f1215438efe7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.13: The login screen of the management console'
  prefs: []
  type: TYPE_NORMAL
- en: Stay tuned for the next episode – creating and configuring users!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the scripts that''s installed by the Debian package is `rabbitmqctl`,
    which is a tool for managing RabbitMQ nodes and used to configure all aspects
    of the broker. Use it to configure an administration user in the broker, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, RabbitMQ comes with a guest user that''s authenticated with the
    guest password. Change this password to something else, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Navigating back to the management console login screen allows us to log in with
    the username `cc-admin` and the password `taxi123`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The welcome screen provides an overview of the broker''s internals, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee346036-1498-4c86-83e8-dbb9b3627f28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.14: The main dashboard of the management console'
  prefs: []
  type: TYPE_NORMAL
- en: Note that at this point, the `cc-admin` user is not able to examine any exchange
    or queue in any vhost. For now, another user must be created for development purposes
    so that applications can connect to RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `cc-dev` user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As discussed earlier in this chapter, RabbitMQ supports the notion of vhosts,
    which is where different users can have different access privileges. The CC development
    environment will have a vhost, also known as vhost. Anything that happens in the
    vhost happens in isolation from any other environment created in the future (such
    as a QA environment). It is possible to set per-vhost limits on a number of queues
    and concurrent client connections in later versions of RabbitMQ (3.7+).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a vhost called `cc-dev-vhost`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This creates a user and a vhost for development.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dedicated vhosts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RabbitMQ comes with a default vhost called `/` that the guest user has full
    permissions for. Though this is convenient for quick tests, it is recommended
    that a dedicated vhost is created to keep concerns separated so that it is possible
    to completely drop a vhost and restart from scratch without unexpected impacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it stands, neither the `cc-admin` nor `cc-dev` users have permission to
    do anything on `cc-dev-vhost`. You can fix this by giving the vhost full rights,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To recap what was just done, most of the command is straightforward but the
    `".*" ".*" ".*"` part looks a tad mysterious, so let's analyze it.
  prefs: []
  type: TYPE_NORMAL
- en: It is a triplet of permissions for the considered vhost, which grants **configure**,
    **write**, and **read** permissions on the designated resources for the considered
    user and vhost. Resources, which consist of exchanges and queues, are designated
    by regular expressions that match their names. In this case, any resource that's
    requested via the `.*` regular expression is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The actual commands that are granted depend on the resource type and the granted
    permissions. For a complete list of the access control policies supported by RabbitMQ,
    see [http://www.rabbitmq.com/access-control.html](http://www.rabbitmq.com/access-control.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to all command lines, turn to the user management features
    of the management console. Click on the Admin tab of the console and then on the
    `cc-dev` user listed in the Users tab to view information similar to what''s shown
    in the following screenshot. The entire user configuration that was set from the
    command line is visible and can be edited in the management console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d898f837-ce12-420c-9644-f4af2a4d27e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.15: User management from the RabbitMQ management console'
  prefs: []
  type: TYPE_NORMAL
- en: 'The details of an individual user can be found by clicking on a given user''s
    name in the management console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75629c10-48d3-4fc3-b069-7cabe27614fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 1.16: Details of an individual user in the management console'
  prefs: []
  type: TYPE_NORMAL
- en: The RabbitMQ broker and the management plugin (Web UI) have been installed and
    the vhost and the users have been configured.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the architectural and design promises of messaging, including
    how AMQP and RabbitMQ deliver on these promises. In addition, the reason why the
    taxi agency Complete Car decided to introduce RabbitMQ in its software landscape
    was discovered. Finally, a RabbitMQ broker was installed and a user and various
    vhosts were configured for it. Armed with a basic understanding of message queues
    and RabbitMQ, the next chapter builds on these concepts and explores the architecture
    behind the Complete Car taxi application.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to hit the ground running and write some code. Turn to the next chapter
    to start building a RabbitMQ-powered application!
  prefs: []
  type: TYPE_NORMAL
