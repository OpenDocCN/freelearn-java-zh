- en: '*Chapter 6*: Data Structures, Generics, and Popular Utilities'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents the Java collections framework and its three main interfaces,
    `List`, `Set`, and `Map`, including a discussion and demonstration of generics.
    The `equals()` and `hashCode()` methods are also discussed in the context of Java
    collections. Utility classes for managing arrays, objects, and time/date values
    have corresponding dedicated sections too. After studying this chapter, you will
    be able to use all the main data structures in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List`, `Set`, and `Map` interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collections` utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Arrays` utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object` utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `java.time` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java **Standard Edition** (**SE**) version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **integrated development environment** (**IDE**) or your preferred code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions on how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015) of this book, *Getting
    Started with Java 17*. The files with code examples for this chapter are available
    on GitHub in the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository, in the `examples/src/main/java/com/packt/learnjava/ch06_collections`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: List, Set, and Map interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `short`, `int`, or `double`. If you need to store such type values, the
    elements must be of a corresponding wrapper type, such as `Short`, `Integer`,
    or `Double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java collections support various algorithms for storing and accessing elements
    of a collection: an ordered list, a unique set, a dictionary (called a `java.util`
    package of the `java.util` package contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces that extend the `Collection` interface: `List`, `Set`, and `Queue`,
    to name the most popular ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classes that implement the previously listed interfaces: `ArrayList`, `HashSet`,
    `Stack`, `LinkedList`, and some others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Map` interface and its `ConcurrentMap` and `SortedMap` sub-interfaces,
    to name a couple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classes that implement `Map`-related interfaces: `HashMap`, `HashTable`, and
    `TreeMap`, to name the three most frequently used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing all the classes and interfaces of the `java.util` package would require
    a dedicated book. So, in this section, we will just have a brief overview of the
    three main interfaces—`List`, `Set`, and `Map`—and one implementation class for
    each of them—`ArrayList`, `HashSet`, and `HashMap`. We start with methods that
    are shared by the `List` and `Set` interfaces. The principal difference between
    `List` and `Set` is that `Set` does not allow the duplication of elements. Another
    difference is that `List` preserves the order of elements and also allows them
    to be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: To identify an element inside a collection, the `equals()` method is used. To
    improve performance, classes that implement the `Set` interface often use the
    `hashCode()` method too. This facilitates rapid calculation of an integer (called
    a `equals()` method) with each of the elements with the same hash value. Such
    a procedure is faster than comparing a new element with each element of the set
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: That is why we often see that the name of a class has a `hash` prefix, indicating
    that the class uses a hash value, so the element must implement the `hashCode()`
    method. While doing this, you must make sure that it is implemented so that every
    time the `equals()` method returns `true` for two objects, the hash values of
    these two objects returned by the `hashCode()` method are equal too. Otherwise,
    the just-described algorithm of using the hash value will not work.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, before talking about `java.util` interfaces, a few words about
    generics.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can see these most often in declarations such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding examples, `<>`) called a **diamond**, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Generics inform the compiler about the expected type of collection elements.
    This way, the compiler can check whether an element a programmer tries to add
    to a declared collection is of a compatible type. Observe the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This helps to avoid runtime errors. It also tips off the programmer (because
    an IDE compiles the code when a programmer writes it) about possible manipulations
    of collection elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also see these other types of generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<? extends T>` means *a type that is either* `T` *or a child of* `T`, where
    `T` is the type used as the generics of a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<? super T>` means *a type* `T` *or any of its base (parent) class*, where
    `T` is the type used as the generics of a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that, let’s start with how an object of a class that implements the `List`
    or `Set` interface can be created—or, in other words, the `List` or `Set` type
    of variable can be initialized. To demonstrate the methods of these two interfaces,
    we will use two classes: `ArrayList` (implements `List`) and `HashSet` (implements
    `Set`).'
  prefs: []
  type: TYPE_NORMAL
- en: How to initialize List and Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Java 9, the `List` or `Set` interfaces have static `of()` factory methods
    that can be used to initialize a collection, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`of()`: Returns an empty collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of(E... e)`: Returns a collection with as many elements as are passed in during
    the call. They can be passed in a comma-separated list or as an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, the factory method for `Set` does not allow duplicates,
    so we have commented the line out (otherwise, the preceding example would stop
    running at that line). What is less expected is that you cannot have a `null`
    element, and you cannot add/remove/modify elements of a collection after it was
    initialized using one of the `of()` methods. That’s why we have commented out
    some lines of the preceding example. If you need to add elements after a collection
    is initialized, you have to initialize it using a constructor or some other utilities
    that create a modifiable collection (we will see an example of `Arrays.asList()`
    shortly).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Collection` interface provides two methods for adding elements to an object
    that implements `Collection` (the parent interface of `List` and `Set`) that look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean add(E e)`: This attempts to add the provided element `e` to the collection;
    it returns `true` in case of success, and `false` in case of not being able to
    accomplish it (for example, when such an element already exists in the `Set` interface).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean addAll(Collection<? extends E> c)`: This attempts to add all of the
    elements in the provided collection to the collection; it returns `true` if at
    least one element was added, and `false` in case of not being able to add an element
    to the collection (for example, when all elements of the provided collection `c`
    already exist in the `Set` interface).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of using the `add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an example of using the `addAll()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the `add()` and `addAll()` methods’ functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how, in the last example in the preceding code snippet, the `set1.addAll(set2)`
    method returns `true`, although not all elements were added. To see the case of
    the `add()` and `addAll()` methods returning `false`, look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ArrayList` and `HashSet` classes also have constructors that accept a
    collection, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Now, after we have learned how a collection can be initialized, we can turn
    to other methods in the `List` and `Set` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: java.lang.Iterable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Collection` interface extends the `java.lang.Iterable` interface, which
    means that classes that implement the `Collection` interface—directly or not—also
    implement the `java.lang.Iterable` interface. There are only three methods in
    the `Iterable` interface, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Iterator<T> iterator()`: This returns an object of a class that implements
    the `java.util.Iterator` interface; it allows the collection to be used in `FOR`
    statements, as in this example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`default void forEach (Consumer<? super T> function)`: This applies the provided
    function of the `Consumer` type to each element of the collection until all elements
    have been processed or the function throws an exception. We will discuss what
    a function is in [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional
    Programming*; for now, we will just provide an example here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`default Spliterator<T> splititerator()`: This returns an object of a class
    that implements the `java.util.Spliterator` interface; it is used primarily for
    implementing methods that allow parallel processing and is outside the scope of
    this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have mentioned already, the `List` and `Set` interfaces extend the `Collection`
    interface, which means that all methods of the `Collection` interface are inherited
    by `List` and `Set`. These methods are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean add(E e)`: This attempts to add an element to the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean addAll(Collection<? extends E> c)`: This attempts to add all elements
    in the collection provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean equals(Object o)`: This compares the collection with the `o` object
    provided. If the object provided is not a collection, this object returns `false`;
    otherwise, it compares the composition of the collection with the composition
    of the collection provided (as an `o` object). In the case of `List`, it also
    compares the order of elements. Let’s illustrate this with a few examples, as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`int hashCode()`: This returns the hash value for the collection; it is used
    in the case where the collection is an element of a collection that requires the
    `hashCode()` method implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isEmpty()`: This returns `true` if the collection does not have any
    elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int size()`: This returns the count of elements of the collection; when the
    `isEmpty()` method returns `true`, this method returns `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void clear()`: This removes all elements from the collection; after this method
    is called, the `isEmpty()` method returns `true`, and the `size()` method returns
    `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean contains(Object o)`: This returns `true` if the collection contains
    the provided `o` object. For this method to work correctly, each element of the
    collection and the provided object must implement the `equals()` method, and,
    in the case of `Set`, the `hashCode()` method should be implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean containsAll(Collection<?> c)`: This returns `true` if the collection
    contains all elements in the collection provided. For this method to work correctly,
    each element of the collection and each element of the collection provided must
    implement the `equals()` method, and, in the case of `Set`, the `hashCode()` method
    should be implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean remove(Object o)`: This attempts to remove the specified element from
    this collection and returns `true` if it was present. For this method to work
    correctly, each element of the collection and the object provided must implement
    the `equals()` method, and, in the case of `Set`, the `hashCode()` method should
    be implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean removeAll(Collection<?> c)`: This attempts to remove from the collection
    all elements of the collection provided; similar to the `addAll()` method, this
    method returns `true` if at least one of the elements was removed; otherwise,
    it returns `false`. For this method to work correctly, each element of the collection
    and each element of the collection provided must implement the `equals()` method,
    and, in the case of `Set`, the `hashCode()` method should be implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default boolean removeIf(Predicate<? super E> filter)`: This attempts to remove
    from the collection all elements that satisfy the given predicate; it is a function
    we are going to describe in [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281),
    *Functional Programming*. It returns `true` if at least one element was removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean retainAll(Collection<?> c)`: This attempts to retain in the collection
    just the elements contained in the collection provided. Similar to the `addAll()`
    method, this method returns `true` if at least one of the elements is retained;
    otherwise, it returns `false`. For this method to work correctly, each element
    of the collection and each element of the collection provided must implement the
    `equals()` method, and, in the case of `Set`, the `hashCode()` method should be
    implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object[] toArray()`, `T[] toArray(T[] a)`: This converts the collection to
    an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default T[] toArray(IntFunction<T[]> generator)`: This converts the collection
    to an array, using the function provided. We are going to explain functions in
    [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional Programming*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Stream<E> stream()`: This returns a `Stream` object (we talk about
    streams in [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296), *Java Standard
    Streams*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Stream<E> parallelStream()`: This returns a possibly parallel `Stream`
    object (we talk about streams in [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `List` interface has several other methods that do not belong to any of
    its parent interfaces, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Static factory `of()` methods, described in the *How to initialize List and
    Set* subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void add(int index, E element)`: This inserts the element provided at the
    provided position in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static List<E> copyOf(Collection<E> coll)`: This returns an unmodifiable `List`
    interface containing the elements of the given `Collection` interface and preserves
    their order. The following code snippet demonstrates the functionality of this
    method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`E get(int index)`: This returns the element located at the position specified
    in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List<E> subList(int fromIndex, int toIndex)`: Extracts a sublist between `fromIndex`
    (inclusive) and `toIndex` (exclusive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int indexOf(Object o)`: This returns the first index (position) of a specified
    element in the list; the first element in the list has an index (position) of
    `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int lastIndexOf(Object o)`: This returns the last index (position) of a specified
    element in the list; the final element in the list has a `list.size() - 1` index
    position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E remove(int index)`: This removes the element located at a specified position
    in the list; it returns the element removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`E set(int index, E element)`: This replaces the element located at a position
    specified in the list; it returns the element replaced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default void replaceAll(UnaryOperator<E> operator)`: This transforms the list
    by applying the function provided to each element. The `UnaryOperator` function
    will be described in [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional
    Programming*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListIterator<E> listIterator()`: Returns a `ListIterator` object that allows
    the list to be traversed backward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListIterator<E> listIterator(int index)`: Returns a `ListIterator` object
    that allows the sublist (starting from the provided position) to be traversed
    backward. Observe the following, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`default void sort(Comparator<? super E> c)`: This sorts the list according
    to the order generated by the `Comparator` interface provided. Observe the following,
    for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are principally two ways to sort a list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a `Comparable` interface implementation (called **natural order**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `Comparator` interface implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Comparable` interface only has a `compareTo()` method. In the preceding
    example, we have implemented the `Comparator` interface basing it on the `Comparable`
    interface implementation in the `String` class. As you can see, this implementation
    provided the same sort order as `Comparator.nullsFirst(Comparator.naturalOrder())`.
    This style of implementation is called **functional programming**, which we will
    discuss in more detail in [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281),
    *Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Set interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Set` interface has the following methods that do not belong to any of
    its parent interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Static `of()` factory methods, described in the *How to initialize List and
    Set* subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `static Set<E> copyOf(Collection<E> coll)` method: This returns an unmodifiable
    `Set` interface containing elements of the given `Collection`; it works the same
    way as the `static <E> List<E> copyOf(Collection<E> coll)` method described in
    the *List interface* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Map` interface has many methods similar to the `List` and `Set` methods,
    as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int size()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void clear()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int hashCode()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean isEmpty()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean equals(Object o)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default void forEach(BiConsumer<K,V> action)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static factory methods: `of()`, `of(K, V v)`, `of(K k1, V v1, K k2, V v2)`,
    and many other methods besides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Map` interface, however, does not extend `Iterable`, `Collection`, or any
    other interface, for that matter. It is designed to be able to store `Entry`,
    which is an internal interface of `Map`. Both `value` and `key` objects must implement
    the `equals()` method. A `key` object must also implement the `hashCode()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many methods of the `Map` interface have exactly the same signature and functionality
    as in the `List` and `Set` interfaces, so we are not going to repeat them here.
    We will only walk through the `Map`-specific methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V get(Object key)`: This retrieves the value according to the key provided;
    it returns `null` if there is no such key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set<K> keySet()`: This retrieves all keys from the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<V> values()`: This retrieves all values from the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean containsKey(Object key)`: This returns `true` if the key provided
    exists in the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean containsValue(Object value)`: This returns `true` if the value provided
    exists in the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V put(K key, V value)`: This adds the value and its key to the map; it returns
    the previous value stored with the same key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void putAll(Map<K,V> m)`: This copies from the map provided all the key-value
    pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default V putIfAbsent(K key, V value)`: This stores the value provided and
    maps to the key provided if such a key is not already used by the map. It returns
    the value mapped to the key provided—either an existing or a new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V remove(Object key)`: This removes both the key and value from the map; it
    returns a value or `null` if there is no such key, or if the value is `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default boolean remove(Object key, Object value)`: This removes the key-value
    pair from the map if such a pair exists in the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default V replace(K key, V value)`: This replaces the value if the key provided
    is currently mapped to the value provided. It returns the old value if it was
    replaced; otherwise, it returns `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default boolean replace(K key, V oldValue, V newValue)`: This replaces the
    `oldValue` value with the `newValue` value provided if the key provided is currently
    mapped to the `oldValue` value. It returns `true` if the `oldValue` value was
    replaced; otherwise, it returns `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default void replaceAll(BiFunction<K,V,V> function)`: This applies the function
    provided to each key-value pair in the map and replaces it with the result, or
    throws an exception if this is not possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set<Map.Entry<K,V>> entrySet()`: This returns a set of all key-value pairs
    as objects of `Map.Entry`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default V getOrDefault(Object key, V defaultValue)`: This returns the value
    mapped to the key provided or the `defaultValue` value if the map does not have
    the key provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static Map.Entry<K,V> entry(K key, V value)`: This returns an unmodifiable
    `Map.Entry` object with the `key` object and `value` object provided in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static Map<K,V> copy(Map<K,V> map):` This converts the `Map` interface provided
    to an unmodifiable one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following `Map` methods are much too complicated for the scope of this
    book, so we are just mentioning them for the sake of completeness. They allow
    multiple values to be combined or calculated and aggregated in a single existing
    value in the `Map` interface, or a new one to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default V merge(K key, V value, BiFunction<V,V,V> remappingFunction)`: If
    the provided key-value pair exists and the value is not `null`, the provided function
    is used to calculate a new value; it removes the key-value pair if the newly calculated
    value is `null`. If the key-value pair provided does not exist or the value is
    `null`, the non-`null` value provided replaces the current one. This method can
    be used for aggregating several values; for example, it can be used for concatenating
    the following string values: `map.merge(key, value, String::concat)`. We will
    explain what `String::concat` means in [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281),
    *Functional Programming.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default V compute(K key, BiFunction<K,V,V> remappingFunction)`: This computes
    a new value using the function provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default V computeIfAbsent(K key, Function<K,V> mappingFunction)`: This computes
    a new value using the function provided only if the provided key is not already
    associated with a value, or the value is `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default V computeIfPresent(K key, BiFunction<K,V,V> remappingFunction)`: This
    computes a new value using the function provided only if the provided key is already
    associated with a value and the value is not `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This last group of *computing* and *merging* methods is rarely used. The most
    popular, by far, are the `V put(K key, V value)` and `V get(Object key)` methods,
    which allow the use of the main `Map` function of storing key-value pairs and
    retrieving the value using the key. The `Set<K> keySet()` method is often used
    for iterating over the map’s key-value pairs, although the `entrySet()` method
    seems a more natural way of doing that. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The first of the `for` loops in the preceding code example uses a more widespread
    way to access the key-pair values of a map by iterating over the keys. The second
    `for` loop iterates over the set of entries, which (in our opinion) is a more
    natural way to do it. Notice that the printed-out values are not in the same order
    we have put them in the map. That is because, since Java 9, unmodifiable collections
    (that is, what `of()` factory methods produce) have added randomization to the
    order of `Set` elements, which changes the order of elements between different
    code executions. Such a design was done to make sure a programmer does not rely
    on a certain order of `Set` elements, which is not guaranteed for a set.
  prefs: []
  type: TYPE_NORMAL
- en: Unmodifiable collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please note that collections produced by `of()` factory methods used to be
    called `Person1` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, for simplicity, we will create a list with one
    element only and will then try to modify the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, although it is not possible to add an element to the list created
    by the `of()` factory method, its element can still be modified if a reference
    to the element exists outside the list.
  prefs: []
  type: TYPE_NORMAL
- en: Collections utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two classes with static methods handling collections that are very
    popular and helpful, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.Collections`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.commons.collections4.CollectionUtils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that the methods are static means they do not depend on the object
    state, so they are also called **stateless methods** or **utility methods**.
  prefs: []
  type: TYPE_NORMAL
- en: java.util.Collections class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many methods in the `Collections` class manage collections and analyze, sort,
    and compare them. There are more than 70 of them, so we won’t have a chance to
    talk about all of them. Instead, we are going to look at the ones most often used
    by mainstream application developers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static copy(List<T> dest, List<T> src)`: This copies elements of the `src`
    list to the `dest` list and preserves the order of elements and their position
    in the list. The `dest` list size has to be equal to, or bigger than, the `src`
    list size, otherwise a runtime exception is raised. Here is an example of this
    method’s usage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`static void sort(List<T> list)`: This sorts the list in order according to
    the `compareTo(T)` method implemented by each element (called `Comparable` interface
    (which requires implementation of the `compareTo(T)` method). In the example that
    follows, we use `List<String>` because the `String` class implements `Comparable`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we could not use the `List.of()` method to create a list because
    the list would be unmodifiable and its order could not be changed. Also, look
    at the resulting order: numbers come first, then capital letters, followed by
    lowercase letters. That is because the `compareTo()` method in the `String` class
    uses code points of the characters to establish the order. Here is the code that
    demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the order is defined by the value of the code points of the
    characters that compose the string.
  prefs: []
  type: TYPE_NORMAL
- en: '`static void sort(List<T> list, Comparator<T> comparator)`: This sorts the
    order of the list according to the `Comparator` object provided, irrespective
    of whether the list elements implement the `Comparable` interface or not. As an
    example, let’s sort a list that consists of objects in the `Person` class, as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And here is the `Comparator` class to sort the list of `Person` objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the `Person` and `ComparePersons` classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: As we have mentioned already, there are many more utilities in the `Collections`
    class, so we recommend you look through the related documentation at least once
    and understand all its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: CollectionUtils class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `org.apache.commons.collections4.CollectionUtils` class in the *Apache Commons*
    project contains static stateless methods that complement the methods of the `java.util.Collections`
    class. They help to search, process, and compare Java collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this class, you would need to add the following dependency to the Maven
    `pom.xml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many methods in this class, and more methods will probably be added
    over time. These utilities are created in addition to `Collections` methods, so
    they are more complex and nuanced and do not fit the scope of this book. To give
    you an idea of the methods available in the `CollectionUtils` class, here is a
    brief description of the methods, grouped according to their functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods that retrieve an element from a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that add an element or a group of elements to a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that merge `Iterable` elements into a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that remove or retain elements with or without criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that compare two collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that transform a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that select from, and filter, a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that generate the union, intersection, or difference of two collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that create an immutable empty collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that check collection size and emptiness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method that reverses an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last method should probably belong to the utility class that handles arrays,
    and that is what we are going to discuss now.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two classes with static methods handling collections that are very
    popular and helpful, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.Arrays`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.commons.lang3.ArrayUtils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will briefly review each of them.
  prefs: []
  type: TYPE_NORMAL
- en: java.util.Arrays class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already used the `java.util.Arrays` class several times. It is the
    primary utility class for array management. This utility class used to be very
    popular because of the `asList(T...a)` method. It was the most compact way of
    creating and initializing a collection and is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: It is still a popular way of creating a modifiable list—we used it, too. However,
    after a `List.of()` factory method was introduced, the `Arrays` class declined
    substantially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, if you need to manage arrays, then the `Arrays` class may be
    a big help. It contains more than 160 methods, and most of them are overloaded
    with different parameters and array types. If we group them by the method name,
    there will be 21 groups, and if we further group them by functionality, only the
    following 10 groups will cover all the `Arrays` class functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asList()`: This creates an `ArrayList` object based on the provided array
    or comma-separated list of parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binarySearch()`: This searches an array or only a specified part of it (according
    to the range of indices).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compare()`, `mismatch()`, `equals()`, and `deepEquals()`: These compare two
    arrays or their elements (according to the range of indices).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copyOf()` and `copyOfRange()`: This copies all arrays or only a specified
    (according to the range of indices) part of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashcode()` and `deepHashCode()`: This generates a hash code value based on
    the array provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()` and `deepToString()`: This creates a `String` representation of
    an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill()`, `setAll()`, `parallelPrefix()`, and `parallelSetAll()`: This sets
    a value (fixed or generated by the function provided) for every element of an
    array or those specified according to a range of indices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort()` and `parallelSort()`: This sorts elements of an array or only part
    of it (specified according to a range of indices).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splititerator()`: This returns a `Splititerator` object for parallel processing
    of an array or part of it (specified according to a range of indices).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream()`: This generates a stream of array elements or some of them (specified
    according to a range of indices); see [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams**.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these methods are helpful, but we would like to draw your attention
    to the `equals(a1, a2)` and `deepEquals(a1, a2)` methods. They are particularly
    helpful for array comparison because an `array` object cannot implement an `equals()`
    custom method and uses the implementation of the `Object` class instead (which
    compares only references). The `equals(a1,` `a2)` and `deepEquals(a1, a2)` methods
    allow a comparison of not just `a1` and `a2` references, but use the `equals()`
    method to compare elements as well. Here is a code example to demonstrate how
    these methods work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `Arrays.deepEquals()` returns `true` every time two equal arrays
    are compared when every element of one array equals the element of another array
    in the same position, while the `Arrays.equals()` method does the same, but for
    **one-dimensional** (**1D**) arrays only.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayUtils class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `org.apache.commons.lang3.ArrayUtils` class complements the `java.util.Arrays`
    class by adding new methods to the array managing the toolkit and the ability
    to handle `null` in cases when, otherwise, `NullPointerException` could be thrown.
    To use this class, you would need to add the following dependency to the Maven
    `pom.xml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ArrayUtils` class has around 300 overloaded methods that can be collected
    in the following 12 groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add()`, `addAll()`, and `insert()`: These add elements to an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone()`: This clones an array, similar to the `copyOf()` method of the `Arrays`
    class and the `arraycopy()` method of `java.lang.System.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getLength()`: This returns an array length or `0` when the array itself is
    `null.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashCode()`: This calculates the hash value of an array, including nested
    arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains()`, `indexOf()`, and `lastIndexOf()`: These search an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isSorted()`, `isEmpty`, and `isNotEmpty()`: These check an array and handle
    `null.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isSameLength()` and `isSameType()`: These compare arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullToEmpty()`: This converts a `null` array to an empty one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()`, `removeAll()`, `removeElement()`, `removeElements()`, and `removeAllOccurances()`:
    These remove certain or all elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reverse()`, `shift()`, `shuffle()`, and `swap()`: These change the order of
    array elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subarray()`: This extracts part of an array according to a range of indices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toMap()`, `toObject()`, `toPrimitive()`, `toString()`, and `toStringArray()`:
    These convert an array to another type and handle `null` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following two utilities are described in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.Objects`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.apache.commons.lang3.ObjectUtils`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are especially useful during class creation, so we will concentrate largely
    on methods related to this task.
  prefs: []
  type: TYPE_NORMAL
- en: java.util.Objects class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Objects` class has only 17 methods that are all static. Let’s look at
    some of them while applying them to the `Person` class. Let’s assume this class
    will be an element of a collection, which means it has to implement the `equals()`
    and `hashCode()` methods. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we do not check the `name` property for `null` because `Object.equals()`
    does not break when any of the parameters is `null`. It just does the job of comparing
    objects. If only one of them is `null`, it returns `false`. If both are `null`,
    it returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `Object.equals()` is a safe way to implement the `equals()` method; however,
    if you need to compare objects that may be arrays, it is better to use the `Objects.deepEquals()`
    method because it not only handles `null`, as the `Object.equals()` method does,
    but also compares values of all array elements, even if the array is multidimensional,
    as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: The `Objects.hash()` method handles `null` values too. One important thing to
    remember is that the list of properties compared in the `equals()` method has
    to match the list of properties passed into `Objects.hash()` as parameters. Otherwise,
    two equal `Person` objects will have different hash values, which makes hash-based
    collections work incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing worth noticing is that there is another hash-related `Objects.hashCode()`
    method that accepts only one parameter, but the value it generates is not equal
    to the value generated by `Objects.hash()` with only one parameter. Observe the
    following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: To avoid this caveat, always use `Objects.hash()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another potential source of confusion is demonstrated in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Objects.hashCode()` method generates the same hash value
    for `null` and `0`, which can be problematic for some algorithms based on the
    hash value.
  prefs: []
  type: TYPE_NORMAL
- en: '`static <T> int compare (T a, T b, Comparator<T> c)` is another popular method
    that returns `0` (if the arguments are equal); otherwise, it returns the result
    of `c.compare(a, b)`. It is very useful for implementing the `Comparable` interface
    (establishing a natural order for custom object sorting). Observe the following,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can easily change the sorting algorithm by setting the `Comparator.reverseOrder()`
    value or by adding `Comparator.nullFirst()` or `Comparator.nullLast()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the `Comparator` implementation we used in the previous section can be
    made more flexible by using the `Objects.compare()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last two methods of the `Objects` class that we are going to discuss
    are methods that generate a string representation of an object. They come in handy
    when you need to call a `toString()` method on an object but are not sure whether
    the object reference is `null`. Observe the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we know the exact value of each element; however,
    imagine a scenario where the list is passed into the method as a parameter. Then,
    we are forced to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn’t seem to be a big deal. But after writing such code a dozen times,
    a programmer naturally thinks about some kind of utility method that does all
    of that, and that is when the following two methods of the `Objects` class help:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static String toString(Object o)`: This returns the result of calling `toString()`
    on the parameter when it is not `null` and returns `null` when the parameter value
    is `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static String toString(Object o, String nullDefault)`: This returns the result
    of calling `toString()` on the first parameter when it is not `null` and returns
    the second `nullDefault` parameter value when the first parameter value is `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: As of the time of writing, the `Objects` class has 17 methods. We recommend
    you become familiar with them so as to avoid writing your own utilities in the
    event that the same utility already exists.
  prefs: []
  type: TYPE_NORMAL
- en: ObjectUtils class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last statement of the previous section applies to the `org.apache.commons.lang3.ObjectUtils`
    class of the `Apache Commons` library that complements the methods of the `java.util.Objects`
    class described in the preceding section. The scope of this book and its allotted
    size does not allow for a detailed review of all the methods under the `ObjectUtils`
    class, so we will describe them briefly in groups according to their related functionality.
    To use this class, you would need to add the following dependency to the Maven
    `pom.xml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'All the methods of the `ObjectUtils` class can be organized into seven groups,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Object cloning methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that support a comparison of two objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `notEqual()` method, which compares two objects for inequality, where either
    one or both objects may be `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several `identityToString()` methods that generate a `String` representation
    of the provided object as if produced by `toString()`, which is a default method
    of the `Object` base class and, optionally, append it to another object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `allNotNull()` and `anyNotNull()` methods, which analyze an array of objects
    for `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `firstNonNull()` and `defaultIfNull()` methods, which analyze an array of
    objects and return the first not-`null` object or default value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `max()`, `min()`, `median()`, and `mode()` methods, which analyze an array
    of objects and return the one that corresponds to the method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The java.time package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many classes in the `java.time` package and its sub-packages. They
    were introduced as a replacement for other (older packages) that handled date
    and time. The new classes are thread-safe (hence, better suited for multithreaded
    processing), and what is also important is that they are more consistently designed
    and easier to understand. Also, the new implementation follows **International
    Organization for Standardization** (**ISO**) standards as regards date and time
    formats, but allows any other custom format to be used as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will describe the following five main classes and demonstrate how to use
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.time.LocalDate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.LocalTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.LocalDateTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.Period`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.time.Duration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these and other classes of the `java.time` package, as well as its sub-packages,
    are rich in various functionality that covers all practical cases. But we are
    not going to discuss all of them; we will just introduce the basics and the most
    popular use cases.
  prefs: []
  type: TYPE_NORMAL
- en: LocalDate class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LocalDate` class does not carry time. It represents a date in *ISO 8601*
    format (`yyyy-MM-dd`) and is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'That is the current date in this location at the time of writing. The value
    was picked up from the computer clock. Similarly, you can get the current date
    in any other time zone using that static `now(ZoneId zone)` method. A `ZoneId`
    object can be constructed using the static `ZoneId.of(String zoneId)` method,
    where `String zoneId` is any of the string values returned by the `ZoneId.getAvailableZoneIds()`
    method, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code prints almost 600 time zone **identifiers** (**IDs**). Here
    are a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try to use `"Asia/Tokyo"`, for example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'A `LocalDate` object can represent any date in the past, or in the future too,
    using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalDate parse(CharSequence text)`: This constructs an object from a string
    in *ISO 8601* format (`yyyy-MM-dd`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate parse(CharSequence text, DateTimeFormatter formatter)`: This constructs
    an object from a string in a format specified by the `DateTimeFormatter` object
    that has a rich system of patterns and many predefined formats as well—here are
    a few of them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BASIC_ISO_DATE`—for example, `20111203`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISO_LOCAL_DATE ISO`—for example, `2011-12-03`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISO_OFFSET_DATE`—for example, `2011-12-03+01:00`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISO_DATE`—for example, `2011-12-03+01:00; 2011-12-03`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISO_LOCAL_TIME`—for example, `10:15:30`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISO_OFFSET_TIME`—for example, `10:15:30+01:00`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISO_TIME`—for example, `10:15:30+01:00; 10:15:30`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ISO_LOCAL_DATE_TIME`—for example, `2011-12-03T10:15:30`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate of(int year, int month, int dayOfMonth)`: This constructs an object
    from a year, month, and day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate of(int year, Month, int dayOfMonth)`: This constructs an object
    from a year, month (enum constant), and day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate ofYearDay(int year, int dayOfYear)`: This constructs an object from
    a year and day-of-year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates the methods listed in the preceding
    bullets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'A `LocalDate` object can provide various values, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'A `LocalDate` object can be modified, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'A `LocalDate` object can be compared, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: There are many other helpful methods in the `LocalDate` class. If you have to
    work with dates, we recommend that you read the `java.time` package and its sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: LocalTime class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LocalTime` class contains time without a date. It has similar methods
    to the methods of the `LocalDate` class. Here is how an object of the `LocalTime`
    class can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'Each component of time value can be extracted from a `LocalTime` object, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'An object of the `LocalTime` class can be modified, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'And two objects of the `LocalTime` class can also be compared, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: There are many other helpful methods in the `LocalTime` class. If you have to
    work with dates, we recommend that you read the API of this class and other classes
    of the `java.time` package and its sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: LocalDateTime class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LocalDateTime` class contains both the date and time and has all the methods
    the `LocalDate` and `LocalTime` classes have, so we are not going to repeat them
    here. We will only show how an object of the `LocalDateTime` class can be created,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: There are many other helpful methods in the `LocalDateTime` class. If you have
    to work with dates, we recommend that you read the API of this class and other
    classes of the `java.time` package and its sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: Period and Duration classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.time.Period` and `java.time.Duration` classes are designed to contain
    an amount of time, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Period` object contains an amount of time in units of years, months, and
    days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Duration` object contains an amount of time in hours, minutes, seconds, and
    nanoseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates their creation and usage using the
    `LocalDateTime` class, but the same methods exist in the `LocalDate` (for `Period`)
    and `LocalTime` (for `Duration`) classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods work the same way as the methods of the `LocalTime` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: 'Some other methods of creating and using `Period` objects are demonstrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '`Duration` objects can be similarly created and used, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: There are many other helpful methods in `Period` and `Duration` classes. If
    you have to work with dates, we recommend that you read the API of this class
    and other classes of the `java.time` package and its sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: Period of day
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java 16 includes a new time format that shows a period of the day as `AM`,
    `in the morning`, and similar. The following two methods demonstrate usage of
    the `DateTimeFormatter.ofPattern()` method with the `LocalDateTime` and `LocalTime`
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates the effect of `"h a"` and `"h B"` patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: You can use `"h a"` and `"h B"` patterns to make the time presentation more
    user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced you to the Java collections framework and its three
    main interfaces: `List`, `Set`, and `Map`. Each of the interfaces was discussed
    and its methods were demonstrated with one of the implementing classes. The generics
    were explained and demonstrated as well. The `equals()` and `hashCode()` methods
    have to be implemented in order for an object to be capable of being handled by
    Java collections correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Collections` and `CollectionUtils` utility classes have many useful methods
    for collection handling and were presented in examples, along with the `Arrays`,
    `ArrayUtils`, `Objects`, and `ObjectUtils` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The class methods of the `java.time` package allow time/date values to be managed
    and were demonstrated in specific practical code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use all the main data structures we talked about in this chapter
    in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will overview JCL and some external libraries, including
    those that support testing. Specifically, we will explore the `org.junit`, `org.mockito`,
    `org.apache.log4j`, `org.slf4j`, and `org.apache.commons` packages and their sub-packages.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is the Java collections framework? Select all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A collection of frameworks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Classes and interfaces of the `java.util` package
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`List`, `Set`, and `Map` interfaces'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Classes and interfaces that implement a collection data structure
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is meant by *generics* in a collection? Select all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A collection structure definition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An element type declaration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A type generalization
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A mechanism that provides compile-time safety
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What are the limitations of the collection of `of()` factory methods? Select
    all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They do not allow a `null` element.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: They do not allow elements to be added to the initialized collection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: They do not allow modification of elements in relation to the initialized collection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What does the implementation of the `java.lang.Iterable` interface allow? Select
    all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows elements of the collection to be accessed one by one.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows the collection to be used in `FOR` statements.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows the collection to be used in `WHILE` statements.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows the collection to be used in `DO...WHILE` statements.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What does the implementation of the `java.util.Collection` interface allow?
    Select all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Addition to the collection of elements from another collection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Removal from the collection of objects that are elements of another collection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Modification of just those elements of the collection that belong to another
    collection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Removal from the collection of objects that do not belong to another collection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements pertaining to `List` interface methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`z get(int index)`: This returns the element at a specified position in the
    list.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`E remove(int index)`: This removes the element at a specified position in
    the list; it returns the removed element.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`static List<E> copyOf(Collection<E> coll)`: This returns an unmodifiable `List`
    interface containing elements of the given `Collection` interface and preserves
    their order.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int indexOf(Object o)`: This returns the position of a specified element in
    the list.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements pertaining to `Set` interface methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`E get(int index)`: This returns the element at a specified position in the
    list.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`E remove(int index)`: This removes the element at a specified position in
    the list; it returns the removed element.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`static Set<E> copyOf(Collection<E> coll)`: This returns an unmodifiable `Set`
    interface containing elements of the given `Collection` interface.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int indexOf(Object o)`: This returns the position of a specified element in
    the list.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements pertaining to `Map` interface methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`int size()`: This returns the count of key-value pairs stored in the map;
    when the `isEmpty()` method returns `true`, this method returns `0`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`V remove(Object key)`: This removes both the key and value from the map; returns
    `value` or `null` if there is no such key or the value is `null`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`default boolean remove(Object key, Object value)`: This removes the key-value
    pair if such a pair exists in the map; returns `true` if the value is removed.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`default boolean replace(K key, V oldValue, V newValue)`: This replaces the
    `oldValue` value with the `newValue` value provided if the key provided is currently
    mapped to the `oldValue` value—it returns `true` if the `oldValue` value was replaced;
    otherwise, it returns `false`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all correct statements pertaining to the `static void sort(List<T> list,
    Comparator<T> comparator)` method of the `Collections` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It sorts the list’s natural order if list elements implement the `Comparable`
    interface.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It sorts the list’s order according to the `Comparator` object provided.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It sorts the list’s order according to the `Comparator` object provided if list
    elements implement the `Comparable` interface.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It sorts the list’s order according to the provided `Comparator` object irrespective
    of whether the list elements implement the `Comparable` interface.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the outcome of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`[s1, s2, s3, s4]`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[s3, s4, s3]`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[s1, s2, s3, s3, s4]`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[s3, s4]`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is the functionality of `CollectionUtils` class methods? Select all that
    apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It matches the functionality of `Collections` class methods, but by handling
    `null`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It complements the functionality of `Collections` class methods
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It searches, processes, and compares Java collections in a way that `Collections`
    class methods do not do
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It duplicates the functionality of `Collections` class methods
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`false true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true false`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`1 2 0 false true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2 1 1 false true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2 1 0 false true`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2 1 0 true false`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`true 0 0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Error`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false -1 0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`false 31 0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`c x a`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a c x`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x c a`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a x c`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`1921-02-23`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`21-02-23`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0021-02-23`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Error`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`20:23:12.000000300`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`20:23:12.300`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`20:23:12:300`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Error`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`2020-02-23 20:23:12`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2020-02-23T20:23:12`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2020-02-23:20:23:12`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Error`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of executing the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`2020-02-23T20:23:12 2020-02-23T20:23:12`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2020-02-23T20:23:12 2020-02-23T20:35:12`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2018-02-23T20:23:12 2020-02-23T20:35:12 2020-02-23T20:23:12`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`2018-02-23T20:23:12 2020-02-23T20:35:12 2018-02-23T20:35:12`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
