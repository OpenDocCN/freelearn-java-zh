["```java\n(defn fibo\n  ([n]\n   (fibo [0N 1N] n))\n  ([xs n]\n   (if (<= n (count xs))\n     xs\n     (let [x' (+ (last xs)\n                 (nth xs (- (count xs) 2)))\n           xs' (conj xs x')]\n       (fibo xs' n)))))\n```", "```java\nuser> (fibo 10)\n[0N 1N 1N 2N 3N 5N 8N 13N 21N 34N]\nuser> (last (fibo 100))\n218922995834555169026N\n```", "```java\nuser> (last (fibo 10000))\nStackOverflowError   clojure.lang.Numbers.lt (Numbers.java:219)\n```", "```java\n(defn fibo-recur\n  ([n]\n   (fibo-recur [0N 1N] n))\n  ([xs n]\n   (if (<= n (count xs))\n     xs\n     (let [x' (+ (last xs)\n                 (nth xs (- (count xs) 2)))\n           xs' (conj xs x')]\n       (recur xs' n)))))\n```", "```java\nuser> (fibo-recur 10)\n[0N 1N 1N 2N 3N 5N 8N 13N 21N 34N]\nuser> (last (fibo-recur 10000))\n207936...230626N\n```", "```java\nuser> (time (last (fibo-recur 10000)))\n\"Elapsed time: 1320.050942 msecs\"\n207936...230626N\n```", "```java\n(defn fibo-loop [n]\n  (loop [xs [0N 1N]\n         n n]\n    (if (<= n (count xs))\n      xs\n      (let [x' (+ (last xs)\n                  (nth xs (- (count xs) 2)))\n            xs' (conj xs x')]\n        (recur xs' n)))))\n```", "```java\nuser> (fibo-loop 10)\n[0N 1N 1N 2N 3N 5N 8N 13N 21N 34N]\nuser> (last (fibo-loop 10000))\n207936...230626N\n```", "```java\n(defn fibo-trampoline [n]\n  (letfn [(fibo-fn [xs n]\n            (if (<= n (count xs))\n              xs\n              (let [x' (+ (last xs)\n                          (nth xs (- (count xs) 2)))\n                    xs' (conj xs x')]\n                #(fibo-fn xs' n))))]\n    (trampoline fibo-fn [0N 1N] n)))\n```", "```java\nuser> (fibo-trampoline 10)\n[0N 1N 1N 2N 3N 5N 8N 13N 21N 34N]\nuser> (time (last (fibo-trampoline 10000)))\n\"Elapsed time: 1346.629108 msecs\"\n207936...230626N\n```", "```java\n(defn sqrt-div2-recur [n]\n  (letfn [(sqrt [n]\n            (if (< n 1)\n              n\n              (div2 (Math/sqrt n))))\n          (div2 [n]\n            (if (< n 1)\n              n\n              (sqrt (/ n 2))))]\n    (sqrt n)))\n```", "```java\n(defn sqrt-div2-trampoline [n]\n  (letfn [(sqrt [n]\n            (if (< n 1)\n              n\n              #(div2 (Math/sqrt n))))\n          (div2 [n]\n            (if (< n 1)\n              n\n              #(sqrt (/ n 2))))]\n    (trampoline sqrt n)))\n```", "```java\nuser> (time (sqrt-div2-recur 10000000000N))\n\"Elapsed time: 0.327439 msecs\"\n0.5361105866719398\nuser> (time (sqrt-div2-trampoline 10000000000N))\n\"Elapsed time: 0.326081 msecs\"\n0.5361105866719398\n```", "```java\n(defn fibo-lazy [n]\n  (->> [0N 1N]\n       (iterate (fn [[a b]] [b (+ a b)]))\n       (map first)\n       (take n)))\n```", "```java\nuser> (fibo-lazy 10)\n(0N 1N 1N 2N 3N 5N 8N 13N 21N 34N)\nuser> (last (fibo-lazy 10000))\n207936...230626N\n```", "```java\nuser> (time (last (fibo-lazy 10000)))\n\"Elapsed time: 18.593018 msecs\"\n207936...230626N\n```", "```java\nuser> (time (def fibo-xs (fibo-lazy 10000)))\n\"Elapsed time: 0.191981 msecs\"\n#'user/fibo-xs\nuser> (type fibo-xs)\nclojure.lang.LazySeq\n```", "```java\n(def fibo-mem (memoize fibo-lazy))\n```", "```java\nuser> (time (last (fibo-mem 10000)))\n\"Elapsed time: 19.776527 msecs\"\n207936...230626N\nuser> (time (last (fibo-mem 10000)))\n\"Elapsed time: 2.82709 msecs\"\n207936...230626N\n```", "```java\nuser> (def xs (cons 0 '(1 2 3)))\n#'user/xs\nuser> (first xs)\n0\nuser> (rest xs)\n(1 2 3)\n```", "```java\nuser> (cons 0 ())\n(0)\nuser> (cons 0 nil)\n(0)\nuser> (rest (cons 0 nil))\n()\n```", "```java\nuser> (empty? ())\ntrue\nuser> (empty? nil)\ntrue\nuser> (nil? ())\nfalse\nuser> (nil? nil)\ntrue\n```", "```java\nuser> (= (rest ()) nil)\nfalse\nuser> (= (seq ()) nil)\ntrue\nuser> (= (next ()) nil)\ntrue\n```", "```java\nuser> (seq? '(1 2 3))\ntrue\nuser> (seq? [1 2 3])\nfalse\nuser> (seq? (seq [1 2 3]))\ntrue\n```", "```java\nuser> (sequential? '(1 2 3))\ntrue\nuser> (sequential? [1 2 3])\ntrue\nuser> (sequential? {:a 1 :b 2})\nfalse\nuser> (sequential? #{:a :b})\nfalse\n```", "```java\nuser> (associative? '(1 2 3))\nfalse\nuser> (associative? [1 2 3])\ntrue\nuser> (associative? {:a 1 :b 2})\ntrue\nuser> (associative? #{:a :b})\nfalse\n```", "```java\nuser> ([:a :b] 1)\n:b\nuser> ({:a 1 :b 2} :a)\n1\n```", "```java\nuser> (#{1 2 3} 1)\n1\nuser> (#{1 2 3} 0)\nnil\n```", "```java\nuser> (conj [1 2 3] 4 5 6)\n[1 2 3 4 5 6]\nuser> (conj '(1 2 3) 4 5 6)\n(6 5 4 1 2 3)\n```", "```java\nuser> (concat [1 2 3] [])\n(1 2 3)\nuser> (concat [] [1 2 3])\n(1 2 3)\nuser> (concat [1 2 3] [4 5 6] [7 8 9])\n(1 2 3 4 5 6 7 8 9)\n```", "```java\nuser> (reverse [1 2 3 4 5 6])\n(6 5 4 3 2 1)\nuser> (reverse (reverse [1 2 3 4 5 6]))\n(1 2 3 4 5 6)\n```", "```java\nuser> (range 5)\n(0 1 2 3 4)\nuser> (range 0 10 3)\n(0 3 6 9)\nuser> (range 15 10 -1)\n(15 14 13 12 11)\n```", "```java\nuser> (take 5 (range 10))\n(0 1 2 3 4)\nuser> (drop 5 (range 10))\n(5 6 7 8 9)\n```", "```java\nuser> (nth (range 10) 0)\n0\nuser> (nth (range 10) 9)\n9\n```", "```java\nuser> (repeat 10 0)\n(0 0 0 0 0 0 0 0 0 0)\nuser> (repeat 5 :x)\n(:x :x :x :x :x)\n```", "```java\nuser> (repeat 5 (rand-int 100))\n(75 75 75 75 75)\nuser> (repeatedly 5 #(rand-int 100))\n(88 80 17 52 32)\n```", "```java\nuser> (take 5 (cycle [0]))\n(0 0 0 0 0)\nuser> (take 5 (cycle (range 3)))\n(0 1 2 0 1)\n```", "```java\nuser> (interleave [0 1 2] [3 4 5 6] [7 8])\n(0 3 7 1 4 8)\nuser> (interleave [1 2 3] (cycle [0]))\n(1 0 2 0 3 0)\n```", "```java\nuser> (interpose 0 [1 2 3])\n(1 0 2 0 3)\n```", "```java\nuser> (take 5 (iterate inc 5))\n(5 6 7 8 9)\nuser> (take 5 (iterate #(+ 2 %) 0))\n(0 2 4 6 8)\n```", "```java\nuser> (map inc [0 1 2 3])\n(1 2 3 4)\nuser> (map #(* 2 %) [0 1 2 3])\n(0 2 4 6)\n```", "```java\nuser> (map + [0 1 2 3] [4 5 6])\n(4 6 8)\n```", "```java\nuser> (mapv inc [0 1 2 3])\n[1 2 3 4]\n```", "```java\nuser> (map-indexed (fn [i x] [i x]) \"Hello\")\n([0 \\H] [1 \\e] [2 \\l] [3 \\l] [4 \\o])\n```", "```java\nuser> (require '[clojure.string :as cs])\nnil\nuser> (map #(cs/split % #\"\\d\") [\"aa1bb\" \"cc2dd\" \"ee3ff\"])\n([\"aa\" \"bb\"] [\"cc\" \"dd\"] [\"ee\" \"ff\"])\nuser> (mapcat #(cs/split % #\"\\d\") [\"aa1bb\" \"cc2dd\" \"ee3ff\"])\n(\"aa\" \"bb\" \"cc\" \"dd\" \"ee\" \"ff\")\n```", "```java\nuser> (reduce + [1 2 3 4 5])\n15\nuser> (reduce + [])\n0\nuser> (reduce + 1 [])\n1\n```", "```java\nuser> (for [x (range 3 7)]\n (* x x))\n(9 16 25 36)\nuser> (for [x [0 1 2 3 4 5]\n :let [y (* x 3)]\n :when (even? y)]\n y)\n(0 6 12)\n```", "```java\nuser> (for [x ['a 'b 'c]\n y [1 2 3]]\n [x y])\n([a 1] [a 2] [a 3] [b 1] [b 2] [b 3] [c 1] [c 2] [c 3])\n```", "```java\nuser> (doseq [x (range 3 7)]\n (* x x))\nnil\nuser> (doseq [x (range 3 7)]\n (println (* x x)))\n9\n16\n25\n36\nnil\n```", "```java\nuser> (into {} [[:a 1] [:c 3] [:b 2]])\n{:a 1, :c 3, :b 2}\nuser> (into [] {1 2 3 4})\n[[1 2] [3 4]]\n```", "```java\nuser> (into [1 2 3] '(4 5 6))\n[1 2 3 4 5 6]\nuser> (into '(1 2 3) '(4 5 6))\n(6 5 4 1 2 3)\n```", "```java\nuser> (partition 2 (range 11))\n((0 1) (2 3) (4 5) (6 7) (8 9))\nuser> (partition-all 2 (range 11))\n((0 1) (2 3) (4 5) (6 7) (8 9) (10))\n```", "```java\nuser> (partition 3 2 (range 11))\n((0 1 2) (2 3 4) (4 5 6) (6 7 8) (8 9 10))\nuser> (partition-all 3 2 (range 11))\n((0 1 2) (2 3 4) (4 5 6) (6 7 8) (8 9 10) (10))\n```", "```java\nuser> (partition 3 (range 11))\n((0 1 2) (3 4 5) (6 7 8))\nuser> (partition 3 3 (range 11 12) (range 11))\n((0 1 2) (3 4 5) (6 7 8) (9 10 11))\nuser> (partition 3 3 (range 11 15) (range 11))\n((0 1 2) (3 4 5) (6 7 8) (9 10 11))\nuser> (partition 3 4 (range 11 12) (range 11))\n((0 1 2) (4 5 6) (8 9 10))\n```", "```java\nuser> (partition-by #(= 0 %) [-2 -1 0 1 2])\n((-2 -1) (0) (1 2))\nuser> (partition-by identity [-2 -1 0 1 2])\n((-2) (-1) (0) (1) (2))\n```", "```java\nuser> (sort [3 1 2 0])\n(0 1 2 3)\nuser> (sort > [3 1 2 0])\n(3 2 1 0)\nuser> (sort [\"Carol\" \"Alice\" \"Bob\"])\n(\"Alice\" \"Bob\" \"Carol\")\n```", "```java\nuser> (sort #(compare (first %1) (first %2)) [[1 1] [2 2] [3 3]])\n([1 1] [2 2] [3 3])\nuser> (sort-by first [[1 1] [2 2] [3 3]])\n([1 1] [2 2] [3 3])\nuser> (sort-by first > [[1 1] [2 2] [3 3]])\n([3 3] [2 2] [1 1])\n```", "```java\nuser> (keep #(if (odd? %) %) (range 10))\n(1 3 5 7 9)\nuser> (keep seq [() [] '(1 2 3) [:a :b] nil])\n((1 2 3) (:a :b))\n```", "```java\nuser> (keep {:a 1, :b 2, :c 3} [:a :b :d])\n(1 2)\nuser> (keep #{0 1 2 3} #{2 3 4 5})\n(3 2)\n```", "```java\nuser> (filter even? (range 10))\n(0 2 4 6 8)\nuser> (filterv even? (range 10))\n[0 2 4 6 8]\n```", "```java\nuser> (keep #(if (odd? %) %) (range 10))\n(1 3 5 7 9)\nuser> (filter odd? (range 10))\n(1 3 5 7 9)\n```", "```java\nuser> (for [x (range 10) :when (odd? x)] x)\n(1 3 5 7 9)\n```", "```java\nuser> (subvec [0 1 2 3 4 5] 3)\n[3 4 5]\nuser> (subvec [0 1 2 3 4 5] 3 5)\n[3 4]\n```", "```java\nuser> (select-keys {:a 1 :b 2} [:a])\n{:a 1}\nuser> (select-keys {:a 1 :b 2 :c 3} [:a :c])\n{:c 3, :a 1}\n```", "```java\nuser> (find {:a 1 :b 2} :a)\n[:a 1]\n```", "```java\nuser> (take-while neg? [-2 -1 0 1 2])\n(-2 -1)\nuser> (drop-while neg? [-2 -1 0 1 2])\n(0 1 2)\n```", "```java\n(defn fibo-cons [a b]\n  (cons a (lazy-seq (fibo-cons b (+ a b)))))\n```", "```java\nuser> (def fibo (fibo-cons 0N 1N))\n#'user/fibo\nuser> (take 2 fibo)\n(0N 1N)\nuser> (take 11 fibo)\n(0N 1N 1N 2N 3N 5N 8N 13N 21N 34N 55N)\nuser> (last (take 10000 fibo))\n207936...230626N\n```", "```java\n(def fibo-seq\n  (lazy-cat [0N 1N] (map + fibo-seq (rest fibo-seq))))\n```", "```java\nuser> (first fibo-seq)\n0N\nuser> (nth fibo-seq 1)\n1N\nuser> (nth fibo-seq 10)\n55N\nuser> (nth fibo-seq 9999)\n207936...230626N\n```", "```java\nuser> (def xs (map println (range 3)))\n#'user/xs\nuser> xs\n0\n1\n2\n(nil nil nil)\n```", "```java\nuser> (def xs (doall (map println (range 3))))\n0\n1\n2\n#'user/xs\nuser> xs\n(nil nil nil)\n```", "```java\n(ns my-namespace\n  (:require [clojure.zip :as z]\n            [clojure.xml :as xml]))\n```", "```java\n(def tree [:a [1 2 3] :b :c])\n```", "```java\n(def root (z/vector-zip tree))\n```", "```java\nuser> (def tree-nodes (iterate z/next root))\n#'user/tree-nodes\nuser> (nth tree-nodes 0)\n[[:a [1 2 3] :b :c] nil]\nuser> (nth tree-nodes 1)\n[:a {:l [], :pnodes ... }]\nuser> (nth tree-nodes 2)\n[[1 2 3] {:l [:a], :pnodes ... }]\nuser> (nth tree-nodes 3)\n[1 {:l [], :pnodes ... }]\n```", "```java\nuser> (-> root z/down)\n[:a {:l [], :pnodes ... }]\nuser> (-> root z/down z/right)\n[[1 2 3] {:l [:a], :pnodes ... }]\nuser> (-> root z/down z/right z/up)\n[[:a [1 2 3] :b :c] nil]\nuser> (-> root z/down z/right z/right)\n[:b {:l [:a [1 2 3]], :pnodes ... }]\nuser> (-> root z/down z/right z/left)\n[:a {:l [], :pnodes ... }]\n```", "```java\nuser> (-> root z/down z/right z/right z/node)\n:b\nuser> (-> root z/down z/right z/left z/node)\n:a\n```", "```java\nuser> (-> root z/down z/rightmost z/node)\n:c\nuser> (-> root z/down z/rightmost z/leftmost z/node)\n:a\n```", "```java\nuser> (-> root z/down z/rights)\n([1 2 3] :b :c)\nuser> (-> root z/down z/lefts)\nnil\n```", "```java\nuser> (-> root z/down z/right z/root)\n[:a [1 2 3] :b :c]\nuser> (-> root z/down z/right r/left z/root)\n[:a [1 2 3] :b :c]\n```", "```java\nuser> (def e (-> root z/down z/right z/down))\n#'user/e\nuser> (z/node e)\n1\nuser> (z/path e)\n[[:a [1 2 3] :b :c]\n [1 2 3]]\n```", "```java\nuser> (-> root (z/insert-child :d) z/root)\n[:d :a [1 2 3] :b :c]\nuser> (-> root z/down z/right (z/insert-child 0) z/root)\n[:a [0 1 2 3] :b :c]\n```", "```java\nuser> (-> root z/down z/remove z/root)\n[[1 2 3] :b :c]\nuser> (-> root z/down (z/replace :d) z/root)\n[:d [1 2 3] :b :c]\n```", "```java\n<countries>\n  <country name=\"England\">\n    <city>Birmingham</city>\n    <city>Leeds</city>\n    <city capital=\"true\">London</city>\n  </country>\n  <country name=\"Germany\">\n    <city capital=\"true\">Berlin</city>\n    <city>Frankfurt</city>\n    <city>Munich</city>\n  </country>\n  <country name=\"France\">\n    <city>Cannes</city>\n    <city>Lyon</city>\n    <city capital=\"true\">Paris</city>\n  </country>\n</countries>\n```", "```java\n(defn is-capital-city? [n]\n  (and (= (:tag n) :city)\n       (= \"true\" (:capital (:attrs n)))))\n\n(defn find-capitals [file-path]\n  (let [xml-root (z/xml-zip (xml/parse file-path))\n        xml-seq (iterate z/next (z/next xml-root))]\n    (->> xml-seq\n         (take-while #(not= (z/root xml-root) (z/node %)))\n         (map z/node)\n         (filter is-capital-city?)\n         (mapcat :content))))\n```", "```java\nuser> (find-capitals \"resources/data/sample.xml\")\n(\"London\" \"Berlin\" \"Paris\")\n```", "```java\n[org.clojure/core.match \"0.2.2\"\n :exclusions [org.clojure/tools.analyzer.jvm]]\n[defun \"0.2.0-RC\"]\n```", "```java\n(ns my-namespace\n  (:require [clojure.core.match :as m]\n            [defun :as f]))\n```", "```java\n(defn xor [x y]\n  (m/match [x y]\n           [true true] false\n           [false true] true\n           [true false] true\n           [false false] false))\n```", "```java\n(f/defun xor\n  ([true true] false)\n  ([false true] true)\n  ([true false] true)\n  ([false false] false))\n```", "```java\nuser> (xor true true)\nfalse\nuser> (xor true false)\ntrue\nuser> (xor false true)\ntrue\nuser> (xor false false)\nfalse\n```", "```java\nuser> (xor 0 0)\nIllegalArgumentException No matching clause: [0 0] user/xor ...\n```", "```java\n(f/defun fibo\n  ([0] 0N)\n  ([1] 1N)\n  ([n] (+ (fibo (- n 1))\n          (fibo (- n 2)))))\n```", "```java\nuser> (fibo 0)\n0N\nuser> (fibo 1)\n1N\nuser> (fibo 10)\n55N\n```", "```java\n(f/defun fibo-recur\n  ([a b 0] a)\n  ([a b n] (recur b (+ a b) (dec n)))\n  ([n] (recur 0N 1N n)))\n```", "```java\nuser> (fibo-recur 0)\n0N\nuser> (fibo-recur 1)\n1N\nuser> (fibo-recur 10)\n55N\nuser> (fibo-recur 9999)\n207936...230626N\n```", "```java\n(def delayed-1\n  (delay\n   (Thread/sleep 3000)\n   (println \"3 seconds later ...\")\n   1))\n```", "```java\nuser> (realized? delayed-1)\nfalse\nuser> (realized? delayed-1)           ; after 3 seconds\nfalse\n```", "```java\nuser> @delayed-1\n3 seconds later ...\n1\nuser> (realized? delayed-1)\ntrue\n```", "```java\nuser> @delayed-1\n1\n```", "```java\n(defn wait-3-seconds []\n  (Thread/sleep 3000)\n  (println)\n  (println \"3 seconds later ...\"))\n```", "```java\nuser> (.start (Thread. wait-3-seconds))\nnil\nuser>\n3 seconds later ...\n\nuser>\n```", "```java\n(defn val-as-future [n secs]\n  (future\n    (Thread/sleep (* secs 1000))\n    (println)\n    (println (str secs \" seconds later ...\"))\n    n))\n```", "```java\nuser> (def future-1 (val-as-future 1 3))\n#'user/future-1\nuser>\n3 seconds later ...\n\nuser>\n```", "```java\nuser> (realized? future-1)\ntrue\nuser> (future-done? future-1)\ntrue\n```", "```java\nuser> (def future-10 (val-as-future 10 10))\n#'user/future-10\nuser> (future-cancel future-10)\ntrue\n```", "```java\nuser> (future-cancelled? future-10)\ntrue\nuser> @future-10\nCancellationException   java.util.concurrent.FutureTask.report (FutureTask.java:121)\n```", "```java\nuser> (def p (promise))\n#'user/p\nuser> (deliver p 100)\n#<core$promise$reify__6363@1792b00: 100>\nuser> (deliver p 200)\nnil\nuser> @p\n100\n```", "```java\n(defn lock-for-2-seconds []\n  (let [lock (Object.)\n        task-1 (fn []\n                 (future\n                   (locking lock\n                     (Thread/sleep 2000)\n                     (println \"Task 1 completed\"))))\n        task-2 (fn []\n                 (future\n                   (locking lock\n                     (Thread/sleep 1000)\n                     (println \"Task 2 completed\"))))]\n    (task-1)\n    (task-2)))\n```", "```java\nuser> (lock-for-2-seconds)\n[#<core$future_call$reify__6320@19ed4e9: :pending>\n #<core$future_call$reify__6320@ac35d5: :pending>]\nuser>\nTask 1 completed\nTask 2 completed\n```", "```java\n(def ^:dynamic *thread-local-state* [1 2 3])\n```", "```java\nuser> (binding [*thread-local-state* [10 20]]\n (map #(* % %) *thread-local-state*))\n(100 400)\nuser> (map #(* % %) *thread-local-state*)\n(1 4 9)\n```", "```java\nuser> *thread-local-state*\n[1 2 3]\nuser> (var *thread-local-state*)\n#'user/*thread-local-state*\n```", "```java\nuser> (with-bindings {#'*thread-local-state* [10 20]}\n (map #(* % %) *thread-local-state*))\n(100 400)\nuser> (with-bindings {(var *thread-local-state*) [10 20]}\n (map #(* % %) *thread-local-state*))\n(100 400)\n```", "```java\nuser> (def ^:dynamic *unbound-var*)\n#'user/*unbound-var*\nuser> (thread-bound? (var *unbound-var*))\nfalse\nuser> (binding [*unbound-var* 1]\n (thread-bound? (var *unbound-var*)))\ntrue\n```", "```java\n(defn factorial [n]\n  (with-local-vars [i n acc 1]\n    (while (> @i 0)\n      (var-set acc (* @acc @i))\n      (var-set i (dec @i)))\n    (var-get acc)))\n```", "```java\n(def state (ref 0))\n```", "```java\nuser> @state\n0\nuser> (dosync (ref-set state 1))\n1\nuser> @state\n1\n```", "```java\nuser> @state\n1\nuser> (dosync (alter state + 2))\n3\nuser> (dosync (commute state + 2))\n5\n```", "```java\nuser> (def r (ref 1 :validator pos?))\n#'user/r\nuser> (dosync (alter r (fn [_] -1)))\nIllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\nuser> (dosync (alter r (fn [_] 2)))\n2\n```", "```java\n(defn make-fork []\n  (ref true))\n\n(defn make-philosopher [name forks food]\n  (ref {:name name\n        :forks forks\n        :eating? false\n        :food food}))\n```", "```java\n(defn has-forks? [p]\n  (every? true? (map ensure (:forks @p))))\n\n(defn update-forks [p]\n  (doseq [f (:forks @p)]\n    (commute f not))\n  p)\n```", "```java\n(defn start-eating [p]\n  (dosync\n   (when (has-forks? p)\n     (update-forks p)\n     (commute p assoc :eating? true)\n     (commute p update-in [:food] dec))))\n\n(defn stop-eating [p]\n  (dosync\n   (when (:eating? @p)\n     (commute p assoc :eating? false)\n     (update-forks p))))\n\n(defn dine [p retry-ms max-eat-ms max-think-ms]\n  (while (pos? (:food @p))\n    (if (start-eating p)\n      (do\n        (Thread/sleep (rand-int max-eat-ms))\n        (stop-eating p)\n        (Thread/sleep (rand-int max-think-ms)))\n      (Thread/sleep retry-ms))))\n```", "```java\n(defn init-forks [nf]\n  (repeatedly nf #(make-fork)))\n\n(defn init-philosophers [np food forks init-fn]\n  (let [p-range (range np)\n        p-names (map #(str \"Philosopher \" (inc %))\n                     p-range)\n        p-forks (map #(vector (nth forks %)\n                              (nth forks (-> % inc (mod np))))\n                     p-range)\n        p-food (cycle [food])]\n    (map init-fn p-names p-forks p-food)))\n```", "```java\n(defn check-philosophers [philosophers forks]\n  (doseq [i (range (count philosophers))]\n    (println (str \"Fork:\\t\\t\\t available=\" @(nth forks i)))\n    (if-let [p @(nth philosophers i)]\n      (println (str (:name p)\n                    \":\\t\\t eating=\" (:eating? p)\n                    \" food=\" (:food p))))))\n```", "```java\n(defn dine-philosophers [philosophers]\n  (doall (for [p philosophers]\n           (future (dine p 10 100 100))))\n```", "```java\n(def all-forks (init-forks 5))\n\n(def all-philosophers\n  (init-philosophers 5 1000 all-forks make-philosopher))\n```", "```java\nuser> (check-philosophers all-philosophers all-forks)\nFork:                         available=true\nPhilosopher 1:                eating=false food=1000\nFork:                         available=true\nPhilosopher 2:                eating=false food=1000\nFork:                         available=true\nPhilosopher 3:                eating=false food=1000\nFork:                         available=true\nPhilosopher 4:                eating=false food=1000\nFork:                         available=true\nPhilosopher 5:                eating=false food=1000\nnil\n```", "```java\nuser> (def philosophers-futures (dine-philosophers all-philosophers))\n#'user/philosophers-futures\nuser> (check-philosophers all-philosophers all-forks)\nFork:                         available=false\nPhilosopher 1:                eating=true food=978\nFork:                         available=false\nPhilosopher 2:                eating=false food=979\nFork:                         available=false\nPhilosopher 3:                eating=true food=977\nFork:                         available=false\nPhilosopher 4:                eating=false food=980\nFork:                         available=true\nPhilosopher 5:                eating=false food=980\nnil\n```", "```java\nuser> (check-philosophers all-philosophers all-forks)\nFork:                         available=true\nPhilosopher 1:                eating=false food=932\nFork:                         available=true\nPhilosopher 2:                eating=false food=935\nFork:                         available=true\nPhilosopher 3:                eating=false food=933\nFork:                         available=true\nPhilosopher 4:                eating=false food=942\nFork:                         available=true\nPhilosopher 5:                eating=false food=935\nnil\n```", "```java\nuser> (map future-cancel philosophers-futures)\n(true true true true true)\n```", "```java\n(def state (atom 0))\n```", "```java\nuser> @state\n0\nuser> (reset! state 1)\n1\nuser> @state\n1\n```", "```java\nuser> @state\n1\nuser> (swap! state + 2)\n3\n```", "```java\n(defn make-state-with-watch []\n  (let [state (atom 0)\n        state-is-changed? (atom false)\n        watch-fn (fn [key r old-value new-value]\n                   (swap! state-is-changed? (fn [_] true))]\n    (add-watch state nil watch-fn)\n    [state\n     state-is-changed?]))\n```", "```java\nuser> (def s (make-state-with-watch))\n#'user/s\nuser> @(nth s 1)\nfalse\nuser> (swap! (nth s 0) inc)\n1\nuser> @(nth s 1)\ntrue\n```", "```java\n(def state (agent {}))\n```", "```java\n(defn set-value-in-ms [n ms]\n  (fn [a]\n    (Thread/sleep ms)\n    (assoc a :value n)))\n```", "```java\nuser> (send state (set-value-in-ms 5 5000))\n#<Agent@7fce18: {}>\nuser> (send-off state (set-value-in-ms 10 5000))\n#<Agent@7fce18: {}>\nuser> @state\n{}\nuser> @state ; after 5 seconds\n{:value 5}\nuser> @state ; after another 5 seconds\n{:value 10}\n```", "```java\nuser> (send-off state (set-value-in-ms 100 3000))\n#<Agent@af9ac: {:value 10}>\nuser> (await state)  ; will block\nnil\nuser> @state\n{:value 100}\n```", "```java\nuser> (def a (agent 1))\n#'user/a\nuser> (send a / 0)\n#<Agent@5d29f1: 1>\nuser> (agent-error a)\n#<ArithmeticException java.lang.ArithmeticException: Divide by zero>\nuser> (clear-agent-errors a)\n1\nuser> (agent-error a)\nnil\nuser> @a\n1\n```", "```java\n(def pool (java.util.concurrent.Executors/newFixedThreadPool 10))\n```", "```java\nuser> (send-via pool state assoc :value 1000)\n#<Agent@8efada: {:value 100}>\nuser> @state\n{:value 1000}\n```", "```java\n(defn make-philosopher-agent [name forks food]\n  (agent {:name name\n          :forks forks\n          :eating? false\n          :food food}))\n\n(defn start-eating [max-eat-ms]\n  (dosync (if (has-forks? *agent*)\n            (do\n              (-> *agent*\n                  update-forks\n                  (send assoc :eating? true)\n                  (send update-in [:food] dec))\n              (Thread/sleep (rand-int max-eat-ms))))))\n\n(defn stop-eating [max-think-ms]\n  (dosync (-> *agent*\n              (send assoc :eating? false)\n              update-forks))\n  (Thread/sleep (rand-int max-think-ms)))\n\n(def running? (atom true))\n\n(defn dine [p max-eat-ms max-think-ms]\n  (when (and p (pos? (:food p)))\n    (if-not (:eating? p)\n      (start-eating max-eat-ms)\n      (stop-eating max-think-ms))\n    (if-not @running?\n      @*agent*\n      @(send-off *agent* dine max-eat-ms max-think-ms))))\n\n(defn dine-philosophers [philosophers]\n  (swap! running? (fn [_] true))\n  (doall (for [p philosophers]\n           (send-off p dine 100 100))))\n\n(defn stop-philosophers []\n  (swap! running? (fn [_] false)))\n```", "```java\n(def all-forks (init-forks 5))\n\n(def all-philosophers\n  (init-philosophers 5 1000 all-forks make-philosopher-agent))\n```", "```java\nuser> (def philosophers-agents (dine-philosophers all-philosophers))\n#'user/philosophers-agents\nuser> (check-philosophers all-philosophers all-forks)\nFork:                    available=false\nPhilosopher 1:           eating=false food=936\nFork:                    available=false\nPhilosopher 2:           eating=false food=942\nFork:                    available=true\nPhilosopher 3:           eating=true food=942\nFork:                    available=true\nPhilosopher 4:           eating=false food=935\nFork:                    available=true\nPhilosopher 5:           eating=true food=943\nnil\nuser> (check-philosophers all-philosophers all-forks)\nFork:                    available=false\nPhilosopher 1:           eating=true food=743\nFork:                    available=false\nPhilosopher 2:           eating=false food=747\nFork:                    available=true\nPhilosopher 3:           eating=false food=751\nFork:                    available=true\nPhilosopher 4:           eating=false food=741\nFork:                    available=true\nPhilosopher 5:           eating=false food=760\nnil\n```", "```java\n(defn square-slowly [x]\n  (Thread/sleep 2000)\n  (* x x))\n```", "```java\nuser> (time (doall (map square-slowly (repeat 3 10))))\n\"Elapsed time: 6000.329702 msecs\"\n(100 100 100)\n```", "```java\nuser> (time (doall (pmap square-slowly (repeat 3 10))))\n\"Elapsed time: 2001.543439 msecs\"\n(100 100 100)\n```", "```java\nuser> (time (doall (pvalues (square-slowly 10)\n (square-slowly 10)\n (square-slowly 10))))\n\"Elapsed time: 2007.702703 msecs\"\n(100 100 100)\nuser> (time (doall (pcalls #(square-slowly 10)\n #(square-slowly 10)\n #(square-slowly 10))))\n\"Elapsed time: 2005.683279 msecs\"\n(100 100 100)\n```", "```java\n[com.climate/claypoole \"1.0.0\"]\n```", "```java\n(ns my-namespace\n  (:require [com.climate.claypoole :as cp]\n            [com.climate.claypoole.lazy :as cpl]))\n```", "```java\nuser> (time (doall (cpl/pmap 2 square-slowly [10 10 10])))\n\"Elapsed time: 4004.029789 msecs\"\n(100 100 100)\n```", "```java\nuser> (def pool (cp/threadpool (cp/ncpus)))\n#'user/pool\nuser> (time (doall (cpl/pmap pool square-slowly [10 10 10])))\n\"Elapsed time: 4002.05885 msecs\"\n(100 100 100)\n```", "```java\nuser> (def pool (cp/priority-threadpool (cp/ncpus))\n#'user/pool\nuser> (def task-1 (cp/pmap (cp/with-priority pool 1000)\n square-slowly [10 10 10]))\n#'user/task-1\nuser> (def task-2 (cp/pmap (cp/with-priority pool 0)\n square-slowly [5 5 5]))\n#'user/task-2\n```", "```java\n(defn square-slowly-with-pool [v]\n  (cp/with-shutdown! [pool (cp/threadpool (cp/ncpus))]\n    (doall (cp/pmap pool square-slowly v))))\n```", "```java\nuser> (def lazy-pmap (cpl/pmap pool square-slowly (range)))\n#'user/lazy-pmap\nuser> (time (doall (take 4 lazy-pmap)))\n\"Elapsed time: 4002.556548 msecs\"\n(0 1 4 9)\n```", "```java\n(defn square-with-side-effect [x]\n  (do\n    (println (str \"Side-effect: \" x))\n    (* x x)))\n```", "```java\nuser> (def mapped (map square-with-side-effect [0 1 2 3 4 5]))\n#'user/mapped\nuser> (reduce + (take 3 mapped))\nSide-effect: 0\nSide-effect: 1\nSide-effect: 2\nSide-effect: 3\nSide-effect: 4\nSide-effect: 5\n5\n```", "```java\n(defn map [f coll]\n  (cons (f (first coll))\n        (lazy-seq (map f (rest coll)))))\n```", "```java\nuser> (first (map #(do (print \\!) %) (range 70)))\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n0\nuser> (nth (map #(do (print \\!) %) (range 70)) 32)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n32\n```", "```java\n(ns my-namespace\n  (:require [clojure.core.reducers :as r]))\n```", "```java\n(defn mapping [f]\n  (fn [rf]\n    (fn [result input]\n      (rf result (f input)))))\n\n(defn filtering [p?]\n  (fn [rf]\n    (fn [result input]\n      (if (p? input)\n        (rf result input)\n        result))))\n\n(defn mapcatting [f]\n  (fn [rf]\n    (fn [result input]\n      (reduce rf result (f input)))))\n```", "```java\n(defprotocol CollReduce\n  (coll-reduce [coll rf init]))\n```", "```java\n(defn reducer\n  ([coll xf]\n   (reify\n     CollReduce\n     (coll-reduce [_ rf init]\n       (coll-reduce coll (xf rf) init)))))\n```", "```java\n(defn reduce\n  ([rf coll]\n   (reduce rf (rf) coll))\n  ([rf init coll]\n   (coll-reduce coll rf init)))\n```", "```java\nuser> (r/reduce + 0 (r/reducer [1 2 3 4] (mapping inc)))\n14\nuser> (reduce + 0 (r/reducer [1 2 3 4] (mapping inc)))\n14\n```", "```java\n(defn map [f coll]\n  (reducer coll (mapping f)))\n\n(defn filter [p? coll]\n  (reducer coll (filtering p?)))\n\n(defn mapcat [f coll]\n  (reducer coll (mapcatting f)))\n```", "```java\nuser> (r/reduce + (r/map inc [1 2 3 4]))\n14\nuser> (r/reduce + (r/filter even? [1 2 3 4]))\n6\nuser> (r/reduce + (r/mapcat range [1 2 3 4]))\n10\n```", "```java\nuser> (def mapped (r/map square-with-side-effect [0 1 2 3 4 5]))\n#'user/mapped\nuser> (reduce + (r/take 3 mapped))\nSide-effect: 0\nSide-effect: 1\nSide-effect: 2\nSide-effect: 3\n5\n```", "```java\n(defn process [nums]\n  (reduce + (map inc (map inc (map inc nums)))))\n\n(defn process-with-reducer [nums]\n  (reduce + (r/map inc (r/map inc (r/map inc nums)))))\n```", "```java\nuser> (def nums (vec (range 1000000)))\n#'user/nums\nuser> (time (process nums))\n\"Elapsed time: 471.217086 msecs\"\n500002500000\nuser> (time (process-with-reducer nums))\n\"Elapsed time: 356.767024 msecs\"\n500002500000\n```", "```java\n(defprotocol CollFold\n  (coll-fold [coll n cf rf]))\n```", "```java\n(defn folder\n  ([coll xf]\n   (reify\n     CollReduce\n     (coll-reduce [_ rf init]\n       (coll-reduce coll (xf rf) init))\n     CollFold\n     (coll-fold [_ n cf rf]\n       (coll-fold coll n cf (xf rf))))))\n```", "```java\n(defn fold\n  ([rf coll]\n   (fold rf rf coll))\n  ([cf rf coll]\n   (fold 512 cf rf coll))\n  ([n cf rf coll]\n   (coll-fold coll n cf rf)))\n```", "```java\n(defn monoid\n  [op ctor]\n  (fn\n    ([] (ctor))\n    ([a b] (op a b))))\n```", "```java\n(defn map [f coll]\n  (folder coll (mapping f)))\n\n(defn filter [p? coll]\n  (folder coll (filtering p?)))\n\n(defn mapcat [f coll]\n  (folder coll (mapcatting f)))\n```", "```java\n(defn process-with-folder [nums]\n  (r/fold + (r/map inc (r/map inc (r/map inc nums)))))\n```", "```java\nuser> (def nums (vec (range 1000000)))\n#'user/nums\nuser> (time (process nums))\n\"Elapsed time: 474.240782 msecs\"\n500002500000\nuser> (time (process-with-reducer nums))\n\"Elapsed time: 364.945748 msecs\"\n500002500000\nuser> (time (process-with-folder nums))\n\"Elapsed time: 241.057025 msecs\"\n500002500000\n```", "```java\n[iota \"1.1.2\"]\n```", "```java\n(ns my-namespace\n  (:require [iota :as i]\n            [clojure.string :as cs]\n            [clojure.core.reducers :as r]))\n```", "```java\nbrown  brian  :m  :child    :east\nsmith  bill   :f  :child    :south\njones  jill   :f  :parent   :west\n```", "```java\nuser> (time (def file-as-seq (i/seq \"resources/data/sample.tsv\")))\n\"Elapsed time: 0.905326 msecs\"\n#'user/file-as-seq\nuser> (time (def file-as-vec (i/vec \"resources/data/sample.tsv\")))\n\"Elapsed time: 4.95506 msecs\"\n#'user/file-as-vec\n```", "```java\nuser> (time (def first-100-lines (doall (take 100 file-as-seq))))\n\"Elapsed time: 63.470598 msecs\"\n#'user/first-100-lines\nuser> (time (def first-100-lines (doall (take 100 file-as-vec))))\n\"Elapsed time: 0.984128 msecs\"\n#'user/first-100-lines\n```", "```java\n(defn into-records [file]\n  (->> file\n       (r/filter identity)\n       (r/map #(cs/split % #\"[\\t]\"))))\n```", "```java\n(defn count-females [coll]\n  (->> coll\n       (r/map #(-> (nth % 2)\n                   ({\":m\" 0 \":f\" 1})))\n       (r/fold +)))\n```", "```java\nuser> (-> file-as-seq into-records count-females)\n10090\nuser> (-> file-as-vec into-records count-females)\n10090\n```", "```java\n(defn get-children-names-in-family [coll family]\n  (->> coll\n       (r/filter #(and (= (nth % 0) family)\n                       (= (nth % 3) \":child\")))\n       (r/map #(nth % 1))\n       (into [])))\n```", "```java\nuser> (-> file-as-seq into-records\n (get-children-names-in-family \"brown\"))\n[\"sue\" \"walter\" ... \"jill\"]\nuser> (-> file-as-vec into-records\n (get-children-names-in-family \"brown\"))\n[\"sue\" \"walter\" ... \"jill\"]\n```", "```java\nuser> (read (-> \"(list 1 2 3)\"\n .toCharArray\n java.io.CharArrayReader.\n java.io.PushbackReader.))\n(list 1 2 3)\n```", "```java\nuser> (read-string \"(list 1 2 3)\")\n(list 1 2 3)\n```", "```java\nuser> (eval '(list 1 2 3))\n(1 2 3)\nuser> (eval (list + 1 2 3))\n6\nuser> (eval (read-string \"(+ 1 2 3)\"))\n6\n```", "```java\nuser> (read (-> \"#=(list 1 2 3)\"\n .toCharArray\n java.io.CharArrayReader.\n java.io.PushbackReader.))\n(1 2 3)\nuser> (read-string \"#=(list 1 2 3)\")\n(1 2 3)\n```", "```java\nuser> #=(list + 1 2 3)\n6\nuser> (read-string \"#=(list + 1 2 3)\")\n(+ 1 2 3)\nuser> (read-string \"#=#=(list + 1 2 3)\")\n6\n```", "```java\nuser> (binding [*read-eval* false]\n (read-string (read-string \"#=(list 1 2 3)\")))\nRuntimeException EvalReader not allowed when *read-eval* is false. clojure.lang.Util.runtimeException (Util.java:221)\n```", "```java\nuser> (load-string \"(+ 1 2 3)\")\n6\n```", "```java\nuser> (eval (read-string \"(println 1) (println 2)\"))\n1\nnil\nuser> (load-string \"(println 1) (println 2)\")\n1\n2\nnil\n```", "```java\nuser> 'x\nx\nuser> (quote x)\nx\n```", "```java\nuser> (def a 1)\n#'user/a\nuser> `(list ~a 2 3)\n(clojure.core/list 1 2 3)\nuser> `(list ~@[1 2 3])\n(clojure.core/list 1 2 3)\n```", "```java\nuser> (def a 1)\n#'user/a\nuser> `(list ~a 2 3)\n(clojure.core/list 1 2 3)\nuser> '(list ~a 2 3)\n(list (clojure.core/unquote a) 2 3)\n```", "```java\nuser> `(vector x y z)\n(clojure.core/vector user/x user/y user/z)\nuser> `(vector ~'x ~'y ~'z)\n(clojure.core/vector x y z)\n```", "```java\nuser> `[1 :b ~(+ 1 2)]\n[1 :b 3]\nuser> `[1 :b '~(+ 1 2)]\n[1 :b (quote 3)]\nuser> `[1 ~'b ~(+ 1 2)]\n[1 b 3]\n```", "```java\nuser> (def ops ['first 'second])\n#'user/ops\nuser> `{:a (~(nth ops 0) ~'xs)\n :b (~(nth ops 1) ~'xs)}\n{:b (second xs),\n :a (first xs)}\n```", "```java\nuser> (-> [0 1 2] first inc)\n1\nuser> (-> [0 1 2] (-> first inc))\n1\nuser> (-> (-> [0 1 2] first) inc)\n1\n```", "```java\nuser> (macroexpand '(-> [0 1 2] first inc))\n(inc (first [0 1 2]))\n```", "```java\nuser> (macroexpand-1 '(-> [0 1 2] (-> first inc)))\n(-> [0 1 2] first inc)\nuser> (macroexpand '(-> [0 1 2] (-> first inc)))\n(inc (first [0 1 2]))\n```", "```java\nuser> (macroexpand-1 '(-> (-> [0 1 2] first) inc))\n(inc (-> [0 1 2] first))\nuser> (macroexpand '(-> (-> [0 1 2] first) inc))\n(inc (-> [0 1 2] first))\n```", "```java\nuser> (clojure.walk/macroexpand-all '(-> (-> [0 1 2] first) inc))\n(inc (first [0 1 2]))\n```", "```java\n(defmacro to-infix [expr]\n  (interpose (first expr) (rest expr)))\n\n(defmacro to-postfix [expr]\n  (concat (rest expr) [(first expr)]))\n```", "```java\nuser> (macroexpand '(to-infix (+ 0 1 2)))\n(0 + 1 + 2)\nuser> (macroexpand '(to-postfix (+ 0 1 2)))\n(0 1 2 +)\n```", "```java\nuser> (fn? @#'to-infix)\ntrue\nuser> (fn? @#'to-postfix)\ntrue\n```", "```java\n(ns my-cljs-namespace\n  (:require-macros [my-clj-macro-namespace :as macro]))\n```", "```java\nuser> (symbol 'x)\nx\nuser> (symbol \"x\")\nx\nuser> (symbol \"my-namespace\" \"x\")\nmy-namespace/x\n```", "```java\nuser> (gensym)\nG__8090\nuser> (gensym 'x)\nx8081\nuser> (gensym \"x\")\nx8084\nuser> (gensym :x)\n:x8087\n```", "```java\nuser> `(let [x# 10] x#)\n(clojure.core/let [x__8561__auto__ 10]\n  x__8561__auto__)\nuser> (macroexpand `(let [x# 10] x#))\n(let* [x__8910__auto__ 10]\n  x__8910__auto__)\n```", "```java\n(defmacro to-list [x]\n  `(list ~x))\n\n(defmacro to-list-with-capture [x]\n  `(list ~'x))\n```", "```java\nuser> (let [x 10]\n (to-list 20))\n(20)\nuser> (let [x 10]\n (to-list-with-capture 20))\n(10)\n```", "```java\n(defmacro to-list-with-error [x]\n  `(let [y ~x]\n     (list y)))\n```", "```java\nuser> (to-list-with-error 10)\nCompilerException java.lang.RuntimeException:\nCan't let qualified name: user/y\n```", "```java\n(defmacro to-list-with-gensym [x]\n  `(let [y# ~x]\n     (list y#)))\n```", "```java\nuser> (to-list-with-gensym 10)\n(10)\n```", "```java\n(defmacro -> [x & forms]\n  (loop [x x\n         forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta\n                         `(~(first form) ~x ~@(next form))\n                         (meta form))\n                       (list form x))]\n        (recur threaded (next forms)))\n      x)))\n\n(defmacro ->> [x & forms]\n  (loop [x x\n         forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta\n                         `(~(first form) ~@(next form) ~x)\n                         (meta form))\n                       (list form x))]\n        (recur threaded (next forms)))\n      x)))\n```", "```java\n(defn thread-form [first? x form]\n  (if (seq? form)\n    (let [[f & xs] form\n          xs (conj (if first? xs (vec xs)) x)]\n      (apply list f xs))\n    (list form x)))\n\n(defn threading [first? x forms]\n  (reduce #(thread-form first? %1 %2)\n          x forms))\n```", "```java\n(defmacro -> [x & forms]\n  (threading true x forms))\n\n(defmacro ->> [x & forms]\n  (threading false x forms))\n```", "```java\n(defmacro as-> [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) forms)]\n     ~name))\n```", "```java\nuser> (macroexpand '(as-> 1 x (+ 1 x) (+ x 1)))\n(let* [x 1\n       x (+ 1 x)\n       x (+ x 1)]\n      x)\nuser> (as-> 1 x (+ 1 x) (+ x 1))\n3\n```", "```java\nuser> (read-string {:read-cond :allow :features #{:clj}}\n \"#?(:cljs \\\"ClojureScript\\\" :clj \\\"Clojure\\\")\")\n\"Clojure\"\nuser> (read-string {:read-cond :allow :features #{:cljs}}\n \"#?(:cljs \\\"ClojureScript\\\" :clj \\\"Clojure\\\")\")\n\"ClojureScript\"\n```", "```java\nuser> (read-string {:read-cond :allow :features #{:clr}}\n \"[1 2 #?@(:cljs [3 4] :default [5 6])]\")\n[1 2 5 6]\nuser> (read-string {:read-cond :allow :features #{:clj}}\n \"[1 2 #?@(:cljs [3 4] :default [5 6])]\")\n[1 2 5 6]\nuser> (read-string {:read-cond :allow :features #{:cljs}}\n \"[1 2 #?@(:cljs [3 4] :default [5 6])]\")\n[1 2 3 4]\n```", "```java\nuser> (read-string {:read-cond :preserve}\n \"[1 2 #?@(:cljs [3 4] :clj [5 6])]\")\n[1 2 #?@(:cljs [3 4] :clj [5 6])]\n```", "```java\n(defmacro get-milliseconds-since-epoch []\n  `(.getTime #?(:cljs (js/Date.)\n                :clj (java.util.Date.))))\n```", "```java\nuser> (macroexpand '(get-milliseconds-since-epoch))\n(. (java.util.Date.) getTime)\n```", "```java\nuser> (def xf-using-partial (comp\n (partial filter even?)\n (partial map inc)))\n#'user/xf-using-partial\nuser> (xf-using-partial (vec (range 10)))\n(2 4 6 8 10)\n```", "```java\n(declare unbundle-pallet)\n(declare non-food?)\n(declare label-heavy)\n\n(def process-bags\n  (comp\n   (partial map label-heavy)\n   (partial filter non-food?)\n   (partial mapcat unbundle-pallet)))\n```", "```java\n(def process-bags\n  (comp\n   (mapcat unbundle-pallet)\n   (filter non-food?)\n   (map label-heavy)))\n```", "```java\nuser> (def xf (map inc))\n#'user/xf\nuser> (transduce xf conj [0 1 2])\n[1 2 3]\nuser> (transduce xf conj () [0 1 2])\n(3 2 1)\n```", "```java\nuser> (def xf (comp\n (map inc)\n (filter even?)))\n#'user/xf\nuser> (transduce xf conj (range 10))\n[2 4 6 8 10]\n```", "```java\nuser> (into [] xf (range 10))\n[2 4 6 8 10]\nuser> (into () xf (range 10))\n(10 8 6 4 2)\n```", "```java\nuser> (sequence xf (range 10))\n(2 4 6 8 10)\n```", "```java\n(def simple-eduction (eduction (map inc)\n                               (filter even?)\n                               (range)))\n```", "```java\nuser> (time (nth simple-eduction 100000))\n\"Elapsed time: 65.904434 msecs\"\n200001\nuser> (time (nth (map inc (filter even? (range))) 100000))\n\"Elapsed time: 159.039363 msecs\"\n200001\n```", "```java\nuser> (def v (volatile! 0))\n#'user/v\nuser> @v\n0\nuser> (vreset! v 1)\n1\n```", "```java\nuser> (vswap! v inc)\n2\nuser> (vswap! v + 3)\n5\n```", "```java\n(defn map\n  ([f]\n   (fn [step]\n     (fn\n       ([] (step))\n       ([result] (step result))\n       ([result input]\n        (step result (f input))))))\n  ([f coll]\n   (sequence (map f) coll)))\n```", "```java\n(defn filter\n  ([p?]\n   (fn [step]\n     (fn\n       ([] (step))\n       ([result] (step result))\n       ([result input]\n        (if (p? input)\n          (step result input)\n          result)))))\n  ([p? coll]\n   (sequence (filter p?) coll)))\n```", "```java\nuser> (def r (reduced 0))\n#'user/r\nuser> (reduced? r)\ntrue\n```", "```java\n(defn rf [result input]\n  (if (< result 100)\n    (+ result input)\n    (reduced :too-big)))\n```", "```java\nuser> (reduce rf (range 3))\n3\nuser> (reduce rf (range 100))\n:too-big\n```", "```java\n(defn take-while [p?]\n  (fn [step]\n    (fn\n      ([] (step))\n      ([result] (step result))\n      ([result input]\n       (if (p? input)\n         (step result input)\n         (reduced result))))))\n```", "```java\n(defn take [n]\n  (fn [step]\n    (let [nv (volatile! n)]\n      (fn\n        ([] (step))\n        ([result] (step result))\n        ([result input]\n         (let [n @nv\n               nn (vswap! nv dec)\n               result (if (pos? n)\n                        (step result input)\n                        result)]\n           (if (not (pos? nn))\n             (ensure-reduced result)\n             result)))))))\n```", "```java\n(defn transduce\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n   (let [xf (xform f)\n         ret (if (instance? clojure.lang.IReduceInit coll)\n               (.reduce ^clojure.lang.IReduceInit coll xf init)\n               (clojure.core.protocols/coll-reduce coll xf init))]\n     (xf ret))))\n```", "```java\nuser> (name :x)\n\"x\"\nuser> (symbol \"x\")\nx\nuser> ((comp symbol name) :x)\nx\n```", "```java\n[funcool/cats \"1.0.0\"]\n```", "```java\n(ns my-namespace\n  (:require [cats.core :as cc]\n            [cats.builtin :as cb]\n            [cats.applicative.validation :as cav]\n            [cats.monad.maybe :as cmm]\n            [cats.monad.identity :as cmi]\n            [cats.monad.exception :as cme]))\n```", "```java\nuser> (cc/mappend \"12\" \"34\" \"56\")\n\"123456\"\nuser> (cc/mappend [1 2] [3 4] [5 6])\n[1 2 3 4 5 6]\n```", "```java\nuser> @(cc/mappend (cmm/just \"123\")\n (cmm/just \"456\"))\n\"123456\"\nuser> @(cc/mappend (cmm/just \"123\")\n (cmm/nothing)\n (cmm/just \"456\"))\n\"123456\"\n```", "```java\nuser> (map inc [0 1 2])\n(1 2 3)\nuser> (cc/fmap inc [0 1 2])\n[1 2 3]\n```", "```java\nuser> (cc/<$> inc (lazy-seq '(1)))\n(2)\nuser> (cc/<$> inc #{1})\n#{2}\n```", "```java\nuser> (cc/fmap inc (cmm/just 1))\n#<Just@ff5df0: 2>\nuser> (cc/fmap inc (cmm/nothing))\n#<Nothing@d4fb58: nil>\n```", "```java\n    user> (cc/<$> identity [0 1 2])\n    [0 1 2]\n    ```", "```java\n    user> (->> [0 1 2]\n     (cc/<$> inc)\n     (cc/<$> (partial + 2)))\n    [3 4 5]\n    user> (cc/<$> (comp (partial + 2) inc) [0 1 2])\n    [3 4 5]\n    ```", "```java\nuser> @(cc/fapply (cmm/just inc)\n (cmm/just 1))\n2\n```", "```java\nuser> (cc/pure cmm/context 1)\n#<Just@cefb4d: 1>\n```", "```java\nuser> @(cc/alet [a (cmm/just [1 2 3])\n b (cmm/just [4 5 6])]\n (cc/mappend a b))\n[1 2 3 4 5 6]\n```", "```java\n(defn validate-page-author [page]\n  (if (nil? (:author page))\n    (cav/fail {:author \"No author\"})\n    (cav/ok page)))\n\n(defn validate-page-number [page]\n  (if (nil? (:number page))\n    (cav/fail {:number \"No page number\"})\n    (cav/ok page)))\n\n(defn validate-page [page]\n  (cc/alet [a (validate-page-author page)\n            b (validate-page-number page)]\n    (cc/<*> (cc/pure cav/context page) \n            a b)))\n```", "```java\nuser> (validate-page {:text \"Some text\"})\n#<Fail@1203b6a: {:author \"No author\", :number \"No page number\"}>\nuser> (validate-page {:text \"Some text\" :author \"John\" :number 1})\n#<Ok@161b2f8: {:text \"Some text\", :author \"John\", :number 1}>\n```", "```java\nbind : (Monad A a, [A -> Monad B] f) -> Monad B\nreturn : (A a) -> Monad A\n```", "```java\nuser> (cc/bind (cmm/just 1) inc)\n2\nuser> (cc/bind (cmm/nothing) inc)\n#<Nothing@24e44b: nil>\n```", "```java\nuser> (cc/bind (cmm/just 1) #(-> % inc cc/return))\n#<Just@208e3: 1>\nuser> (cc/bind (cmm/nothing) #(-> % inc cc/return))\n#<Nothing@1e7075b: nil>\n```", "```java\nuser> ((cc/lift-m inc) (cmm/just 1))\n#<Just@1eaaab: 2>\n```", "```java\nuser> (cc/>>= (cc/>>= (cmm/just 1)\n #(-> % inc cmm/just))\n #(-> % dec cmm/just))\n#<Just@91ea3c: 1>\n```", "```java\nuser> (cc/>>= (cc/>>= (cmm/just 1)\n #(-> % inc cmm/just))\n #(-> % dec cmi/identity))\n#<Identity@dd6793: 1>\n```", "```java\n(defn process-with-maybe [x]\n  (cc/mlet [a (if (even? x)\n                (cmm/just x)\n                (cmm/nothing))\n            b (do\n                (println (str \"Incrementing \" a))\n                (-> a inc cmm/just))]\n    b))\n```", "```java\nuser> (process-with-maybe 2)\nIncrementing 2\n3\nuser> (process-with-maybe 3)\n#<Nothing@1ebd3fe: nil>\n```", "```java\nuser> (cme/success 1)\n#<Success@441a312 [1]>\nuser> (cme/failure {:error (Exception.)})\n#<Failure@4812b43 [#<java.lang.Exception>]>\nuser> (cme/try-on 1)\n#<Success@5141a5 [1]>\nuser> @(cme/try-on 1)\n1\n```", "```java\nuser> (cme/try-on (/ 1 0))\n#<Failure@bc1115 [#<java.lang.ArithmeticException>]>\nuser> (cme/try-on (-> 1 (/ 0) inc))\n#<Failure@f2d11a [#<java.lang.ArithmeticException>]>\n```", "```java\nuser> (cc/bind (cme/try-on (/ 1 1)) #(-> % inc cc/return))\n#<Success@116ea43 [2]>\nuser> (cc/bind (cme/try-on (/ 1 0)) #(-> % inc cc/return))\n#<Failure@0x1c90acb [#<java.lang.ArithmeticException>]>\n```", "```java\nuser> (cme/try-or-else (/ 1 0) 0)\n#<Success@bd15e6 [0]>\nuser> (cme/try-or-recover (/ 1 0)\n (fn [e]\n (if (instance? ArithmeticException e)\n 0\n :error)))\n0\n```", "```java\n[org.clojure/core.logic \"0.8.10\"]\n```", "```java\n(ns my-namespace\n  (:require [clojure.core.logic :as l]\n            [clojure.core.logic.fd :as fd]))\n```", "```java\nuser> (l/run* [x]\n (l/== x 1))\n(1)\nuser> (l/run* [x]\n (l/== 1 0))\n()\n```", "```java\nuser> (l/run* [x]\n (l/!= 1 1))\n()\nuser> (l/run* [x]\n (l/== 1 1))\n(_0)\n```", "```java\nuser> (l/run* [x]\n (l/conso 1 [2 x]\n [1 2 3]))\n(3)\n```", "```java\nuser> (l/run* [x y]\n (l/== x y)\n (l/== y 1))\n([1 1])\nuser> (l/run* [x]\n (l/fresh [y]\n (l/== x y)\n (l/== y 1)))\n(1)\n```", "```java\nuser> (l/run 5 [x]\n (fd/in x (fd/interval 0 100))\n (fd/> x 10))\n(11 12 13 14 15)\n```", "```java\nuser> (l/run 1 [v a b x]\n (l/== v [a b])\n (fd/in a b x (fd/domain 0 1 2))\n (fd/< a b)\n (l/firsto v x))\n([[0 1] 0 1 0])\n```", "```java\nuser> (l/run* [x]\n (l/conde\n ((l/== 'A x) l/succeed)\n ((l/== 'B x) l/succeed)\n ((l/== 'C x) l/fail)))\n(A B)\n```", "```java\nuser> (l/run* [x]\n (l/conde\n ((l/== 'A x) l/succeed)\n ((l/== 'B x) l/succeed)))\n(A B)\nuser> (l/run* [x]\n (l/matche [x]\n (['A] l/succeed)\n (['B] l/succeed)))\n(A B)\n```", "```java\nuser> (l/run* [x]\n (l/matche [x]\n (['A])\n ([_] l/fail)))\n(A)\n```", "```java\nuser> (l/run* [x]\n (l/fresh [y]\n (l/== y [1 2 3])\n (l/matche [y]\n ([[1 . x]]))))\n((2 3))\n```", "```java\n(l/defne membero [x xs]\n  ([_ [x . ys]])\n  ([_ [y . ys]]\n   (membero x ys)))\n```", "```java\nuser> (l/run* [x]\n (membero x (range 5))\n (membero x (range 3 10)))\n(3 4)\n```", "```java\nuser> (l/run 2 [x y]\n (l/membero x (range 1 10))\n (l/membero y (range 1 10))\n (l/project [x y]\n (l/== (+ x y) 5)))\n([1 4] [2 3])\n```", "```java\n(l/defne safeo [q qs]\n  ([_ ()])\n  ([[x1 y1] [[x2 y2] . t]]\n     (l/!= x1 x2)\n     (l/!= y1 y2)\n     (l/project [x1 x2 y1 y2]\n       (l/!= (- x2 x1) (- y2 y1))\n       (l/!= (- x1 x2) (- y2 y1)))\n     (safeo [x1 y1] t)))\n\n(l/defne nqueenso [n qs]\n  ([_ ()])\n  ([n [[x y] . t]]\n     (nqueenso n t)\n     (l/membero x (range n))\n     (safeo [x y] t)))\n\n(defn solve-nqueens [n]\n  (l/run* [qs]\n    (l/== qs (map vector (repeatedly l/lvar) (range n)))\n    (nqueenso n qs)))\n```", "```java\n(defn print-nqueens-solution [solution n]\n  (let [solution-set (set solution)\n        positions (for [x (range n)\n                        y (range n)]\n                    (if (contains? solution-set [x y]) 1 0))]\n    (binding [clojure.pprint/*print-right-margin* (* n n)]\n      (clojure.pprint/pprint\n       (partition n positions)))))\n\n(defn print-all-nqueens-solutions [solutions n]\n  (dorun (for [i (-> solutions count range)\n               :let [s (nth solutions i)]]\n           (do\n             (println (str \"\\nSolution \" (inc i) \":\"))\n             (print-nqueens-solution s n)))))\n\n(defn solve-and-print-nqueens [n]\n  (-> (solve-nqueens n)\n      (print-all-nqueens-solutions n)))\n```", "```java\nuser> (solve-and-print-nqueens 4)\n\nSolution 1:\n((0 1 0 0)\n (0 0 0 1)\n (1 0 0 0)\n (0 0 1 0))\n\nSolution 2:\n((0 0 1 0)\n (1 0 0 0)\n (0 0 0 1)\n (0 1 0 0))\nnil\n```", "```java\n(l/defne init-sudoku-board [vars puzzle]\n  ([[] []])\n  ([[_ . vs] [0 . ps]] (init-sudoku-board vs ps))\n  ([[n . vs] [n . ps]] (init-sudoku-board vs ps)))\n\n(defn solve-sudoku [puzzle]\n  (let [board (repeatedly 81 l/lvar)\n        rows (into [] (map vec (partition 9 board)))\n        cols (apply map vector rows)\n        val-range (range 1 10)\n        in-range (fn [x]\n                   (fd/in x (apply fd/domain val-range)))\n        get-square (fn [x y]\n                     (for [x (range x (+ x 3))\n                           y (range y (+ y 3))]\n                       (get-in rows [x y])))\n        squares (for [x (range 0 9 3)\n                      y (range 0 9 3)]\n                  (get-square x y))]\n    (l/run* [q]\n      (l/== q board)\n      (l/everyg in-range board)\n      (init-sudoku-board board puzzle)\n      (l/everyg fd/distinct rows)\n      (l/everyg fd/distinct cols)\n      (l/everyg fd/distinct squares))))\n```", "```java\n(defn solve-and-print-sudoku [puzzle]\n  (let [solutions (solve-sudoku puzzle)]\n    (dorun (for [i (-> solutions count range)\n                 :let [s (nth solutions i)]]\n             (do\n               (println (str \"\\nSolution \" (inc i) \":\"))\n               (clojure.pprint/pprint\n                (partition 9 s)))))))\n```", "```java\n(def puzzle-1\n  [0 9 0 0 0 0 0 5 0\n   6 0 0 0 5 0 0 0 2\n   1 0 0 8 0 4 0 0 6\n   0 7 0 0 8 0 0 3 0\n   8 0 3 0 0 0 2 0 9\n   0 5 0 0 3 0 0 7 0\n   7 0 0 3 0 2 0 0 5\n   3 0 0 0 6 0 0 0 7\n   0 1 0 0 0 0 0 4 0])\n```", "```java\nuser> (solve-and-print-sudoku puzzle-1)\n\nSolution 1:\n((4 9 8 6 2 3 7 5 1)\n (6 3 7 9 5 1 4 8 2)\n (1 2 5 8 7 4 3 9 6)\n (9 7 1 2 8 6 5 3 4)\n (8 4 3 5 1 7 2 6 9)\n (2 5 6 4 3 9 1 7 8)\n (7 6 9 3 4 2 8 1 5)\n (3 8 4 1 6 5 9 2 7)\n (5 1 2 7 9 8 6 4 3))\nnil\n```", "```java\n(def puzzle-2\n  [0 8 0 0 0 9 7 4 3\n   0 5 0 0 0 8 0 1 0\n   0 1 0 0 0 0 0 0 0\n   8 0 0 0 0 5 0 0 0\n   0 0 0 8 0 4 0 0 0\n   0 0 0 3 0 0 0 0 6\n   0 0 0 0 0 0 0 7 0\n   0 3 0 5 0 0 0 8 0\n   9 7 2 4 0 0 0 5 0])\n```", "```java\n[org.clojure/core.async \" 0.1.346.0-17112a-alpha\"]\n```", "```java\n(ns my-namespace\n  (:require [clojure.core.async :as a]))\n```", "```java\n(defn wait-and-print [c]\n  (a/go-loop [n 1]\n    (let [v (a/<! c)]\n      (when v\n        (println (str \"Got a message: \" v))\n        (println (str \"Got \" n \" messages so far!\"))\n        (recur (inc n)))))\n  (println \"Waiting...\"))\n```", "```java\nuser> (def c (a/chan))\n#'user/c\nuser> (wait-and-print c)\nWaiting...\nnil\nuser> (a/>!! c :foo)\ntrue\nGot a message: :foo\nGot 1 messages so far!\nuser> (a/>!! c :bar)\ntrue\nGot a message: :bar\nGot 2 messages so far!\n```", "```java\nuser> (a/close! c)\nnil\nuser> (a/>!! c :foo)\nfalse\n```", "```java\nuser> (def c (a/chan 4))\n#'user/c\nuser> (a/onto-chan c (range 4))\n#<ManyToManyChannel@0x86f03a>\nuser> (repeatedly 4 #(-> c a/<!!))\n(0 1 2 3)\n```", "```java\n(defn process-channels [c0 c1 c2 c3 c4 c5]\n  (a/go\n    (a/alt!\n      ;; read from c0, c1, c2, c3\n      c0 :r\n      c1 ([v] (str v))\n      [c2 c3] ([v c] (str v))\n      ;; write to c4, c5\n      [[c4 :v1] [c5 :v2]] :w)))\n```", "```java\nuser> (time  (a/<!! (a/timeout 1000)))\n\"Elapsed time: 1029.502223 msecs\"\nnil\n```", "```java\nuser> (def c (a/chan 5))\n#'user/c\nuser> (a/onto-chan c (range 5))\n#<ManyToManyChannel@0x4adadd>\nuser> (def rc (a/reduce #(str %1 %2 \" \") \"\" c))\n#'user/rc\nuser> (a/<!! rc)\n\"0 1 2 3 4 \"\n```", "```java\n(def xform\n  (comp\n   (map inc)\n   (map #(* % 2))))\n```", "```java\nuser> (def xc (a/chan 10 xform))\n#'user/xc\nuser> (a/onto-chan xc (range 10) false)\n#<ManyToManyChannel@0x17d6a37>\nuser> (repeatedly 10 #(-> xc a/<!!))\n(2 4 6 8 10 12 14 16 18 20)\n```", "```java\n(ns my-namespace\n  (:require [clojure.core.async :as a]\n            [m-clj.c2.refs :as c2]))\n```", "```java\n(defn make-philosopher [name forks food]\n  {:name name\n   :forks forks\n   :food food})\n\n(defn make-forks [nf]\n  (let [forks (repeatedly nf #(a/chan 1))]\n    (doseq [f forks]\n      (a/>!! f :fork))\n    forks))\n```", "```java\n(defn philosopher-process [p-chan max-eat-ms max-think-ms]\n  (a/go-loop []\n    (let [p (a/<! p-chan)\n          food (:food p)\n          fork-1 ((:forks p) 0)\n          fork-2 ((:forks p) 1)\n          ;; take forks\n          fork-1-result (a/alt!\n                          (a/timeout 100) :timeout\n                          fork-1 :fork-1)\n          fork-2-result (a/alt!\n                          (a/timeout 100) :timeout\n                          fork-2 :fork-2)]\n      (if (and (= fork-1-result :fork-1)\n               (= fork-2-result :fork-2))\n        (do\n          ;; eat\n          (a/<! (a/timeout (rand-int max-eat-ms)))\n          ;; put down both acquired forks\n          (a/>! fork-1 :fork)\n          (a/>! fork-2 :fork)\n          ;; think\n          (a/<! (a/timeout (rand-int max-think-ms)))\n          (a/>! p-chan (assoc p :food (dec food))))\n        (do\n          ;; put down any acquired forks\n          (if (= fork-1-result :fork-1)\n            (a/>! fork-1 :fork))\n          (if (= fork-2-result :fork-2)\n            (a/>! fork-2 :fork))\n          (a/>! p-chan p)))\n      ;; recur\n      (when (pos? (dec food)) (recur)))))\n```", "```java\n(defn start-philosophers [p-chan philosophers]\n  (a/onto-chan p-chan philosophers false)\n  (dorun (repeatedly (count philosophers)\n                     #(philosopher-process p-chan 100 100)))) \n\n(defn print-philosophers [p-chan n]\n  (let [philosophers (repeatedly n #(a/<!! p-chan))]\n    (doseq [p philosophers]\n      (println (str (:name p) \":\\t food=\" (:food p)))\n      (a/>!! p-chan p))))\n```", "```java\n(def all-forks (make-forks 5))\n(def all-philosophers\n  (c2/init-philosophers 5 1000 all-forks make-philosopher))\n\n(def philosopher-chan (a/chan 5))\n```", "```java\nuser> (start-philosophers philosopher-chan all-philosophers)\nnil\nuser> (print-philosophers philosopher-chan 5)\nPhilosopher 3:   food=937\nPhilosopher 2:   food=938\nPhilosopher 1:   food=938\nPhilosopher 5:   food=938\nPhilosopher 4:   food=937\nnil\nuser> (print-philosophers philosopher-chan 5)\nPhilosopher 4:   food=729\nPhilosopher 1:   food=729\nPhilosopher 2:   food=729\nPhilosopher 5:   food=730\nPhilosopher 3:   food=728\nnil\n```", "```java\n[co.paralleluniverse/quasar-core \"0.7.3\"]\n[co.paralleluniverse/pulsar \"0.7.3\"]\n```", "```java\n:java-agents\n[[co.paralleluniverse/quasar-core \"0.7.3\"]]\n:jvm-opts\n[\"-Dco.paralleluniverse.pulsar.instrument.auto=all\"]\n```", "```java\n(ns my-namespace\n  (:require [co.paralleluniverse.pulsar.core :as pc]\n            [co.paralleluniverse.pulsar.actors :as pa]))\n```", "```java\n(def actor (pa/spawn\n            #(pa/receive\n              :finish (println \"Finished\")\n              m (do\n                  (println (str \"Received: \" m))\n                  (recur)))))\n```", "```java\nuser> (pa/! actor :foo)\nnil\nReceived: :foo\nuser> (pa/done? actor)\nfalse\n```", "```java\nuser> (pa/! actor :finish)\nnil\nFinished\nuser> (pa/done? actor)\ntrue\n```", "```java\n(def divide-actor\n  (pa/spawn\n   #(loop [c 0]\n      (pa/receive\n       :result c\n       [a b] (recur (/ a b))))))\n```", "```java\nuser> (pa/! divide-actor 30 10)\nnil\nuser> (pa/! divide-actor :result)\nnil\nuser> (pc/join divide-actor)\n3\n```", "```java\n(defn ping-fn [n pong]\n  (if (= n 0)\n    (do\n      (pa/! pong :finished)\n      (println \"Ping finished\"))\n    (do\n      (pa/! pong [:ping @pa/self])\n      (pa/receive\n       :pong (println \"Ping received pong\"))\n      (recur (dec n) pong))))\n\n(defn pong-fn []\n  (pa/receive\n   :finished (println \"Pong finished\")\n   [:ping ping] (do\n                  (println \"Pong received ping\")\n                  (pa/! ping :pong)\n                  (recur))))\n\n(defn start-ping-pong [n]\n  (let [pong (pa/spawn pong-fn)\n        ping (pa/spawn ping-fn n pong)]\n    (pc/join pong)\n    (pc/join ping)\n    :finished))\n```", "```java\nuser> (start-ping-pong 3)\nPong received ping\nPing received pong\nPong received ping\nPing received pong\nPong received ping\nPing received pong\nPing finished\nPong finished\n:finished\n```", "```java\n(defn add-using-state [a b]\n  (let [actor (pa/spawn\n               #(do\n                  (pa/set-state! 0)\n                  (pa/set-state! (+ @pa/state (pa/receive)))\n                  (pa/set-state! (+ @pa/state (pa/receive)))))]\n    (pa/! actor a)\n    (pa/! actor b)\n    (pc/join actor)))\n```", "```java\nuser> (add-using-state 10 20)\n30\n```", "```java\n(defn add-using-selective-receive [a b]\n  (let [actor (pa/spawn\n               #(do\n                  (pa/set-state! 0)\n                  (pa/receive\n                   m (pa/receive\n                      n (pa/set-state! (+ n m))))))]\n    (pa/! actor a)\n    (pa/! actor b)\n    (pc/join actor)))\n```", "```java\nuser> (add-using-selective-receive 10 20)\n30\n```", "```java\n[co.paralleluniverse/quasar-core \"0.7.3\"]\n[co.paralleluniverse/pulsar \"0.7.3\"]\n```", "```java\n:java-agents\n[[co.paralleluniverse/quasar-core \"0.7.3\"]]\n:jvm-opts\n[\"-Dco.paralleluniverse.pulsar.instrument.auto=all\"]\n```", "```java\n(ns my-namespace\n  (:require [co.paralleluniverse.pulsar.core :as pc]\n            [co.paralleluniverse.pulsar.dataflow\n             :as pd]))\n```", "```java\n(defn add-with-fiber [a b]\n  (let [f (pc/spawn-fiber\n               (fn []\n                 (pc/sleep 100)\n                 (+ a b)))]\n    (pc/join f)))\n```", "```java\n(defn df-add [a b]\n  (let [x (pd/df-val)\n        y (pd/df-val)\n        sum (pd/df-var #(+ @x @y))]\n    (x a)\n    (y b)\n    @sum))\n```", "```java\n(defn df-add-to-range [a r]\n  (let [x (pd/df-val)\n        y (pd/df-var)\n        sum (pd/df-var #(+ @x @y))\n        f (pc/fiber\n           (for [i r]\n             (do\n               (y i)\n               (pc/sleep 10)\n               @sum)))]\n    (x a)\n    (pc/join f)))\n```", "```java\nuser> (df-add-to-range 2 (range 10))\n(2 3 4 5 6 7 8 9 10 11)\n```", "```java\n[io.reactivex/rxclojure \"1.0.0\"]\n```", "```java\n(ns my-namespace\n  (:require [rx.lang.clojure.core :as rx]\n            [rx.lang.clojure.blocking :as rxb]\n            [rx.lang.clojure.interop :as rxj]))\n```", "```java\nuser> (def o (rx/return 0))\n#'user/o\nuser> (rxb/into [] o)\n[0]\nuser> (rxb/first o)\n0\n```", "```java\nuser> (def o (rx/seq->o [1 2 3]))\n#'user/o\nuser> (rxb/o->seq o)\n(1 2 3)\n```", "```java\nuser> (def o (rx/cons 0 (rx/empty)))\n#'user/o\nuser> (rxb/first o)\n0\n```", "```java\n(def observer\n  (reify rx.Observer\n    (onNext [this v] (println (str \"Got value: \" v \"!\")))\n    (onError [this e] (println e))\n    (onCompleted [this] (println \"Done!\"))))\n```", "```java\n(defn make-observable []\n  (rx/observable* (fn [s]\n                    (-> s\n                        (rx/on-next :a)\n                        (rx/on-next :b)\n                        rx/on-completed))))\n```", "```java\nuser> (def o (make-observable))\n#'user/o\nuser> (rxb/into [] o)\n[:a :b]\n```", "```java\n(defn rx-inc [o]\n  (rx/subscribe o (fn [v] (println (str \"Got value: \" v \"!\"))))\n  (rx/map inc o))\n```", "```java\nuser> (def o (rx/seq->o [0 1 2]))\n#'user/o\nuser> (rx-inc o)\nGot value: 0!\nGot value: 1!\nGot value: 2!\n#<rx.Observable 0xc3fae8>\n```", "```java\n(defn rxj-inc [o]\n  (.subscribe o (rxj/action [v]\n                  (println (str \"Got value: \" v \"!\"))))\n  (.map o (rxj/fn [v] (inc v))))\n```", "```java\nuser> (def o (rx.Observable/from [0 1 2]))\n#'user/o\nuser> (rxj-inc o)\nGot value: 0!\nGot value: 1!\nGot value: 2!\n#<rx.Observable 0x16459ef>\n```", "```java\nuser> (rxb/into [] (->> (rx/range)\n (rx/take 10)))\n[0 1 2 3 4 5 6 7 8 9]\nuser> (rxb/into [] (->> (rx/cycle (rx/return 1))\n (rx/take 5)))\n[1 1 1 1 1]\n```", "```java\nuser> (rxb/into [] (->> (rx/seq->o [:a :b :c :d :e])\n (rx/filter #{:b :c})))\n[:b :c]\n```", "```java\n(defn group-maps [ms]\n  (->> ms\n       (rx/seq->o)\n       (rx/group-by :k)\n       (rx/mapcat (fn [[k vs :as me]]\n                    (rx/map #(vector k %) vs)))\n       (rxb/into [])))\n```", "```java\nuser> (group-maps [{:k :a :v 1}\n {:k :b :v 2}\n {:k :a :v 3}\n {:k :c :v 4}])\n[[:a {:k :a, :v 1}]\n [:a {:k :a, :v 3}]\n [:b {:k :b, :v 2}]\n [:c {:k :c, :v 4}]]\n```", "```java\nuser> (let [o1 (rx/seq->o (range 5))\n o2 (rx/seq->o (range 5 10))\n o (rx/merge o1 o2)]\n (rxb/into [] o))\n[0 1 2 3 4 5 6 7 8 9]\n```", "```java\nuser> (->> (range 6)\n rx/seq->o\n (rx/split-with (partial >= 3))\n rxb/first\n (map (partial rxb/into [])))\n([0 1 2 3] [4 5])\n```", "```java\n[yolk \"0.9.0\"]\n```", "```java\n(ns my-namespace\n  (:require [yolk.bacon :as y]))\n```", "```java\n(defn ^:export by-id [id]\n  (.getElementById js/document id))\n\n(defn ^:export set-html! [el s]\n  (set! (.-innerHTML el) s))\n```", "```java\n$ lein cljsbuild once\n\n```", "```java\n<script type=\"text/javascript\" src=\"img/bacon.js\">\n</script>\n<script type=\"text/javascript\" src=\"img/yolk.js\">\n</script>\n```", "```java\n(defn render-philosophers [philosophers]\n  (apply str\n         (for [p (reverse philosophers)]\n           (str \"<div>\" p \"</div>\"))))\n\n(defn philosopher-fn [i n forks philosophers wait-ms]\n  (let [p (nth philosophers i)\n        fork-1 (nth forks i)\n        fork-2 (nth forks (-> i inc (mod n)))]\n    (fn []\n      (js/setTimeout\n       (fn []\n         (y/push fork-1 :fork)\n         (y/push fork-2 :fork)\n         (y/push p {}))\n       wait-ms)\n      (str \"Philosopher \" (inc i) \" ate!\"))))\n```", "```java\n(let [out (by-id \"ex-9-10-out\")\n      n 5\n      [f1 f2 f3 f4 f5 :as forks] (repeatedly n #(y/bus))\n      [p1 p2 p3 p4 p5 :as philosophers] (repeatedly n #(y/bus))\n      eat #(philosopher-fn % n forks philosophers 1000)\n      events (y/when [p1 f1 f2] (eat 0)\n                     [p2 f2 f3] (eat 1)\n                     [p3 f3 f4] (eat 2)\n                     [p4 f4 f5] (eat 3)\n                     [p5 f5 f1] (eat 4))]\n  (-> events\n      (y/sliding-window n)\n      (y/on-value\n       #(set-html! out (render-philosophers %))))\n  (doseq [f forks]\n    (y/push f :fork))\n  (doseq [p philosophers]\n    (y/push p {})))\n```", "```java\n[yolk \"0.9.0\"]\n[org.clojure/core.async \"0.1.346.0-17112a-alpha\"]\n```", "```java\n(ns my-namespace\n  (:require [goog.events :as events]\n            [goog.events.EventType]\n            [goog.style :as style]\n            [cljs.core.async :as a]\n            [yolk.bacon :as y])\n  (:require-macros [cljs.core.async.macros\n                    :refer [go go-loop alt!]]))\n```", "```java\n$ lein cljsbuild once\n\n```", "```java\n<script type=\"text/javascript\" src=\"img/bacon.js\">\n</script>\n<script type=\"text/javascript\" src=\"img/reactive.js\">\n</script>\n```", "```java\n(defn render-div [q]\n  (apply str\n         (for [p (reverse q)]\n           (str \"<div class='proc-\" p \"'>Process \" p \"</div>\"))))\n\n(defn start-process [v t]\n  (let [c (a/chan)]\n    (go (while true\n          (a/<! (a/timeout t))\n          (a/>! c v)))\n    c))\n\n(let [out (by-id \"ex-9-11-out\")\n      c1 (start-process 1 250)\n      c2 (start-process 2 1000)\n      c3 (start-process 3 1500)\n      c (a/merge [c1 c2 c3])\n      firstn (fn [v n]\n               (if (<= (count v) n)\n                 v\n                 (subvec v (- (count v) n))))]\n  (go-loop [q []]\n    (set-html! out (render-div q))\n    (recur (-> (conj q (a/<! c))\n               (firstn 10)))))\n```", "```java\n(let [out (by-id \"ex-9-12-out\")\n      events [(y/interval 250 1)\n              (y/interval 1000 2)\n              (y/interval 1500 3)]]\n  (-> events\n      y/merge-all\n      (y/sliding-window 10)\n      (y/on-value\n       #(set-html! out (render-div %)))))\n```", "```java\n(defn listen\n  ([el type] (listen el type nil))\n  ([el type f] (listen el type f (a/chan)))\n  ([el type f out]\n   (events/listen el type\n                  (fn [e] (when f (f e)) (a/put! out e)))\n   out))\n```", "```java\n(defn offset [el]\n  [(style/getPageOffsetLeft el) (style/getPageOffsetTop el)])\n\n(let [el (by-id \"ex-9-14\")\n      out (by-id \"ex-9-14-out\")\n      events-chan (listen el goog.events.EventType.MOUSEMOVE)\n      [left top] (offset el)\n      location (fn [e]\n                 {:x (+ (.-offsetX e) (int left))\n                  :y (+ (.-offsetY e) (int top))})]\n  (go-loop []\n    (if-let [e (a/<! events-chan)]\n      (let [loc (location e)]\n        (set-html! out (str (:x loc) \", \" (:y loc)))\n        (recur)))))\n```", "```java\n(let [el (by-id \"ex-9-15\")\n      out (by-id \"ex-9-15-out\")\n      events (y/from-event-target el \"mousemove\")]\n  (-> events\n      (y/map (juxt (fn [e] (.-pageX e))\n                   (fn [e] (.-pageY e))))\n      (y/map (fn [[x y]] (str x \", \" y)))\n      (y/on-value\n       #(set-html! out %))))\n```", "```java\n(defn chan-search [kind]\n  (fn [query]\n    (go\n      (a/<! (a/timeout (rand-int 100)))\n      [kind query])))\n\n(def chan-web1 (chan-search :web1))\n(def chan-web2 (chan-search :web2))\n(def chan-image1 (chan-search :image1))\n(def chan-image2 (chan-search :image2))\n(def chan-video1 (chan-search :video1))\n(def chan-video2 (chan-search :video2))\n```", "```java\n(defn chan-search-all [query & searches]\n  (let [cs (for [s searches]\n             (s query))]\n    (-> cs vec a/merge)))\n\n(defn chan-search-fastest [query]\n  (let [t (a/timeout 80)\n        c1 (chan-search-all query chan-web1 chan-web2)\n        c2 (chan-search-all query chan-image1 chan-image2)\n        c3 (chan-search-all query chan-video1 chan-video2)\n        c (a/merge [c1 c2 c3])]\n    (go (loop [i 0\n               ret []]\n          (if (= i 3)\n            ret\n            (recur (inc i)\n                   (conj ret (alt!\n                               [c t] ([v] v)))))))))\n```", "```java\n(let [out (by-id \"ex-9-18-out\")\n      button (by-id \"search-1\")\n      c (listen button goog.events.EventType.CLICK)]\n  (go (while true\n        (let [e (a/<! c)\n              result (a/<! (chan-search-fastest \"channels\"))\n              s (str result)]\n          (set-html! out s)))))\n```", "```java\n(defn frp-search [kind]\n  (fn [query]\n    (y/later (rand-int 100) [kind query])))\n\n(def frp-web1 (frp-search :web1))\n(def frp-web2 (frp-search :web2))\n(def frp-image1 (frp-search :image1))\n(def frp-image2 (frp-search :image2))\n(def frp-video1 (frp-search :video1))\n(def frp-video2 (frp-search :video2))\n```", "```java\n(defn frp-search-all [query & searches]\n  (let [results (map #(% query) searches)\n        events (cons (y/later 80 \"nil\") results)]\n    (-> (apply y/merge events)\n        (y/take 1))))\n\n(defn frp-search-fastest [query]\n  (y/combine-as-array\n   (frp-search-all query frp-web1 frp-web2)\n   (frp-search-all query frp-image1 frp-image2)\n   (frp-search-all query frp-video1 frp-video2)))\n```", "```java\n(let [out (by-id \"ex-9-21-out\")\n      button (by-id \"search-2\")\n      events (y/from-event-target button \"click\")]\n  (-> events\n      (y/flat-map-latest #(frp-search-fastest \"events\"))\n      (y/on-value\n       #(set-html! out %))))\n```", "```java\n[org.omcljs/om \"0.8.8\"]\n```", "```java\n(ns my-namespace\n  (:require [om.core :as om :include-macros true]\n            [om.dom :as dom :include-macros true]))\n```", "```java\n$ lein cljsbuild once\n\n```", "```java\n<script type=\"text/javascript\" src=\"img/om.js\">\n</script>\n```", "```java\n(defn update-input-value-fn [owner]\n  (fn [e]\n    (let [target (.-target e)\n          val (.-value target)\n          id (keyword (.-id target))]\n      (om/set-state! owner id val))))\n\n(defn input-field [text owner attrs]\n  (let [handler (update-input-value-fn owner)\n        event-attr {:onChange handler}\n        js-attrs (-> attrs (merge event-attr) clj->js)]\n    (dom/div\n     nil\n     (dom/div nil text)\n     (dom/input js-attrs))))\n```", "```java\n(defn form [data owner]\n  (reify\n    om/IInitState\n    (init-state [_]\n      {:username \"\" :password \"\"})\n    om/IRenderState\n    (render-state [_ state]\n      (dom/form\n       nil\n       (input-field \"Username\" owner\n                    {:type \"text\"\n                     :id \"username\"\n                     :value (:username state)})\n       (input-field \"Password\" owner\n                    {:type \"password\"\n                     :id \"password\"\n                     :value (:password state)})\n       (dom/br nil)\n       (dom/input\n        #js {:type \"submit\"\n             :value \"Login\"\n             :disabled (or (-> state :username empty?)\n                           (-> state :password empty?))})))))\n\n(om/root form nil {:target (by-id \"ex-9-23\")})\n```", "```java\n(ns my-namespace\n  (:require [clojure.test :refer :all]))\n```", "```java\n(deftest test-*\n  (is (= 6 (* 2 3)))\n  (is (= 4 (* 1 4)))\n  (is (= 6 (* 3 2))))\n\n(deftest test-*-with-are\n  (are [x y] (= 6 (* x y))\n    2 3\n    1 6\n    3 2))\n```", "```java\nuser> (run-tests)\n\nTesting ...\n\nRan 2 tests containing 6 assertions.\n0 failures, 0 errors.\n{:test 2, :pass 6, :fail 0, :error 0, :type :summary}\n```", "```java\n(deftest test-*-fails\n  (is (= 5 (* 2 3))))\n```", "```java\nuser> (run-tests)\n\nTesting ...\n\nFAIL in (test-*-fails) (test.clj:24)\nexpected: (= 5 (* 2 3))\n  actual: (not (= 5 6))\n\nRan 3 tests containing 7 assertions.\n1 failures, 0 errors.\n{:test 3, :pass 6, :fail 1, :error 0, :type :summary}\n```", "```java\n$ lein test my-namespace\n\n```", "```java\n[midje \"1.8.2\"]\n```", "```java\n[lein-midje \"3.1.3\"]\n```", "```java\n(ns my-namespace\n  (:require [midje.sweet :refer :all]\n            [midje.repl :as mr]))\n```", "```java\n(defn first-element [sequence default]\n  (if (empty? sequence)\n    default\n    (first sequence)))\n```", "```java\n(facts \"about first-element\"\n  (fact \"it returns the first element of a collection\"\n        (first-element [1 2 3] :default) => 1\n        (first-element '(1 2 3) :default) => 1)\n\n  (fact \"it returns the default value for empty collections\"\n        (first-element [] :default) => :default\n        (first-element '() :default) => :default\n        (first-element nil :default) => :default\n        (first-element\n         (filter even? [1 3 5])\n         :default) => :default))\n```", "```java\n(fact \"first-element returns the first element of a collection\"\n      (first-element ..seq.. :default) => :default\n      (provided\n       (empty? ..seq..) => true))\n```", "```java\n(defn is-diesel? [car])\n\n(defn cost-of-car [car])\n\n(defn overall-cost-of-car [car]\n  (if (is-diesel? car)\n    (* (cost-of-car car) 1.4)\n    (cost-of-car car)))\n```", "```java\n(fact\n  (overall-cost-of-car ..car..) => (* 5000 1.4)\n  (provided\n    (cost-of-car ..car..) => 5000\n    (is-diesel? ..car..) => true))\n```", "```java\nuser> (mr/autotest :files \"test\")\n\n====================================================================\nLoading ( ... )\n>>> Output from clojure.test tests:\n\n0 failures, 0 errors.\n>>> Midje summary:\nAll checks (8) succeeded.\n[Completed at ... ]\n```", "```java\n$ lein midje :autotest test\n\n```", "```java\n[speclj \"3.3.1\"]\n```", "```java\n(ns my-namespace\n  (:require [speclj.core :refer :all]))\n```", "```java\n(describe \"*\"\n  (it \"2 times 3 is 6\"\n    (should (= 6 (* 2 3)))))\n```", "```java\n(describe \"/\"\n  (it \"5 divided by 5 is 1\"\n    (should= 1 (/ 5 5)))\n  (it \"5 divided by 5 is not 0\"\n    (should-not= 0 (/ 5 5)))\n  (it \"fail if 5 divided by 5 is not 1\"\n    (if (not= 1 (/ 5 5))\n      (should-fail \"divide not working\")))\n  (it \"throw an error if 5 is divided by 0\"\n    (should-throw ArithmeticException\n      (/ 5 0))))\n```", "```java\n(defn echo []\n  (let [s (read-line)]\n    (println (str \"Echo: \" s))))\n\n(describe \"echo\"\n  (it \"reads a line and prints it\"\n    (should= \"Echo: Hello!\\r\\n\"\n      (with-out-str\n        (with-in-str \"Hello!\"\n          (echo))))))\n```", "```java\n(describe \"echo\"\n  (it \"reads a line and prints it\"\n    (with-redefs [read-line (fn [] \"Hello!\")\n                  println (fn [x] x)]\n      (should= \"Echo: Hello!\" (echo)))))\n```", "```java\nuser> (run-specs)\n...\n\nFinished in 0.00547 seconds\n7 examples, 0 failures\n#<speclj.run.standard.StandardRunner 0x10999>\n```", "```java\n$ lein spec -a\n\n```", "```java\n[org.clojure/test.check \"0.9.0\"]\n```", "```java\n(ns my-namespace\n  (:require [clojure.test.check :as tc]\n            [clojure.test.check.generators :as gen]\n            [clojure.test.check.properties :as prop]\n            [clojure.test.check.clojure-test \n             :refer [defspec]]))\n```", "```java\n(def commutative-mult-prop\n  (prop/for-all [a gen/int\n                 b gen/int]\n    (= (* a b)\n       (* b a))))\n\n(def first-is-min-after-sort-prop\n  (prop/for-all [v (gen/not-empty (gen/vector gen/int))]\n    (= (apply min v)\n       (first (sort v)))))\n```", "```java\nuser> (tc/quick-check 100 commutative-mult-prop)\n{:result true, :num-tests 100, :seed 1449998010193}\nuser> (tc/quick-check 100 first-is-min-after-sort-prop)\n{:result true, :num-tests 100, :seed 1449998014634}\n```", "```java\n(def commutative-minus-prop\n  (prop/for-all [a gen/int\n                 b gen/int]\n    (= (- a b)\n       (- b a))))\n```", "```java\nuser> (tc/quick-check 100 commutative-minus-prop)\n{:result false, :seed 1449998165908,\n :failing-size 1, :num-tests 2, :fail [0 -1],\n :shrunk {:total-nodes-visited 1, :depth 0, :result false,\n               :smallest [0 -1]}}\n```", "```java\n(defspec commutative-mult 100\n  (prop/for-all [a gen/int\n                 b gen/int]\n    (= (* a b)\n       (* b a))))\n```", "```java\n[org.clojure/core.typed \"0.3.0\"]\n```", "```java\n(ns my-namespace\n  (:require [clojure.core.typed :as t]))\n```", "```java\n(t/ann add [Number Number -> Number])\n(defn add [a b]\n  (+ a b))\n```", "```java\nuser> (t/check-ns 'my-namespace)\nStart collecting my-namespace\nFinished collecting my-namespace\nCollected 2 namespaces in 200.965982 msecs\nStart checking my-namespace\nChecked my-namespace in 447.580402 msecs\nChecked 2 namespaces  in 650.979682 msecs\n:ok\n```", "```java\n(defn add [a b]\n  (str (+ a b)))\n```", "```java\nuser> (t/check-ns 'my-namespace)\nStart collecting my-namespace\nFinished collecting my-namespace\nCollected 2 namespaces in 215.705251 msecs\nStart checking my-namespace\nChecked my-namespace in 493.669488 msecs\nChecked 2 namespaces  in 711.644548 msecs\nType Error (m_clj/c1/typed.clj:23:3) Type mismatch:\n\nExpected:   Number\n\nActual:   String\nin: (str (clojure.lang.Numbers/add a b))\nExceptionInfo Type Checker: Found 1 error  clojure.core/ex-info (core.clj:4403)\n```", "```java\n(t/ann add-abc\n       (t/IFn [Number Number -> Number]\n              [Number Number Number -> Number]))\n(defn add-abc\n  ([a b]\n   (+ a b))\n  ([a b c]\n   (+ a b c)))\n```", "```java\n(t/ann add-xs [Number * -> Number])\n(defn add-xs [& xs]\n  (apply + xs))\n```", "```java\nuser> (t/cf nil)\n[nil {:then ff, :else tt}]\nuser> (t/cf true)\n[true {:then tt, :else ff}]\nuser> (t/cf false)\n[false {:then ff, :else tt}]\n```", "```java\nuser> (t/cf \"Hello\")\n[(t/Val \"Hello\") {:then tt, :else ff}]\nuser> (t/cf 1)\n[(t/Val 1) {:then tt, :else ff}]\nuser> (t/cf :key)\n[(t/Val :key) {:then tt, :else ff}]\n```", "```java\nuser> (t/cf str)\n[t/Any * -> String]\nuser> (t/cf +)\n(t/IFn [Long * -> Long]\n       [(t/U Double Long) * -> Double]\n       [t/AnyInteger * -> t/AnyInteger]\n       [Number * -> Number])\n```", "```java\nuser> (t/cf (t/ann-form #(inc %) [Number -> Number]))\n[[Number -> Number] {:then tt, :else ff}]\nuser> (t/cf (t/ann-form #(str %) [t/Any -> String]))\n[[t/Any -> String] {:then tt, :else ff}]\n```", "```java\nuser> (t/cf (list 0 1 2))\n(PersistentList (t/U (t/Val 1) (t/Val 0) (t/Val 2)))\nuser> (t/cf [0 1 2])\n[(t/HVec [(t/Val 0) (t/Val 1) (t/Val 2)]) {:then tt, :else ff}]\n```", "```java\nuser> (t/cf (list 0 1 2) (t/List t/Num))\n(t/List t/Num)\nuser> (t/cf [0 1 2] (t/Vec t/Num))\n(t/Vec t/Num)\nuser> (t/cf {:a 1 :b 2} (t/Map t/Keyword t/Int))\n(t/Map t/Keyword t/Int)\nuser> (t/cf #{0 1 2} (t/Set t/Int))\n(t/Set t/Int)\n```", "```java\n(defalias AnyInteger\n  (U Integer Long clojure.lang.BigInt BigInteger Short Byte))\n```", "```java\nuser> (t/cf identity)\n(t/All [x] [x -> x :filters ... ])\nuser> (t/cf iterate)\n(t/All [x] [[x -> x] x -> (t/ASeq x)])\n```", "```java\n(t/ann make-map (t/All [x] [x -> (t/Map t/Keyword x)]))\n(defn make-map [a]\n  {:x a})\n```", "```java\n[org.clojure/tools.trace \"0.7.9\"]\n```", "```java\n(ns my-namespace\n  (:require [clojure.tools.trace :as tr]))\n```", "```java\n(defn make-vector [x]\n  [x])\n```", "```java\nuser> (tr/trace (make-vector 0))\nTRACE: [0]\n[0]\nuser> (tr/trace \"my-tag\" (make-vector 0))\nTRACE my-tag: [0]\n[0]\n```", "```java\nuser> (tr/trace-forms (+ 10 20) (* 2 3) (/ 10 0))\nArithmeticException Divide by zero\n  Form failed: (/ 10 0)\nclojure.lang.Numbers.divide (Numbers.java:158)\n```", "```java\n(tr/deftrace add-into-vector [& xs]\n  (let [sum (apply + xs)]\n    [sum]))\n```", "```java\nuser> (add-into-vector 10 20)\nTRACE t9083: (add-into-vector 10 20)\nTRACE t9083: => [30]\n[30]\n```", "```java\n[spyscope \"0.1.5\"]\n```", "```java\n(require 'spyscope.core)\n```", "```java\n(ns my-namespace\n  (:require [spyscope.repl :as sr]))\n```", "```java\nuser> (take 5 (repeatedly\n #(let [r (rand-int 100)]\n #spy/p r)))\n95\n36\n61\n99\n73\n(95 36 61 99 73)\n```", "```java\nuser> (take 5 (repeatedly\n #(let [r (rand-int 100)]\n #spy/d (/ r 10.0))))\nuser$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) => 4.6\nuser$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) => 4.4\nuser$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) => 5.0\nuser$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) => 7.8\nuser$eval9408$fn__9409.invoke(form-init1..0.clj:2) (/ r 10.0) => 3.1\n(4.6 4.4 5.0 7.8 3.1)\n```", "```java\nuser> (take 5 (repeat #spy/d ^{:fs 3 :marker \"add\"}\n (+ 0 1 2)))\n----------------------------------------\nclojure.lang.Compiler.eval(Compiler.java:6745)\nclojure.lang.Compiler.eval(Compiler.java:6782)\nuser$eval9476.invoke(form-init1..0.clj:1) add (+ 0 1 2) => 3\n(3 3 3 3 3)\n```", "```java\nuser> (take 5 (repeat #spy/d ^{:fs 3 :nses #\"core|user\"}\n (+ 0 1 2)))\n----------------------------------------\nclojure.core$apply.invoke(core.clj:630)\nclojure.core$eval.invoke(core.clj:3081)\nuser$eval9509.invoke(form-init1..0.clj:1) (+ 0 1 2) => 3\n(3 3 3 3 3)\n```", "```java\n(defn add-in-future [& xs]\n  (future\n    #spy/t (apply + xs)))\n```", "```java\nuser> (sr/trace-next)\nnil\nuser> (def f1 (add-in-future 10 20))\n#'user/f1\nuser> (def f2 (add-in-future 20 30))\n#'user/f2\nuser> (sr/trace-query)\nuser$add_in_future$fn_..7.invoke(debugging.clj:66) (apply + xs) => 30\n----------------------------------------\nuser$add_in_future$fn_..7.invoke(debugging.clj:66) (apply + xs) => 50\nnil\n```", "```java\n[org.clojure/tools.logging \"0.3.1\"]\n[ch.qos.logback/logback-classic \"1.1.3\"]\n```", "```java\n(ns my-namespace\n  (:require [clojure.tools.logging :as log]))\n```", "```java\n(defn divide [a b]\n  (log/info \"Dividing\" a \"by\" b)\n  (try\n    (log/spyf \"Result: %s\" (/ a b))\n    (catch Exception e\n      (log/error e \"There was an error!\"))))\n```", "```java\nuser> (divide 10 1)\nINFO  - Dividing 10 by 1\nDEBUG - Result: 10\n10\nuser> (divide 10 0)\nINFO  - Dividing 10 by 0\nERROR - There was an error!\njava.lang.ArithmeticException: Divide by zero\nat clojure.lang.Numbers.divide(Numbers.java:158) ~[clojure-1.7.0.jar:na]\n...\nat java.lang.Thread.run(Thread.java:744) [na:1.7.0_45]\nnil\n```", "```java\n(Thread/setDefaultUncaughtExceptionHandler\n (reify Thread$UncaughtExceptionHandler\n   (uncaughtException [_ thread ex]\n     (log/error ex \"Uncaught exception on\" (.getName thread)))))\n```"]