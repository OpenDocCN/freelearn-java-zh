<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0;The Bukkit Scheduler" id="28FAO1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. The Bukkit Scheduler</h1></div></div></div><p class="calibre8">The Bukkit scheduler<a id="id272" class="calibre1"/> is a very powerful tool, and it is easy to learn how to use it. It allows you to create repetitive tasks such as saving data. It also allows you to delay how long until a block of code is executed. The Bukkit scheduler can also be used to asynchronously compute lengthy tasks. This means that a task such as writing data to a file or downloading a file to the server can be scheduled to run on a separate thread to prevent the main thread, and thus the game, from lagging. In this chapter, you will learn how to do each of these by continuing to work on the <code class="email">Warper</code> teleportation plugin, as well as creating a new plugin called <code class="email">AlwaysDay</code>. This new plugin will ensure that it is always daytime on the server by repeatedly setting the time to noon. This chapter will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating a <code class="email">BukkitRunnable</code> class</li><li class="listitem">Understanding synchronous and asynchronous tasks and when they should be used</li><li class="listitem">Running a task from a <code class="email">BukkitRunnable</code> class</li><li class="listitem">Scheduling a delayed task from a <code class="email">BukkitRunnable</code> class</li><li class="listitem">Scheduling a repeating task from a <code class="email">BukkitRunnable</code> class</li><li class="listitem">Writing a plugin called <code class="email">AlwaysDay</code> that uses a repeating task</li><li class="listitem">Adding a delayed task to the <code class="email">Warper</code> plugin</li><li class="listitem">Asynchronously executing code</li></ul></div></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;The Bukkit Scheduler" id="28FAO1-b66e70deee6e4ed481db4b113e303f23">
<div class="book" title="Creating a BukkitRunnable class"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec70" class="calibre1"/>Creating a BukkitRunnable class</h1></div></div></div><p class="calibre8">We <a id="id273" class="calibre1"/>will start by creating the <code class="email">AlwaysDay</code> plugin. The code that we will write for this plugin will be put inside the <code class="email">onEnable</code> method. The first step to creating a scheduled task is to create a <code class="email">BukkitRunnable</code> class. This class will comprise very few lines of code. Therefore, it is not necessary to create a whole new Java file for it. For this reason, we will create a class within the <code class="email">onEnable</code> method. This can be done using the following line of code:</p><div class="informalexample"><pre class="programlisting">BukkitRunnable runnable = new BukkitRunnable();</pre></div><p class="calibre8">Normally, this <a id="id274" class="calibre1"/>code would be valid since you are constructing a new instance of a class. However, <code class="email">BukkitRunnable</code> is an<a id="id275" class="calibre1"/> <span class="strong"><strong class="calibre2">abstract class</strong></span>, which means that it cannot be instantiated. The purpose of an <span class="strong"><strong class="calibre2">abstract class</strong></span> is to provide some base code that other classes can <span class="strong"><strong class="calibre2">extend</strong></span> and build on top of. An example of this is the <code class="email">JavaPlugin</code> class. For each plugin that you created, you started with a class that extends <code class="email">JavaPlugin</code>. This allows you to override methods, such as <code class="email">onEnable</code>, while keeping the current code of other methods, such as <code class="email">getConfig</code>. This is similar to implementing an Interface, such as Listener. The difference between an abstract class and an interface is its purpose. As mentioned earlier, an abstract class is a base for other classes to extend. An interface is more of an outline within which classes can implement. Interfaces do not include code within any of their methods and therefore, all methods within an interface must have an implementation. For an abstract class, only the methods defined as <code class="email">abstract</code> must be overridden because they do not include code within them. Therefore, because <code class="email">BukkitRunnable</code> is an abstract class, you will be given a warning that will ask you to implement all the abstract methods. NetBeans can automatically add the needed methods for you. The new method that is added for you is <code class="email">run</code>. This method will be called when the scheduler runs your task. For the new <code class="email">AlwaysDay</code> plugin, we want the task to set each world's time to noon, as follows:</p><div class="informalexample"><pre class="programlisting">BukkitRunnable runnable = new BukkitRunnable() {
  @Override
  public void run() {
    for (World world : Bukkit.getWorlds()) {
      //Set the time to noon
      world.setTime(6000);
    }
  }
};</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">Remember that time on a Minecraft server is measured in ticks. 20 ticks is equivalent to 1 second. The measurement of ticks is as follows:</p><p class="calibre8">0 ticks: Dawn</p><p class="calibre8">6,000 ticks: Noon</p><p class="calibre8">12,000 ticks: Dusk</p><p class="calibre8">18,000 ticks: Midnight</p></div><p class="calibre8">Take a look at the API documentation for the <code class="email">BukkitRunnable</code> class <a id="id276" class="calibre1"/>at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/spigot/org/bukkit/scheduler/BukkitRunnable.html">https://hub.spigotmc.org/javadocs/spigot/org/bukkit/scheduler/BukkitRunnable.html</a>. Note that there are six ways to run this task, which are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">runTask</li><li class="listitem">runTaskAsynchronously</li><li class="listitem">runTaskLater</li><li class="listitem">runTaskLaterAsynchronously</li><li class="listitem">runTaskTimer</li><li class="listitem">runTaskTimerAsynchronously</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Synchronous versus asynchronous tasks" id="29DRA1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec71" class="calibre1"/>Synchronous versus asynchronous tasks</h1></div></div></div><p class="calibre8">A task can be run either <a id="id277" class="calibre1"/>synchronously or <a id="id278" class="calibre1"/>asynchronously. Simply put, when a synchronous task is executed, it must be completed before the server can continue running normally. An asynchronous task can run in the background while the server continues to function. If a task accesses the Bukkit API in any way, then it should be run synchronously. For this reason, you will rarely run a task asynchronously. An advantage that an asynchronous task gives is that it can be completed without causing your server to lag. For example, writing data to a save file can be done asynchronously. Later in this chapter, we will modify the <code class="email">Warper</code> plugin to save its data asynchronously. As for the <code class="email">AlwaysDay</code> plugin, we must run the task synchronously because it accesses the Minecraft server.</p></div>

<div class="book" title="Synchronous versus asynchronous tasks" id="29DRA1-b66e70deee6e4ed481db4b113e303f23">
<div class="book" title="Running a task from a BukkitRunnable class"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec16" class="calibre1"/>Running a task from a BukkitRunnable class</h2></div></div></div><p class="calibre8">Calling <code class="email">runTask</code> or <code class="email">runTaskAsynchronously</code> on a <code class="email">BukkitRunnable</code> class will cause the task to run immediately. The <a id="id279" class="calibre1"/>only time you are likely to use this is to<a id="id280" class="calibre1"/> run a synchronous task from an asynchronous context or vice versa.</p></div></div>

<div class="book" title="Synchronous versus asynchronous tasks" id="29DRA1-b66e70deee6e4ed481db4b113e303f23">
<div class="book" title="Running a task later from a BukkitRunnable class"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec17" class="calibre1"/>Running a task later from a BukkitRunnable class</h2></div></div></div><p class="calibre8">Calling <code class="email">runTaskLater</code> or <code class="email">runTaskLaterAsynchronously</code> on a <code class="email">BukkitRunnable</code>  class will delay the<a id="id281" class="calibre1"/> task from being executed for a<a id="id282" class="calibre1"/> specific amount of time. The amount of time is measured in ticks. Remember that there are 20 ticks in every second. In the <code class="email">Warper</code> plugin, we will add a warp delay so that the player is teleported 5 seconds after running the warp command. We will accomplish this by running the task later.</p></div></div>

<div class="book" title="Synchronous versus asynchronous tasks" id="29DRA1-b66e70deee6e4ed481db4b113e303f23">
<div class="book" title="Running a task timer from a BukkitRunnable class"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec18" class="calibre1"/>Running a task timer from a BukkitRunnable class</h2></div></div></div><p class="calibre8">Calling <code class="email">runTaskTimer</code> or <code class="email">runTaskTimerAsynchronously</code> on a <code class="email">BukkitRunnable</code> class will repeat the task<a id="id283" class="calibre1"/> every specified number of ticks. The<a id="id284" class="calibre1"/> task will repeat until it is canceled. Task timers can also be delayed to offset the initial run of the task. A task timer can be used to periodically save data, but for now, we will use this type of repeating task to complete the <code class="email">AlwaysDay</code> plugin.</p></div></div>
<div class="book" title="Writing a repeating task for a plugin" id="2ACBS1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec72" class="calibre1"/>Writing a repeating task for a plugin</h1></div></div></div><p class="calibre8">We already have a <code class="email">BukkitRunnable</code> class. Therefore, in order to run a task timer, we just need to determine<a id="id285" class="calibre1"/> the delay and the period by which the task is <a id="id286" class="calibre1"/>delayed. We want the delay to be 0. That way, if it is night when the plugin is enabled, the time will be set to noon right away. As for the period, we can repeat the task every second if we want to keep the sun always directly above. The task only contains one simple line of code. Repeating it often will not cause the server to lag. However, repeating the task every minute will still prevent the world from ever growing dark and will be less of a strain on the computer. Therefore, we will delay the task by 0 ticks and repeat it every 1,200 ticks. This results in the following line of code:</p><div class="informalexample"><pre class="programlisting">runnable.runTaskTimer(this, 0, 1200);</pre></div><p class="calibre8">With this, we started a repeating task. It is good practice to cancel repeating tasks when the plugin is disabled. To accomplish this, we will store the <code class="email">BukkitTask</code> as a class variable so that we can access it later to disable it. Once you have canceled the task within the <code class="email">onDisable</code> method, the entire <code class="email">AlwaysDay</code> plugin is given in the following code:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.alwaysday;

import org.bukkit.Bukkit;
import org.bukkit.World;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.scheduler.BukkitTask;

public class AlwaysDay extends JavaPlugin {
    BukkitTask dayLightTask;

    @Override
    public void onDisable() {

        dayLightTask.cancel();

    }

  @Override
  public void onEnable() {
    BukkitRunnable bRunnable = new BukkitRunnable() {
      @Override
      public void run() {
        for (World world : Bukkit.getWorlds()) {
          //Set the time to noon
          world.setTime(6000);
        }
      }
    };

    //Repeat task every 1200 ticks (1 minute)
    dayLightTask = bRunnable.runTaskTimer(this, 0, 1200);
  }
}</pre></div></div>
<div class="book" title="Adding a delayed task to a plugin" id="2BASE1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec73" class="calibre1"/>Adding a delayed task to a plugin</h1></div></div></div><p class="calibre8">We will now add a warp delay to the <code class="email">Warper</code> plugin. This will require players to stand still after running the <a id="id287" class="calibre1"/>warp or home commands. If they move too much, the <a id="id288" class="calibre1"/>warp task will be canceled and they will not be<a id="id289" class="calibre1"/> teleported. This will prevent players from<a id="id290" class="calibre1"/> teleporting when someone is attacking them or they are falling to their death.</p><p class="calibre8">If you haven't already, add a variable of <code class="email">warpDelay</code> in the <code class="email">main</code> class. This is given in the following line of code:</p><div class="informalexample"><pre class="programlisting">static int warpDelay = 5; //in seconds</pre></div><p class="calibre8">This time will be in seconds. We will multiply it by 20 later in the code to calculate the number of ticks by which we wish to delay the task.</p><p class="calibre8">We will also need to keep track of the player who is in the process of warping so that we can check whether they are moving. Add another variable of the current <code class="email">warpers</code>. This will be a <code class="email">HashMap</code> so that we can keep track of which players are warping and the tasks that will be run to teleport them. That way, if a specific player moves, we can get their task and cancel it. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">private static HashMap&lt;String, BukkitTask&gt;warpers = new HashMap&lt;&gt;();//Player UUID -&gt; Warp Task</pre></div><p class="calibre8">The <a id="id291" class="calibre1"/>code <a id="id292" class="calibre1"/>contains <a id="id293" class="calibre1"/>three new methods, which must be added to the <code class="email">main</code> class in<a id="id294" class="calibre1"/> order to schedule the warp task, check whether a player has a warp task, and cancel a player's warp task. The code is as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * Schedules a Player to be teleported after the delay time
 *
 * @param player The Player being teleported
 * @param loc The location of the destination
 */
public static void scheduleWarp(final Player player, final Location loc) {
  //Inform the player that they will be teleported
  player.sendMessage("You will be teleported in "+ warpDelay + " seconds");

  //Create a task to teleport the player
  BukkitRunnable bRunnable = new BukkitRunnable() {
    @Override
    public void run() {
      player.teleport(loc); 

      //Remove the player as a warper because they have already beenteleported
      warpers.remove(player.getName());
    }
  };

  //Schedule the task to run later
  BukkitTask task = bRunnable.runTaskLater(plugin, 20L * warpDelay);

  //Keep track of the player and their warp task
  warpers.put(player.getUniqueId().toString(), task);
}

/**
 * Returns true if the player is waiting to be teleported
 *
 * @param player The UUID of the Player in question
 * @return true if the player is waiting to be warped
 */
public static boolean isWarping(String player) {
  return warpers.containsKey(player);
}

/**
 * Cancels the warp task for the given player
 *
 * @param player The UUID of the Player whose warp task will be canceled
 */
public static void cancelWarp(String player) {
  //Check if the player is warping
  if (isWarping(player)) {
    //Remove the player as a warper
    //Cancel the task so that the player is not teleported
    warpers.remove(player).cancel();
  }
}</pre></div><p class="calibre8">In<a id="id295" class="calibre1"/> the<a id="id296" class="calibre1"/> <code class="email">scheduleTeleportation</code> method, note<a id="id297" class="calibre1"/> that both the <code class="email">player</code> and <code class="email">loc</code> <a id="id298" class="calibre1"/>variables are <code class="email">final</code>. This is required to use the variables within the <code class="email">BukkitRunnable</code> class. This must be done to ensure that the values will not change before the task is run. Also, note that the <code class="email">runTaskLater</code> method call returns a <code class="email">BukkitTask</code>, which is what we save inside the <code class="email">HashMap</code>. You can see why it is saved by looking at the <code class="email">cancelWarp</code> method, which removes the <code class="email">BukkitTask</code> of the given player and then invokes the <code class="email">cancel</code> method on it before it is executed.</p><p class="calibre8">In both the <code class="email">WarpCommand</code> and <code class="email">HomeCommand</code> classes, we teleport a player. We want to remove that line and replace it with a method call to <code class="email">scheduleTeleportation</code>. The feature addition is nearing completion. All that is left to do is calling the <code class="email">cancelWarp</code> method when a <code class="email">warper</code> moves. For this, add an event listener to listen for the <code class="email">player move</code> event. This can be seen in the following code:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.warper;

import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;

public class WarperPlayerListener implements Listener {
  @EventHandler (priority = EventPriority.MONITOR)
  public void onPlayerMove(PlayerMoveEvent event) {
    Player player = event.getPlayer();
    String playerUuid = player.getUniqueId().toString();

    //We only care about this event if the player is flagged aswarping
    if (Warper.isWarping(playerUuid)) {
      //Compare the block locations rather than the player locations
      //This allows a player to move their head without canceling thewarp
      Block blockFrom = event.getFrom().getBlock();
      Block blockTo = event.getTo().getBlock();

      //Cancel the warp if the player moves to a different block
      if (!blockFrom.equals(blockTo)) {
        Warper.cancelWarp(playerUuid);
        player.sendMessage("Warping canceled because you moved!");
      }
    }
  }
}</pre></div><p class="calibre8">Do <a id="id299" class="calibre1"/>not<a id="id300" class="calibre1"/> forget<a id="id301" class="calibre1"/> to register <a id="id302" class="calibre1"/>the event within the <code class="email">onEnable</code> method.</p></div>
<div class="book" title="Executing code asynchronously" id="2C9D01-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec74" class="calibre1"/>Executing code asynchronously</h1></div></div></div><p class="calibre8">We can improve <a id="id303" class="calibre1"/>the <code class="email">Warper</code> plugin by writing its data to a file asynchronously. This will help keep the main thread of the server running smoothly with no lag.</p><p class="calibre8">Take a look at the current <code class="email">save</code> method. We will add the data to a <code class="email">YamlConfiguration</code>  file and then write the configuration to the file. This entire method cannot be run asynchronously. Adding the data to the configuration must be done synchronously to ensure that it is not modified while it is being added. However, the <code class="email">save</code> method call on the configuration can be called asynchronously. We will place the entire <code class="email">try/catch</code> block within a new <code class="email">BukkitRunnable class</code>. We will then run it asynchronously as a task. This task will be stored as a static variable in the <code class="email">Warper</code> class. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">BukkitRunnable saveRunnable = new BukkitRunnable() {
  @Override
  public void run() {
    try {
      //Write the configuration to our save file
      config.save(new File(plugin.getDataFolder(), "warps.yml"));
    } catch (Exception saveFailed) {
      plugin.getLogger().log(Level.SEVERE, "Save Failed!", saveFailed);
    }
  }
};

saveTask = saveRunnable.runTaskAsynchronously(plugin);</pre></div><p class="calibre8">Now, the rest of the server can continue running while the data is being saved.</p><p class="calibre8">However, what if we try to save the file again when the previous write is not yet finished? In this case, we do not care about the previous task, because it is now saving outdated data. We will first cancel the task before starting a new one. This will be done using the following code before creating the <code class="email">BukkitRunnable</code> class:</p><div class="informalexample"><pre class="programlisting">if (saveTask != null) {
  saveTask.cancel();
}</pre></div><p class="calibre8">This completes this<a id="id304" class="calibre1"/> version of <code class="email">Warper</code>. As mentioned in <a class="calibre1" title="Chapter 9. Saving Your Data" href="part0069_split_000.html#21PMQ1-b66e70deee6e4ed481db4b113e303f23">Chapter 9</a>, <span class="strong"><em class="calibre9">Saving Your Data</em></span>, this plugin has a lot of potential for feature additions. You now have the required knowledge to add these additions on your own.</p></div>
<div class="book" title="Summary" id="2D7TI1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec75" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">You are now familiar with most of the complicated aspects of the Bukkit API. With this knowledge, you can program almost any type of Bukkit plugin. Try putting this knowledge to use by creating a new plugin. You can perhaps try to write an announcement plugin that will rotate through a list of messages that need to be broadcast on a server. Think about all the Bukkit API concepts and how you can use them to add new features to the plugin. For example, with an announcement plugin, you can do the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Add commands to allow an administrator to add messages that need to be announced</li><li class="listitem">Add permissions to control who can add messages and even who can see the messages that are announced</li><li class="listitem">Add an <code class="email">EventHandler</code> method to listen for when players log in so that a message can be sent to them</li><li class="listitem">Add a <code class="email">config.yml</code> file to set how often messages should be announced</li><li class="listitem">Add a save file to save and load all the messages that will be announced</li><li class="listitem">Use the Bukkit scheduler to repeatedly broadcast the messages while the server is running</li></ul></div><p class="calibre8">For any plugin that you make, think of each segment of the Bukkit API to figure out some way to improve the plugin by adding more features. This will surely make your plugin and server stand out.</p><p class="calibre8">There are some topics that were not discussed in this book, but they are simple enough; you can learn how to use them on your own by reading the API documentation. Some interesting features that can spruce up a Bukkit plugin are the <code class="email">playSound</code> and <code class="email">playEffect</code> methods, which can be found inside the <code class="email">World</code> and <code class="email">Player</code> classes. I encourage you to read about them and try to use them yourself.</p><p class="calibre8">You know how to program plugin commands, player permissions, event listeners, configuration files, the saving and loading of data, and scheduled tasks. All that remains is imagining how to use these newfound skills to create a great and unique plugin for the Bukkit server.</p></div></body></html>