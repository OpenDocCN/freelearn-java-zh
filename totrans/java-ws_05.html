<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer049">
			</div>
		</div>
		<div class="Content" id="_idContainer050">
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>5. Exceptions</h1>
		</div>
		<div class="Content" id="_idContainer051">
			<p class="callout-heading">Overview </p>
			<p class="callout">This chapter discusses how exceptions are dealt with in Java. You will first learn how to identify the situations that produce exceptions in your code. This knowledge will simplify the process of handling these exceptions by alerting you to those circumstances in which they are most likely to arise. In this endeavor, this chapter also provides a list of best practices guiding you through common scenarios and the best methods of either catching exceptions or throwing them to the calling class, logging their details as you go. You will further learn to differentiate between different types of exceptions, and practice the techniques for handling each. By the end of the chapter, you will even be able to create your own exception class, capable of logging each type of exception in order of severity.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Introduction</h1>
			<p>Exceptions are not errors, or, more accurately, exceptions are not bugs, even if you might perceive them to be when they crash your programs. Exceptions are situations that occur in your code when there is a mismatch between the data you are handling and the method or command you are using to process it. </p>
			<p>In Java, there is a class that is dedicated to errors. Errors are unexpected situations that affect programs on the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) level. For example, if you fill-up the program stack through an unconventional use of memory, then your whole JVM will crash. Unlike errors, exceptions are situations that your code, when properly designed, can catch on the fly. </p>
			<p>Exceptions are not as drastic as errors, even if the result for you, the developer, will be the same—that is, a non-working program. In this chapter, we are inviting you to make your programs crash by intentionally provoking exceptions that you will later learn how to catch (that is, handle) and avoid. Depending on how you develop the catch mechanism, you can decide whether to get your program to recover and continue operating or to gracefully end its execution with a human-readable error message.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>A Simple Exception Example</h1>
			<p>Start by provoking a simple exception in your code. First, type in the following program in the <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) and execute it:</p>
			<p class="source-code">public class Example01 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        // declare a string with nothing inside</p>
			<p class="source-code">        String text = null;</p>
			<p class="source-code">        // you will see this at the console</p>
			<p class="source-code">        System.out.println("Go Java Go!");</p>
			<p class="source-code">        // null'ed strings should crash your program</p>
			<p class="source-code">        System.out.println(text.length());</p>
			<p class="source-code">        // you will never see this print</p>
			<p class="source-code">        System.out.println("done");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here is the output:</p>
			<p class="source-code">Go Java Go!</p>
			<p class="source-code">Exception in thread "main" java.lang.NullPointerException</p>
			<p class="source-code">     at Example01.main(Example01.java:11)</p>
			<p class="source-code">Process finished with exit code 1</p>
			<p>The previous code listing shows how the program starts executing a command that works fine. The sentence <strong class="source-inline">Go Java Go!</strong> is printed on the console, but then a <strong class="source-inline">NullPointerException</strong> shows up, highlighting that something exceptional happened. In this case, we tried to print the length of a string initiated to null by calling <strong class="source-inline">text.length()</strong>. Since there is no length to be calculated (that is, we don't even have an empty string), either <strong class="source-inline">System.out.println()</strong> or <strong class="source-inline">text.length()</strong> provoked the exception. Additionally, there was an error at that point, so the program exited and the final call to <strong class="source-inline">System.out.println("done")</strong> was not executed. You could try to separate both commands to see what the outcome will be:</p>
			<p class="source-code">// null'ed strings should crash your program</p>
			<p class="source-code">int number = text.length();</p>
			<p class="source-code">System.out.println(number);</p>
			<p>Here is the output:</p>
			<p class="source-code">Go Java Go!</p>
			<p class="source-code">Exception in thread "main" java.lang.NullPointerException</p>
			<p class="source-code">     at Example01.main(Example01.java:11)</p>
			<p class="source-code">Process finished with exit code 1</p>
			<p>If you check the line numbers in the IDE, you will see that the exception takes place on the line where we are trying to get the length of the string. Now that we know the cause of the problem, there are two ways around this issue: either we fix the data (note that there will be situations where this will be impossible), or we include a countermeasure in our code to detect the exceptions and then handle or ignore them. The action of handling an unexpected event is what we call catching the exception. On the other hand, bypassing the event is called throwing the exception. Later in the chapter, we will explore different ways of doing both of these actions, as well as good practices for when writing code-handling exceptions.</p>
			<p>However, before learning about how to avoid or handle exceptions, let's provoke some more. Almost every Java API includes the definition of an exception that can help to propagate errors towards the main class, and thus the developer. In that way, it will be possible to avoid situations where the code will break in front of the user's eyes. </p>
			<p>The exceptions covered by the Java APIs are what we call built-in exceptions. It is also possible to create your own when you define a class. Talking about classes, let's try to get a character from a non-existing location within an object instantiated from <strong class="source-inline">String</strong> and see what happens:</p>
			<p class="source-code">public class Example02 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        // declare a string of a fixed length</p>
			<p class="source-code">        String text = "I &lt;3 bananas"; // 12 characters long</p>
			<p class="source-code">        // provoke an exception</p>
			<p class="source-code">        char character = text.charAt(15); // get the 15th element</p>
			<p class="source-code">        // you will never see this print</p>
			<p class="source-code">        System.out.println("done");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The IDE will respond with the following:</p>
			<p class="source-code">Exception in thread "main" java.lang.StringIndexOutOfBoundsException: String index out of range: 15</p>
			<p class="source-code">      at java.lang.String.charAt(String.java:658)</p>
			<p class="source-code">      at Example02.main(Example02.java:8)</p>
			<p class="source-code">Process finished with exit code 1</p>
			<p>Note that the text variable is only 12 characters long. When trying to extract the 15th character, the IDE will issue an exception and terminate the program. In this case, we got one called <strong class="source-inline">StringOutOfBoundsException</strong>. There are many different types of built-in exceptions.</p>
			<p>Here's a list of the various types of exceptions:</p>
			<ul>
				<li><strong class="source-inline">NullPointerException</strong></li>
				<li><strong class="source-inline">StringOutOfBoundsException</strong></li>
				<li><strong class="source-inline">ArithmeticException</strong></li>
				<li><strong class="source-inline">ClassCastException</strong></li>
				<li><strong class="source-inline">IllegalArgumentException</strong></li>
				<li><strong class="source-inline">IndexOutOfBoundsException</strong></li>
				<li><strong class="source-inline">NumberFormatException</strong></li>
				<li><strong class="source-inline">IllegalAccessException</strong></li>
				<li><strong class="source-inline">InstantiationException</strong></li>
				<li><strong class="source-inline">NoSuchMethodException</strong></li>
			</ul>
			<p>As you can see, the names of the different exceptions are quite descriptive. When you get one, it should be quite easy to figure out where to find more information about it within the Java documentation in order to mitigate the problem. We classify exceptions as checked or unchecked:</p>
			<ul>
				<li><strong class="bold">Checked exceptions</strong>: These are highlighted during compilation. In other words, your program will not make it to the end of the compilation process, and therefore you will not be able to run it.</li>
				<li><strong class="bold">Unchecked exceptions</strong>: These show up during program execution; therefore, we also call them runtime exceptions. The examples that have been shown in this chapter so far (<strong class="source-inline">NullPointerException</strong> and <strong class="source-inline">StringOutOfBoundsException</strong>) are both unchecked.<p class="callout-heading">Why Two Types of Exception?</p><p class="callout">There are two possibilities for exceptions: either we, as developers, make a mistake and don't realize that our way of handling data is going to produce an error (such as when we are trying to get the length of an empty string or when we are dividing a number by zero), or the error happens because we are uncertain about the nature of the data we will be gathering during an exchange with something external to our program (such as when getting parameters from the CLI and they are of the wrong type). In cases like the first one, checked exceptions make more sense. The second scenario is the reason why we need unchecked exceptions. In this second case, we should develop strategies to handle potential threats to the proper execution of the program.</p></li>
			</ul>
			<p>Making an example of a checked exception is slightly more complicated because we have to anticipate things that will not be introduced in depth until a later chapter. However, we consider that the following example, which displays an example of <strong class="source-inline">IOException</strong>, is simple enough even if it includes a couple of classes that haven't been touched on in the book yet:</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example03 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        // declare a list that will contain all of the files</p>
			<p class="source-code">        // inside of the readme.txt file</p>
			<p class="source-code">        List&lt;String&gt; lines = Collections.emptyList();</p>
			<p class="source-code">        // provoke an exception</p>
			<p class="source-code">        lines = Files.readAllLines(Paths.get("readme.txt"));</p>
			<p class="source-code">        // you will never see this print</p>
			<p class="source-code">        Iterator&lt;String&gt; iterator = lines.iterator();</p>
			<p class="source-code">        while (iterator.hasNext())</p>
			<p class="source-code">            System.out.println(iterator.next());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The newest thing in this code listing is the use of <strong class="source-inline">java.nio.file.*</strong>. This is an API that includes classes and methods to manage files, among other things. The goal of this program is to read a whole text file called readme.txt into a list that will then be printed using an iterator, as we saw in <em class="italic">Chapter 4</em>, <em class="italic">Collections, Lists, and Java's Built-In APIs</em>.</p>
			<p>This is a case where a checked exception could occur when calling <strong class="source-inline">Files.readAllLines()</strong> if there is no file to be read because of, for example, having a wrongly declared filename. The IDE knows this and, therefore, it flags that there is a potential risk.</p>
			<p>Note how the IDE displays a warning from the moment we write the code. Furthermore, when trying to compile the program, the IDE will respond with the following:</p>
			<p class="source-code">Error:(11, 35) java: unreported exception java.io.IOException; must be caught or declared to be thrown</p>
			<p><strong class="bold">Catching</strong> and <strong class="bold">throwing</strong> are the two strategies that you can use to avoid exceptions. We will talk about them in more detail later in the chapter.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/>NullPointerException – Have No Fear</h1>
			<p>We presented the concept of <strong class="source-inline">null</strong> within Java in a previous chapter. As you may recall, <strong class="source-inline">null</strong> is the value that is implicitly assigned to an object upon creation, that is, unless you assign a different value to it. Related to <strong class="source-inline">null</strong> is the <strong class="source-inline">NullPointerException</strong> value. This is a very common event that can and will happen to you for a variety of reasons. In this section, we will highlight some of the most common scenarios of this in an effort to introduce you to a different way of thinking when dealing with any type of exception in your code.</p>
			<p>In <em class="italic">Example01</em>, we examined the process of trying to perform operations on an object that was pointing to <strong class="source-inline">null</strong>. Let's look at some other possible cases:</p>
			<p class="source-code">public class Example04 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        String vehicleType = null;</p>
			<p class="source-code">        String vehicle = "car";</p>
			<p class="source-code">        if (vehicleType.equals(vehicle)) {</p>
			<p class="source-code">            System.out.println("it's a car");</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            System.out.println("it's not a car");</p>
			<p class="source-code">        } </p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The outcome of this example would be the following:</p>
			<p class="source-code">Exception in thread "main" java.lang.NullPointerException</p>
			<p class="source-code">      at Example04.main(Example04.java:5)</p>
			<p class="source-code">Process finished with exit code 1</p>
			<p>You could have prevented this exception if you had written your code to compare the existing variable with the potentially <strong class="source-inline">null</strong> one instead.</p>
			<p class="source-code">public class Example05 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        String vehicleType = null;</p>
			<p class="source-code">        String vehicle = "car";</p>
			<p class="source-code">        if (vehicle.equals(vehicleType)) {</p>
			<p class="source-code">            System.out.println("it's a car");</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            System.out.println("it's not a car");</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding code will produce the following result:</p>
			<p class="source-code">it's not a car</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>As you can see, there is no conceptual difference between the examples; however, there is a difference at the code level. This difference is enough for your code to issue an exception upon compilation. This is because the <strong class="source-inline">equals()</strong> method for the <strong class="source-inline">String</strong> class is prepared to handle the situation of its parameter being <strong class="source-inline">null</strong>. On the other hand, a <strong class="source-inline">String</strong> variable that is initialized to <strong class="source-inline">null</strong> cannot have access to the <strong class="source-inline">equals()</strong> method.</p>
			<p>A very common situation for provoking a <strong class="source-inline">NullPointerException</strong> occurs when trying to call non-static methods from an object initialized to <strong class="source-inline">null</strong>. The following example shows a class with two methods that you can call to see whether they produce the exception. You can do this by simply commenting or uncommenting each of the lines calling the methods from <strong class="source-inline">main()</strong>. Copy the code in the IDE and try the two cases:</p>
			<p class="source-code">public class Example06 {</p>
			<p class="source-code">    private static void staticMethod() {</p>
			<p class="source-code">        System.out.println("static method, accessible from null reference");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private void nonStaticMethod() {</p>
			<p class="source-code">        System.out.print("non-static method, inaccessible from null reference");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String args[]) {</p>
			<p class="source-code">        Example06 object = null;</p>
			<p class="source-code">        object.staticMethod();</p>
			<p class="source-code">        //object.nonStaticMethod();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>There are other cases when this exception can appear, but let's focus on how to deal with exceptions. The following sections will describe different mechanisms you can use to enable your programs to recover from unexpected situations.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Catching Exceptions</h1>
			<p>As mentioned earlier, there are two ways to handle exceptions: catching and throwing. In this section, we will deal with the first of these methods. Catching an exception requires encapsulating the code that might generate an unwanted result into a specific statement, as shown in the following code snippet:</p>
			<p class="source-code">try {</p>
			<p class="source-code">  // code that could generate an exception of the type ExceptionM</p>
			<p class="source-code">} catch (ExceptionM e) {</p>
			<p class="source-code">  // code to be executed in case of exception happening</p>
			<p class="source-code">}</p>
			<p>We can put this code to test with any of the previous examples. Let's demonstrate how we could stop the exception we found in the first example of the chapter, where we tried to check the length of a string that was initialized to null:</p>
			<p class="source-code">public class Example07 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        // declare a string with nothing inside</p>
			<p class="source-code">        String text = null;</p>
			<p class="source-code">        // you will see this at the console</p>
			<p class="source-code">        System.out.println("Go Java Go!");</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            // null'ed strings should crash your program</p>
			<p class="source-code">            System.out.println(text.length());</p>
			<p class="source-code">        } catch (NullPointerException ex) {</p>
			<p class="source-code">            System.out.println("Exception: cannot get the text's length");</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // you will now see this print</p>
			<p class="source-code">        System.out.println("done");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see, we have wrapped the potentially broken code inside a <strong class="source-inline">try-catch</strong> statement. The result of this code listing is very different from the result that we saw previously:</p>
			<p class="source-code">Go Java Go!</p>
			<p class="source-code">Exception: cannot get the text's length</p>
			<p class="source-code">done</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>Mainly, we find that the program is not interrupted until the end. The <strong class="source-inline">try</strong> section of the program detects the arrival of the exception, and the <strong class="source-inline">catch</strong> part will execute a specific code if the exception is of the <strong class="source-inline">NullPointerException</strong> type.</p>
			<p>Several <strong class="source-inline">catch</strong> statements can be placed in sequence after the call to <strong class="source-inline">try</strong> as a way to detect different types of exceptions. To try this out, let's go back to the example where we were trying to open a non-existing file and try to catch the reason for <strong class="source-inline">readAllLines()</strong> stopping the program:</p>
			<p class="source-code-heading">Example08.java</p>
			<p class="source-code">5  public class Example08 {</p>
			<p class="source-code">6      public static void main(String[] args) {</p>
			<p class="source-code">7          // declare a list that will contain all of the files</p>
			<p class="source-code">8          // inside of the readme.txt file</p>
			<p class="source-code">9          List&lt;String&gt; lines = Collections.emptyList();</p>
			<p class="source-code">10 </p>
			<p class="source-code">11         try {</p>
			<p class="source-code">12             // provoke an exception</p>
			<p class="source-code">13             lines = Files.readAllLines(Paths.get("readme.txt"));</p>
			<p class="source-code">14         } catch (NoSuchFileException fe) {</p>
			<p class="source-code">15             System.out.println("Exception: File Not Found");</p>
			<p class="source-code">16         } catch (IOException ioe) {</p>
			<p class="source-code">17             System.out.println("Exception: IOException");</p>
			<p class="source-code">18         }</p>
			<p class="source-code-link"><a href="https://packt.live/2VU59wh">https://packt.live/2VU59wh</a></p>
			<p>As we saw earlier in the chapter, we have made a program that tries to open a non-existing file. The exception that we got then was <strong class="source-inline">IOException</strong>. In reality, that exception is triggered by <strong class="source-inline">NoSuchFileException</strong>, which is escalated and triggers <strong class="source-inline">IOException</strong>. Therefore, we get that exception on the IDE. When implementing the multiple try-catch statements, as shown in the previous example, we get the following outcome:</p>
			<p class="source-code">Exception: File Not Found</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>This means that the program detects the <strong class="source-inline">NoSuchFileException</strong> and, therefore, prints the message included in the corresponding catch statement. However, if you want to see the full sequence of exceptions triggered by the non-existing readme.txt file, you can use a method called <strong class="source-inline">printStackTrace()</strong>. This will send to the output everything that was on the way to the proper execution of the program. To see this, simply add the following highlighted changes to the previous example:</p>
			<p class="source-code">try {</p>
			<p class="source-code">    // provoke an exception</p>
			<p class="source-code">    lines = Files.readAllLines(Paths.get("readme.txt"));</p>
			<p class="source-code">} catch (NoSuchFileException fe) {</p>
			<p class="source-code">    System.out.println("Exception: File Not Found");</p>
			<p class="source-code">    fe.printStackTrace();</p>
			<p class="source-code">} catch (IOException ioe) {</p>
			<p class="source-code">    System.out.println("Exception: IOException");</p>
			<p class="source-code">}</p>
			<p>The output of the program will now include a full printout of the different exceptions triggered during program execution. You will see the output of the stack is inverted: first, you will see the reason why the program stopped (<strong class="source-inline">NoSuchFileException</strong>), and it will end with the method that starts the process that provokes the exception (<strong class="source-inline">readAllLines</strong>). This is due to the way exceptions are built. As we will discuss later, there are many different types of exceptions. Each one of these types is defined as a class of exceptions, which may be extended by several other subclasses of exceptions. If an extension of a certain type occurs, then the class that it is extending will also appear when printing out the stack. In our case, <strong class="source-inline">NoSuchFileException</strong> is a subclass of <strong class="source-inline">IOException</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Depending on your operating system, the different nested exceptions for dealing with opening a file will probably be called differently.</p>
			<p>We have been catching two different exceptions – one nested inside the other. It should also be possible to handle exceptions coming from different classes, such as <strong class="source-inline">IOException</strong> and <strong class="source-inline">NullPointerException</strong>. The following example demonstrates how to do this. If you are dealing with exceptions that are not a subclass of one another, it is possible to catch both exceptions using a logical OR operator:</p>
			<p class="source-code">import java.io.*;•</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example09 {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        List&lt;String&gt; lines = Collections.emptyList();</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            lines = Files.readAllLines(Paths.get("readme.txt"));</p>
			<p class="source-code">        } catch (NullPointerException|IOException ex) {</p>
			<p class="source-code">            System.out.println("Exception: File Not Found or NullPointer");</p>
			<p class="source-code">            ex.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // you will never see this print</p>
			<p class="source-code">        Iterator&lt;String&gt; iterator = lines.iterator();</p>
			<p class="source-code">        while (iterator.hasNext())</p>
			<p class="source-code">            System.out.println(iterator.next());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see, it is possible to handle both exceptions in a single <strong class="source-inline">catch</strong> statement. However, if you want to handle the exceptions differently, you will have to work with the object containing the information about the exception, which, in this case, is <strong class="source-inline">ex</strong>. The keyword you need to distinguish the between the exceptions that you may be handling simultaneously is <strong class="source-inline">instanceof</strong>, as shown in the following modification of the previous example:</p>
			<p class="source-code">try {</p>
			<p class="source-code">    // provoke an exception</p>
			<p class="source-code">    lines = Files.readAllLines(Paths.get("readme.txt"));</p>
			<p class="source-code">} catch (NullPointerException|IOException ex) {</p>
			<p class="source-code">    if (ex instanceof IOException) {</p>
			<p class="source-code">        System.out.println("Exception: File Not Found");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (ex instanceof NullPointerException) {</p>
			<p class="source-code">        System.out.println("Exception: NullPointer");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="callout-heading">How Many Different Exceptions Can You Catch in a Single Try?</p>
			<p class="callout">The fact is that you can daisy chain as many catch statements as you need to. If you use the second method that we discussed in this chapter (that is, using the OR statement), then you should remember that it is not possible to have a subclass together with its parent class. For example, it is not possible to have NoSuchFileException and IOException together in the same statement – they should be placed in two different catch statements.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>Exercise 1: Logging Exceptions</h2>
			<p>There are two main actions that you can perform when catching exceptions aside from any type of creative coding you may want to do to respond to the situation; these actions are logging or throwing. In this exercise, you will learn how to log the exception. In a later exercise, you will learn how to throw it instead. As we will reiterate in the <em class="italic">Best Practices for Handling Exceptions</em> section of this chapter, you should never do both at once:</p>
			<ol>
				<li>Create a new Java project in IntelliJ using the template for CLI. Name it LoggingExceptions. You will be creating classes inside it that you can then use later in other programs.</li>
				<li>In the code, you need to import the logging API by issuing the following command:<p class="source-code">import java.util.logging.*;</p></li>
				<li>Declare an object that you will be using to log the data into. This object will be printed to the terminal upon program termination; therefore, you don't need to worry about where it will end up at this point:<p class="source-code">Logger logger = Logger.getAnonymousLogger();</p></li>
				<li>Provoke an exception, as follows:<p class="source-code">String s = null;</p><p class="source-code">try {</p><p class="source-code">    System.out.println(s.length());</p><p class="source-code">} catch (NullPointerException ne) {</p><p class="source-code">    // do something here</p><p class="source-code">}</p></li>
				<li>At the time of catching the exception, send the data to the logger object using the <strong class="source-inline">log()</strong> method:<p class="source-code">logger.log(Level.SEVERE, "Exception happened", ne);</p></li>
				<li>Your full program should read as follows:<p class="source-code">import java.util.logging.*;</p><p class="source-code">public class LoggingExceptions {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Logger logger = Logger.getAnonymousLogger();</p><p class="source-code">        String s = null;</p><p class="source-code">        try {</p><p class="source-code">            System.out.println(s.length());</p><p class="source-code">        } catch (NullPointerException ne) {</p><p class="source-code">            logger.log(Level.SEVERE, "Exception happened", ne);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>When you execute the code, the output should be as follows:<p class="source-code">may 09, 2019 7:42:05 AM LoggingExceptions main</p><p class="source-code">SEVERE: Exception happened</p><p class="source-code">java.lang.NullPointerException</p><p class="source-code">      at LoggingExceptions.main(LoggingExceptions .java:10)</p><p class="source-code">Process finished with exit code 0</p></li>
				<li>As you can see, the exception is logged at the determined <strong class="source-inline">SEVERE</strong> level, but the code ends without an error code because we were able to handle the exception. The log is useful because it tells us where the exception happened in the code and, additionally, helps us to find the place of where we can dig deeper into the code and fix any potential issues.</li>
			</ol>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Throws and Throw</h1>
			<p>You can choose not to deal with some caught exceptions in your code at a low level, as described in the previous section. It could be interesting to filter out an exception's parent class and focus on detecting a subclass that might be of more importance to us. The <strong class="source-inline">throws</strong> keyword is used in the definition of the method you are creating and where the exception may occur. In the following case, which is a modification of <em class="italic">Example 09</em>, we should call throws in the definition of <strong class="source-inline">main()</strong>:</p>
			<p class="source-code"><a id="_idTextAnchor110"/>import java.io.*;</p>
			<p class="source-code">import java.nio.file.*;</p>
			<p class="source-code">import java.util.*;</p>
			<p class="source-code">public class Example10 {</p>
			<p class="source-code">    public static void main(String[] args) throws IOException {</p>
			<p class="source-code">        // declare a list that will contain all of the files</p>
			<p class="source-code">        // inside of the readme.txt file</p>
			<p class="source-code">        List&lt;String&gt; lines = Collections.emptyList();</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            lines = Files.readAllLines(Paths.get("readme.txt"));</p>
			<p class="source-code">        } catch (NoSuchFileException fe) {</p>
			<p class="source-code">            System.out.println("Exception: File Not Found");</p>
			<p class="source-code">            //fe.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // you will never see this print</p>
			<p class="source-code">        Iterator&lt;String&gt; iterator = lines.iterator();</p>
			<p class="source-code">        while (iterator.hasNext())</p>
			<p class="source-code">            System.out.println(iterator.next());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see, we are throwing any <strong class="source-inline">IOException</strong> that is occurring during runtime. In this way, we can focus on catching the one that actually happens: <strong class="source-inline">NoSuchFileException</strong>. It is possible to throw more than one exception type in this way by separating them using commas. </p>
			<p>An example of such a method definition is as follows:</p>
			<p class="source-code">public static void main(String[] args) throws IOException, NullPointerException {</p>
			<p>The one thing that is not possible is having an exception class and its subclass being thrown in the same method definition – just as we saw when trying to catch more than one exception in a single <strong class="source-inline">catch</strong> statement. It is also interesting to see that <strong class="source-inline">throws</strong> is operating at a certain scope; for example, we could disregard a certain exception within a method in a class but not a different one.</p>
			<p>On the other hand, there is yet another keyword that you will find relevant for dealing with exceptions as you advance in your understanding of the term. The <strong class="source-inline">throw</strong> keyword (note that this is not <strong class="source-inline">throws</strong>) will explicitly invoke an exception. You can use this to create your own exceptions and try them out in your code. We will demonstrate in a later section how you can create your own exception, and then we will use <strong class="source-inline">throw</strong> as part of the example to also see how exceptions propagate. The main reason to use <strong class="source-inline">throw</strong> is if you want your code to hand over an exception occurring within your class to another one higher up in the hierarchy. For the sake of learning about how this works, let's look at the following example:</p>
			<p class="source-code">public class Example11 {</p>
			<p class="source-code">    public static void main(String args[]) {</p>
			<p class="source-code">        String text = null;</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            System.out.println(text.length());</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            System.out.println("Exception: this should be a NullPointerException");</p>
			<p class="source-code">            throw new RuntimeException();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this case, we reproduce the <strong class="source-inline">NullPointerException</strong> example we saw earlier by trying to call the <strong class="source-inline">length()</strong> method on a string initialized as <strong class="source-inline">null</strong>. However, if you run this code, you will see that the exception that is being displayed is <strong class="source-inline">RuntimeException</strong>:</p>
			<p class="source-code">Exception: this should be a NullPointerException</p>
			<p class="source-code">Exception in thread "main" java.lang.RuntimeException</p>
			<p class="source-code">      at Example11.main(Example11.java:9)</p>
			<p class="source-code">Process finished with exit code 1</p>
			<p>The reason for this is the call to <strong class="source-inline">throw new RuntimeException()</strong> that we issued in the <strong class="source-inline">catch</strong> block. As you can see, when dealing with the exception, we are provoking a different exception. This can be very useful for catching exceptions and piping them through your own exceptions, or simply catching the exception, giving a meaningful message to help the user understand what went down, and then letting the exception continue its own path, and eventually crashing the program if the exception is not handled at a higher level in the code.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>Exercise 2: Breaking the Law (and Fixing It)</h2>
			<p>In this example, you will create your own checked exception class. You will define a class and then experiment by provoking that exception, logging its results, and then analyzing them:</p>
			<ol>
				<li value="1">Create a new Java project in IntelliJ using the template for CLI. Name it <strong class="source-inline">BreakingTheLaw</strong>. You will be creating classes inside it that you can use later in other programs.</li>
				<li>In the code, create a new class to describe your exception. This class should extend the base <strong class="source-inline">Exception</strong> class. Call it <strong class="source-inline">MyException</strong> and include the empty constructor:<p class="source-code">public class BreakingTheLaw {</p><p class="source-code">    class MyException extends Exception {</p><p class="source-code">        // Constructor</p><p class="source-code">        MyException() {};</p><p class="source-code">    }</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">      // write your code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Your constructor should include all the possibilities to be thrown. This implies that the constructor needs to contemplate several different cases:<p class="source-code">// Constructor</p><p class="source-code">public MyException() { </p><p class="source-code">    super(); </p><p class="source-code">}</p><p class="source-code">public MyException(String message) { </p><p class="source-code">    super(message); </p><p class="source-code">}</p><p class="source-code">public MyException(String message, Throwable cause) { </p><p class="source-code">    super(message, cause); </p><p class="source-code">}</p><p class="source-code">public MyException(Throwable cause) { </p><p class="source-code">    super(cause); </p><p class="source-code">}</p></li>
				<li>This will allow us to now wrap any exception with our newly formed exception. However, there are a couple of modifications that we should apply to our program in order for it to compile. First, we need to make the exception class static for it to work in the context we are using it in:<p class="source-code">public static class MyException extends Exception {</p></li>
				<li>Next, you need to make sure that the main class is throwing your new exception since you are going to be issuing that exception in the code:<p class="source-code">public static void main(String[] args) throws MyException {</p></li>
				<li>Finally, you need to generate some code that will provoke an exception, such as <strong class="source-inline">NullPointerException</strong>, when trying to get the length of a <strong class="source-inline">String</strong> initialized to <strong class="source-inline">null</strong>, <strong class="source-inline">catch</strong> it, and then <strong class="source-inline">throw</strong> it away using our newly created class:<p class="source-code">public static void main(String[] args) throws MyException {</p><p class="source-code">    String s = null;</p><p class="source-code">    try {</p><p class="source-code">        System.out.println(s.length());</p><p class="source-code">    } catch (NullPointerException ne) {</p><p class="source-code">        throw new MyException("Exception: my exception happened");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The result of running this code is as follows:<p class="source-code">Exception in thread "main" BreakingTheLaw$MyException: Exception: my exception happened</p><p class="source-code">      at BreakingTheLaw.main(BreakingTheLaw.java:26)</p><p class="source-code">Process finished with exit code 1</p></li>
				<li>You can now experiment with the call to <strong class="source-inline">throw</strong> by using any other of the constructors in the class. We just tried one that includes our own error message, so let's add the stack trace for the exception:<p class="source-code">throw new MyException("Exception: my exception happened", ne);</p></li>
				<li>What will make the output slightly more informative is that it will now include information about the exception that generated our own <strong class="source-inline">NullPointerException</strong>:<p class="source-code">Exception in thread "main" BreakingTheLaw$MyException: Exception: my exception happened</p><p class="source-code">      at BreakingTheLaw.main(BreakingTheLaw.java:26)</p><p class="source-code">Caused by: java.lang.NullPointerException</p><p class="source-code">      at BreakingTheLaw.main(BreakingTheLaw.java:24)</p><p class="source-code">Process finished with exit code 1</p><p>You have now learned how to use throw to wrap an exception into your own exception class. This can be very handy when dealing with a large codebase and having to look for the exceptions generated by your code in a long log file, or similar.</p><p class="callout-heading">Note</p><p class="callout">The final code can be referred at: <a href="https://packt.live/2VVdy2f">https://packt.live/2VVdy2f</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>The finally Block</h1>
			<p>The <strong class="source-inline">finally</strong> block can be used to execute some common code after any of the <strong class="source-inline">catch</strong> blocks used to handle a series of different exceptions in the code. Going back to our example where we tried to open a non-existing file, a modified version of it including a <strong class="source-inline">finally</strong> statement would look like the following: </p>
			<p class="source-code-heading">Example12.java</p>
			<p class="source-code">11         try {</p>
			<p class="source-code">12             // provoke an exception</p>
			<p class="source-code">13             lines = Files.readAllLines(Paths.get("readme.txt"));</p>
			<p class="source-code">14         } catch (NoSuchFileException fe) {</p>
			<p class="source-code">15             System.out.println("Exception: File Not Found");</p>
			<p class="source-code">16         } catch (IOException ioe) {</p>
			<p class="source-code">17             System.out.println("Exception: IOException");</p>
			<p class="source-code">18         } finally {</p>
			<p class="source-code">19             System.out.println("Exception: Case Closed");</p>
			<p class="source-code">20         }</p>
			<p class="source-code-link"><a href="https://packt.live/2VTBFOS">https://packt.live/2VTBFOS</a></p>
			<p>The output of the preceding example is as follows:</p>
			<p class="source-code">Exception: File Not Found</p>
			<p class="source-code">Exception: Case Closed</p>
			<p class="source-code">Process finished with exit code 0</p>
			<p>After the <strong class="source-inline">catch</strong> block detecting the <strong class="source-inline">NoSuchFileException</strong>, the handling mechanism jumps into the <strong class="source-inline">finally</strong> block and executes whatever is in it, which, in this case, implies printing yet another line of text to the output.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Activity 1: Designing an Exception Class Logging Data</h2>
			<p>We have seen examples of how to log exceptions and how to throw them. We have also learned how to create exception classes and throw them. With all that information, the goal of this activity is to create your own exception class that should log the different exceptions in terms of severity. You should make an application that is based on the arguments to the program, and the program will respond to the logging exceptions in different ways. Just to have a common ground, use the following standard:</p>
			<ol>
				<li value="1">If the input is number 1, issue the <strong class="source-inline">NullPointerException</strong> with a severity level of SEVERE.</li>
				<li>If the input is number 2, issue the <strong class="source-inline">NoSuchFileException</strong> with a severity level of WARNING.</li>
				<li>If the input is number 3, issue the <strong class="source-inline">NoSuchFileException</strong> with a severity level of INFO.</li>
				<li>In order to make this program, you will need to consider making your own methods for issuing exceptions, such as the following:<p class="source-code">public static void issuePointerException() throws NullPointerException {</p><p class="source-code">    throw new NullPointerException("Exception: file not found");</p><p class="source-code">}</p><p class="source-code">public static void issueFileException() throws NoSuchFileException {</p><p class="source-code">    throw new NoSuchFileException("Exception: file not found");</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 540.</p></li>
			</ol>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/>Best Practices for Handling Exceptions</h1>
			<p>Dealing with exceptions in your code requires following a set of best practices in order to avoid deeper issues when writing your programs. This list of common practices is of relevance to your code in order to keep some degree of professional programming consistency: </p>
			<p>The first piece of advice is to avoid throwing or catching the main <strong class="source-inline">Exception</strong> class. You need to be as specific as possible when dealing with an exception. Therefore, a case like the following is not recommended:</p>
			<p class="source-code">public class Example13 {</p>
			<p class="source-code">    public static void main(String args[]) {</p>
			<p class="source-code">        String text = null;</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            System.out.println(text.length());</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            System.out.println("Exception happened");</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This code listing will catch any exception, with no granularity. So, how are you supposed to properly handle the exception this way?</p>
			<p>In the following section, we will do a quick recap of where the Exception class is located within the Java API structure. We will examine how it hangs from the Throwable class at the same level as the Error class. Therefore, if you were to catch the Throwable class, you would mask possible errors occurring in your code and not only exceptions. Remember that errors are those situations when your code should be exited because they alert to a real malfunction that could lead to the misuse of JVM resources. </p>
			<p>Masking such a scenario behind a catch could stall the whole JVM. Therefore, avoid code like the following:</p>
			<p class="source-code">try {</p>
			<p class="source-code">    System.out.println(text.length());</p>
			<p class="source-code">} catch (Throwable e) {</p>
			<p class="source-code">    System.out.println("Exception happened");</p>
			<p class="source-code">}</p>
			<p>In <em class="italic">Exercise 2</em>, <em class="italic">Breaking the Law (and Fixing It)</em> you saw how to make your own exception class. As discussed, it is possible to redirect exceptions toward others by using <strong class="source-inline">throw</strong>. It is good practice to not disregard the stack trace of the original exception since it will help you to debug the source of the issue in a better way. Therefore, when catching the original exception, you should consider passing over the whole stack trace as a parameter to the exception constructor:</p>
			<p class="source-code">} catch (OriginalException e) {</p>
			<p class="source-code">    throw new MyVeryOwnException("Exception trace: ", e);</p>
			<p class="source-code">}</p>
			<p>In the same exercise, when making your own exception, you learned how to use the system's log to store the information of the exception. You should avoid both logging the exception and throwing it once more. You should try to log at the highest level possible in your code. Otherwise, you will get duplicated information about the situation inside your log, making the debugging a lot more complicated. Therefore, we recommend that you use the following:</p>
			<p class="source-code">throw new NewException();</p>
			<p>Alternatively, you can use the following inside the same <strong class="source-inline">catch</strong> block, but not for both:</p>
			<p class="source-code">log.error("Exception trace: ", e);</p>
			<p>Additionally, when logging information, try to use a single call to the system's log. As your code grows bigger, there will be multiple processes working in parallel, thus a lot of different sources will be issuing log commands:</p>
			<p class="source-code">log.debug("Exception trace happened here");</p>
			<p class="source-code">log.debug("It was a bad thing");</p>
			<p>This will most likely not show up as two consecutive lines in the log, but as two lines that are far apart. Instead, you should do something like this:</p>
			<p class="source-code">log.debug("Exception trace happened here. It was a bad thing");</p>
			<p>When dealing with multiple exceptions, some being subclasses of others, you should catch them in order, starting from the most specific. We have seen this in some of the examples in this chapter when, for example, dealing with <strong class="source-inline">NoSuchFileException</strong> and <strong class="source-inline">IOException</strong>. Your code should look like this:</p>
			<p class="source-code">try {</p>
			<p class="source-code">    tryAnExceptionCode();</p>
			<p class="source-code">} catch (SpecificException se) {</p>
			<p class="source-code">    doTheCatch1();</p>
			<p class="source-code">} catch (ParentException pe) {</p>
			<p class="source-code">    doTheCatch2();</p>
			<p class="source-code">}</p>
			<p>If you are not planning to catch the exception at all, but you are still forced to use the try block for the code to compile, use a finally block to close whatever actions were initiated prior to the exception. An example of this is opening a file that should be closed prior to leaving the method, which will happen because of the exception:</p>
			<p class="source-code">try {</p>
			<p class="source-code">    tryAnExceptionCode();</p>
			<p class="source-code">} finally {</p>
			<p class="source-code">    closeWhatever();</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">throw</strong> keyword is a very powerful tool, as you have noticed. Being able to redirect exceptions allows you to create your own strategy for handling different situations and, additionally, it means that you don't have to rely on the strategy provided by default by the JVM. However, you should be careful with placing <strong class="source-inline">throw</strong> in some of the blocks when catching. You should avoid using <strong class="source-inline">throw</strong> inside a <strong class="source-inline">finally</strong> block as it will mask the original reason for the exception.</p>
			<p>In a way, this is in line with the "throw early, catch late" principle when dealing with Java exceptions. Imagine that you are doing a low-level operation that is part of a larger method. For example, you are opening a file as part of a piece of code that will parse its contents and look for patterns. If the action of opening the file fails due to an exception, it is a better option to simply <strong class="source-inline">throw</strong> that exception to the following method for it to put in context and be able to decide at a higher level how to proceed with the whole task. You should handle the exceptions only when you can make final decisions at a higher level.</p>
			<p>We saw the use of <strong class="source-inline">printStackTrace()</strong> throughout the previous examples as a way to see the full source of an exception. While it is very interesting to be able to see that when debugging some code, it is also almost irrelevant when not being in that mindset. Therefore, you should make sure to either delete or comment away all the <strong class="source-inline">printStackTrace()</strong> commands you might have been using. Other developers will have to determine where they want to put their probes when analyzing the code later if that is ever needed.</p>
			<p>In a similar manner, when dealing with exceptions in whatever way inside your methods, you should remember to document things properly in your Javadoc. You should add an <strong class="source-inline">@throws</strong> declaration to clarify what kind of exception arrives and whether it is handled, passed over, or what:</p>
			<p class="source-code">/**</p>
			<p class="source-code">* Method name and description</p>
			<p class="source-code">*</p>
			<p class="source-code">* @param input</p>
			<p class="source-code">* @throws ThisStrangeException when ...</p>
			<p class="source-code">*/</p>
			<p class="source-code">public void myMethod(Integer input) throws ThisStrangeException {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/>Where Do Exceptions Come from?</h1>
			<p>Moving away from the more-pragmatic approach we have followed in this chapter, it is now time to put things into perspective and understand where things come from in the larger schema of the Java API. Exceptions, as mentioned in a previous section, hang from the <strong class="source-inline">Throwable</strong> class, which is part of the <strong class="source-inline">java.lang</strong> package. They are on the same level as errors (which we explained earlier). In other words, both <strong class="source-inline">Exception</strong> and <strong class="source-inline">Error</strong> are subclasses of <strong class="source-inline">Throwable</strong>.</p>
			<p>Only object instances of the <strong class="source-inline">Throwable</strong> class can be thrown by the Java <strong class="source-inline">throw</strong> statement; therefore, the way we had to define our own exception implied using this class as a point of departure. As stated in the Java documentation for the <strong class="source-inline">Throwable</strong> class, this includes a snapshot of the execution stack at the time of creation. This allows you to look for the source of the exception (or the error) because it includes the state of computer memory at that time. A throwable object can contain the reason for which it was constructed. This is what is known as the chained exception facility because one exceptional event might be caused by a certain chain of exceptions. This is something we have seen when analyzing the stack traces in some of the programs in this chapter.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor116"/>Summary</h1>
			<p>We have taken a very hands-on approach with this chapter. We started by making your code break in different ways, and then explained the differences between an error and an exception. We focused on ways to handle the latter because those are the only ones that should not make your program crash immediately. </p>
			<p>Exceptions can be handled by catching or throwing. The former is done by observing the different exceptions and defining different strategies to respond to the situations by means of a try-catch statement. You have the option of either resending the exception to a different class with the <strong class="source-inline">throw</strong> or responding within the <strong class="source-inline">catch</strong> block. Independently of what strategy you follow, you can set the system to execute some final lines of code after handling the exception using the <strong class="source-inline">finally</strong> block. </p>
			<p>This chapter also included a series of recommendations on how to deal with exceptions on a more conceptual level. You have a list of best practices that any professional programmer will follow. </p>
			<p>Finally, at the practical level, you worked on a number of exercises that guided you through classic scenarios of dealing with exceptions, and you have seen different tools that you can use to debug your code, such as logs and <strong class="source-inline">printStackTrace()</strong>.</p>
		</div>
	</body></html>