<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer117">
			</div>
		</div>
		<div class="Content" id="_idContainer118">
			<h1 id="_idParaDest-321"><a id="_idTextAnchor332"/>17. Reactive Programming with Java Flow</h1>
		</div>
		<div class="Content" id="_idContainer121">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter covers the Java Flow API and the advantages of the Reactive Streams specification. It will first define, in general terms, the motivation for Flow and Reactive Streams, as well as the respective functions of Publishers, Subscribers, and Processors in Java. You will then learn to use the basic <strong class="source-inline">SubmissionPublisher</strong> to build a reactive application and, in the final sections, practice implementing a simple Subscriber and Processor using Flow.</p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor333"/>Introduction</h1>
			<p>The Reactive Streams specification presents an ongoing development within software architecture, referred to as Reactive Systems. These systems, ideally, have the following advantages:</p>
			<ul>
				<li>A faster response</li>
				<li>More controlled responses in relation to one another</li>
				<li>Increased reliability</li>
			</ul>
			<p>A natively supported API for developing Reactive Systems<a id="_idTextAnchor334"/> or applications was introduced in Java 9, called Flow.</p>
			<p>The Java 9 Flow API was not intended to compete with the already developed, highly adopted, and appreciated reactive libraries or APIs available out there. The biggest reason for the advent of the Flow API was the need for a common denominator amongst these libraries; to ensure that the core of reactive programming would be the same regardless of which implementation you use. That way, you can easily translate from one implementation to another.</p>
			<p>To achieve this, the Java Flow API adheres to the Reactive Streams specification—the specification that most of the libraries available use as a blueprint for their design. The Reactive Streams initiative, which designed the specification, was started in 2013 by Netflix and several other large corporations with a vested interest in delivering content reliably.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While they may share a lot of the same lingo, the Flow API is not in any way related to the Streams API of Java 8. They are focused on solving different kinds of problems.</p>
			<p>In simple terms, reactive programming is a way to write programs using components that communicate with each other by streaming events. These events are often asynchronous in nature and should never overwhelm the receiving party. Within a reactive system, there are two main components—publishers and subscribers. This is similar to a networked pub/sub system, but on a micro-scale.</p>
			<p>The Java Flow API (or rather Reactive Streams, which Flow adheres to) has three main actors:</p>
			<ul>
				<li>The Publisher has the knowledge of the available data and pushes it on-demand to any interested subscriber.</li>
				<li>The Subscriber is the one demanding the data.</li>
				<li>The Processor may sit between a publisher and a subscriber. Processors can intercept and transform the published data before releasing it to a subscriber or another processor. Thus, the processor can act as both a subscriber and a publisher.</li>
			</ul>
			<p>Communication between these components is of both a push and pull nature. The subscriber first asks the publisher to send, at most, <strong class="source-inline">n</strong> messages. That's the pull part of the communication. Following that request, the publisher will begin to send messages to the subscriber, but it will never exceed <strong class="source-inline">n</strong> messages.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer119">
					<img alt="Figure 17.1: Communication between the Subscriber and the Publisher&#13;&#10;" src="image/C13927_17_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.1: Communication between the Subscriber and the Publisher</p>
			<p>When the publisher has sent the final message, it will provide a notification that the sending of messages is complete, and the subscriber may then act as needed—probably requesting more messages or aborting the communication entirely.</p>
			<p>The entire Flow API, which we will look into further in this chapter, is defined in a single Java class. It contains one interface for each of the actors, and an extra interface describing the subscription object, which is the messaging link between the publisher and subscriber.</p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor335"/>Publisher</h1>
			<p>The publisher holds the data that other components are interested in getting. The publisher will wait until a subscriber who is interested in the data requests n-number of items to be sent, and will only then start sending those items to the subscriber.</p>
			<p>Asking for a specific number of items, rather than asking for everything, is called backpressure, and is very important in the Reactive Streams specification. This backpressure lets listeners request only as many items as they can handle at a time, ensuring that the application will not stall or crash.</p>
			<p>The interface for <strong class="source-inline">Publisher</strong> in Flow, and Reactive Streams looks like this: </p>
			<p class="source-code">@FunctionalInterface</p>
			<p class="source-code">public static interface Publisher&lt;T&gt; {</p>
			<p class="source-code">    public void subscribe(Subscriber&lt;? super T&gt; subscriber);</p>
			<p class="source-code">}</p>
			<p>You'll notice that it's a functional interface, which can be implemented as a lambda, should you wish.</p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor336"/>SubmissionPublisher</h2>
			<p>Creating a fully functional Publisher can be quite a complicated endeavor. Luckily, Flow includes a complete implementation called <strong class="source-inline">SubmissionPublisher</strong>. We'll use this class in several examples in this chapter.</p>
			<p>You can use <strong class="source-inline">SubmissionPublisher</strong> either directly, as a component, or as a superclass for your extended <strong class="source-inline">Publisher</strong>. <strong class="source-inline">SubmissionPublisher</strong> requires an <strong class="source-inline">Executor</strong> and a buffer size. By default, it will use the common <strong class="source-inline">ForkJoinPool</strong> and a buffer size of 256:</p>
			<p class="source-code">SubmissionPublisher&lt;?&gt; publisher = new SubmissionPublisher&lt;&gt;();</p>
			<p class="source-code">SubmissionPublisher&lt;?&gt; publisher = new SubmissionPublisher&lt;&gt;(ForkJoinPool.commonPool(), Flow.defaultBufferSize());</p>
			<p>The choice of executor should be based on how your application is designed and the tasks it is supposed to handle. In some cases, the common <strong class="source-inline">ForkJoinPool</strong> is the best choice, while in other situations, a scheduled thread pool may work better. You may need to try different executors and buffer sizes to find the combination that best suits your needs:</p>
			<p class="source-code">SubmissionPublisher&lt;?&gt; publisher = new SubmissionPublisher&lt;&gt;(Executors.newCachedThreadPool(), 512);</p>
			<p>You may also use <strong class="source-inline">SubmissionPublisher</strong> as a superclass for your own implementation.</p>
			<p>In the following example, <strong class="source-inline">MyPublisher</strong> extends <strong class="source-inline">SubmissionPublisher</strong>, but defines a fixed <strong class="source-inline">threadpool</strong> executor rather than the common <strong class="source-inline">ForkJoinPool</strong> executor: </p>
			<p class="source-code">public class MyPublisher extends SubmissionPublisher&lt;String&gt; {</p>
			<p class="source-code">    public MyPublisher() {</p>
			<p class="source-code">        super(Executors.newFixedThreadPool(1), Flow.defaultBufferSize());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<h1 id="_idParaDest-325"><a id="_idTextAnchor337"/>Subscriber</h1>
			<p>The subscriber represents the end-user. It receives the data at the very end of the stream and acts on it. The action may include updating a user interface, pushing it to another component, or transforming it in any way.</p>
			<p>The interface of the subscribers contains four different callbacks, each of which represents a message of some type from the publisher or the subscriber itself:</p>
			<ul>
				<li><strong class="source-inline">onSubscribe:</strong> The <strong class="source-inline">onSubscribe</strong> method is invoked as soon as the subscriber has a valid subscription. Generally, this is used to kick-start the delivery of items from the publisher. The <strong class="source-inline">Subscriber</strong> will typically inform the <strong class="source-inline">Publisher</strong> here, by requesting another item.</li>
				<li><strong class="source-inline">onNext:</strong> The <strong class="source-inline">onNext</strong> method is invoked when another item is made available from the <strong class="source-inline">Publisher</strong>.</li>
				<li><strong class="source-inline">onError:</strong> The <strong class="source-inline">onError</strong> method is invoked when an error occurs. This usually means that the subscriber will no longer receive any more messages and should be closed down.</li>
				<li><strong class="source-inline">onComplete:</strong> The <strong class="source-inline">onComplete</strong> method is invoked by the publisher when the final item has been sent.</li>
			</ul>
			<p>The following example illustrates all of these callbacks:</p>
			<p class="source-code">public static interface Subscriber&lt;T&gt; {</p>
			<p class="source-code">    public void onSubscribe(Subscription subscription);</p>
			<p class="source-code">    public void onNext(T item);</p>
			<p class="source-code">    public void onError(Throwable throwable);</p>
			<p class="source-code">    public void onComplete();</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor338"/>Subscription</h2>
			<p>A <strong class="source-inline">Subscriber</strong> may use the Subscription API to control a publisher, either by requesting more items, or by canceling the subscription altogether:</p>
			<p class="source-code">public static interface Subscription {</p>
			<p class="source-code">    public void request(long n);</p>
			<p class="source-code">    public void cancel();</p>
			<p class="source-code">}</p>
			<p>It is the <strong class="source-inline">Publisher</strong> who creates the subscriptions. It does this whenever a <strong class="source-inline">Subscriber</strong> has subscribed to that <strong class="source-inline">Publisher</strong>. If a <strong class="source-inline">Subscriber</strong> happens to subscribe twice to one publisher, it will fire the <strong class="source-inline">onError()</strong> callback with <strong class="source-inline">IllegalStateException</strong>.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor339"/>Exercise 1: A Simple Application with a Single Publisher and a Single Subscriber</h2>
			<p>In this exercise, we will build an application with a single <strong class="source-inline">Publisher</strong> and a single <strong class="source-inline">Subscriber</strong>. The <strong class="source-inline">Publisher</strong> will send a string of messages to the <strong class="source-inline">Subscriber</strong>, which will then print it to the terminal. The messages are found in the <strong class="source-inline">lipsum.txt</strong> file, which should be placed in your <strong class="source-inline">projects /res</strong> folder. For this exercise, we will use the common <strong class="source-inline">ForkJoinPool</strong> to generate the executor:</p>
			<ol>
				<li>If IntelliJ is already started, but no project is open, select <strong class="source-inline">Create New Project</strong>. If IntelliJ already has a project opened, select <strong class="source-inline">File</strong> à <strong class="source-inline">New</strong> à <strong class="source-inline">Project</strong> from the menu.</li>
				<li>In <strong class="source-inline">New Project</strong> dialog, select a Java project, and then click <strong class="source-inline">Next</strong>.</li>
				<li>Check the box to create the project from a template. Select <strong class="source-inline">Command Line App</strong>, and then click <strong class="source-inline">Next</strong>.</li>
				<li>Name the new project <strong class="source-inline">Chapter17</strong>.</li>
				<li>IntelliJ will give you a default project location. If you wish to select a different one, you may enter it here.</li>
				<li>Set the package name to <strong class="source-inline">com.packt.java.chapter17</strong>.</li>
				<li>Click <strong class="source-inline">Finish</strong>.<p>IntelliJ will create your project, called <strong class="source-inline">Chapter17</strong>, with the standard folder structure. IntelliJ will also create a main entry point called <strong class="source-inline">Main.java</strong>.</p></li>
				<li>Rename this file to <strong class="source-inline">Exercise1.java</strong>. When you're done, it should look like this:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    // write your code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We will use <strong class="source-inline">SubmissionPublisher</strong> in this exercise. This is a fully functional implementation of the <strong class="source-inline">Publisher</strong> interface, which you can use to demonstrate the basic functionality of a reactive application. Declare a default <strong class="source-inline">SubmissionPublisher</strong>, as shown here, and then initialize it:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Flow doesn't come with any already available implementations of <strong class="source-inline">Subscriber</strong>, so we will need to implement our own <strong class="source-inline">Subscriber</strong>. Create a new class called <strong class="source-inline">LipsumSubscriber</strong>, and allow it to implement the <strong class="source-inline">Flow.Subscriber</strong> interface. Your new class should look something like the following example:<p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The subscriber has four methods to implement. The <strong class="source-inline">onSubscribe</strong> method will be called by the publisher when the <strong class="source-inline">Subscription</strong> object has been created. Usually, you'll store a reference to that subscription so that you can issue requests to the publisher, create a <strong class="source-inline">Flow.Subscription</strong> member variable in your <strong class="source-inline">LipsumSubscriber</strong> class, and store the reference from the <strong class="source-inline">onSubscribe</strong> method:<p class="source-code">    private Flow.Subscription subscription;</p><p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">        this.subscription = subscription;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Usually, you'll also request at least one item when the subscription has been created. Use the <strong class="source-inline">request</strong> method to ask for one item from the publisher:<p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">        this.subscription = subscription;</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Looking at the next method in the class, called <strong class="source-inline">onNext</strong>, this is the callback executed by the <strong class="source-inline">Publisher</strong> whenever an item is issued to all subscribers. In this example, we will simply print the contents of the item:<p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">        System.out.println(item);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>To keep getting more items from the publisher, we need to keep requesting them; this is what is called backpressure. It's the subscriber who is in control in terms of how many items it can handle at a time. In this exercise, we'll handle one item at a time and then request another. Request another item after you've printed the current item to the console:<p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">        System.out.println(item);</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The subscriber can use the methods <strong class="source-inline">onError</strong> and <strong class="source-inline">onComplete</strong> to perform a cleanup and make sure that no resources are kept in vain. In this example, we will simply print the error and a completion message:<p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">        System.out.println(throwable.getMessage());</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">        System.out.println("completed");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Back in the <strong class="source-inline">main</strong> method, create a new subscriber and allow it to subscribe to the publisher:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;();</p><p class="source-code">        LipsumSubscriber lipsumSubscriber = new LipsumSubscriber();</p><p class="source-code">        publisher.subscribe(lipsumSubscriber);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>However, this will not actually do anything. The publisher still has no data to send, so we need to provide the data to the publisher as well. We'll use the <strong class="source-inline">lipsum.txt</strong> file as the source. Copy the file to the <strong class="source-inline">res/</strong> folder in your project. Create the folder if it doesn't already exist:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;();</p><p class="source-code">        LipsumSubscriber lipsumSubscriber = new LipsumSubscriber();</p><p class="source-code">        publisher.subscribe(lipsumSubscriber);</p><p class="source-code">        String filePath = "res/lipsum.txt";</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>To send the words from the <strong class="source-inline">lipsum.txt</strong> file to the <strong class="source-inline">Publisher</strong>, you need to load the file into some kind of container. We will use the <strong class="source-inline">Stream</strong> API to load the words, and then push them to the publisher immediately. Wrap the stream in a try-with-resources block to enable the JVM to auto-close the resource after loading it:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;();</p><p class="source-code">        LipsumSubscriber lipsumSubscriber = new LipsumSubscriber();</p><p class="source-code">        publisher.subscribe(lipsumSubscriber);</p><p class="source-code">        String filePath = "res/lipsum.txt";</p><p class="source-code">        try (Stream&lt;String&gt; words = Files.lines(Paths.get(filePath))) {</p><p class="source-code">            words.flatMap((l) -&gt; Arrays.stream(l.split("[\\s.,\\n]+")))              .forEach(publisher::submit);</p><p class="source-code">        } catch (IOException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p>Here, we are loading the file as a stream of strings. It will load the lines from the file into one string each. Since every line may contain multiple words, we need to apply a flat mapping to each line to extract the words. We are using a simple regular expression to split the lines into words, looking for one or more whitespaces, punctuation items, or a new line.</p><p class="callout-heading">Note</p><p class="callout">You can read more about the Streams API, and the different methods used here, in <em class="italic">Chapter 15</em>, <em class="italic">Processing Data with Streams</em>.</p></li>
				<li>At this point, the program will execute and print all the words available in the file. However, you may notice that it does not print any completion messages. That is because we haven't actually notified the subscribers that the stream has ended. Send the completion signal, as seen here:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise1 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        SubmissionPublisher&lt;String&gt; publisher = new SubmissionPublisher&lt;&gt;();</p><p class="source-code">        LipsumSubscriber lipsumSubscriber = new LipsumSubscriber();</p><p class="source-code">        publisher.subscribe(lipsumSubscriber);</p><p class="source-code">        String filePath = "res/lipsum.txt";</p><p class="source-code">        try (Stream&lt;String&gt; words = Files.lines(Paths.get(filePath))) {</p><p class="source-code">            words.flatMap((l) -&gt; Arrays.stream(l.split("[\\s.,\\n]+")))              .forEach(publisher::submit);</p><p class="source-code">            publisher.close();</p><p class="source-code">        } catch (IOException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p>Running this program should yield the following output in the console:</p><p class="source-code">Lorem</p><p class="source-code">ipsum</p><p class="source-code">dolor</p><p class="source-code">sit</p><p class="source-code">amet</p><p class="source-code">consectetur</p><p class="source-code">adipiscing</p><p class="source-code">elit</p><p class="source-code">Pellentesque</p><p class="source-code">malesuada</p><p class="source-code">ultricies</p><p class="source-code">ultricies</p><p class="source-code">Curabitur</p><p class="source-code">...</p></li>
			</ol>
			<p>Having built your first reactive application, you may notice that it doesn't really make much sense to use this extra logic in a very simple program, as shown in this example. Applying the Reactive Streams concept to a simple example makes very little sense as it is meant to be used in asynchronous applications, where you may not be sure when, or if, a Subscriber can currently receive messages.</p>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor340"/>Processor</h1>
			<p>The Processor is something of a chameleon in Flow; it may act as both a <strong class="source-inline">Subscriber</strong> and a <strong class="source-inline">Publisher</strong>.</p>
			<p>There are several different reasons for adding an interface such as the Processor. One reason may be that you have a stream of data that you do not fully trust. Imagine an asynchronous flow of data from a server, where data is delivered over a UDP connection that lacks promises of delivery; this data will eventually be corrupted and you need to handle that. A simple way would be to inject a filter of some kind between the publisher and subscriber. This is where a <strong class="source-inline">Processor</strong> excels.</p>
			<p>Another reason for using a Processor could be to separate a polymorphic data stream between different subscribers so that alternative actions may be taken based on the data type.</p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor341"/>Exercise 2: Using a Processor to Convert a Stream of Strings to Numbers</h2>
			<p>In this exercise, we will first build a Publisher that periodically publishes a string from a text file. Then, we will use a scheduler to control the timer. The Subscriber should then attempt to transform a certain string to a number. The <strong class="source-inline">numbers.txt</strong> file will be used to build this application. In this example, we will also show how to clean up the handling of the data using a Supplier implementation to make the data source abstract.</p>
			<p>The <strong class="source-inline">numbers.txt</strong> file contains intentional errors that we will handle by applying a processor before the subscriber:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Chapter17</strong> project in IDEA if it's not already opened.</li>
				<li>Create a new Java class, using the <strong class="source-inline">File</strong> | <strong class="source-inline">New</strong> |<strong class="source-inline">Java Class</strong> menu.</li>
				<li>In the <strong class="source-inline">Create New Class</strong> dialog, enter <strong class="source-inline">Exercise2</strong> as <strong class="source-inline">Name</strong>, and select <strong class="source-inline">OK</strong>.<p>IntelliJ will create your new class. It should look something like the following snippet:</p><p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">main</strong> method to this class:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main (String[] args) {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We will continue using the basic <strong class="source-inline">SubmissionPublisher</strong> supplied in the Flow library, but in this exercise, we'll create our own subclass. Create a new class called <strong class="source-inline">NumberPublisher</strong>. This should extend <strong class="source-inline">SubmissionPublisher</strong>, as shown in the following code block:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class NumberPublisher extends SubmissionPublisher&lt;String&gt; {</p><p class="source-code">}</p></li>
				<li>Our new <strong class="source-inline">NumberPublisher</strong> should publish numbers periodically to any interested <strong class="source-inline">Subscriber</strong>. There are several different options in terms of how to accomplish this, but probably the easiest solution is to use a <strong class="source-inline">Timer</strong>. Add a <strong class="source-inline">Timer</strong>, and a <strong class="source-inline">TimerTask</strong> to your publisher:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.Timer;</p><p class="source-code">import java.util.TimerTask;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class NumberPublisher extends SubmissionPublisher&lt;String&gt; {</p><p class="source-code">    final Timer timer = new Timer();</p><p class="source-code">    final TimerTask timerTask = new TimerTask() {</p><p class="source-code">        @Override</p><p class="source-code">        public void run() {</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    public NumberPublisher() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>When the publisher is shutting down, so should <strong class="source-inline">Timer</strong>. Override the publisher's <strong class="source-inline">close()</strong> method, and add a call to the <strong class="source-inline">cancel()</strong> method of <strong class="source-inline">Timer</strong> just before the publisher is about to shut down:<p class="source-code">    @Override</p><p class="source-code">    public void close() {</p><p class="source-code">        timer.cancel();</p><p class="source-code">        super.close();</p><p class="source-code">    }</p></li>
				<li>There are two different ways to let the publisher send items to the connected subscribers. Using either <strong class="source-inline">submit()</strong> or <strong class="source-inline">offer()</strong>. <strong class="source-inline">submit()</strong> works in a fire-and-forget fashion, while <strong class="source-inline">offer()</strong> lets the publisher retry sending the item once using a handler. In our case, <strong class="source-inline">submit()</strong> would work just fine. But, before you can submit, you need some data. Add a <strong class="source-inline">Supplier</strong> to the <strong class="source-inline">Publisher</strong> using dependency injection:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.Timer;</p><p class="source-code">import java.util.TimerTask;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">import java.util.function.Supplier;</p><p class="source-code">public class NumberPublisher extends SubmissionPublisher&lt;String&gt; {</p><p class="source-code">    final Timer timer = new Timer();</p><p class="source-code">    final TimerTask timerTask = new TimerTask() {</p><p class="source-code">        @Override</p><p class="source-code">        public void run() {</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    final Supplier&lt;String&gt; supplier;</p><p class="source-code">    public NumberPublisher(Supplier&lt;String&gt; supplier) {</p><p class="source-code">        this.supplier = supplier;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void close() {</p><p class="source-code">        timer.cancel();</p><p class="source-code">        super.close();</p><p class="source-code">    }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">A supplier is a functional interface that is often used to deliver results – to anyone and anything.</p></li>
				<li>Now that we know how to get the data we need using <strong class="source-inline">Supplier</strong>, we can actually send it to the subscribers. Inside the <strong class="source-inline">run()</strong> method of <strong class="source-inline">TimerTask</strong>, add a call to <strong class="source-inline">submit()</strong> and get the data from the supplier:<p class="source-code">        @Override</p><p class="source-code">        public void run() {</p><p class="source-code">            submit(supplier.get());</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    final Supplier&lt;String&gt; supplier;</p><p class="source-code">    public NumberPublisher(Supplier&lt;String&gt; supplier) {</p><p class="source-code">        this.supplier = supplier;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void close() {</p><p class="source-code">        timer.cancel();</p><p class="source-code">        super.close();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>One last thing remains, because the publisher may run into trouble when attempting to either get items from the supplier or send items onward. We need to catch any exception when attempting to execute the <strong class="source-inline">submit()</strong> method. Add a try-catch clause, and use a <strong class="source-inline">closeExceptionally()</strong> method to inform any subscriber that we ran into difficulty. Executing <strong class="source-inline">closeExceptionally()</strong> will force the publisher into a state where it cannot send anything else out:<p class="source-code">        @Override</p><p class="source-code">        public void run() {</p><p class="source-code">            try {</p><p class="source-code">                submit(supplier.get());</p><p class="source-code">            } catch (Exception e) {</p><p class="source-code">                closeExceptionally(e);</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    final Supplier&lt;String&gt; supplier;</p><p class="source-code">    public NumberPublisher(Supplier&lt;String&gt; supplier) {</p><p class="source-code">        this.supplier = supplier;</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void close() {</p><p class="source-code">        timer.cancel();</p><p class="source-code">        super.close();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, <strong class="source-inline">TimerTask</strong> is fully implemented. The data is injected into <strong class="source-inline">Publisher</strong> using <strong class="source-inline">Supplier</strong>, and shutdown handling is ready. All that remains to do is to actually schedule periodic publishing. Using <strong class="source-inline">Timer</strong>, schedule <strong class="source-inline">TimerTask</strong> for repeat execution every 1 second. Since <strong class="source-inline">TimerTask</strong> accepts only milliseconds, we need to remember to multiply the delay by <strong class="source-inline">1000</strong>. We're also setting the initial delay to <strong class="source-inline">1000</strong> milliseconds:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.Timer;</p><p class="source-code">import java.util.TimerTask;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">import java.util.function.Supplier;</p><p class="source-code">public class NumberPublisher extends SubmissionPublisher&lt;String&gt; {</p><p class="source-code">    final Timer timer = new Timer();</p><p class="source-code">    final TimerTask timerTask = new TimerTask() {</p><p class="source-code">        @Override</p><p class="source-code">        public void run() {</p><p class="source-code">            try {</p><p class="source-code">                submit(supplier.get());</p><p class="source-code">            } catch (Exception e) {</p><p class="source-code">                closeExceptionally(e);</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    final Supplier&lt;String&gt; supplier;</p><p class="source-code">    public NumberPublisher(Supplier&lt;String&gt; supplier) {</p><p class="source-code">        this.supplier = supplier;</p><p class="source-code">        this.timer.schedule(timerTask, 1000, 1000);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void close() {</p><p class="source-code">        timer.cancel();</p><p class="source-code">        super.close();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now that our <strong class="source-inline">NumberPublisher</strong> is ready, we need to start feeding it data, but in order to feed it the data that should be published, we need to load the data. The data we're going to send is located in the <strong class="source-inline">numbers.txt</strong> file. Copy the <strong class="source-inline">numbers.txt</strong> file to the <strong class="source-inline">/res</strong> folder, creating the folder if it doesn't already exist.</li>
				<li>In the <strong class="source-inline">Exercise2 </strong>class, create a new method called <strong class="source-inline">getStrings()</strong>, which will return the numbers from the <strong class="source-inline">numbers.txt</strong> file as <strong class="source-inline">Strings</strong>:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    private static String[] getStrings() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In this new method, create a variable called <strong class="source-inline">filePath</strong>. Let it point to the <strong class="source-inline">numbers.txt</strong> file, located in the <strong class="source-inline">/res</strong> folder. We will use this <strong class="source-inline">filePath</strong> variable to load the file contents in the next step:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    private static String[] getStrings() {</p><p class="source-code">        String filePath = "res/numbers.txt";</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Load the file contents into a <strong class="source-inline">String</strong> stream, and then wrap the load in a try-with-resources block so that we don't need to care about releasing the file resources when we're done:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    private static String[] getStrings() {</p><p class="source-code">        String filePath = "res/numbers.txt";</p><p class="source-code">        try (Stream&lt;String&gt; words = Files.lines(Paths.get(filePath))) {</p><p class="source-code">            </p><p class="source-code">        } catch (IOException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">numbers.txt</strong> file contains lots of numbers and some other characters that might cause trouble later on. But, in order to actually decode the file to single words, we need to review the structure of the file. Let's open it, and you should see something like this—multiple rows with a column-like structure:<p class="source-code">6   2e   22    4   11   59   73   41   60    8</p><p class="source-code">42   91   99   89   17   96   54   24   77   36</p><p class="source-code">12    9   64   0a   31   75    1   14   34   56</p><p class="source-code">67   78   37   87   93   92  100   28   47    5</p><p class="source-code">52   85   29   38   21   88   65   81   25   70</p><p class="source-code">95    3   74    2   35   84   32   66   86   69</p><p class="source-code">58   45   48   10   26   53   40   13   49   94</p><p class="source-code">98   71   39   68   76   43   63   7g   72   80</p><p class="source-code">61   46   57   18   79   27   20   83   82   33</p><p class="source-code">97   2h   50   44   15   16   55   30   19   51</p></li>
				<li>The stream of strings we've just loaded will not be of much help. Each item in the stream will represent a whole line, and we need to transform the stream before it will be useful to us. First of all, apply a <strong class="source-inline">flatMap</strong> operator to create a new stream for each item in the original stream. This will let us split each line up into multiple items, and return them to the main stream:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    private static String[] getStrings() {</p><p class="source-code">        String filePath = "res/numbers.txt";</p><p class="source-code">        try (Stream&lt;String&gt; words = Files.lines(Paths.get(filePath))) {</p><p class="source-code">            return words.flatMap((line) -&gt;               Arrays.stream(line.split("[\\s\\n]+")))</p><p class="source-code">        } catch (IOException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">} </p><p class="callout-heading">Note</p><p class="callout">You can read more about processing data with Streams in <em class="italic">Chapter 15</em>, <em class="italic">Processing Data with Streams</em>, and regular expressions in <em class="italic">Chapter 12</em>, <em class="italic">Regular Expressions</em>.</p></li>
				<li>The stream now contains items representing each column for each line. But, in order to use the data, we need to filter it based on length as we don't want any <strong class="source-inline">0</strong> length words, and then we need to turn the stream into an array of strings. Filter the items of the stream, allowing only words with a length in excess of <strong class="source-inline">0</strong> to pass:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    private static String[] getStrings() {</p><p class="source-code">        String filePath = "res/numbers.txt";</p><p class="source-code">        try (Stream&lt;String&gt; words = Files.lines(Paths.get(filePath))) {</p><p class="source-code">            return words.flatMap((line) -&gt; Arrays.stream(line.split("[\\s\\n]+")))</p><p class="source-code">                    .filter((word) -&gt; word.length() &gt; 0)</p><p class="source-code">        } catch (IOException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now, turn the whole stream into an array of strings. This will return an array of strings to the caller of the method. However, if we do have an error in reading the file, we need to return something too. Return <strong class="source-inline">null</strong> at the very end of the <strong class="source-inline">getStrings()</strong> method. The publisher will interpret <strong class="source-inline">null</strong> as an error and throw <strong class="source-inline">NullPointerException</strong>, closing the connection to the subscriber:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">    }</p><p class="source-code">    private static String[] getStrings() {</p><p class="source-code">        String filePath = "res/numbers.txt";</p><p class="source-code">        try (Stream&lt;String&gt; words = Files.lines(Paths.get(filePath))) {</p><p class="source-code">            return words.flatMap((line) -&gt;               Arrays.stream(line.split("[\\s\\n]+")))</p><p class="source-code">                    .filter((word) -&gt; word.length() &gt; 0)</p><p class="source-code">                    .toArray(String[]::new);</p><p class="source-code">        } catch (IOException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        } </p><p class="source-code">        return null;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The data for our little program is ready for pushing into the publisher so that it can send it to any interested subscriber. Now, we need to build a supplier that will take these strings and send them to the publisher, one by one, when the publisher requests them. Create a supplier in the <strong class="source-inline">main</strong> method of the <strong class="source-inline">Exercise2</strong> class:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.function.Supplier;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {</p><p class="source-code">            @Override</p><p class="source-code">            public String get() {</p><p class="source-code">                return null;</p><p class="source-code">            }</p><p class="source-code">        };</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Let the Supplier call <strong class="source-inline">getStrings()</strong> to retrieve the full array:<p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {</p><p class="source-code">            @Override</p><p class="source-code">            public String get() {</p><p class="source-code">                String[] data = getStrings();</p><p class="source-code">                return null;</p><p class="source-code">            }</p><p class="source-code">        };</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The supplier, however, cannot return the entire dataset; it is designed to return one string at a time. For this to work, we need to keep an index of the last string sent to <strong class="source-inline">Supplier</strong>:<p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {</p><p class="source-code">            int index;</p><p class="source-code">            @Override</p><p class="source-code">            public String get() {</p><p class="source-code">                String[] data = getStrings();</p><p class="source-code">                return data[index];</p><p class="source-code">            }</p><p class="source-code">        };</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>This will constantly return the first number in the file, and that's not what we want. So, we need to increment the index every time someone asks the supplier for a string:<p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {</p><p class="source-code">            int index;</p><p class="source-code">            @Override</p><p class="source-code">            public String get() {</p><p class="source-code">                String[] data = getStrings();</p><p class="source-code">                return data[index++];</p><p class="source-code">            }</p><p class="source-code">        };</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>This, however, will throw an exception when we reach the final number in the file. So, we need to protect against that. In this case, we'll return <strong class="source-inline">null</strong> when we reach the end. Add an <strong class="source-inline">if</strong> statement, checking that we haven't gone too far:<p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {</p><p class="source-code">            int index;</p><p class="source-code">            @Override</p><p class="source-code">            public String get() {</p><p class="source-code">                String[] data = getStrings();</p><p class="source-code">                if (index &lt; data.length - 1) {</p><p class="source-code">                    return data[index++];</p><p class="source-code">                } else {</p><p class="source-code">                    return null;</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        };</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The supplier is now ready to be used by our <strong class="source-inline">NumberPublisher</strong>. Create an instance of <strong class="source-inline">NumberPublisher</strong> in the <strong class="source-inline">main()</strong> method of <strong class="source-inline">Exercise2</strong>, passing the supplier as an argument:<p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {</p><p class="source-code">            int index;</p><p class="source-code">            @Override</p><p class="source-code">            public String get() {</p><p class="source-code">                String[] data = getStrings();</p><p class="source-code">                if (index &lt; data.length - 1) {</p><p class="source-code">                    return data[index++];</p><p class="source-code">                } else {</p><p class="source-code">                    return null;</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        };</p><p class="source-code">        NumberPublisher publisher = new NumberPublisher(supplier);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create a Subscriber and allow it to request an item on subscription success. Then, request a new item every time it receives an item—backpressure. While implementing the subscriber, add printouts for every method so that we can easily see what's happening:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.function.Supplier;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {</p><p class="source-code">            int index;</p><p class="source-code">            @Override</p><p class="source-code">            public String get() {</p><p class="source-code">                String[] data = getStrings();</p><p class="source-code">                if (index &lt; data.length - 1) {</p><p class="source-code">                    return data[index++];</p><p class="source-code">                } else {</p><p class="source-code">                    return null;</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        };</p><p class="source-code">        NumberPublisher publisher = new NumberPublisher(supplier);</p><p class="source-code">        publisher.subscribe(new Flow.Subscriber&lt;&gt;() {</p><p class="source-code">            Flow.Subscription subscription;</p><p class="source-code">            @Override</p><p class="source-code">            public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">                this.subscription = subscription;</p><p class="source-code">                subscription.request(1);</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onNext(String item) {</p><p class="source-code">                System.out.println("onNext: " + item);</p><p class="source-code">                subscription.request(1);</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onError(Throwable throwable) {</p><p class="source-code">                System.out.println("onError: " + throwable.getMessage());</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onComplete() {</p><p class="source-code">                System.out.println("onComplete()");</p><p class="source-code">            }</p><p class="source-code">        });</p><p class="source-code">    }</p><p class="source-code">}</p><p>Running this code, you should get an output to the console, and the entire file should print:</p><p class="source-code">onNext: 6</p><p class="source-code">onNext: 2e</p><p class="source-code">onNext: 22</p><p class="source-code">onNext: 4</p><p class="source-code">onNext: 11</p><p class="source-code">onNext: 59</p><p class="source-code">onNext: 73</p><p class="source-code">...</p></li>
				<li>However, in the subscriber, we expect to get data we can easily transform into integers. If we apply simple integer parsing to the text, we'll end up in trouble:<p class="source-code">publisher.subscribe(new Flow.Subscriber&lt;&gt;() {</p><p class="source-code">            Flow.Subscription subscription;</p><p class="source-code">            @Override</p><p class="source-code">            public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">                this.subscription = subscription;</p><p class="source-code">                subscription.request(1);</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onNext(String item) {</p><p class="source-code">                System.out.println("onNext: " + Integer.valueOf(item));</p><p class="source-code">                subscription.request(1);</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onError(Throwable throwable) {</p><p class="source-code">                System.out.println("onError: " + throwable.getMessage());</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onComplete() {</p><p class="source-code">                System.out.println("onComplete()");</p><p class="source-code">            }</p><p class="source-code">});</p><p>This will stop, with a parse exception, when reaching the second item, <strong class="source-inline">2e</strong>, which, of course, is not an integer:</p><p class="source-code">onNext: 6</p><p class="source-code">onError: For input string: "2e"</p><p>To rectify the problem with the broken subscriber, you can, of course, catch the exception right there. But, in this exercise, we will involve a filter processor in the mix. <strong class="source-inline">Processor</strong> will subscribe to <strong class="source-inline">Publisher</strong>, and <strong class="source-inline">Subscriber</strong> will subscribe to <strong class="source-inline">Processor</strong>. In essence, <strong class="source-inline">Processor</strong> is both a Publisher and a Subscriber. To make this simple for us, allow <strong class="source-inline">NumberProcessor</strong> to extend <strong class="source-inline">SubmissionPublisher</strong>, just like <strong class="source-inline">NumberPublisher</strong> does. </p><div class="IMG---Figure" id="_idContainer120"><img alt="Figure 17.2: Communication between the Subscriber, the Processor, and the Publisher&#13;&#10;" src="image/C13927_17_02.jpg"/></div><p class="figure-caption">Figure 17.2: Communication between the Subscriber, the Processor, and the Publisher</p></li>
				<li>Create a class called <strong class="source-inline">NumberProcessor</strong>, allow it to extend <strong class="source-inline">SubmissionPublisher</strong>, and implement the <strong class="source-inline">Flow.Processor</strong> interface:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class NumberProcessor extends SubmissionPublisher&lt;String&gt; implements Flow.Processor&lt;String, String&gt; {</p><p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">NumberProcessor</strong> will subscribe to <strong class="source-inline">NumberPublisher</strong>, and, just like the subscriber, it needs to store a reference to the publisher so that it can control when to request new items. Store the reference received in <strong class="source-inline">onSubscribe()</strong> as a private field in the processor. Also, take this opportunity to request the first item from the publisher:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class NumberProcessor extends SubmissionPublisher&lt;String&gt; implements   Flow.Processor&lt;String, String&gt; {</p><p class="source-code">    private Flow.Subscription subscription;</p><p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">        this.subscription = subscription;</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Whenever you receive an item from the publisher, you need to also request the next item, just like the subscriber would:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class NumberProcessor extends SubmissionPublisher&lt;String&gt; implements Flow.Processor&lt;String, String&gt; {</p><p class="source-code">    private Flow.Subscription subscription;</p><p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">        this.subscription = subscription;</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>If the subscription to <strong class="source-inline">NumberPublisher</strong> is closed, we also need to inform the subscriber that there was a problem. Likewise, we need to inform the subscriber when the subscription ended. In the <strong class="source-inline">onError()</strong> callback, add a call to <strong class="source-inline">closeExceptionally()</strong>, and, in <strong class="source-inline">onComplete()</strong>, add a call to <strong class="source-inline">close()</strong>:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">public class NumberProcessor extends SubmissionPublisher&lt;String&gt; implements   Flow.Processor&lt;String, String&gt; {</p><p class="source-code">    private Flow.Subscription subscription;</p><p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">        this.subscription = subscription;</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">        closeExceptionally(throwable);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">        close();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The processor is almost done. The one thing that is missing is communicating the received items back to the subscriber. We will do this in the <strong class="source-inline">onNext()</strong> callback method. However, since we know that there may be invalid values, we want to filter those. We'll use a predicate for this, declaring a predicate to the <strong class="source-inline">NumberProcessor</strong> class:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class NumberProcessor extends SubmissionPublisher&lt;String&gt; implements   Flow.Processor&lt;String, String&gt; {</p><p class="source-code">    private Flow.Subscription subscription;</p><p class="source-code">    private Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {</p><p class="source-code">        @Override</p><p class="source-code">        public boolean test(String s) {</p><p class="source-code">            return false;</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">        this.subscription = subscription;</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">        closeExceptionally(throwable);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">        close();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The predicate is a simple functional interface that is used to verify the input using a <strong class="source-inline">test()</strong> method. The <strong class="source-inline">test()</strong> method should always return <strong class="source-inline">true</strong> if the value was acceptable, or <strong class="source-inline">false</strong> if it was faulty. In our predicate, we will attempt to parse the string supplied. If the parsing is successful, we will return true; otherwise, we will return <strong class="source-inline">false</strong>:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class NumberProcessor extends SubmissionPublisher&lt;String&gt; implements   Flow.Processor&lt;String, String&gt; {</p><p class="source-code">    private Flow.Subscription subscription;</p><p class="source-code">    private Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {</p><p class="source-code">        @Override</p><p class="source-code">        public boolean test(String s) {</p><p class="source-code">            try {</p><p class="source-code">                Integer.valueOf(s);</p><p class="source-code">                return true;</p><p class="source-code">            } catch (NumberFormatException e) {</p><p class="source-code">                return false;</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">        this.subscription = subscription;</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">        closeExceptionally(throwable);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">        close();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Back in the <strong class="source-inline">onNext()</strong> callback, we can now use our predicate to verify the value supplied before we submit it to the subscribers:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.concurrent.SubmissionPublisher;</p><p class="source-code">import java.util.function.Predicate;</p><p class="source-code">public class NumberProcessor extends SubmissionPublisher&lt;String&gt; implements Flow.Processor&lt;String, String&gt; {</p><p class="source-code">    private Flow.Subscription subscription;</p><p class="source-code">    private Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {</p><p class="source-code">        @Override</p><p class="source-code">        public boolean test(String s) {</p><p class="source-code">            try {</p><p class="source-code">                Integer.valueOf(s);</p><p class="source-code">                return true;</p><p class="source-code">            } catch (NumberFormatException e) {</p><p class="source-code">                return false;</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    @Override</p><p class="source-code">    public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">        this.subscription = subscription;</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onNext(String item) {</p><p class="source-code">        if (predicate.test(item)) {</p><p class="source-code">            submit(item);</p><p class="source-code">        }</p><p class="source-code">        this.subscription.request(1);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onError(Throwable throwable) {</p><p class="source-code">        closeExceptionally(throwable);</p><p class="source-code">    }</p><p class="source-code">    @Override</p><p class="source-code">    public void onComplete() {</p><p class="source-code">        close();</p><p class="source-code">    }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">You can read more about predicates and how to use them in <em class="italic">Chapter 16</em>, <em class="italic">Predicates and Other Functional Interfaces</em>.</p></li>
				<li>Now that your <strong class="source-inline">Processor</strong> is ready, inject it between <strong class="source-inline">NumberPublisher</strong> and <strong class="source-inline">Subscriber</strong>:<p class="source-code">package com.packt.java.chapter17;</p><p class="source-code">import java.io.IOException;</p><p class="source-code">import java.nio.file.Files;</p><p class="source-code">import java.nio.file.Paths;</p><p class="source-code">import java.util.Arrays;</p><p class="source-code">import java.util.concurrent.Flow;</p><p class="source-code">import java.util.function.Supplier;</p><p class="source-code">import java.util.stream.Stream;</p><p class="source-code">public class Exercise2 {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {</p><p class="source-code">            int index;</p><p class="source-code">            @Override</p><p class="source-code">            public String get() {</p><p class="source-code">                String[] data = getStrings();</p><p class="source-code">                if (index &lt; data.length - 1) {</p><p class="source-code">                    return data[index++];</p><p class="source-code">                } else {</p><p class="source-code">                    return null;</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        };</p><p class="source-code">        NumberPublisher publisher = new NumberPublisher(supplier);</p><p class="source-code">        NumberProcessor processor = new NumberProcessor();</p><p class="source-code">        publisher.subscribe(processor);</p><p class="source-code">        processor.subscribe(new Flow.Subscriber&lt;&gt;() {</p><p class="source-code">            Flow.Subscription subscription;</p><p class="source-code">            @Override</p><p class="source-code">            public void onSubscribe(Flow.Subscription subscription) {</p><p class="source-code">                this.subscription = subscription;</p><p class="source-code">                subscription.request(1);</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onNext(String item) {</p><p class="source-code">                System.out.println("onNext: " + Integer.valueOf(item));</p><p class="source-code">                subscription.request(1);</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onError(Throwable throwable) {</p><p class="source-code">                System.out.println("onError: " + throwable.getMessage());</p><p class="source-code">            }</p><p class="source-code">            @Override</p><p class="source-code">            public void onComplete() {</p><p class="source-code">                System.out.println("onComplete()");</p><p class="source-code">            }</p><p class="source-code">        });</p><p class="source-code">    }</p><p class="source-code">    private static String[] getStrings() {</p><p class="source-code">        String filePath = "res/numbers.txt";</p><p class="source-code">        try (Stream&lt;String&gt; words = Files.lines(Paths.get(filePath))) {</p><p class="source-code">            return words.flatMap((line) -&gt; Arrays.stream(line.split("[\\s\\n]+")))</p><p class="source-code">                    .filter((word) -&gt; word.length() &gt; 0)</p><p class="source-code">                    .toArray(String[]::new);</p><p class="source-code">        } catch (IOException e) {</p><p class="source-code">            e.printStackTrace();</p><p class="source-code">        }</p><p class="source-code">        return null;</p><p class="source-code">    }</p><p class="source-code">}</p><p>After running this example, you should see that the processor filters the faulty number values from the file before they reach the subscriber:</p><p class="source-code">onNext: 6</p><p class="source-code">onNext: 22</p><p class="source-code">onNext: 4</p><p class="source-code">onNext: 11</p><p class="source-code">onNext: 59</p><p class="source-code">onNext: 73</p><p class="source-code">onNext: 41</p><p class="source-code">onNext: 60</p><p class="source-code">onNext: 8</p><p class="source-code">...</p></li>
			</ol>
			<p>This example shows how to take content from a publisher and pass it through a processor to ensure that the values are valid.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor342"/>Activity 1: Let NumberProcessor Format Values as Integers</h2>
			<p>Improve <strong class="source-inline">NumberProcessor</strong> further. Let it not only verify that the values can be parsed as integers, but also publish them to the subscriber as integers. The subscriber should only accept integer values, and no longer need to parse the received values.</p>
			<ol>
				<li value="1">Change the processors published item type to Integer. Make the necessary changes in the implementation to match the new type.</li>
				<li>Change the subscriber for the processor, it should accept only Integer values in the <strong class="source-inline">onNext</strong> method.<p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 568.</p></li>
			</ol>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor343"/>Summary</h1>
			<p>In this chapter, you've learned the basics of Reactive Streams components, how they communicate, and their respective roles in a reactive application.</p>
			<p>In most cases, you should avoid using the Flow API to build reactive applications as there are much more advanced and user-friendly reactive libraries available out there. The Flow API provides only the basic building blocks for reactive applications, while implementations such as Akka or RxJava will give you a richer experience, providing essential functionality such as throttling, filtering, and debouncing, to name a few. If you're interested in delving further into reactive programming, there are entire books devoted to the subject.</p>
			<p>As mentioned before, Flow provides the basis for building your own Reactive Streams library, however complex that may be. Should you wish to implement a Reactive Streams library of your own, you should start by reviewing the Reactive Streams Technology Compatibility Kit. This test-based kit will help you to ensure that your implementation follows the Reactive Streams rules.</p>
			<p>After the next chapter, which focuses on unit testing, you should be all set to start looking at the compatibility kit and build your own Reactive Streams library.</p>
		</div>
	</body></html>