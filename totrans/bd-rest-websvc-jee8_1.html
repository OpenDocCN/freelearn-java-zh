<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting Started with Java EE 8</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this first chapter, you will learn why Java EE is a great platform for building lightweight state-of-the-art microservices. You will learn the latest advances in the different APIs of Java EE 8, with a focus on the more microservice-relevant APIs. You will then learn how to develop, build, run, and package your first microservice powered by Java EE 8.</p>
<p class="calibre6">This chapter includes the following sections:</p>
<ul class="calibre14">
<li class="calibre15"><span class="calibre4">Why is Java EE a good platform for microservices?</span></li>
<li class="calibre15"><span class="calibre4">What's new in Java EE 8?</span></li>
<li class="calibre15"><span class="calibre4">Getting started with Java EE 8 microservices</span></li>
<li class="calibre15"><span class="calibre4">Containerizing Java EE 8 microservices using Docker </span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">You need basic programming skills and some Java knowledge. Along with that, you need a computer with a modern operating system, such as Windows 10, macOS, or Linux. We'll be using Maven 3.5 as our build tool and Payara Server as our application server. For the Java 8 application server, you need Docker for Windows, Mac or Linux, an IDE with Java EE 8 support, such as IntelliJ, and a REST client, such as Postman or SoapUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Why is Java EE a good platform for microservices?</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">Well, this is the question, why? And the short answer is simple: because Java EE 8 is the most lightweight enterprise framework currently out there. Let me give you a few more details. First up, Java EE is an industry standard. It's been developed by a vendor-neutral committee and there is widespread knowledge out there because Java EE has been available for a couple of years already. Java EE consists of several specifications, and these specifications have very tight integration. Also, Java EE applies a convention of a configuration programming model, which means that you don't need cumbersome XML descriptors anymore; just throw in a couple of annotations and you're done. For most of the services you're going to develop, you will not need any external dependencies, and this leads to thin deployment artifacts. And finally, you have the availability of modern application servers that suit the cloud era.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java EE version history</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">If you have a look at the Java EE version history, which you can find at <a href="https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition</a>, you'll see we've come a long way since J2EE 1.2 was first released on December 12, 1999. If you look on the far-right side in the following diagram, you can see Java EE 8 was released on September 21, 2017, which means we have 18 years of experience and 18 years of community-built knowledge. Therefore it's definitely a very mature and stable API that's been continually improved:</p>
<p class="cdpaligncenter"><img src="Images/214aa66c-f49b-4dd4-bfdd-9c8c99f7dd83.png" width="1200" height="360" class="calibre23"/></p>
<div class="mce-root">Java EE version history</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Overview of Java EE 8</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In the following diagram, you can see an overview of Java EE 8 in its current state, you have loads of APIs here that you can program against, and it should meet most of the needs of any enterprise's web-service development. You've got JPA for persistence, JMS for messaging, good JAX-WS for web services in structure, JAX-RS for REST services, and many more APIs you can use for your modern enterprise's application development:</p>
<p class="cdpaligncenter"><img src="Images/c37711d0-1ac4-47bd-bcd9-97c41e463bd2.png" width="1274" height="489" class="calibre24"/></p>
<div class="mce-root">Overview of Java EE 8</div>
<p class="calibre6">And all you need is the following code, which is the only dependency required; this is the Maven dependency for the Java EE 8 API and leads to no external dependencies. All you need is Java EE 8 and Java 8; this results in very thin artifacts which speeds up your daily development and your deployment cycles, and because you have those thin WAR files, this is very Docker-friendly:</p>
<pre class="calibre22">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>
<p class="calibre6">Now there are people out there who say that Java EE 8, especially the application service, should not go in a Docker container, but those heavy times are over; modern application servers are really lightweight, have a look at Payara server or WildFly Swarm, or maybe Open Liberty or Apache TomEE, along with the various other application servers. These servers are very lightweight and are definitely suitable to be run in a Docker container. I hope by now you're convinced that Java EE 8 is indeed the most lightweight enterprise framework currently available. In the next section, we're going to have a look what's new in Java EE 8.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">What's new in Java EE 8?</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at the different APIs of Java EE 8 and the latest advances, with a focus on the more microservice-relevant APIs. We're going to look at JSR 370, which is JAX-RS 2.1; JSR 367, which is the JSON Binding; and also JSR 374, which is the Java API for JSON Processing.</p>
<p class="calibre6">We saw the different APIs in Java EE 8 in the <em class="calibre18">Overview of Java EE 8</em> section. The ones in blue are the ones that have been added or revamped. We see that CDI is been bumped to version 2.0, mainly focusing on asynchronous events, and the Servlet API has been bumped to version 4.0, adding HTTP2 support. JSF 2.3, which is an API to build server-side UIs, the old JSF bean-managed model, has been removed and it's fully integrated with CDI. On the right-hand side of the figure in the previous section, you see the Bean Validation API, which has been bumped to version 2.0. It's tightly integrated with CDI and has been revamped to fully support Java 8 features such as streams and lambdas. There's also a totally new Security API for cloud security and past security in adding standardized authorization, authentication mechanisms, and APIs. Here, we want to focus on JAX-RS 2.1, JSON-P 1.1, and JSON-B 1.0.</p>
<p class="calibre6">Let's get started with JAX-RS 2.1. First, it improved the integration with CDI, so all your resource beans are properly CDI-managed. It's also been tightly integrated with JSON-B for JSON marshalling and JSON-P for JSON Processing. Also, server-sent events have been added to implement push notifications. They support non-blocking I/O and all the providers, such as filters and interceptors for JAX-RS. There's also been an improved JAX-RS, which is a synchronous client API supporting a completion stage. If you have a look at the Java API for JSON Processing, it's been updated to version 1.1 to support JSON Pointer and JSON Patch. It allows you to edit and transform operations for your JSON object model, and the API has been updated to work with Java SE 8 features, such as lambdas and streams.</p>
<p class="calibre6">The new kid on the block is JSON-B, the JSON Binding 1.0 API. It's the new standard way to convert JSON into Java objects and vice-versa. For a long time, we've had JSON-B to do the same for XML, and JSON-B is the API to do that for JSON. JSON-B leverages JSON-P and provides a conversion layer above it. It provides a default mapping algorithm for converting existing Java classes to JSON. The mapping is highly customizable through the use of Java annotations, and you can plug in different JSON-B runtimes to convert Java objects to and from JSON, such as Jackson. Those are the most relevant Java EE 8 APIs with respect to web-service development. In the next section, we're getting started with Java EE 8 microservices development.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started with Java EE 8 microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at the following things:</p>
<ul class="calibre14">
<li class="calibre15">How to develop, build, and run your first Java-EE-8-powered microservice</li>
<li class="calibre15">Required Java EE 8 dependencies for basic web-service development</li>
<li class="calibre15">Basic components of any JAX-RS-based web service</li>
<li class="calibre15">Deployment of a thin WAR artifact using Payara Server 5</li>
</ul>
<p class="calibre6">Let's get started and dive into the code. I've prepared my IDE and a raw skeleton Maven project. What you see here is a very basic POM file:</p>
<p class="cdpaligncenter"><img src="Images/35f6a339-c833-4dd2-95f1-0f576e24fa48.png" width="1252" height="601" class="calibre25"/></p>
<p class="calibre6">There's one thing missing though; first, we need to define the required dependency for the Java EE 8 API. Let's do that:</p>
<pre class="calibre22">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>
<p class="calibre6">We specify <kbd class="calibre17">version</kbd> as <kbd class="calibre17">8.0</kbd>. We should also define the proper <kbd class="calibre17">scope</kbd> for this, which is <kbd class="calibre17">provided</kbd> in this case because the Java EE 8 API will later be provided by our application server and we are done with our dependency. Next, we should add a <kbd class="calibre17">beans.xml</kbd> descriptor to the <kbd class="calibre17">WEB-INF</kbd> directory of our web application:</p>
<pre class="calibre22">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="calibre2"/>&lt;beans <br class="calibre2"/>       <br class="calibre2"/>       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee<br class="calibre2"/>                      http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd"<br class="calibre2"/>       bean-discovery-mode="all"&gt;<br class="calibre2"/>&lt;/beans&gt;</pre>
<p class="calibre6">We do this and we're done, what's next? Well, next we should bootstrap our JAX-RS application. Now let's create a class called <kbd class="calibre17">JAXRSConfiguration</kbd>. The name really doesn't matter. What's important is that this class extends from the <kbd class="calibre17">Application</kbd> base class. Bear in mind the <kbd class="calibre17">javax.ws.rs.core</kbd> packa<span class="calibre10">ge while selecting the</span> <kbd class="calibre17">Application</kbd>. It's also important that you specify the <kbd class="calibre17">@ApplicationPath</kbd> annotation. This will be the base path our REST API will be accessible under, thus we call that <kbd class="calibre17">"api"</kbd>:</p>
<pre class="calibre22">package com.packtpub.javaee8;<br class="calibre2"/><br class="calibre2"/>import javax.ws.rs.ApplicationPath;<br class="calibre2"/>import javax.ws.rs.core.Application;<br class="calibre2"/><br class="calibre2"/>/**<br class="calibre2"/> * Configures a JAX-RS endpoint.<br class="calibre2"/> */<br class="calibre2"/>@ApplicationPath("api")<br class="calibre2"/>public class JAXRSConfiguration extends Application {<br class="calibre2"/>}</pre>
<p class="calibre6">Once we've bootstrapped JAX-RS, what's missing is a proper REST resource. Let's create a class called <kbd class="calibre17">HelloWorldResouce</kbd>. We used the <kbd class="calibre17">@Path</kbd> annotation, which will be the path this resource will be accessible under. We'll call that <kbd class="calibre17">"hello"</kbd>. Next up, we create a method that will produce the proper response once called, we call that <kbd class="calibre17">helloWorld</kbd>. We use the proper <kbd class="calibre17">Response</kbd> here. We annotate this using the <kbd class="calibre17">@GET</kbd> annotation because we will be issuing <kbd class="calibre17">GET</kbd> requests later on, and we'll say that it produces <kbd class="calibre17">MediaType.APPLICATION_JSON</kbd>. Then we return <kbd class="calibre17">Response.ok</kbd>, where <kbd class="calibre17">ok</kbd> is HTTP status 200 of a response when we call the <kbd class="calibre17">build</kbd>. So, what should be used as the response? We'll be using <kbd class="calibre17">Map&lt;String, String&gt;</kbd> as our response and will return <kbd class="calibre17">singletonMap</kbd> with the <kbd class="calibre17">message</kbd> key and the <kbd class="calibre17">Hello World</kbd> value:</p>
<pre class="calibre22">package com.packtpub.javaee8;<br class="calibre2"/><br class="calibre2"/>import javax.ws.rs.GET;<br class="calibre2"/>import javax.ws.rs.Path;<br class="calibre2"/>import javax.ws.rs.Produces;<br class="calibre2"/>import javax.ws.rs.core.MediaType;<br class="calibre2"/>import javax.ws.rs.core.Response;<br class="calibre2"/>import java.util.Map;<br class="calibre2"/><br class="calibre2"/>import static java.util.Collections.singletonMap;<br class="calibre2"/><br class="calibre2"/>/**<br class="calibre2"/> * The REST resource implementation class.<br class="calibre2"/> */<br class="calibre2"/>@Path("hello")<br class="calibre2"/>public class HelloWorldResource {<br class="calibre2"/>    @GET<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response helloWorld() {<br class="calibre2"/>        Map&lt;String, String&gt; response = singletonMap("message", <br class="calibre2"/>          "Building Web Services with Java EE 8.");<br class="calibre2"/>        return Response.ok(response).build();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre6">We should already have a very simple working microservice. Now let's deploy this onto our Payara Server 5 and run it. We're going to deploy the WAR file, it's been built; you can see that it's already been deployed and the deployment took 5.1 milliseconds.</p>
<p class="calibre6">Let's check our browser. You should see the <span class="calibre10">"Hello World."</span> message, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/c3f47211-7ef1-4113-86a0-1d927c6c4475.png" width="364" height="144" class="calibre26"/></p>
<p class="calibre6">If you don't trust me, let's just modify the value here to <kbd class="calibre17">"Building Web Services with Java EE 8."</kbd> value. We deploy this once more and update our artifact. The new version has been deployed. Let's go back to our browser to check that we have the proper response message, <span class="calibre10">as shown in the following screenshot</span>:</p>
<p class="cdpaligncenter"><img src="Images/9868e14b-2e6d-413e-80ed-ace1bb19f5c8.png" width="385" height="135" class="calibre27"/></p>
<p class="calibre6">That's all for this section; in the next section, I'm going to show you how to containerize your Java EE 8 microservice.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Containerizing Java EE 8 microservices</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this section, we're going to take a look at how to containerize and run our Java EE 8 microservice using Docker. We'll learn how to write a basic Docker file, and we'll also see how to build and run the Docker image using Payara Server full and Payara Server micro edition. Let's open our IDE again to the microservice project from the previous section; all that's missing here is <kbd class="calibre17">Dockerfile</kbd>, therefore let's create one.</p>
<p class="calibre6">Now the question is: what base image should we use? We have two basic options when using Payara: you can either use the server-full image or the Payara micro edition. Let's use the full version of Payara first. <kbd class="calibre17">Dockerfile</kbd> will be as follows:</p>
<pre class="calibre22">FROM payara/server-full:5-SNAPSHOT<br class="calibre2"/><br class="calibre2"/>COPY target/hello-javaee8.war $DEPLOY_DIR</pre>
<p class="calibre6">In the preceding <kbd class="calibre17">Dockerfile</kbd>, we mentioned that we're using <kbd class="calibre17">payara/server-full</kbd>. We need to use the correct version of it, in our case this is version <kbd class="calibre17">5-SNAPSHOT</kbd>, and then copy the <kbd class="calibre17">hello-javaee8.war</kbd> file of our microservice into the correct location of the produced image. We need to issue a <kbd class="calibre17">COPY</kbd> command from <kbd class="calibre17">target/hello-javaee8.war</kbd> and then copy this into the deployment directory, that should be it, let's see whether is worked. We open a console, making sure that we're in the right directory. We check that everything is packaged nicely, and to do this we call <kbd class="calibre17">mvn package</kbd> just to make sure the WAR file is in the correct state. If it is, you'll see my things running while compiling, an absence of tests, and the WAR file is up to date:</p>
<p class="cdpaligncenter"><img src="Images/4ba70a79-9a24-4690-9dc8-634f29b29dc6.png" width="1155" height="624" class="calibre28"/></p>
<p class="calibre6">We build <span class="calibre10">Docker using <kbd class="calibre17">-t</kbd></span>, which specifies the tag we want to use, we do that by calling <kbd class="calibre17">hello-javaee8</kbd> and we give it a version number, <kbd class="calibre17">1.0</kbd>:</p>
<pre class="calibre22"><strong class="calibre3">&gt;docker build -t hello-javaee8:1.0 .</strong></pre>
<p class="calibre6">Using the following command, let's see whether our server starts up:</p>
<pre class="calibre22"><strong class="calibre3">&gt;docker run -it -p 8080:8080 hello-javaee8:1.0</strong></pre>
<p class="calibre6">We mapped port <kbd class="calibre17">8080</kbd> from the container onto our Docker host. You'll see that the Payara GlassFish Server is starting up in the console—it should only take a couple of seconds—and in a second we should see that our application is deployed. To check that we can reach our web service hit the IP address as shown in the following screenshot. This is the IP address of my Docker host port <kbd class="calibre17">8080</kbd> and we can access our service, which was successful:</p>
<p class="cdpaligncenter"><img src="Images/be19bd06-103e-4496-9257-9fc59c736297.png" width="396" height="102" class="calibre29"/></p>
<p class="calibre6">Now let's stop that and delete the contents of this <kbd class="calibre17">Dockerfile</kbd>. I want to show you how to use the Payara micro edition instead. First, we need to change <kbd class="calibre17">FROM</kbd>. To do this we use a different base tag for this image (<kbd class="calibre17">payara/micro:5-SNAPSHOT</kbd>), and then copy the <kbd class="calibre17">hello-javaee8.war</kbd> file into the proper location for this base image. Next we copy our WAR file in the <kbd class="calibre17">target</kbd> directory and we call it to our <kbd class="calibre17">/opt/payara/deployments</kbd>. This is the default <kbd class="calibre17">deployments</kbd> directory for the micro edition base container. The <kbd class="calibre17">Dockerfile</kbd> should look as follows:</p>
<pre class="calibre22">FROM payara/micro:5-SNAPSHOT<br class="calibre2"/><br class="calibre2"/>COPY target/hello-javaee8.war /opt/payara/deployments</pre>
<p class="calibre6">Switch back to the console and issue the Docker build command again:</p>
<pre class="calibre22"><strong class="calibre3">&gt;docker build -t hello-javaee8:1.0 .</strong></pre>
<p class="calibre6">Fire up the container again:</p>
<pre class="calibre22"><strong class="calibre3">&gt;docker run -it -p 8080:8080 hello-javaee8:1.0</strong></pre>
<p class="calibre6"/>
<p class="calibre6"/>
<p class="calibre6">You can see that the output in the console changes and we're using the Payara micro runtime this time. This takes a couple of seconds to spin up our web service, and in a few seconds it should be done. We can see that our <kbd class="calibre17">REST Endpoints</kbd> are available. Let's check again. We go to our management console and we can see that we have a running container. Try calling the web service from the browser, as shown in the following screenshot:</p>
<p class="cdpaligncenter"><img src="Images/e9b000fe-aafe-4432-94b8-df51a594af84.png" width="387" height="135" class="calibre30"/></p>
<p class="calibre6">We can see that everything's working fine and we have a running Dockerized version of our web service.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="calibre6">In this chapter, we talked about Java EE and the fact that it's a great platform for building modern and lightweight web services. We had a look at the different APIs of Java EE 8 and the latest advances, with a focus on the more microservice-relevant APIs, such as JAX-RS, JSON-B, and JSON-P. We then developed, built, and ran our Java-EE-8-powered microservice and deployed it locally to the Payara Server. In the final section, we containerized and ran our Java EE 8 microservice using Docker.</p>
<p class="calibre6">In the next chapter, we'll do a deep dive into building synchronous web services and clients using the relevant JAX-RS APIs.</p>


            </article>

            
        </section>
    </div>



  </body></html>