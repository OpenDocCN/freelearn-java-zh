- en: Chapter 6. Building IcedTea with Other VM Implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring cross-compilation between ARM and x86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building IcedTea for ARM with integrated CACAO VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting JamVM to use OpenJDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Zero assembler with the Shark compiler to use OpenJDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building MIPS and other architectures using OpenEmbedded recipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though various x86-compatible platforms are widespread and common to use, there
    are other architectures to think about. Java language itself is designed to be
    as cross-platform, as possible. In an x86-compatible world, it means that Java
    will work equally well and predictable for the vast majority of operating systems.
    Where more architectures are concerned, it should work on a great number of them.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM architecture is the second architecture among the most popular ones.
    It gives a great balance between power saving and performance, and is used mostly
    in embedded and portable devices. There are several operating systems, supporting
    ARM, such as various Linux distributions, Android, Symbian, MeeGo, and many Windows
    releases.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will speak about building IcedTea on ARM, using virtual
    Java machines, which are not official and aren't parts of the OpenJDK community.
    They are built for different purposes—academic, performance, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, these days, the only operating system that works with ARM and
    OpenJDK both, is Linux. Nuances of building IcedTea on Linux differ from distribution
    to distribution, though the main idea and philosophy is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will try to use as many different distribution-based examples
    and device nuances, as possible, though the most thoroughly tested ones will be
    the following pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi and Raspbian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nexus 7 and Ubuntu touch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will also cover a topic of cross-compilation with an x86-based
    system, because one may probably need a faster compilation that ARM processors
    are capable of, especially in the case of small computers of the Raspberry Pi
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have three VMs in this chapter: ZeroVM, CACAO VM, and Jam VM. However,
    only the Zero assembler is a member of an OpenJDK project. The Zero assembler
    is an effort to get rid of platform-specific assembler languages and to build
    an interpreter-only virtual machine. It will make porting any Java executable
    to any operating system a remarkably easy task, but with a significant performance
    impact because of the absence of JIT. However, there is Shark, a JIT-compiler
    for Zero, which uses LLVM to compile the Zero-assembler to the platform-specific
    code. It''s obvious, though, that Shark works only for architectures that are
    supported by LLVM itself.'
  prefs: []
  type: TYPE_NORMAL
- en: JamVM is also famous because of its really small size, which is, depending on
    architectures, between 200 and 250 kilobytes. In this space, it implements the
    full JVM specification, published by Oracle, known as **blue book**.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring cross-compilation between ARM and x86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though many of the recent ARM devices have great performance and the same core
    numbers, as their desktop fellows, there are always those whose performance is
    not sufficient enough to do complicated work in a reasonable amount of time. Don't
    want to be bored by endless hours of compilation? Use OpenEmbedded builds. **OpenEmbedded**
    is a build framework to create Linux distributions and can cross-compile for a
    large variety of architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need a real or emulated ARM device with Linux installed on it. The following
    recipes are primarily for the deb-based distributions, but the general idea remains
    the same for any ARM-based device that runs Linux kernel with GNU-based tools.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will need another device with Linux, or Windows with Cygwin installed,
    to do the main compilation job.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe also assumes that you will use the deb-based distributions. If you
    are using the ebuild-based distributions, use their own cross-compile tools. In
    the rpm-based distributions, the process is quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to make use of the OpenEmbedded project. OpenEmbedded is a project
    whose goal is to build a platform-specific environment and build various known
    packages. Take a look at the following procedure to build various packages using
    the OpenEmbedded project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use it, we will install some packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we need to get an OpenEmbedded environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to create three more projects in the `oe-core` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moving ahead, let''s clone some layers into our root directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, initialize an OpenEmbedded environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have a fully operational OpenEmbedded environment. All we have to do
    is to configure our build. There are two ways to do it: by editing the config
    files manually or through the Hob GUI.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OpenEmbedded build manually
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to edit two configuration files: the first configuration file
    is for Java layer and the second is generic and easy to include this layer in
    the build, as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, edit the `conf/local.conf` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will set JamVM as a preferred virtual machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set other versions as you wish (Version 1.8.11, for example):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need an ARM build, so we will select a qemu-arm machine as the target
    machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need to mention how many compilation processes can be in progress
    together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, we can reconfigure a number of threads for one compiling package. For
    a Quad-core computer, it will be `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we will edit the `conf/bblayers.conf` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following parameter is a version of the file format. It means that there
    was 3 incompatible formats before this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then set layers to command OpenEmbedded system on what exactly to build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the Hob utility to configure the OpenEmbedded build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hob is a graphical UI for BitBake. Please take a look at the following procedures
    to use the Hob utility to configure the OpenEmbedded build:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a `hob` executable from a build directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This can be done only after an environment initialization. You will have a command
    not found message otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A starting screen will appear as shown:![Using the Hob utility to configure
    the OpenEmbedded build](img/8405_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we will select a virtual machine. For ARM processors, the most convenient
    is the qemu-arm machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we will need to select two additional layers. One is the **meta-oe**
    layer and the second is **meta-java**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: While the `meta-java` folder is in the root folder of OpenEmbedded, the path
    to `meta-oe` is `meta-openembedded/meta-oe/`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When a machine is chosen, the tool will parse all recipes and compute all dependencies
    needed. Then, the window should look like this:![Using the Hob utility to configure
    the OpenEmbedded build](img/8405_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then select a recipe. Here is one Java-related recipe: **java-test-image**.
    Although, it would be better not to choose it and choose **core-image-basic**
    instead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can try to assemble your image from scratch. You can select the package
    you want and dependencies will be automatically calculated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can choose in an advanced configuration section, exactly what the output
    will be. You can even get it in a `.deb` form, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to edit recipes and add **openjdk-7-jre** to them as shown:![Using
    the Hob utility to configure the OpenEmbedded build](img/8405_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, you can add some dependencies that are necessary for the build.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When all is ready, press the **Build packages** button and the following screen
    will appear:![Using the Hob utility to configure the OpenEmbedded build](img/8405_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If something goes wrong, the **Issues** tab will not be empty.
  prefs: []
  type: TYPE_NORMAL
- en: After the build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to copy the build output from the **tmp-eglibc** folder to your
    ARM device.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenEmbedded is a stack of cross-compile recipes for various tools that needs
    a lot of time for compilation. OpenEmbedded will create a root filesystem from
    scratch. Then it will build the packages that you want to be built. OpenEmbedded
    provides a bunch of abstraction layers, from the developer to the core layer.
    These layers include recipes and tools to build an environment and a target project.
  prefs: []
  type: TYPE_NORMAL
- en: So, after a performed configuration, the tool will build an environment and
    then some projects in it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building OpenEmbedded recipes is not a trivial task. It often needs some problem
    solving skills. It's not unusual when your build, that literally takes hours to
    pass, is interrupted with some errors even when you are trying to build a stock
    Java-test image.
  prefs: []
  type: TYPE_NORMAL
- en: Though the basics of recipe-building and correcting will be given in the following
    recipes, we can provide a roadmap to deal with some problems right here, in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some cases, which were found and overcome by authors, will be found in [Chapter
    8](ch08.html "Chapter 8. Hacking OpenJDK"), *Hacking OpenJDK*.
  prefs: []
  type: TYPE_NORMAL
- en: Configure problems – when a header file is not found
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Though the building process is similar to creating a well-maintained Linux
    repository from scratch, it''s not so simple. It''s a task of building the whole
    thing from source, and some header movement in some minor package maybe a major
    problem that is fatal to your build, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: So, it's a dependency problem. At first, try to find out, do you need the package,
    which header is not found, at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, find out whether you can disable it through the standard `./configure`
    properties (those which are specified before make).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you can, you're lucky. Just find a recipe for your package and edit the `.bb`
    or `.inc` file. For OpenJDK, it's `openjdk-7-common.inc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add (or remove) the desired `./configure` property to (or from) `EXTRA_OECONF`.
    Don't forget the screening `\`. If you need that dependency or cannot disable
    it, it's another matter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, consider switching to an older/newer version of the `.bb` files. It may
    solve some problems, but can easily add to them as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is impossible or will not help, try to find a patch to the source and
    apply it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch problems – where your package is not accessible through any mirror available
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, try to check whether all the mirrors that are used are permanently offline.
    If not, just wait for a bit while one of those becomes accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Compile problems – where a compile error occurs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is always a solution to this kind of problem, which is searchable through
    the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: It may be a wrong dependency version or even a major compilation issue that
    slipped away from the maintainer's eye. The solution is to patch your build using
    some known patches or even your own patch, or change the source parameter of the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing problems – where your recipes cannot be parsed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not a common problem but it was encountered, for example, in the `openjdk-7`
    branch of the `meta-java` repository. Often it doesn't mean that something is
    completely broken. Check the indicated lines of recipe files for missing \, partial
    comments, and other minor formatting issues. If the problem still appears, consider
    changing your current branch.
  prefs: []
  type: TYPE_NORMAL
- en: Building IcedTea for ARM with integrated CACAO VM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe promises to be quite simple, because the integration of CACAO VM
    is already a part of IcedTea itself. It will not require any patching or other
    complicated things.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may need a real or emulated ARM device, which has Linux and any Java environment
    installed. We need Java to perform a `javac` compilation, which is a necessary
    part of the IcedTea building process.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will download IcedTea, unpack it, and build it with the specified parameters,
    that's all.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s get the latest IcedTea source from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will download an archive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Perform a checksum check if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s unpack an archive and copy it into the `icedtea` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, you might have to install some dependency packages needed to make your
    IcedTea.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The given packages are those that were missing on the authors'' machine during
    the first build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will make a link for build configuration to find the Java home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a distribution-recommended way to change the default Java home directory,
    please follow it instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then we will enable the CACAO VM in our configuration. Also, we will configure
    the newly built IcedTea to use the CACAO VM not only as the build configuration,
    but as a default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When running `configure`, you probably will encounter errors with messages indicating
    that some program or library is missing. It's okay, you just need to install them
    using your package manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After doing that, we will build IcedTea using just one simple command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is a long process, even using cross-compilation, so it's best to have a cup
    of tea or something.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IcedTea is now supporting CACAO VM as a build configuration just out of the
    box. We will only need to enable this option to configure and add missing dependencies.
    Normally, IcedTea uses a ZeroVM on ARM, but without Shark JIT compilation. Under
    the hood, however, it literally applies hundreds of patches and uses an amount
    of memory that is not acceptable on embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since you may experience some difficulties with building IcedTea on some devices,
    you may need to use cross-compiling the way we used it before.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may need just to set a variable to the local configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Porting JamVM to use OpenJDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another Zero HotSpot alternative for non-JIT supported platforms is JamVM—an
    extremely small VM, which is the smallest among those supporting the blue book
    specification (one that was published in the book form) for Java VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may need a real or emulated ARM device that has Linux and any Java environment
    installed. We need Java to perform a `javac` compilation, which is a necessary
    part of IcedTea building process.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though JamVM patches may be applied manually, we will use the more simple way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s clone the source from the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we configure it to use OpenJDK as Java runtime libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we will actually build it from source using the `make` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to copy `libjvm` to `lib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then let''s copy the OpenJDK contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let''s run our compiled Java:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see the output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also, the Jam M support is a part of an OpenEmbedded Java layer. In order to
    add it, you will remove the ZeroVM support and add a JamVM support. It's a simple
    task, though you may experience errors during configuration and building.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you can run whatever Java program you choose with JamVM, even if your
    IcedTea build is not configured to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Zero-assembler with the Shark compiler to use OpenJDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zero-assembler HotSpot port is the default Java VM for all newly-built OpenJDK
    instances on ARM prior to Java 8\. It is the default Java VM for quite a few JIT-unsupported
    platforms. However, there is an effort to bring JIT power to it, named Shark.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may need a real or emulated ARM device, which has Linux and any Java environment
    installed. We need Java to perform a `javac` compilation, which is a necessary
    part of the IcedTea building process.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's download an IcedTea source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will download an archive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, you can check a checksum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s unpack it and copy it into the `icedtea` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, you may need to install some dependency packages needed to make your IcedTea.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following packages are those that were missing on my machine during my first
    build.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will make a link for the build configuration to find the Java home
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a distribution-recommended way to change the default Java home directory,
    please follow it instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then we will enable Zero-Shark in our configuration. Also, we will configure
    the newly built IcedTea to use Shark VM not only as the build, but as the default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When running `configure`, you probably will encounter errors with messages indicating
    that some program or library is missing. It's okay, you just need to install them
    using your package manager.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After doing that, we will build IcedTea using just one simple command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, IcedTea uses a ZeroVM on ARM but without Shark JIT-compilation. All
    we need to do is to command it to use ZeroVM and Shark JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Shark is a project that uses a famous list of LLVM-supported platforms to enable
    JIT support on all of them, which is quite impressive. It may not be as fast as
    native JIT but something is better than nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On ARM, there is a workable OpenJDK that uses JIT-compilation in HotSpot out
    of the box. However, it's only in the early-access mode and since it's JDK 8,
    this support will not be ported any prior to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The LLVM project''s goal is to achieve the cross-platform compilation across
    as many languages and platforms as possible. It uses frontend and backend transforms
    to provide a flexibility of their tools as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/8405OT_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because of this structure, LLVM can be used to compile the Java class methods'
    code to an intermediate language and then to a native code. It leaves the simplest
    features as reflection and so on to the VM.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also, you could always cross-compile IcedTea with Zero-Shark support. In order
    to do so, refer to the last recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building for MIPS and other architectures using OpenEmbedded recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When ARM-based devices are widespread and popular, there are always other architectures.
    The great power of Java is its cross-platformness, so let's try to have builds
    for some other architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need an Internet connection and Linux or Windows with Cygwin installed
    on your computer. Also, from the author's experience, you will need at least 4GB
    RAM.
  prefs: []
  type: TYPE_NORMAL
- en: For a comfortable build, it's recommended to have a powerful hardware and a
    fast HDD.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you may experience some lags or even OOM-kills during build, so make sure
    that all your data is saved.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you will need an OpenEmbedded project configured, as described in the
    first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will see how to add architectures and software to OpenEmbedded:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser, and go to [http://layers.openembedded.org/layerindex/branch/master/layers/](http://layers.openembedded.org/layerindex/branch/master/layers/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will find a list of architectures supported and a list of software that
    you can install.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do a Git clone of the repositories containing the code that you need (such as
    `meta-asus` or `meta-htc`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then prepare your build environment and open the Hob GUI as shown:![How to do
    it...](img/8405_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the machine from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you will probably need to set some architecture-specific `./configure`
    options. In order to do that, you will need to change a `bitbake` file, adding
    or correcting the `EXTRA_OECONF` variable. Don't forget to add trailing \s.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main goal of this project is to create the repository and distribution from
    scratch, with precompiled images and dependencies. It consists of metadata, called
    the `.bb` files, and many dependencies between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this project is not running very smoothly, and you may need to make some
    changes in order to make your way through. A `.bb` file is a file of the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is a plain recipe template and you can add whatever dependency you want
    through it. Also, you can add patches into the recipe directory or even add sources
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You always can build OpenJDK on other architectures using a standard HotSpot
    Zero port. It is fully interpretable and it can make your programs run very slowly,
    but it''s better than nothing. Just follow the standard procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This approach has its downsides, because most of the architectures aside from
    Intel and ARM are embedded, so you will not be able to make something fast, or
    even make it at all. For example, on Raspberry Pi with a newly-built Raspbian
    and 512 Mb RAM, building IcedTea will randomly crash because of lack of memory,
    even with large swapfiles.
  prefs: []
  type: TYPE_NORMAL
