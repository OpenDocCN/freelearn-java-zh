<html><head></head><body>
		<div>
			<div id="_idContainer085" class="Content">
			</div>
		</div>
		<div id="_idContainer086" class="Content">
			<h1 id="_idParaDest-165"><a id="_idTextAnchor185"/>8. Namespaces, Libraries and Leiningen</h1>
		</div>
		<div id="_idContainer109" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we learn how to organize Clojure code. We start by looking at namespacesâ€”a way to group Clojure functions together. We will see how to create our own namespaces and how to import namespaces written by others. Namespaces are building blocks of Clojure libraries. We will learn how to import and use Clojure libraries. After learning about namespaces and libraries, we investigate how to structure a Clojure project. We then look at Leiningen project template and how it helps developers to create applications.</p>
			<p class="callout">By the end of this chapter, you will be able to use Leiningen to organize and run your projects.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor186"/>Introduction</h1>
			<p>In the previous chapter, we learned about sequences in Clojure and how working with them helps us to build Clojure programs. Now that you're familiar with using Clojure to implement various pieces of functionality, it's time to become more comfortable with accomplishing the basic tasks of creating, building, testing, deploying, and running projects in Clojure and ClojureScript.</p>
			<p>Clojure was designed to be a very practical language from the beginning. Getting things done means interacting with the outside world, building projects, using libraries, and deploying your work. As a developer, you will need to organize written code in a structure. In this chapter, you will see how namespaces can help you structure code and how build tools such as Leiningen help you put together a whole application.</p>
			<p>In a real-world project, you won't write all the code. External dependencies are a crucial part of any project, and we'll learn here how to bring them into your project and your code.</p>
			<p>The first step is to understand how Clojure namespaces work in general. Then we'll look at the project level and using Leiningen and your <strong class="source-inline">project.clj<a id="_idTextAnchor187"/></strong> file to pull everything together into a Java executable. Finally, we'll take a look at some of the conveniences that Leiningen provides throughout the life cycle of a project.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor188"/>Namespaces</h1>
			<p>Namespaces are a way to organize Clojure functions; you can think of a namespace as being a directory (or file) that stores a particular group of functions. <a id="_idTextAnchor189"/>Each directory is independent of other directories; this helps to keep different groups of functions separate and gives a clear structure to your code. It also helps to avoid the confusion that can come with naming clashes.</p>
			<p>Consider a situation where you have written a function called <strong class="source-inline">calculate-total</strong>, and as part of your project, you're using a library <em class="italic">(more on libraries later in this chapter)</em> that also contains a function called <strong class="source-inline">calculate-total</strong>. Although these functions have the same name, they work differently, produce slightly different outputs, and are intended to be used in different situations. When you come to use <strong class="source-inline">calculate-total</strong> in your code, how does the system know which <strong class="source-inline">calculate-function</strong> you actually want? That's where namespaces come in. The two functions will exist in different namespaces, so you can state the appropriate namespace when calling the function in order to specify which one you want to use.</p>
			<p>In more technical terms, namespaces provide a mapping between a symbol (which makes sense to a human reader) and a var or class. Namespaces can be compared to packages in Java or modules in Ruby and Python. We will first explore the concept of namespaces in Clojure using REPL.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor190"/>Exercise 8.01: Investigating Namespaces Started by Default in REPL</h2>
			<p>In this exercise, we will investigate how namespaces are handled in REPL:</p>
			<ol>
				<li>Open Terminal or Command Prompt and add the following command to start REPL using Leiningen:<p class="source-code">lein repl</p><p>This will start REPL using Leiningen. It might take several seconds to start REPL. Once REPL is started, you should see something similar to the following:</p><div id="_idContainer087" class="IMG---Figure"><img src="image/B14502_08_01.jpg" alt="Figure 8.1: Starting REPL&#13;&#10;"/></div><p class="figure-caption">Figure 8.1: Starting REPL</p><p>The last line, <strong class="source-inline">user=&gt;</strong>, tells us that we are in the default <strong class="source-inline">user</strong> namespace. In this namespace, functions from the <strong class="source-inline">clojure.core</strong> namespace are available to us. Let's explore a few functions.</p></li>
				<li>In REPL, type the following code to calculate the sum of two numbers:<p class="source-code">(+ 1 2)</p><p>This simple code should return:</p><p class="source-code">3</p></li>
				<li>Let's try Clojure's <strong class="source-inline">filter odd</strong> function to return the odd numbers:<p class="source-code">(filter odd? [1 2 3 4 5 6])</p><p>This will return the following:</p><p class="source-code">(1 3 5)</p></li>
			</ol>
			<p>We see that in the default user namespace, we have access to core Clojure functions. But what if we want to access functions that are defined in some other namespaces? Clojure provides us with the <strong class="source-inline">in-ns</strong> function, which switches to the requested namespace. This function will also create a new namespace if the requested namespace does not exist. In the next exercise, we will use the <strong class="source-inline">in-ns</strong> function to access data from a different namespace than the one currently being used.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor191"/>Exercise 8.02: Navigating Namespaces</h2>
			<p>In the previous exercise, we used functions in the default user namespace. In this exercise, we will have a look at accessing data from other namespaces:</p>
			<ol>
				<li value="1">In Terminal, call the <strong class="source-inline">in-ns</strong> function to create a new namespace:<p class="source-code">(in-ns 'new-namespace)</p><p>In REPL, we will see that a new namespace has been created:</p><div id="_idContainer088" class="IMG---Figure"><img src="image/B14502_08_02.jpg" alt="Figure 8.2: New namespace created&#13;&#10;"/></div><p class="figure-caption">Figure 8.2: New namespace created</p><p>You should notice that the REPL prompt has changed to <strong class="source-inline">new-namespace=&gt;</strong>.</p><p>This visual cue tells us that we have successfully switched to a new namespace. Anything you declare inside this namespace will be available in it.</p></li>
				<li>We will declare a variable in our new namespace. Type the following declaration:<p class="source-code">(def fruits ["orange" "apple" "melon"])</p><p>REPL lets us know that a new variable has been created:</p><p class="source-code">#'new-namespace/fruits</p></li>
				<li>To check its content, we will access it from REPL as follows:<p class="source-code">fruits</p><p>As expected, REPL gives us back the vector:</p><p class="source-code">["orange" "apple" "melon"]</p></li>
				<li>We will switch the namespace now using the <strong class="source-inline">in-ns</strong> function:<p class="source-code">(in-ns 'other-namespace)</p><p>REPL lets us know that the change has happened:</p><p class="source-code">#object[clojure.lang.Namespace 0x2f2b1d3c "other-namespace"]</p><p>REPL's prompt has also changed:</p><p class="source-code">other-namespace=&gt;</p></li>
				<li>Now access the <strong class="source-inline">fruits</strong> vector as follows:<p class="source-code">fruits</p><p>We will see an unpleasant surprise:</p><p class="source-code">CompilerException java.lang.RuntimeException: Unable to resolve symbol: fruits in this context, compiling:(null:0:0)</p><p>We have declared the <strong class="source-inline">fruits</strong> vector in <strong class="source-inline">new-namespace</strong> but we tried to access it from another namespace. To access vars from one namespace in another namespace, we need to explicitly state which namespace the var comes from.</p></li>
				<li>Type the fully qualified name in REPL to access the data as follows:<p class="source-code">new-namespace/fruits</p><p>This time, we get our <strong class="source-inline">fruits</strong> vector:</p><p class="source-code">["orange" "apple" "melon"]</p></li>
			</ol>
			<p>Using fully qualified names can become tedious. In the next exercise, we will see how Clojure helps us with managing multiple namespaces.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor192"/>Importing Clojure Namespaces Using the refer Function</h2>
			<p>Clojure provides the <strong class="source-inline">refer</strong> function, which aims to help developers write compact code. This is achieved by importing the contents of a specific namespace into the current namespace, thereby allowing those contents to be accessed easily. In the previous example, we used <strong class="source-inline">new-namespace/fruits</strong> to access the <strong class="source-inline">fruits</strong> vector from a different namespace outside <strong class="source-inline">new-namespace</strong>. What <strong class="source-inline">refer</strong> allows us to do is reference <strong class="source-inline">new-namespace</strong> once and then use <strong class="source-inline">fruits</strong> as many times as we need, without having to state the full namespace every time.</p>
			<p>In the previous section, we used the <strong class="source-inline">in-ns</strong> function. In this section, we will use <strong class="source-inline">refer</strong> function. Although both functions help us to work with namespaces, we use them for different purposes. The <strong class="source-inline">in-ns</strong> function creates a scope for our code. We place data and functions inside a namespace. When we want to create a new namespace and thus a new scope for code, we use <strong class="source-inline">in-ns</strong>. Now, <strong class="source-inline">refer</strong>, on the other hand, will allow us to work within the scope of the current namespace and import data from a different namespace. We can import one or more namespaces and still work in one namespace scope.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor193"/>Exercise 8.03: Using the refer Function to Import a Namespace</h2>
			<p>In this exercise, we will use the <strong class="source-inline">refer</strong> function to import Clojure namespaces. This will help us understand how the <strong class="source-inline">refer</strong> function is used.</p>
			<p>Using <strong class="source-inline">refer</strong> allows us to reference functions or objects from other namespaces:</p>
			<ol>
				<li value="1">In REPL, type the following command to import a new namespace using the <strong class="source-inline">refer</strong>Â function:<p class="source-code">(clojure.core/refer 'new-namespace)</p><p>We used <strong class="source-inline">refer</strong> here to import data from <strong class="source-inline">new-namespace</strong>. If we'd used the <strong class="source-inline">in-ns</strong> function, we would have changed the scope of the code. We would be able to access data from <strong class="source-inline">new-namespace</strong> but because the scope changed, we would lose access to <strong class="source-inline">other-namespace</strong> that we worked at before switching to <strong class="source-inline">new-namespace</strong>. Our aim is to write code within the scope of <strong class="source-inline">other-namespace</strong> and only access functions from <strong class="source-inline">new-namespace</strong>.</p></li>
				<li>After this, we can use the <strong class="source-inline">fruits</strong> vector directly by calling it in REPL:<p class="source-code">fruits</p><p>The output is as follows:</p><p class="source-code">["orange" "apple" "melon"]</p></li>
			</ol>
			<p>Using <strong class="source-inline">refer</strong> allowed us to include all objects from the specified namespace in the current one. The <strong class="source-inline">refer</strong> function allows us to use optional keywords to control importing namespaces. We will see them in action now. </p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor194"/>Advanced Use of the refer Function</h2>
			<p>In <em class="italic">Chapter 2</em>, <em class="italic">Data Types and Immutability</em>, we learned about keywords in Clojure. The basic usage of the <strong class="source-inline">refer</strong> function that we learned in the previous section can be altered or expanded using keywords. They are optional as we can use them but do not have to.</p>
			<p>The keywords that we can use with <strong class="source-inline">refer</strong> are:</p>
			<ul>
				<li><strong class="source-inline">:only</strong>: The <strong class="source-inline">:o<a id="_idTextAnchor195"/>nly</strong> keyword allows us to import only the functions that we specify. This means that any functions not specified are not imported. </li>
				<li><strong class="source-inline">:exclude</strong>: The <strong class="source-inline">:e<a id="_idTextAnchor196"/>xclude</strong> keyword allows us to exclude certain functions from being imported. We would import all but the ones that we want to exclude.</li>
				<li><strong class="source-inline">:rename</strong>: The <strong class="source-inline">:r<a id="_idTextAnchor197"/>ename</strong> keyword allows us to rename functions that we import. This sets an aliasâ€”a new name for a functionâ€”and we would refer to the function using that new name.</li>
			</ul>
			<p>W<a id="_idTextAnchor198"/><a id="_idTextAnchor199"/><a id="_idTextAnchor200"/>e now know three keywords that can modify the importing of namespaces using the <strong class="source-inline">refer</strong> function. In the next three exercises, we will use each keyword to import namespaces and use data from them.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor201"/>Exercise 8.04: Using the :only Keyword</h2>
			<p>The aim of this exercise is to show how we can extend the basic use of the <strong class="source-inline">refer</strong> function by using the <strong class="source-inline">:only</strong> keyword. We will import namespaces using the <strong class="source-inline">refer</strong> function with the <strong class="source-inline">:only</strong> keyword. Then, we will access data from the imported namespace:</p>
			<ol>
				<li value="1">In REPL, type the following command to use the <strong class="source-inline">in-ns</strong> function to create the <strong class="source-inline">garden</strong>Â namespace:<p class="source-code">(in-ns 'garden)</p><p>REPL creates a new namespace for us:</p><p class="source-code">#object[clojure.lang.Namespace 0x6436be0 "garden"]</p></li>
				<li>We can define two variables in this namespace:<p class="source-code">(d<a id="_idTextAnchor202"/>ef vegetables ["cucumber" "carrot"])</p><p class="source-code">(def fruits ["orange" "apple" "melon"])</p><p>REPL informs us that vars have been created:</p><p class="source-code">#'garden/vegetables</p><p class="source-code">#'garden/fruits</p></li>
				<li>After that, we switch to a new namespace using the <strong class="source-inline">in-ns</strong> function:<p class="source-code">(i<a id="_idTextAnchor203"/>n-ns 'shop)</p><p class="callout-heading">Note</p><p class="callout">With the <strong class="source-inline">:only</strong> keyword, we can refer to another namespace but import only selected parts.</p></li>
				<li>Import the <strong class="source-inline">garden</strong> namespace using the <strong class="source-inline">refer</strong> function together with the <strong class="source-inline">:only</strong>Â keyword:<p class="source-code">(c<a id="_idTextAnchor204"/>lojure.core/refer 'garden :only '(vegetables))</p><p>This will return the following:</p><p class="source-code">nil</p><p>We can access the <strong class="source-inline">vegetables</strong> var directly in the new <strong class="source-inline">shop</strong> namespace.</p></li>
				<li>Call the <strong class="source-inline">vegetables</strong> var to access its content:<p class="source-code">vegetables</p><p>REPL returns the expected vector as follows:</p><p class="source-code">["cucumber" "carrot"]</p></li>
				<li>If, however, we want to access another var, <strong class="source-inline">fruits</strong>, call the <strong class="source-inline">fruits</strong> vector as follows:<p class="source-code">fruits</p><p>We get an exception in REPL:</p><p class="source-code">CompilerException java.lang.RuntimeException: Unable to resolve symbol: fruits in this context, compiling:(null:0:0)</p><p>Because when we imported the namespace, we used the <strong class="source-inline">:only</strong> keyword to import the <strong class="source-inline">vegetables</strong> var. The other var needs to be fully qualified with a namespace if we want to use it.</p></li>
				<li>Call the <strong class="source-inline">fruits</strong> vector using the fully qualified name:<p class="source-code">garden/fruits</p><p>This time, we get the expected vector as follows:</p><p class="source-code">["orange" "apple" "melon"]</p></li>
			</ol>
			<p>In this exercise, we created vars in one namespace and then we imported this namespace using the <strong class="source-inline">refer</strong> function. During the import, we used the <strong class="source-inline">:only</strong> keyword, which allowed us to import only the selected data. </p>
			<p>In the next exercise, we will import a namespace using the <strong class="source-inline">refer</strong> function and the <strong class="source-inline">:exclude</strong> keyword.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor205"/>Exercise 8.05: Using the :exclude Keyword</h2>
			<p>In the previous exercise, we imported content from one namespace to another using the <strong class="source-inline">refer</strong> function. We restricted importing using the <strong class="source-inline">:only</strong> keyword to import only selected data. Now we will use a second keyword that allows us to control the importing of namespaces with the <strong class="source-inline">refer</strong> function.</p>
			<p>Using the <strong class="source-inline">:exclude</strong> keyword allows us to import some parts from a namespace but exclude parts that we do not need:</p>
			<ol>
				<li value="1">First, we will switch to a new namespace using the <strong class="source-inline">in-ns</strong> function:<p class="source-code">(in-ns 'market)</p><p>REPL tells us that we successfully switched to a new namespace:</p><p class="source-code">#object[clojure.lang.Namespace 0x177c36c4 "market"]</p></li>
				<li>The next step is to import the <strong class="source-inline">garden</strong> namespace but exclude the <strong class="source-inline">vegetables</strong> var. We use the <strong class="source-inline">refer</strong> function with the <strong class="source-inline">:exclude</strong> keyword:<p class="source-code">(clojure.core/refer 'garden :exclude '(vegetables))</p><p>This will return the following:</p><p class="source-code">nil</p></li>
				<li>We test the import by trying to access the <strong class="source-inline">fruits</strong> var:<p class="source-code">fruits</p><p>So far, so good, as REPL returns us the vector:</p><p class="source-code">["orange" "apple" "melon"]</p></li>
				<li>We will try accessing the excluded var, <strong class="source-inline">vegetables</strong>:<p class="source-code">vegetables</p><p>We immediately see an exception message in REPL:</p><p class="source-code">CompilerException java.lang.RuntimeException: Unable to resolve symbol: vegetables in this context, compiling:(null:0:0)</p></li>
				<li>We need to use the fully qualified name to access the <strong class="source-inline">vegetables</strong> var:<p class="source-code">garden/vegetables</p><p>This time, REPL shows us the expected vector:</p><p class="source-code">["cucumber" "carrot"]</p></li>
			</ol>
			<p>In this exercise, we imported a namespace using the <strong class="source-inline">refer</strong> function. During the import, we used the <strong class="source-inline">:exclude</strong> keyword, which allowed us to restrict the data to be imported.</p>
			<p>In the next exercise, we will import a namespace using the <strong class="source-inline">refer</strong> function and the <strong class="source-inline">:rename</strong> keyword.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor206"/>Exercise 8.06: Using the :rename Keyword</h2>
			<p>In the previous exercise, we imported content from one namespace to another using the <strong class="source-inline">refer</strong> function. We restricted importing using the <strong class="source-inline">:exclude</strong> keyword to import only data that we wanted. Now we will use a third keyword that allows us to control the importing of namespaces with the <strong class="source-inline">refer</strong> function.</p>
			<p>We will see the <strong class="source-inline">:rename</strong> keyword in use. It allows us to import from one namespace and rename certain symbols:</p>
			<ol>
				<li value="1">We will switch to a new namespace using the <strong class="source-inline">in-ns</strong> function:<p class="source-code">(in-ns 'shops)</p></li>
				<li>While we import the <strong class="source-inline">garden</strong> namespace, we want to rename the <strong class="source-inline">fruits</strong> var to <strong class="source-inline">owoce</strong> (Polish for fruits). We will use the <strong class="source-inline">refer</strong> function with the <strong class="source-inline">:rename</strong> keyword:<p class="source-code">(clojure.core/refer 'garden :rename '{fruits owoce})</p></li>
				<li>We access the <strong class="source-inline">vegetables</strong> var in the REPL:<p class="source-code">ve<a id="_idTextAnchor207"/>getables</p><p>This returns the vector in the REPL:</p><p class="source-code">["cucumber" "carrot"]</p></li>
				<li>Trying to access the <strong class="source-inline">fruits</strong> var:<p class="source-code">fr<a id="_idTextAnchor208"/>uits</p><p>It tells us that it is not accessible:</p><p class="source-code">CompilerException java.lang.RuntimeException: Unable to resolve symbol: fruits in this context, compiling:(null:0:0)</p><p>Because we renamed the <strong class="source-inline">fruits</strong> var, we need to access <strong class="source-inline">fruits</strong> with a new name, which we defined when we used the <strong class="source-inline">refer</strong> function.</p></li>
				<li>Now type <strong class="source-inline">owoce</strong> in the REPL:<p class="source-code">owoce</p><p>This time, we get the expected vector:</p><p class="source-code">["orange" "apple" "melon"]</p></li>
			</ol>
			<p>In this exercise, we imported a namespace using the <strong class="source-inline">refer</strong> function. During the import, we used the <strong class="source-inline">:rename</strong> keyword, which allowed us to restrict what data should be imported.</p>
			<p>We now know how to use <strong class="source-inline">refer</strong>. First, we imported a namespace using the <strong class="source-inline">refer</strong> function. Then we saw how we can modify importing with the <strong class="source-inline">refer</strong> function when we use three keywords: <strong class="source-inline">:only</strong>, <strong class="source-inline">:exclude</strong>, and <strong class="source-inline">:rename</strong>. </p>
			<p>We use the <strong class="source-inline">:only</strong> keyword when we want to import from one namespace to certain other functions. The <strong class="source-inline">:only</strong> keyword allows us to limit the functions that we import.</p>
			<p>We use the <strong class="source-inline">:exclude</strong> keyword when we want to import from one namespace to another but without certain functions. The <strong class="source-inline">:only</strong> keyword allows us to exclude functions that we do not want to import.</p>
			<p>We use the <strong class="source-inline">:rename</strong> keyword when we want to import from one namespace to another and change the names of some functions during the import. </p>
			<p>In the next section, we will learn how <strong class="source-inline">require</strong> and <strong class="source-inline">use</strong> help us with managing namespaces.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor209"/>Importing Clojure Functions with require and use</h1>
			<p>In the previous section, we learned how to import Clojure functions using <strong class="source-inline">refer</strong>. In this section, we will learn how we can import Clojure functions with <strong class="source-inline">require</strong> and <strong class="source-inline">use</strong>.</p>
			<p>While <strong class="source-inline">refer</strong> allows us to literally refer to other namespaces' vars without fully qualifying them, often we need more than that. In the previous exercise, we imported a namespace and accessed vars such as <strong class="source-inline">fruits</strong> from it without using the namespace name as a prefix to the <strong class="source-inline">garden</strong>/<strong class="source-inline">fruits</strong> var. Often, we want to load functions from a namespace and use those functions. If we want to read the file, we need to import code from the Clojure I/O library (the library for input-output operations such as reading and writing files).</p>
			<p>With the <strong class="source-inline">require</strong> function, we will load a namespace that we'll specify. This way, functions from the loaded namespace are available in our namespace for use. This is a great way to write Clojure code, reuse existing functions, and make them available in our code. Although we loaded new functions with <strong class="source-inline">require</strong>, we still need to fully qualify them.</p>
			<p>While the <strong class="source-inline">require</strong> function allows us to load a designated namespace, the <strong class="source-inline">use</strong> function goes a little bit further and implicitly uses <strong class="source-inline">refer</strong> to allow code to refer to other namespaces' vars without fully qualifying them.</p>
			<p><strong class="source-inline">refer</strong>, <strong class="source-inline">require</strong>, and <strong class="source-inline">use</strong> all serve different purposes:</p>
			<ul>
				<li><strong class="source-inline">refer</strong> allows us to call functions from a different namespace (functions are notÂ imported).</li>
				<li><strong class="source-inline">require</strong> imports functions from a different namespace but we have to qualify them when using them.</li>
				<li><strong class="source-inline">use</strong> loads functions from a different namespace and we do not have to qualify them.</li>
			</ul>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor210"/>Exercise 8.07: Importing Clojure Functions with require and use</h2>
			<p>In this exercise, we will learn how the <strong class="source-inline">require</strong> and <strong class="source-inline">use</strong> functions can help us to import Clojure namespaces. We will import Clojure namespaces using both methods. This will help us understand the difference between both methods.</p>
			<p>By using <strong class="source-inline">require</strong>, we ensure that the namespaces provided are fully loaded whenever we need to use them.</p>
			<p>Clojure provides a number of namespaces, such as <strong class="source-inline">clojure.edn</strong> or <strong class="source-inline">clojure.pprint</strong>, that help developers to create programs. EDN stands for extensible data notation. It is a system for representing objects. It provides a rich set of features such as functionality for specifying the date and time. The <strong class="source-inline">clojure.edn</strong> namespace allows us to use the <strong class="source-inline">edn</strong> format. Imagine that you want to send a date from one program to another. If you send the date as a string, "Monday 7.10.2019," there is no information about time zone. The program receiving this date string does not know whether this time is in London or New York. With <strong class="source-inline">edn</strong>, we can send a date object that contains information about the time zone.</p>
			<p>The <strong class="source-inline">clojure.print</strong> namespace contains utility functions that help to print data from programs in an easy-to-understand and easy-to-read format. </p>
			<p>Consider printing a hash as shown in the following figure:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B14502_08_03.jpg" alt="Figure 8.3: Printing a hash&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: Printing a hash</p>
			<p>Instead of printing a hash as shown in <em class="italic">Figure 8.3</em>, functions from the <strong class="source-inline">clojure.pprint</strong> namespace allow us to print a hash like this:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B14502_08_04.jpg" alt="Figure 8.4: Printing a hash using the functions from the namespace&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4: Printing a hash using the functions from the namespace</p>
			<p>By default, when we start a new session, only <strong class="source-inline">clojure.core</strong> is available. The <strong class="source-inline">clojure.core</strong> namespace contains the main Clojure functions, such as <strong class="source-inline">filter</strong>, <strong class="source-inline">map</strong>, <strong class="source-inline">reduce</strong>, and <strong class="source-inline">count</strong>. These are core functions that are used very often when working in Clojure. That is why they are available by default when working in Clojure. The other namespaces need to be added by us:</p>
			<ol>
				<li value="1">We will require a new namespace in our REPL session that will help us pretty print some content:<p class="source-code">(require 'clojure.pprint)</p></li>
				<li>We can use functions from this namespace now. We call the <strong class="source-inline">print-table</strong> function to print a table in REPL:<p class="source-code">(clojure.pprint/print-table [{:text "Clojure"}{:text "is"}{:text "fun"}])</p><p>This prints a table in REPL:</p><div id="_idContainer091" class="IMG---Figure"><img src="image/B14502_08_05.jpg" alt="Figure 8.5: Printing a table in REPL&#13;&#10;"/></div><p class="figure-caption">Figure 8.5: Printing a table in REPL</p><p>Using fully qualified names can become tedious because every time we want to call any function, we have to provide its full name, including the namespace. This results in verbose code and a lot of repetition of namespace names. Fortunately, Clojure allows us to set an alias for a namespace. In order to set an alias, we use the <strong class="source-inline">:as</strong> keyword. With the <strong class="source-inline">:as</strong> keyword, we shorten how we call functions. We do not need to write the full namespace but simply an alias that we choose.</p></li>
				<li>Call the <strong class="source-inline">require</strong> function with the <strong class="source-inline">:as</strong> keyword to simplify importing the function:<p class="source-code">(require '[clojure.pprint :as pprint])</p></li>
				<li>Now we can use the alias to call the <strong class="source-inline">print-table</strong> function:<p class="source-code">(pprint/print-table [{:text "Clojure"}{:text "is"}{:text "fun"}])</p><p>We have just seen how the <strong class="source-inline">require</strong> function is used. Next, we will see how the <strong class="source-inline">use</strong> function helps us to import namespaces.</p></li>
				<li>We call the <strong class="source-inline">use</strong> function to import namespaces in REPL:<p class="source-code">(use 'clojure.pprint)</p><p>The preceding statement will load the <strong class="source-inline">clojure.pprint</strong> namespace and refer to theÂ namespace.</p><p>We can use functions from this namespace without fully qualifying them.</p></li>
				<li>Call the <strong class="source-inline">print-table</strong> function without the namespace name to print a table:<p class="source-code">(print-table [{:text "Clojure"}{:text "is"}{:text "fun"}])</p><p>This will print a table for us:</p><div id="_idContainer092" class="IMG---Figure"><img src="image/B14502_08_06.jpg" alt="Figure 8.6: Calling the print-table function&#13;&#10;"/></div><p class="figure-caption">Figure 8.6: Calling the print-table function</p><p>We have just seen how <strong class="source-inline">use</strong> works. Next, we will look into using keywords such as <strong class="source-inline">:only</strong> and <strong class="source-inline">:rename</strong> with <strong class="source-inline">use</strong>.</p></li>
				<li>Import a function from the <strong class="source-inline">clojure.string</strong> namespace:<p class="source-code">(use '[clojure.string :only [split]])</p><p>This will import the <strong class="source-inline">split</strong> function from the <strong class="source-inline">string</strong> namespace and return theÂ following:</p><p class="source-code">nil</p><p>We can use the <strong class="source-inline">split</strong> function without a namespace name:</p><div id="_idContainer093" class="IMG---Figure"><img src="image/B14502_08_07.jpg" alt="Figure 8.7: Using the split function&#13;&#10;"/></div><p class="figure-caption">Figure 8.7: Using the split function</p></li>
				<li>Rename the function from the <strong class="source-inline">clojure.edn</strong> namespace when importing with <strong class="source-inline">use</strong>:<p class="source-code">(use '[clojure.edn :rename {read-string string-read}])</p><p>This will return the following:</p><p class="source-code">nil</p></li>
				<li>We renamed the <strong class="source-inline">read-string</strong> function from the <strong class="source-inline">clojure.end</strong> namespace to <strong class="source-inline">string-read</strong>. We can call the <strong class="source-inline">string-read</strong> function without a namespace name now:<p class="source-code">(class (string-read "#inst \"1989-02-06T13:20:50.52Z\""))</p><p>The output is as follows:</p><p class="source-code">java.util.Date</p><p>We have a string that represents a date from 1989. We pass this string to the <strong class="source-inline">edn</strong> function, which converts a string to a <strong class="source-inline">Date</strong> object. When we call the <strong class="source-inline">class</strong> function, it tells us that we have a <strong class="source-inline">Date</strong> object.</p></li>
			</ol>
			<p>We have seen how to import namespaces with <strong class="source-inline">refer</strong> and <strong class="source-inline">use</strong>. In the following activity, we will put this knowledge into practice.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor211"/>Activity 8.01: Altering the Users List in an Application</h2>
			<p>In this activity, we will apply our knowledge about importing namespaces to solve a real-world problem. Imagine that we work in an IT company and we are responsible for designing a backend application. One of the functions in our backend returns a list of users. A new frontend feature needs this list in a different format. The aim of this activity is to alter the list of users.</p>
			<p>The two alterations required are:</p>
			<ul>
				<li>Capitalizing usernames</li>
				<li>Checking whether the users John, Paul, and Katie belong to an admin group</li>
			</ul>
			<p>The application currently displays a list of users, their honorifics, their first names, and their last names. The honorifics and first names are separated by <strong class="source-inline">_</strong> (an underscore). In this activity, we will add a space between the honorifics and the first names. Then, we will take the first and last names and capitalize the first letter of the honorifics, first names, and last names. Finally, we will check whether our users belong to the admin group.</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">clojure.string</strong> namespace with <strong class="source-inline">use</strong> and the <strong class="source-inline">:rename</strong> keyword for the <strong class="source-inline">replace</strong> and <strong class="source-inline">reverse</strong> functions.</li>
				<li>Create a set of users.</li>
				<li>Replace<a id="_idTextAnchor212"/> the underscore between the honorifics and the first names.</li>
				<li>Use the <strong class="source-inline">capitalize</strong> function to capitalize each person's initials in the user group.</li>
				<li>Update the user list by using the string <strong class="source-inline">replace</strong> and <strong class="source-inline">capitalize</strong> functions.</li>
				<li>Import only the <strong class="source-inline">print-table</strong> function from the <strong class="source-inline">clojure.pprint</strong> namespace.</li>
				<li>Print a table with users.</li>
				<li>Import the <strong class="source-inline">clojure.set</strong> namespace, excluding the <strong class="source-inline">join</strong> function.</li>
				<li>Create a set of admins.</li>
				<li>Call the <strong class="source-inline">subset?</strong> function on two sets of users and admins.</li>
			</ol>
			<p>The initial list of users and admins will look as follows:</p>
			<p class="source-code">#{"mr_john blake" "miss_paul smith" "dr_katie hudson"}</p>
			<p>The admin list will look as follows:</p>
			<p class="source-code">#{"Mr Paul Smith" "Dr Mike Rose" "Miss Katie Hudson" "Mrs Tracy Ford"}</p>
			<p>The final list of users will look as follows:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B14502_08_08.jpg" alt="Figure 8.8: Expected outcome&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8: Expected outcome</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 706.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor213"/>When You Want use versus When You Want require</h2>
			<p>Although <strong class="source-inline">use</strong> and <strong class="source-inline">require</strong> may seem very similar at first glance, with some practice you will understand when to use each one.</p>
			<p>If we want to import a namespace using <strong class="source-inline">require</strong>, we will call it as follows:</p>
			<p class="source-code">(require 'clojure.pprint)</p>
			<p>Importing a namespace with <strong class="source-inline">use</strong> is done as follows:</p>
			<p class="source-code">(use 'clojure.pprint)</p>
			<p>If we compare both statements, we see that the only difference is the importing function, either <strong class="source-inline">require</strong> or <strong class="source-inline">use</strong>. The syntax of using them is the same. We call a function and then the namespace that we want to import. The reason to use both importing functions is different, though, as we will see in this topic.</p>
			<p>When in doubt, choose <strong class="source-inline">require</strong>. It allows you to add an alias for the namespace and makes the code more readable than having to use fully qualified names:</p>
			<p class="source-code">(require '[clojure.string :as str])</p>
			<p>This way, we can call functions very easily. Consider the following example:</p>
			<p class="source-code">(str/reverse "palindrome")</p>
			<p>When choosing <strong class="source-inline">use</strong>, advised to add an alias and import only required functions:</p>
			<p class="source-code">(use '[clojure.string :as str :only (split)])</p>
			<p>When you import only required functions, you can easily add more later on. Importing only the functions that we require at the moment helps us to maintain the code. The developers dealing with the code will not spend time searching for the usage of functions that we imported.</p>
			<p>There are two potential problems with using <strong class="source-inline">use</strong> without the <strong class="source-inline">:only</strong> keyword:</p>
			<ul>
				<li>Inspecting the code does not tell us quickly from which namespace a certain function comes. With aliased namespaces, we can establish this more easily.</li>
				<li>We avoid any name collisions in the future if we add a new library or if an existing library introduces a new function with a name that we are already using.</li>
			</ul>
			<p>Now that we've looked at namespaces, we will go a level higher and investigate how to structure projects using Leiningen.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor214"/>Leiningenâ€”A Build Tool in Clojure</h1>
			<p>With namespaces, we put our functions into files and group related functions together. This helps to keep code separated into units. Consider a situation where utility functions are separated from frontend functions. This helps us navigate code and find functions. We know that frontend functions responsible for creating HTML will not be in a backend namespace responsible for connecting to the database. Build tools serve a different purpose. As the name suggests, these are tools that help us build. With them, we automate the creation of an executable application. An alternative would be to compile all the code ourselves and put it on a server. Even in applications with only a few features, we run the risk of forgetting to compile a namespace. The more namespaces there are and the more complicated an application is, the bigger the risk of making a mistake in manual code compilation. Build tools compile our code and package it into a usable form. Developers specify parts of the application that need to be compiled and the build tool automatically compiles the parts for them. This helps to minimize compilation mistakes. Some build tools are Maven, Gradle, Webpack, and Grunt.</p>
			<p>Leiningen is a very popular build tool in the Clojure community. Its popularity comes from the rich set of features it has. It provides a lot of templates that allow developers to start writing code without much of a project setup. Often, the type of application that a developer wants to create has already been created by someone else. This way, we can reuse what developers before us created instead of writing so much code ourselves. We have a web application template that provides us with a common structure for a web page. There is a template for a backend server with a file structure and configuration that is common in backend servers. In the next exercise, we will create a new project.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor215"/>Exercise 8.08: Creating a Leiningen Project</h2>
			<p>The aim of this exercise is to learn about the standard structure in Leiningen projects. We will create a sample project based on a template from Leiningen. This will allow us to explore the files that Leiningen creates and the purpose of each file.</p>
			<p>In order to create a new Leiningen project, we will use the command line:</p>
			<ol>
				<li value="1">Call a new <strong class="source-inline">lein</strong> task with the <strong class="source-inline">app</strong> template. To create a new project, execute theÂ following:<p class="source-code">lein new app hello-leiningen</p><p>In the preceding command, the <strong class="source-inline">lein</strong> command takes three parameters:</p><p><strong class="source-inline">new</strong>: A <strong class="source-inline">lein</strong> task telling Leiningen what type of task to execute. Task <strong class="source-inline">new</strong> will create a project based on a template.</p><p><strong class="source-inline">app</strong>: The name of the template to use when creating a project. Leiningen will create a project using a specified template.</p><p><strong class="source-inline">hello-leiningen</strong>: The name of the project.</p><p>We should see that our new project has been created:</p><p class="source-code">Generating a project called hello-leiningen based on the 'app' template.</p></li>
				<li>After creating a project, we will navigate to the project's directory:<p class="source-code">cd hello-leiningen</p></li>
				<li>Now, inspect the project as follows:<p class="source-code">find .</p><p>We will see that Leiningen has created a number of files for us already:</p><div id="_idContainer095" class="IMG---Figure"><img src="image/B14502_08_09.jpg" alt="Figure 8.9: Inspecting the project&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.9: Inspecting the project</p>
			<p>There are a few important things to notice here:</p>
			<ul>
				<li>We have a source directory, <strong class="source-inline">src</strong>, where we will put our code.</li>
				<li>The <strong class="source-inline">project.clj</strong> file contains a description of our project.</li>
				<li><strong class="source-inline">README.md</strong> is an entry point with information about our application.</li>
				<li>We have a <strong class="source-inline">test</strong> directory for our tests.</li>
			</ul>
			<p>We will have a closer look at these points in the following sections. Testing will be covered in <em class="italic">Chapter 10</em>, <em class="italic">Testing</em>. In the next section, we will look at the <strong class="source-inline">project.clj</strong> file.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor216"/>Investigating project.clj</h2>
			<p>The <strong class="source-inline">project.clj</strong> file that you have created will look similar to this one:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B14502_08_10.jpg" alt="Figure 8.10: The project.clj file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10: The project.clj file</p>
			<p>Let's take a look at each parameter:</p>
			<ul>
				<li><strong class="bold">Project version</strong>: We see that our <strong class="source-inline">hello-leiningen</strong> project has got a SNAPSHOT version. This means that it is not yet a stable production-tested version but rather a development version. When you are ready to publish your project, be sure to add a proper version. A good guide is to use semantic versioning. There are times when using a snapshot version is necessary, such as with a bug fix before the fix gets included in the next release. The rule of thumb is to use stable versions unless a bug fix is needed.</li>
				<li><strong class="bold">Description</strong>: Adding a description is a good starting point for people looking at understanding the purpose of a project. Also, when the project is published in project repositories such as Maven or Clojars, it is easier to search for the project.</li>
				<li><strong class="bold">URL</strong>: While the description is limited, the <strong class="source-inline">url</strong> parameter allows us to place a web URL for our project. On our web page, we can add much more information about our project. Most project websites would have:<p>A rationale: Why the project was created</p><p>Documentation: A description of its usage</p><p>Tutorials: Examples of using the project</p></li>
				<li><strong class="bold">License</strong>: The license is used as you might expect. It is a legal instrument governing the use of software. Essentially, it is an agreement between the owner of software and its user, allowing the user to use software under certain conditions.<p>There are many types of software licenses. Examples of licenses include:</p><p>MIT license: This allows the distribution and modification of source code.</p><p>Apache License 2.0: Like the MIT license, this allows the distribution and modification of code but requires the preservation of copyright notices.</p><p>GNU AGPLv3: Like the MIT license, this allows the distribution and modification of code but requires the stating of changes compared to the original version of the software.</p></li>
				<li><strong class="bold">Dependencies</strong>: Java or JVM projects are distributed as <strong class="source-inline">jar</strong> files. They are basically <strong class="source-inline">zip</strong> files (compressed files) with some metadata about the project. When we specify dependencies in our <strong class="source-inline">project.clj</strong>, Leiningen will search the local repository. If dependencies are not already stored locally, then it will search the Maven and Clojars websites and download the dependencies. Such dependencies are then available for our project.</li>
				<li><strong class="bold">Main namespace</strong>: In the <strong class="source-inline">:main</strong> keyword, we specify the namespace that is the entry point for our project and application. It gets called when we run our project. </li>
				<li><strong class="bold">Ahead of time</strong> (<strong class="bold">AOT</strong>): Clojure compiles all our code on the fly into JVM bytecode. AOT compilation allows us to compile code before we run it. This speeds up application startup. We can see that under the <strong class="source-inline">:profiles</strong> keyword, we have an <strong class="source-inline">uberjar</strong> profile where we want AOT compilation. On the other hand, we would like our <strong class="source-inline">:main</strong> namespace to be without AOT. We create an uberjar with AOT because we want to compile the code before we run it. We do not want AOT for <strong class="source-inline">:main</strong> as we want to defer compilation until we start an application. For example, <strong class="source-inline">:main</strong> can use symbols such as environment settings, parameters that are not available at AOT compilation. They are only available when we start an application. If we compile too fast, the application will not have access to parameters that we passed when we start an application.</li>
				<li><strong class="bold">Profiles</strong>: Leiningen allows us to set up various profiles in our projects. Thanks to profiles, we can customize projects depending on our needs.<p>For example, a development version could require a testing suite and we might want testing dependencies. On the other hand, when creating a production jar, we do not need testing dependencies.</p><p>We will look at Leiningen's profiles at the end of this chapter.</p></li>
			</ul>
			<p>Now that we have looked at <strong class="source-inline">project.clj</strong>, we will see what the <strong class="source-inline">README.md</strong> file has to offer for us.</p>
			<p>A README file is a Markdown file that provides information about our project that we consider important for users to know. Markdown is a markup language that allows us to style documents.</p>
			<p>Typically, a README file will have the following sections:</p>
			<ul>
				<li><strong class="bold">Project name</strong>: Where we put a short description of what the project does</li>
				<li><strong class="bold">Installation</strong>: Where we inform users of the steps necessary to install ourÂ application</li>
				<li><strong class="bold">Usage</strong>: Where we let users know how to use our project</li>
				<li><strong class="bold">Examples</strong>: A section with code samples showing how to use our project</li>
				<li><strong class="bold">Bugs</strong>: Any known bugs</li>
				<li><strong class="bold">Changelog</strong>: Where we document any changes between versions</li>
				<li><strong class="bold">License</strong>: Where we inform users of our project's license type</li>
			</ul>
			<p>Here's a sample README file:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B14502_08_11.jpg" alt="Figure 8.11: Sample README file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: Sample README file</p>
			<p>You can add more sections. It all depends on what you think is important for users ofÂ your project to know. In the next topic, we will modify source files and run our application.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor217"/>Exercise 8.09: Executing the Application on the Command Line</h2>
			<p>The aim of this exercise is to create a Leiningen application and explore how applications are run.</p>
			<p>This will help us understand the different options that Leiningen provides in the <strong class="source-inline">project.clj</strong> file.</p>
			<p>As we will see at the end of this exercise, in order to run our application from the command line, we need to call Leiningen's <strong class="source-inline">run</strong> task. Leiningen's <strong class="source-inline">run</strong> task will search the <strong class="source-inline">project.clj</strong> file for the <strong class="source-inline">:main</strong> keyword and corresponding namespace. </p>
			<p>In our case, the <strong class="source-inline">:main</strong> keyword in <strong class="source-inline">project.clj</strong> will look like this:</p>
			<p class="source-code">:main ^:skip-aot hello-leiningen.core</p>
			<p><strong class="source-inline">^:skip-aot</strong> instructs Leiningen to skip AOT for the namespace that we specify. Here, the namespace is <strong class="source-inline">hello-leiningen.core</strong>. When we explored the <strong class="source-inline">project.clj</strong> file, we talked about why we want to skip AOT for the <strong class="source-inline">:main</strong> namespace.</p>
			<p>By default, Leiningen will search for the namespace that we specified in the <strong class="source-inline">:main</strong> keyword. In our case, it will search for the <strong class="source-inline">hello-leiningen.core</strong> namespace. In this namespace, if we have the <strong class="source-inline">-main</strong> function, it will be called:</p>
			<ol>
				<li value="1">After creating a new project, the content of the <strong class="source-inline">hello-leiningen.core</strong> namespace is the following:<p class="source-code">(ns hello-leiningen.core</p><p class="source-code">Â Â (:gen-class))</p><p class="source-code">(defn -main</p><p class="source-code">Â Â "I don't do a whole lot ... yet."</p><p class="source-code">Â Â [&amp; args]</p><p class="source-code">Â Â (println "Hello, World!"))</p><p>When we create an application using Leiningen, it will autogenerate code in the <strong class="source-inline">core</strong> namespace.<strong class="source-inline"> (:gen-class)</strong> instructs Leiningen to generate a Java class from the namespace. Build tools such as Leiningen execute Java bytecode so we need to compile Clojure to bytecode in order to run the <strong class="source-inline">core</strong> namespace.</p><p>Next, we have the <strong class="source-inline">-main</strong> function. By default, when an application is started, Leiningen will search for a method with that name and execute it. As such, <strong class="source-inline">-main</strong> is an entry point to our application.</p><p>Like all functions in Clojure, <strong class="source-inline">-main</strong> can be supplied with an optional documentation string. Here, it tells us that the function does not do a whole lot... yet. This function takes optional arguments. We can pass arguments when we start an application. Often, applications are started for various environments by passing an environment type, such as test or production, as a command-line argument.</p><p>When Leiningen calls the <strong class="source-inline">-main</strong> function, it will execute the body of this function. In this case, the function will print the string <strong class="source-inline">Hello World!</strong> to the console. </p></li>
				<li>To run the application from the command line, we use Leiningen's <strong class="source-inline">run</strong> task:<p class="source-code">lein run</p><p>This will print the following to the console:</p><p class="source-code">Hello, World!</p></li>
			</ol>
			<p>This exercise showed us how to run a Leiningen application as defined in <strong class="source-inline">project.clj</strong> file.</p>
			<p>In the next exercise we will extend the application to take arguments from the command line.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor218"/>Exercise 8.10: Executing Application on the Command Line with arguments</h2>
			<p>In this exercise we will write a small command line application that takes a string as input, parses that input and replaces the contents of that string.</p>
			<ol>
				<li value="1">After creating a new project, the content of the <strong class="source-inline">hello-leiningen.core</strong> namespace is the following:<p class="source-code">(ns hello-leiningen.core</p><p class="source-code">  (:gen-class))</p><p class="source-code">(defn -main</p><p class="source-code">  "I don't do a whole lot ... yet."</p><p class="source-code">  [&amp; args]</p><p class="source-code">  (println "Hello, World!"))</p></li>
				<li>When we create an application using Leiningen, it will autogenerate code in the core namespace. (<strong class="source-inline">:gen-class</strong>) instructs Leiningen to generate a Java class from the namespace. Build tools such as Leiningen execute Java bytecode so we need to compile Clojure to bytecode in order to run the core namespace.</li>
				<li>Next, we have the <strong class="source-inline">-main</strong> function. By default, when an application is started, Leiningen will search for a method with that name and execute it. As such, -main is an entry point to our application.</li>
				<li>Like all functions in Clojure, <strong class="source-inline">-main</strong> can be supplied with an optional documentation string. Here, it tells us that the function does not do a whole lot... yet. This function takes optional arguments. We can pass arguments when we start an application. Often, applications are started for various environments by passing an environment type, such as test or production, as a command-line argument.</li>
				<li>When Leiningen calls the -main function, it will execute the body of this function. In this case, the function will print the string Hello World! to the console. </li>
				<li>To run the application from the command line, we use Leiningen's run task:<p class="source-code">lein run</p></li>
				<li>This will print the following to the console:<p class="source-code">Hello, World!</p></li>
				<li>Import the <strong class="source-inline">clojure.string</strong>. We want to manipulate strings in our <strong class="source-inline">-main</strong> function. In order to do that we need to import string namespace.<p class="source-code">(ns hello-leiningen.core</p><p class="source-code">  (:require [clojure.string :as str]))</p><p>After importing <strong class="source-inline">clojure.string</strong> namespace we can use functions from this namespace.</p></li>
				<li>Updating <strong class="source-inline">-main</strong> function to replace certain words when the <strong class="source-inline">-main</strong> function is run:<p class="source-code">(defn -main </p><p class="source-code">  "I don't do a whole lot ... yet."</p><p class="source-code">  [&amp; args]</p><p class="source-code">    (-&gt; (str/join " " args)</p><p class="source-code">        (str/replace "melon" "banana")</p><p class="source-code">        (str/replace "apple" "orange")</p><p class="source-code">        println))</p><p>This code will replace words "<strong class="source-inline">melon</strong>" and "<strong class="source-inline">apple</strong>" with other fruits.</p></li>
				<li>We run the application as follows:<p class="source-code">lein run "apple" "melon" "grapes"</p></li>
				<li>This will print the following in the REPL:<p class="source-code">orange banana grapes</p></li>
			</ol>
			<p>We know now how to run an application from the command line and pass arguments. InÂ the following activity, you will use this knowledge to create a new application.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor219"/>Activity 8.02: Summing Up Numbers</h2>
			<p>Often, applications that are created by developers need to run in different environments and business contexts. This requires the applications to be flexible. OneÂ way to achieve this is by using command-line parameters that change how applications behave. </p>
			<p>In this activity, you will create an application that takes integers as input parameters from the command line and sums them up to print the result to the console. Depending on the integers passed, the results will differ. This shows the flexibility of the application.</p>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Create a Leiningen application. </li>
				<li>Alter the <strong class="source-inline">-main</strong> function to convert string arguments to integers, add integers, and print the result.</li>
			</ol>
			<p>The output will look like the following:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B14502_08_12.jpg" alt="Figure 8.12: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 708.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor220"/>Working with External Libraries</h1>
			<p>Libraries are packaged programs that are ready to be used in other projects. External libraries are libraries that come from other developers. In Clojure, examples of such libraries include Ring, an HTTP library; <strong class="source-inline">clojure.java-time</strong>, a library for time and date manipulation; and <strong class="source-inline">hiccup</strong>, a library for writing HTML code using Clojure-style syntax.</p>
			<p>Most projects will require developers to use existing code packaged as libraries. This is a good thing. We do not want to write code over and over again if the problem at hand has been already solved and someone has created a library for it that we can use. </p>
			<p>In this section, we will use the <strong class="source-inline">clojure.Java-time</strong> library to display the current time.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor221"/>Exercise 8.11: Using an External Library in a Leiningen Project</h2>
			<p>The aim of this exercise is to show you how to add a library to a Leiningen project and demonstrate how this library is used in code:</p>
			<ol>
				<li value="1">The first thing to do is add a dependency to the <strong class="source-inline">time</strong> library in the <strong class="source-inline">project.clj</strong> file. The <strong class="source-inline">dependencies</strong> section should look like this:<p class="source-code">:dependencies [[org.clojure/clojure "1.9.0"]</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  [clojure.java-time "0.3.2"]]</p></li>
				<li>The next step is to import the library to our <strong class="source-inline">core</strong> namespace. Alter <strong class="source-inline">hello-leiningen.core</strong> to look like this:<p class="source-code">(ns hello-leiningen.core</p><p class="source-code">Â Â Â Â (:require [java-time :as time]))</p></li>
				<li>Finally, we will change the <strong class="source-inline">-main</strong> function to print the local time using a function from the <strong class="source-inline">clojure.java-time</strong> library:<p class="source-code">(defn -main</p><p class="source-code">Â Â "Display current local time"</p><p class="source-code">Â Â [&amp; args]</p><p class="source-code">Â Â (println (time/local-time)))</p></li>
				<li>We run the application from the command line using the <strong class="source-inline">run</strong> task:<p class="source-code">lein run</p><p>This will show us output similar to the following:</p><p class="source-code">#object[java.time.LocalTime 0x2fa47368 23:37:55.623]</p></li>
			</ol>
			<p>We now know how to add and use external libraries. We are ready to package our application to a jar and run it.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor222"/>Creating and Executing a jar with Leiningen</h2>
			<p>When we discussed project structure in Clojure, we mentioned that projects are packaged as jar files. To remind you, a jar file is a zipped (packed) file that is an executable application. Leiningen has tasks for creating jars.</p>
			<p>Leiningen provides two tasks that can create a jar:</p>
			<ul>
				<li>jar</li>
				<li>uberjar</li>
			</ul>
			<p>Both will create a zipped file with our code. The difference is that a jar task will package only our code while an uberjar task will also package dependencies. If you run one application on your server and want one standalone file, then an uberjar is your go-to option. If you have a number of applications on your server and they share libraries, then packaging each application as a jar will take less space overall than packaging them as uberjars. This is because libraries are shared on servers between your applications.</p>
			<p>If we want to run a jar, we need to generate a named class from our core namespace.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor223"/>Exercise 8.12: Creating a Jar File</h2>
			<p>In this exercise, we will show how to create a jar file using Leiningen tasks:</p>
			<ol>
				<li value="1">Alter the <strong class="source-inline">hello-leiningen.core</strong> namespace declaration to include a <strong class="source-inline">(:gen-class)</strong> function call:<p class="source-code">(ns hello-leiningen.core</p><p class="source-code">Â Â (:require [java-time :as time])</p><p class="source-code">Â Â (:gen-class))</p><p>The <strong class="source-inline">:gen-class</strong> directive is an important concept in Clojure. This directive will generate a Java class corresponding to the target namespace. The result of generating a Java class is a <strong class="source-inline">.class</strong> file. A Java <strong class="source-inline">.class</strong> file contains Java bytecode that can be executed on the JVM. Such a file can be executed by build tools such as Leiningen.</p><p>Running Leiningen tasks for both a jar and uberjar is the same. In our case, we will create an uberjar.</p></li>
				<li>Call Leiningen's <strong class="source-inline">uberjar</strong> task in the command line:<p class="source-code">lein uberjar</p><p>This task will create <strong class="source-inline">hello-leiningen-0.1.0-SNAPSHOT.jar</strong> and <strong class="source-inline">hello-leiningen-0.1.0-SNAPSHOT-standalone.jar</strong> jar files inside the target directory.</p><p>When we compare the files, we will see that their sizes differ greatly:</p><div id="_idContainer099" class="IMG---Figure"><img src="image/B14502_08_13.jpg" alt="Figure 8.13: Comparing the files&#13;&#10;"/></div><p class="figure-caption">Figure 8.13: Comparing the files</p><p>The <strong class="source-inline">hello-leiningen-0.1.0-SNAPSHOT.jar</strong> file is less than 1 MB, while <strong class="source-inline">hello-leiningen-0.1.0-SNAPSHOT-standalone.jar</strong> is 5.2 MB. There is a good reason why the size differs. The standalone version is meant to include all the dependencies necessary for running the jar. We can check what is actually includedÂ in the jar file by listing its content:</p><p class="source-code">jar -tvf target/uberjar/hello-leiningen-0.1.0-SNAPSHOT-standalone.jar</p><p>Running this command will give us the output similar to the following:</p><div id="_idContainer100" class="IMG---Figure"><img src="image/B14502_08_14.jpg" alt="Figure 8.14: Inspecting the standalone version of the file&#13;&#10;"/></div><p class="figure-caption">Figure 8.14: Inspecting the standalone version of the file</p><p>We would notice a <strong class="source-inline">clojure</strong> directory. When inspecting the first file, however, there would be no Clojure directory:</p><div id="_idContainer101" class="IMG---Figure"><img src="image/B14502_08_15.jpg" alt="Figure 8.15: Checking for the Clojure directory&#13;&#10;"/></div><p class="figure-caption">Figure 8.15: Checking for the Clojure directory</p><p>The first jar (<strong class="source-inline">hello-leiningen-0.1.0-SNAPSHOT.jar</strong>) contains only application code, while the second file (<strong class="source-inline">hello-leiningen-0.1.0-SNAPSHOT-standalone.jar</strong>) also contains core Clojure code. The standalone file is intended to be used when we have one Clojure application. In such cases, we want to have all the dependencies in one place. When we run more than one Clojure application on a server, having each application containing core Clojure functions takes more space than needed. In such cases, having core Clojure code once and allowing all applications to access it saves disk space. </p></li>
				<li>In order to run a jar, we will call the following:<p class="source-code">java -jar target/uberjar/hello-leiningen-0.1.0-SNAPSHOT-standalone.jar</p><p>This will display the current local time for us, as follows:</p><div id="_idContainer102" class="IMG---Figure"><img src="image/B14502_08_16.jpg" alt="Figure 8.16: Print the local time&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.16: Print the local time</p>
			<p>In the next section, we will look at Leiningen profilesâ€”a powerful feature that allows us to customize our projects.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor224"/>Leiningen Profiles</h1>
			<p>Profiles are a Leiningen tool that allows us to change the configuration of our projects. A profile is a specification that influences how a project behaves. For example, during development or testing, say that we would like to include testing frameworks in our builds but the production build does not need testing dependencies. Using profiles is a great way to separate different development setups that should be run against one code base. </p>
			<p>Leiningen allows us to define profiles in a few places depending on our needs:</p>
			<ul>
				<li>In the <strong class="source-inline">project.clj</strong> file</li>
				<li>In the <strong class="source-inline">profiles.clj</strong> file</li>
				<li>In the <strong class="source-inline">~/.lein/profiles.clj</strong> file</li>
			</ul>
			<p>Leiningen profiles defined in <strong class="source-inline">project.clj</strong> are specific to that particular project. Such profiles will not affect other projects. This allows separation between projects and the ability to customize them independently. We could have one application that uses the newest version of Clojure and requires different libraries to another application relying on an older Clojure version.</p>
			<p>Leiningen profiles defined in <strong class="source-inline">profiles.clj</strong> are also specific to a project. Such profiles will not affect other projects. The difference between putting a profile in <strong class="source-inline">project.clj</strong> and <strong class="source-inline">profiles.clj</strong> is that profiles in <strong class="source-inline">project.clj</strong> will be committed in version control. Profiles defined in <strong class="source-inline">profiles.clj</strong> are independent of the project configuration in <strong class="source-inline">project.clj</strong> and do not need to be committed to version control. Profiles from both files are merged together by Leiningen. Profiles with the same name in <strong class="source-inline">profiles.clj</strong> take precedence over profiles in <strong class="source-inline">project.clj</strong>.</p>
			<p>Now that we know what Leiningen profiles are and the places that they can be defined, we will look at the syntax of creating profiles. First, we will define a profile in a <strong class="source-inline">project.clj</strong> file.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor225"/>Exercise 8.13: Adding Leiningen Profiles to a Project</h2>
			<p>The aim of this exercise is to add a new development profile inside a <strong class="source-inline">project.clj</strong> file. This will allow us to customize a project for the development phase of the software development life cycle.</p>
			<p>If we wanted to add a dependency on a testing framework, such as <strong class="source-inline">expectations</strong>, we would alter the <strong class="source-inline">project.clj</strong> file to look like this:</p>
			<p class="source-code">(defproject hello-leiningen "0.1.0-SNAPSHOT"</p>
			<p class="source-code"> ;;; skipped irrelevant content</p>
			<p class="source-code">Â Â :profiles {:uberjar {:aot :all}</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  :dev {:dependenc<a id="_idTextAnchor226"/>ies [[expectations "2.1.10"]]}})</p>
			<p>Inside the <strong class="source-inline">:profiles</strong> hash, we have a <strong class="source-inline">:dev</strong> hash with a dependency on the <strong class="source-inline">expectations</strong> framework. With this change, the <strong class="source-inline">dev</strong> profile is available for us. We can check this by listing available profiles:</p>
			<ol>
				<li value="1">Calling Leiningen's <strong class="source-inline">show-profiles</strong> task will display the available profiles:<p class="source-code">lein show-profiles</p><p>The output is as follows:</p><div id="_idContainer103" class="IMG---Figure"><img src="image/B14502_08_17.jpg" alt="Figure 8.17: Printing the available profiles&#13;&#10;"/></div><p class="figure-caption">Figure 8.17: Pr<a id="_idTextAnchor227"/>inting the available profiles</p><p>The profiles available in this example are:</p><p><strong class="source-inline">base</strong>: A profile that provides basic REPL functionality.</p><p><strong class="source-inline">debug</strong>: When Leiningen tasks are run with this profile, they print more information to the console, such as the names of the dependencies used.</p><p><strong class="source-inline">default</strong>: The default profile run when no profiles are selected. Unless overridden, the profile defaults to the <strong class="source-inline">leiningen/default</strong> profile.</p><p><strong class="source-inline">dev</strong>: The development profile as set up in the <strong class="source-inline">project.clj</strong> file by a developer.</p><p><strong class="source-inline">leiningen/default</strong>: The default profile that runs when no profile is selected.</p><p><strong class="source-inline">leiningen/test</strong>: A test profile that runs test files.</p><p><strong class="source-inline">offline</strong>: Profiles where stored dependencies are used offline without downloading new ones.</p><p><strong class="source-inline">uberjar</strong>: Profiles that create uberjar files.</p><p><strong class="source-inline">update</strong>: Profiles that update dependencies.</p><p><strong class="source-inline">user</strong>: A profile defined for a Linux user.</p><p><strong class="source-inline">whidbey/repl</strong>: A p<a id="_idTextAnchor228"/>rofile where results in the REPL are printed in a formatted way.</p><p>As you can see, the <strong class="source-inline">dev</strong> profile is listed among other profiles.</p></li>
				<li>If we wanted to run this profile, we would call the <strong class="source-inline">with-profiles</strong> task:<p class="source-code">lein with-profile<a id="_idTextAnchor229"/> dev test</p><p>Calling this task would run the tests with the <strong class="source-inline">dev</strong> profile. In <em class="italic">Chapter 10</em>, <em class="italic">Testing</em>, we will explore testing in Clojure and this task will be used often.</p></li>
			</ol>
			<p>In this exercise, we have added a new Leiningen profile to the <strong class="source-inline">project.clj</strong> file. This allows us to have a configuration for a particular project. This configuration is independent of configurations in other projects.</p>
			<p>In the next exercise, we will add user-wide profile configuration.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor230"/>User-Wide Profiles</h2>
			<p>Leiningen allows us to define user-wide profiles that will affect all Leiningen projects. This is a great place to put common code that we want for all our projects. The most common examples would be including libraries for testing or pretty printing output. Once we include a testing library in a user-wide profile, that library can be used to write tests for all our projects. This also benefits us when it comes to upgrading the library. We only need to upgrade its version in one place.</p>
			<p>User-wide profiles allow us to add dependencies that we would like to be included in all our projects. One such dependency would be Ultra, which gives developers working in REPL features such as colorization and pretty printing.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor231"/>Exercise 8.14: Using User-Wide Profiles</h2>
			<p>The aim of this exercise is to add a new library to the <strong class="source-inline">profiles.clj</strong> file. This will allow us to access the added library on all Leiningen projects, reducing the need to manually add a dependency every time we create a new project. Additionally, if a new version of the library is available, we need to update only one <strong class="source-inline">profiles.clj</strong> file and the update will be available in all our Leiningen projects.</p>
			<p>If we often work with input that we need to display in a way that's accessible to users, we can use the <strong class="source-inline">humanize</strong> library. This library pluralizes nouns, shows dates in a friendly manner, and converts numbers to strings. </p>
			<p>In order to use the humanize library for all of our projects, we add it to the <strong class="source-inline">:user</strong> keyword in <strong class="source-inline">~/.lein/profiles.clj</strong>:</p>
			<p class="source-code">{:user {:dependencies [[clojure-humanize "0.2.2"]]}}</p>
			<p>Quite often, you will have more libraries and plugins defined in <strong class="source-inline">profiles.clj</strong>. It could look like this with the  <strong class="source-inline">humanize</strong> library and two plugins, <strong class="source-inline">ultra</strong> and <strong class="source-inline">localrepo</strong>:</p>
			<p class="source-code">{:user {:plugins [[lein-localrepo "0.5.4"]</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  [venantius/ultra "0.6.0"]]</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â :dependencies [[clojure-humanize "0.2.2"]]}}</p>
			<ol>
				<li value="1">Start the REPL using Leiningen:<p class="source-code">lein repl</p></li>
				<li>Import the humanize library:<p class="source-code">(require 'clojure.contrib.humanize)</p><p>Although we did not have the <strong class="source-inline">humanize</strong> library in the <strong class="source-inline">project.clj</strong> file, we could import this library:</p><div id="_idContainer104" class="IMG---Figure"><img src="image/B14502_08_18.jpg" alt="Figure 8.18: Importing the humanize library&#13;&#10;"/></div><p class="figure-caption">Figure 8.18: Importing the humanize library</p></li>
				<li>Convert numbers to strings as follows:<p class="source-code">(clojure.contrib.humanize/numberword 4589)</p><p>humanize will convert passed numbers to strings as follows:</p><p class="source-code">"four thousand five hundred and eighty-nine"</p></li>
				<li>Convert the number of milliseconds to time values:<p class="source-code">(clojure.contrib.humanize/duration 500)</p><p>500 milliseconds is not even a second and hence the output will be as follows:</p><p class="source-code">"less than a second"</p><p>This concludes our tour of namespaces in Clojure and Leiningen project structure. In the following activity, we will use our new knowledge of libraries and profiles inÂ Leiningen.</p></li>
			</ol>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor232"/>Useful Clojure Libraries</h2>
			<p>The Clojure ecosystem has a number of great libraries. As we have learned in this chapter, using libraries helps us to create Clojure applications. Libraries provide features that we can use in our code. We do not need to write code ourselves as we can instead reuse code written by others. This saves us time and means we can focus on developing features specific to our application. There are a number of Clojure libraries. Clojure provides a central place to search for available libraries on <a href="https://clojars.org">https://clojars.org</a>. We will learn about two useful Clojure libraries, <strong class="source-inline">cheshire</strong> and <strong class="source-inline">lein-ancient</strong>. The <strong class="source-inline">cheshire</strong> library allows us to work with the JSON format. <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) is a data format from JavaScript. The JSON format defines what data types, such as strings or numbers, are allowed. It is a very popular format. Using a common format allows applications to exchange data. With the <strong class="source-inline">cheshire</strong> library, we can change Clojure data to JSON format and back. This is a very powerful feature. Imagine that we have a holiday-booking application. In the application, we want to display current weather information. There are national services providing such information. The weather services allow the downloading of data in a common JSON format. When we download weather data, we need to turn JSON into Clojure data. The <strong class="source-inline">cheshire</strong> library helps us with data conversion. <strong class="source-inline">lein-ancient</strong> is a useful Leiningen plugin. This plugin allows us to check our Leiningen projects for outdated dependencies. Often, a new version of a library that we use is released. New releases introduce errors or security fixes. Using updated libraries helps our applications to stay secure. In the following activity, we will create a Leiningen project using useful Clojure libraries.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor233"/>Activity 8.03: Building a Format-Converting Application</h2>
			<p>The aim of this activity is to create a Leiningen project that will convert between JSON format and Clojure data. JSON is a popular transfer format often used to send data between various backend applications. Using a common format increases the operability between different applications and reduces the development cost of building and maintaining applications. </p>
			<p>Like most applications used in production, our application will have development and default production profiles. Leiningen profiles will be used to create a testing profile that will use testing libraries to make sure our application is running correctly.</p>
			<p>As our application matures, newer versions of the libraries used will be released. We will use a plugin that will let us know whether any libraries that we use are outdated.</p>
			<p>Once you complete this activity, the application will have the following features:</p>
			<ul>
				<li>Converting between JSON and Clojure data</li>
				<li>A testing profile for checking code before releasing to production</li>
				<li>Checking for outdated libraries</li>
			</ul>
			<p>These steps will help you complete the activity:</p>
			<ol>
				<li value="1">Include the <strong class="source-inline">cheshire</strong> "3.0.0" library as a dependency.</li>
				<li>Create a function to convert from hash to JSON.</li>
				<li>Create a function to convert from JSON to hash.</li>
				<li>Add the <strong class="source-inline">expectations</strong> library to the testing profile defined for the project.</li>
				<li>Add the <strong class="source-inline">lein-expectations</strong> plugin to the project.</li>
				<li>Write a test for the JSON functions.</li>
				<li>Add <strong class="source-inline">lein-ancient</strong> to the user-wide profiles.</li>
			</ol>
			<p>The latest versions of libraries can be found on the <a href="https://clojars.org">https://clojars.org</a> website.</p>
			<p>After creating the application and running it, you should have output similar to the following.</p>
			<p>Converting from hash to JSON format should return the following:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B14502_08_19.jpg" alt="Figure 8.19: Converting from hash to JSON&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.19: Converting from hash to JSON</p>
			<p>Generating JSON from hash should return the following:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B14502_08_20.jpg" alt="Figure 8.20: Generating JSON from hash&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.20: Generating JSON from hash</p>
			<p>Running the testing profile should return the following:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B14502_08_21.jpg" alt="Figure 8.21: Executing the test profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21: Executing the test profile</p>
			<p>Checking for outdated dependencies should return the following:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B14502_08_22.jpg" alt="Figure 8.22: Checking for outdated dependencies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.22: Checking for outdated dependencies</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 709.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor234"/>Summary</h1>
			<p>In this chapter, we learned about namespaces in Clojure. Namespaces are key Clojure concepts. We organize code into namespaces. We investigated various ways in which we can import namespaces in Clojure by using <strong class="source-inline">refer</strong>, <strong class="source-inline">require</strong>, and <strong class="source-inline">use</strong>. With each option to import, we learned the syntax of importing functions and when to use each type of function. We went into depth and investigated the <strong class="source-inline">:only</strong>, <strong class="source-inline">:exlude</strong>, and <strong class="source-inline">:rename</strong> keywords, which help us to fine-tune importing. </p>
			<p>Then, we learned about Leiningenâ€”a popular Clojure build tool. We created a Leiningen application and explored how Clojure projects are structured. We added dependencies on libraries. Finally, we saw how we can customize Leiningen projects using profiles. We created an application that accepted command-line arguments that were used by the application to customize the output.</p>
			<p>In the next chapter, we will investigate host platform interopâ€”accessing Java and JavaScript from Clojure.</p>
		</div>
		<div>
			<div id="_idContainer110" class="Basic-Text-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer111" class="Content">
			</div>
		</div>
	</body></html>