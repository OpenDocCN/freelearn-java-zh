<html><head></head><body>
<div id="_idContainer016">
<h1 class="chapter-number" id="_idParaDest-30"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-31"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.2.1">Using TDD to Create Good Code</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We’ve seen that bad code is bad news: bad for business, bad for users, and bad for developers. </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Test-driven development</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">TDD</span></strong><span class="koboSpan" id="kobo.7.1">) is a core software engineering practice that helps us keep bad code out of </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">our systems.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The goal of this chapter is to learn the specifics of how TDD helps us to create well-engineered, correct code, and how it helps us to keep it that way. </span><span class="koboSpan" id="kobo.9.2">By the end, we will understand the basic principles behind good code and how TDD helps us create it. </span><span class="koboSpan" id="kobo.9.3">It is important for us to understand why TDD works in order to motivate us and so that we have a response to give to colleagues about why we recommend that they use it </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Designing good </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">quality code</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Revealing </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">design flaws</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Preventing </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">logic flaws</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Protecting against </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">future defects</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Documenting </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">our code</span></span></li>
</ul>
<h1 id="_idParaDest-32"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.23.1">Designing good quality code</span></h1>
<p><span class="koboSpan" id="kobo.24.1">Good quality code</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.25.1"> doesn’t happen by accident. </span><span class="koboSpan" id="kobo.25.2">It is intentional. </span><span class="koboSpan" id="kobo.25.3">It is the result of thousands of small decisions, each one shaping how easy our code is to read, test, compose, and change. </span><span class="koboSpan" id="kobo.25.4">We must choose between quick-and-dirty hacks, where we have no idea what edge cases are covered, and more robust approaches, where we are confident that no matter how the user misuses our code, it will work </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">Every line of source code involves at least one of these decisions. </span><span class="koboSpan" id="kobo.27.2">That’s an awful lot of deciding that we have </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">to do.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">You’ll notice that we haven’t mentioned TDD so far. </span><span class="koboSpan" id="kobo.29.2">As we will see, TDD does not design your code for you. </span><span class="koboSpan" id="kobo.29.3">It doesn’t remove that essential engineering sensibility and creative input that is needed to turn requirements into code. </span><span class="koboSpan" id="kobo.29.4">To be honest, I’m grateful for that – it’s the part that </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">I enjoy.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">However, that does cause a lot of early failure with TDD, which is worth noting. </span><span class="koboSpan" id="kobo.31.2">Expecting to </span><em class="italic"><span class="koboSpan" id="kobo.32.1">implement the TDD process</span></em><span class="koboSpan" id="kobo.33.1"> and get good quality code out without your own design input will simply not work. </span><span class="koboSpan" id="kobo.33.2">TDD, as we will see, is a tool that allows you to get rapid feedback on these design decisions. </span><span class="koboSpan" id="kobo.33.3">You can change your mind and adapt while the code is still cheap and quick to change but they are still </span><em class="italic"><span class="koboSpan" id="kobo.34.1">your</span></em><span class="koboSpan" id="kobo.35.1"> design decisions that are </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">playing out.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">So, what is good code? </span><span class="koboSpan" id="kobo.37.2">What are we </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">aiming for?</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Good code, for me, is all about</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.40.1"> readability. </span><span class="koboSpan" id="kobo.40.2">I optimize for clarity. </span><span class="koboSpan" id="kobo.40.3">I want to be kind to my future self and my long-suffering colleagues by engineering code that is clear and safe to work with. </span><span class="koboSpan" id="kobo.40.4">I want to create clear and simple code that is free of </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">hidden traps.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">While there is a huge range of advice on what makes good code, the basics </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">are straightforward:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.44.1">Say what you mean, mean what </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">you say</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Take care of the details </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">in private</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">Avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">accidental complexity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.50.1">It’s worth a quick review</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.51.1"> of what I mean by </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">those things.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.53.1">Say what you mean, mean what you say</span></h2>
<p><span class="koboSpan" id="kobo.54.1">Here’s an interesting</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.55.1"> experiment. </span><span class="koboSpan" id="kobo.55.2">Take a piece of source code (in any language) and strip out everything that is not part of the language specification, then see if you can figure out what it does. </span><span class="koboSpan" id="kobo.55.3">To make things really stand out, we will replace all method names and variable identifiers with the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">symbol </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">???</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Here’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">quick example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.61.1">
public boolean ??? </span><span class="koboSpan" id="kobo.61.2">(int ???) {
    if ( ??? </span><span class="koboSpan" id="kobo.61.3">&gt; ??? </span><span class="koboSpan" id="kobo.61.4">) {
        return ???;
    }
    return ???;
}</span></pre>
<p><span class="koboSpan" id="kobo.62.1">Any ideas what this code does? </span><span class="koboSpan" id="kobo.62.2">No, me neither. </span><span class="koboSpan" id="kobo.62.3">I haven’t </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">a clue.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">I can tell by its shape that it is some kind of </span><em class="italic"><span class="koboSpan" id="kobo.65.1">assessment</span></em><span class="koboSpan" id="kobo.66.1"> method that passes something in and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">true</span></strong><span class="koboSpan" id="kobo.68.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">false</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Maybe it implements a threshold or limit. </span><span class="koboSpan" id="kobo.70.3">It uses a multipath return structure, where we check something, then return an answer as soon as we know what that </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">answer is.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">While the shape</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.73.1"> of the code and the syntax tell us something, it’s not telling us much. </span><span class="koboSpan" id="kobo.73.2">It is definitely not enough. </span><span class="koboSpan" id="kobo.73.3">Nearly all the information we share about what our code does is a result of the natural language identifiers we choose. </span><span class="koboSpan" id="kobo.73.4">Names are absolutely vital to good code. </span><span class="koboSpan" id="kobo.73.5">They are beyond important. </span><span class="koboSpan" id="kobo.73.6">They are everything. </span><span class="koboSpan" id="kobo.73.7">They can reveal intent, explain outcomes, and describe why a piece of data is important to us, but they can’t do any of this if we do a bad job choosing </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">our names.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">I use two guidelines for names, one for naming active code – methods and functions – and one </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">for variables:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.77.1">Method</span></strong><span class="koboSpan" id="kobo.78.1"> – Say what it does. </span><span class="koboSpan" id="kobo.78.2">What</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.79.1"> is the outcome? </span><span class="koboSpan" id="kobo.79.2">Why would I </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">call this?</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">Variable</span></strong><span class="koboSpan" id="kobo.82.1"> – Say what it contains. </span><span class="koboSpan" id="kobo.82.2">Why</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.83.1"> would I </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">access this?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.85.1">A common mistake with method naming is to describe how it works internally, instead of describing what the outcome is. </span><span class="koboSpan" id="kobo.85.2">A method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">addTodoItemToItemQueue</span></strong><span class="koboSpan" id="kobo.87.1"> is committing us to one specific implementation of a method that we don’t really care about. </span><span class="koboSpan" id="kobo.87.2">Either that or it is misinformation. </span><span class="koboSpan" id="kobo.87.3">We can improve the name by calling it </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">add(Todo item)</span></strong><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">This name tells us why exactly we should call this method. </span><span class="koboSpan" id="kobo.89.3">It leaves us free to revise how it is </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">coded later.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The classic mistake with variable names is to say what they are made of. </span><span class="koboSpan" id="kobo.91.2">For example, the variable name </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">String string</span></strong><span class="koboSpan" id="kobo.93.1"> helps nobody, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">String firstName</span></strong><span class="koboSpan" id="kobo.95.1"> tells me clearly that this variable is somebody’s first name. </span><span class="koboSpan" id="kobo.95.2">It tells me why I would want to read or write </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">that variable.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">Perhaps more importantly, it tells us what </span><em class="italic"><span class="koboSpan" id="kobo.98.1">not</span></em><span class="koboSpan" id="kobo.99.1"> to write in that variable. </span><span class="koboSpan" id="kobo.99.2">Having one variable serve multiple purposes in the same scope is a real headache. </span><span class="koboSpan" id="kobo.99.3">Been there, done that, never </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">going back.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">It turns out that code is </span><em class="italic"><span class="koboSpan" id="kobo.102.1">storytelling</span></em><span class="koboSpan" id="kobo.103.1">, pure and simple. </span><span class="koboSpan" id="kobo.103.2">We tell the story</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.104.1"> of what problem we are solving</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.105.1"> and how we have decided to solve it to human programmers. </span><span class="koboSpan" id="kobo.105.2">We can throw any old code into a compiler and the computer will make it work but we must take more care if we want humans to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">our work.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.107.1">Take care of the details in private</span></h2>
<p><span class="koboSpan" id="kobo.108.1">Taking care of the details</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.109.1"> in private is a simple</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.110.1"> way to describe the computer science concepts of </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">abstraction</span></strong><span class="koboSpan" id="kobo.112.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">information hiding</span></strong><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">These are fundamental ideas that allow</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.115.1"> us to break complex systems</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.116.1"> into smaller, </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">simpler parts.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">The way I think about abstraction is the same way I think about hiring an electrician for </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">my house.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">I know that my electric water heater needs to be fixed but I don’t want to know how. </span><span class="koboSpan" id="kobo.120.2">I don’t want to learn how to do it. </span><span class="koboSpan" id="kobo.120.3">I don’t want to have to figure out what tools are needed and buy them. </span><span class="koboSpan" id="kobo.120.4">I want to have nothing whatsoever to do with it, beyond asking that it gets done when I need it done. </span><span class="koboSpan" id="kobo.120.5">So, I’ll call the electrician and ask them to do it. </span><span class="koboSpan" id="kobo.120.6">I’m more than happy to pay for a good job, as long as I don’t have to do </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">it myself.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">This is what abstraction means. </span><span class="koboSpan" id="kobo.122.2">The electrician abstracts the job of fixing my water heater. </span><span class="koboSpan" id="kobo.122.3">Complex stuff gets done in response to my </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">simple requests.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">Abstraction happens everywhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">good software.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Every time you make some kind of detail less important, you have abstracted it. </span><span class="koboSpan" id="kobo.126.2">A method has a simple signature but the code inside it may be complex. </span><span class="koboSpan" id="kobo.126.3">This is an abstraction of an algorithm. </span><span class="koboSpan" id="kobo.126.4">A local variable might be declared as type </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">String</span></strong><span class="koboSpan" id="kobo.128.1">. </span><span class="koboSpan" id="kobo.128.2">This is an abstraction of the memory management of each text character and the character encoding. </span><span class="koboSpan" id="kobo.128.3">A microservice that will send discount vouchers to our top customers who haven’t visited the site</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.129.1"> in a while is an abstraction</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.130.1"> of a business process. </span><span class="koboSpan" id="kobo.130.2">Abstraction</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.131.1"> is everywhere in programming, across all major paradigms – </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.133.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.134.1">OOP</span></strong><span class="koboSpan" id="kobo.135.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">procedural</span></strong><span class="koboSpan" id="kobo.137.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.139.1">functional</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">The idea of splitting software</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.142.1"> into components, each of which takes care of something for us, is a massive</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.143.1"> quality driver. </span><span class="koboSpan" id="kobo.143.2">We centralize decisions, meaning that we don’t make mistakes in duplicated code. </span><span class="koboSpan" id="kobo.143.3">We can test a component thoroughly in isolation. </span><span class="koboSpan" id="kobo.143.4">We </span><em class="italic"><span class="koboSpan" id="kobo.144.1">design out</span></em><span class="koboSpan" id="kobo.145.1"> problems caused by hard-to-write code just by writing it once and having an </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">easy-to-use interface.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.147.1">Avoid accidental complexity</span></h2>
<p><span class="koboSpan" id="kobo.148.1">This is my personal favorite</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.149.1"> destroyer of good code – complex code that simply never needed </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">to exist.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">There are always many ways of writing a piece of code. </span><span class="koboSpan" id="kobo.151.2">Some of them use complicated features or go all around the houses; they use convoluted chains of actions to do a simple thing. </span><span class="koboSpan" id="kobo.151.3">All versions of the code get the same result but some just do it in a more complicated way </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">by accident.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">My goal for code is to tell at first sight the story of what problem I am solving, leaving the details about how I am solving it for closer analysis. </span><span class="koboSpan" id="kobo.153.2">This is quite different from how I learned</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.154.1"> how to code originally. </span><span class="koboSpan" id="kobo.154.2">I choose to emphasize </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">domain</span></strong><span class="koboSpan" id="kobo.156.1"> over </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">mechanism</span></strong><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">The domain here means using the same language as the user, for example, expressing the problem in business terms, not just raw computer code syntax. </span><span class="koboSpan" id="kobo.158.3">If I am writing a banking system, I want to see money, ledgers, and transactions coming to the forefront. </span><span class="koboSpan" id="kobo.158.4">The story the code is telling has to be that </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">of banking.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Implementation details such as message queues and databases are important but only as far as they describe how we are solving the problem today. </span><span class="koboSpan" id="kobo.160.2">They may need to change later. </span><span class="koboSpan" id="kobo.160.3">Whether they change or not, we still want the primary story to be about </span><em class="italic"><span class="koboSpan" id="kobo.161.1">transactions going into an account</span></em><span class="koboSpan" id="kobo.162.1"> and not </span><em class="italic"><span class="koboSpan" id="kobo.163.1">message queues talking to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.164.1">REST services</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">As our code gets better at telling the story of the problem we are solving, we make it easier to write replacement components. </span><span class="koboSpan" id="kobo.166.2">Swapping out a database for another vendor’s product is simplified because we know exactly what purpose it is serving in </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">our system.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">This is what we mean by hiding details. </span><span class="koboSpan" id="kobo.168.2">At some level, it is important to see how we wired up the database, but only after we have seen why we even needed one in the </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">first place.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">To give you a concrete example, here is a piece of code similar to some code that I found in a </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">production system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.172.1">
public boolean isTrue (Boolean b) {
    boolean result = false;
    if ( b == null ) {
        result = false;
    }
    else if ( b.equals(Boolean.TRUE)) {
        result = true;
    }
    else if ( b.equals(Boolean.FALSE)) {
        result = false;
    }
    else {
        result = false;
    }
    return result;
}</span></pre>
<p><span class="koboSpan" id="kobo.173.1">You can see the problem</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.174.1"> here. </span><span class="koboSpan" id="kobo.174.2">Yes, there is a need for a method like this. </span><span class="koboSpan" id="kobo.174.3">It is a low-level mechanism that converts a Java </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">true</span></strong><span class="koboSpan" id="kobo.176.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">false</span></strong><span class="koboSpan" id="kobo.178.1"> object into its equivalent primitive type and does it safely. </span><span class="koboSpan" id="kobo.178.2">It covers all edge cases relating to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">null</span></strong><span class="koboSpan" id="kobo.180.1"> value input, as well as valid </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1"> values.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">However, it has problems. </span><span class="koboSpan" id="kobo.185.2">This code is cluttered. </span><span class="koboSpan" id="kobo.185.3">It is unnecessarily</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.186.1"> hard to read and test. </span><span class="koboSpan" id="kobo.186.2">It has high </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">cyclomatic complexity (CYC)</span></strong><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">CYC is an objective measure of how complex a piece of code is, based on the number of independent execution paths possible in a section </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">The previous code is unnecessarily</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.191.1"> verbose and over-complicated. </span><span class="koboSpan" id="kobo.191.2">I’m pretty sure it has a </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">dead-code path</span></strong><span class="koboSpan" id="kobo.193.1"> – meaning a path containing unreachable code – on that final </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">else</span></strong><span class="koboSpan" id="kobo.195.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Looking at the logic needed, there are only three interesting input conditions: </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">null</span></strong><span class="koboSpan" id="kobo.199.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">true</span></strong><span class="koboSpan" id="kobo.201.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">false</span></strong><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">It certainly does not need all those </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">else/if</span></strong><span class="koboSpan" id="kobo.205.1"> chains to decode that. </span><span class="koboSpan" id="kobo.205.2">Once you’ve got that </span><em class="italic"><span class="koboSpan" id="kobo.206.1">null-to-false</span></em><span class="koboSpan" id="kobo.207.1"> conversion out of the way, you really only need to inspect one value before you can fully decide what </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">to return.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">A better equivalent would be </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
    public boolean isTrue (Boolean b) {
        return Boolean.TRUE.equals(b);
    }</span></pre>
<p><span class="koboSpan" id="kobo.212.1">This code does the same thing with a lot less fuss. </span><span class="koboSpan" id="kobo.212.2">It does not have the same level of accidental complexity as the previous code. </span><span class="koboSpan" id="kobo.212.3">It reads better. </span><span class="koboSpan" id="kobo.212.4">It is easier to test with fewer paths needing testing. </span><span class="koboSpan" id="kobo.212.5">It has a better cyclomatic complexity figure, which means fewer places for bugs to hide. </span><span class="koboSpan" id="kobo.212.6">It tells a better story about why the method exists. </span><span class="koboSpan" id="kobo.212.7">To be perfectly honest, I might even refactor this method by inlining it. </span><span class="koboSpan" id="kobo.212.8">I’m not sure the method adds any worthwhile extra explanation to </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">This method was a simple example. </span><span class="koboSpan" id="kobo.214.2">Just imagine seeing this scaled up to thousands of lines of copy-pasted, slightly-changed code. </span><span class="koboSpan" id="kobo.214.3">You can see why accidental complexity is a killer. </span><span class="koboSpan" id="kobo.214.4">This cruft builds up over time and grows exponentially. </span><span class="koboSpan" id="kobo.214.5">Everything becomes harder to read and harder to </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">safely change.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">Yes, I have seen that. </span><span class="koboSpan" id="kobo.216.2">I will never stop being sad about it when I do. </span><span class="koboSpan" id="kobo.216.3">We can do better than this. </span><span class="koboSpan" id="kobo.216.4">As professional software engineers, we </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">really should.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">This section has been</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.219.1"> a lightning tour of </span><em class="italic"><span class="koboSpan" id="kobo.220.1">good design</span></em><span class="koboSpan" id="kobo.221.1"> fundamentals. </span><span class="koboSpan" id="kobo.221.2">They apply across all styles of programming. </span><span class="koboSpan" id="kobo.221.3">However, if we can do things right, we can also do things wrong. </span><span class="koboSpan" id="kobo.221.4">In the next section, we’ll take a look at how TDD tests can help us prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">bad designs.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.223.1">Revealing design flaws</span></h1>
<p><span class="koboSpan" id="kobo.224.1">Bad design is truly bad. </span><span class="koboSpan" id="kobo.224.2">It is the root cause</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.225.1"> of software being hard to change and hard to work with. </span><span class="koboSpan" id="kobo.225.2">You can never quite be sure whether your changes are going to work because you can never quite be sure what a bad design is really doing. </span><span class="koboSpan" id="kobo.225.3">Changing that kind of code is scary and often gets put off. </span><span class="koboSpan" id="kobo.225.4">Whole sections of code can be left to rot with only a </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">/* Here be dragons! </span><span class="koboSpan" id="kobo.226.2">*/</span></strong><span class="koboSpan" id="kobo.227.1"> comment to show </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">for it.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">The first major benefit of TDD is that it forces us to think about the design of a component. </span><span class="koboSpan" id="kobo.229.2">We do that before we think about how we implement it. </span><span class="koboSpan" id="kobo.229.3">By doing things in this order, we are far less likely to drift into a bad design </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">by mistake.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">The way we consider the design first is to think about the public interfaces of a component. </span><span class="koboSpan" id="kobo.231.2">We think about how that component will be used and how it will be called. </span><span class="koboSpan" id="kobo.231.3">We don’t yet consider how we will make any implementations actually work. </span><span class="koboSpan" id="kobo.231.4">This is </span><em class="italic"><span class="koboSpan" id="kobo.232.1">outside-in</span></em><span class="koboSpan" id="kobo.233.1"> thinking. </span><span class="koboSpan" id="kobo.233.2">We consider the usage of the code from outside callers before we consider any </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">inside implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">This is quite a different approach to take for many of us. </span><span class="koboSpan" id="kobo.235.2">Typically, when we need code to do something, we start by writing the implementation. </span><span class="koboSpan" id="kobo.235.3">After that, we will ripple out whatever is needed in method signatures, without a thought about the call site. </span><span class="koboSpan" id="kobo.235.4">This is </span><em class="italic"><span class="koboSpan" id="kobo.236.1">inside-out</span></em><span class="koboSpan" id="kobo.237.1"> thinking. </span><span class="koboSpan" id="kobo.237.2">It works, of course, but it often leads to complex calling code. </span><span class="koboSpan" id="kobo.237.3">It locks us into implementation details that just </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">aren’t important.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Outside-in thinking means we get to dream up the perfect component for its users. </span><span class="koboSpan" id="kobo.239.2">Then, we will bend the implementation to work with our desired code at the call site. </span><span class="koboSpan" id="kobo.239.3">Ultimately, this is far more important than the implementation. </span><span class="koboSpan" id="kobo.239.4">This is, of course, abstraction being used </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">in practice.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">We can ask questions like </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.243.1">Is it easy to </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">set up?</span></span></li>
<li><span class="koboSpan" id="kobo.245.1">Is it easy to ask it to </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">do something?</span></span></li>
<li><span class="koboSpan" id="kobo.247.1">Is the outcome easy to </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">work with?</span></span></li>
<li><span class="koboSpan" id="kobo.249.1">Is it difficult to use it the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">wrong way?</span></span></li>
<li><span class="koboSpan" id="kobo.251.1">Have we made any incorrect assumptions </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">about it?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.253.1">You can see that by asking the right sort of questions, we’re going to get the right sort </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">of results.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">By writing tests first, we cover all these questions. </span><span class="koboSpan" id="kobo.255.2">We decide upfront how we are going to set up our component, perhaps deciding on a clear constructor signature for an object. </span><span class="koboSpan" id="kobo.255.3">We decide how we are going to make the calling code look and what the call site will be. </span><span class="koboSpan" id="kobo.255.4">We decide how we will consume any results returned or what the effect will be on </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">collaborating components.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">This is the heart of software design. </span><span class="koboSpan" id="kobo.257.2">TDD does not do this for us, nor does it force us to do a good job. </span><span class="koboSpan" id="kobo.257.3">We could still come up with terrible answers for all those questions and simply write a test to lock those poor answers into place. </span><span class="koboSpan" id="kobo.257.4">I’ve seen that happen on numerous occasions in real code </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">TDD provides that early opportunity to reflect on our decisions. </span><span class="koboSpan" id="kobo.259.2">We are literally writing the first example of a working, executable call site for our code before we even think about how it will work. </span><span class="koboSpan" id="kobo.259.3">We are totally focused on how this new component is going to fit into the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">bigger picture.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">The test itself provides</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.262.1"> immediate feedback on how well our decisions have worked out. </span><span class="koboSpan" id="kobo.262.2">It gives three tell-tale signals that we could and should improve. </span><span class="koboSpan" id="kobo.262.3">We’ll save the details for a later chapter but the test code itself clearly shows when your component is either hard to set up, hard to call, or its outputs are hard to </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">work with.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.264.1">Analyzing the benefits of writing tests before production code</span></h2>
<p><span class="koboSpan" id="kobo.265.1">There are three</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.266.1"> times you can choose</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.267.1"> to write tests: before the code, after the code, </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">or never.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Obviously, never writing any tests sends us back to the dark ages of development. </span><span class="koboSpan" id="kobo.269.2">We’re winging it. </span><span class="koboSpan" id="kobo.269.3">We write code assuming it will work, then leave it all to a manual test stage later. </span><span class="koboSpan" id="kobo.269.4">If we’re lucky, we will discover functional errors at this stage, before our </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">customers do.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">Writing tests just after we complete a small chunk of code is a much better option. </span><span class="koboSpan" id="kobo.271.2">We get much faster feedback. </span><span class="koboSpan" id="kobo.271.3">Our code isn’t necessarily any better though, because we write with the same mindset as we do without the implementation of tests. </span><span class="koboSpan" id="kobo.271.4">The same kinds of functional errors will be present. </span><span class="koboSpan" id="kobo.271.5">The good news is that we will then write tests to </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">uncover them.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">This is a big improvement, but it still isn’t the gold</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.274.1"> standard, as it leads</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.275.1"> to a couple of </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">subtle problems:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.277.1">Missing tests</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.278.1">Leaky abstractions</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.279.1">Missing tests – undetected errors</span></h3>
<p><span class="koboSpan" id="kobo.280.1">Missing tests</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.281.1"> happen because of human nature. </span><span class="koboSpan" id="kobo.281.2">When we are busy writing code, we are juggling many ideas in our heads at once. </span><span class="koboSpan" id="kobo.281.3">We focus on specific details at the expense of others. </span><span class="koboSpan" id="kobo.281.4">I always find that I mentally </span><em class="italic"><span class="koboSpan" id="kobo.282.1">move on</span></em><span class="koboSpan" id="kobo.283.1"> a bit too quickly after a line of code. </span><span class="koboSpan" id="kobo.283.2">I just assume that it’s going to be okay. </span><span class="koboSpan" id="kobo.283.3">Unfortunately, when I come to write my tests, that means I’ve forgotten some </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">key points.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Suppose I end up writing some code </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
public boolean isAllowed18PlusProducts( Integer age ) {
    return (age != null)  &amp;&amp; age.intValue() &gt; 18;
}</span></pre>
<p><span class="koboSpan" id="kobo.288.1">I’ll probably have quickly started with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">&gt; 18</span></strong><span class="koboSpan" id="kobo.290.1"> check, then </span><em class="italic"><span class="koboSpan" id="kobo.291.1">moved on</span></em><span class="koboSpan" id="kobo.292.1"> mentally and remembered that the age could be </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">null</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">I will have added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">And</span></strong><span class="koboSpan" id="kobo.296.1"> clause to check whether it is or not. </span><span class="koboSpan" id="kobo.296.2">That makes sense. </span><span class="koboSpan" id="kobo.296.3">My experience tells me that this particular snippet of code needs to do more than be a basic, </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">robust check.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">When I write my test, I’ll remember to write a test for what happens when I pass in </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">null</span></strong><span class="koboSpan" id="kobo.300.1">, as that is fresh in my mind. </span><span class="koboSpan" id="kobo.300.2">Then, I will write another test for what happens with a higher age, say </span><em class="italic"><span class="koboSpan" id="kobo.301.1">21</span></em><span class="koboSpan" id="kobo.302.1">. </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">Again, good.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">Chances are that I will forget about writing a test for the edge case of an age value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">18</span></strong><span class="koboSpan" id="kobo.306.1">. </span><span class="koboSpan" id="kobo.306.2">That’s really important here but my mind has moved on from that detail already. </span><span class="koboSpan" id="kobo.306.3">All it will take is one Slack message from a colleague about what’s for lunch, and I will most likely forget all about that test and start coding the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">next method.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">The preceding code has a subtle bug in it. </span><span class="koboSpan" id="kobo.308.2">It is supposed to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">true</span></strong><span class="koboSpan" id="kobo.310.1"> for any age that is </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">18</span></strong><span class="koboSpan" id="kobo.312.1"> or above. </span><span class="koboSpan" id="kobo.312.2">It doesn’t. </span><span class="koboSpan" id="kobo.312.3">It returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">true</span></strong><span class="koboSpan" id="kobo.314.1"> only for </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">19</span></strong><span class="koboSpan" id="kobo.316.1"> and above. </span><span class="koboSpan" id="kobo.316.2">The greater-than symbol should have been a greater-than-or-equal-to symbol but I missed </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">this detail.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">Not only did I miss the nuance in the code but I missed out a vital test. </span><span class="koboSpan" id="kobo.318.2">I wrote two important tests but I </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">needed three.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">Because I wrote the other tests, I get no warning at all about this. </span><span class="koboSpan" id="kobo.320.2">You don’t get a failing test that you </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">haven’t written.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">We can avoid this by writing</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.323.1"> a failing test for every piece of code, then adding only enough code to make that test pass. </span><span class="koboSpan" id="kobo.323.2">That workflow would have been more likely to steer us toward thinking through the four tests needed to drive out </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">null</span></strong><span class="koboSpan" id="kobo.325.1"> handling and the three boundary cases relating to age. </span><span class="koboSpan" id="kobo.325.2">It cannot guarantee it, of course, but it can drive the right kind </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">of thinking.</span></span></p>
<h3><span class="koboSpan" id="kobo.327.1">Leaky abstractions – exposing irrelevant details</span></h3>
<p><span class="koboSpan" id="kobo.328.1">Leaky abstractions</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.329.1"> are a different</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.330.1"> problem. </span><span class="koboSpan" id="kobo.330.2">This is where we focus so much on the inside of the method that we forget to think about our </span><em class="italic"><span class="koboSpan" id="kobo.331.1">dream call site</span></em><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">We just ripple out whatever is easiest </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">to code.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">We might be writing an interface where we store </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">UserProfile</span></strong><span class="koboSpan" id="kobo.336.1"> objects. </span><span class="koboSpan" id="kobo.336.2">We might proceed code-first, pick ourselves a </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">JDBC</span></strong><span class="koboSpan" id="kobo.338.1"> library that we like, code up the method, then find that it needs a </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">database connection.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">We might simply add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">Connection</span></strong><span class="koboSpan" id="kobo.342.1"> parameter to </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">fix that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
interface StoredUserProfiles {
    UserProfile load( Connection conn, int userId );
}</span></pre>
<p><span class="koboSpan" id="kobo.345.1">At first sight, there’s nothing much wrong with it. </span><span class="koboSpan" id="kobo.345.2">However, look at that first parameter: it’s the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">JDBC</span></strong><span class="koboSpan" id="kobo.347.1">-specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Connection</span></strong><span class="koboSpan" id="kobo.349.1"> object. </span><span class="koboSpan" id="kobo.349.2">We have locked our interface into having to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">JDBC</span></strong><span class="koboSpan" id="kobo.351.1">. </span><span class="koboSpan" id="kobo.351.2">Or at the very least, having to supply some </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">JDBC</span></strong><span class="koboSpan" id="kobo.353.1">-related thing as a first parameter. </span><span class="koboSpan" id="kobo.353.2">We didn’t even mean to do that. </span><span class="koboSpan" id="kobo.353.3">We simply hadn’t thought about </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">it thoroughly.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">If we think about the ideal abstraction, it should load the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">UserProfile</span></strong><span class="koboSpan" id="kobo.357.1"> object for the given </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">userId</span></strong><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">It should </span><em class="italic"><span class="koboSpan" id="kobo.360.1">not</span></em><span class="koboSpan" id="kobo.361.1"> know how it is stored. </span><span class="koboSpan" id="kobo.361.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">JDBC</span></strong><span class="koboSpan" id="kobo.363.1">-specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Connection</span></strong><span class="koboSpan" id="kobo.365.1"> parameter should not </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">be there.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">If we think outside-in and consider the design before the implementation, we are less likely to go down </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">this route.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">Leaky abstractions like this create accidental complexity. </span><span class="koboSpan" id="kobo.369.2">They make code harder to understand by forcing future readers to wonder why we are insisting on </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">JDBC</span></strong><span class="koboSpan" id="kobo.371.1"> use when we never meant to do so. </span><span class="koboSpan" id="kobo.371.2">We just forgot to design </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">it out.</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">Writing tests first helps prevent this. </span><span class="koboSpan" id="kobo.373.2">It leads us to think about the ideal abstractions as a first step so we can write the test </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">for them.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">Once we have that test coded up, we have locked in our decision on how the code will be used. </span><span class="koboSpan" id="kobo.375.2">Then, we can figure out how to implement that without any unwanted details </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">leaking out.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">The previously explained</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.378.1"> techniques are simple but cover most of the basics</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.379.1"> of good design. </span><span class="koboSpan" id="kobo.379.2">Use clear names. </span><span class="koboSpan" id="kobo.379.3">Use simple logic. </span><span class="koboSpan" id="kobo.379.4">Use abstraction to hide implementation details, so that we emphasize what problem we are solving, rather than how we are solving it. </span><span class="koboSpan" id="kobo.379.5">In the next section, let’s review the most obvious benefit of TDD: preventing flaws in </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">our logic.</span></span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.381.1">Preventing logic flaws</span></h1>
<p><span class="koboSpan" id="kobo.382.1">The idea of logic errors</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.383.1"> is perhaps what everybody thinks of first when we talk about testing: </span><em class="italic"><span class="koboSpan" id="kobo.384.1">did it </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.385.1">work right?</span></em></span></p>
<p><span class="koboSpan" id="kobo.386.1">I can’t disagree here – this is really important. </span><span class="koboSpan" id="kobo.386.2">As far as users, revenues, our Net Promoter Score®™, and market growth go, if your code doesn’t work right, it doesn’t sell. </span><span class="koboSpan" id="kobo.386.3">It’s </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">that simple.</span></span></p>
<h3><span class="koboSpan" id="kobo.388.1">Understanding the limits of manual testing</span></h3>
<p><span class="koboSpan" id="kobo.389.1">We know</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.390.1"> from bitter experience</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.391.1"> that the simplest logic flaws are often the easiest to create. </span><span class="koboSpan" id="kobo.391.2">The examples that we can all relate to are those one-off errors, that </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">NullPointerException</span></strong><span class="koboSpan" id="kobo.393.1"> from an uninitialized variable, and that exception thrown by a library that wasn’t in the documentation. </span><span class="koboSpan" id="kobo.393.2">They are all so simple and small. </span><span class="koboSpan" id="kobo.393.3">It seems like it would be so obvious for us to realize that we were making these mistakes, yet we all know they are often the hardest to spot. </span><span class="koboSpan" id="kobo.393.4">When we humans concentrate on the big picture of our code, sometimes these critical details just </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">go unnoticed.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">We know that manual testing </span><em class="italic"><span class="koboSpan" id="kobo.396.1">can</span></em><span class="koboSpan" id="kobo.397.1"> reveal these logic flaws but we also know from experience that manual test plans are fragile. </span><span class="koboSpan" id="kobo.397.2">It is possible to miss steps out or rush and miss important errors. </span><span class="koboSpan" id="kobo.397.3">We might simply assume that something does not need testing on this release </span><em class="italic"><span class="koboSpan" id="kobo.398.1">because we did not change that section of code</span></em><span class="koboSpan" id="kobo.399.1">. </span><span class="koboSpan" id="kobo.399.2">You guessed it – that doesn’t always work out so well for us. </span><span class="koboSpan" id="kobo.399.3">Bugs can arise in sections of code that seem totally unrelated to the bug if some underlying assumption </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">has changed.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">Manual testing costs money, which is money that can now not be spent on adding shiny new </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">features instead.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">Manual testing also gets blamed for delaying ship dates. </span><span class="koboSpan" id="kobo.403.2">Now, this is spectacularly unfair to our manual test colleagues. </span><span class="koboSpan" id="kobo.403.3">The development team – obviously writing code without TDD tests – stumble over their own bugs until there are only a couple of days left to ship. </span><span class="koboSpan" id="kobo.403.4">Then, we hand over the code to the testers, who have to run a huge test document in next to no time. </span><span class="koboSpan" id="kobo.403.5">They sometimes get blamed for </span><em class="italic"><span class="koboSpan" id="kobo.404.1">delaying the release</span></em><span class="koboSpan" id="kobo.405.1">, even though the real cause was development taking longer than </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">it should.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Yet, we never truly had a release. </span><span class="koboSpan" id="kobo.407.2">If we define a release as including tested code, which we should, then it is clear that the necessary testing never happened. </span><span class="koboSpan" id="kobo.407.3">You can’t ethically release code when you don’t even know whether it works. </span><span class="koboSpan" id="kobo.407.4">If you do, your users will be quick </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">to complain.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">It’s no wonder some</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.410.1"> of my testing colleagues get so grumpy</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.411.1"> by the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">a sprint.</span></span></p>
<h3><span class="koboSpan" id="kobo.413.1">Solving problems by automating the tests</span></h3>
<p><span class="koboSpan" id="kobo.414.1">TDD has</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.415.1"> this totally covered. </span><span class="koboSpan" id="kobo.415.2">These logic errors simply</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.416.1"> cannot arise, which sounds like fantasy, but it really </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">is true.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">Before you type any production code, you have already written a failing test. </span><span class="koboSpan" id="kobo.418.2">Once you add your new code, you rerun the test. </span><span class="koboSpan" id="kobo.418.3">If you somehow typed in a logic error, the test still fails and you know about it </span><em class="italic"><span class="koboSpan" id="kobo.419.1">right away</span></em><span class="koboSpan" id="kobo.420.1">. </span><span class="koboSpan" id="kobo.420.2">That’s the magic here: your mistake happens but is highlighted right away. </span><span class="koboSpan" id="kobo.420.3">This enables you to fix it when it is fresh in your mind. </span><span class="koboSpan" id="kobo.420.4">It also means you cannot forget about fixing it </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">later on.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">You can often go to the exact line that’s wrong and make the change. </span><span class="koboSpan" id="kobo.422.2">It’s 10 seconds of work, not months of waiting for a test silo to get to work and fill out a </span><em class="italic"><span class="koboSpan" id="kobo.423.1">JIRA</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.424.1">bug ticket.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">The kinds of unit tests we are talking about are also fast to run – very fast. </span><span class="koboSpan" id="kobo.425.2">Many of them run within a millisecond. </span><span class="koboSpan" id="kobo.425.3">Compare that to the total time to write a test plan document, run</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.426.1"> the whole app, set up stored data, operate the </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">user interface</span></strong><span class="koboSpan" id="kobo.428.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.429.1">UI</span></strong><span class="koboSpan" id="kobo.430.1">), record output, then write up a bug ticket. </span><span class="koboSpan" id="kobo.430.2">It is incomparably better, </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">isn’t it?</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">You can see how this is a bug-squashing superpower. </span><span class="koboSpan" id="kobo.432.2">We are making significant time savings within the code-test-debug cycle. </span><span class="koboSpan" id="kobo.432.3">This reduces development costs and increases delivery velocity. </span><span class="koboSpan" id="kobo.432.4">These are big wins for our team and </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">our users.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">Every time you write a test before code, you have kept bugs out of that code. </span><span class="koboSpan" id="kobo.434.2">You follow the most basic rule that you do not check code with failing tests. </span><span class="koboSpan" id="kobo.434.3">You make </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">them pass.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">It shouldn’t need saying but you also don’t cheat around that failing test by deleting it, ignoring it, or making it </span><em class="italic"><span class="koboSpan" id="kobo.437.1">always pass</span></em><span class="koboSpan" id="kobo.438.1"> by using some technical hack. </span><span class="koboSpan" id="kobo.438.2">However, I am saying all this because I have seen exactly that done in </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">real code.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">We’ve seen how writing tests</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.441.1"> first helps prevent adding bugs</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.442.1"> in our new code but TDD is even better than that: it helps prevent adding bugs in code that we will add </span><em class="italic"><span class="koboSpan" id="kobo.443.1">in the future</span></em><span class="koboSpan" id="kobo.444.1">, which we will cover in the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">next section.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.446.1">Protecting against future defects</span></h1>
<p><span class="koboSpan" id="kobo.447.1">As we grow our code by writing</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.448.1"> tests first, we could always simply delete each test after it has passed. </span><span class="koboSpan" id="kobo.448.2">I’ve seen some students do that when I’ve taught them TDD because I hadn’t explained that we shouldn’t do that yet. </span><span class="koboSpan" id="kobo.448.3">Regardless, we don’t delete tests once they pass. </span><span class="koboSpan" id="kobo.448.4">We keep </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">them all.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">Tests grow into large regression suites, automatically testing every feature of the code we have built. </span><span class="koboSpan" id="kobo.450.2">By frequently running all the tests, we gain safety and confidence in the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">As team members add features to this code base, keeping all the tests passing shows that nobody has accidentally broken something. </span><span class="koboSpan" id="kobo.452.2">It is quite possible in software to add a perfectly innocent change somewhere, only to find that some seemingly unrelated thing has now stopped working. </span><span class="koboSpan" id="kobo.452.3">This will be because of the relationship between those two pieces that we previously did </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">not understand.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">The tests have now caused us to learn more about our system and our assumptions. </span><span class="koboSpan" id="kobo.454.2">They have prevented a defect from being written into the code base. </span><span class="koboSpan" id="kobo.454.3">These are both great benefits but the bigger picture is that our team has the confidence to make changes safely and know they have tests automatically looking </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">after them.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">This is true agility, the freedom to change. </span><span class="koboSpan" id="kobo.456.2">Agility was never about JIRA tickets and sprints. </span><span class="koboSpan" id="kobo.456.3">It was always about the ability to move quickly, with confidence, through an ever-changing landscape of requirements. </span><span class="koboSpan" id="kobo.456.4">Having tens of thousands of fast-running automated tests is probably the biggest enabling practice </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">we have.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">The ability of tests to give team members confidence to work quickly and effectively is a huge benefit of TDD. </span><span class="koboSpan" id="kobo.458.2">You may have heard the phrase </span><em class="italic"><span class="koboSpan" id="kobo.459.1">move fast and break things</span></em><span class="koboSpan" id="kobo.460.1">, famous from the early days of Facebook. </span><span class="koboSpan" id="kobo.460.2">TDD allows us to move fast and </span><em class="italic"><span class="koboSpan" id="kobo.461.1">not</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.462.1">break things.</span></span></p>
<p><span class="koboSpan" id="kobo.463.1">As we’ve seen, tests are great at providing fast feedback on design and logic correctness, as well as providing</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.464.1"> a defense against future bugs, but one huge extra benefit is that tests document </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">our code.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.466.1">Documenting our code</span></h1>
<p><span class="koboSpan" id="kobo.467.1">Everybody likes helpful, clear</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.468.1"> documentation, but not when it is out of date and unrelated to the current </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">There is a general principle in software that the more separation there is between two related ideas, the more pain they will bring. </span><span class="koboSpan" id="kobo.470.2">As an example, think of some code that reads some obscure file format that nobody remembers. </span><span class="koboSpan" id="kobo.470.3">All works well, so long as you are reading files in that old format. </span><span class="koboSpan" id="kobo.470.4">Then you upgrade the application, that old file format is no longer supported, and everything breaks. </span><span class="koboSpan" id="kobo.470.5">The code was separated from the data content in those old files. </span><span class="koboSpan" id="kobo.470.6">The files didn’t change but the code did. </span><span class="koboSpan" id="kobo.470.7">We didn’t even realize what was </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">going on.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">It’s the same with documentation. </span><span class="koboSpan" id="kobo.472.2">The worst documentation is often contained in the glossiest productions. </span><span class="koboSpan" id="kobo.472.3">These are artifacts written a long time after the code was created by teams with separate skillsets – copywriting, graphic design, and so on. </span><span class="koboSpan" id="kobo.472.4">Documentation updates are the first thing to get dropped from a release when time </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">gets tight.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">The solution is to bring documentation closer to the code. </span><span class="koboSpan" id="kobo.474.2">Get it produced by people closer to the code who know how it works in detail. </span><span class="koboSpan" id="kobo.474.3">Get it read by people who need to work directly with </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">that code.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">As with all other aspects of </span><strong class="bold"><span class="koboSpan" id="kobo.477.1">Extreme Programming (XP)</span></strong><span class="koboSpan" id="kobo.478.1">, the most obvious major win is to make it so close</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.479.1"> to the code that it is the code. </span><span class="koboSpan" id="kobo.479.2">Part of this involves using our good design fundamentals to write clear code and our test suite also plays a </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">key role.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">Our TDD tests are code, not manual test documents. </span><span class="koboSpan" id="kobo.481.2">They are usually written in the same language and repo as the main code base. </span><span class="koboSpan" id="kobo.481.3">They will be written by the same people who are writing the production code – </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">the developers.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">The tests are executable. </span><span class="koboSpan" id="kobo.483.2">As a form of documentation, you know that something that can run has to be up to date. </span><span class="koboSpan" id="kobo.483.3">Otherwise, the compiler will complain, and the code will </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">not run.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">Tests also form the perfect example of how to use our production code. </span><span class="koboSpan" id="kobo.485.2">They clearly define how it should be set up, what dependencies it has, what its interesting methods and functions are, what its expected effects are, and how it will report errors. </span><span class="koboSpan" id="kobo.485.3">Everything you would want to know about that code is in </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">the tests.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">It may be surprising at first. </span><span class="koboSpan" id="kobo.487.2">Testing</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.488.1"> and documentation are not normally confused with each other. </span><span class="koboSpan" id="kobo.488.2">Because of how TDD works, there is a huge overlap between the two. </span><span class="koboSpan" id="kobo.488.3">Our test is a detailed description of what our code should do and how we can make it do that </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">for us.</span></span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.490.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.491.1">In this chapter, we’ve learned that TDD helps us create good designs, write correct logic, prevent future defects, and provide executable documentation for our code. </span><span class="koboSpan" id="kobo.491.2">Understanding what TDD will do for our projects is important to use it effectively and to persuade our teams to use it as well. </span><span class="koboSpan" id="kobo.491.3">There are many advantages to TDD and yet it is not used as often as it should be in </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">real-world projects.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">In the next chapter, we will look into some common objections to TDD, learn why they are not valid, and how we can help our colleagues </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">overcome them.</span></span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.495.1"> Questions and answers </span></h1>
<ol>
<li><span class="koboSpan" id="kobo.496.1">What is the connection between testing and </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">clean code?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.498.1">There is not a direct one, which is why we need to understand how to write clean code. </span><span class="koboSpan" id="kobo.498.2">How TDD adds value is that it forces us to think about how our code will be used before we write it and when it is easiest to clean up. </span><span class="koboSpan" id="kobo.498.3">It also allows us to refactor our code, changing its structure without changing its function, with certainty that we have not broken </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">that function.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.500.1">Can tests </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">replace documentation?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.502.1">Well-written tests replace some but not all documentation. </span><span class="koboSpan" id="kobo.502.2">They become a detailed and up-to-date executable specification for our code. </span><span class="koboSpan" id="kobo.502.3">What they cannot replace are documents such as user manuals, operations manuals, or contractual specifications for public </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">application programming </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.504.1">interfaces</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.505.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.506.1">APIs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">).</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.508.1">What are the problems with writing production code </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">before tests?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.510.1">If we write production code first, then add tests later, we are more likely to face the </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">following problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.512.1">Missing broken edge cases </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">on conditionals</span></span></li>
<li><span class="koboSpan" id="kobo.514.1">Leaking implementation details </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">through interfaces</span></span></li>
<li><span class="koboSpan" id="kobo.516.1">Forgetting </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">important tests</span></span></li>
<li><span class="koboSpan" id="kobo.518.1">Having untested </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">execution paths</span></span></li>
<li><span class="koboSpan" id="kobo.520.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">difficult-to-use code</span></span></li>
<li><span class="koboSpan" id="kobo.522.1">Forcing more rework when design flaws are revealed later in </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">the process</span></span></li>
</ul>
<h1 id="_idParaDest-43"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.524.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.525.1">A formal definition of cyclomatic complexity can be found in the WikiPedia link. </span><span class="koboSpan" id="kobo.525.2">Basically, every conditional statement adds to the complexity, as it creates a new possible </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">execution path:</span></span></p>
<p><a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity"><span class="No-Break"><span class="koboSpan" id="kobo.527.1">https://en.wikipedia.org/wiki/Cyclomatic_complexity</span></span></a></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer017">
</div>
</div>
</body></html>