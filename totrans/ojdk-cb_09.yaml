- en: Chapter 9. Testing OpenJDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running tests using the downloaded or the built version of jtreg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building jtreg from the source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the standard set of OpenJDK tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own test for jtreg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using jtreg in GUI mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing TestNG tests for jtreg
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling JT Harness from the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running jcstress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests for jcstress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a benchmark project using JMH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading the source and compiling JMH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in 1997, when JDK 1.1 was completed and JDK 1.2 had just started, there
    was an obvious problem—JDK had to be tested somehow and there had to be a tool
    for it. This is the moment when **jtreg** appeared as the regression test harness.
    At that time, there were not many testing frameworks for Java. In fact, there
    was not even much software written in Java. So choices were very limited and the
    only reasonable option was the framework that was being used at that time for
    the **Java Compatibility Kit** (**JCK**). Its name was **JavaTest**. But, as JCK
    tests were very different from what a JDK regression test is supposed to do, the
    framework required some adaptation and that is when jtreg appeared. At the moment,
    even though many years have passed since 1997, jtreg still remains the primary
    tool for running unit and regression tests in OpenJDK. Since its introduction
    in OpenJDK, more than 10,000 tests have been created that run using the jtreg
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: As a testing tool, jtreg might look a little unusual for modern developers who
    are used to tools such as jUnit and TestNG. The main reason jtreg looks different
    is because it has a long history. It appeared before jUnit in 1997, which appeared
    sometime around 2000\. At that time, especially when technology was so young,
    three years was a long period. It seems possible that the other contributing factor
    was that jtreg for a long time remained a proprietary tool and, as it was doing
    its job, there was no need to change it. Also, it was not open to the wide open
    source community, who could have changed its shape over time. The other reason
    that contributes to its difference when compared to the current *classical* tools
    is that it provides some special features that are not usually available in testing
    frameworks, but are required to do testing on JDK. These features include running
    a test in a separate instance (or for some tests, even several instances) of JVM
    with a specific set of parameters, testing Java applets (remember them?), running
    shell scripts as tests, running GUI tests which require user interaction, and
    so on. This is a pretty big set of additional features, which is enough to justify
    building a separate framework for it.
  prefs: []
  type: TYPE_NORMAL
- en: Having said all that, it would not be fair to say that jtreg is some old-fashioned
    tool that is stuck in the 1990s and does not attempt to change itself to be closer
    to the modern way of building frameworks for software testing. It has been integrated
    with testing frameworks such as **TestNG** and provides a way to create tests
    that are based on that framework. However, the majority of tests in JDK are still
    just classes with a main method that are executed by the framework. Though, to
    be fair, such an approach has its benefits since it allows one to run individual
    tests without any framework. There are also some tests that are just batch files
    and there is an ongoing effort to get rid of them.
  prefs: []
  type: TYPE_NORMAL
- en: As a tool that evolved from JavaTest, jtreg inherited compatibility with its
    framework. This compatibility has been now isolated into a separate project called
    **Java Test Harness** (**JT Harness**). This is a framework for running, building,
    and deploying tests suites. It also provides a GUI to manage and execute the test
    suites.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn enough to be a confident jtreg user and know
    how to use JT Harness. You will find out how to build jtreg and JT Harness from
    the source code, how to run tests, and how to write your own tests. The chapter
    covers only plain Java and TestNG tests, as they are the most useful ones for
    OpenJDK developers. This chapter does not cover the usage of shell tests, as their
    usage is not considered a good practice and they were created to work around JVM
    limitations that existed a few years back. At the current moment, all OpenJDK
    contributors are encouraged to replace the shell tests with the Java version,
    wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests using the downloaded or the built version of jtreg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to get started with jtreg is to just download it, unpack it,
    and run some tests. In this recipe, we will do exactly that, without doing any
    additional things such as building it from the source code or trying to create
    our own tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, nothing much is really required—just the Internet connection,
    a machine with an installed or built OpenJDK, and the OpenJDK source code. In
    a Windows environment, Cygwin has to be installed in your machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are a few simple steps to get a set of tests executed by jtreg:'
  prefs: []
  type: TYPE_NORMAL
- en: If jtreg is not yet available on the machine, go to the official page of jtreg
    ([https://adopt-openjdk.ci.cloudbees.com/job/jtreg/lastSuccessfulBuild/artifact/](https://adopt-openjdk.ci.cloudbees.com/job/jtreg/lastSuccessfulBuild/artifact/))
    and download the latest available version of jtreg. The other option is to build
    it from the source code. To do this, follow the instructions in the *Building
    Jtreg from the source* recipe that is covered later in this chapter. After you
    have either downloaded jtreg or built it using the source code, proceed to the
    next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unpack the downloaded archive to a folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the root folder of the OpenJDK source tree, create a shell script with the
    name, `run_test.sh`. This script will be used to run jtreg:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only thing here that needs to be changed is the `JT_JAVA` environment variable
    that has to point to the version of OpenJDK that is higher or equal to 1.5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After running the script, you will see the output as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the test, run the HTML report that is generated by jtreg. This is available
    in the folder specified by the `-r` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the shell script that is used to run jtreg is simple and there
    are only a few points that need to be clarified. These are the `JT_JAVA` environment
    variables and the command line arguments of jtreg.
  prefs: []
  type: TYPE_NORMAL
- en: '`JT_JAVA` is one of the two environment variables used by the jtreg shell script.
    `JT_JAVA` specifies the version of Java that will be used to run the framework,
    but not the tests. In this recipe, for the sake of simplicity, we used the same
    version of Java to run jtreg and the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The jtreg command line arguments are all described in detail on the jtreg webpage
    ([http://openjdk.java.net/jtreg/command-help.html](http://openjdk.java.net/jtreg/command-help.html)),
    so we will cover just a few of them that are used in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-jdk`: This argument will generate the JDK that will be used to run tests.
    Basically, it is the version of Java which is tested by the test run. In our example,
    we used the version that was installed on the machine. If you want to use the
    version that was built from the source, the variable should be changed appropriately
    to point to the output of the build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-agentvm`: This is the mode when jtreg uses the pool of reusable JVMs to run
    the tests. When a test requires a separate JVM for the run, that JVM is not created,
    but it is borrowed from the pool of reusable instances. If any parameter is not
    specified, jtreg will recreate a JVM for each test and this will significantly
    slow down the test run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-verbose:summary`: This argument specifies the output mode. The `summary`
    parameter means that it will print just the status and the test name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-automatic`: This argument means that only the automatic tests that do not
    require user intervention will be run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w`: This argument provides the location of the working directory. This will
    be used to store class files, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This argument provides the reporting directory in which reports are to
    be stored. To see the report, open the `<reporting directory>/html/report.html`
    file in any browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete list of command line options is available at [http://openjdk.java.net/jtreg/command-help.html](http://openjdk.java.net/jtreg/command-help.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some might find it useful to run tests only for a specific bug and, for that,
    the `bug:<bug_id>` command-line option can be used. The tests' logfiles can be
    found in the working directory (specified by the `-w` parameter or in `JTwork`
    if that parameter is not defined). Logfiles are in text format with a `.jtr` extension.
    These files contain the test output along with the command line and an exception,
    if thrown, and are very useful for troubleshooting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building jtreg from the source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from downloading jtreg as a binary package, there is also an option to
    download the source code and build jtreg from the source. This can be beneficial
    for developers who might want to make changes in the source code or get the latest
    fix that has not yet been released as a binary package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need an Internet connection, a machine capable of running make and
    batch files (Linux or Cygwin), and an installed Mercurial.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following simple steps will show you how to get the jtreg source code and
    make the build:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the sources from [http://hg.openjdk.java.net/code-tools/jtreg](http://hg.openjdk.java.net/code-tools/jtreg).
    To do this, just execute the following command that will clone the jtreg source
    tree in the local folder, `jtreg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the execution of the command, the current directory can be found in the
    new `jtreg` folder with all the jtreg sources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there is no Ant software installed on the machine, install it using `yum`
    (or any other packaging tool), or simply download it from [http://ant.apache.org/](http://ant.apache.org/)
    and then unpack it. If you are using a Linux machine, you also have an option
    to install it by running `yum` or any other similar tool that can be found at
    [http://ant.apache.org/](http://ant.apache.org/) and then unpack it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the latest available version of JT Harness, which is available at [https://jtharness.java.net/](https://jtharness.java.net/).
    Unpack it in the `jtreg/lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: jtreg requires JUnit, but not the latest version. The version has to be earlier
    than 4.11\. The simplest way to get it would be to download the version from Maven
    central at [http://mvnrepository.com/artifact/junit/junit/4.5](http://mvnrepository.com/artifact/junit/junit/4.5).
    A jtreg build requires just the JAR file. Put this file in the `jtreg/lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make things slightly more exciting, a jtreg build also requires another testing
    framework—**TestNG v.6.8**. This can be downloaded from [http://testng.org/doc/download.html](http://testng.org/doc/download.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the required version is the version for Ant users. To make things
    simpler, just use the link, [http://testng.org/testng-6.8.zip](http://testng.org/testng-6.8.zip).
    Unpack the downloaded archive in the `jtreg/lib` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next dependency is `JavaHelp`. This seems to be available only via a direct
    link at [http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip](http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip).
    Unpack it in the `jtreg/lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And then, finally, the last dependency, that is `Xalan`, the XML transformation
    library. The required version is 2.7.1, which can be downloaded from one of the
    websites listed at [http://www.apache.org/dyn/closer.cgi/xml/xalan-j](http://www.apache.org/dyn/closer.cgi/xml/xalan-j).
    Follow the same procedure that you did with the other libraries and unpack it
    in the `jtreg/lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, it is time to write the script that will execute the build. Put the following
    script code into the `make.sh` file of the `jtreg` folder, created in the first
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the script is simple and it is only required to set the environment
    variables. Not much explanation is required, as all the variable names are pretty
    self-explanatory. So, just assign appropriate values that are relevant for your
    machine setup. All the variables are mandatory and have to be defined to run the
    framework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step is to just run that script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the build, which should take just a few seconds, the resulting JAR file
    can be found in the `build/images/jtreg/` folder. This folder will contain a fully
    workable and self-sufficient jtreg distribution:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the standard set of OpenJDK tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is not much different from the one that describes a simple test
    execution. However, it will focus on how to run JDK tests. This knowledge might
    be required if someone is making changes to HotSpot or to any other part of OpenJDK.
  prefs: []
  type: TYPE_NORMAL
- en: Standard tests are available only in three root folders for JDK7 and in four
    folders for JDK8\. These are `hotspot`, `jdk`, `langtools`, and `nashorn` (for
    jdk8 only). Although tests are not available for other areas such as CORBA, JDBC,
    JAXP, and so on, it doesn't mean that they are not tested at all. It just means
    that tests for them are not part of OpenJDK, that is, they are not provided by
    vendors.
  prefs: []
  type: TYPE_NORMAL
- en: The way tests are organized varies with the dependency of the area they are
    testing, for example, `hotspot` and `langtools` are mostly grouped by functional
    areas they are testing and, then, by bugs (by their numbers). The `jdk` folder
    is mostly organized by the package name, as this set of tests covers the Java
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that some tests might fail, but it does not mean that something
    is particularly wrong with OpenJDK. It just means that there are some situations
    when it is rather hard to create a test that can pass in any environment. For
    example, there can be tests that need a special network configuration or some
    other sort of special environment, which might not be set up on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: There is a set of tests that are known to fail and there is usually a good reason
    for that. The most obvious example is a test that covers some known problem, but
    whose fix is not going to happen soon. These tests are listed in `jdk/test/ProblemList.txt`
    or marked with a `@ignore` tag. These tests should usually be excluded from the
    standard test run.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we will be running tests for OpenJDK, it is required to have relevant sources
    available on the machine. The machine should also be set up for the OpenJDK build,
    as we will be using OpenJDK make files to execute the test run.
  prefs: []
  type: TYPE_NORMAL
- en: jtreg should be downloaded and unpacked in a folder on the machine so that it
    is ready for the test run.
  prefs: []
  type: TYPE_NORMAL
- en: Some OpenJDK tests are shell scripts, so you will need to use either a Linux
    machine or, in the case of a Windows machine, Cygwin with support for the Bourne
    shell, even though Cygwin is not recommended, as there is a chance that some shell
    tests will not run properly on it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most convenient ways to run tests is to run them separately for
    each area, such as `hotspot`, `jdk`, and so on. As the aim of this recipe is to
    just explain the concept, we will be using the `jdk` tests, which are just a subset
    of all the tests available in OpenJDK, but the same pattern can be applied to
    all the other areas as well. Follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the OpenJDK source root folder, create a file with the name, `run_jdk_lang_tests.sh`
    and the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `JTREG_HOME` and `JT_HOME` environment variables are both the same and should
    point to a folder with jtreg. Unfortunately, there are places in make files where
    both these variables are used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`PRODUCT_HOME` points to a JDK in the test. It is not strictly required to
    point it to a version of JDK that was just built from the source, but there is
    also no sense in executing tests on a version that one can''t change.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`TESTDIRS` points to a subset of tests to run. Obviously, the wider that subset,
    the more tests will be executed and the longer it will take to run. So usually
    it makes sense to limit this subset to something reasonable, unless there is a
    need to do a regression test after making big changes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s run the script. It will execute tests in the `jdk` folder and output
    hundreds of lines like these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When it''s all finished, the make script will report something as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding output tells us how many tests were executed, how many failed,
    how many passed, and so on. Now, when all the tests that we were interested in
    are run, the results can be found in the `jdk/build/linux-amd64/testoutput/JTreport`
    folder. There will be standard jtreg text and HTML report files that can be viewed
    using any web browser.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If someone came to a point where there was a need to run an OpenJDK test, there
    is a good chance that there would be a situation when the tests had to be updated
    or extended. In that case, it is important to have a good understanding of what
    is going on inside these tests and what is the exact reason for each of them to
    exist. Mostly, that information is available in the `@bug` and `@summary` tags.
    It is highly recommended to pay attention to their content and put in some effort
    to see how they correlate with actual test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the tests contain additional information in the `@bug` and `@summary`
    tags. It is important to refer to these tags to understand the reason for the
    test. For example, when you run tests, it is not uncommon to see an output like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It means that this is the test for the bug with ID `7157574`, which can actually
    be found in the JDK bug tracking system at [https://bugs.openjdk.java.net/browse/JDK-7157574](https://bugs.openjdk.java.net/browse/JDK-7157574).
    And, when one takes a look at the test, the following information will be in the
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This header has a reference to the bug that this test is testing and, in the
    summary section, it explains exactly what this test is doing. Also, when you look
    at the source of a test, it is quite common to see that it contains a very detailed
    explanation of the problem and the way that the problem is being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own test for jtreg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are going to add a new feature to OpenJDK or fix a bug, it is really
    a good idea to have a test case to cover the change in functionality and to ensure
    that the implementation change doesn't break anything. This recipe will help you
    to get some understanding of the process and create a simple test. You will find
    that writing your own test case for jtreg is not a complicated task, but it can
    be slightly unusual in some respects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that is required for this recipe is an installed jtreg and the OpenJDK sources.
    The latter is required only because this recipe assumes that the newly created
    test is for OpenJDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing tests for jtreg can be a little unusual, but when you get used to the
    pattern it is actually quite easy. To begin, just follow the steps. Keep in mind
    that all the paths are given relative to the OpenJDK source root:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the root folder of OpenJDK and create the `jdk/test/demo/SampleTest.java`
    file first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the `jdk/test/demo/SampleTimeProvider.java` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a script file with the name, `run_jtreg.sh` in the source root
    folder of JDK and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, only one test was run and the run was successful. So, writing
    a simple test case is a very simple task.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, the final step. After all the tests have been run, let's look at the test
    result whose path was provided in the output of jtreg. Let's open `report/html/repost.html`
    in a web browser and take a look at what's there:![How to do it...](img/8405OT_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we can see that only one test, **demo/SampleTest.java**, was executed
    and it was the one that passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some explanation is required to find out what actually happened. The test itself
    is in the `SampleTest.java` file. jtreg knows that the file contains the test
    by the presence of the `@test` tag in the class header comments. Without that
    tag, jtreg will not consider it as a test.
  prefs: []
  type: TYPE_NORMAL
- en: The only purpose of the `@summary` tag is to give a summary description for
    the test. This description will also be used in logs and reports. It is very important
    to have a good, readable description for that tag. Also, if a test is for a bug,
    it is necessary to have the `@bug` tag populated with an appropriate bug number.
  prefs: []
  type: TYPE_NORMAL
- en: The next tag, `@compile`, has a reference to another file, which is required
    to be compiled to run the test. The only reason for the existence of `SampleTimeProvider.java`
    is to show how to use the `@compile` tag. It is very unusual for Java to do things
    like this. Usually, everything is compiled and then things are picked from the
    classpath, but this is the way Java works.
  prefs: []
  type: TYPE_NORMAL
- en: The `@run` tag tells the harness how to run the test. As can be seen from the
    test class, this parameter can be defined several times, which means that the
    test will also be executed several times and each time it will be run with a configuration
    defined by the associated run tag. In our example, there are two runs, one in
    the same VM and the other in a new instance of VM, which is specified by the `othervm`
    parameter. If this tag is not defined, then, by default, jtreg assumes that it
    is `@run main ClassName`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a test fails if it runs for longer than 2 minutes (120 seconds) and
    can be overwritten by `@run main/timeout=xxx`.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a test indicates its failure by throwing an exception. A test from
    this recipe will throw `RuntimeException` when its conditions are not met.
  prefs: []
  type: TYPE_NORMAL
- en: jtreg requires the `TEST.ROOT` file to be created in the tests' root folder.
    Without that file, it will not execute any test. Luckily for us, JDK already has
    the required file with the appropriate content, so there is no need for us to
    worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jtreg test cases are defined by the Javadoc tags and it is useful to be familiar
    with all of them. The complete list of tags and information about each tag is
    available either in the help file that can be accessed by running the jtreg command,
    `–onlineHelp`, or online at [http://openjdk.java.net/jtreg/tag-spec.html](http://openjdk.java.net/jtreg/tag-spec.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using jtreg in GUI mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jtreg is not only a command-line tool, but it also provides a relatively sophisticated
    graphical interface that allows you to run an individual set of tests, prepare
    test runs, see results of the run, and so on. This recipe will cover some basic
    features of UI that are enough for the user to start using the tool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that is required for this recipe is an installed jtreg and the OpenJDK sources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the following script that will launch jtreg with a graphical UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parameter that tells jtreg to launch JT Harness UI is `-g`. After it is
    launched, jtreg displays a window similar to the following one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/8405OT_09_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: On the right-hand side of the preceding screenshot, you can see the results
    of the latest test run. It knows where to pick them up from the `–r` parameter.
    In this screenshot, you can also see the number of successful and failed tests,
    the total number of executed tests, and some other stats.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side of the preceding screenshot, there is a tree with all
    the available tests. This shows all the tests from the root of the test bundle,
    which is the folder with the `TEST.ROOT` configuration file. The green folder
    icon indicates the tests that ran successfully and the red one indicates the ones
    that failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run a specific test from a set of tests, right-click on the individual test
    folder and select the **Execute these test** item from the pop-up menu. This will
    trigger the test run and a new report will be generated. For long running tests,
    there is a status window, which is available via the **Run Tests** | **Monitor
    Progress** menu item:![How to do it...](img/8405OT_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UI that is used by jtreg does not actually belong to jtreg. It is provided
    by JT Harness and jtreg just integrates it using the provided plugin system.
  prefs: []
  type: TYPE_NORMAL
- en: JT Harness provides a rich interface not only to run tests, but it also has
    a set of wizards to create test configurations, various report conversion tools,
    an agent monitoring tool, and so on. To get more information about all these features,
    refer to JT Harness online help, which is available via the **Help/Online Help**
    menu item.
  prefs: []
  type: TYPE_NORMAL
- en: Writing TestNG tests for jtreg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jtreg also provides support to run TestNG test cases, which might be a more
    familiar technique for many developers. There are some steps that need to be performed
    to make it happen and this recipe will go through them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will require the OpenJDK source code and an installed version of
    jtreg. On a Windows machine, it is also required to have Cygwin installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following procedure should be more familiar to Java developers than writing
    a native jtreg test, as TestNG is what most developers have heard of and used.
    Now, let's get to the practical part and create a test. The paths are relative
    to the OpenJDK source root.
  prefs: []
  type: TYPE_NORMAL
- en: Relative to the OpenJDK root folder, create a folder with the name, `jdk/test/testng/org/demo`.
    This is the folder where we are going to create our tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file, `jdk/test/testng/TEST.properties`, relative to the OpenJDK
    source root. Add the following line there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is not strictly required to create the file, and it is also possible to define
    the property in `jdk/test/TEST.ROOT`, which will work in the same way as our previous
    property. However, in most cases, it is practical to have that file so that it
    can contain some additional configuration that is specific to the set of TestNG
    tests, for example, the `lib.dirs` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `jdk/test/testng/org/mydemo` folder, create the following file with
    the name, `MyTestNGTest.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in OpenJDK''s source root folder, create the following bash script (fix
    the paths as required to match the machine environment):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, give it a name, `./run_jtreg.sh`, and make it executable (running `chmod
    +x ./run_jterg.sh` will do the job) and run it. The resulting output of the script
    should look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that's it. The test has been run and, as can be seen from the output, it
    has passed. The result of the run can be seen by opening `/home/user/openjdk/jdk7u/build/jtreg/report/html/report.html`
    in the browser application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file named `TEST.properties` that is created in the folder with the tests
    root package, requires a bit of explanation. This is the file that contains sets
    of configurations specific to the TestNG tests in the folder where the file is
    located. For example, it can have a reference to folders with libraries via the
    `lib.dirs` property. That is the `path` type property, which is the same as `TestNG.dirs`,
    and such properties are space-separated lists of paths to some of the folders
    or files. If the path in the list starts with `/`, then it is evaluated relative
    to a folder with `TEST.ROOT`, otherwise it is evaluated from the directory containing
    `TEST.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As it is possible to use the TestNG annotations within the test classes, it
    is worth checking the TestNG website, which contains some documentation on this
    topic at [http://testng.org/doc/documentation-main.html](http://testng.org/doc/documentation-main.html).
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use the jtreg style tags and the TestNG style test together.
    In that case, the test should be created as a normal jtreg test (see the *Writing
    your own test for jtreg* recipe), using `testng` as the argument for `@run`, for
    example, `@run testng SampleTest`. In this scenario, there is no need for `TEST.properties`
    and things like `lib.dirs` are defined in the test source file via the jtreg tags,
    rather than in a separate configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling JT Harness from the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JT Harness is a framework that allows you to execute different sets of tests.
    It is not necessary to use it only with jtreg. Other testing frameworks can be
    integrated with it as well. This means that it could be useful to have its source
    code to be able to build it from the source. This is exactly what this recipe
    is going to explain.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need Internet access to download the source code and install the additional
    software that is required for the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that Ant version 1.6.1 or later is installed on the machine. If not,
    then install it. The *How to do it...* section depends on the OS you are using.
    For example, on Fedora, that will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, the simplest way would be to just download the distribution and
    add Ant's `bin` folder to the `PATH` environment variable. The Ant distribution
    can be found at [http://ant.apache.org/](http://ant.apache.org/). Keep in mind
    that, to make it work, the `JAVA_HOME` environment variable has to contain the
    correct path of the Java distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that Subversion is installed on the machine. In contrast to other tools,
    JT Harness doesn''t use the Mercurial repository for its source code. On Fedora,
    Subversion can be installed by running `yum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: On any other OS, it really depends on the OS. Check [http://subversion.apache.org/](http://subversion.apache.org/)
    to find out what is available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following command to check the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a folder with the name, `jtharness`, and download the
    source code. In that folder, create another folder and name it, `lib`. Here we
    will put the libraries required to build JT Harness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now download the following software (all paths are given relative to the `jtharness`
    folder):'
  prefs: []
  type: TYPE_NORMAL
- en: JavaHelp seems to be available only via a direct link from [http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip](http://download.java.net/javadesktop/javahelp/javahelp2_0_05.zip).
    Unpack it into `lib/jh2.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to [http://asm.ow2.org/](http://asm.ow2.org/) and download the ASM Java bytecode
    manipulation library binaries version 3.1\. Unpack the archive into `lib/asm-3.1`.
    This is required only for compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the required library is `Java Communications API`. Go to [http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-misc-419423.html](http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-misc-419423.html)
    and download `Java Communications API 3.0u1` or any other higher version that
    is available. Unpack the archive into `lib/commapi`. This is required only for
    compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java Servlet APIs are only required for compilation. Probably the simplest way
    to download them is to get the JAR from Maven Central. Go to [http://search.maven.org/](http://search.maven.org/)
    and search for `javax.servlet servlet-api`. Download the JAR v.3.1.0 and put it
    directly into the `lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last one is JUnit, which is also only required for compilation. The recommended
    version is 4.4\. Go to [http://junit.org/](http://junit.org/)and click on the
    **Download** link to download the appropriate version of the JAR file. Place it
    directly into the `lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to get the sources. To do this, run the following command
    that will get the latest sources from the trunk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create the folder, `jtharness`, with two subfolders: `www` and `code`.
    The `www` folder contains pages with links to the documentation and other useful
    information, but we are really interested in the folder with the name code. It
    is actually not strictly necessary to download `www` at all, but it doesn''t do
    any harm either.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to the folder, `jtharness/code/build`, locate the file `local.properties`,
    and edit it to set the following properties to point to the appropriate locations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jhalljar`: This provides the path to the JavaHelp `jhalljar.jar` file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jhjar`: This property provides the path to the JavaHelp `jhjar.jar` file'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jcommjar`: This provides the path to `comm.jar` from the `Java Communications
    API`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servletjar`: This provides the path to the `servlet-api.jar` file from `Java
    Servlet API`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytecodelib`: This provides a colon-separated path to the `asm-3.1.jar` and
    `asm-commons-3.1.jar` files'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junitlib`: This provides the path to `junit-4.4.jar` from jUnit'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the editing, the file should look similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If it is required, the `BUILD_DIR` variable can be changed to a different folder
    but, usually it is not necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now ensure that the current folder is `jtharness/code/build` and run Ant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the build is finished, the folder, `jtharness/JTHarness-build/binaries`,
    contains the distribution of JT Harness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are other targets available in the JT Harness build file that you may
    find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`run`: This builds and runs JT Harness. This is not the only way to launch
    the application. The other option is to run the following command from the source
    root folder after the build:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`clean`: This just builds the distribution directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: This builds JT Harness and then runs all the tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: This just runs the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Javadoc`: This generates the Javadoc API documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build-examples`: This builds the example test suites packaged with the source.
    This target also automatically builds the core harness first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running jcstress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Concurrency Stress Test** (**jcstress**) is a set of tests for testing
    the correctness of the Java concurrency support. This is a new tool that is mostly
    targeted to Java 8, which means that not all the tests will run on previous versions
    of Java. As a new tool, jcstress is in its alpha phase and changes for fixes and
    improvements are common, which means that whoever is working with it is expected
    to update the source code and rebuild the tool relatively often.
  prefs: []
  type: TYPE_NORMAL
- en: Testing concurrency is not an easy task and it may or may not be easy to make
    such tests fail even with incorrect code. This happens due to the nature of concurrent
    code, which might work differently on different hardware configurations. Such
    variations arise from the number of CPUs or the CPU architecture. Overall, this
    means that many tests in jcstress are uncertain and they might require a long
    time before exposing potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need Internet access and the Mercurial repository to download the
    source code. As jcstress requires Java 8 for compilation and to run the full set
    of tests, it has to be installed on the machine and set as the current version.
    This means that the following commands should, as illustrated next, show Java
    1.8 as the major version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The build will also require Maven (one of the Java build tools) to be installed
    on the machine. The installation of this tool depends on the OS. For example,
    on Fedora, this can be done by running the following command as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: On other OSs, the simplest way might be to download the binary from [http://maven.apache.org/download.cgi](http://maven.apache.org/download.cgi),
    unpack the archive, point `M2_HOME` to the root of the unpacked folder and add
    `M2_HOME/bin` to the path.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it''s time for action. The first few steps of this recipe will cover the
    build process and then it will switch to run the actual tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to download the sources. Go to the folder where you want
    to store the source code and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When this command is run, Mercurial is downloaded along with the source code
    from the remote repository and it is stored in the folder, `jcstress`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to build the tool, move to the folder `jcstress` and run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If successful, it should display something like this as the end:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that the build has done what it was supposed to do and the tests
    are ready to be run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run all the tests, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will output thousands of lines like these:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ETA` is the estimated completion time, `R` is the runtime in nanoseconds,
    `T` is the test number, `F` is the fork number, and `I` is the test iteration
    number. This is all followed by the result (`OK` in this example) and the full
    name of the test class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As you can see, the full standard set of tests run for approximately 40 minutes,
    and this might be too much, so there is an option to select which test to run
    using the `-t` parameter. This is a regular expression selected for the tests,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will only run tests which have `ByteBufferAtomicityTests` anywhere in their
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the tests are completed, it is time to have a look at the reports that
    are generated and, by default, they are put into the `./results/` folder. There
    you can find the file, `index.html`, which can be opened with any browser. The
    result will list all the tests and, if you click on the tests, all the observer
    outputs. These outputs can be something that is expected, not expected, or expected
    but somehow surprising to the user. This can result in the following outcomes
    for a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FAILED`: The test failed and the outcomes were not what was expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERROR`: The test crashed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACCEPTABLE`: The test results matched the specifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACCEPTABLE_INTERESTING`: This is the same as `ACCEPTABLE`, but it has something
    to highlight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACCEPTABLE_SPEC`: This is the same as `ACCEPTABLE`, but some interesting behavior
    is also observed that might not be otherwise expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is recommended that you have a look at the other command-line options that
    are available for jcstress. This information can be retrieved by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: jcstress has its own page at [http://openjdk.java.net/](http://openjdk.java.net/),
    which has some very useful information and links to the source and mailing list
    at [http://openjdk.java.net/projects/code-tools/jcstress/](http://openjdk.java.net/projects/code-tools/jcstress/).
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for jcstress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Concurrency Stress test** is a wonderful tool that is used by JDK
    authors to ensure that their concurrent code works correctly with regards to concurrency.
    Concurrent code is hard to write and even harder to test. Most of their tests
    are probabilistic, require a lot of skill to write, and might take many days running
    time and the appropriate hardware to exhibit the fail behavior. Considering all
    this complexity, having a framework that can help with correct test execution
    is a big advantage. This recipe will go through the steps that are required to
    write your own tests for jcstress.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow this recipe, the only requirement is to have an environment that is
    capable of compiling and running jcstress (see the *Building and running jcstress*
    recipe).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will lead you through the process of creating a test and
    running it using jcstress:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will need a code to test. Let''s pick the problem which, arguably,
    is the most common cause of headaches in concurrency and is very easy to reproduce.
    Data race sounds like a good candidate. We will make a class called `CASValue`
    and implement it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class implements a single operation which is supposed to perform the compare-and-swap
    operation (see [http://en.wikipedia.org/wiki/Compare-and-swap](http://en.wikipedia.org/wiki/Compare-and-swap)).
    Without synchronization, it will not work correctly in a multithreaded environment
    and should fail the test that we will create in the next steps of this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the source root folder of jcstress, create the file, `tests-custom/src/main/java/org/openjdk/jcstress/tests/CASValue.java`,
    and put the source code of the `CASValue` class in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it''s time to write a test to see whether our implementation is wrong.
    The test class will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save this file in the same folder as `CASValue.java`, that is, in `tests-custom/src/main/java/org/openjdk/jcstress/tests/`,
    and give it the name, `CASValueTests.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `CASValueTests` class is the container class for other classes within the
    test. This is not strictly required, but it helps to keep the code clean. The
    `ValCas_ValCas` class, which is annotated with `@JCStressTest`, is the test case
    class that contains two actors—methods annotated with `@Actor`. These are the
    methods that will be run in parallel by the test framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subclass `S`, annotated with `@State`, is the state that was shared among
    the actors and, in this case, is the class under test. It extends our class, `CASValue`,
    and is created solely to avoid adding the `@State` annotation on `CASValue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@Outcome` annotations specify the outcomes of the test. The outcomes can
    be `ACCEPTABLE`, `FORBIDDEN`, `ACCEPTABLE_INTERESTING`, and `ACCEPTABLE_SPEC`.
    These are defined by the `expect` attribute. The `id` attribute provides the list
    of outcomes, whereas `desc` is just a description of the outcome. This test case
    specifies that, for our test, the only valid outcomes for the values in `LongResul2`
    are `5` and `2` and `1` and `10`, which are the only expected ones if CAS works
    as expected. Any other outcomes are forbidden and will cause the test case to
    fail, which is exactly what we want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it''s time to compile the test. To do this, run the following command from
    the source root directory of jcstress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will just run the build for the `tests-custom` project, which will compile
    the classes that we have just created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to run our test and see if it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `-t` parameter in this command specifies that we only want to run the tests
    that satisfy the `.*CASValueTests.*` regular expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As expected, the tests should fail, as the provided implementation does implement
    the CAS operation correctly. The output should have several test outcomes similar
    to this one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It shows how many outputs of each outcome were observed. So far, the incorrect
    outcome `[5, 10]` is the leader with `7,609,449` occurrences. This shows that
    the test worked correctly and helped us to identify that we need to fix our implementation
    on the CAS class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s fix our class and run the test again. The easiest, though not the
    most efficient, way to fix the problem is to simply add the `synchronized` modifier
    to our CAS method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After changing the implementation, run the build again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, rerun the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the test should not show any failures and report that the test runs were
    successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows that the change in the implementation worked and the implementation
    is correct according to the test case.
  prefs: []
  type: TYPE_NORMAL
- en: By following these steps, a developer can ensure that a concurrent code works
    as expected according to the specification, as long as the tests and test cases
    are implemented and defined correctly. However, keep in mind that concurrency
    is something that is hard to test, and an implementation that works on one hardware
    can easily fail on other hardware. It means that it is recommended to run these
    test on the widest possible range of configurations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This framework is built and maintained by Aleksey Shipilëv who has his own blog
    and also delivers lectures in various conferences. We recommend that you visit
    his home page ([http://shipilev.net/](http://shipilev.net/)), watch his videos
    on YouTube (for example, [https://www.youtube.com/watch?v=4p4vL6EhzOk](https://www.youtube.com/watch?v=4p4vL6EhzOk)),
    and read some of his papers. This will help you to get tons of information on
    correct concurrency testing, concurrency in general, support for concurrency in
    Java, and other related topics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a benchmark project using JMH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Micro benchmarking itself is not an easy topic, and doing it correctly using
    languages like Java is a very difficult task. These difficulties arise from the
    way Java executes the code and the infrastructure required by JVM. Just as things
    like JIT and GC may affect the results of micro benchmarking heavily, to ensure
    that the result of each run is consistent and correct might not be an easy task
    to accomplish. To help with this problem, there are several frameworks that can
    help to ensure that the benchmark test runs properly. One of these frameworks
    is **Java Microbenchmark Harness** (**JMH**), which is a part of OpenJDK. This
    recipe will explain how developers can use this framework to benchmark his/her
    own code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a machine with an Internet connection, Maven, Java SDK,
    and your favorite IDE that has support for Maven projects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will take you through the process of creating a benchmark
    project and writing the benchmark, which can be used to analyze the performance
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the command line, run the following Maven command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running this command, in the current directory, Maven will create a folder
    with the name, `mybenchmark`, which will have the skeleton of the project. If
    all goes well, the build should end with an output that is similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when the project is generated, we can start working with it and create
    our first microbenchmark test. Open the generated project file (`/home/user/openjdk/mybenchmark/pom.xml`)
    with your favorite IDE. Ensure that Maven is correctly configured and all dependencies
    are downloaded correctly. Notice that there is already a class created for the
    benchmark whose name is `org.benchmark.MyBenchmark`. At the beginning, all it
    has is a single method where we will later put the code we are going to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, let''s test something that is relatively simple but has some
    room for improvement. A binary search is a good choice for this purpose. So, let''s
    draft a simple implementation and put it into the `org.benchmark.BinarySearch1`
    class as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a very basic implementation, which will be fine for our experiment.
    If you are not familiar with binary search or where to get more information about
    this algorithm, visit the Wikipedia page at [http://en.wikipedia.org/wiki/Binary_search_algorithm](http://en.wikipedia.org/wiki/Binary_search_algorithm).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, when the first draft of the implementation is ready, we will create a
    microbenchmark for it. Put the following code into the `org.benchmark.MyBenchmark`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code requires some clarification. The `@State` annotation is required to
    tell JMH that this class contains some data that is used by the tests, and that
    data in the `Scope.Thread` scope means that it will not be shared between several
    threads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `@BenchmarkMode(Mode.AverageTime)` annotation says that what we want to
    measure is the average time required to execute our test, which, by default, measures
    throughput. The `@OutputTimeUnit(TimeUnit.MICROSECONDS)` annotation sets `timeunit`.
    We need to define it, as the default is in seconds, which is a very big scale
    for the benchmark.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The setup method is annotated with the `@Setup` annotation, which means that
    it does some preparation for the tests and it will be called to initialize the
    data for the test. It is similar to the `@Before` annotation from JUnit. Keep
    in mind that this method is executed only once before running the test in the
    fork on JVM. It is not executed before each test method is called. This means
    that the same test method will work with the same data after each iteration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The actual test is in the method annotated with `@Benchmark` that executes the
    code that we are testing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that everything is set up, run a test and find out how fast our code is.
    First, let''s build the project with our code and test it. To do this, go to the
    folder with the project and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, run the benchmark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here `wi` defines the number of `warmup` iterations, `i` the number of test
    run iterations, `f` says how many JVM forks to use, and `jvmArgs` are the parameters
    for forked JVM.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output for each of our test methods should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output shows the runs executed for each fork and the final result. Here
    we can see that, on average, our method takes `77.178` nanoseconds to run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have the results, what to do with them? Generally, these results
    make sense only when they are compared with something else. Let''s try to make
    some changes to the code and see whether it helps our implementation of binary
    search to work faster. We can try to remove recursion and see how it''s going
    to work. Create another class with the name, `org.benchmark.BinarySearch2`, and
    put the following implementation there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the iterative implementation, which doesn't use recursive calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s update the benchmark class so that we can compare recursive and
    iterative implementations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The difference between this benchmark and the previous version is that this
    uses the benchmarking groups that give us a simple comparison of our implementations.
    The `@State` annotation now has to have the `Group` scope, otherwise the tests
    will be using different data instances, which is not what we would want, as we
    want algorithms to work in exactly the same conditions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, rebuild the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, run the test again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is going to be slightly different from the previous one, because
    of the use of groups. The main difference in which we are interested is going
    to be at the end of the report:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What we can see here is that, for this particular configuration (which includes
    machine spec, version of JDK, OS, and so on), iterative implementation, which
    is implemented by the method, `testBinarySearch2()`, is on average faster than
    the recursive one, implemented by `testBinarySearch1()` (`54.141` < `79.717`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After going through this recipe, you have learned how to run microbenchmark
    tests, how to interpret results, and how to compare the performance of different
    implementations. Ensure that you microbenchmark each hard task properly and remember
    that the results can vary significantly on different machines, JVM versions, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JMH is a flexible framework that provides flexibility to the way it can be
    used. For example, if someone wants to run tests via the main method, without
    using `benchmarks.jar`, this can be easily achieved. To do this, just add the
    following main method to `MyBenchmark` and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will give the same result as running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We also recommend that you download the source code (see the *Downloading source
    and compiling JHM* recipe). Have a look at the recipe and JavaDocs, as the JavaDocs
    are well written and explain a lot about the framework.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to jcstress, this framework is also built and maintained by Aleksey
    Shipilëv who has his own blog and also delivers lectures in various conferences.
    We recommend you visit his home page ([http://shipilev.net/](http://shipilev.net/)),
    watch his videos on YouTube (for example, [https://www.youtube.com/watch?v=4p4vL6EhzOk](https://www.youtube.com/watch?v=4p4vL6EhzOk)),
    and read some of his papers.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the source and compiling JHM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to all other OpenJDK tools and projects, there is an option to download
    the source of the JHM and build it yourself. This might be required if a framework
    requires customization and an extension fix. Luckily the process is very easy
    and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a machine with an Internet connection that is capable of
    running Mercurial and Maven. Basically, the requirements are the same as that
    for compiling and running `jcstress` (see the *Building and running jcstress*
    recipe).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps will lead you through the process of downloading the source
    code and building JHM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s run the following command to download the source files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command will download the source files and put them into the `jmh` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to build the source code. The build requires Maven to be installed
    on the machine. Change the current folder to `jmh` and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command should generate an output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that the build was successful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, the final step is to change your benchmark project to use the version
    of JHM that was just built. Assuming the project references of the JHM version
    are by properties, just change the version of the JHM dependency in your project
    to `1.0-SNAPHOT`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you run Maven with the `install` target, it will put the newly built version
    of the artefact in the local repository. In this case, the version is `1.0-SNAPSHOT`.
    When another project has dependency on that version, Maven will pick the version
    from the local repository and use it.
  prefs: []
  type: TYPE_NORMAL
