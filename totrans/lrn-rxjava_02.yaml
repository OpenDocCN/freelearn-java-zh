- en: Observables and Subscribers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Observable`和订阅者'
- en: We already got a glimpse into the `Observable` and how it works in [Chapter
    1](aba3c4b9-d382-43b5-b81a-495d3b2ca605.xhtml), *Thinking Reactively*. You probably
    have many questions on how exactly it operates and what practical applications
    it holds. This chapter will provide a foundation for understanding how an `Observable`
    works as well as the critical relationship it has with the `Observer`**.** We
    will also cover several ways to create an `Observable` as well make it useful
    by covering a few operators. To make the rest of the book flow smoothly, we will
    also cover all critical nuances head-on to build a solid foundation and not leave
    you with surprises later.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第一章](aba3c4b9-d382-43b5-b81a-495d3b2ca605.xhtml)《反应式思考》中窥见了`Observable`及其工作原理。你可能对它如何精确运作以及它有哪些实际应用有很多疑问。本章将为理解`Observable`的工作原理及其与`Observer`的关键关系奠定基础。我们还将介绍几种创建`Observable`的方法，并通过介绍一些操作符使其变得有用。为了使本书的其余部分流畅，我们还将直接覆盖所有关键细节，以建立一个坚实的基础，避免你在以后遇到惊喜。
- en: 'Here is what we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: The `Observable`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable`'
- en: The `Observer`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observer`'
- en: Other `Observable` factories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他`Observable`工厂
- en: '`Single`, `Completable`, and `Maybe`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Single`、`Completable`和`Maybe`'
- en: '`Disposable`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Disposable`'
- en: The Observable
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Observable`'
- en: As introduced in [Chapter 1](aba3c4b9-d382-43b5-b81a-495d3b2ca605.xhtml), *Thinking
    Reactively*, the `Observable` is a push-based**,** composable iterator. For a
    given `Observable<T>`, it pushes items (called emissions) of type `T` through
    a series of operators until it finally arrives at a final Observer, which consumes
    the items. We will cover several ways to create an `Observable`, but first, let's
    dive into how an `Observable` works through its `onNext()`, `onCompleted()`, and
    `onError()` calls.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第一章](aba3c4b9-d382-43b5-b81a-495d3b2ca605.xhtml)《反应式思考》中所述，`Observable`是一个基于推送的**可组合迭代器**。对于给定的`Observable<T>`，它通过一系列操作符推送类型为`T`的项目（称为发射），直到最终到达一个最终的`Observer`，它消费这些项目。我们将介绍几种创建`Observable`的方法，但首先，让我们深入了解`Observable`是如何通过其`onNext()`、`onCompleted()`和`onError()`调用工作的。
- en: How Observables work
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Observable`的工作原理'
- en: 'Before we do anything else, we need to study how an `Observable` sequentially
    passes items down a chain to an `Observer`. At the highest level, an `Observable`
    works by passing three types of events:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们做任何事情之前，我们需要研究`Observable`如何顺序地将项目传递到链中的`Observer`。在最高层次上，`Observable`通过传递三种类型的事件来工作：
- en: '`onNext()`: This passes each item one at a time from the source `Observable`
    all the way down to the `Observer`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext()`：这个方法将每个项目逐个从源`Observable`传递到`Observer`。'
- en: '`onComplete()`: This communicates a completion event all the way down to the
    `Observer`, indicating that no more `onNext()` calls will occur.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete()`：这个方法将完成事件传递到`Observer`，表明将不再发生`onNext()`调用。'
- en: '`onError()`: This communicates an error up the chain to the `Observer`, where
    the `Observer` typically defines how to handle it. Unless a `retry()` operator
    is used to intercept the error, the `Observable` chain typically terminates, and
    no more emissions will occur.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError()`：这个方法将错误传递到链中的`Observer`，其中`Observer`通常定义如何处理它。除非使用`retry()`操作符来拦截错误，否则`Observable`链通常终止，不再发生更多的发射。'
- en: These three events are abstract methods in the `Observer` type, and we will
    cover some of the implementation later. For now, we will focus pragmatically on
    how they work in everyday usage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个事件是`Observer`类型中的抽象方法，我们将在稍后介绍一些实现。现在，我们将实用主义地关注它们在日常使用中的工作方式。
- en: In RxJava 1.0, the `onComplete()` event is actually called `onCompleted()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava 1.0中，`onComplete()`事件实际上被称作`onCompleted()`。
- en: Using Observable.create()
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Observable.create()
- en: Let's start with creating a source `Observable` using `Observable.create()`.
    Relatively speaking, a source `Observable` is an `Observable` where emissions
    originate from and is the starting point of our `Observable` chain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`Observable.create()`创建一个源`Observable`开始。相对而言，源`Observable`是一个发射起源于此的`Observable`，并且是我们`Observable`链的起点。
- en: 'The `Observable.create()` factory allows us to create an `Observable` by providing
    a lambda receiving an `Observable` emitter**.** We can call the `Observable` emitter''s
    `onNext()` method to pass emissions  (one a time) up the chain as well as `onComplete()`
    to signal completion and communicate that there will be no more items. These `onNext()`
    calls will pass these items up the chain towards the `Observer`, where it will
    print each item, as shown in the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.create()` 工厂允许我们通过提供一个接收 `Observable` 发射器的 lambda 来创建一个 `Observable`。我们可以调用
    `Observable` 发射器的 `onNext()` 方法将发射（一次一个）向上传递到链中，以及调用 `onComplete()` 来表示完成并传达将没有更多项目。这些
    `onNext()` 调用会将这些项目向上传递到链中的 `Observer`，它将打印每个项目，如下面的代码片段所示：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In RxJava 1.0, ensure that you use `Observable.fromEmitter()` instead of `Observable.create()`.
    The latter is something entirely different in RxJava 1.0 and is only for advanced
    RxJava users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 1.0 中，请确保使用 `Observable.fromEmitter()` 而不是 `Observable.create()`。在
    RxJava 1.0 中，后者是完全不同的东西，仅适用于高级 RxJava 用户。
- en: 'The `onNext()` method is a way to hand each item, starting with `Alpha`, to
    the next step in the chain. In this example, the next step is the Observer, which
    prints the item using the **`s -> System.out.println("RECEIVED: " + s)`** lambda.
    This lambda is invoked in the `onNext()` call of `Observer`, and we will  look
    at `Observer` more closely in a moment.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`onNext()` 方法是将每个项目（从 `Alpha` 开始）传递给链中的下一个步骤的一种方式。在这个例子中，下一个步骤是观察者，它使用 **`s
    -> System.out.println("RECEIVED: " + s)`** lambda 打印项目。这个 lambda 在 `Observer`
    的 `onNext()` 调用中被调用，我们稍后会更详细地了解 `Observer`。'
- en: Note that the `Observable` contract ([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))
    dictates that emissions must be passed sequentially and one at a time. Emissions
    cannot be passed by an `Observable` concurrently or in parallel. This may seem
    like a limitation, but it does in fact simplify programs and make Rx easier to
    reason with. We will learn some powerful tricks to effectively leverage concurrency
    and parallelization in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Concurrency and Parallelization* , without breaking the `Observable` contract.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Observable` 协议 ([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))
    规定发射必须按顺序逐个传递。`Observable` 不能并发或并行地传递发射。这看起来可能是一个限制，但实际上它确实简化了程序，并使 Rx 更容易推理。我们将在第
    6 章 [并发和并行化](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml)中学习一些强大的技巧，以有效地利用并发和并行化，而不会破坏
    `Observable` 协议。
- en: The `onComplete()` method is used to communicate up the chain to the `Observer`
    that no more items are coming. Observables can indeed be infinite, and if this
    is the case, the `onComplete()` event will never be called. Technically, a source
    could stop emitting `onNext()` calls and never call `onComplete()`. This would
    likely be bad design, though, if the source no longer plans to send emissions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`onComplete()` 方法用于向上传递到 `Observer`，表示没有更多项目到来。实际上，观察者可以是无限的，如果这种情况发生，`onComplete()`
    事件将永远不会被调用。技术上，源可以停止发出 `onNext()` 调用并永远不调用 `onComplete()`。但这可能是不良的设计，因为如果源不再计划发送发射。'
- en: 'Although this particular example is unlikely to throw an error, we can catch
    errors that may occur within our `Observable.create()` block and emit them through
    `onError()`.This way, the error can be pushed up the chain and handled by th**e**
    `Observer`. This particular `Observer` that we have set up does not handle exceptions,
    but you can do that, as shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个特定的例子不太可能抛出错误，但我们可以在 `Observable.create()` 块内部捕获可能发生的错误，并通过 `onError()`
    发出它们。这样，错误就可以被推送到链的上方，并由 `Observer` 处理。我们设置的特定 `Observer` 并不处理异常，但你可以像下面这样做到：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that `onNext()`, `onComplete()`, and `onError()` do not necessarily push
    directly to the final Observer. They can also push to an operator serving as the
    next step in the chain. In the following code, we derive new Observables with
    the `map()` and `filter()` operators, which will act between the source `Observable`
    and final `Observer` printing the items:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`onNext()`、`onComplete()` 和 `onError()` 并不一定直接推送到最终的观察者。它们也可以推送到作为链中下一个步骤的操作符。在下面的代码中，我们使用
    `map()` 和 `filter()` 操作符派生新的观察者，这些操作符将在源 `Observable` 和最终 `Observer` 打印项目之间起作用：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the output after running the code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行代码后的输出：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the `map()` and `filter()` operators between the source `Observable` and
    Observer, ` onNext()` will hand each item to the  `map()` operator. Internally,
    it will act as an intermediary Observer and convert each string to its `length()`.
    This, in turn, will call `onNext()` on `filter()` to pass that integer, and the
    lambda condition `i -> i >= 5` will suppress emissions that fail to be at least
    five characters in length. Finally, the `filter()` operator will call `onNext()`
    to hand each item to the final `Observer` where they will be printed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在源 `Observable` 和 Observer 之间使用 `map()` 和 `filter()` 操作符时，`onNext()` 将每个项目交给
    `map()` 操作符。内部，它将充当中间 Observer，并将每个字符串转换为它的 `length()`。这将反过来调用 `filter()` 上的 `onNext()`
    来传递那个整数，lambda 条件 `i -> i >= 5` 将抑制长度不足五个字符的发射。最后，`filter()` 操作符将调用 `onNext()`
    将每个项目交给最终的 `Observer`，在那里它们将被打印出来。
- en: 'It is critical to note that the `map()` operator will yield a new `Observable<Integer>` derived
    off the original `Observable<String>`. The `filter()`will also return an `Observable<Integer>`
    but ignore emissions that fail to meet the criteria. Since operators such as `map()`
    and `filter()` yield new Observables (which internally use `Observer` implementations
    to receive emissions), we can chain all our returned Observables with the next
    operator rather than unnecessarily saving each one to an intermediary variable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`map()` 操作符将产生一个新的 `Observable<Integer>`，它是从原始的 `Observable<String>`
    派生出来的。`filter()` 也会返回一个 `Observable<Integer>`，但会忽略不符合标准的事件。由于像 `map()` 和 `filter()`
    这样的操作符产生新的 Observables（它们内部使用 `Observer` 实现来接收事件），我们可以通过下一个操作符链式连接所有返回的 Observables，而不是将每个
    Observables 无需保存到中间变量中：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Chaining operators in this way is common (and encouraged) in reactive programming.
    It has a nice quality of being readable from left to right and top to bottom much
    like a book, and this helps in maintainability and legibility.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式链式连接操作符在响应式编程中很常见（并且被鼓励）。它有一个很好的特性，就像一本书一样，可以从左到右、从上到下阅读，这有助于维护性和可读性。
- en: In RxJava 2.0, Observables no longer support emitting null values. You will
    immediately get a non-null exception if you create an `Observable` that attempts
    to emit a null value. If you need to emit a null, consider wrapping it in a Java
    8 or Google Guava Optional.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 2.0 中，Observables 不再支持发出 null 值。如果你创建了一个尝试发出 null 值的 `Observable`，你将立即得到一个非
    null 异常。如果你需要发出 null，考虑将其包装在 Java 8 或 Google Guava Optional 中。
- en: Using Observable.just()
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `Observable.just()`
- en: Before we look at the `subscribe()` method a bit more, note that you likely
    will not need to use `Observable.create()` often. It can be helpful in hooking
    into certain sources that are not reactive, and we will see this in a couple of
    places later in this chapter. But typically, we use streamlined factories to create
    Observables for common sources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地查看 `subscribe()` 方法之前，请注意，你可能不太经常需要使用 `Observable.create()`。它有助于连接某些非响应式的源，我们将在本章后面的几个地方看到这一点。但通常，我们使用精简的工厂来为常见的源创建
    Observables。
- en: 'In our previous example with `Observable.create()`, we could have used `Observable.just()`
    to accomplish this. We can pass it up to 10 items that we want to emit. It will
    invoke the `onNext()` call for each one and then invoke `onComplete()` when they
    all have been pushed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的 `Observable.create()` 示例中，我们可以使用 `Observable.just()` 来完成这个任务。我们可以传递最多
    10 个我们想要发出的项目。它将为每个项目调用 `onNext()` 调用，然后在它们全部被推入后调用 `onComplete()`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also use `Observable.fromIterable()` to emit the items from any Iterable
    type, such as a `List`. It also will call `onNext()` for each element and then
    call `onComplete()` after the iteration is complete. You will likely use this
    factory frequently since Iterables in Java are common and can easily be made reactive:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `Observable.fromIterable()` 来从任何 Iterable 类型（如 `List`）发出项目。它也会为每个元素调用
    `onNext()`，然后在迭代完成后调用 `onComplete()`。你可能会经常使用这个工厂，因为 Java 中的 Iterables 很常见，并且可以很容易地使其响应式：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will explore other factories to create Observables later in this chapter,
    but for now, let's put that on hold and learn more about Observers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面探索其他创建 Observables 的工厂，但到目前为止，让我们先放一放，更多地了解 Observers。
- en: The Observer interface
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observer 接口
- en: 'The `onNext()`, `onComplete()`, and `onError()` methods actually define the
    Observer type, an abstract interface implemented throughout RxJava to communicate
    these events. This is the Observer definition in RxJava shown in the code snippet.
    Do not bother yourself about `onSubscribe()` for now, as we will cover it at the
    end of this chapter. Just bring your attention to the other three methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`onNext()`、`onComplete()`和`onError()`方法实际上定义了观察者类型，这是一个在RxJava中实现以通信这些事件的抽象接口。这是RxJava中显示在代码片段中的观察者定义。现在不必担心`onSubscribe()`，因为我们将在本章末尾讨论它。只需关注其他三个方法：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Observers and source Observables are somewhat relative. In one context, a source
    Observable is where your `Observable` chain starts and where emissions originate.
    In our previous examples, you could say that the `Observable` returned from our
    `Observable.create()`method or `Observable.just()` is the source `Observable`.
    But to the `filter()` operator, the `Observable` returned from the `map()` operator
    is the source. It has no idea where the emissions are originating from, and it
    just knows that it is receiving emissions from the operator immediately upstream
    from it, which come from `map()`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者和源`Observable`是相对的。在一个上下文中，源`Observable`是`Observable`链开始的地方，也是发射的起源。在我们的前例中，可以说我们从`Observable.create()`方法或`Observable.just()`返回的`Observable`是源`Observable`。但对`filter()`操作符来说，从`map()`操作符返回的`Observable`是源。它不知道发射从哪里起源，它只知道它立即从上游的操作符接收发射，这些发射来自`map()`。
- en: Conversely, each `Observable` returned by an operator is internally an Observer
    that receives, transforms, and relays emissions to the next `Observer` downstream.
    It does not know whether the next `Observer` is another operator or the final Observer
    at the end of the chain. When we talk about the `Observer`, we are often talking
    about the final Observer at the end of the `Observable` chain that consumes the
    emissions. But each operator, such as `map()` and `filter()`, also implements
    `Observer` internally.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，每个由操作符返回的`Observable`在内部都是一个观察者，它接收、转换并将发射传递给下一个`Observer`。它不知道下一个`Observer`是另一个操作符还是链尾的最终`Observer`。当我们谈论`Observer`时，我们通常指的是`Observable`链尾的最终`Observer`，它消费这些发射。但每个操作符，如`map()`和`filter()`，也内部实现了`Observer`。
- en: We will learn in detail about how operators are built in [Chapter 9](3108e794-df20-4efd-8a71-b4da8e3ae036.xhtml),
    *Transformers and Custom Operators*. For now, we will focus on using an `Observer`
    for the `subscribe()` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第9章[变换器和自定义操作符](3108e794-df20-4efd-8a71-b4da8e3ae036.xhtml)中详细了解操作符是如何构建的。现在，我们将专注于使用`Observer`来调用`subscribe()`方法。
- en: In RxJava 1.0, the Subscriber essentially became a Observer in RxJava 2.0\.
    There is an `Observer` type in RxJava 1.0 that defines the three event methods,
    but the Subscriber is what you passed to the `subscribe()` method, and it is implemented
    `Observer`. In RxJava 2.0, a Subscriber only exists when talking about Flowables,
    which we will discuss in [Chapter 8](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml),
    *Flowables and Backpressure*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava 1.0中，订阅者本质上成为了RxJava 2.0中的观察者。在RxJava 1.0中有一个定义了三个事件方法的`Observer`类型，但订阅者是传递给`subscribe()`方法的，并且实现了`Observer`。在RxJava
    2.0中，订阅者仅在讨论`Flowables`时存在，我们将在第8章[Flowables和背压](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml)中讨论。
- en: Implementing and subscribing to an Observer
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现并订阅一个观察者
- en: 'When you call the `subscribe()` method on an `Observable`, an `Observer` is
    used to consume these three events by implementing its methods. Instead of specifying
    lambda arguments like we were doing earlier, we can implement an `Observer` and
    pass an instance of it to the `subscribe()` method. Do not bother yourself about `onSubscribe()`
    at the moment. Just leave its implementation empty until we discuss it at the
    end of this chapter:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`Observable`上调用`subscribe()`方法时，使用一个`Observer`通过实现其方法来消费这三个事件。我们不再像之前那样指定lambda参数，我们可以实现一个`Observer`并将其实例传递给`subscribe()`方法。现在不必担心`onSubscribe()`，只需将其实现留空，直到我们在本章末尾讨论它：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We quickly create an `Observer<Integer>` that serves as our `Observer`, and
    it will receive integer length emissions. Our `Observer` receives emissions at
    the end of an `Observable` chain and serves as the endpoint where the emissions
    are consumed. By consumed, this means they reach the end of the process where
    they are written to a database, text file, a server response, displayed in a UI,
    or (in this case) just printed to the console.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速创建一个`Observer<Integer>`作为我们的`Observer`，它将接收整数长度的发射。我们的`Observer`在`Observable`链的末尾接收发射，并作为消耗发射的终点。通过消耗，这意味着它们到达过程的末尾，被写入数据库、文本文件、服务器响应、在UI中显示，或者（在这种情况下）只是打印到控制台。
- en: 'To further explain this example in detail, we start with string emissions at
    our source. We declare our `Observer` in advance and pass it to the `subscribe()`
    method at the end of our `Observable` chain. Note that each string is transformed
    to its length. The `onNext()` method receives each integer length emission and
    prints it using `System.out.println("RECEIVED: " + value)`. We will not get any
    errors running this simple process, but if one did occur anywhere in our `Observable`
    chain, it will be pushed to our  `onError()` implementation on `Observer`, where
    the stack trace of `Throwable` will be printed. Finally, when the source has no
    more emissions (after pushing "`Epsilon`"), it will call `onComplete()` up the
    chain all the way to the Observer, where its `onComplete()` method will be called
    and print `Done!` to the console.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '为了更详细地解释这个示例，我们从源头的字符串发射开始。我们提前声明我们的`Observer`，并在`Observable`链的末尾将其传递给`subscribe()`方法。请注意，每个字符串都被转换为其长度。`onNext()`方法接收每个整数长度的发射，并使用`System.out.println("RECEIVED:
    " + value)`打印出来。运行这个简单的过程不会出现任何错误，但如果在`Observable`链的任何地方发生了错误，它将被推送到`Observer`上的`onError()`实现，在那里将打印出`Throwable`的堆栈跟踪。最后，当源没有更多的发射（在推送"`Epsilon`"之后），它将调用链中的`onComplete()`直到Observer，在那里它的`onComplete()`方法将被调用，并在控制台打印`Done!`。'
- en: Shorthand Observers with lambdas
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda的简写Observer
- en: 'Implementing an `Observer` is a bit verbose and cumbersome. Thankfully, the
    `subscribe()` method is overloaded to accept lambda arguments for our three events.
    This is likely what we will want to use for most cases, and we can specify three
    lambda parameters separated by commas: the `onNext` lambda, the `onError` lambda,
    and the `onComplete` lambda. For our previous example, we can consolidate our
    three method implementations using these three lambdas:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Observer`有点冗长和繁琐。幸运的是，`subscribe()`方法被重载以接受我们的三个事件的lambda参数。这可能是我们大多数情况下想要使用的，我们可以指定三个用逗号分隔的lambda参数：`onNext`
    lambda、`onError` lambda和`onComplete` lambda。对于我们之前的示例，我们可以使用这三个lambda合并我们的三个方法实现：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can pass these three lambdas as arguments to the `subscribe()` method, and
    it will use them to implement an `Observer` for us. This is much more concise
    and requires far less boilerplate code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这三个lambda作为参数传递给`subscribe()`方法，它将使用它们为我们实现一个`Observer`。这要简洁得多，需要的样板代码也少得多：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that there are other overloads for `subscribe()`. You can omit `onComplete()`
    and only implement `onNext()` and `onError()`. This will no longer perform any
    action for `onComplete()`, but there will likely be cases where you do not need
    one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`subscribe()`还有其他重载。您可以省略`onComplete()`，只实现`onNext()`和`onError()`。这将不再为`onComplete()`执行任何操作，但可能存在不需要一个的情况：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you have seen in earlier examples, you can even omit `onError` and just
    specify `onNext`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在之前的示例中看到的，您甚至可以省略`onError`，只需指定`onNext`：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, not implementing `onError()` is something you want to avoid doing in
    production. Errors that happen anywhere in the `Observable` chain will be propagated
    to `onError()` to be handled and then terminate the `Observable` with no more
    emissions. If you do not specify an action for `onError`, the error will go unhandled.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在生产中不实现`onError()`是您想要避免做的事情。在`Observable`链的任何地方发生的错误都将传播到`onError()`进行处理，然后没有更多的发射终止`Observable`。如果您没有为`onError`指定操作，错误将不会被处理。
- en: You can use `retry()` operators to attempt recovery and resubscribe to an `Observable`
    if an error occurs. We will cover how to do that in the next chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，您可以使用`retry()`运算符尝试恢复并重新订阅一个`Observable`。我们将在下一章中介绍如何做到这一点。
- en: It is critical to note that most of the `subscribe()` overload variants (including
    the shorthand lambda ones we just covered) return a `Disposable` that we did not
    do anything with. `disposables` allow us to disconnect an `Observable` from an `Observer`
    so emissions are terminated early, which is critical for infinite or long-running
    Observables. We will cover `disposables` at the end of this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，大多数的 `subscribe()` 重载变体（包括我们刚刚提到的简写 lambda 变体）返回一个 `Disposable`，我们没有对其进行任何操作。`disposables`
    允许我们断开 `Observable` 和 `Observer` 的连接，以便提前终止发射，这对于无限或长时间运行的观察量至关重要。我们将在本章末尾介绍 `disposables`。
- en: Cold versus hot Observables
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冷观察量与热观察量
- en: There are subtle behaviors in a relationship between an `Observable` and an
    `Observer` depending on how the `Observable` is implemented. A major characteristic
    to be aware of is cold versus hot Observables, which defines how Observables behave
    when there are multiple Observers. First, we will cover cold Observables.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `Observable` 的实现方式，`Observable` 和 `Observer` 之间的关系存在细微的行为差异。需要了解的一个重要特征是冷观察量与热观察量，它定义了当存在多个观察者时观察量的行为。首先，我们将介绍冷观察量。
- en: Cold Observables
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冷观察量
- en: Cold Observables are much like a music CD that can be replayed to each listener,
    so each person can hear all the tracks at any time. In the same manner, cold Observables
    will replay the emissions to each `Observer`, ensuring that all Observers get
    all the data. Most data-driven Observables are cold, and this includes the `Observable.just()`
    and `Observable.fromIterable()` factories.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 冷观察量非常像一张可以被每位听众重放的音乐 CD，所以每个人都可以在任何时候听到所有曲目。同样，冷观察量将重新播放发射给每个 `Observer`，确保所有观察者都能获得所有数据。大多数数据驱动的观察量都是冷的，这包括
    `Observable.just()` 和 `Observable.fromIterable()` 工厂。
- en: 'In the following example, we have two Observers subscribed to one `Observable`.
    The `Observable` will first play all the emissions to the first `Observer` and
    then call `onComplete()`. Then, it will play all the emissions again to the second
    `Observer` and call `onComplete()`. They both receive the same datasets by getting
    two separate streams each, which is typical behavior for a cold `Observable`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有两个观察者订阅了一个 `Observable`。`Observable` 将首先将所有发射传递给第一个 `Observer` 并调用
    `onComplete()`。然后，它将再次将所有发射传递给第二个 `Observer` 并调用 `onComplete()`。他们各自通过获取两个单独的流接收相同的数据集，这是冷
    `Observable` 的典型行为：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Even if the second `Observer` transforms its emissions with operators, it will
    still get its own stream of emissions. Using operators such as `map()` and `filter()`
    against a cold `Observable` will still maintain the cold nature of the yielded
    Observables:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 即使第二个 `Observer` 使用操作符转换其发射，它仍然会得到自己的发射流。对冷 `Observable` 使用如 `map()` 和 `filter()`
    这样的操作符仍然会保持产生的观察量的冷性质：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As stated earlier, `Observable` sources that emit finite datasets are usually
    cold.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，发射有限数据集的 `Observable` 源通常是冷的。
- en: 'Here is a more real-world example: Dave Moten''s RxJava-JDBC ([https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc))
    allows you to create cold Observables built off of SQL database queries. We will
    not digress into this library for too long, but if you want to query a SQLite
    database, for instance, include the **SQLite JDBC** driver and **RxJava-JDBC**
    libraries in your project. You can then query a database table reactively, as
    shown in the following code snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更贴近现实世界的例子：Dave Moten 的 RxJava-JDBC ([https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc))
    允许你基于 SQL 数据库查询创建冷观察量。我们不会过多地深入这个库，但如果你想要查询 SQLite 数据库，例如，在你的项目中包含 **SQLite JDBC**
    驱动和 **RxJava-JDBC** 库。然后你可以以响应式的方式查询数据库表，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This SQL-driven `Observable` is cold. Many Observables emitting from finite
    data sources such as databases, text files, or JSON are cold. It is still important
    to note how the source `Observable` is architected. RxJava-JDBC will run the query
    each time for each `Observer`. This means that if the data changes in between
    two subscriptions, the second `Observer` will get different emissions than the
    first one. But the `Observable` is still cold since it is *r*eplaying the query
    even if the resulting data changes from the underlying tables.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个由 SQL 驱动的 `Observable` 是冷的。许多来自有限数据源（如数据库、文本文件或 JSON）的 `Observable` 都是冷的。仍然重要的是要注意源
    `Observable` 的架构。RxJava-JDBC 将为每个 `Observer` 运行查询。这意味着如果在两次订阅之间数据发生变化，第二个 `Observer`
    将获得与第一个不同的输出。但由于 `Observable` 正在重新执行查询（即使结果数据从底层表中更改），它仍然是冷的。
- en: Again, cold Observables will, in some shape or form, repeat the operation to
    generate these emissions to each `Observer`. Next, we will cover **hot Observables** that
    resemble events more than data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，冷观察者将以某种形式重复操作以向每个 `Observer` 生成这些输出。接下来，我们将介绍更类似于事件而不是数据的 **热观察者**。
- en: Hot Observables
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热观察者
- en: You just learned about the cold `Observable`, which works much like a music
    CD. A hot `Observable` is more like a radio station. It broadcasts the same emissions
    to all Observers at the same time. If an `Observer` subscribes to a hot `Observable`,
    receives some emissions, and then another `Observer` comes in afterwards, that
    second `Observer` will have missed those emissions. Just like a radio station,
    if you tune in too late, you will have missed that song.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚了解了冷 `Observable`，它的工作方式类似于音乐 CD。热 `Observable` 更像是一个广播电台。它同时向所有观察者广播相同的输出。如果观察者订阅了一个热
    `Observable`，接收了一些输出，然后另一个观察者随后加入，那么第二个观察者将错过那些输出。就像广播电台一样，如果你调得太晚，就会错过那首歌。
- en: Logically, hot Observables often represent events rather than finite datasets.
    The events can carry data with them, but there is a time-sensitive component where
    late observers can miss previously emitted data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，热观察者通常表示事件而不是有限的数据集。事件可以携带数据，但存在一个时间敏感的组件，晚到的观察者可能会错过之前发出的数据。
- en: 'For instance, a JavaFX or Android UI event can be represented as a hot `Observable`.
    In JavaFX, you can create an `Observable<Boolean>` off a `selectedProperty()`
    operator of a  `ToggleButton` using `Observable.create()`. You can then transform
    the Boolean emissions into strings indicating whether the `ToggleButton` is `UP` or
    `DOWN` and then use an `Observer` to display them in `Label`, as shown in the
    following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JavaFX 或 Android UI 事件可以表示为一个热 `Observable`。在 JavaFX 中，你可以使用 `Observable.create()`
    创建一个基于 `ToggleButton` 的 `selectedProperty()` 操作符的 `Observable<Boolean>`。然后，你可以将布尔输出转换为表示
    `ToggleButton` 是 `UP` 还是 `DOWN` 的字符串，并使用 `Observer` 在 `Label` 中显示它们，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](img/bfa2c770-eb35-4685-93bf-ad6f70c10966.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfa2c770-eb35-4685-93bf-ad6f70c10966.png)'
- en: A JavaFX app backed by a hot **Observable<Boolean>** created off a **ToggleButton**'s
    selection state
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `ToggleButton` 的选择状态创建的热 `Observable<Boolean>` 支持的 JavaFX 应用
- en: Note that if you are using OpenJDK, you will need to get the JavaFX library
    separately. It is easiest to use Oracle's official JDK, which includes JavaFX
    and is available at [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你使用 OpenJDK，你需要单独获取 JavaFX 库。最简单的方法是使用 Oracle 的官方 JDK，它包含 JavaFX，可在 [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)
    获取。
- en: A JavaFX `ObservableValue` has nothing to do with an RxJava `Observable`. It
    is proprietary to JavaFX, but we can easily turn it into an RxJava `Observable`
    using the `valuesOf()` factory implemented earlier to hook `ChangeListener` as
    an `onNext()` call. Every time you click on the `ToggleButton`, the  `Observable<Boolean>`
    will emit a `true` or `false` reflecting the selection state. This is a simple
    example, showing that this `Observable` is emitting events but is also emitting
    data in the form of `true` or `false`. It will transform that boolean into a string
    and have an Observer modify a text of `Label`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 的 `ObservableValue` 与 RxJava 的 `Observable` 没有任何关系。它是 JavaFX 的专有技术，但我们可以通过之前实现的
    `valuesOf()` 工厂方法轻松地将它转换成 RxJava 的 `Observable`，并将 `ChangeListener` 作为 `onNext()`
    调用挂钩。每次点击 `ToggleButton`，`Observable<Boolean>` 都会发出 `true` 或 `false`，反映选择状态。这是一个简单示例，说明这个
    `Observable` 正在发出事件，同时也以 `true` 或 `false` 的形式发出数据。它将布尔值转换为字符串，并让观察者修改 `Label`
    的文本。
- en: We only have one Observer in this JavaFX example. If we were to bring in more
    Observers to this `ToggleButton`'s events after emissions have occurred, those
    new Observers will have missed these emissions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个JavaFX示例中，我们只有一个观察者。如果我们在这个`ToggleButton`的事件发生后引入更多的观察者，那些新的观察者将错过这些事件。
- en: UI events on JavaFX and Android are prime examples of hot Observables, but you
    can also use hot Observables to reflect server requests. If you created an `Observable`
    off a live Twitter stream emitting tweets for a certain topic, that also would
    be a hot `Observable`**.** All of these sources are likely infinite, and while
    many hot Observables are indeed infinite, they do not have to be. They just have
    to share emissions to all Observers simultaneously and not replay missed emissions
    for tardy Observers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX和Android上的UI事件是热Observables的典型例子，但你也可以使用热Observables来反映服务器请求。如果你创建了一个从实时Twitter流中发出特定主题推文的`Observable`，那也将是一个热`Observable`**。**所有这些来源都可能无限，虽然许多热Observables确实是无限的，但它们不必是无限的。它们只需同时将事件共享给所有观察者，并且不会为迟到的观察者重新播放错过的事件。
- en: Note that RxJavaFX (as well as RxAndroid, covered in [Chapter 11](4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml),
    *RxJava on Android*) has factories to turn various UI events into Observables
    and bindings for you. Using RxJavaFX, you can simplify the previous example using
    the `valuesOf()` factory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，RxJavaFX（以及在第11章中介绍的RxAndroid，*RxJava在Android上*）有将各种UI事件转换为Observables的工厂和绑定。使用RxJavaFX，你可以使用`valuesOf()`工厂简化前面的示例。
- en: Note that we did leave a loose end with this JavaFX example, as we never handled
    disposal. We will revisit this when we cover Disposables at the end of this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这个JavaFX示例中确实留下了一个悬而未决的问题，因为我们从未处理过销毁。我们将在本章末尾介绍Disposables时重新讨论这个问题。
- en: ConnectableObservable
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ConnectableObservable
- en: 'A helpful form of hot `Observable` is `ConnectableObservable`. It will take
    any `Observable`, even if it is cold, and make it hot so that all emissions are
    played to all Observers at once. To do this conversion, you simply need to call `publish()`
    on any `Observable`, and it will yield a `ConnectableObservable`. But subscribing
    will not start the emissions yet. You need to call its `connect()` method to start
    firing the emissions. This allows you to set up all your Observers beforehand.
    Take a look at the following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 热Observables的一种有用形式是`ConnectableObservable`。它可以将任何`Observable`（即使是冷的）转换为热Observables，以便所有事件一次播放给所有观察者。为此转换，你只需在任意的`Observable`上调用`publish()`，它将产生一个`ConnectableObservable`。但是订阅不会立即开始事件发射。你需要调用它的`connect()`方法来开始发射事件。这允许你事先设置好所有的观察者。看看下面的代码片段：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Take a look at the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note how one Observer is receiving the string while the other is receiving the
    length and the two are printing them in an interleaved fashion. Both subscriptions
    are set up beforehand, and then `connect()` is called to fire the emissions. Rather
    than `Observer 1` processing all the emissions before `Observer 2`, each emission
    goes to each Observer simultaneously. `Observer 1` receives `Alpha` and `Observer
    2` receives `5` and then `Beta` and `4`, and so on. Using `ConnectableObservable`
    to force each emission to go to all Observers simultaneously is known as **multicasting**,
    which we will cover in detail in [Chapter 5](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml),
    *Multicasting*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个观察者接收字符串，而另一个接收长度，并且它们以交错的方式打印它们。这两个订阅都在之前设置好，然后调用`connect()`来触发事件。不是`观察者1`在`观察者2`之前处理所有事件，每个事件同时发送给每个观察者。`观察者1`接收`Alpha`，`观察者2`接收`5`，然后是`Beta`和`4`，依此类推。使用`ConnectableObservable`强制每个事件同时发送给所有观察者称为**多播**，我们将在第5章*多播*中详细讨论。
- en: '`ConnectableObservable` is helpful in preventing the replay of data to each
    Observer. You may want to do this if replaying emissions is expensive and you
    would rather emit them to all Observers at once. You may also do it simply to
    force the operators upstream to use a single stream instance even if there are
    multiple Observers downstream. Multiple Observers normally result in multiple
    stream instances upstream, but using `publish()` to return `ConnectableObservable`
    consolidates all the upstream operations before `publish()` into a single stream.
    Again, these nuances will be covered more in [Chapter 5](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml),
    *Multicasting*.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectableObservable`有助于防止将数据重新播放给每个观察者。你可能想这样做，如果重新播放发射很昂贵，你更愿意一次性将它们发射给所有观察者。你也可能只是想强制上游操作符使用单个流实例，即使下游有多个观察者。通常，多个观察者会导致上游有多个流实例，但使用`publish()`返回`ConnectableObservable`将`publish()`之前的所有上游操作合并成一个单一的流。再次强调，这些细微差别将在[第5章](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml)，*多播*中更详细地介绍。'
- en: For now, remember that `ConnectableObservable` is hot, and therefore, if new
    subscriptions occur after `connect()` is called, they will miss emissions that
    were fired previously.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，请记住`ConnectableObservable`是热的，因此，如果在调用`connect()`之后发生新的订阅，它们将错过之前发射的发射。
- en: Other Observable sources
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Observable源
- en: We already covered a few factories to create `Observable` sources, including
    `Observable.create()`, `Observable.just()`, and `Observable.fromIterable()`. After
    our detour covering Observers and their nuances, let's pick up where we left off
    and cover a few more `Observable` factories.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些创建`Observable`源的工厂，包括`Observable.create()`、`Observable.just()`和`Observable.fromIterable()`。在介绍观察者和它们的细微差别之后，让我们继续之前的话题，并介绍一些更多的`Observable`工厂。
- en: Observable.range()
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.range()
- en: 'To emit a consecutive range of integers, you can use `Observable.range()`.
    This will emit each number from a start value and increment each emission until
    the specified count is reached. These numbers are all passed through the `onNext()`
    event, followed by the  `onComplete()` event:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要发射一个连续的整数范围，你可以使用`Observable.range()`。这将从起始值开始发射每个数字，并在达到指定的计数之前递增每个发射。这些数字都通过`onNext()`事件传递，然后是`onComplete()`事件：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note closely that the two arguments for **`Observable.range()`** are not lower/upper
    bounds. The first argument is the starting value. The second argument is the total
    count of emissions, which will include both the initial value and incremented
    values. Try emitting `Observable.range(5,10)`, and you will notice that it emits
    `5` followed by the next nine consecutive integers following it (for a grand total
    of 10 emissions):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细注意，`Observable.range()`的两个参数不是下限/上限。第一个参数是起始值。第二个参数是发射的总数，这包括初始值和递增的值。尝试发射`Observable.range(5,10)`，你会注意到它首先发射`5`，然后是接下来的九个连续整数（总共发射10次）：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that there is also a long equivalent called `Observable.rangeLong()` if
    you need to emit larger numbers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你需要发射更大的数字，还有一个长等效函数`Observable.rangeLong()`。
- en: Observable.interval()
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.interval()
- en: As we have seen, Observables have a concept of emissions over time. Emissions
    are handed from the source up to the Observer sequentially. But these emissions
    can be spaced out over time depending on when the source provides them. Our JavaFX
    example with `ToggleButton` demonstrated this, as each click resulted in an emission
    of `true` or `false`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Observables有一个随时间发射的概念。发射是按顺序从源传递到观察者的。但是，这些发射可以根据源提供它们的时间来分散。我们的JavaFX示例使用`ToggleButton`展示了这一点，因为每次点击都会导致发射`true`或`false`。
- en: 'But let''s look at a simple example of a time-based `Observable` using `Observable.interval()`.
    It will emit a consecutive long emission (starting at `0`) at every specified
    time interval. Here, we have an `Observable<Long>` that emits every second:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看看使用`Observable.interval()`的一个基于时间的`Observable`的简单示例。它将在每个指定的时间间隔发射一个连续的长整数发射（从`0`开始）。在这里，我们有一个每秒发射一次的`Observable<Long>`：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Observable.interval()` will emit infinitely at the specified interval (which
    is 1 second in this case). However, because it operates on a timer, it needs to
    run on a separate thread and will run on the computation **Scheduler** by default.
    We will cover concurrency in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Concurrency and Parallelization* and learn about schedulers. For now, just note
    that our  `main()` method is going to kick off this `Observable`, but it will
    not wait for it to finish. It is now emitting on a separate thread. To keep our
    `main()` method from finishing and exiting the application before our `Observable`
    has a chance to fire, we use a `sleep()` method to keep this application alive
    for five seconds. This gives our `Observable` five seconds to fire emissions before
    the application quits. When you create production applications, you likely will
    not run into this issue often as non-daemon threads for tasks such as web services,
    Android apps, or JavaFX will keep the application alive.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.interval()`将以指定的间隔无限发射（在本例中为1秒）。然而，因为它在计时器上操作，所以需要在单独的线程上运行，并且默认情况下将在计算**调度器**上运行。我们将在[第6章](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml)中介绍并发和并行化，并学习调度器。现在，只需注意我们的`main()`方法将启动这个`Observable`，但它不会等待它完成。现在它在一个单独的线程上发射。为了防止我们的`main()`方法在`Observable`有机会发射之前完成并退出应用程序，我们使用`sleep()`方法使这个应用程序保持活跃五秒钟。这给我们的`Observable`五秒钟的时间来发射，然后应用程序退出。当您创建生产应用程序时，您可能很少会遇到这个问题，因为像网络服务、Android应用程序或JavaFX这样的非守护线程将保持应用程序的活跃状态。'
- en: 'Trick question: does `Observable.interval()` return a hot or a cold `Observable`?
    Because it is event-driven (and infinite), you may be tempted to say it is hot.
    But put a second `Observer` on it, wait for five seconds, and then add another
    Observer. What happens? Let''s take a look:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 玩笑问题：`Observable.interval()`返回的是热可观察对象还是冷可观察对象？因为它是由事件驱动的（并且是无限的），您可能会想它是热的。但是，在它上面添加第二个`Observer`，等待五秒，然后添加另一个观察者。会发生什么？让我们看看：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Look what happened after five seconds elapsed, when `Observer 2` came in. Note
    that it is on its own separate timer and starting at `0`! These two observers
    are actually getting their own emissions, each starting at `0`. So this `Observable`
    is actually cold. To put all observers on the same timer with the same emissions,
    you will want to use `ConnectableObservable` to force these emissions to become
    hot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看看五秒后发生了什么，当`Observer 2`到来时。注意，它有自己的单独计时器，从`0`开始！这两个观察者实际上是在获取它们自己的发射，每个都是从`0`开始的。所以这个`Observable`实际上是冷的。为了将所有观察者放在同一个计时器上，并具有相同的发射，您将想要使用`ConnectableObservable`来强制这些发射变为热：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now `Observer 2`, although 5 seconds late and having missed the previous emissions,
    will at least be completely in sync with `Observer 1` and receive the same emissions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Observer 2`虽然晚了5秒并且错过了之前的发射，但至少与`Observer 1`完全同步，并接收到了相同的发射。
- en: Observable.future()
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Observable.future()`'
- en: 'RxJava Observables are much more robust and expressive than `Futures`, but
    if you have existing libraries that yield `Futures`, you can easily turn them
    into Observables via `Observable.future()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava的可观察对象（Observables）比`Futures`更加健壮和表达性强，但如果您有现有的库返回`Futures`，您可以通过`Observable.future()`轻松地将它们转换为可观察对象：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Observable.empty()
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Observable.empty()`'
- en: 'Although this may not seem useful yet, it is sometimes helpful to create an
    `Observable` that emits nothing and calls `onComplete()`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来目前没有太大用处，但有时创建一个不发射任何内容并调用`onComplete()`的可观察对象是有帮助的：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that no emissions were printed because there were none. It went straight
    to calling `onComplete` , which printed the `Done!` message in the Observer. Empty
    observables are common to represent empty datasets. They can also result from
    operators such as `filter()` when all emissions fail to meet a condition. Sometimes,
    you will deliberately create empty Observables using `Observable.empty()`, and
    we will see examples of this in a few places throughout this book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有打印任何发射，因为没有发射。它直接调用`onComplete`，在观察者中打印了`Done!`消息。空的可观察对象常用于表示空数据集。它们也可能由`filter()`等操作符产生，当所有发射都未能满足条件时。有时，您会故意使用`Observable.empty()`创建空的可观察对象，我们将在本书的几个地方看到这个例子。
- en: An empty Observable is essentially RxJava's concept of null. It is the absence
    of a value (or technically, "values"). Empty Observables are much more elegant
    than nulls because operations will simply continue empty rather than throw `NullPointerExceptions`.
    But when things go wrong in RxJava programs, sometimes it is because observers
    are receiving no emissions. When this happens, you have to trace through your
    Observable's chain of operators to find which one caused emissions to become empty.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的`Observable`基本上是RxJava的null概念。它是值的缺失（或者技术上，“值”）。空的`Observable`比null更优雅，因为操作将简单地继续为空而不是抛出`NullPointerExceptions`。但是，当RxJava程序中的事情出错时，有时是因为观察者没有收到任何发射物。当这种情况发生时，您必须追踪您的`Observable`的运算符链以找到导致发射物变为空的运算符。
- en: Observable.never()
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.never()
- en: 'A close cousin of `Observable.empty()` is `Observable.never()`. The only difference
    between them is that it never calls `onComplete()`, forever leaving observers
    waiting for emissions but never actually giving any:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.empty()`的一个近亲是`Observable.never()`。它们之间的唯一区别是它永远不会调用`onComplete()`，永远让观察者等待发射物，但永远不会实际提供任何：'
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This `Observable` is primarily used for testing and not that often in production.
    We have to use `sleep()` here just like `Observable.interval()` because the main
    thread is not going to wait for it after kicking it off. In this case, we just
    use `sleep()` for five seconds to prove that no emissions are coming from it.
    Then, the application will quit.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Observable`主要用于测试，在生产环境中并不常用。我们在这里必须使用`sleep()`，就像使用`Observable.interval()`一样，因为启动后主线程不会等待它。在这种情况下，我们只使用`sleep()`五秒钟来证明没有发射物来自它。然后，应用程序将退出。
- en: Observable.error()
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.error()
- en: 'This too is something you likely will only do with testing, but you can create
    an `Observable` that immediately calls `onError()` with a specified exception:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是您可能只会用于测试的事情，但您可以创建一个立即调用`onError()`并带有指定异常的`Observable`：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can also provide the exception through a lambda so that it is created from
    scratch and separate exception instances are provided to each Observer:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过lambda表达式提供异常，这样它就是从头创建的，并且为每个观察者提供单独的异常实例：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Observable.defer()
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.defer()
- en: '`Observable.defer()` is a powerful factory due to its ability to create a separate
    state for each `Observer`. When using certain `Observable` factories, you may
    run into some nuances if your source is stateful and you want to create a separate
    state for each `Observer`. Your source `Observable` may not capture something
    that has changed about its parameters and send emissions that are obsolete. Here
    is a simple example: we have an `Observable.range()` built off two static `int`
    properties, `start` and `count`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.defer()`是一个强大的工厂，因为它能够为每个`Observer`创建一个单独的状态。当使用某些`Observable`工厂时，如果您的源是状态性的并且您想要为每个`Observer`创建一个单独的状态，您可能会遇到一些细微差别。您的源`Observable`可能没有捕捉到其参数的变化，并发送了过时的发射物。这里有一个简单的例子：我们有一个基于两个静态`int`属性`start`和`count`的`Observable.range()`。'
- en: 'If you subscribe to this `Observable`, modify the count, and then subscribe
    again, you will find that the second `Observer` does not see this change:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您订阅了这个`Observable`，修改计数，然后再次订阅，您会发现第二个`Observer`看不到这个变化：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To remedy this problem of `Observable` sources not capturing state changes,
    you can create a fresh `Observable` for each subscription. This can be achieved
    using `Observable.defer()`, which accepts a lambda instructing how to create an
    `Observable` for every subscription. Because this creates a new `Observable` each
    time, it will reflect any changes driving its parameters:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决`Observable`源没有捕捉状态变化的问题，您可以为每个订阅创建一个新的`Observable`。这可以通过使用`Observable.defer()`来实现，它接受一个lambda表达式，指示如何为每个订阅创建一个`Observable`。因为每次都会创建一个新的`Observable`，所以它会反映其参数的任何变化：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That's better! When your `Observable` source is not capturing changes to the
    things driving it, try putting it in `Observable.defer()`. If your Observable
    source was implemented naively and behaves brokenly with more than one Observer
    (for example, it reuses an Iterator that only iterates data once), `Observable.defer()`
    provides a quick workaround for this as well.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好！当您的`Observable`源没有捕捉到驱动它的东西的变化时，尝试将其放入`Observable.defer()`。如果您的`Observable`源实现得过于简单并且与多个观察者（例如，它重用只迭代数据一次的迭代器）一起表现不佳，`Observable.defer()`也提供了一个快速解决方案。
- en: Observable.fromCallable()
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.fromCallable()
- en: 'If you need to perform a calculation or action and then emit it, you can use
    `Observable.just()` (or `Single.just()` or `Maybe.just()`, which we will learn
    about later). But sometimes, we want to do this in a lazy or deferred manner.
    Also, if that procedure throws an error, we want it to be emitted up the `Observable`
    chain through `onError()` rather than throw the error at that location in traditional
    Java fashion. For instance, if you try to wrap `Observable.just()` around an expression
    that divides  `1` by `0`, the exception will be thrown, not emitted up to `Observer`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要执行一个计算或操作然后发射它，你可以使用 `Observable.just()`（或 `Single.just()` 或 `Maybe.just()`，我们将在后面学习），但有时我们希望以懒或延迟的方式执行。此外，如果该过程抛出错误，我们希望它通过
    `onError()` 发射到 `Observable` 链而不是在传统的 Java 风格中将错误抛出在那个位置。例如，如果你尝试将 `Observable.just()`
    包裹在一个除以 `0` 的表达式中，异常将被抛出，而不是发射到 `Observer`：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we are going to be reactive in our error handling, this may not be desirable.
    Perhaps you would like the error to be emitted down the chain to the `Observer`
    where it will be handled. If that is the case, use `Observable.fromCallable()`
    instead, as it accepts a lambda `Supplier<T>` and it will emit any error that
    occurs down to `Observer`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算在错误处理方面做出反应，这可能不是所希望的。也许你希望错误被发射到链中的 `Observer`，在那里它将被处理。如果是这种情况，请使用 `Observable.fromCallable()`，因为它接受一个
    lambda `Supplier<T>`，并且它将发射任何发生到 `Observer` 的错误：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That is better! The error was emitted to the `Observer` rather than being thrown
    where it occurred. If initializing your emission has a likelihood of throwing
    an error, you should use `Observable.fromCallable()` instead of `Observable.just()`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好！错误被发射到了 `Observer`，而不是在发生错误的地方抛出。如果你初始化发射有抛出错误的可能性，你应该使用 `Observable.fromCallable()`
    而不是 `Observable.just()`。
- en: Single, Completable, and Maybe
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Single, Completable, and Maybe
- en: 'There are a few specialized flavors of `Observable` that are explicitly set
    up for one or no emissions: `Single`, `Maybe`, and `Completable`. These all follow
    the `Observable` closely and should be intuitive to use in your reactive coding
    workflow. You can create them in similar ways as the `Observable` (for example,
    they each have their own `create()` factory), but certain `Observable` operators
    may return them too.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种专门的 `Observable` 类型是明确为单个或零个发射而设置的：`Single`、`Maybe` 和 `Completable`。这些都与
    `Observable` 非常接近，并且应该在你的响应式编码工作流程中使用起来很直观。你可以用类似 `Observable` 的方式创建它们（例如，它们各自都有自己的
    `create()` 工厂），但某些 `Observable` 操作符也可能返回它们。
- en: Single
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Single
- en: '`Single<T>` is essentially an `Observable<T>` that will only emit one item.
    It works just like an Observable, but it is limited only to operators that make
    sense for a single emission. It has its own `SingleObserver` interface as well:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single<T>` 实质上是一个只发射一个项目的 `Observable<T>`。它的工作方式与可观察者类似，但它仅限于对单个发射有意义的操作符。它还有一个自己的
    `SingleObserver` 接口：'
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `onSuccess()` essentially consolidates `onNext()` and `onComplete()` into
    a single event that accepts the one emission. When you call `subscribe()` against
    a Single, you provide the lambdas for `onSuccess()` as well as an optional `onError()`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSuccess()` 实质上将 `onNext()` 和 `onComplete()` 合并成一个接受一个发射的单个事件。当你对一个 Single
    调用 `subscribe()` 时，你提供 `onSuccess()` 的 lambda 以及可选的 `onError()`：'
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Certain RxJava Observable operators will yield a Single, as we will see in
    the next chapter. For instance, the `first()` operator will return a Single since
    that operator is logically concerned with a single item. However, it accepts a
    default value as a parameter (which I specified as `Nil` in the following example)
    if the Observable comes out empty:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 RxJava 可观察者操作符将产生一个 Single，我们将在下一章中看到。例如，`first()` 操作符将返回一个 Single，因为该操作符在逻辑上只关注单个项目。然而，如果可观察者返回空值，它将接受一个默认值作为参数（以下示例中我将其指定为
    `Nil`）：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Single` must have one emission, and you should prefer it if you only have
    one emission to provide. This means that instead of using `Observable.just("Alpha")`,
    you should try to use `Single.just("Alpha")` instead. There are operators on `Single`
    that will allow you to turn it into an `Observable` when needed, such as `toObservable()`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single` 必须有一个发射，如果你只有一个发射要提供，你应该优先选择它。这意味着，而不是使用 `Observable.just("Alpha")`，你应该尝试使用
    `Single.just("Alpha")`。`Single` 上有操作符可以将它转换为 `Observable`，例如 `toObservable()`。'
- en: If there are `0` or `1` emissions, you will want to use `Maybe`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有 `0` 或 `1` 个发射，你将想要使用 `Maybe`。
- en: Maybe
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maybe
- en: '`Maybe` is just like a `Single` except that it allows no emission to occur
    at all (hence `Maybe`). `MaybeObserver` is much like a standard Observer, but
    `onNext()` is called `onSuccess()` instead:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe` 与 `Single` 类似，但它允许根本不发生事件（因此称为 `Maybe`）。`MaybeObserver` 与标准观察者非常相似，但
    `onNext()` 被称为 `onSuccess()`：'
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A given `Maybe<T>` will only emit `0` or  `1` emissions. It will pass the possible
    emission to `onSuccess()`, and in either case, it will call `onComplete()` when
    done. `Maybe.just()` can be used to create a `Maybe` emitting the single item.
    `Maybe.empty()` will create a `Maybe` that yields no emission:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 `Maybe<T>` 只会发出 `0` 或 `1` 个事件。它会将可能的事件传递给 `onSuccess()`，并在完成时调用 `onComplete()`。`Maybe.just()`
    可以用来创建发出单个项的 `Maybe`，而 `Maybe.empty()` 将创建一个不产生任何事件的 `Maybe`：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Certain `Observable` operators that we will learn about later yield a `Maybe`.
    One example is the `firstElement()` operator, which is similar to `first()`, but
    it returns an empty result if no elements are emitted:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将要学习的某些 `Observable` 操作符会返回一个 `Maybe`。一个例子是 `firstElement()` 操作符，它与 `first()`
    类似，但如果没有任何事件被发射，它将返回一个空的结果：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Completable
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可完成性
- en: '`Completable` is simply concerned with an action being executed, but it does
    not receive any emissions. Logically, it does not have  `onNext()` or `onSuccess()`
    to receive emissions, but it does have `onError()` and `onComplete()`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Completable` 仅关注一个动作的执行，但它不会接收任何事件。从逻辑上讲，它没有 `onNext()` 或 `onSuccess()` 来接收事件，但它确实有
    `onError()` 和 `onComplete()`：'
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Completable is something you likely will not use often. You can construct one
    quickly by calling `Completable.complete()` or `Completable.fromRunnable()`. The
    former will immediately call `onComplete()` without doing anything, while `fromRunnable()`
    will execute the specified action before calling `onComplete()`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Completable` 是你可能不会经常使用的东西。你可以通过调用 `Completable.complete()` 或 `Completable.fromRunnable()`
    快速构建一个。前者会立即调用 `onComplete()` 而不执行任何操作，而 `fromRunnable()` 将在调用 `onComplete()`
    之前执行指定的动作：'
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Disposing
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: When you `subscribe()` to an Observable to receive emissions, a stream is created
    to process these emissions through the Observable chain. Of course, this uses
    resources. When we are done, we want to dispose of these resources so that they
    can be garbage-collected. Thankfully, the finite Observables that call `onComplete()`
    will typically dispose of themselves safely when they are done. But if you are
    working with infinite or long-running Observables, you likely will run into situations
    where you want to explicitly stop the emissions and dispose of everything associated
    with that subscription. As a matter of fact, you cannot trust the garbage collector
    to take care of active subscriptions that you no longer need, and explicit disposal
    is necessary in order to prevent memory leaks.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你订阅一个 `Observable` 来接收事件时，会创建一个流来处理这些事件通过 `Observable` 链。当然，这会使用资源。当我们完成时，我们想要清理这些资源，以便它们可以被垃圾回收。幸运的是，调用
    `onComplete()` 的有限 `Observable` 通常会在完成时安全地清理自己。但是，如果你正在处理无限或长时间运行的 `Observable`，你可能会遇到想要明确停止事件发射并清理与该订阅相关的一切的情况。实际上，你不能依赖垃圾回收器来处理不再需要的活动订阅，显式清理是防止内存泄漏所必需的。
- en: 'The Disposable is a link between an Observable and an active Observer, and
    you can call its `dispose()` method to stop emissions and dispose of all resources
    used for that Observer. It also has an `isDisposed()` method, indicating whether
    it has been disposed of already:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Disposable` 是 `Observable` 和活动观察者之间的一个链接，你可以调用它的 `dispose()` 方法来停止事件发射并清理用于该观察者的所有资源。它还有一个
    `isDisposed()` 方法，指示它是否已经被清理：'
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When you provide `onNext()`, `onComplete()`, and/or `onError()` lambdas as
    arguments to the `subscribe()` method,  it will actually return a `Disposable`.
    You can use this to stop emissions at any time by calling its `dispose()` method.
    For instance, we can stop receiving emissions from an `Observable.interval()`
    after five seconds:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 `onNext()`、`onComplete()` 和/或 `onError()` 作为参数传递给 `subscribe()` 方法时，它实际上会返回一个
    `Disposable`。你可以通过调用其 `dispose()` 方法在任何时候停止事件发射。例如，我们可以在五秒后停止接收来自 `Observable.interval()`
    的发射：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we let `Observable.interval()` run for five seconds with an Observer,
    but we save the Disposable returned from the `subscribe()` method. Then we call
    the Disposable's `dispose()` method to stop the process and free any resources
    that were being used. Then, we sleep for another five seconds just to prove that
    no more emissions are happening.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们让 `Observable.interval()` 在一个观察者中运行五秒钟，但我们保存了从 `subscribe()` 方法返回的 `Disposable`。然后我们调用
    `Disposable` 的 `dispose()` 方法来停止进程并释放任何正在使用的资源。然后，我们再睡五秒钟，只是为了证明没有更多的发射发生。
- en: Handling a Disposable within an Observer
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在观察者内部处理销毁
- en: Earlier, I shied away from talking about the `onSubscribe()` method in the `Observer`,
    but now we will address it. You may have noticed that `Disposable` is passed in
    the implementation of an `Observer` through the `onSubscribe()` method. This method
    was added in RxJava 2.0, and it allows the `Observer` to have the ability to dispose
    of the subscription at any time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我回避了在 `Observer` 中谈论 `onSubscribe()` 方法，但现在我们将解决这个问题。你可能已经注意到，`Disposable`
    是通过 `onSubscribe()` 方法在 `Observer` 的实现中传递的。这个方法是在 RxJava 2.0 中添加的，它允许 `Observer`
    在任何时候都有权取消订阅。
- en: 'For instance, you can implement your own `Observer` and use `onNext()`, `onComplete()`,
    or `onError()` to have access to the `Disposable`.This way, these three events
    can call `dispose()` if, for whatever reason, the `Observer` does not want any
    more emissions:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以实现自己的 `Observer` 并使用 `onNext()`、`onComplete()` 或 `onError()` 来访问 `Disposable`。这样，这三个事件可以在
    `Observer` 不想接收更多发射的任何原因下调用 `dispose()`：
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `Disposable` is sent from the source all the way up the chain to the Observer,
    so each step in the `Observable` chain has access to the Disposable.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Disposable` 从源头一路传递到观察者，所以 `Observable` 链中的每一步都有权访问 `Disposable`。'
- en: 'Note that passing an `Observer` to the `subscribe()` method will be void and
    not return a `Disposable` since it is assumed that the `Observer` will handle
    it. If you do not want to explicitly handle the `Disposable` and want RxJava to
    handle it for you (which is probably a good idea until you have reason to take
    control), you can extend `ResourceObserver` as your Observer, which uses a default
    `Disposable` handling. Pass this to `subscribeWith()` instead of `subscribe()`,
    and you will get the default `Disposable` returned:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将 `Observer` 传递给 `subscribe()` 方法将无效，并且不会返回 `Disposable`，因为假设 `Observer`
    将处理它。如果你不想显式处理 `Disposable`，并希望 RxJava 为你处理（这可能是一个好主意，直到你有理由接管），你可以扩展 `ResourceObserver`
    作为你的观察者，它使用默认的 `Disposable` 处理。将此传递给 `subscribeWith()` 而不是 `subscribe()`，你将获得默认的
    `Disposable` 返回：
- en: '[PRE67]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Using CompositeDisposable
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `CompositeDisposable`
- en: 'If you have several subscriptions that need to be managed and disposed of,
    it can be helpful to use `CompositeDisposable`. It implements `Disposable`, but
    it internally holds a collection of `disposables`, which you can add to and then
    dispose all at once:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要管理并销毁多个订阅，使用 `CompositeDisposable` 可能会有所帮助。它实现了 `Disposable`，但内部持有 `disposables`
    的集合，你可以添加到其中，然后一次性销毁所有：
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`CompositeDisposable` is a simple but helpful utility to maintain a collection
    of `disposables` that you can add to by calling `add()` or `addAll()`. When you
    no longer want these subscriptions, you can call `dispose()` to dispose of all
    of them at once.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompositeDisposable` 是一个简单但有用的实用工具，可以维护一个你可以通过调用 `add()` 或 `addAll()` 添加的
    `disposables` 集合。当你不再需要这些订阅时，你可以调用 `dispose()` 一次性销毁所有这些。'
- en: Handling Disposal with Observable.create()
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `Observable.create()` 处理销毁
- en: If your `Observable.create()` is returning a long-running or infinite `Observable`,
    you should ideally check the `isDisposed()` method of `ObservableEmitter` regularly,
    to see whether you should keep sending emissions. This prevents unnecessary work
    from being done if the subscription is no longer active.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 `Observable.create()` 返回一个长时间运行或无限的 `Observable`，你应该理想地定期检查 `ObservableEmitter`
    的 `isDisposed()` 方法，以查看你是否应该继续发送发射。这可以防止在订阅不再活跃时进行不必要的操作。
- en: 'In this case, you should use `Observable.range()`, but for the sake of the
    example, let''s say we are emitting integers in a `for` loop in `Observable.create()`.
    Before emitting each integer, you should make sure that `ObservableEmitter` does
    not indicate that a disposal was called:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该使用 `Observable.range()`，但为了举例，让我们假设我们在 `Observable.create()` 中的 `for`
    循环中发射整数。在发射每个整数之前，你应该确保 `ObservableEmitter` 没有指示已经调用销毁：
- en: '[PRE69]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If your `Observable.create()` is wrapped around some resource, you should also
    handle the disposal of that resource to prevent leaks. `ObservableEmitter` has
    the `setCancellable()` and `setDisposable()` methods for that. In our earlier
    JavaFX example, we should remove the  `ChangeListener` from our JavaFX `ObservableValue`
    when a disposal occurs. We can provide a lambda to `setCancellable()`, which will
    execute the following action for us, which will occur when `dispose()` is called:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 `Observable.create()` 包围了一些资源，你也应该处理该资源的释放以防止泄漏。`ObservableEmitter` 有 `setCancellable()`
    和 `setDisposable()` 方法来处理。在我们的早期 JavaFX 示例中，当发生释放操作时，我们应该从我们的 JavaFX `ObservableValue`
    中移除 `ChangeListener`。我们可以提供一个 lambda 表达式给 `setCancellable()`，它将执行以下操作，当调用 `dispose()`
    时会发生：
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was an intense chapter, but it will provide a solid foundation as you learn
    how to use RxJava to tackle real-world work. RxJava, with all of its expressive
    power, has some nuances that are entirely due to the change of mindset it demands.
    It has done an impressive amount of work taking an imperative language like Java
    and adapting it to become reactive and functional. But this interoperability requires
    some understanding of the implementations between an `Observable` and a `Observer`.
    We touched on various ways to create Observables as well as how they interact
    with Observers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个充满挑战的章节，但当你学习如何使用 RxJava 来处理现实世界的工作时，它将为你提供一个坚实的基础。RxJava，凭借其强大的表达能力，有一些细微之处完全是因为它要求的心态转变。它已经做了令人印象深刻的工作，将像
    Java 这样的命令式语言适应成反应式和函数式。但这种互操作性需要理解 `Observable` 和 `Observer` 之间的实现细节。我们讨论了创建
    Observables 的各种方法以及它们如何与 Observers 交互。
- en: Take your time trying to digest all this information but do not let it stop
    you from moving on to the next two chapters, where the usefulness of RxJava starts
    to take formation. In the next chapters, the pragmatic usefulness of RxJava will
    start to become clear.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细消化所有这些信息，但不要让它阻止你继续阅读下一章，在那里 RxJava 的实用性开始形成。在下一章中，RxJava 的实用价值将开始变得清晰。
