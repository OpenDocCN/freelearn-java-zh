- en: Observables and Subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already got a glimpse into the `Observable` and how it works in [Chapter
    1](aba3c4b9-d382-43b5-b81a-495d3b2ca605.xhtml), *Thinking Reactively*. You probably
    have many questions on how exactly it operates and what practical applications
    it holds. This chapter will provide a foundation for understanding how an `Observable`
    works as well as the critical relationship it has with the `Observer`**.** We
    will also cover several ways to create an `Observable` as well make it useful
    by covering a few operators. To make the rest of the book flow smoothly, we will
    also cover all critical nuances head-on to build a solid foundation and not leave
    you with surprises later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Observable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Observer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other `Observable` factories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Single`, `Completable`, and `Maybe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disposable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As introduced in [Chapter 1](aba3c4b9-d382-43b5-b81a-495d3b2ca605.xhtml), *Thinking
    Reactively*, the `Observable` is a push-based**,** composable iterator. For a
    given `Observable<T>`, it pushes items (called emissions) of type `T` through
    a series of operators until it finally arrives at a final Observer, which consumes
    the items. We will cover several ways to create an `Observable`, but first, let's
    dive into how an `Observable` works through its `onNext()`, `onCompleted()`, and
    `onError()` calls.
  prefs: []
  type: TYPE_NORMAL
- en: How Observables work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we do anything else, we need to study how an `Observable` sequentially
    passes items down a chain to an `Observer`. At the highest level, an `Observable`
    works by passing three types of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onNext()`: This passes each item one at a time from the source `Observable`
    all the way down to the `Observer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete()`: This communicates a completion event all the way down to the
    `Observer`, indicating that no more `onNext()` calls will occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError()`: This communicates an error up the chain to the `Observer`, where
    the `Observer` typically defines how to handle it. Unless a `retry()` operator
    is used to intercept the error, the `Observable` chain typically terminates, and
    no more emissions will occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three events are abstract methods in the `Observer` type, and we will
    cover some of the implementation later. For now, we will focus pragmatically on
    how they work in everyday usage.
  prefs: []
  type: TYPE_NORMAL
- en: In RxJava 1.0, the `onComplete()` event is actually called `onCompleted()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Observable.create()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with creating a source `Observable` using `Observable.create()`.
    Relatively speaking, a source `Observable` is an `Observable` where emissions
    originate from and is the starting point of our `Observable` chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observable.create()` factory allows us to create an `Observable` by providing
    a lambda receiving an `Observable` emitter**.** We can call the `Observable` emitter''s
    `onNext()` method to pass emissions  (one a time) up the chain as well as `onComplete()`
    to signal completion and communicate that there will be no more items. These `onNext()`
    calls will pass these items up the chain towards the `Observer`, where it will
    print each item, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In RxJava 1.0, ensure that you use `Observable.fromEmitter()` instead of `Observable.create()`.
    The latter is something entirely different in RxJava 1.0 and is only for advanced
    RxJava users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onNext()` method is a way to hand each item, starting with `Alpha`, to
    the next step in the chain. In this example, the next step is the Observer, which
    prints the item using the **`s -> System.out.println("RECEIVED: " + s)`** lambda.
    This lambda is invoked in the `onNext()` call of `Observer`, and we will  look
    at `Observer` more closely in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Observable` contract ([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))
    dictates that emissions must be passed sequentially and one at a time. Emissions
    cannot be passed by an `Observable` concurrently or in parallel. This may seem
    like a limitation, but it does in fact simplify programs and make Rx easier to
    reason with. We will learn some powerful tricks to effectively leverage concurrency
    and parallelization in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Concurrency and Parallelization* , without breaking the `Observable` contract.
  prefs: []
  type: TYPE_NORMAL
- en: The `onComplete()` method is used to communicate up the chain to the `Observer`
    that no more items are coming. Observables can indeed be infinite, and if this
    is the case, the `onComplete()` event will never be called. Technically, a source
    could stop emitting `onNext()` calls and never call `onComplete()`. This would
    likely be bad design, though, if the source no longer plans to send emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this particular example is unlikely to throw an error, we can catch
    errors that may occur within our `Observable.create()` block and emit them through
    `onError()`.This way, the error can be pushed up the chain and handled by th**e**
    `Observer`. This particular `Observer` that we have set up does not handle exceptions,
    but you can do that, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `onNext()`, `onComplete()`, and `onError()` do not necessarily push
    directly to the final Observer. They can also push to an operator serving as the
    next step in the chain. In the following code, we derive new Observables with
    the `map()` and `filter()` operators, which will act between the source `Observable`
    and final `Observer` printing the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output after running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the `map()` and `filter()` operators between the source `Observable` and
    Observer, ` onNext()` will hand each item to the  `map()` operator. Internally,
    it will act as an intermediary Observer and convert each string to its `length()`.
    This, in turn, will call `onNext()` on `filter()` to pass that integer, and the
    lambda condition `i -> i >= 5` will suppress emissions that fail to be at least
    five characters in length. Finally, the `filter()` operator will call `onNext()`
    to hand each item to the final `Observer` where they will be printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is critical to note that the `map()` operator will yield a new `Observable<Integer>` derived
    off the original `Observable<String>`. The `filter()`will also return an `Observable<Integer>`
    but ignore emissions that fail to meet the criteria. Since operators such as `map()`
    and `filter()` yield new Observables (which internally use `Observer` implementations
    to receive emissions), we can chain all our returned Observables with the next
    operator rather than unnecessarily saving each one to an intermediary variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Chaining operators in this way is common (and encouraged) in reactive programming.
    It has a nice quality of being readable from left to right and top to bottom much
    like a book, and this helps in maintainability and legibility.
  prefs: []
  type: TYPE_NORMAL
- en: In RxJava 2.0, Observables no longer support emitting null values. You will
    immediately get a non-null exception if you create an `Observable` that attempts
    to emit a null value. If you need to emit a null, consider wrapping it in a Java
    8 or Google Guava Optional.
  prefs: []
  type: TYPE_NORMAL
- en: Using Observable.just()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at the `subscribe()` method a bit more, note that you likely
    will not need to use `Observable.create()` often. It can be helpful in hooking
    into certain sources that are not reactive, and we will see this in a couple of
    places later in this chapter. But typically, we use streamlined factories to create
    Observables for common sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example with `Observable.create()`, we could have used `Observable.just()`
    to accomplish this. We can pass it up to 10 items that we want to emit. It will
    invoke the `onNext()` call for each one and then invoke `onComplete()` when they
    all have been pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `Observable.fromIterable()` to emit the items from any Iterable
    type, such as a `List`. It also will call `onNext()` for each element and then
    call `onComplete()` after the iteration is complete. You will likely use this
    factory frequently since Iterables in Java are common and can easily be made reactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will explore other factories to create Observables later in this chapter,
    but for now, let's put that on hold and learn more about Observers.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `onNext()`, `onComplete()`, and `onError()` methods actually define the
    Observer type, an abstract interface implemented throughout RxJava to communicate
    these events. This is the Observer definition in RxJava shown in the code snippet.
    Do not bother yourself about `onSubscribe()` for now, as we will cover it at the
    end of this chapter. Just bring your attention to the other three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Observers and source Observables are somewhat relative. In one context, a source
    Observable is where your `Observable` chain starts and where emissions originate.
    In our previous examples, you could say that the `Observable` returned from our
    `Observable.create()`method or `Observable.just()` is the source `Observable`.
    But to the `filter()` operator, the `Observable` returned from the `map()` operator
    is the source. It has no idea where the emissions are originating from, and it
    just knows that it is receiving emissions from the operator immediately upstream
    from it, which come from `map()`.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, each `Observable` returned by an operator is internally an Observer
    that receives, transforms, and relays emissions to the next `Observer` downstream.
    It does not know whether the next `Observer` is another operator or the final Observer
    at the end of the chain. When we talk about the `Observer`, we are often talking
    about the final Observer at the end of the `Observable` chain that consumes the
    emissions. But each operator, such as `map()` and `filter()`, also implements
    `Observer` internally.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn in detail about how operators are built in [Chapter 9](3108e794-df20-4efd-8a71-b4da8e3ae036.xhtml),
    *Transformers and Custom Operators*. For now, we will focus on using an `Observer`
    for the `subscribe()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In RxJava 1.0, the Subscriber essentially became a Observer in RxJava 2.0\.
    There is an `Observer` type in RxJava 1.0 that defines the three event methods,
    but the Subscriber is what you passed to the `subscribe()` method, and it is implemented
    `Observer`. In RxJava 2.0, a Subscriber only exists when talking about Flowables,
    which we will discuss in [Chapter 8](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml),
    *Flowables and Backpressure*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and subscribing to an Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you call the `subscribe()` method on an `Observable`, an `Observer` is
    used to consume these three events by implementing its methods. Instead of specifying
    lambda arguments like we were doing earlier, we can implement an `Observer` and
    pass an instance of it to the `subscribe()` method. Do not bother yourself about `onSubscribe()`
    at the moment. Just leave its implementation empty until we discuss it at the
    end of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We quickly create an `Observer<Integer>` that serves as our `Observer`, and
    it will receive integer length emissions. Our `Observer` receives emissions at
    the end of an `Observable` chain and serves as the endpoint where the emissions
    are consumed. By consumed, this means they reach the end of the process where
    they are written to a database, text file, a server response, displayed in a UI,
    or (in this case) just printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further explain this example in detail, we start with string emissions at
    our source. We declare our `Observer` in advance and pass it to the `subscribe()`
    method at the end of our `Observable` chain. Note that each string is transformed
    to its length. The `onNext()` method receives each integer length emission and
    prints it using `System.out.println("RECEIVED: " + value)`. We will not get any
    errors running this simple process, but if one did occur anywhere in our `Observable`
    chain, it will be pushed to our  `onError()` implementation on `Observer`, where
    the stack trace of `Throwable` will be printed. Finally, when the source has no
    more emissions (after pushing "`Epsilon`"), it will call `onComplete()` up the
    chain all the way to the Observer, where its `onComplete()` method will be called
    and print `Done!` to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand Observers with lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing an `Observer` is a bit verbose and cumbersome. Thankfully, the
    `subscribe()` method is overloaded to accept lambda arguments for our three events.
    This is likely what we will want to use for most cases, and we can specify three
    lambda parameters separated by commas: the `onNext` lambda, the `onError` lambda,
    and the `onComplete` lambda. For our previous example, we can consolidate our
    three method implementations using these three lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass these three lambdas as arguments to the `subscribe()` method, and
    it will use them to implement an `Observer` for us. This is much more concise
    and requires far less boilerplate code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there are other overloads for `subscribe()`. You can omit `onComplete()`
    and only implement `onNext()` and `onError()`. This will no longer perform any
    action for `onComplete()`, but there will likely be cases where you do not need
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have seen in earlier examples, you can even omit `onError` and just
    specify `onNext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, not implementing `onError()` is something you want to avoid doing in
    production. Errors that happen anywhere in the `Observable` chain will be propagated
    to `onError()` to be handled and then terminate the `Observable` with no more
    emissions. If you do not specify an action for `onError`, the error will go unhandled.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `retry()` operators to attempt recovery and resubscribe to an `Observable`
    if an error occurs. We will cover how to do that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is critical to note that most of the `subscribe()` overload variants (including
    the shorthand lambda ones we just covered) return a `Disposable` that we did not
    do anything with. `disposables` allow us to disconnect an `Observable` from an `Observer`
    so emissions are terminated early, which is critical for infinite or long-running
    Observables. We will cover `disposables` at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Cold versus hot Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are subtle behaviors in a relationship between an `Observable` and an
    `Observer` depending on how the `Observable` is implemented. A major characteristic
    to be aware of is cold versus hot Observables, which defines how Observables behave
    when there are multiple Observers. First, we will cover cold Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Cold Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cold Observables are much like a music CD that can be replayed to each listener,
    so each person can hear all the tracks at any time. In the same manner, cold Observables
    will replay the emissions to each `Observer`, ensuring that all Observers get
    all the data. Most data-driven Observables are cold, and this includes the `Observable.just()`
    and `Observable.fromIterable()` factories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have two Observers subscribed to one `Observable`.
    The `Observable` will first play all the emissions to the first `Observer` and
    then call `onComplete()`. Then, it will play all the emissions again to the second
    `Observer` and call `onComplete()`. They both receive the same datasets by getting
    two separate streams each, which is typical behavior for a cold `Observable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if the second `Observer` transforms its emissions with operators, it will
    still get its own stream of emissions. Using operators such as `map()` and `filter()`
    against a cold `Observable` will still maintain the cold nature of the yielded
    Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As stated earlier, `Observable` sources that emit finite datasets are usually
    cold.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a more real-world example: Dave Moten''s RxJava-JDBC ([https://github.com/davidmoten/rxjava-jdbc](https://github.com/davidmoten/rxjava-jdbc))
    allows you to create cold Observables built off of SQL database queries. We will
    not digress into this library for too long, but if you want to query a SQLite
    database, for instance, include the **SQLite JDBC** driver and **RxJava-JDBC**
    libraries in your project. You can then query a database table reactively, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This SQL-driven `Observable` is cold. Many Observables emitting from finite
    data sources such as databases, text files, or JSON are cold. It is still important
    to note how the source `Observable` is architected. RxJava-JDBC will run the query
    each time for each `Observer`. This means that if the data changes in between
    two subscriptions, the second `Observer` will get different emissions than the
    first one. But the `Observable` is still cold since it is *r*eplaying the query
    even if the resulting data changes from the underlying tables.
  prefs: []
  type: TYPE_NORMAL
- en: Again, cold Observables will, in some shape or form, repeat the operation to
    generate these emissions to each `Observer`. Next, we will cover **hot Observables** that
    resemble events more than data.
  prefs: []
  type: TYPE_NORMAL
- en: Hot Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You just learned about the cold `Observable`, which works much like a music
    CD. A hot `Observable` is more like a radio station. It broadcasts the same emissions
    to all Observers at the same time. If an `Observer` subscribes to a hot `Observable`,
    receives some emissions, and then another `Observer` comes in afterwards, that
    second `Observer` will have missed those emissions. Just like a radio station,
    if you tune in too late, you will have missed that song.
  prefs: []
  type: TYPE_NORMAL
- en: Logically, hot Observables often represent events rather than finite datasets.
    The events can carry data with them, but there is a time-sensitive component where
    late observers can miss previously emitted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a JavaFX or Android UI event can be represented as a hot `Observable`.
    In JavaFX, you can create an `Observable<Boolean>` off a `selectedProperty()`
    operator of a  `ToggleButton` using `Observable.create()`. You can then transform
    the Boolean emissions into strings indicating whether the `ToggleButton` is `UP` or
    `DOWN` and then use an `Observer` to display them in `Label`, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/bfa2c770-eb35-4685-93bf-ad6f70c10966.png)'
  prefs: []
  type: TYPE_IMG
- en: A JavaFX app backed by a hot **Observable<Boolean>** created off a **ToggleButton**'s
    selection state
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you are using OpenJDK, you will need to get the JavaFX library
    separately. It is easiest to use Oracle's official JDK, which includes JavaFX
    and is available at [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: A JavaFX `ObservableValue` has nothing to do with an RxJava `Observable`. It
    is proprietary to JavaFX, but we can easily turn it into an RxJava `Observable`
    using the `valuesOf()` factory implemented earlier to hook `ChangeListener` as
    an `onNext()` call. Every time you click on the `ToggleButton`, the  `Observable<Boolean>`
    will emit a `true` or `false` reflecting the selection state. This is a simple
    example, showing that this `Observable` is emitting events but is also emitting
    data in the form of `true` or `false`. It will transform that boolean into a string
    and have an Observer modify a text of `Label`.
  prefs: []
  type: TYPE_NORMAL
- en: We only have one Observer in this JavaFX example. If we were to bring in more
    Observers to this `ToggleButton`'s events after emissions have occurred, those
    new Observers will have missed these emissions.
  prefs: []
  type: TYPE_NORMAL
- en: UI events on JavaFX and Android are prime examples of hot Observables, but you
    can also use hot Observables to reflect server requests. If you created an `Observable`
    off a live Twitter stream emitting tweets for a certain topic, that also would
    be a hot `Observable`**.** All of these sources are likely infinite, and while
    many hot Observables are indeed infinite, they do not have to be. They just have
    to share emissions to all Observers simultaneously and not replay missed emissions
    for tardy Observers.
  prefs: []
  type: TYPE_NORMAL
- en: Note that RxJavaFX (as well as RxAndroid, covered in [Chapter 11](4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml),
    *RxJava on Android*) has factories to turn various UI events into Observables
    and bindings for you. Using RxJavaFX, you can simplify the previous example using
    the `valuesOf()` factory.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we did leave a loose end with this JavaFX example, as we never handled
    disposal. We will revisit this when we cover Disposables at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ConnectableObservable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A helpful form of hot `Observable` is `ConnectableObservable`. It will take
    any `Observable`, even if it is cold, and make it hot so that all emissions are
    played to all Observers at once. To do this conversion, you simply need to call `publish()`
    on any `Observable`, and it will yield a `ConnectableObservable`. But subscribing
    will not start the emissions yet. You need to call its `connect()` method to start
    firing the emissions. This allows you to set up all your Observers beforehand.
    Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note how one Observer is receiving the string while the other is receiving the
    length and the two are printing them in an interleaved fashion. Both subscriptions
    are set up beforehand, and then `connect()` is called to fire the emissions. Rather
    than `Observer 1` processing all the emissions before `Observer 2`, each emission
    goes to each Observer simultaneously. `Observer 1` receives `Alpha` and `Observer
    2` receives `5` and then `Beta` and `4`, and so on. Using `ConnectableObservable`
    to force each emission to go to all Observers simultaneously is known as **multicasting**,
    which we will cover in detail in [Chapter 5](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml),
    *Multicasting*.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConnectableObservable` is helpful in preventing the replay of data to each
    Observer. You may want to do this if replaying emissions is expensive and you
    would rather emit them to all Observers at once. You may also do it simply to
    force the operators upstream to use a single stream instance even if there are
    multiple Observers downstream. Multiple Observers normally result in multiple
    stream instances upstream, but using `publish()` to return `ConnectableObservable`
    consolidates all the upstream operations before `publish()` into a single stream.
    Again, these nuances will be covered more in [Chapter 5](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml),
    *Multicasting*.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, remember that `ConnectableObservable` is hot, and therefore, if new
    subscriptions occur after `connect()` is called, they will miss emissions that
    were fired previously.
  prefs: []
  type: TYPE_NORMAL
- en: Other Observable sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already covered a few factories to create `Observable` sources, including
    `Observable.create()`, `Observable.just()`, and `Observable.fromIterable()`. After
    our detour covering Observers and their nuances, let's pick up where we left off
    and cover a few more `Observable` factories.
  prefs: []
  type: TYPE_NORMAL
- en: Observable.range()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To emit a consecutive range of integers, you can use `Observable.range()`.
    This will emit each number from a start value and increment each emission until
    the specified count is reached. These numbers are all passed through the `onNext()`
    event, followed by the  `onComplete()` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note closely that the two arguments for **`Observable.range()`** are not lower/upper
    bounds. The first argument is the starting value. The second argument is the total
    count of emissions, which will include both the initial value and incremented
    values. Try emitting `Observable.range(5,10)`, and you will notice that it emits
    `5` followed by the next nine consecutive integers following it (for a grand total
    of 10 emissions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is also a long equivalent called `Observable.rangeLong()` if
    you need to emit larger numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Observable.interval()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, Observables have a concept of emissions over time. Emissions
    are handed from the source up to the Observer sequentially. But these emissions
    can be spaced out over time depending on when the source provides them. Our JavaFX
    example with `ToggleButton` demonstrated this, as each click resulted in an emission
    of `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s look at a simple example of a time-based `Observable` using `Observable.interval()`.
    It will emit a consecutive long emission (starting at `0`) at every specified
    time interval. Here, we have an `Observable<Long>` that emits every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`Observable.interval()` will emit infinitely at the specified interval (which
    is 1 second in this case). However, because it operates on a timer, it needs to
    run on a separate thread and will run on the computation **Scheduler** by default.
    We will cover concurrency in [Chapter 6](4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml),
    *Concurrency and Parallelization* and learn about schedulers. For now, just note
    that our  `main()` method is going to kick off this `Observable`, but it will
    not wait for it to finish. It is now emitting on a separate thread. To keep our
    `main()` method from finishing and exiting the application before our `Observable`
    has a chance to fire, we use a `sleep()` method to keep this application alive
    for five seconds. This gives our `Observable` five seconds to fire emissions before
    the application quits. When you create production applications, you likely will
    not run into this issue often as non-daemon threads for tasks such as web services,
    Android apps, or JavaFX will keep the application alive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Trick question: does `Observable.interval()` return a hot or a cold `Observable`?
    Because it is event-driven (and infinite), you may be tempted to say it is hot.
    But put a second `Observer` on it, wait for five seconds, and then add another
    Observer. What happens? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Look what happened after five seconds elapsed, when `Observer 2` came in. Note
    that it is on its own separate timer and starting at `0`! These two observers
    are actually getting their own emissions, each starting at `0`. So this `Observable`
    is actually cold. To put all observers on the same timer with the same emissions,
    you will want to use `ConnectableObservable` to force these emissions to become
    hot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now `Observer 2`, although 5 seconds late and having missed the previous emissions,
    will at least be completely in sync with `Observer 1` and receive the same emissions.
  prefs: []
  type: TYPE_NORMAL
- en: Observable.future()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RxJava Observables are much more robust and expressive than `Futures`, but
    if you have existing libraries that yield `Futures`, you can easily turn them
    into Observables via `Observable.future()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Observable.empty()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although this may not seem useful yet, it is sometimes helpful to create an
    `Observable` that emits nothing and calls `onComplete()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that no emissions were printed because there were none. It went straight
    to calling `onComplete` , which printed the `Done!` message in the Observer. Empty
    observables are common to represent empty datasets. They can also result from
    operators such as `filter()` when all emissions fail to meet a condition. Sometimes,
    you will deliberately create empty Observables using `Observable.empty()`, and
    we will see examples of this in a few places throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: An empty Observable is essentially RxJava's concept of null. It is the absence
    of a value (or technically, "values"). Empty Observables are much more elegant
    than nulls because operations will simply continue empty rather than throw `NullPointerExceptions`.
    But when things go wrong in RxJava programs, sometimes it is because observers
    are receiving no emissions. When this happens, you have to trace through your
    Observable's chain of operators to find which one caused emissions to become empty.
  prefs: []
  type: TYPE_NORMAL
- en: Observable.never()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A close cousin of `Observable.empty()` is `Observable.never()`. The only difference
    between them is that it never calls `onComplete()`, forever leaving observers
    waiting for emissions but never actually giving any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This `Observable` is primarily used for testing and not that often in production.
    We have to use `sleep()` here just like `Observable.interval()` because the main
    thread is not going to wait for it after kicking it off. In this case, we just
    use `sleep()` for five seconds to prove that no emissions are coming from it.
    Then, the application will quit.
  prefs: []
  type: TYPE_NORMAL
- en: Observable.error()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This too is something you likely will only do with testing, but you can create
    an `Observable` that immediately calls `onError()` with a specified exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also provide the exception through a lambda so that it is created from
    scratch and separate exception instances are provided to each Observer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Observable.defer()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Observable.defer()` is a powerful factory due to its ability to create a separate
    state for each `Observer`. When using certain `Observable` factories, you may
    run into some nuances if your source is stateful and you want to create a separate
    state for each `Observer`. Your source `Observable` may not capture something
    that has changed about its parameters and send emissions that are obsolete. Here
    is a simple example: we have an `Observable.range()` built off two static `int`
    properties, `start` and `count`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you subscribe to this `Observable`, modify the count, and then subscribe
    again, you will find that the second `Observer` does not see this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To remedy this problem of `Observable` sources not capturing state changes,
    you can create a fresh `Observable` for each subscription. This can be achieved
    using `Observable.defer()`, which accepts a lambda instructing how to create an
    `Observable` for every subscription. Because this creates a new `Observable` each
    time, it will reflect any changes driving its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That's better! When your `Observable` source is not capturing changes to the
    things driving it, try putting it in `Observable.defer()`. If your Observable
    source was implemented naively and behaves brokenly with more than one Observer
    (for example, it reuses an Iterator that only iterates data once), `Observable.defer()`
    provides a quick workaround for this as well.
  prefs: []
  type: TYPE_NORMAL
- en: Observable.fromCallable()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to perform a calculation or action and then emit it, you can use
    `Observable.just()` (or `Single.just()` or `Maybe.just()`, which we will learn
    about later). But sometimes, we want to do this in a lazy or deferred manner.
    Also, if that procedure throws an error, we want it to be emitted up the `Observable`
    chain through `onError()` rather than throw the error at that location in traditional
    Java fashion. For instance, if you try to wrap `Observable.just()` around an expression
    that divides  `1` by `0`, the exception will be thrown, not emitted up to `Observer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are going to be reactive in our error handling, this may not be desirable.
    Perhaps you would like the error to be emitted down the chain to the `Observer`
    where it will be handled. If that is the case, use `Observable.fromCallable()`
    instead, as it accepts a lambda `Supplier<T>` and it will emit any error that
    occurs down to `Observer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: That is better! The error was emitted to the `Observer` rather than being thrown
    where it occurred. If initializing your emission has a likelihood of throwing
    an error, you should use `Observable.fromCallable()` instead of `Observable.just()`.
  prefs: []
  type: TYPE_NORMAL
- en: Single, Completable, and Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few specialized flavors of `Observable` that are explicitly set
    up for one or no emissions: `Single`, `Maybe`, and `Completable`. These all follow
    the `Observable` closely and should be intuitive to use in your reactive coding
    workflow. You can create them in similar ways as the `Observable` (for example,
    they each have their own `create()` factory), but certain `Observable` operators
    may return them too.'
  prefs: []
  type: TYPE_NORMAL
- en: Single
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Single<T>` is essentially an `Observable<T>` that will only emit one item.
    It works just like an Observable, but it is limited only to operators that make
    sense for a single emission. It has its own `SingleObserver` interface as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onSuccess()` essentially consolidates `onNext()` and `onComplete()` into
    a single event that accepts the one emission. When you call `subscribe()` against
    a Single, you provide the lambdas for `onSuccess()` as well as an optional `onError()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Certain RxJava Observable operators will yield a Single, as we will see in
    the next chapter. For instance, the `first()` operator will return a Single since
    that operator is logically concerned with a single item. However, it accepts a
    default value as a parameter (which I specified as `Nil` in the following example)
    if the Observable comes out empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `Single` must have one emission, and you should prefer it if you only have
    one emission to provide. This means that instead of using `Observable.just("Alpha")`,
    you should try to use `Single.just("Alpha")` instead. There are operators on `Single`
    that will allow you to turn it into an `Observable` when needed, such as `toObservable()`.
  prefs: []
  type: TYPE_NORMAL
- en: If there are `0` or `1` emissions, you will want to use `Maybe`.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Maybe` is just like a `Single` except that it allows no emission to occur
    at all (hence `Maybe`). `MaybeObserver` is much like a standard Observer, but
    `onNext()` is called `onSuccess()` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'A given `Maybe<T>` will only emit `0` or  `1` emissions. It will pass the possible
    emission to `onSuccess()`, and in either case, it will call `onComplete()` when
    done. `Maybe.just()` can be used to create a `Maybe` emitting the single item.
    `Maybe.empty()` will create a `Maybe` that yields no emission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Certain `Observable` operators that we will learn about later yield a `Maybe`.
    One example is the `firstElement()` operator, which is similar to `first()`, but
    it returns an empty result if no elements are emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Completable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Completable` is simply concerned with an action being executed, but it does
    not receive any emissions. Logically, it does not have  `onNext()` or `onSuccess()`
    to receive emissions, but it does have `onError()` and `onComplete()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Completable is something you likely will not use often. You can construct one
    quickly by calling `Completable.complete()` or `Completable.fromRunnable()`. The
    former will immediately call `onComplete()` without doing anything, while `fromRunnable()`
    will execute the specified action before calling `onComplete()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Disposing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you `subscribe()` to an Observable to receive emissions, a stream is created
    to process these emissions through the Observable chain. Of course, this uses
    resources. When we are done, we want to dispose of these resources so that they
    can be garbage-collected. Thankfully, the finite Observables that call `onComplete()`
    will typically dispose of themselves safely when they are done. But if you are
    working with infinite or long-running Observables, you likely will run into situations
    where you want to explicitly stop the emissions and dispose of everything associated
    with that subscription. As a matter of fact, you cannot trust the garbage collector
    to take care of active subscriptions that you no longer need, and explicit disposal
    is necessary in order to prevent memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Disposable is a link between an Observable and an active Observer, and
    you can call its `dispose()` method to stop emissions and dispose of all resources
    used for that Observer. It also has an `isDisposed()` method, indicating whether
    it has been disposed of already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When you provide `onNext()`, `onComplete()`, and/or `onError()` lambdas as
    arguments to the `subscribe()` method,  it will actually return a `Disposable`.
    You can use this to stop emissions at any time by calling its `dispose()` method.
    For instance, we can stop receiving emissions from an `Observable.interval()`
    after five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here, we let `Observable.interval()` run for five seconds with an Observer,
    but we save the Disposable returned from the `subscribe()` method. Then we call
    the Disposable's `dispose()` method to stop the process and free any resources
    that were being used. Then, we sleep for another five seconds just to prove that
    no more emissions are happening.
  prefs: []
  type: TYPE_NORMAL
- en: Handling a Disposable within an Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, I shied away from talking about the `onSubscribe()` method in the `Observer`,
    but now we will address it. You may have noticed that `Disposable` is passed in
    the implementation of an `Observer` through the `onSubscribe()` method. This method
    was added in RxJava 2.0, and it allows the `Observer` to have the ability to dispose
    of the subscription at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can implement your own `Observer` and use `onNext()`, `onComplete()`,
    or `onError()` to have access to the `Disposable`.This way, these three events
    can call `dispose()` if, for whatever reason, the `Observer` does not want any
    more emissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `Disposable` is sent from the source all the way up the chain to the Observer,
    so each step in the `Observable` chain has access to the Disposable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that passing an `Observer` to the `subscribe()` method will be void and
    not return a `Disposable` since it is assumed that the `Observer` will handle
    it. If you do not want to explicitly handle the `Disposable` and want RxJava to
    handle it for you (which is probably a good idea until you have reason to take
    control), you can extend `ResourceObserver` as your Observer, which uses a default
    `Disposable` handling. Pass this to `subscribeWith()` instead of `subscribe()`,
    and you will get the default `Disposable` returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Using CompositeDisposable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have several subscriptions that need to be managed and disposed of,
    it can be helpful to use `CompositeDisposable`. It implements `Disposable`, but
    it internally holds a collection of `disposables`, which you can add to and then
    dispose all at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`CompositeDisposable` is a simple but helpful utility to maintain a collection
    of `disposables` that you can add to by calling `add()` or `addAll()`. When you
    no longer want these subscriptions, you can call `dispose()` to dispose of all
    of them at once.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling Disposal with Observable.create()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your `Observable.create()` is returning a long-running or infinite `Observable`,
    you should ideally check the `isDisposed()` method of `ObservableEmitter` regularly,
    to see whether you should keep sending emissions. This prevents unnecessary work
    from being done if the subscription is no longer active.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you should use `Observable.range()`, but for the sake of the
    example, let''s say we are emitting integers in a `for` loop in `Observable.create()`.
    Before emitting each integer, you should make sure that `ObservableEmitter` does
    not indicate that a disposal was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If your `Observable.create()` is wrapped around some resource, you should also
    handle the disposal of that resource to prevent leaks. `ObservableEmitter` has
    the `setCancellable()` and `setDisposable()` methods for that. In our earlier
    JavaFX example, we should remove the  `ChangeListener` from our JavaFX `ObservableValue`
    when a disposal occurs. We can provide a lambda to `setCancellable()`, which will
    execute the following action for us, which will occur when `dispose()` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was an intense chapter, but it will provide a solid foundation as you learn
    how to use RxJava to tackle real-world work. RxJava, with all of its expressive
    power, has some nuances that are entirely due to the change of mindset it demands.
    It has done an impressive amount of work taking an imperative language like Java
    and adapting it to become reactive and functional. But this interoperability requires
    some understanding of the implementations between an `Observable` and a `Observer`.
    We touched on various ways to create Observables as well as how they interact
    with Observers.
  prefs: []
  type: TYPE_NORMAL
- en: Take your time trying to digest all this information but do not let it stop
    you from moving on to the next two chapters, where the usefulness of RxJava starts
    to take formation. In the next chapters, the pragmatic usefulness of RxJava will
    start to become clear.
  prefs: []
  type: TYPE_NORMAL
