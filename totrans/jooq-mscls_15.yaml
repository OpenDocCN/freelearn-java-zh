- en: '*Chapter 12*: Pagination and Dynamic Queries'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：分页和动态查询'
- en: In this chapter, we'll talk about pagination and dynamic queries in jOOQ, two
    topics that work hand in hand in a wide range of applications to paginate and
    filter lists of products, items, images, posts, articles, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 jOOQ 中的分页和动态查询，这两个主题在广泛的应用中协同工作，用于分页和过滤产品、项目、图片、帖子、文章等列表。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: jOOQ offset pagination
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ 偏移量分页
- en: jOOQ keyset pagination
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ 键集分页
- en: Writing dynamic queries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写动态查询
- en: Infinite scrolling and dynamic filters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限滚动和动态筛选
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter12](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter12).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter12](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter12)。
- en: Offset and keyset pagination
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏移量和键集分页
- en: Offset and keyset pagination (or seek, as Markus Winand calls it) represent
    two well-known techniques for paginating data while fetching it from the database.
    Offset pagination is quite popular because Spring Boot (more precisely, Spring
    Data Commons) provides two default implementations for it, via the `Page` and
    `Slice` APIs. Therefore, in terms of productivity, it's very convenient to rely
    on these implementations. However, in terms of performance, while your project
    evolves and data keeps accumulating, relying on offset pagination may lead to
    serious performance degradations. Nevertheless, as you'll see soon, jOOQ can help
    you to sweeten the situation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量和键集分页（或如马克斯·温安德所说的“查找”）是两种在从数据库中获取数据时进行分页的知名技术。偏移量分页相当流行，因为 Spring Boot（更确切地说，Spring
    Data Commons）提供了两种默认实现，通过 `Page` 和 `Slice` API。因此，从生产力的角度来看，依赖这些实现非常方便。然而，从性能的角度来看，随着项目的演变和数据量的积累，依赖偏移量分页可能会导致严重的性能下降。不过，正如你很快就会看到的，jOOQ
    可以帮助你改善这种情况。
- en: Conversely, keyset pagination is a technique that sustains high performance,
    being faster and more stable than offset pagination. Keyset pagination really
    shines on paginating large datasets and infinite scrolling, while it leads to
    almost the same performance as offset pagination, especially for relatively small
    datasets. However, can you guarantee that the amount of data will not grow over
    time (sometimes, quite fast)? If yes, then using offset pagination should be okay.
    Otherwise, it is better to prevent this well-known performance issue right from
    the start and rely on keyset pagination. Don't think that this is premature optimization;
    think of it as the capability to make the right decisions depending on the business
    case you are modeling. And, as you'll see soon, jOOQ makes keyset pagination usage
    child's play.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，键集分页是一种保持高性能的技术，比偏移量分页更快、更稳定。键集分页在分页大型数据集和无限滚动方面表现尤为出色，同时其性能几乎与偏移量分页相同，尤其是在相对较小的数据集上。然而，你能保证数据量不会随着时间的推移而增长（有时增长得相当快）吗？如果可以，那么使用偏移量分页应该是可以的。否则，最好从一开始就防止这种已知的性能问题，并依赖键集分页。不要认为这是过早优化；将其视为根据你正在建模的业务案例做出正确决策的能力。而且，正如你很快就会看到的，jOOQ
    使得键集分页变得轻而易举。
- en: Index scanning in offset and keyset
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏移量和键集索引扫描
- en: Dealing with offset pagination means you can ignore the performance penalty
    induced by throwing away *n* records before reaching the desired offset. A larger
    *n* leads to a significant performance penalty that equally affects both the `Page`
    and `Slice` APIs. Another penalty is the extra `SELECT COUNT` needed to count
    the total number of records. This extra `SELECT COUNT` is specific to the `Page`
    API only, so it doesn't affect the `Slice` API. Basically, this is the main difference
    between the `Page` and `Slice` APIs; the former contains the total number of records
    (useful for computing the total number of pages), while the latter can only tell
    whether there is at least one more page available or this is the last page.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 处理偏移量分页意味着你可以忽略在达到期望偏移量之前丢弃 *n* 条记录所引起的性能惩罚。较大的 *n* 会导致显著的性能惩罚，这同样影响了 `Page`
    和 `Slice` API。另一个惩罚是需要额外的 `SELECT COUNT` 来计算记录总数。这个额外的 `SELECT COUNT` 仅针对 `Page`
    API，因此不会影响 `Slice` API。基本上，这是 `Page` 和 `Slice` API 之间的主要区别；前者包含记录总数（用于计算总页数），而后者只能判断是否至少还有一页可用或这是最后一页。
- en: 'Lukas Eder has a very nice observation here: *"Another way I tend to think
    about this is: What''s the business value of being able to jump to page 2712?
    What does that page number even mean? Shouldn''t the search be refined with better
    filters instead? On the other hand, jumping to the *next* page from any page is
    a very common requirement."*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Lukas Eder 在这里有一个非常棒的观察：“我倾向于这样思考的另一种方式是：能够跳转到第 2712 页的商业价值是什么？那个页码甚至意味着什么？难道不应该使用更好的过滤器来细化搜索吗？另一方面，从任何页面跳转到下一页是一个非常常见的需求。”*
- en: 'An index scan in offset will traverse the range of indexes from the beginning
    to the specified offset. Basically, the offset represents the number of records
    that must be skipped before including them in the result set. So, the offset approach
    will traverse the already shown records, as shown in the following figure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量索引扫描将从开始到指定的偏移量遍历索引范围。基本上，偏移量表示在将记录包含到结果集中之前必须跳过的记录数。因此，偏移量方法将遍历已经显示的记录，如下面的图所示：
- en: '![Figure 12.1 – An index scan in offset and keyset pagination'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – 偏移量和键集分页中的索引扫描'
- en: '](img/B16833_Figure_12.1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_12.1.jpg)'
- en: Figure 12.1 – An index scan in offset and keyset pagination
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 偏移量和键集分页中的索引扫描
- en: On the other hand, the index scan in the keyset pagination will traverse only
    the required values, starting with the last previous value (it skips the values
    until the last value previously fetched). In the keyset, the performance remains
    approximately constant in relation to the increase of the table records.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，键集分页中的索引扫描将仅遍历所需值，从最后一个前一个值开始（它跳过直到最后一个之前获取的值）。在键集中，性能相对于表记录的增加保持大致恒定。
- en: Important Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An important reference and compelling argument against using offset pagination
    is mentioned on the *USE THE INDEX, LUKE!* website ([https://use-the-index-luke.com/no-offset](https://use-the-index-luke.com/no-offset)).
    I strongly suggest you take some time and watch this great presentation by Markus
    Winand ([https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way?ref=https://use-the-index-luke.com/no-offset](https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way?ref=https://use-the-index-luke.com/no-offset)),
    which covers important topics for tuning pagination-SQL, such as using indexes
    and row values (supported in PostgreSQL) in offset and keyset pagination.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *USE THE INDEX, LUKE!* 网站上提到了一个重要的参考和反对使用偏移量分页的论点（[https://use-the-index-luke.com/no-offset](https://use-the-index-luke.com/no-offset)）。我强烈建议你花些时间观看
    Markus Winand 的这个精彩演示（[https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way?ref=https://use-the-index-luke.com/no-offset](https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way?ref=https://use-the-index-luke.com/no-offset)），它涵盖了调整分页-SQL
    的重要主题，例如在偏移量和键集分页中使用索引和行值（在 PostgreSQL 中受支持）。
- en: Okay, after this summary of offset versus keyset pagination, let's see how jOOQ
    can mimic and even improve the default Spring Boot offset pagination implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在总结了偏移量与键集分页之后，让我们看看 jOOQ 如何模拟甚至改进默认的 Spring Boot 偏移量分页实现。
- en: jOOQ offset pagination
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ 偏移量分页
- en: 'Spring Boot implementation of offset pagination can be easily shaped via `LIMIT
    … OFFSET` (or `OFFSET … FETCH`) and `SELECT COUNT`. For instance, if we assume
    that a client gives us a page number (via the `page` argument) and `size` (the
    number of products to be displayed on `page`), then the following jOOQ query mimics
    the default Spring Boot pagination behavior for the `PRODUCT` table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 的偏移量分页实现可以通过 `LIMIT … OFFSET`（或 `OFFSET … FETCH`）和 `SELECT COUNT`
    轻松地塑形。例如，如果我们假设客户端通过 `page` 参数给我们一个页码（`size` 是要在 `page` 上显示的产品数量），那么下面的 jOOQ 查询模拟了
    `PRODUCT` 表的默认 Spring Boot 分页行为：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the client (for instance, the browser) expects as a response a serialization
    of the classical `Page<Product>` (`org.springframework.data.domain.Page`), then
    you can simply produce it, as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端（例如，浏览器）期望作为响应返回经典 `Page<Product>` (`org.springframework.data.domain.Page`)
    的序列化，那么你可以简单地生成它，如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, instead of executing two `SELECT` statements, we can use the `COUNT()`
    window function to obtain the same result but with a single `SELECT`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不必执行两个 `SELECT` 语句，我们可以使用 `COUNT()` 窗口函数以单个 `SELECT` 获取相同的结果：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is already better than the default Spring Boot implementation. When you
    return this `Map<Integer, List<Product>>` to the client, you can return a `Page<Product>`
    as well:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经比默认的 Spring Boot 实现要好。当你将这个 `Map<Integer, List<Product>>` 返回给客户端时，你也可以返回一个
    `Page<Product>`：
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most probably, you'll prefer `Page` because it contains a set of metadata, such
    as the total number of records if we hadn't paginated (`totalElements`), the current
    page we're on (`pageNumber`), the actual page size (`pageSize`), the actual offsets
    of the returned rows (`offset`), and whether we are on the last page (`last`).
    You can find the previous examples in the bundled code as *PaginationCountOver*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你更喜欢`Page`，因为它包含一系列元数据，例如如果没有分页的总记录数（`totalElements`），当前页码（`pageNumber`），实际页面大小（`pageSize`），返回行的实际偏移量（`offset`），以及我们是否在最后一页（`last`）。你可以在捆绑的代码（*PaginationCountOver*）中找到之前的例子。
- en: However, as Lukas Eder highlights in this article ([https://blog.jooq.org/2021/03/11/calculating-pagination-metadata-without-extra-roundtrips-in-sql/](https://blog.jooq.org/2021/03/11/calculating-pagination-metadata-without-extra-roundtrips-in-sql/)),
    all this metadata can be obtained in a single SQL query; therefore, there is no
    need to create a `Page` object to have them available. In the bundled code (*PaginationMetadata*)
    you can practice Lukas's dynamic query via a REST controller.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如Lukas Eder在这篇文章中强调的（[https://blog.jooq.org/2021/03/11/calculating-pagination-metadata-without-extra-roundtrips-in-sql/](https://blog.jooq.org/2021/03/11/calculating-pagination-metadata-without-extra-roundtrips-in-sql/))，所有这些元数据都可以在一个SQL查询中获取；因此，没有必要创建一个`Page`对象来使它们可用。在捆绑的代码（*PaginationMetadata*）中，你可以通过REST控制器练习Lukas的动态查询。
- en: jOOQ keyset pagination
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jOOQ键集分页
- en: 'Keyset (or seek) pagination doesn''t have a default implementation in Spring
    Boot, but this shouldn''t stop you from using it. Simply start by choosing a table''s
    column that should act as the latest visited record/row (for instance, the id
    column), and use this column in the `WHERE` and `ORDER BY` clauses. The idioms
    relying on the ID column are as follows (sorting by multiple columns follows this
    same idea):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '键集（或seek）分页在Spring Boot中没有默认实现，但这不应该阻止你使用它。只需从选择一个用作最新访问记录/行的表列（例如，id列）开始，并在`WHERE`和`ORDER
    BY`子句中使用这个列。依赖于ID列的惯用用法如下（多列排序遵循相同的概念）:'
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，像这样：
- en: '[PRE29]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Based on the experience gained so far, expressing these queries in jOOQ should
    be a piece of cake. For instance, let''s apply the first idiom to the `PRODUCT`
    table via `PRODUCT_ID`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据迄今为止获得的经验，在jOOQ中表达这些查询应该轻而易举。例如，让我们通过`PRODUCT_ID`将第一个惯用用法应用到`PRODUCT`表上：
- en: '[PRE37]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In MySQL, the rendered SQL is (where `productId` = `20` and `size` = `5`) as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中，渲染的SQL如下（其中`productId` = `20`和`size` = `5`）：
- en: '[PRE42]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This was easy! You can practice this case in *KeysetPagination*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！你可以在*KeysetPagination*中练习这个案例。
- en: However, keyset pagination becomes a little bit trickier if the `WHERE` clause
    becomes more complicated. Fortunately, jOOQ saves us from this scenario via a
    synthetic clause named `SEEK`. Let's dive into it!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`WHERE`子句变得更加复杂，键集分页就会变得有点棘手。幸运的是，jOOQ通过一个名为`SEEK`的合成子句帮助我们避免了这种情况。让我们深入探讨它！
- en: The jOOQ SEEK clause
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jOOQ的SEEK子句
- en: The jOOQ synthetic `SEEK` clause simplifies the implementation of keyset pagination.
    Among its major advantages, the `SEEK` clause is type-safe and is capable of generating/emulating
    the correct/expected `WHERE` clause (including the emulation of row value expressions).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ的合成`SEEK`子句简化了键集分页的实现。其主要优点之一是`SEEK`子句是类型安全的，并且能够生成/模拟正确的/预期的`WHERE`子句（包括行值表达式的模拟）。
- en: 'For instance, the previous keyset pagination example can be expressed using
    the `SEEK` clause, as shown here (`productId` is provided by the client):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，前面的键集分页示例可以使用`SEEK`子句来表示，如下所示（`productId`由客户提供）:'
- en: '[PRE49]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Note that there is no explicit `WHERE` clause. jOOQ will generate it on our
    behalf, based on the `seek()` arguments. While this example may not look so impressive,
    let''s consider another one. This time, let''s paginate `EMPLOYEE` using the employee''s
    office code and salary:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，这里没有显式的`WHERE`子句。jOOQ会根据`seek()`参数为我们生成它。虽然这个例子可能看起来并不那么令人印象深刻，但让我们考虑另一个例子。这次，让我们使用员工的办公代码和薪水来分页`EMPLOYEE`:'
- en: '[PRE54]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Both `officeCode` and `salary` are provided by the client, and they land into
    the following generated SQL sample (where `officeCode` = `1`, `salary` = `75000`,
    and `size` = `10`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`officeCode`和`salary`都由客户提供，并会落在以下生成的SQL示例中（其中`officeCode` = `1`，`salary` =
    `75000`，`size` = `10`）:'
- en: '[PRE59]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Check out the generated `WHERE` clause! I am pretty sure that you don't want
    to get your hands dirty and explicitly write this clause. How about the following
    example?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的`WHERE`子句！我非常确信你不想手动编写这个子句。以下例子如何？
- en: '[PRE68]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And the following code is a sample of the generated SQL (where `orderId` =
    `10100`, `productId` = `23`, `quantityOrdered` = `30`, and `size` = `10`):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是生成的 SQL 示例（其中 `orderId` = `10100`，`productId` = `23`，`quantityOrdered`
    = `30`，`size` = `10`）：
- en: '[PRE74]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'After this example, I think is obvious that you should opt for the `SEEK` clause
    and let jOOQ do its job! Look, you can even do this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例之后，我认为很明显，你应该选择 `SEEK` 子句，让 jOOQ 做它的工作！看，你甚至可以这样做：
- en: '[PRE87]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You can practice these examples in *SeekClausePagination*, next to the other
    examples, including using jOOQ-embedded keys as arguments of the `SEEK` clause.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *SeekClausePagination* 中练习这些示例，包括使用 jOOQ 内嵌键作为 `SEEK` 子句的参数。
- en: Implementing infinite scroll
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现无限滚动
- en: 'Infinite scroll is a classical usage of keyset pagination and is gaining popularity
    these days. For instance, let''s assume that we plan to obtain something, as shown
    in this figure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动是键集分页的经典用法，并且近年来越来越受欢迎。例如，假设我们计划获取如图所示的内容：
- en: '![Figure 12.2 – An infinite scroll'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – 无限滚动'
- en: '](img/B16833_Figure_12.2.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_12.2.jpg)'
- en: Figure 12.2 – An infinite scroll
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 无限滚动
- en: 'So, we want an infinite scroll over the `ORDERDETAIL` table. At each scroll,
    we fetch the next *n* records via the `SEEK` clause:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要对 `ORDERDETAIL` 表进行无限滚动。在每次滚动时，我们通过 `SEEK` 子句获取下一个 *n* 条记录：
- en: '[PRE93]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This method gets the last visited `ORDERDETAIL_ID` and the number of records
    to fetch (`size`), and it returns a list of `jooq.generated.tables.pojos.Orderdetail`,
    which will be serialized in JSON format via a Spring Boot REST controller endpoint
    defined as `@GetMapping("/orderdetail/{orderdetailId}/{size}")`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法获取最后访问的 `ORDERDETAIL_ID` 和要获取的记录数（`size`），然后返回一个 `jooq.generated.tables.pojos.Orderdetail`
    的列表，这些列表将通过定义在 `@GetMapping("/orderdetail/{orderdetailId}/{size}")` 的 Spring Boot
    REST 控制器端点以 JSON 格式序列化。
- en: 'On the client side, we rely on the JavaScript Fetch API (of course, you can
    use XMLHttpRequest, jQuery, AngularJS, Vue, React, and so on) to execute an HTTP
    `GET` request, as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们依赖于 JavaScript Fetch API（当然，你也可以使用 XMLHttpRequest、jQuery、AngularJS、Vue、React
    等等）来执行 HTTP `GET` 请求，如下所示：
- en: '[PRE102]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'For fetching exactly three records, we replace `${size}` with `3`. Moreover,
    the `${start}` placeholder should be replaced by the last visited `ORDERDETAIL_ID`,
    so the `start` variable can be computed as the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取正好三条记录，我们将 `${size}` 替换为 `3`。此外，`${start}` 占位符应该被替换为最后访问的 `ORDERDETAIL_ID`，因此
    `start` 变量可以计算如下：
- en: '[PRE105]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'While scrolling, your browser will execute an HTTP request at every three records,
    as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在滚动时，你的浏览器将在每三条记录后执行一个 HTTP 请求，如下所示：
- en: '[PRE106]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: You can check out this example in *SeekInfiniteScroll*. Next, let's see an approach
    for paginating `JOIN` statements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *SeekInfiniteScroll* 中查看这个示例。接下来，让我们看看分页 `JOIN` 语句的方法。
- en: Paginating JOINs via DENSE_RANK()
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 DENSE_RANK() 分页 JOIN
- en: 'Let''s assume that we want to paginate offices (`OFFICE`) with employees (`EMPLOYEE`).
    If we apply a classical offset or keyset pagination to the `JOIN` between `OFFICE`
    and `EMPLOYEE`, then the result is prone to be truncated. Therefore, an office
    can be fetched with only a subset of its employees. For instance, while we think
    of a result page of size 3 as containing three offices with all their employees,
    we instead get a single office with three employees (even if this office has more
    employees). The following figure reveals what we expect versus what we get from
    a page of size 3 (offices):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要分页显示办公室（`OFFICE`）和员工（`EMPLOYEE`）。如果我们将经典的偏移量或键集分页应用于 `OFFICE` 和 `EMPLOYEE`
    之间的 `JOIN`，那么结果可能会被截断。因此，一个办公室可能只能获取其部分员工的记录。例如，当我们认为一个大小为 3 的结果页面包含三个具有所有员工的办公室时，我们实际上只得到一个有三个员工的办公室（即使这个办公室有更多员工）。以下图显示了我们的预期结果与从大小为
    3 的页面（办公室）得到的结果：
- en: '![Figure 12.3 – Join pagination'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3 – 连接分页'
- en: '](img/B16833_Figure_12.3.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_12.3.jpg)'
- en: Figure 12.3 – Join pagination
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 连接分页
- en: 'In order to obtain a result set like the one on the left-hand side of the preceding
    figure, we can rely on the `DENSE_RANK()` window function, which assigns a sequential
    number to different values of `a` within each group `b`, as shown in the following
    query:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得如图左侧所示的结果集，我们可以依赖 `DENSE_RANK()` 窗口函数，该函数为每个组 `b` 中 `a` 的不同值分配一个顺序号，如下查询所示：
- en: '[PRE110]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `start` and `end` variables represent the range of offices set via `DENSE_RANK()`.
    The following figure should clarify this aspect where `start` = `1` and `end`
    = `3` (the next page of three offices is between `start` = `4` and `end` = `6`):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`end`变量代表通过`DENSE_RANK()`设置的办公室范围。以下图应能阐明这一点，其中`start` = `1`和`end`
    = `3`（下一个包含三个办公室的页面在`start` = `4`和`end` = `6`之间）：'
- en: '![Figure 12.4 – The DENSE_RANK() effect'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – DENSE_RANK()的效果'
- en: '](img/B16833_Figure_12.4.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_12.4.jpg]'
- en: Figure 12.4 – The DENSE_RANK() effect
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – DENSE_RANK()的效果
- en: 'Here is a more compact version of the previous query, using the `QUALIFY` clause:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是上一个查询的一个更紧凑版本，使用了`QUALIFY`子句：
- en: '[PRE120]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: You can check out these examples (offset, keyset, and `DENSE_RANK()` queries)
    via three REST controller endpoints in *DenseRankPagination* for MySQL. In all
    these cases, the returned `Map<Office, List<Employee>>` is serialized to JSON.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过MySQL的*DenseRankPagination*中的三个REST控制器端点查看这些示例（偏移量、键集和`DENSE_RANK()`查询）。在这些所有情况下，返回的`Map<Office,
    List<Employee>>`被序列化为JSON。
- en: Paginating database views via ROW_NUMBER()
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ROW_NUMBER()分页数据库视图
- en: 'Let''s consider the following figure, representing a snapshot of a database
    view named `PRODUCT_MASTER` (it could be a regular table as well):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图，它表示名为`PRODUCT_MASTER`的数据库视图的快照（它也可以是一个常规表）：
- en: '![Figure 12.5 – The PRODUCT_MASTER database view'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – PRODUCT_MASTER数据库视图'
- en: '](img/B16833_Figure_12.5.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_12.5.jpg]'
- en: Figure 12.5 – The PRODUCT_MASTER database view
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – PRODUCT_MASTER数据库视图
- en: Next, we want to paginate this view by `PRODUCT_LINE` (first column), so we
    have to take into account the fact that `PRODUCT_LINE` contains duplicates. While
    this is not an issue for offset pagination, it could produce weird results for
    keyset pagination relying only on `PRODUCT_LINE` and `LIMIT` (or counterparts)
    clauses. We can eliminate this issue by using the (`PRODUCT_LINE`, `PRODUCT_NAME`)
    combo in `ORDER BY` and `WHERE` predicate. This will work as expected because
    `PRODUCT_NAME` contains unique values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望通过`PRODUCT_LINE`（第一列）来分页这个视图，因此我们必须考虑到`PRODUCT_LINE`包含重复项的事实。虽然这对于偏移分页不是问题，但它可能会为仅依赖于`PRODUCT_LINE`和`LIMIT`（或其对应项）子句的关键集分页产生奇怪的结果。我们可以通过在`ORDER
    BY`和`WHERE`谓词中使用(`PRODUCT_LINE`, `PRODUCT_NAME`)组合来消除这个问题。这将按预期工作，因为`PRODUCT_NAME`包含唯一值。
- en: However, let's try another approach, relying on the `ROW_NUMBER()` window function.
    This function assigns a database temporary sequence of values to rows. More precisely,
    the `ROW_NUMBER()` window function produces a sequence of values that starts from
    value 1 with an increment of 1\. This is a temporary sequence of values (non-persistent)
    that is calculated dynamically at query execution time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们尝试另一种方法，依赖于`ROW_NUMBER()`窗口函数。此函数为行分配一个数据库临时值序列。更确切地说，`ROW_NUMBER()`窗口函数生成一个从值1开始，增量1的值序列。这是一个在查询执行时动态计算的临时值序列（非持久）。
- en: 'Based on `ROW_NUMBER()`, we can visualize `PRODUCT_MASTER`, as shown in this
    figure:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`ROW_NUMBER()`，我们可以可视化`PRODUCT_MASTER`，如图所示：
- en: '![Figure 12.6 – The ROW_NUMBER() effect'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 – ROW_NUMBER()的效果'
- en: '](img/B16833_Figure_12.6.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_12.6.jpg]'
- en: Figure 12.6 – The ROW_NUMBER() effect
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – ROW_NUMBER()的效果
- en: 'In this context, expressing pagination can be done as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，可以这样表达分页：
- en: '[PRE130]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Alternatively, we can make it more compact via the `QUALIFY` clause:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过`QUALIFY`子句使其更加紧凑：
- en: '[PRE138]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Fetching the first page of size 5 can be done via `start` = `1` and `end` =
    `5`. Fetching the next page of size 5 can be done via `start` = `6` and `end`
    = `10`. The complete example is available in the bundler code as *RowNumberPagination*
    for MySQL.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`start` = `1`和`end` = `5`获取大小为5的第一页。通过`start` = `6`和`end` = `10`获取下一页的大小为5。完整的示例在MySQL的bundler代码中的*RowNumberPagination*部分可用。
- en: Okay, that's enough about pagination. Next, let's tackle dynamic queries (filters).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于分页就说到这里。接下来，让我们解决动态查询（过滤器）的问题。
- en: Writing dynamic queries
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写动态查询
- en: Commonly, a dynamic query contains no or some fixed parts and some other parts
    that can be appended at runtime to form a query that corresponds to a certain
    scenario or use case.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个动态查询包含没有或一些固定部分，以及一些可以在运行时附加的部分，以形成一个对应于特定场景或用例的查询。
- en: Important Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In jOOQ, even when they look like static queries (due to jOOQ's API design),
    every SQL is dynamic; therefore, it can be broken up into query parts that can
    be fluently glued back in any valid jOOQ query. We already have covered this aspect
    in [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040), *jOOQ Core Concepts*, in the
    *Understanding the jOOQ fluent API* section.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，即使它们看起来像静态查询（由于 jOOQ 的 API 设计），每个 SQL 都是动态的；因此，它可以分解成可以流畅地重新组合在任何有效
    jOOQ 查询中的查询部分。我们已经在 [*第 3 章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ 核心概念*，*理解
    jOOQ 流畅 API* 部分中涵盖了这一方面。
- en: Dynamically creating an SQL statement on the fly is one of the favorite topics
    of jOOQ, so let's try to cover some approaches that can be useful in real applications.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建 SQL 语句是 jOOQ 最受欢迎的主题之一，因此让我们尝试涵盖一些在实际应用中可能有用的方法。
- en: Using the ternary operator
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用三元运算符
- en: 'The Java ternary operator (`?`) is probably the simplest approach for shaping
    a query at runtime. Check out this sample:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的三元运算符 (`?`) 是在运行时塑造查询的最简单方法之一。查看以下示例：
- en: '[PRE144]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The `PRODUCT.BUY_PRICE.gt(BigDecimal.valueOf(buyPrice))` condition is appended
    only if the passed `buyPrice` is greater than 0; otherwise, we rely on the handy
    `noCondition()` method. Next, depending on the `cars` flag, we shape the range
    of values for `PRODUCT.PRODUCT_LINE.in()`. Via this single jOOQ query, we can
    shape four different SQL queries at runtime, depending on the `buyPrice` and `cars`
    values.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRODUCT.BUY_PRICE.gt(BigDecimal.valueOf(buyPrice))` 条件仅在传递的 `buyPrice` 大于
    0 时附加；否则，我们依赖便捷的 `noCondition()` 方法。接下来，根据 `cars` 标志，我们调整 `PRODUCT.PRODUCT_LINE.in()`
    的值域。通过这个单一的 jOOQ 查询，我们可以在运行时形成四个不同的 SQL 查询，具体取决于 `buyPrice` 和 `cars` 的值。'
- en: Using jOOQ comparators
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jOOQ 比较器
- en: 'The jOOQ `Comparator` API is quite handy for toggling comparison operators
    in conditions while remaining fluent. For instance, let''s assume that the client
    (user, service, and so on) can choose between two categories of employees – a
    category of all the sales reps and a category of non-sales reps. If the client
    chooses the first category, then we want to fetch all employees (`EMPLOYEE`) that
    have a `salary` less than *65,000*. However, if the client chooses the second
    category, then we want to fetch all employees (`EMPLOYEE`) that have a `salary`
    greater than or equal to *65,000*. Instead of writing two queries or using any
    other approach, we can rely on jOOQ''s `Comparator.IN` and `Comparator.NOT_IN`
    (note that, in the case of `NOT_IN`, the projected column(s) should be `NOT NULL`),
    as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 的 `Comparator` API 在条件中切换比较运算符时非常方便，同时保持流畅。例如，假设客户端（用户、服务等等）可以在两个员工类别之间进行选择——一个是所有销售代表的类别，另一个是非销售代表的类别。如果客户端选择第一个类别，那么我们希望获取所有
    `salary` 小于 *65,000* 的员工 (`EMPLOYEE`)。然而，如果客户端选择第二个类别，那么我们希望获取所有 `salary` 大于或等于
    *65,000* 的员工 (`EMPLOYEE`)。而不是编写两个查询或使用其他任何方法，我们可以依赖 jOOQ 的 `Comparator.IN` 和 `Comparator.NOT_IN`（注意，在
    `NOT_IN` 的情况下，投影的列应该是 `NOT NULL`），如下所示：
- en: '[PRE154]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'jOOQ provides a comprehensive list of built-in comparators, including `EQUALS`,
    `GREATER`, `LIKE`, and `IS_DISTINCT_FROM`. While you can find all of them covered
    in the jOOQ documentation, here is another example that uses `Comparator.LESS`
    and `Comparator.GREATER` to express in jOOQ a query that can be translated into
    four SQL queries, depending on the values of `buyPrice` and `msrp`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 提供了一个全面的内置比较器列表，包括 `EQUALS`、`GREATER`、`LIKE` 和 `IS_DISTINCT_FROM`。虽然你可以在
    jOOQ 文档中找到所有这些内容，但这里有一个使用 `Comparator.LESS` 和 `Comparator.GREATER` 来在 jOOQ 中表达一个可以翻译成四个
    SQL 查询的查询的例子，具体取决于 `buyPrice` 和 `msrp` 的值：
- en: '[PRE163]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: You can check out these examples next to others in *DynamicQuery*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *DynamicQuery* 中查看这些示例以及其他示例。
- en: Using SelectQuery, InsertQuery, UpdateQuery, and DeleteQuery
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SelectQuery、InsertQuery、UpdateQuery 和 DeleteQuery
- en: The goal of the `SelectQuery` (`InsertQuery`, `UpdateQuery`, and `DeleteQuery`)
    types is to allow the expression of dynamic queries in an imperative style. However,
    it is recommended to avoid this imperative style and use a more functional style,
    as you'll see soon in this chapter. So, while you read this section, consider
    this sentence as a disclaimer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectQuery`（`InsertQuery`、`UpdateQuery` 和 `DeleteQuery`）类型的目标是允许以命令式风格表达动态查询。然而，建议避免这种命令式风格，并使用更函数式的方法，正如你将在本章中很快看到的。所以，当你阅读这一节时，请将这句话视为免责声明。'
- en: When the previous approaches can't be used or the query becomes cluttered, it
    is time to turn your attention to the `SelectQuery` (`InsertQuery`, `UpdateQuery`,
    and `DeleteQuery`) APIs. These jOOQ APIs are very useful for expressing dynamic
    queries because they contain dedicated methods for appending different parts of
    a query effortlessly (for example, conditions, joins, having, and order by).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的方法无法使用或查询变得杂乱时，是时候将注意力转向`SelectQuery`（`InsertQuery`、`UpdateQuery`和`DeleteQuery`）API了。这些jOOQ
    API对于表达动态查询非常有用，因为它们包含用于轻松添加查询不同部分的方法（例如，条件、连接、HAVING和ORDER BY）。
- en: Using SelectQuery
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SelectQuery
- en: 'For instance, let''s assume that our application exposes a filter for optionally
    selecting a price range (`startBuyPrice` and `endBuyPrice`), the product vendor
    (`productVendor`), and the product scale (`productScale`) for ordering a `PRODUCT`.
    Based on the client selections, we should execute the proper `SELECT` query, so
    we start by writing a `SelectQuery`, as shown here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的应用程序公开了一个过滤器，可以可选地选择一个价格范围（`startBuyPrice`和`endBuyPrice`），产品供应商（`productVendor`）和产品规模（`productScale`）来订购`PRODUCT`。基于客户端的选择，我们应该执行适当的`SELECT`查询，所以我们首先编写一个`SelectQuery`，如下所示：
- en: '[PRE175]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'So far, this query doesn''t involve any of the client selections. Furthermore,
    we take each client selection and rely on `addConditions()` to enrich them accordingly:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个查询没有涉及任何客户端选择。此外，我们针对每个客户端选择，并依靠`addConditions()`来相应地丰富它们：
- en: '[PRE178]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Finally, we execute the query and fetch the results:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们执行查询并获取结果：
- en: '[PRE190]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Done! The same thing can be expressed like this as well:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！同样的事情也可以这样表达：
- en: '[PRE191]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'If you don''t have a start condition (a fix condition), then you can start
    from a dummy `true` condition:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有起始条件（一个固定条件），那么你可以从一个虚拟的`true`条件开始：
- en: '[PRE208]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Besides `trueCondition()`, we can use `falseCondition()` or `noCondition()`.
    More details are available here: [https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/true-false-no-condition/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/true-false-no-condition/).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`trueCondition()`之外，我们还可以使用`falseCondition()`或`noCondition()`。更多详情请参阅[https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/true-false-no-condition/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/true-false-no-condition/)。
- en: Next, use `and()`, `or()`, `andNot()`, `andExists()`, and so on to chain the
    optional conditions as you feel appropriate.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`and()`、`or()`、`andNot()`、`andExists()`等来按适当的方式链式连接可选条件。
- en: 'However, conditions are not the only flexible parts of a dynamic query. For
    instance, let''s assume that we have a query that returns the office''s cities
    and countries (`OFFICE.CITY` and `OFFICE.COUNTRY`). However, depending on client
    selections, this query should also return the employees from these offices (`EMPLOYEE`)
    and the sales of these employees (`SALE`). This means that our query should be
    dynamically appended with joins. Via the `SelectQuery` API, this can be done via
    `addJoin()` methods, exemplified here:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，条件并不是动态查询中唯一的灵活部分。例如，假设我们有一个查询返回办公室的城市和国家（`OFFICE.CITY`和`OFFICE.COUNTRY`）。然而，根据客户端的选择，这个查询还应返回这些办公室的员工（`EMPLOYEE`）以及这些员工的销售额（`SALE`）。这意味着我们的查询应该动态地添加连接。通过`SelectQuery`
    API，这可以通过`addJoin()`方法完成，如下所示：
- en: '[PRE209]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: As you can see, `addJoin()` comes in different flavors. Mainly, there is a set
    of `addJoin()` that implicitly generates an `INNER JOIN` (as `addJoin(TableLike<?>
    tl, Condition cndtn)`), a set of `addJoin()` that allows us to specify the type
    of join via the `JoinType` enumeration (as  `addJoin(TableLike<?> tl, JoinType
    jt, Condition... cndtns)`), a set of `addJoinOnKey()` that generates the `ON`
    predicate based on the given foreign key (as `addJoinOnKey(TableLike<?> tl, JoinType
    jt, ForeignKey<?,?> fk)`), and a set of `addJoinUsing()` that relies on the `USING`
    clause (as `addJoinUsing``(TableLike<?> table, Collection<? extends Field<?>>
    fields)`).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`addJoin()`有多种形式。主要的是有一组`addJoin()`会隐式生成一个`INNER JOIN`（如`addJoin(TableLike<?>
    tl, Condition cndtn)`），有一组`addJoin()`允许我们通过`JoinType`枚举指定连接类型（如`addJoin(TableLike<?>
    tl, JoinType jt, Condition... cndtns)`），有一组`addJoinOnKey()`会根据给定的外键生成`ON`谓词（如`addJoinOnKey(TableLike<?>
    tl, JoinType jt, ForeignKey<?,?> fk)`），以及一组`addJoinUsing()`依赖于`USING`子句（如`addJoinUsing(TableLike<?>
    table, Collection<? extends Field<?>> fields)`）。
- en: Next to the `addFoo()` methods used/mentioned here, we have `addFrom()`, `addHaving()`,
    `addGroupBy()`, `addLimit()`, `addWindow()`, and so on. You can find all of them
    and their flavors in the jOOQ documentation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用/提到的`addFoo()`方法旁边，我们有`addFrom()`、`addHaving()`、`addGroupBy()`、`addLimit()`、`addWindow()`等等。你可以在jOOQ文档中找到所有这些及其变体。
- en: 'Sometimes, we need to simply reuse a part of a query a number of times. For
    instance, the following figure is obtained by `UNION` the (near) same query:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要多次简单地重用查询的一部分。例如，以下图是通过`UNION`（几乎）相同的查询获得的：
- en: '![Figure 12.7 – Apply UNION to count and classify customer''s payment'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 应用UNION对客户的付款进行计数和分类'
- en: '](img/B16833_Figure_12.7.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_12.7.jpg)'
- en: Figure 12.7 – Apply UNION to count and classify customer's payment
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 应用UNION对客户的付款进行计数和分类
- en: 'The query behind this figure applies `UNION` to count and classifies the customers''
    payments based on the given classes, as shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此图背后的查询通过`UNION`对基于给定类别的客户付款进行计数和分类，如下所示：
- en: '[PRE226]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'However, if the number of classes varies (being an input parameter provided
    by the client), then the number of `UNION` statements also varies, and the `HAVING`
    clause must be appended dynamically. First, we can isolate the fixed part of our
    query, like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果类的数量变化（这是一个由客户提供的输入参数），那么`UNION`语句的数量也会变化，并且必须动态地附加`HAVING`子句。首先，我们可以隔离查询的固定部分，如下所示：
- en: '[PRE250]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Next, we should `UNION` a `getQuery()` for each given class and generate the
    specific `HAVING` clause, but not before reading the following important note.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该对每个给定的类`UNION`一个`getQuery()`并生成特定的`HAVING`子句，但在阅读以下重要提示之前不要这样做。
- en: Important Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that it is not possible to use the same instance of a `SelectQuery` on
    both sides of a set operation such as `s.union(s)`, so you'll need a new `SelectQuery`
    for each `UNION`. This seems to be a fixable bug, so this note may not be relevant
    when you read this book.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在集合操作（如`s.union(s)`）的两边不能使用相同的`SelectQuery`实例，因此你需要为每个`UNION`创建一个新的`SelectQuery`。这似乎是一个可修复的错误，所以当你阅读这本书时，这个注意事项可能不再相关。
- en: 'This can be done as shown in this simple code:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下简单代码完成：
- en: '[PRE258]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'Of course, you can try to write this much cleverly and more compact. A call
    of this method is shown here:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以尝试写得更加巧妙和紧凑。这里展示了此方法的调用：
- en: '[PRE287]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: In order to check out these examples, refer to the *DynamicQuery* application.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这些示例，请参考*DynamicQuery*应用程序。
- en: InsertQuery, UpdateQuery, and DeleteQuery
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: InsertQuery, UpdateQuery, 和 DeleteQuery
- en: Dynamic queries representing DML operations are also supported by jOOQ. `InsertQuery`,
    `UpdateQuery`, and `DeleteQuery` work on the same principle as `SelectQuery` and
    expose a comprehensive API intended to chain SQL parts into a valid and dynamic
    SQL query.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ也支持表示DML操作的动态查询。`InsertQuery`、`UpdateQuery`和`DeleteQuery`与`SelectQuery`的工作原理相同，并公开了一个综合的API，旨在将SQL部分链接成一个有效且动态的SQL查询。
- en: 'Let''s see an example of using `InsertQuery` to insert a `PRODUCT` (a classic
    car), based on data provided by the client, and return the generated identity:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`InsertQuery`插入一个基于客户提供的数据的`PRODUCT`（一辆经典汽车）并返回生成的ID的例子：
- en: '[PRE290]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: As you'll see in the jOOQ documentation, the `InsertQuery` API supports many
    more methods, such as `addConditions()`, `onDuplicateKeyIgnore()`, `onConflict()`,
    `setSelect()`, and `addValueForUpdate()`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在jOOQ文档中看到的，`InsertQuery` API支持许多其他方法，例如`addConditions()`、`onDuplicateKeyIgnore()`、`onConflict()`、`setSelect()`和`addValueForUpdate()`。
- en: 'How about a dynamic update or delete? Here is a very intuitive example of a
    dynamic update:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 动态更新或删除怎么样？这里有一个动态更新的非常直观的例子：
- en: '[PRE314]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'And here''s what code for a dynamic delete of sales (`SALE`) looks like:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是动态删除销售（`SALE`）的代码示例：
- en: '[PRE322]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: You can check out these examples in *DynamicQuery*. After exploring these APIs,
    take your time and challenge yourself to write your own dynamic queries. It's
    really fun and helps you get familiar with this amazingly simple but powerful
    API.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*DynamicQuery*中查看这些示例。在探索这些API之后，花些时间挑战自己编写你自己的动态查询。这真的很有趣，并帮助你熟悉这个简单但强大的API。
- en: Writing generic dynamic queries
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写通用的动态查询
- en: 'Sooner or later, you''ll realize that what you need is a generic dynamic query.
    For instance, you may encounter a scenario that sounds like this. You need to
    select from an arbitrary table a number of arbitrary columns, based on arbitrary
    conditions. In such a scenario, it will be inefficient to duplicate the code only
    to vary the name of the table, columns, and conditions. So, most probably, you''ll
    prefer a generic dynamic query, as shown here:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，你会意识到你需要的是一个通用的动态查询。例如，你可能遇到一个听起来像这样的场景。你需要根据任意条件从任意表中选取任意列。在这种情况下，仅仅为了改变表名、列名和条件而重复代码将是不高效的。所以，很可能会选择一个通用的动态查询，如下所示：
- en: '[PRE333]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'Calling this method can be done as shown in the following examples:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个方法可以像以下示例那样进行：
- en: '[PRE341]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'If you want to rely only on the first type of call – that is, calls based on
    jOOQ-generated code – then you can enforce the type-safety of the generic method
    by replacing `SelectField<?>` with `TableField<R, ?>`, as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想依赖第一种类型的调用——即基于jOOQ生成的代码的调用——那么你可以通过将`SelectField<?>`替换为`TableField<R,
    ?>`来强制通用方法的类型安全，如下所示：
- en: '[PRE352]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'This time, only the first call (`List<ProductRecord> rs1 = …`) compiles and
    works. The same thing applies to DML operations – for instance, inserting in an
    arbitrary table:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，只有第一次调用（`List<ProductRecord> rs1 = …`）编译并工作。同样的情况也适用于DML操作——例如，在任意表中插入：
- en: '[PRE360]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'Here is a call example of the previous method:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前一种方法的调用示例：
- en: '[PRE366]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'Alternatively, for an arbitrary update, we can write the following method:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于任意的更新，我们可以编写以下方法：
- en: '[PRE370]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'Here is a call example of the previous method:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前一种方法的调用示例：
- en: '[PRE377]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: 'Alternatively, for an arbitrary delete, we can write the following method:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于任意的删除，我们可以编写以下方法：
- en: '[PRE380]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: 'Here is a call example of the previous method:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前一种方法的调用示例：
- en: '[PRE386]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: You can see these examples next to others in *GenericDynamicQuery*.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*GenericDynamicQuery*旁边看到这些示例。
- en: Writing functional dynamic queries
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写作功能动态查询
- en: 'Functional dynamic queries take this topic to the next level. However, let''s
    try to see how and why we should evolve a query from zero to functional implementation.
    Let''s assume that we develop an application for an organization''s sales department,
    and we have to write a query that filters sales (`SALE`) by fiscal year (`SALE.FISCAL_YEAR`).
    Initially (day 1), we can do it as shown here:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 功能动态查询将这个主题提升到了新的水平。然而，让我们尝试看看我们应该如何以及为什么应该从零到功能实现地演变查询。让我们假设我们为某个组织的销售部门开发应用程序，我们必须编写一个查询来过滤销售（`SALE`）按财政年度（`SALE.FISCAL_YEAR`）。最初（第一天），我们可以像下面这样操作：
- en: '[PRE390]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: 'While everybody was satisfied with the result, we got a new request for a filter
    that obtains the sales of a certain trend (`SALE.TREND`). We''ve done this on
    day 1, so there is no problem to repeat it on day 2:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个人都对结果感到满意时，我们收到了一个新的请求，需要获取某种趋势（`SALE.TREND`）的销售。我们在第一天已经做过这个操作，所以第二天重复它没有问题：
- en: '[PRE397]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: 'This filter is the same as the filter from day 1, only that it has a different
    condition/filter. We realize that continuing like this will end up with a lot
    of similar methods that just repeat the code for different filters, which means
    a lot of *boilerplate* code. While reflecting on this aspect, we just got an urgent
    request for a filter of sales by fiscal year and trend. So, our horrible solution
    on day 3 is shown here:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器与第一天的过滤器相同，只是它有一个不同的条件/过滤器。我们意识到继续这样下去将导致大量类似的方法，这些方法只是为不同的过滤器重复代码，这意味着大量的*样板代码*。在反思这个方面时，我们刚刚收到了一个紧急请求，需要按财政年度和趋势进行销售过滤。所以，我们第三天的糟糕解决方案如下所示：
- en: '[PRE403]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: After 3 days, we realize that this becomes unacceptable. The code becomes verbose,
    hard to maintain, and prone to errors.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 经过3天后，我们意识到这是不可接受的。代码变得冗长，难以维护，并且容易出错。
- en: 'On day 4, while looking for a solution, we noticed in the jOOQ documentation
    that the `where()` method also comes with `where(Collection<? extends Condition>
    clctn)` and `where(Condition... cndtns)`. This means that we can simplify our
    solution to something like this:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四天，当我们寻找解决方案时，在jOOQ文档中注意到`where()`方法还提供了`where(Collection<? extends Condition>
    clctn)`和`where(Condition... cndtns)`。这意味着我们可以简化我们的解决方案，如下所示：
- en: '[PRE411]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'This is quite nice because we can pass any set of conditions without modifying
    the `filterSaleBy()` method. Here is a call example:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当不错，因为我们可以在不修改`filterSaleBy()`方法的情况下传递任何一组条件。以下是一个调用示例：
- en: '[PRE418]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: 'However, this is not type-safe. For instance, the error from this call is discovered
    only at compile time (check out the code in bold):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是类型安全的。例如，这个调用的错误只有在编译时才会被发现（查看粗体代码）：
- en: '[PRE422]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'Well, a new day brings a new idea! On day 5, we defined an interface to prevent
    the type-safety issues from day 4\. This is a functional interface, as shown here:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，新的一天带来了新的想法！在第 5 天，我们定义了一个接口来防止第 4 天的类型安全问题。这是一个函数式接口，如下所示：
- en: '[PRE426]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'And `filterSaleBy()` becomes the following:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `filterSaleBy()` 变成了以下形式：
- en: '[PRE431]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: 'Problem solved! This time, we can run this type-safe call:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决！这次，我们可以运行这个类型安全的调用：
- en: '[PRE437]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: 'On day 6, Mark (our colleague) noticed this code, and he enlightens us that
    Java 8 already has this functional interface, which is called `java.util.function.Function<T,
    R>`. So, there is no need to define our `SaleFunction`, since `Function` can do
    the job, as shown here:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 天，我们的同事马克注意到了这段代码，他向我们指出 Java 8 已经有了这个函数式接口，称为 `java.util.function.Function<T,
    R>`。因此，没有必要定义我们的 `SaleFunction`，因为 `Function` 可以完成这项工作，如下所示：
- en: '[PRE439]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: 'On day 7, we noticed that calling `filterSaleBy()` works only for a single
    condition. However, we need to pass multi-conditions as well (as we did earlier
    when we were using `Collection<Condition>`). This led to the decision of modifying
    `filterSaleBy()` to accept an array of `Function`. The challenge is represented
    by applying this array of `Function`, and the solution relies on `Arrays.stream(array)`
    or `Stream.of(array)`, as shown here (use the one that you find more expressive;
    as an example, behind the scenes, `Stream.of()` calls `Arrays.stream()`):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 天，我们注意到调用 `filterSaleBy()` 只适用于单个条件。然而，我们还需要传递多个条件（就像我们在使用 `Collection<Condition>`
    的时候所做的那样）。这导致了修改 `filterSaleBy()` 以接受一个 `Function` 数组的决定。挑战在于应用这个 `Function` 数组，解决方案依赖于
    `Arrays.stream(array)` 或 `Stream.of(array)`，如下所示（使用你认为更具有表达力的一个；作为一个例子，在幕后，`Stream.of()`
    调用了 `Arrays.stream()`）：
- en: '[PRE446]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: 'Now, we can write type-safe calls, like this one:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写类型安全的调用，如下所示：
- en: '[PRE454]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'Cool! Day 8 was an important day because we managed to adjust this code to
    work for any table and conditions by writing it generically:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！第 8 天是一个重要的日子，因为我们设法通过编写泛型代码使这段代码适用于任何表和条件：
- en: '[PRE458]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: 'Here are some call samples:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些调用示例：
- en: '[PRE464]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: 'On day 9, we start to consider tuning this query. For instance, instead of
    fetching all fields via `selectFrom()`, we decided to add an argument to receive
    the fields that should be fetched as a `Collection<TableField<R, ?>>`. Moreover,
    we decided to defer the creation of such a collection until they are really used,
    and in order to accomplish this, we wrapped the collection in a `Supplier`, as
    shown here:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 天，我们开始考虑调整这个查询。例如，我们决定不再通过 `selectFrom()` 获取所有字段，而是添加一个参数来接收应该获取的字段，作为一个
    `Collection<TableField<R, ?>>`。此外，我们决定将这些字段集合的创建推迟到它们真正被使用时，为了实现这一点，我们将集合包装在一个
    `Supplier` 中，如下所示：
- en: '[PRE475]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: 'Here is a call sample:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个调用示例：
- en: '[PRE484]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: 'Maybe you want to support a call like the following one as well:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你还想支持以下这样的调用：
- en: '[PRE488]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: 'In such a case, replace `TableField<R, ?>` with `SelectField<?>`, as shown
    here:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将 `TableField<R, ?>` 替换为 `SelectField<?>`，如下所示：
- en: '[PRE494]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: Done! I hope you've found this story and examples useful and inspirational for
    your own functional generic dynamic queries. Until then, you can see these examples
    in the bundled code, named *FunctionalDynamicQuery*.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！我希望你发现这个故事和示例对你的功能性泛型动态查询有用且富有启发性。在此之前，你可以在名为 *FunctionalDynamicQuery* 的捆绑代码中查看这些示例。
- en: Infinite scrolling and dynamic filters
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限滚动和动态筛选
- en: 'In the last section of this chapter, let''s bring together our two main topics
    – pagination and dynamic queries. Earlier, in the *Implementing infinite scroll*
    section, we implemented infinite scrolling for the `ORDERDETAIL` table. Now, let''s
    add some filters for `ORDERDETAIL` that allows a client to choose the price and
    quantity ordered range, as shown in this figure:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，让我们将我们的两个主要主题——分页和动态查询——结合起来。在之前的 *实现无限滚动* 部分中，我们为 `ORDERDETAIL` 表实现了无限滚动。现在，让我们为
    `ORDERDETAIL` 添加一些筛选器，允许客户端选择价格和订购数量的范围，如图所示：
- en: '![Figure 12.8 – Infinite scrolling and dynamic filters'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.8 – 无限滚动和动态筛选'
- en: '](img/B16833_Figure_12.8.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_12.8.jpg)'
- en: Figure 12.8 – Infinite scrolling and dynamic filters
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 无限滚动和动态筛选
- en: 'We can easily implement this behavior by fusing the powers of `SEEK` and `SelectQuery`:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过融合 `SEEK` 和 `SelectQuery` 的力量轻松实现这种行为：
- en: '[PRE503]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: 'The following example URL involves loading the first page of three records
    that have prices between *50* and *100*, and an order quantity between *50* and
    *75*:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例 URL 涉及加载价格在 *50* 到 *100* 之间，订购数量在 *50* 到 *75* 之间的前三个记录的第一页：
- en: '[PRE521]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: You can find the complete example in *SeekInfiniteScrollFilter* for MySQL.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在名为 *SeekInfiniteScrollFilter* 的 MySQL 中找到完整的示例。
- en: Summary
  id: totrans-693
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This was a relatively short chapter about pagination and dynamic queries. As
    you saw, jOOQ excels on both topics and provides support and APIs that allow us
    to intuitively and quickly implement the simplest to the most complex scenarios.
    In the first part of this chapter, we covered offset and keyset pagination (including
    infinite scrolling, the fancy `DENSE_RANK()`, and the `ROW_NUMBER()` approach).
    In the second part, we covered dynamic queries, including the ternary operator,
    the `Comparator` API, the `SelectQuery`, `InsertQuery`, `UpdateQuery`, and `DeleteQuery`
    APIs, and their respective generic and functional dynamic queries.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章相对简短的章节，关于分页和动态查询。正如你所见，jOOQ在这两个主题上都表现出色，并提供了支持和API，使我们能够直观且快速地实现从最简单到最复杂的场景。在本章的第一部分，我们介绍了偏移量和键集分页（包括无限滚动、花哨的`DENSE_RANK()`和`ROW_NUMBER()`方法）。在第二部分，我们讨论了动态查询，包括三元运算符、`Comparator`
    API、`SelectQuery`、`InsertQuery`、`UpdateQuery`和`DeleteQuery` API，以及它们各自的泛型和功能动态查询。
- en: In the next chapter, we will talk about exploiting SQL functions.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论利用SQL函数。
