- en: '*Chapter 12*: Pagination and Dynamic Queries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll talk about pagination and dynamic queries in jOOQ, two
    topics that work hand in hand in a wide range of applications to paginate and
    filter lists of products, items, images, posts, articles, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ offset pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jOOQ keyset pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing dynamic queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinite scrolling and dynamic filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter12](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Offset and keyset pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Offset and keyset pagination (or seek, as Markus Winand calls it) represent
    two well-known techniques for paginating data while fetching it from the database.
    Offset pagination is quite popular because Spring Boot (more precisely, Spring
    Data Commons) provides two default implementations for it, via the `Page` and
    `Slice` APIs. Therefore, in terms of productivity, it's very convenient to rely
    on these implementations. However, in terms of performance, while your project
    evolves and data keeps accumulating, relying on offset pagination may lead to
    serious performance degradations. Nevertheless, as you'll see soon, jOOQ can help
    you to sweeten the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, keyset pagination is a technique that sustains high performance,
    being faster and more stable than offset pagination. Keyset pagination really
    shines on paginating large datasets and infinite scrolling, while it leads to
    almost the same performance as offset pagination, especially for relatively small
    datasets. However, can you guarantee that the amount of data will not grow over
    time (sometimes, quite fast)? If yes, then using offset pagination should be okay.
    Otherwise, it is better to prevent this well-known performance issue right from
    the start and rely on keyset pagination. Don't think that this is premature optimization;
    think of it as the capability to make the right decisions depending on the business
    case you are modeling. And, as you'll see soon, jOOQ makes keyset pagination usage
    child's play.
  prefs: []
  type: TYPE_NORMAL
- en: Index scanning in offset and keyset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dealing with offset pagination means you can ignore the performance penalty
    induced by throwing away *n* records before reaching the desired offset. A larger
    *n* leads to a significant performance penalty that equally affects both the `Page`
    and `Slice` APIs. Another penalty is the extra `SELECT COUNT` needed to count
    the total number of records. This extra `SELECT COUNT` is specific to the `Page`
    API only, so it doesn't affect the `Slice` API. Basically, this is the main difference
    between the `Page` and `Slice` APIs; the former contains the total number of records
    (useful for computing the total number of pages), while the latter can only tell
    whether there is at least one more page available or this is the last page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lukas Eder has a very nice observation here: *"Another way I tend to think
    about this is: What''s the business value of being able to jump to page 2712?
    What does that page number even mean? Shouldn''t the search be refined with better
    filters instead? On the other hand, jumping to the *next* page from any page is
    a very common requirement."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'An index scan in offset will traverse the range of indexes from the beginning
    to the specified offset. Basically, the offset represents the number of records
    that must be skipped before including them in the result set. So, the offset approach
    will traverse the already shown records, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – An index scan in offset and keyset pagination'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_12.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – An index scan in offset and keyset pagination
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the index scan in the keyset pagination will traverse only
    the required values, starting with the last previous value (it skips the values
    until the last value previously fetched). In the keyset, the performance remains
    approximately constant in relation to the increase of the table records.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: An important reference and compelling argument against using offset pagination
    is mentioned on the *USE THE INDEX, LUKE!* website ([https://use-the-index-luke.com/no-offset](https://use-the-index-luke.com/no-offset)).
    I strongly suggest you take some time and watch this great presentation by Markus
    Winand ([https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way?ref=https://use-the-index-luke.com/no-offset](https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way?ref=https://use-the-index-luke.com/no-offset)),
    which covers important topics for tuning pagination-SQL, such as using indexes
    and row values (supported in PostgreSQL) in offset and keyset pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, after this summary of offset versus keyset pagination, let's see how jOOQ
    can mimic and even improve the default Spring Boot offset pagination implementation.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ offset pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot implementation of offset pagination can be easily shaped via `LIMIT
    … OFFSET` (or `OFFSET … FETCH`) and `SELECT COUNT`. For instance, if we assume
    that a client gives us a page number (via the `page` argument) and `size` (the
    number of products to be displayed on `page`), then the following jOOQ query mimics
    the default Spring Boot pagination behavior for the `PRODUCT` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the client (for instance, the browser) expects as a response a serialization
    of the classical `Page<Product>` (`org.springframework.data.domain.Page`), then
    you can simply produce it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, instead of executing two `SELECT` statements, we can use the `COUNT()`
    window function to obtain the same result but with a single `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is already better than the default Spring Boot implementation. When you
    return this `Map<Integer, List<Product>>` to the client, you can return a `Page<Product>`
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Most probably, you'll prefer `Page` because it contains a set of metadata, such
    as the total number of records if we hadn't paginated (`totalElements`), the current
    page we're on (`pageNumber`), the actual page size (`pageSize`), the actual offsets
    of the returned rows (`offset`), and whether we are on the last page (`last`).
    You can find the previous examples in the bundled code as *PaginationCountOver*.
  prefs: []
  type: TYPE_NORMAL
- en: However, as Lukas Eder highlights in this article ([https://blog.jooq.org/2021/03/11/calculating-pagination-metadata-without-extra-roundtrips-in-sql/](https://blog.jooq.org/2021/03/11/calculating-pagination-metadata-without-extra-roundtrips-in-sql/)),
    all this metadata can be obtained in a single SQL query; therefore, there is no
    need to create a `Page` object to have them available. In the bundled code (*PaginationMetadata*)
    you can practice Lukas's dynamic query via a REST controller.
  prefs: []
  type: TYPE_NORMAL
- en: jOOQ keyset pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keyset (or seek) pagination doesn''t have a default implementation in Spring
    Boot, but this shouldn''t stop you from using it. Simply start by choosing a table''s
    column that should act as the latest visited record/row (for instance, the id
    column), and use this column in the `WHERE` and `ORDER BY` clauses. The idioms
    relying on the ID column are as follows (sorting by multiple columns follows this
    same idea):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the experience gained so far, expressing these queries in jOOQ should
    be a piece of cake. For instance, let''s apply the first idiom to the `PRODUCT`
    table via `PRODUCT_ID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In MySQL, the rendered SQL is (where `productId` = `20` and `size` = `5`) as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This was easy! You can practice this case in *KeysetPagination*.
  prefs: []
  type: TYPE_NORMAL
- en: However, keyset pagination becomes a little bit trickier if the `WHERE` clause
    becomes more complicated. Fortunately, jOOQ saves us from this scenario via a
    synthetic clause named `SEEK`. Let's dive into it!
  prefs: []
  type: TYPE_NORMAL
- en: The jOOQ SEEK clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The jOOQ synthetic `SEEK` clause simplifies the implementation of keyset pagination.
    Among its major advantages, the `SEEK` clause is type-safe and is capable of generating/emulating
    the correct/expected `WHERE` clause (including the emulation of row value expressions).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the previous keyset pagination example can be expressed using
    the `SEEK` clause, as shown here (`productId` is provided by the client):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is no explicit `WHERE` clause. jOOQ will generate it on our
    behalf, based on the `seek()` arguments. While this example may not look so impressive,
    let''s consider another one. This time, let''s paginate `EMPLOYEE` using the employee''s
    office code and salary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `officeCode` and `salary` are provided by the client, and they land into
    the following generated SQL sample (where `officeCode` = `1`, `salary` = `75000`,
    and `size` = `10`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Check out the generated `WHERE` clause! I am pretty sure that you don't want
    to get your hands dirty and explicitly write this clause. How about the following
    example?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following code is a sample of the generated SQL (where `orderId` =
    `10100`, `productId` = `23`, `quantityOrdered` = `30`, and `size` = `10`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'After this example, I think is obvious that you should opt for the `SEEK` clause
    and let jOOQ do its job! Look, you can even do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *SeekClausePagination*, next to the other
    examples, including using jOOQ-embedded keys as arguments of the `SEEK` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing infinite scroll
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Infinite scroll is a classical usage of keyset pagination and is gaining popularity
    these days. For instance, let''s assume that we plan to obtain something, as shown
    in this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – An infinite scroll'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_12.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – An infinite scroll
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we want an infinite scroll over the `ORDERDETAIL` table. At each scroll,
    we fetch the next *n* records via the `SEEK` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This method gets the last visited `ORDERDETAIL_ID` and the number of records
    to fetch (`size`), and it returns a list of `jooq.generated.tables.pojos.Orderdetail`,
    which will be serialized in JSON format via a Spring Boot REST controller endpoint
    defined as `@GetMapping("/orderdetail/{orderdetailId}/{size}")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, we rely on the JavaScript Fetch API (of course, you can
    use XMLHttpRequest, jQuery, AngularJS, Vue, React, and so on) to execute an HTTP
    `GET` request, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'For fetching exactly three records, we replace `${size}` with `3`. Moreover,
    the `${start}` placeholder should be replaced by the last visited `ORDERDETAIL_ID`,
    so the `start` variable can be computed as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'While scrolling, your browser will execute an HTTP request at every three records,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: You can check out this example in *SeekInfiniteScroll*. Next, let's see an approach
    for paginating `JOIN` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Paginating JOINs via DENSE_RANK()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to paginate offices (`OFFICE`) with employees (`EMPLOYEE`).
    If we apply a classical offset or keyset pagination to the `JOIN` between `OFFICE`
    and `EMPLOYEE`, then the result is prone to be truncated. Therefore, an office
    can be fetched with only a subset of its employees. For instance, while we think
    of a result page of size 3 as containing three offices with all their employees,
    we instead get a single office with three employees (even if this office has more
    employees). The following figure reveals what we expect versus what we get from
    a page of size 3 (offices):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Join pagination'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_12.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Join pagination
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to obtain a result set like the one on the left-hand side of the preceding
    figure, we can rely on the `DENSE_RANK()` window function, which assigns a sequential
    number to different values of `a` within each group `b`, as shown in the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The `start` and `end` variables represent the range of offices set via `DENSE_RANK()`.
    The following figure should clarify this aspect where `start` = `1` and `end`
    = `3` (the next page of three offices is between `start` = `4` and `end` = `6`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – The DENSE_RANK() effect'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_12.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – The DENSE_RANK() effect
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a more compact version of the previous query, using the `QUALIFY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: You can check out these examples (offset, keyset, and `DENSE_RANK()` queries)
    via three REST controller endpoints in *DenseRankPagination* for MySQL. In all
    these cases, the returned `Map<Office, List<Employee>>` is serialized to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Paginating database views via ROW_NUMBER()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider the following figure, representing a snapshot of a database
    view named `PRODUCT_MASTER` (it could be a regular table as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – The PRODUCT_MASTER database view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_12.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – The PRODUCT_MASTER database view
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to paginate this view by `PRODUCT_LINE` (first column), so we
    have to take into account the fact that `PRODUCT_LINE` contains duplicates. While
    this is not an issue for offset pagination, it could produce weird results for
    keyset pagination relying only on `PRODUCT_LINE` and `LIMIT` (or counterparts)
    clauses. We can eliminate this issue by using the (`PRODUCT_LINE`, `PRODUCT_NAME`)
    combo in `ORDER BY` and `WHERE` predicate. This will work as expected because
    `PRODUCT_NAME` contains unique values.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's try another approach, relying on the `ROW_NUMBER()` window function.
    This function assigns a database temporary sequence of values to rows. More precisely,
    the `ROW_NUMBER()` window function produces a sequence of values that starts from
    value 1 with an increment of 1\. This is a temporary sequence of values (non-persistent)
    that is calculated dynamically at query execution time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on `ROW_NUMBER()`, we can visualize `PRODUCT_MASTER`, as shown in this
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – The ROW_NUMBER() effect'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_12.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – The ROW_NUMBER() effect
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, expressing pagination can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can make it more compact via the `QUALIFY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Fetching the first page of size 5 can be done via `start` = `1` and `end` =
    `5`. Fetching the next page of size 5 can be done via `start` = `6` and `end`
    = `10`. The complete example is available in the bundler code as *RowNumberPagination*
    for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that's enough about pagination. Next, let's tackle dynamic queries (filters).
  prefs: []
  type: TYPE_NORMAL
- en: Writing dynamic queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commonly, a dynamic query contains no or some fixed parts and some other parts
    that can be appended at runtime to form a query that corresponds to a certain
    scenario or use case.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: In jOOQ, even when they look like static queries (due to jOOQ's API design),
    every SQL is dynamic; therefore, it can be broken up into query parts that can
    be fluently glued back in any valid jOOQ query. We already have covered this aspect
    in [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040), *jOOQ Core Concepts*, in the
    *Understanding the jOOQ fluent API* section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically creating an SQL statement on the fly is one of the favorite topics
    of jOOQ, so let's try to cover some approaches that can be useful in real applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java ternary operator (`?`) is probably the simplest approach for shaping
    a query at runtime. Check out this sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The `PRODUCT.BUY_PRICE.gt(BigDecimal.valueOf(buyPrice))` condition is appended
    only if the passed `buyPrice` is greater than 0; otherwise, we rely on the handy
    `noCondition()` method. Next, depending on the `cars` flag, we shape the range
    of values for `PRODUCT.PRODUCT_LINE.in()`. Via this single jOOQ query, we can
    shape four different SQL queries at runtime, depending on the `buyPrice` and `cars`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Using jOOQ comparators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The jOOQ `Comparator` API is quite handy for toggling comparison operators
    in conditions while remaining fluent. For instance, let''s assume that the client
    (user, service, and so on) can choose between two categories of employees – a
    category of all the sales reps and a category of non-sales reps. If the client
    chooses the first category, then we want to fetch all employees (`EMPLOYEE`) that
    have a `salary` less than *65,000*. However, if the client chooses the second
    category, then we want to fetch all employees (`EMPLOYEE`) that have a `salary`
    greater than or equal to *65,000*. Instead of writing two queries or using any
    other approach, we can rely on jOOQ''s `Comparator.IN` and `Comparator.NOT_IN`
    (note that, in the case of `NOT_IN`, the projected column(s) should be `NOT NULL`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ provides a comprehensive list of built-in comparators, including `EQUALS`,
    `GREATER`, `LIKE`, and `IS_DISTINCT_FROM`. While you can find all of them covered
    in the jOOQ documentation, here is another example that uses `Comparator.LESS`
    and `Comparator.GREATER` to express in jOOQ a query that can be translated into
    four SQL queries, depending on the values of `buyPrice` and `msrp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: You can check out these examples next to others in *DynamicQuery*.
  prefs: []
  type: TYPE_NORMAL
- en: Using SelectQuery, InsertQuery, UpdateQuery, and DeleteQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of the `SelectQuery` (`InsertQuery`, `UpdateQuery`, and `DeleteQuery`)
    types is to allow the expression of dynamic queries in an imperative style. However,
    it is recommended to avoid this imperative style and use a more functional style,
    as you'll see soon in this chapter. So, while you read this section, consider
    this sentence as a disclaimer.
  prefs: []
  type: TYPE_NORMAL
- en: When the previous approaches can't be used or the query becomes cluttered, it
    is time to turn your attention to the `SelectQuery` (`InsertQuery`, `UpdateQuery`,
    and `DeleteQuery`) APIs. These jOOQ APIs are very useful for expressing dynamic
    queries because they contain dedicated methods for appending different parts of
    a query effortlessly (for example, conditions, joins, having, and order by).
  prefs: []
  type: TYPE_NORMAL
- en: Using SelectQuery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For instance, let''s assume that our application exposes a filter for optionally
    selecting a price range (`startBuyPrice` and `endBuyPrice`), the product vendor
    (`productVendor`), and the product scale (`productScale`) for ordering a `PRODUCT`.
    Based on the client selections, we should execute the proper `SELECT` query, so
    we start by writing a `SelectQuery`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this query doesn''t involve any of the client selections. Furthermore,
    we take each client selection and rely on `addConditions()` to enrich them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we execute the query and fetch the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! The same thing can be expressed like this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t have a start condition (a fix condition), then you can start
    from a dummy `true` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides `trueCondition()`, we can use `falseCondition()` or `noCondition()`.
    More details are available here: [https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/true-false-no-condition/](https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/true-false-no-condition/).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, use `and()`, `or()`, `andNot()`, `andExists()`, and so on to chain the
    optional conditions as you feel appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, conditions are not the only flexible parts of a dynamic query. For
    instance, let''s assume that we have a query that returns the office''s cities
    and countries (`OFFICE.CITY` and `OFFICE.COUNTRY`). However, depending on client
    selections, this query should also return the employees from these offices (`EMPLOYEE`)
    and the sales of these employees (`SALE`). This means that our query should be
    dynamically appended with joins. Via the `SelectQuery` API, this can be done via
    `addJoin()` methods, exemplified here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `addJoin()` comes in different flavors. Mainly, there is a set
    of `addJoin()` that implicitly generates an `INNER JOIN` (as `addJoin(TableLike<?>
    tl, Condition cndtn)`), a set of `addJoin()` that allows us to specify the type
    of join via the `JoinType` enumeration (as  `addJoin(TableLike<?> tl, JoinType
    jt, Condition... cndtns)`), a set of `addJoinOnKey()` that generates the `ON`
    predicate based on the given foreign key (as `addJoinOnKey(TableLike<?> tl, JoinType
    jt, ForeignKey<?,?> fk)`), and a set of `addJoinUsing()` that relies on the `USING`
    clause (as `addJoinUsing``(TableLike<?> table, Collection<? extends Field<?>>
    fields)`).
  prefs: []
  type: TYPE_NORMAL
- en: Next to the `addFoo()` methods used/mentioned here, we have `addFrom()`, `addHaving()`,
    `addGroupBy()`, `addLimit()`, `addWindow()`, and so on. You can find all of them
    and their flavors in the jOOQ documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to simply reuse a part of a query a number of times. For
    instance, the following figure is obtained by `UNION` the (near) same query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Apply UNION to count and classify customer''s payment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_12.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Apply UNION to count and classify customer's payment
  prefs: []
  type: TYPE_NORMAL
- en: 'The query behind this figure applies `UNION` to count and classifies the customers''
    payments based on the given classes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the number of classes varies (being an input parameter provided
    by the client), then the number of `UNION` statements also varies, and the `HAVING`
    clause must be appended dynamically. First, we can isolate the fixed part of our
    query, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: Next, we should `UNION` a `getQuery()` for each given class and generate the
    specific `HAVING` clause, but not before reading the following important note.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is not possible to use the same instance of a `SelectQuery` on
    both sides of a set operation such as `s.union(s)`, so you'll need a new `SelectQuery`
    for each `UNION`. This seems to be a fixable bug, so this note may not be relevant
    when you read this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done as shown in this simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can try to write this much cleverly and more compact. A call
    of this method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: In order to check out these examples, refer to the *DynamicQuery* application.
  prefs: []
  type: TYPE_NORMAL
- en: InsertQuery, UpdateQuery, and DeleteQuery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic queries representing DML operations are also supported by jOOQ. `InsertQuery`,
    `UpdateQuery`, and `DeleteQuery` work on the same principle as `SelectQuery` and
    expose a comprehensive API intended to chain SQL parts into a valid and dynamic
    SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of using `InsertQuery` to insert a `PRODUCT` (a classic
    car), based on data provided by the client, and return the generated identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: As you'll see in the jOOQ documentation, the `InsertQuery` API supports many
    more methods, such as `addConditions()`, `onDuplicateKeyIgnore()`, `onConflict()`,
    `setSelect()`, and `addValueForUpdate()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about a dynamic update or delete? Here is a very intuitive example of a
    dynamic update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s what code for a dynamic delete of sales (`SALE`) looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: You can check out these examples in *DynamicQuery*. After exploring these APIs,
    take your time and challenge yourself to write your own dynamic queries. It's
    really fun and helps you get familiar with this amazingly simple but powerful
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Writing generic dynamic queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sooner or later, you''ll realize that what you need is a generic dynamic query.
    For instance, you may encounter a scenario that sounds like this. You need to
    select from an arbitrary table a number of arbitrary columns, based on arbitrary
    conditions. In such a scenario, it will be inefficient to duplicate the code only
    to vary the name of the table, columns, and conditions. So, most probably, you''ll
    prefer a generic dynamic query, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this method can be done as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to rely only on the first type of call – that is, calls based on
    jOOQ-generated code – then you can enforce the type-safety of the generic method
    by replacing `SelectField<?>` with `TableField<R, ?>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, only the first call (`List<ProductRecord> rs1 = …`) compiles and
    works. The same thing applies to DML operations – for instance, inserting in an
    arbitrary table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a call example of the previous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for an arbitrary update, we can write the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a call example of the previous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for an arbitrary delete, we can write the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a call example of the previous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: You can see these examples next to others in *GenericDynamicQuery*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing functional dynamic queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functional dynamic queries take this topic to the next level. However, let''s
    try to see how and why we should evolve a query from zero to functional implementation.
    Let''s assume that we develop an application for an organization''s sales department,
    and we have to write a query that filters sales (`SALE`) by fiscal year (`SALE.FISCAL_YEAR`).
    Initially (day 1), we can do it as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'While everybody was satisfied with the result, we got a new request for a filter
    that obtains the sales of a certain trend (`SALE.TREND`). We''ve done this on
    day 1, so there is no problem to repeat it on day 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: 'This filter is the same as the filter from day 1, only that it has a different
    condition/filter. We realize that continuing like this will end up with a lot
    of similar methods that just repeat the code for different filters, which means
    a lot of *boilerplate* code. While reflecting on this aspect, we just got an urgent
    request for a filter of sales by fiscal year and trend. So, our horrible solution
    on day 3 is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: After 3 days, we realize that this becomes unacceptable. The code becomes verbose,
    hard to maintain, and prone to errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'On day 4, while looking for a solution, we noticed in the jOOQ documentation
    that the `where()` method also comes with `where(Collection<? extends Condition>
    clctn)` and `where(Condition... cndtns)`. This means that we can simplify our
    solution to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite nice because we can pass any set of conditions without modifying
    the `filterSaleBy()` method. Here is a call example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not type-safe. For instance, the error from this call is discovered
    only at compile time (check out the code in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, a new day brings a new idea! On day 5, we defined an interface to prevent
    the type-safety issues from day 4\. This is a functional interface, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'And `filterSaleBy()` becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: 'Problem solved! This time, we can run this type-safe call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'On day 6, Mark (our colleague) noticed this code, and he enlightens us that
    Java 8 already has this functional interface, which is called `java.util.function.Function<T,
    R>`. So, there is no need to define our `SaleFunction`, since `Function` can do
    the job, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: 'On day 7, we noticed that calling `filterSaleBy()` works only for a single
    condition. However, we need to pass multi-conditions as well (as we did earlier
    when we were using `Collection<Condition>`). This led to the decision of modifying
    `filterSaleBy()` to accept an array of `Function`. The challenge is represented
    by applying this array of `Function`, and the solution relies on `Arrays.stream(array)`
    or `Stream.of(array)`, as shown here (use the one that you find more expressive;
    as an example, behind the scenes, `Stream.of()` calls `Arrays.stream()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write type-safe calls, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Day 8 was an important day because we managed to adjust this code to
    work for any table and conditions by writing it generically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some call samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: 'On day 9, we start to consider tuning this query. For instance, instead of
    fetching all fields via `selectFrom()`, we decided to add an argument to receive
    the fields that should be fetched as a `Collection<TableField<R, ?>>`. Moreover,
    we decided to defer the creation of such a collection until they are really used,
    and in order to accomplish this, we wrapped the collection in a `Supplier`, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a call sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe you want to support a call like the following one as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: 'In such a case, replace `TableField<R, ?>` with `SelectField<?>`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: Done! I hope you've found this story and examples useful and inspirational for
    your own functional generic dynamic queries. Until then, you can see these examples
    in the bundled code, named *FunctionalDynamicQuery*.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite scrolling and dynamic filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section of this chapter, let''s bring together our two main topics
    – pagination and dynamic queries. Earlier, in the *Implementing infinite scroll*
    section, we implemented infinite scrolling for the `ORDERDETAIL` table. Now, let''s
    add some filters for `ORDERDETAIL` that allows a client to choose the price and
    quantity ordered range, as shown in this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Infinite scrolling and dynamic filters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_12.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Infinite scrolling and dynamic filters
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily implement this behavior by fusing the powers of `SEEK` and `SelectQuery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example URL involves loading the first page of three records
    that have prices between *50* and *100*, and an order quantity between *50* and
    *75*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete example in *SeekInfiniteScrollFilter* for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a relatively short chapter about pagination and dynamic queries. As
    you saw, jOOQ excels on both topics and provides support and APIs that allow us
    to intuitively and quickly implement the simplest to the most complex scenarios.
    In the first part of this chapter, we covered offset and keyset pagination (including
    infinite scrolling, the fancy `DENSE_RANK()`, and the `ROW_NUMBER()` approach).
    In the second part, we covered dynamic queries, including the ternary operator,
    the `Comparator` API, the `SelectQuery`, `InsertQuery`, `UpdateQuery`, and `DeleteQuery`
    APIs, and their respective generic and functional dynamic queries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about exploiting SQL functions.
  prefs: []
  type: TYPE_NORMAL
