- en: Chapter 6.  Persistence with Slick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned to bootstrap your application using Activator,
    we developed our web application using Scala and Play framework, and we added
    Reactive microservices calls using RxScala for data flow computations. We performed
    unit tests and controller testing using the BDD and Play frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to achieve relational database persistence.
    So far, we have our application up and running. However, we are using in-memory
    persistence with HashMap. Now we will upgrade our application to use proper persistence.
    In order to achieve this, we will use a reactive database persistence framework
    called Slick.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Principles of database persistence with Slick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Functional Relational Mapping in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Queries with SQL support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving code with Async database operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will do some refactoring in our application. Step-by-step, we will create
    all the tables and persistence classes that we need to have Slick working with
    our Play framework application. Tests will be refactored as well in order to test
    the application logic, and skip the database persistence part.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Slick framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scala Language Integrated Connection Kit** (**Slick**) is a Scala modern
    framework, which allows working with data using abstractions that are very similar
    to Scala collections. You can write database queries in both SQL and Scala code.
    Writing Scala code instead of SQL is better, because we leverage the compiler,
    and hence, this approach is less error-prone. Also, it becomes easier to maintain
    the code, since the compiler will help you by pointing out where the code breaks,
    if it happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Slick is a **Functional Relational Mapping** (**FRM**) library. Those of you
    who come from a Java background, and are familiar with **Object Relational Mapping**
    (**ORM**) frameworks such as Hibernate, will see that Slick has similar concepts.
    Basically, you create a Scala class, which will explicitly map to a relational
    table. Slick FRM ideas are inspired by Microsoft's LINQ framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slick is reactive by design, and works in an asynchronous non-blocking IO model.
    Using Slick you have the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resilience**: A common issue is that a heavy load on the DB and application
    creates more threads, and makes the situation worse. Slick can fix this problem,
    because it queues database operations in the DB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient Resources utilization**: Slick can be tuned for parallelism in
    terms of the number of active jobs and suspended database sessions. Slick also
    has a clean demarcation between I/O and CPU-intensive code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Slick with MySQL 5.6\. However, Slick supports other relational
    databases like Oracle, SQL Server, DB2, and Postgres. First of all, we need to
    install MySQL in our machine. Open the console, and perform the following steps
    (for Ubuntu Linux, other OS (Windows/Mac), and distros, check out [http://dev.mysql.com/downloads/mysql/](http://dev.mysql.com/downloads/mysql/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After installation with `apt-get`, when you run the other two commands, you
    should see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MySQL setup](img/image00290.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: MySQL Installation
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is done and the MySQL server is up and running, we can
    move on and create the database. In order to get this, we will need to open the
    MySQL console. For development reasons, I did not put a password for root. However,
    for production, it is strongly recommended that you do use a strong password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MySQL setup](img/image00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: MySQL Console
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you enter the MySQL console, you can create the database. We will create
    a database named `RWS_DB` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MySQL setup](img/image00292.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can type `$ SHOW DATABASES;` in order to get a list of all the available
    databases in MySQL. All set, we have our database up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Slick in our Play framework app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to add dependencies to the `build.sbt` file. We will need to
    remove or comment a library called `JDBC` and add the `play-slick` libraries and
    MySQL java driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we comment out the `JDBC` library, and
    add three new dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can go to the console and run the commands `$ activator`, `$ reload`, and
    `$ compile` in order to get SBT to download all the new dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Configure the database connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Slick needs to be configured to access the MySQL database that we created.
    Under the folder `ReactiveWebStore/conf`, we need to edit the `application.conf`
    file and add the database connection URL and settings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: FPM Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to create FPM mapping between our Scala code and MySQL tables
    under `ReactiveWebStore/app`, we will create a new package called `dao`. DAO stands
    for **Database Access Object** (**DAO**), and is a well-known OO pattern. So we
    will create some DAO classes here. First we will define a base trait, which will
    define the behavior and code capability for each of our `dao` packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with `BaseDao.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have three `dao` packages: `ProductDao`, `ImageDao`, and `ReviewDao`.
    Each `dao` will be able to perform  an operation, but over a different MySQL table.
    According to the trait we just defined, we will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**findAll**: Find all data for a specific table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**remove**: Delete an item in a table by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**insert**: Add new data to a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**update**: Update data in a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**findbyId**: Get a specific record in a table, filtered by ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**toTable**: Return the table FRM mapping for that `dao`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ProductDao
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with having a look at `ProductDao.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the `dao` implementation for `Product`. We have lots of new concepts
    here, so let's take a look at each step, one at a time. As you can see, a trait
    called `IProductDao` which extends from `BaseDao` using generics to specify the
    model `Product`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This trait is important for dependency injection using Guice. We will have
    two `dao` implementations for each model: one implementation using Slick and MySQL,
    and the other using our previous `inMemory` database for testing purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a class there called `ProductDao` which is the `dao` implementation
    using Slick. We need Guice to inject a class here, called `DatabaseConfigProvider`,
    which will be used to perform the database operations. `ProductDao` also needs
    to extend `HasDatabaseConfigProvider[JdbcProfile]` to work with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to import the `driver` api via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to create FRM mapping with a class called `ProductTable`, which
    extends table passing the model, which in our case is a product. You also need
    to announce the name of the MySQL table. In order to get the table name, we use
    a companion object, which we need to create around our models. We do it this way
    in order to avoid duplicating the MySQL table name everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ProductTable` table, you can see some functions such as `id`, `name`,
    `price`, and `details`. These are the exact name of the fields of `model.Product`.
    However, we have to add the mapping to the MySQL table on the right side. We do
    it using a function called `column` where we pass the type and the exact MySQL
    field name.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to run a special projection function called `*` to pass all
    the fields on the model, which are being mapped to the relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can move to the `dao` operations. As you can see, all the functions use
    `db.run` to perform data access. This is great because, as you can realize, they
    return a Future so the `dao` won't be blocking, and you can do something else,
    for instance, more database operations, pre-optimizations, and validations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a `ProductTable` table, we can create a Slick `TableQuery` with
    it to perform database operations as if they are Scala functions. In order to
    list all the available products, we just use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is as simple as that. This code will return a `Future [Seq[Products]]`.
    We can also filter by ID using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, `first _.id` is the `id` on the database, and `id` is the one that comes
    by parameter. After getting the result, you can see that we called another function
    called `headOption`, which makes sure that we get the result as an option. This
    is a great pattern to rely on, since the data might not be there on the table,
    and we avoid getting `NoSuchElementException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing a product is fairly trivial as well. We just use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This preceding code returns `Future[Int]`, counting the number of items that
    were deleted. If the record ID is not found in the database, the result will be
    `0`. We expect it to be always `1`, since we are going to delete by ID. However,
    the API is generic, and if, let's say, you delete by name or another field, you
    might have multiple deletes. That's why it is an `Int` and not a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inserting data is easy too; we just give the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is a very simple `map` function as if we were adding an element
    to a list. This code returns unit, which means nothing. However, we still have
    a Future, so this code is not blocking.
  prefs: []
  type: TYPE_NORMAL
- en: To perform an update, there is a little bit more code, but it is still simple
    at the end of the day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First we need to apply a filter to select the records that we will update. We
    pass the ID, because we just want to update a single record. Then we need to apply
    a `map` function to pick the fields that we want to update;  finally, we perform
    the update, passing the new values to the `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the companion object for the product model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `Models.Product.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a simple helper companion object to hold the MySQL table
    name.
  prefs: []
  type: TYPE_NORMAL
- en: ReviewDAO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are done with `ProductDao`, and now we need to move to the review model and
    create `dao` for reviews. We will perform steps similar to the ones we did for
    the product.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReviewDao.scala` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have the elements that we saw in `ProductDao`. There
    is an interface for `dao` called `IReviewDao`, which extends `BaseDao` using the
    review model. We have the `ReviewDao` implementation with the `ReviewTable` FRM
    mapping. We also have a companion object for the review model.
  prefs: []
  type: TYPE_NORMAL
- en: '`Review.scala` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: ImageDao
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we need to move to our last `dao`, `ImageDao`. Like `ProductDao` and `ReviewDao`,
    we will go through the same ideas and concepts as implementation too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now look at `ImageDao.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We also need to have a companion object helper for the image.
  prefs: []
  type: TYPE_NORMAL
- en: '`Image.scala` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Slick evolutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slick won't create the table for us, unless we create an evolution. Slick keeps
    track of the database state and creates and applies SQL commands for us. Evolutions
    need be located at `ReactiveWebStore/conf/evolutions/default`, where `default`
    is the name of the database we configured in `application.conf`. Evolutions need
    to be named in a sequential way so that we can preserve order and Slick can keep
    track of the changes. Right now, we will create an evolution for `ProductDao`,
    because we need a product table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will be as follows with the name `1.sql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We need evolutions for th review and image as well. So we need to create `2.sql`
    for the image and `3.sql` for the review.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will be as follows for `2.sql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The code will be as follows with the name `3.sql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to change the default base trait for our `dao` packages to return Futures
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `BaseServices.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This last implementation reflects what's happening in the `dao` packages. Now
    we can move to the services implementation, and proceed with our refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we see `ProductService.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of changes here. First, we inject an `IProductDao`, and let
    Guice figure out the right injection that we need to be able to test with our
    old `in-memory` HashMap implementation, which will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The changes involve new function signatures, using `Awaits`, and using `Seq`
    instead of `List`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move to on `ReviewService.scala` now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have the same kind of changes that we made for the
    product. Let's move to `ImageService.scala`, which is our last service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have refactored all services to use the new `dao` packages implementation.
    Now the next step is the move to the controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have all the `dao` packages implemented with the respective database
    evolutions. However, our services expected a different contract, since we were
    using an in-memory database before. Let''s refactor the product controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two big changes in the preceding code despite the new function signatures.
    First, we use a utility function called `get` from a class called `Awaits`. This
    is needed so that we wait for the result to come back from the database. Second,
    when we flash the result, we no longer show the `id`, we just display a text message.
    Let''s take a look at the `Awaits` implementation in `Utils.Awaits.scala`, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Awaits` is just a simple utility class that waits for a period of time to
    get a Future result. We need to add some tweaks in `ReviewController` and `ImageController`
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first explore `ReviewController.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For `ReviewController`, we have made the same changes that we did for the product,
    that is, the use of `Awaits` and labels on flash returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the final controller: `ImageController.scala.`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Configuring DAO packages in Guice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to configure the injections for the three new `dao` packages that we
    created. So we to need to add three lines in the file `Module.scala`. Please open
    the file in your IDE, and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole file, `Module.scala`, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might expect, most tests are no longer working. We will need to perform
    some refactoring here as well. We will refactor our former `dao` to make it generic,
    and it will be used in integration tests (end-to-end tests).
  prefs: []
  type: TYPE_NORMAL
- en: Since we will create a generic dao system in memory for end-to-end testing purposes,
    we need to change our models a little bit. First, we need to create a base trait
    for all the models. This is needed so we can treat our models as equals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at `models.BaseModel.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to make all our models implement this new trait. So we will need
    to change the Scala code for the product, image, and review. This is very trivial:
    we just add a getter and a setter for the `id` field. You can also use `scala.bean.BeanProperty`
    instead of writing one by yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `models.Product.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we extend the `BaseModel` method, and
    implement `getId` and `setId`. We need to do the same for the review and image
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `models.Review.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now we move on to the last model. We need to implement it in `Image.scala`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `models.Image.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Generic mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have all that we need to create a generic mock implementation and mock
    all the `dao` packages. Under the location `ReactiveWebStore/test/`, we will create
    a package called mocks, and create a call, `GenericMockedDao`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `GenericMockedDao.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So the `GenericMockedDao` call expects the `Generic` parameter, which could
    be any class extending from `BaseModel`. Then we use an in-memory HashMap implementation
    and a counter to simulate database operations. We run all the operations inside
    Futures, so we don''t break the new signature the code is expecting. Now we can
    create three `MockedDaos` for each model we need: product, review, and image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `mocks.ProductMockedDao.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, we implement the `IProdutDao` trait, and we delegate all
    operations to `genericMockedDao`. Since everything is in-memory, we don't need
    to implement the `toTable` function. We need to do the same for the review and
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `mocks.ReviewMockedDao.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Exactly like product, we delegate all operations to `GenericMockedDao`. Now
    let's move to the last one, the image, and then we can fix the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `mocks.ImageMockedDao.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Okay, we have all the mocks that we need for now. We can move on to fix the
    test specs. We need to fix services tests and controller test. Services tests
    will use mocks. Controllers tests, however, will use the real database implementation.
    We need to use other utility classes for controller tests. Located in the test
    source folder, we need to create a package called `utils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `utils.DBCleaner.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`DBCleaner` will connect to the real database and perform delete statements
    to clean up all table data. After deleting all data in the tables, we also reset
    the sequence in the database; otherwise, our tests will not have the predictability
    we need to do assertions.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in `db.run`, we can use `DBIO.seq`, which allows us to execute
    multiple instructions on the database. Here we are not using Scala code. We are
    using pure SQL statements, since we need to use very specific MySQL functions
    to reset the sequences.
  prefs: []
  type: TYPE_NORMAL
- en: If you need, you could use all these functions in your application. This is
    useful if you need to use a specific database function, if you have a very complex
    query, or sometimes, because there is a performance issue.
  prefs: []
  type: TYPE_NORMAL
- en: Most fixes we do now center around using `Awaits` to wait for the Future result,
    and also using our new mocks. For the controller test, we need to call the `DBCleaner`
    function as well.
  prefs: []
  type: TYPE_NORMAL
- en: Service tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will create tests for services to test them. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ProductServiceTestSpec.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, most fixes center around the new signatures
    and the fact we are using Futures and need to use the `Awaits` utility and mocks.
    We test the service without the database call via this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can move on to the next service, which will be the review.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ReviewServiceTestSpec.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: That was the review spec service test code. We apply the same changes as we
    did for product. Now we need to move on to the last service test, which will be
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ImageServiceTestSpec.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have fixed all the services tests. Now we need to fix the controller tests.
  prefs: []
  type: TYPE_NORMAL
- en: Controller tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's fix the controller tests. The first one will be the product controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ProductControllerTestSpec.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The Controller product test needs to call the `DBCleaner` function at the beginning
    of the test to make sure that the database is in a well-known state; additionally,
    and after running all the tests, we need to clean up the database just to be safe.
  prefs: []
  type: TYPE_NORMAL
- en: We will now apply the same changes for the review and image controller tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ReviewControllerTestSpec` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Alright, we have the tests for the review controller fixed. Now we can move
    to the last controller test for the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ImageControllerTestSpec.scala` file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: All right, all the controller tests are fixed now. We can run all the tests
    to double check whether everything is OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You get output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controller tests](img/image00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you have problems running the application (covered in the next section),
    apply the evolution, and then you can run the tests again. Tests might take some
    time, depending on your hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to run the application using `$ activator run`. Open your web
    browser, and go to `http://localhost:9000/`. Once you do that, Play will detect
    that the application needs evolutions, and will apply the three evolutions we
    have (`1.sql`, `2.sql`, and `3.sql`). However, you will need to click on the button
    to apply the evolution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/image00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After you click on the red button, **Apply this script now!**, Slick will create
    the tables, and redirect you to the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/image00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we reach the end of the chapter. You learned how to perform database
    persistence using Slick. You also learned how to do FRM mapping, and we refactored
    our application and tests so they work with reactive persistence and the Play
    framework. We then explained how to access the database using Scala code, and
    perform operations using SQL.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will see more about reports, and we will use our
    database to generate reports based on our Play framework application.
  prefs: []
  type: TYPE_NORMAL
