<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Mastermind - Creating a Game</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we will start to develop a simple game. The game is the Mastermind game for two players. Player one selects four differently colored pins out of six possible colors and arranges them on a board in a row hidden from the other player. The other player tries to guess the colors of the pins and its positions. After each try, player one tells the number of matching colors and the pins matching both color and position. The program will act as both player one and player two. Our code will play alone. However, what remains for us to play with is the most important: the code.</p>
<p class="calibre2">This example is complex enough to deepen the OO principles and how we design classes and model the real world. We have already used classes provided in the Java runtime. This time, we will use collections and discuss this important area. These classes and interfaces are widely used and available in the JDK and as important for a professional Java developer as the language itself.</p>
<p class="calibre2">The build tool this time is Gradle.</p>
<p class="calibre2">In this chapter we will cover:</p>
<ul class="calibre14">
<li class="calibre15">Java collections</li>
<li class="calibre15">Dependency injection</li>
<li class="calibre15">How to comment our code and to create JavaDoc documentation</li>
<li class="calibre15">How to create integration tests</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The Game</h1>
            

            <article>
                
<p class="calibre2">Mastermind (<a href="https://en.wikipedia.org/wiki/Mastermind_(board_game)" class="calibre6"><span>https://en.wikipedia.org/wiki/Mastermind_(board_game)</span></a>) is an old game. The plastic version that was ubiquitous in every house with children was invented in 1970. I got a board around 1980 as a Christmas gift and solving the game puzzle in BASIC language was one of the first programs that I created around 1984.</p>
<p class="calibre2">The game board contains holes in several rows in four columns. There are plastic pins of six different colors that can be inserted into the holes. Each pin has one color. They are usually red, green, blue, yellow, black, and white. There is a special row that is hidden from one of the players (the guesser).</p>
<p class="calibre2">To play the game, one of the players (hider) has to select four pins from a set of pins. The selected pins should have different colors. The pins are placed in the hidden row one by one, each into a position.</p>
<p class="calibre2">The guesser tries to find out what colors are in which position guessing. Each guess takes place selecting four pins and placing them in a row. The hider tells the guesser how many pins are in correct position and how many have a color that is on the table, but are not in the position where that color is hidden.</p>
<div class="packtfigure"><img class="image-border27" src="../images/00039.jpeg"/></div>
<p class="calibre2">A sample play may go like this:</p>
<ul class="calibre14">
<li class="calibre15">The hider hides four pins with color blue, yellow, white, and black.</li>
<li class="calibre15">Guesser guesses yellow, blue, green, and red.</li>
<li class="calibre15">The hider tells the guesser that there are two colors matching, but none of them is in the position in the hidden row. The hider says this because yellow and blue are in the hidden row but not in the positions as the guesser guessed. They are actually swapped, but this information the hider keeps a secret. All she says is that there are two colors matching, none in the correct position.</li>
<li class="calibre15">The next guess is ...</li>
</ul>
<p class="calibre2">The game finishes when the guesser finds the correct colors in the correct order. The same game, as on the figure, can also be described with textual notation, <kbd class="calibre11">B</kbd> for blue, <kbd class="calibre11">Y</kbd> for yellow, <kbd class="calibre11">G</kbd> for green, <kbd class="calibre11">W</kbd> for white, <kbd class="calibre11">R</kbd> for red, and <kbd class="calibre11">b</kbd> for black (lucky we have upper and lower case letters on the computer).</p>
<pre class="calibre20">
RGBY 0/0<br class="title-page-name"/>GRWb 0/2<br class="title-page-name"/>YBbW 0/2<br class="title-page-name"/>BYGR 0/4<br class="title-page-name"/>RGYB 2/2<br class="title-page-name"/>RGBY 4/0
</pre>
<p class="calibre2">Guess what! This is the actual output of the program that we develop in this chapter.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The model of the game</h1>
            

            <article>
                
<p class="calibre2">When we develop a piece of code with an object-oriented mindset, we try to model the real world and map real-world objects to objects in the program. You certainly have heard of object orientation explained with the very typical examples of geometric objects, or the car and the motor thing to explain composition. Personally, I believe that these examples are too simple to get a good understanding. They may be good for starters, but we are already in the fourth chapter of the book. The Mastermind game is much better. It is a bit more complex than just rectangles and triangles, but not as complex as a telecom billing application or an atomic power plant control.</p>
<p class="calibre2">What are the real-world objects that we have in that game? We have a table and we have pins of different colors. There are two Java classes that we certainly will need. What is in a table? There are rows each having four positions. Perhaps we will need a class for a row. A table will have rows. We will also need something that hides the secret. This also may be a row and each row may also hold the information about how many positions and how many colors are matching. In case of the secret row, this information is obvious: 4 and 0.</p>
<p class="calibre2">What is a pin? Each pin has a color and generally, that is it. There are no other features of a pin, except that it can be inserted into a hole on the table, but this is a real life feature we will not model. Essentially, a pin is a color and nothing else. This way, we can eliminate the pin class from our model early on, even before we created it in Java. Instead, we have colors.</p>
<p class="calibre2">What is a color? This is something that may be hard to immerse into the first time. We all know well what a color is. It is a mixture of different frequency of lights, as our eyes perceive it. We can have paints and prints in different colors, and so on. There are very many things that we do not model in this program. It is really hard to tell what we model about color in our code because these features are so obvious that we take it for granted in real life; we can tell about two colors that they are different. This is the only feature we need. To do this, the simplest class of Java can be used:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>public class Color {}
</pre>
<p class="calibre2">If you have two variables of the type <kbd class="calibre11">Color</kbd>, you can tell if they are the same or not. You can use object identity comparing <kbd class="calibre11">a</kbd> and <kbd class="calibre11">b</kbd> using the expression <kbd class="calibre11">a == b</kbd> or you can use the <kbd class="calibre11">equals</kbd> method inherited from the <kbd class="calibre11">Object</kbd> class, <kbd class="calibre11">a.equals(b)</kbd>. It is tempting to encode the colors with letters, or use <kbd class="calibre11">String</kbd> constants to denote them. It may be easier first, but there are serious drawbacks later. When the code becomes complex, it leads to bugs; it will be easy to pass something also encoded as String instead of a color and only unit tests may save the day. Better, the compiler already complains in the IDE when you type the wrong argument.</p>
<p class="calibre2">When we play the game, the pins are in small boxes. We pull pins out of the boxes. How do we get the colors in the program? We need something from where we can fetch colors or looking at the other way something that can give us colors. We will call it <kbd class="calibre11">ColorManager</kbd>. <kbd class="calibre11">ColorManager</kbd> knows how many different colors we have and any time we need a color, we can ask for it.</p>
<p class="CDPAlignLeft1">Again, there is a temptation to design the <kbd class="calibre11">ColorManager</kbd> that it can serve a color by its serial number. If we have four colors, we could ask for color number 0, 1, 2, or 3. But then again, it would just implicitly encode the colors as integer numbers, which we agreed we will not. We should find the minimum feature that we will need to model the game.</p>
<p class="calibre2">To describe the structure of the classes, professional developers usually use UML class diagrams. UML is a diagram notation that is standardized and is almost exclusively used to visualize software architecture. There are many diagram types in UML to describe the static structure and the dynamic behavior of a program. This time, we will look at a very simplified class diagram.</p>
<div class="packtfigure"><img class="image-border28" src="../images/00040.gif"/></div>
<p class="calibre2">We have no room to get into the details of UML class diagrams. Rectangles denote the classes, normal arrows denote the relations when a class has field of the other class type, and triangle headed arrow means that a class extends another. The arrow points to the direction of the class being extended.</p>
<p class="calibre2">A <strong class="calibre1">Game</strong> contains a secret <strong class="calibre1">Row</strong> and a <strong class="calibre1">Table</strong>. The <strong class="calibre1">Table</strong> has a <strong class="calibre1">ColorManager</strong> and a <strong class="calibre1">List&lt;&gt;</strong> of <strong class="calibre1">Row</strong>. The <strong class="calibre1">ColorManager</strong> has a first color and has a <strong class="calibre1">Map&lt;&gt;</strong> of <strong class="calibre1">Color</strong>. We have not discussed why that is the design, we will get there and the diagram helps us walking that road. A <strong class="calibre1">Row</strong> is essentially an array of <strong class="calibre1">Color</strong>.</p>
<p class="calibre2">The one who plays the game has one function: it has to guess many times until it finds the hidden secret. To get to the model of the <strong class="calibre1">ColorManager</strong>, we will have to design the algorithm of the <strong class="calibre1">Guesser</strong>.</p>
<p class="calibre2">When the player makes the first guess, any combination of colors is just as good as any other. Later, the guesses should consider the responses that were given for previous guesses. It is a reasonable approach to try only color variations that can be the actual secret. The player selects a variation and looks at all previous guesses assuming that the selected variation is the secret. If the responses to the rows he has already made are the same for this variation as for the unknown secret in the game, then it is reasonable to try this variation. If there is any difference in the responses, then this variation is certainly not the variation that was hidden.</p>
<p class="calibre2">To follow this approach, the guesser has to generate all possible color variations one after the other and compare it against the table. The guesser code will not create and store all the possible variations ahead, but it has to know where it was and has to be able to calculate the next variation that comes. This assumes an order of the variations. For a short while, let's forget that no color may appear twice in a variation. A simple ordering can be made the same way as we sort decimal numbers. If we have a three-digit number, then the first one is 000, the next one is 001, and so on until 009, always fetching the next digit for the last position. After that, 010 comes. We increased a digit next to the last one and we set the last one to 0 again. Now, we have 011, 012, and so on. You know, how we count numbers. Now, replace the digits with colors and we have only six and not ten. Or, we have as many as we want when we instantiate a <kbd class="calibre11">ColorManager</kbd> object.</p>
<p class="calibre2">This leads to the functionality of the <kbd class="calibre11">ColorManager</kbd>. It has to do the following two things:</p>
<ul class="calibre14">
<li class="calibre15">Give the first color to the caller</li>
<li class="calibre15">Give the next color that follows a given color (we will name the method <kbd class="calibre11">nextColor</kbd>)</li>
</ul>
<p class="calibre2">The latter functionality should also signal some way when there is no next color. This will be implemented using another method, named <kbd class="calibre11">thereIsNextColor</kbd>.</p>
<div class="packttip">It is a convention to start the method names that return a Boolean value with <kbd class="calibre22">is</kbd>. That would lead to the name following this convention <kbd class="calibre22">isThereNextColor</kbd>, or <kbd class="calibre22">isNextColor</kbd>. Either of these names explains the functionality of the method. If I ask the question <kbd class="calibre22">isThereNextColor</kbd>, the method will answer me <kbd class="calibre22">true</kbd> or <kbd class="calibre22">false</kbd>. But, this is not how we will use the method. We will talk in simple sentences. We will use short sentences. We will avoid unnecessary, gibberish expressions. We will also program that way. Most probably, the caller will use this method in an <kbd class="calibre22">if</kbd> statement. They will write the following:<br class="calibre23"/>
<kbd class="calibre22">If( thereIsNextColor(currentColor)){...}</kbd><br class="calibre23"/>
and not<br class="calibre23"/>
<kbd class="calibre22">if( isThereNextColor(currentColor)){...}</kbd><br class="calibre23"/>
I think the first version is more readable and readability comes first. Last, but not least, nobody will blame you if you follow the old convention, and in case that is the company standard, you have to anyway.</div>
<p class="calibre2">To do these, the <kbd class="calibre11">ColorManager</kbd> also has to create the color objects and should store them in a structure that helps the operations being performed.</p>
<div class="title-page-name">
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> import java.util.HashMap; <br class="title-page-name"/> import java.util.Map; <br class="title-page-name"/>  <br class="title-page-name"/> public class ColorManager { <br class="title-page-name"/>     final protected int nrColors; <br class="title-page-name"/>     final protected Map&lt;Color, Color&gt; successor = new HashMap&lt;&gt;(); <br class="title-page-name"/>     final private Color first; <br class="title-page-name"/>  <br class="title-page-name"/>     public ColorManager(int nrColors) { <br class="title-page-name"/>         this.nrColors = nrColors; <br class="title-page-name"/>         first = new Color(); <br class="title-page-name"/>         Color previousColor = first; <br class="title-page-name"/>  <br class="title-page-name"/>         for (int i = 1; i &lt; nrColors; i++) { <br class="title-page-name"/>             final Color thisColor = new Color(); <br class="title-page-name"/>             successor.put(previousColor, thisColor); <br class="title-page-name"/>             previousColor = thisColor; <br class="title-page-name"/>         } <br class="title-page-name"/>         successor.put(previousColor, Color.none); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public Color firstColor() { <br class="title-page-name"/>         return first; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     boolean thereIsNextColor(Color color) { <br class="title-page-name"/>         return successor.get(color) != Color.none; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public Color nextColor(Color color) { <br class="title-page-name"/>         return successor.get(color); <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre></div>
<p class="calibre2">The structure we use is a <kbd class="calibre11">Map</kbd>. <kbd class="calibre11">Map</kbd> is an interface defined in the Java runtime and is available since the very early releases of Java. A <kbd class="calibre11">Map</kbd> has keys and value, and for any key, you can easily retrieve the value assigned to the key.</p>
<div class="packttip">You can see on the line, where the variable <kbd class="calibre22">successor</kbd> is defined that we define the type of the variable as an interface, but the value is an instance of a class. Obviously, the value cannot be an instance of an interface because such beasts do not exist. But, why do we define the variable to be an interface? The reason is abstraction and coding practice. If we need to change the implementation we use for some reason, the variable type still may remain the same and there is no need to change the code elsewhere. It is also a good practice to declare the variable to be an interface so that we will not have the temptation to use some special API of the implementation that is not available in the interface just by convenience. When it is really needed, we can change the type of the variable and use the special API. After all, there is a reason that API is there, but the mere temptation to use some special thing just because it is there is hindered. This helps to write simpler and cleaner program.</div>
<p class="calibre2"><kbd class="calibre11">Map</kbd> is only one of the <span>interfaces </span><span>defined in the Java runtime belonging to the Java collections. There are many other interfaces and classes. Although, the JDK and all the classes are a vast amount and almost nobody knows all the classes that are there, collections is a special area that a professional developer should be knowledgeable about. Before getting into details on why</span> <kbd class="calibre11">HashMap</kbd> <span>is used in this code, we will have an overview of the collection classes and interfaces. This will help us also understand the other collections used in this program.</span></p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Java collections</h1>
            

            <article>
                
<p class="calibre2">Collections are interfaces and classes that help us store more than one object. We have already seen arrays that can do that, and also <kbd class="calibre11">ArrayList</kbd> in the previous chapters, but we did not discuss in detail what other possibilities there are in the JDK. Here, we will go into more detail, but leave the streams and the functional methods for later chapters, and we will also refrain to go into details that is rather the task of a reference book.</p>
<p class="calibre2">Using implementation of the collection classes and interfaces reduces the programming effort. First of all, you do not need to program something that is already there. Secondly, these classes are highly optimized, both in implementation and in their features. They have very well designed API as well as the code is fast and uses small memory footprint. Sorry to say that their code was written long time ago and many times it is not a good style, hard to read, and understand.</p>
<p class="calibre2">When you use a collection from the JDK, it is more likely that you can interoperate with some library. If you cook your own version of linked lists, it is not likely that you will find a readymade solution that will sort your list. If you use the <kbd class="calibre11">LinkedList</kbd> class in the JDK's standard class library, you will get a readymade solution from the <kbd class="calibre11">Collections</kbd> class, right from the JDK. It is also worth mentioning that the Java language itself supports these classes, for example, you can easily iterate through the elements of a <kbd class="calibre11">Collection</kbd> with a shortened special syntax.</p>
<p class="calibre2">The collections in JDK contain interfaces that define the behavior of the different collection types, implementation classes, and algorithms that perform certain actions such as sorting. Many times, these algorithms work on different implementation versions, getting the same result, but optimized for the implementation specific class.</p>
<p class="calibre2">You can use the API given by the interface, and if you change the implementation in your code, you will get an optimized version fitting the implementation.</p>
<div class="packtfigure"><img class="image-border29" src="../images/00041.gif"/></div>
<p class="calibre2">The collection interfaces can be categorized in two bags. One bag contains the interfaces that extend the <kbd class="calibre11">Collection</kbd> interface, and the other one contains <kbd class="calibre11">Map</kbd>, and a <kbd class="calibre11">SortedMap</kbd> extending <kbd class="calibre11">Map</kbd>. This way, <kbd class="calibre11">Map</kbd> is not really a collection, as it does not simply contain other objects but also pair values to keys.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Interface collection</h1>
            

            <article>
                
<p class="calibre2">Collection is the top of the interface hierarchy. This interface defines the methods that all implementations should provide, no matter if they implement the <kbd class="calibre11">Set</kbd>, <kbd class="calibre11">SortedSet</kbd>, <kbd class="calibre11">List</kbd>, <kbd class="calibre11">Queue</kbd>, or <kbd class="calibre11">Deque</kbd> interface directly. As <kbd class="calibre11">Collection</kbd> simply says that an object that implements the <kbd class="calibre11">Collection</kbd> interface is only an object that collects other objects together, the methods it defines are like adding a new object to the collection, clearing all elements from there, checking that an object is already a member of the collection, and iterating through the elements.</p>
<div class="packtinfobox">For an up-to-date definition of the interface, consult the Java pi documentation (<a href="http://download.java.net/java/jdk9/docs/api/overview-summary.html" class="calibre25"><span class="URLPACKT">http://download.java.net/java/jdk9/docs/api/overview-summary.html</span></a>). You can consult the online API any time, and it is recommended to do so.</div>
<p class="calibre2">The Java language itself directly supports the interface. You can iterate through the elements of the <kbd class="calibre11">Collection</kbd> with the enhanced <kbd class="calibre11">for</kbd> loop syntax, the same way as you can iterate over the elements of an array where the collection should be an expression that results an object that implements the <kbd class="calibre11">Collection</kbd> interface:</p>
<pre class="calibre20">
for( E element : collection ){...}
</pre>
<p class="calibre2">In the preceding code, <kbd class="calibre11">E</kbd> is either Object or the generic type of the elements of the <kbd class="calibre11">Collection</kbd>.</p>
<p class="calibre2">The interface <kbd class="calibre11">Collection</kbd> is not directly implemented in the JDK. Classes implement one of the sub interfaces of <kbd class="calibre11">Collection</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Set</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">Set</kbd> is a special collection that cannot contain duplicate elements. When you want to add an object into a set that already has an object that is the same or equal to the actual one, then the <kbd class="calibre11">add</kbd> method will not add the actual object. The <kbd class="calibre11">add</kbd> method will return <kbd class="calibre11">false</kbd> indicating the failure.</p>
<p class="calibre2">You can use <kbd class="calibre11">Set</kbd> in your program when you need a collection of unique elements where you simply want to check that an element is a member of a set or not, whether an object belongs to a certain group or not.</p>
<p class="calibre2">As we will return to our program code, we will see that the <kbd class="calibre11">UniqueGuesser</kbd> class has to implement an algorithm that checks that a color in a guess is present only once. This algorithm is the ideal candidate for a <kbd class="calibre11">Set</kbd> to be used:</p>
<pre class="calibre20">
private boolean isNotUniqueWithSet(Color[] guess) { <br class="title-page-name"/>     final Set&lt;Color&gt; alreadyPresent = new HashSet&lt;&gt;(); <br class="title-page-name"/>     for (Color color : guess) { <br class="title-page-name"/>         if (alreadyPresent.contains(color)) { <br class="title-page-name"/>             return true; <br class="title-page-name"/>         } <br class="title-page-name"/>         alreadyPresent.add(color); <br class="title-page-name"/>     } <br class="title-page-name"/>     return false; <br class="title-page-name"/> }
</pre>
<p class="calibre2">The code creates a set, which is empty when the method starts. After that, it checks for each color (notice the enhanced <kbd class="calibre11">for</kbd> loop over the array elements) if it was already present before. To do that, the code checks if the color is already in the set. If it is there, the guess is not unique as we have found a color that is present at least twice. If the color was not in the set, then the guess can still be unique in colors. To be able to detect that later, the code puts the color into the set.</p>
<p class="calibre2">The actual implementation of <kbd class="calibre11">Set</kbd> that we will use is <kbd class="calibre11">HashSet</kbd>. In the JDK, there are many classes implementing the <kbd class="calibre11">Set</kbd> interface. The most widely used is <kbd class="calibre11">HashSet</kbd>, and it is also worth mentioning <kbd class="calibre11">EnumSet</kbd>, <kbd class="calibre11">LinkedHashSet</kbd>, and <kbd class="calibre11">TreeSet</kbd>. The last one also implements the <kbd class="calibre11">SortedSet</kbd> interface, so we will detail it there.</p>
<p class="calibre2">To understand what <kbd class="calibre11">HashSet</kbd> (and later <kbd class="calibre11">HashMap</kbd>) are and how they work, we will have to discuss what hashes are. They play very important and central role in many applications. They do their job under the hood in the JDK but there are some very important constraints that programmers have to follow or else really weird and extremely hard to find bugs will make their life miserable. <a class="calibre6">I dare to say that violation of the hash contract in</a> <kbd class="calibre11">HashSet</kbd> and <kbd class="calibre11">HashMap</kbd> are the cause of the second most difficult to find bugs next to multithread issues.</p>
<p class="calibre2">Thus, before going on with the different collection implementations, we will visit this topic. We are already one level deep from our example in this detour discussing collections and now we will go one level deeper. I promise this is the last in-depth level of detours.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Hash functions</h1>
            

            <article>
                
<p class="calibre2">A hash is a mathematical function that assigns a number to an element. Say you work at a university administration and you have to tell if Wilkinson is a student at your class. You can store the names on small papers in envelopes one for each starting letter. Instead of searching through the 10 thousand students, you can look at the papers in the envelope titled W. This very simple hash function assigns the first letter of the name to the name (or the ordinal number of the letter, as we said that a hash function results a number). This is not really a good hash function because it puts only a few elements, if any, into the envelope denoted X and many to A for example.</p>
<p class="calibre2">A good hash function results each possible ordinal number with similar probability. In hash tables, we usually have more buckets (envelopes in the previous example) than the number of elements to be stored. Therefore, when an element is searched for, it is likely that there is only one element there. At least that is what we would like to have. If there are multiple elements in a single bucket, it is called collision. A good hash function has as little collisions as possible.</p>
<div class="packtinfobox">For backward compatibility, there is a <kbd class="calibre22">Hashtable</kbd> class in the JDK. This was one of the first hash table implementations in Java right in the very first version, and as Java is backward compatible, it was not thrown away. The <kbd class="calibre22">Map</kbd> interface was introduced in version 1.2 only. <kbd class="calibre22">Hashtable</kbd> has many drawbacks and its use is not recommended. (Even the name is violating the Java naming conventions.) We do not discuss this class in this book. Whenever we talk about hash tables, it is referring to the actual array that is inside the implementation of <kbd class="calibre22">HashSet</kbd>, <kbd class="calibre22">HashMap</kbd>, or any other collection that uses some hash indexed table.</div>
<p class="calibre2">Hash tables are arrays that use the result of the hash function to index the array. Usually, linked lists manage collisions. Hash table implementations also implement a strategy to resize the array when the number of elements to be stored becomes too high and the likelihood of collisions increase. This operation may take considerable time and, during this, the individual elements are moved between the buckets.</p>
<div class="packttip">During this operation, the hash table cannot reliably be used and this may be some source of issues in a multithread environment. In single thread code, you do not meet this problem. When you call the <kbd class="calibre22">add</kbd> method, the hash table (set or map) decides that the table has to be resized. The <kbd class="calibre22">add</kbd> method calls the resizing method and does not return until it is finished. Single thread code has no possibility to use the hash table during this period: the one and single thread is executing the resizing itself. In a multithread environment, however...</div>
<p class="calibre2"><kbd class="calibre11">HashSet</kbd> and <kbd class="calibre11">HashMap</kbd> use the hash function provided by the <kbd class="calibre11">Object</kbd> that is stored in the collection. The <kbd class="calibre11">Object</kbd> class implements the <kbd class="calibre11">hashCode</kbd> and <kbd class="calibre11">equals</kbd> methods. You can override them and if you do, you should override both in a consistent manner. First, we will see what they are and then how to override them consistently.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Method equals</h1>
            

            <article>
                
<p class="calibre2">The documentation of set says "sets contain no pair of elements <kbd class="calibre11">e1</kbd> and <kbd class="calibre11">e2</kbd> such that <kbd class="calibre11">e1.equals</kbd>(<kbd class="calibre11">e2</kbd>)". The <kbd class="calibre11">equals</kbd> method returns <kbd class="calibre11">true</kbd> if the <kbd class="calibre11">e1</kbd> and <kbd class="calibre11">e2</kbd> are in some way equal. It may be different from two objects being identical. There can be two distinct objects that are equal. For example, we could have a color implementation that has the name of the colors as an attribute and two color objects may return true calling the <kbd class="calibre11">equals</kbd> method on one of them and passing the argument as the other when the two strings are equal. The default implementation of the <kbd class="calibre11">equals</kbd> method is in the code of the <kbd class="calibre11">Object</kbd> class and this returns <kbd class="calibre11">true</kbd> if and only if <kbd class="calibre11">e1</kbd> and <kbd class="calibre11">e2</kbd> are exactly the same and single object.</p>
<p class="calibre2">It seems to be obvious, but my experience shows that it cannot be stressed enough that the implementation of equals in an object has to be as follows:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Reflexive</strong>: This means that an object that always equals itself</li>
<li class="calibre15"><strong class="calibre1">Symmetric</strong> (commutative): This means if <kbd class="calibre11">e1.equals(e2)</kbd> is <kbd class="calibre11">true</kbd>, then <kbd class="calibre11">e2.equals(e1)</kbd> should also be <kbd class="calibre11">true</kbd></li>
<li class="calibre15"><strong class="calibre1">Transitive</strong>: This means if <kbd class="calibre11">e1.equals(e2)</kbd> and <kbd class="calibre11">e2.equals(e3)</kbd>, then <kbd class="calibre11">e1.equals(e3)</kbd></li>
<li class="calibre15"><strong class="calibre1">Consistent</strong>: This means that the return value should not change if the objects were not changed between the invocations</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Method hashCode</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">hashCode</kbd> method returns an <kbd class="calibre11">int</kbd>. The documentation says that any class redefining this method should provide the following implementation:</p>
<ul class="calibre14">
<li class="calibre15">Consistently return the same value if the object was not modified</li>
<li class="calibre15">Result the same <kbd class="calibre11">int</kbd> value for two objects that are equal (the <kbd class="calibre11">equals</kbd> method returns <kbd class="calibre11">true</kbd>)</li>
</ul>
<p class="calibre2">The documentation also mentions that this is not a requirement to result different <kbd class="calibre11">int</kbd> values for objects that are not equal, but it is desirable to support the performance of the hash implementing collections.</p>
<p class="calibre2">If you violate any of these rules in the implementation of <kbd class="calibre11">equals</kbd> and <kbd class="calibre11">hashCode</kbd>, then the JDK classes using them will fail. As you can be sure that <kbd class="calibre11">HashSet</kbd>, <kbd class="calibre11">HashMap</kbd>, and similar classes were fully debugged, seeing that you added an object to a set and then the set reporting that it is not there will be a bewildering experience. However, only until you find out that the two objects being equal and stored in the set have different <kbd class="calibre11">hashCode</kbd> values, <kbd class="calibre11">HashSet</kbd> and <kbd class="calibre11">HashMap</kbd> will look for the object only in the bucket that is indexed by the <kbd class="calibre11">hashCode</kbd> value.</p>
<p class="calibre2">It is also a common mistake to store an object in a <kbd class="calibre11">HashSet</kbd> or <kbd class="calibre11">HashMap</kbd> and then modify it. The object is in the collection but you cannot find it because the <kbd class="calibre11">hashCode</kbd> returns a different value. Objects stored in a collection should not be modified unless you know what you are doing.</p>
<p class="calibre2">Many times, objects contain fields that are not interesting from the equality point of view. The <kbd class="calibre11">hashCode</kbd> and <kbd class="calibre11">equals</kbd> methods should be idempotent to those fields and you can alter those fields even after storing the object in a <kbd class="calibre11">HashSet</kbd> or in <kbd class="calibre11">HashMap</kbd>.</p>
<p class="calibre2">As an example, you may administer triangles in objects maintaining the coordinates of the vertices and the color of the triangle. However, you do not care about the color for equality, only that the two triangles are at the exact same location in the space. In that case, the <kbd class="calibre11">equals</kbd> and <kbd class="calibre11">hashCode</kbd> method should not take the field color into account. This way, we can paint our triangles; they will still be found in <kbd class="calibre11">HashSet</kbd> or <kbd class="calibre11">HashMap</kbd> no matter what the color field is.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing equals and hashCode</h1>
            

            <article>
                
<p class="calibre2">Implementing these methods is fairly simple. As this is a very common task, the IDEs support the generation of these methods. These methods are tied together so much that the menu items in the IDEs are not separate; they offer you to generate these methods at once.</p>
<p class="calibre2">Asking the IDE to generate the <kbd class="calibre11">equals</kbd> method will result in something like the following code:</p>
<pre class="calibre20">
@Override <br class="title-page-name"/> public boolean equals(Object o) { <br class="title-page-name"/>     if (this == o) return true; <br class="title-page-name"/>     if (o == null || getClass() != o.getClass()) return false; <br class="title-page-name"/>     MyObjectJava7 that = (MyObjectJava7) o; <br class="title-page-name"/>     return Objects.equals(field1, that.field1) &amp;&amp; <br class="title-page-name"/>             Objects.equals(field2, that.field2) &amp;&amp; <br class="title-page-name"/>             Objects.equals(field3, that.field3); <br class="title-page-name"/> }
</pre>
<p class="calibre2">For this sample, we have three <kbd class="calibre11">Object</kbd> fields named <kbd class="calibre11">field1</kbd>, <kbd class="calibre11">field2</kbd>, and <kbd class="calibre11">field3</kbd>. The code with any other types and fields will look very similar.</p>
<p class="calibre2">First, the method checks for object identity. One <kbd class="calibre11">Object</kbd> always <kbd class="calibre11">equals</kbd> itself. If the reference passed as argument is <kbd class="calibre11">null</kbd> and not an object, or they are of different class, then this generated method will return false. In other cases, the static method of the class <kbd class="calibre11">Objects</kbd> (note the plural) will be used to compare each of the fields.</p>
<p class="calibre2">The utility class <kbd class="calibre11">Objects</kbd> was introduced in Java 7, hence the name of the sample class. The static methods, <kbd class="calibre11">equals</kbd> and <kbd class="calibre11">hash</kbd>, support the override of the <kbd class="calibre11">Object equals</kbd> and <kbd class="calibre11">hashCode</kbd> methods. The <kbd class="calibre11">hashCode</kbd> creation before Java 7 was fairly complex and required the implementation of modulo arithmetic with some magic numbers that is hard to explain just looking at the code without knowing the mathematics behind it.</p>
<p class="calibre2">This complexity is now hidden behind the following <kbd class="calibre11">Objects.hash</kbd> method.</p>
<pre class="calibre20">
@Override <br class="title-page-name"/> public int hashCode() { <br class="title-page-name"/>     return Objects.hash(field1, field2, field3); <br class="title-page-name"/> }
</pre>
<p class="calibre2">The generated method simply calls the <kbd class="calibre11">Objects.hash</kbd> method passing the important fields as arguments.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">HashSet</h1>
            

            <article>
                
<p class="calibre2">Now, we know essentially a lot of things about hashes so we can bravely discuss the <kbd class="calibre11">HashSet</kbd> class. <kbd class="calibre11">HashSet</kbd> is an implementation of the <kbd class="calibre11">Set</kbd> interface that internally uses hash table. Generally, that is it. You store objects there and you can see if an object is already there or not. When there is a need for a <kbd class="calibre11">Set</kbd> implementation, almost always <kbd class="calibre11">HashSet</kbd> is the choice. Almost...</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">EnumSet</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">EnumSet</kbd> can contain elements from a certain enumeration. Recall that enumerations are classes that have fixed a number of instances declared inside the <kbd class="calibre11">enum</kbd> itself. As this limits the number of the different object instances, and this number is known during compilation time, the implementation of the <kbd class="calibre11">EnumSet</kbd> code is fairly optimized. Internally, <kbd class="calibre11">EnumSet</kbd> is implemented as a bit field and is a good choice where bit field manipulations can be used.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">LinkedHashSet</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">LinkedHashSet</kbd> is a <kbd class="calibre11">HashSet</kbd> that also maintains a doubly linked list of the elements it holds. When we iterate though a <kbd class="calibre11">HashSet</kbd>, there is no guaranteed order of the element. When the <kbd class="calibre11">HashSet</kbd> is modified, the new elements are inserted into one of the buckets and, possibly, the hash table gets resized. This means that the elements get rearranged and get into totally different buckets. Iteration over the elements in <kbd class="calibre11">HashSet</kbd> just takes the buckets and the elements in it in some order that is arbitrary from the caller point of view.</p>
<p class="calibre2"><kbd class="calibre11">LinkedHashSet</kbd>, however, iterates over the elements using the linked list it maintains and the iteration is guaranteed to happen in the order the elements were inserted.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">SortedSet</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">SortedSet</kbd> is an interface that guarantees that the classes implementing it will iterate over the set in a sorted order. The order may be the natural ordering of the objects if the objects implement the <kbd class="calibre11">Comparable</kbd> interface or a <kbd class="calibre11">Comparator</kbd> object may drive it. This object should be available when the instance of the class implementing the <kbd class="calibre11">SortedSet</kbd> is created; in other words, it has to be a constructor parameter.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">NavigableSet</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">NavigableSet</kbd> extends the <kbd class="calibre11">SortedSet</kbd> interface with methods that let you do proximity search in the set. This essentially lets you search for an element that is in the search and is less than the searched object, less or equal to the searched element, greater or equal, or greater than the searched <a class="calibre6">object</a>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">TreeSet</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">TreeSet</kbd> is an implementation of <kbd class="calibre11">NavigableSet</kbd> and, this way this is also a <kbd class="calibre11">SortedSet</kbd> and, as a matter of fact, is also a <kbd class="calibre11">Set.</kbd> As a <kbd class="calibre11">SortableSet</kbd> documentation implies there are two types of the constructors, each having multiple versions though. One requires some <kbd class="calibre11">Comparator</kbd>, the other one relies on the natural ordering of the elements.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">List</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">List</kbd> is an interface that requires implementing class to keep track of the order of the elements. There are also methods that access an element by index and iteration defined by the <kbd class="calibre11">Collection</kbd> interface that guarantees the order of the elements. The interface also defines the <kbd class="calibre11">listIterator</kbd> method that returns an <kbd class="calibre11">Iterator</kbd> also implementing the <kbd class="calibre11">ListIterator</kbd> interface. This interface provides methods that let the caller insert elements to the list while iterating through it and also going back and forth in the iteration. It is also possible to search for a certain element in the <kbd class="calibre11">List</kbd> but most implementations of the interface provide poor performance while the searching is simply going through all elements until the element searched for is found. There are many classes implementing this interface in the JDK. Here, we will mention two.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">LinkedList</h1>
            

            <article>
                
<p class="calibre2">This is a doubly-linked list implementation of the List interface that has a reference to the previous, and also to the next element in the list for each element. The class also implements the <kbd class="calibre11">Deque</kbd> interface. It is fairly cheap to insert or delete an element from the list because it needs only the adjustment of few references. On the other hand, the access to an element by index will need iteration from the start of the list, or from the end of the list, whichever is closer to the specified indexed element.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">ArrayList</h1>
            

            <article>
                
<p class="calibre2">This class is an implementation of the <kbd class="calibre11">List</kbd> interface that keeps the references to the elements in an array. That way, this is fairly fast to access an element by index. On the other hand, inserting an element to <kbd class="calibre11">ArrayList</kbd> can be costly. It needs moving all references above the inserted element one index higher, and it may also require resizing the backing array in case there is no room in the original one to store the new element. Essentially, this means allocating a new array and copying all references to it.</p>
<p class="calibre2">The reallocation of the array may be optimized if we know how large the array will grow and call the <kbd class="calibre11">ensureCapacity</kbd> method. This will resize the array to the size provided as argument, even if the currently used slots are less numbered.</p>
<div class="packttip">My experience is that novice programmers use <kbd class="calibre22">ArrayList</kbd> when they need a list without considering the algorithmic performance of the different implementations. I do not actually know why there is this popularity of <kbd class="calibre22">ArrayList</kbd>. The actual implementation used in a program should be based on proper decision and not habit.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Queue</h1>
            

            <article>
                
<p class="calibre2">Queue is a collection that usually stores element for later use. You can put elements into a queue and you can pull them out. An implementation may specify the given order, that may be <strong class="calibre1">first in first out</strong> (<strong class="calibre1">FIFO</strong>) or <strong class="calibre1">last in first out</strong> (<strong class="calibre1">LIFO</strong>) or some priority based ordering.</p>
<p class="calibre2">On a queue, you can invoke the <kbd class="calibre11">add</kbd> method to add an element, <kbd class="calibre11">remove</kbd> to remove the head element, and the <kbd class="calibre11">element</kbd> method to access the head element without removing it from the queue. The <kbd class="calibre11">add</kbd> method will throw an exception when there is a capacity problem and the element cannot be added to the queue. When the queue is empty, and there is no head element, the <kbd class="calibre11">element</kbd> and <kbd class="calibre11">remove</kbd> methods throw exception.</p>
<p class="calibre2">As exceptions can only be used in exceptional cases, and the calling program may handle these situations in the normal course of the code, thus all these methods have a version that just return some special value signaling the situation. Instead of <kbd class="calibre11">add</kbd>, a caller may call <kbd class="calibre11">offer</kbd> to offer an element for storage. If the queue cannot store the element, it will return <kbd class="calibre11">false</kbd>. Similarly, <kbd class="calibre11">peek</kbd> will try to get access to the head element or return <kbd class="calibre11">null</kbd> if there is none, and <kbd class="calibre11">poll</kbd> will remove and return the head element or just return <kbd class="calibre11">null</kbd> if there is none.</p>
<div class="packttip">Note that these methods returning <kbd class="calibre22">null</kbd> just make the situation ambiguous when the implementation, such as <kbd class="calibre22">LinkedList</kbd>, allows <kbd class="calibre22">null</kbd> elements. Never store a <kbd class="calibre22">null</kbd> element in a queue.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Deque</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">Deque</kbd> is an interface which is a double-ended queue. It extends the <kbd class="calibre11">Queue</kbd> interface with the methods that allow access to both ends of the queue to add, look at, and remove elements from both ends.</p>
<p class="calibre2">For the <kbd class="calibre11">Queue</kbd> interface we needed six methods. <kbd class="calibre11">Dequeue</kbd> having two manageable ends needs 12 methods. Instead of <kbd class="calibre11">add</kbd> we have <kbd class="calibre11">addFirst</kbd> and <kbd class="calibre11">addLast</kbd>. Similarly we can <kbd class="calibre11">offerFirst</kbd>, <kbd class="calibre11">offerLast</kbd> as well as <kbd class="calibre11">peekFirst</kbd>, <kbd class="calibre11">peekLast</kbd> and <kbd class="calibre11">pollFirst</kbd>, <kbd class="calibre11">pollLast</kbd>. For some reason the methods that implement the functionality of the <kbd class="calibre11">element</kbd> method on <kbd class="calibre11">Queue</kbd> are named <kbd class="calibre11">getFirst</kbd> and <kbd class="calibre11">getLast</kbd>.</p>
<p class="calibre2">Since this interface extends the <kbd class="calibre11">Queue</kbd> interface the methods defined there can also be used to access the head of the queue. In addition to these this interface also defines the methods <kbd class="calibre11">removeFirstOccurrence</kbd> and <kbd class="calibre11">removeLastOccurrence</kbd> that can be used to remove a specific element inside the queue. We cannot specify the index of the element to remove and we also cannot access an element based on index. The <kbd class="calibre11">removeFirst</kbd>/<kbd class="calibre11">LastOccurrence</kbd> methods' argument is the object that is to be removed. If we need this functionality we can use <kbd class="calibre11">Deque</kbd> even if we add and remove elements from the same end of the queue.</p>
<div class="packttip">Why are there these methods in <kbd class="calibre22">Deque</kbd> and not in <kbd class="calibre22">Queue</kbd>? These methods have nothing to do with double headedness of <kbd class="calibre22">Deque</kbd>. The reason is that methods cannot be added to interfaces after they were released. If we add a method to an interface we break the backward compatibility because all classes that implement that interface have to implement the new method. Java 8 introduced default methods that eased this constraint, but the <kbd class="calibre22">Queue</kbd> interface was defined in Java 1.5 and the <kbd class="calibre22">Deque</kbd> interface was defined in Java 1.6. There was no way at that time to add the new methods to the already existing interfaces.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Map</h1>
            

            <article>
                
<p class="calibre2">A <kbd class="calibre11">Map</kbd> pairs keys and values. If we want to approach a <kbd class="calibre11">Map</kbd> from the <kbd class="calibre11">Collection</kbd> point of view then a <kbd class="calibre11">Map</kbd> is a set of key/value pairs. You can put key value pairs into a <kbd class="calibre11">Map</kbd> and you can get a value based on a key. Keys are unique the same way as elements in a <kbd class="calibre11">Set</kbd>. If you look at the source code of the different implementations of the <kbd class="calibre11">Set</kbd> interface, you may see that some of them are implemented as a wrapper around a <kbd class="calibre11">Map</kbd> implementation where the values are simply discarded.</p>
<p class="calibre2">Using <kbd class="calibre11">Map</kbd>s is easy and alluring. Many languages, such as Python, Go, JavaScript, Perl, and so on, support this data structure on the language level. However, using a Map when an array would be sufficient is a bad practice that I have seen many times, especially in scripting languages. Java is not prone to that novice programmer error but you may still find yourself in a situation when you want to use a Map, and still there is a better solution. It is a general rule that the simplest data structure should be used that is sufficient for the implementation of the algorithm.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">HashMap</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">HashMap</kbd> is a hash table based implementation of the <kbd class="calibre11">Map</kbd> interface. As the map is based on a hash table, the basic <kbd class="calibre11">put</kbd> and <kbd class="calibre11">get</kbd> methods are performed in constant time. Additionally, as Map is very important, and because the most frequently used implementation in the JDK is <kbd class="calibre11">HashMap</kbd>, the implementation is fairly configurable. You can instantiate <kbd class="calibre11">HashMap</kbd> using the default constructor without argument, but there is also a constructor that defines the initial capacity and the load factor.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">IdentityHashMap</h1>
            

            <article>
                
<p class="calibre2"><kbd class="calibre11">IdentityHashMap</kbd> is a special <kbd class="calibre11">Map</kbd> that implements the <kbd class="calibre11">Map</kbd> interface literally, but as a matter of fact, it violates the contract the <kbd class="calibre11">Map</kbd> interface documentation defines. It does it with good reason. The implementation uses a hash table just as <kbd class="calibre11">HashMap</kbd>, but to decide the equality of the key found in the bucket comparing with the key element provided as argument to the get method it uses <kbd class="calibre11">Object</kbd> reference (<kbd class="calibre11">==</kbd> operator) and not the method <kbd class="calibre11">equals</kbd>, which is required by documentation of <kbd class="calibre11">Map</kbd> interface.</p>
<div class="packttip">The use of this implementation is reasonable when we want to distinguish different <kbd class="calibre22">Object</kbd> instances as keys that otherwise equal to each other. Using this implementation for performance reasons is almost certainly a wrong decision. Also, note that there is no <kbd class="calibre22">IdentityHashSet</kbd> implementation in the JDK. Probably such collection is so rarely used that its existence in the JDK would cause more harm than good alluring novice programmers to misuse.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Dependency injection</h1>
            

            <article>
                
<p class="calibre2">In the previous chapter we briefly already discussed <strong class="calibre1">dependency injection</strong> (<strong class="calibre1">DI</strong>). Now we will dig into it a bit more detail.</p>
<p class="calibre2">Objects usually do not work on their own. Most of the time the implementation depends on the services of other classes. When we want to write something to the console we use the <kbd class="calibre11">System</kbd> class. When we manage the table of guesses we need <kbd class="calibre11">Color</kbd> objects and <kbd class="calibre11">ColorManager</kbd>.</p>
<p class="calibre2">In case of writing to the console we may not realize the dependency because the class being part of the JDK class library is available all the time and all we need to do is to write <kbd class="calibre11">System.out.println</kbd>. In this case this dependency is wired into the code. We cannot send the output somewhere else unless we change the code. This is not too flexible and in many cases we need a solution that can work with different output, different color manager or different whatever service our code depends on. The first step to do that is to have a field that has a reference of the object that gives our class the service. In case of output the type of the field can be of type <kbd class="calibre11">OutputStream</kbd>. The next, more interesting step is how this field gets value.</p>
<p class="calibre2">One of the solution is to use DI. In this approach some external code prepares the dependencies and injects them into the object. When the first call to a method of the class is issued all the dependencies are already filled and ready to be used.</p>
<p class="calibre2">In this structure, we have four different players:</p>
<ul class="calibre14">
<li class="calibre15">The client object is the one that gets the injected service objects during the process</li>
<li class="calibre15">Service object or objects are injected into the client object</li>
<li class="calibre15">Injector is the code that performs the injection</li>
<li class="calibre15">Interfaces define the service that the client needs</li>
</ul>
<p class="calibre2">If we move the logic of the creation of the service objects from the client code the code becomes shorter and cleaner. The actual competency of the client class should hardly ever cover the creation of the service objects. For example a <kbd class="calibre11">Game</kbd> class contains a <kbd class="calibre11">Table</kbd> instance but a game is not responsible to create the <kbd class="calibre11">Table</kbd>. It is given to it to work with it, just as in real life that we model.</p>
<p class="calibre2">The creation of service objects is sometimes as simple as issuing the <kbd class="calibre11">new</kbd> operator. Sometimes service objects also depend on other service objects and that way also act as clients in the process of dependency injection. In this case the creation of the service objects may be a lot of lines. The structure of the dependencies can be expressed in a declarative fashion that describes which service object needs which other service objects and also what implementation of the service interfaces are to be used. Dependency injection injectors work with such declarative descriptions. When there is a need for an object that needs service objects that themselves need again other service objects the injector creates the service instances in the appropriate order using the implementations that are matching the declarative descriptions. The injector discovers all the dependencies transitively and creates a transitive closure graph of the dependencies.</p>
<p class="calibre2">The declarative description of the needed dependencies can be XML, or a special language developed especially for the dependency injection or it can even be Java itself using specially designed fluent API (<a href="https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/" class="calibre6"><span>https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/</span></a>). XML was first used in <strong class="calibre1">DI</strong> injectors. Later <strong class="calibre1">Groovy</strong> based <strong class="calibre1">Domain Specific Language</strong> (<a href="https://martinfowler.com/books/dsl.html" class="calibre6"><span>https://martinfowler.com/books/dsl.html</span></a>) came into picture and Java fluent API approach. We will use only the last one being the most modern and we will use <strong class="calibre1">Spring</strong> and <strong class="calibre1">Guice</strong><strong class="calibre1">DI</strong> containers since they are the most well-known injector implementations.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing the game</h1>
            

            <article>
                
<p class="calibre2">Collections without examples are boring. Fortunately, we have our game where we use a few collection classes and also other aspects that we will examine in this chapter.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">ColorManager</h1>
            

            <article>
                
<p class="calibre2">We jumped into the pool filled with collection classes from the implementation of the <kbd class="calibre11">ColorManager</kbd> class. Let's refresh the part of the class that is interesting for us now—the constructor:</p>
<pre class="calibre20">
final protected int nrColors; <br class="title-page-name"/> final protected Map&lt;Color, Color&gt; successor = new HashMap&lt;&gt;(); <br class="title-page-name"/> final private Color first; <br class="title-page-name"/>  <br class="title-page-name"/> public ColorManager(int nrColors) { <br class="title-page-name"/>     this.nrColors = nrColors; <br class="title-page-name"/>     first = new Color(); <br class="title-page-name"/>     Color previousColor = first; <br class="title-page-name"/>  <br class="title-page-name"/>     for (int i = 1; i &lt; nrColors; i++) { <br class="title-page-name"/>         final Color thisColor = new Color(); <br class="title-page-name"/>         successor.put(previousColor, thisColor); <br class="title-page-name"/>         previousColor = thisColor; <br class="title-page-name"/>     } <br class="title-page-name"/>     successor.put(previousColor, Color.none); <br class="title-page-name"/> }
</pre>
<p class="calibre2">We will use <kbd class="calibre11">HashMap</kbd> to keep the colors in an ordered list. At first, the choice of <kbd class="calibre11">HashMap</kbd> seems to be strange. Very true, that during the coding of <kbd class="calibre11">ColorManager</kbd>, I also considered a <kbd class="calibre11">List</kbd>, which seemed to be a more obvious choice. When we have a <kbd class="calibre11">List&lt;Color&gt; colors</kbd> variable, then the <kbd class="calibre11">nextColor</kbd> method is something like this:</p>
<pre class="calibre20">
public Color nextColor(Color color) { <br class="title-page-name"/>     if (color == Color.none) <br class="title-page-name"/>         return null; <br class="title-page-name"/>     else <br class="title-page-name"/>         return colors.get(colors.indexOf(color) + 1); <br class="title-page-name"/> }
</pre>
<p class="calibre2">The constructor will be much simpler, as shown in the following piece of code:</p>
<pre class="calibre20">
final List&lt;Color&gt; colors = new ArrayList&lt;&gt;(); <br class="title-page-name"/>  <br class="title-page-name"/>     public ColorManager(int nrColors) { <br class="title-page-name"/>         this.nrColors = nrColors; <br class="title-page-name"/>         for (int i = 0; i &lt; nrColors; i++) { <br class="title-page-name"/>             colors.add(new Color()); <br class="title-page-name"/>         } <br class="title-page-name"/>         colors.add(Color.none); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public Color firstColor() { <br class="title-page-name"/>         return colors.get(0); <br class="title-page-name"/>     }
</pre>
<p class="calibre2">Why did I choose the more complex solution and the unobvious data structure? The thing is performance. When the <kbd class="calibre11">nextColor</kbd> method is invoked, the list implementation first finds the element checking all the elements in the list and then fetches the next element. The time is proportional to the number of colors. When our number of colors increases, the time will also increase to just get the next color having one.</p>
<p class="calibre2">At the same time, if we focus on not the data structure that comes from the verbal expression of the task we want to solve (get the colors in a sorted order) but rather focus on the actual method that we want to implement, <kbd class="calibre11">nextColor(Color)</kbd>, then we will easily come to the conclusion that a <kbd class="calibre11">Map</kbd> is more reasonable. What we need is exactly a <kbd class="calibre11">Map</kbd> : having one element we want another related to the one we have. The key and the value is also <kbd class="calibre11">Color</kbd>. Getting the next element is constant time using <kbd class="calibre11">HashMap</kbd>. This implementation is probably faster than the one based on <kbd class="calibre11">ArrayList</kbd>.</p>
<div class="packtinfobox">The problem is that it is only probably faster. When you consider refactoring a code to have better performance, your decision should always be based on measurements. If you implement a code that you only think is faster, practice shows, you will fail. In best case, you will optimize a code to be blazing fast and runs during the application server setup. At the same time, optimized code is usually less readable. Something for something.<br class="calibre23"/>
Optimization should never be done prematurely. Code for readability first. Then, assess the performance, and in case there is problem with the performance, then profile the execution and optimize the code where it hurts the most of the overall performance. Micro-optimizations will not help.<br class="calibre23"/>
Did I do premature optimization selecting the <kbd class="calibre22">HashMap</kbd> implementation instead of <kbd class="calibre22">List</kbd>? If I actually implemented the code using <kbd class="calibre22">List</kbd> and then refactored, then yes. If I was thinking about the <kbd class="calibre22">List</kbd> solution and then it came to me that  <kbd class="calibre22">Map</kbd> solution is better without prior coding, then I did not. By years, such considerations will come easier, as you will also experience.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The class color</h1>
            

            <article>
                
<p class="calibre2">We have already looked at the code for the class code and it was the simplest class in the world. In reality, as it is in the GitHub repository (<a href="https://github.com/j9be/chapter04" class="calibre6"><span>https://github.com/j9be/chapter04</span></a> or <a href="https://github.com/PacktPublishing/Java-9-Programming-By-Example/tree/master/Chapter04" class="calibre6">https://github.com/PacktPublishing/Java-9-Programming-By-Example/tree/master/Chapter04</a>), the code is a bit more complex:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> /** <br class="title-page-name"/>  * Represents a color in the MasterMind table. <br class="title-page-name"/>  */ <br class="title-page-name"/> public class Color { <br class="title-page-name"/>     /** <br class="title-page-name"/>      * A special object that represents a <br class="title-page-name"/>      * value that is not a valid color. <br class="title-page-name"/>      */ <br class="title-page-name"/>     public static final Color none = new Color(); <br class="title-page-name"/> }
</pre>
<p class="calibre2">We have a special color constant named <kbd class="calibre11">none</kbd> that we use to signal a reference that is of type <kbd class="calibre11">Color</kbd> but is not a valid <kbd class="calibre11">Color</kbd>. In professional development, we used the <kbd class="calibre11">null</kbd> value for a long time to signal invalid reference, and because we are backward compatible, we still use it. However, it is recommended to avoid the <kbd class="calibre11">null</kbd> reference wherever possible.</p>
<div class="packtinfobox">Tony Hoare (<a href="https://en.wikipedia.org/wiki/Tony_Hoare" class="calibre25"><span class="URLPACKT">https://en.wikipedia.org/wiki/Tony_Hoare</span></a>), who invented the <kbd class="calibre22">null</kbd> reference in 1965, admitted one time that this was a mistake that cost billions of dollars in the IT industry.</div>
<p class="calibre2">The problem with the <kbd class="calibre11">null</kbd> value is that it takes the control away from the class, and thus, opens encapsulation. If a method returns <kbd class="calibre11">null</kbd> in some situation, the caller is strictly required to check the nullity and act according to that. For example, you cannot call a method on a <kbd class="calibre11">null</kbd> reference and you cannot access any field. If the method returns, a special instance of the object these problems are less serious. If the caller forgets to check the special return value and invokes methods on the special instance, the methods invoked still have the possibility to implement some exception or error handling. The class has the control encapsulated and can throw a special exception that may give more information about the error caused by the programmatic mistake by the caller not checking the special value.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">JavaDoc and code comments</h1>
            

            <article>
                
<p class="calibre2">There is also another difference between what we presented here earlier and the listing. This is the commenting of the code. Code comments are part of the program, which are ignored, filtered out by the compiler. These comments are solely for those who maintain or use the code.</p>
<p class="calibre2">In Java, there are two different comments. The code enclosed between <kbd class="calibre11">/*</kbd> and <kbd class="calibre11">*/</kbd> are comments. The start and the end of the comment do not need to be on the same line. The other type of comment starts with the <kbd class="calibre11">//</kbd> characters and ends at the end of the line.</p>
<p class="calibre2">To document the code, the JavaDoc tool can be used. JavaDoc is a special tool that reads the source code and extracts HTML documentation about the classes, methods, fields, and other entities that have a comment starting with the <kbd class="calibre11">/**</kbd> characters. The documentation will contain the JavaDoc comments in a formatted way and also the information that is extracted from the program code.</p>
<p class="calibre2">The documentation also appears as online help in the IDE when you move the mouse over a method call or class name, if there is any. The JavaDoc comment can contain HTML codes, but it generally should not. If really needed, you can use <kbd class="calibre11">&lt;p&gt;</kbd> to start a new paragraph or the <kbd class="calibre11">&lt;pre&gt;</kbd> tags to include some preformatted code sample into the documentation, but nothing more gives real benefit. Documentation should be as short as possible and contain as few formatting as possible.</p>
<p class="calibre2">There are special tags that appear in the JavaDoc documentation. These are prefilled by the IDEs when you start to type a JavaDoc as <kbd class="calibre11">/**</kbd> and then press <em class="calibre12">Enter</em>. These are inside the comment and start with the <kbd class="calibre11">@</kbd> character. There are a predefined set of tags: <kbd class="calibre11">@author</kbd>, <kbd class="calibre11">@version</kbd>, <kbd class="calibre11">@param</kbd>, <kbd class="calibre11">@return</kbd>, <kbd class="calibre11">@exception</kbd>, <kbd class="calibre11">@see</kbd>, <kbd class="calibre11">@since</kbd>, <kbd class="calibre11">@serial</kbd>, and <kbd class="calibre11">@deprecated</kbd>. The most important tags are <kbd class="calibre11">@param</kbd> and <kbd class="calibre11">@return</kbd>. They are used to describe the method arguments and the return value. Although we are not there yet, let's peek ahead to the <kbd class="calibre11">guessMatch</kbd> method from the <kbd class="calibre11">Guesser</kbd> class.</p>
<pre class="calibre20">
/** <br class="title-page-name"/>  * A guess matches if all rows in the table matches the guess. <br class="title-page-name"/>  * <br class="title-page-name"/>  * @param guess to match against the rows <br class="title-page-name"/>  * @return true if all rows match <br class="title-page-name"/>  */ <br class="title-page-name"/> protected boolean guessMatch(Color[] guess) { <br class="title-page-name"/>     for (Row row : table.rows) { <br class="title-page-name"/>         if (!row.guessMatches(guess)) { <br class="title-page-name"/>             return false; <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>     return true; <br class="title-page-name"/> }
</pre>
<p class="calibre2">The name of the parameter is automatically generated by the IDE. When you create the documentation, write something that is meaningful and not tautology. Many times, novice programmers feel the urge to write JavaDoc, and that something has to be written about the parameters. They create documentations like this:</p>
<pre class="calibre20">
* @param guess is the guess
</pre>
<p class="calibre2">Really? I would never have guessed. If you do not know what to write there to document the parameter, it may happen that you were choosing the name of the parameter excellent. The documentation of our preceding example will look as follows:</p>
<div class="packtfigure"><img class="image-border30" src="../images/00042.jpeg"/></div>
<p class="calibre2">Focus on what the method, class, and interface does and how it can be used. Do not explain how it works internally. JavaDoc is not the place for the explanation of the algorithm or the coding. It is used to help use the code. However, if somebody happens to explain how a method works, it is not a disaster. Comments can easily be deleted.</p>
<p class="calibre2">There is, however, a comment that is worse than nothing: outdated documentation that is not valid anymore. When the contract of the element has changed, but the documentation does not follow the change and is misleading the user who wants to call the method, interface, or class whatever will face serious bugs and will be clueless.</p>
<p class="calibre2">From now on, JavaDoc comments will not be listed in print to save trees, and electrons in the eBook version, but they are there in the repository and can be examined.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Row</h1>
            

            <article>
                
<p class="calibre2">Now, we have <kbd class="calibre11">Color</kbd>s and even instances if we need having a <kbd class="calibre11">ColorManager</kbd>. This is the time to store <kbd class="calibre11">Color</kbd>s in <kbd class="calibre11">Row</kbd>s. The <kbd class="calibre11">Row</kbd> class is a bit longer, but not too complex.</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> import java.util.Arrays; <br class="title-page-name"/>  <br class="title-page-name"/> public class Row { <br class="title-page-name"/>     final Color[] positions; <br class="title-page-name"/>     private int matchedPositions; <br class="title-page-name"/>     private int matchedColors;
</pre>
<p class="calibre2">A <kbd class="calibre11">Row</kbd> contains three fields. One is the <kbd class="calibre11">positions</kbd> array. Each element of the array is a <kbd class="calibre11">Color</kbd>. The <kbd class="calibre11">matchedPositions</kbd> is the number of positions that are matched and <kbd class="calibre11">matchedColors</kbd> is the number of colors that match a color in the hidden row but is not on the position as in the hidden row.</p>
<pre class="calibre20">
    public static final Row none = new Row(Guesser.none);
</pre>
<p class="calibre2">The <kbd class="calibre11">none</kbd> is a constant that contains a special <kbd class="calibre11">Row</kbd> instance that we will use wherever we would use <kbd class="calibre11">null</kbd>. The constructor gets the colors in an array that should be in the row.</p>
<pre class="calibre20">
  public Row(Color[] positions) { <br class="title-page-name"/>         this.positions = Arrays.copyOf(positions, positions.length); <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The constructor makes a copy of the original array. This is an important code that we will examine a bit. Let's reiterate that Java passes arguments by value. It means that when you pass an array to a method, you will pass the value of the variable that holds the array. However, an array in Java is an Object just as well as anything else (except primitives like <kbd class="calibre11">int</kbd>). Therefore, what the variable contains is a reference to an object that happens to be an array. If you change the elements of the array, you actually change the elements of the original array. The array reference is copied when the argument passes, but the array itself, and the elements, are not.</p>
<p class="calibre2">The <kbd class="calibre11">java.util.Arrays</kbd> utility class provides a lot of useful tools. We can easily code the array copying in Java but why to reinvent the wheel? In addition to that, arrays are continuous area of memory that can very effectively be copied from one place to another using low-level machine code. The <kbd class="calibre11">copyOf</kbd> method that we invoke calls the method <kbd class="calibre11">System.arraycopy</kbd> which is a native method and as such executes native code.</p>
<div class="packttip">Note that there is no guarantee that <kbd class="calibre22">Arrays.copyOf</kbd> invokes the native implementations and that this will be extremely fast in case of large arrays. The very version I was testing and debugging was doing it that way, and we can assume that a good JDK does something similar, effective and fast.</div>
<p class="calibre2">After we copied the array, it is not a problem if the caller modifies the array that was passed to the constructor. The class will have a reference to a copy that will contain the same elements. However, note that if the caller changes any of the objects that are stored in the array (not the reference in the array, but the object itself that is referenced by an array element), then the same object is modified. <kbd class="calibre11">Arrays.copyOf</kbd> does not copy the objects that are referenced by the array, only the array elements.</p>
<p class="calibre2">The row is created along with the colors and thus, we used a <kbd class="calibre11">final</kbd> field for the <kbd class="calibre11">Color</kbd> array. The matches, however, cannot be known when a Row is created. One of the players creates the <kbd class="calibre11">Row</kbd> and after that, the other player will tell the two <kbd class="calibre11">int</kbd> values. We do not create two setters for the two values, however, because they are always defined at the same time in the game together.</p>
<pre class="calibre20">
  public void setMatch(int matchedPositions, int matchedColors) { <br class="title-page-name"/>         if (matchedColors + matchedPositions &gt; positions.length) { <br class="title-page-name"/>             throw new IllegalArgumentException( <br class="title-page-name"/>                     "Number of matches can not be more that the position."); <br class="title-page-name"/>         } <br class="title-page-name"/>         this.matchedColors = matchedColors; <br class="title-page-name"/>         this.matchedPositions = matchedPositions; <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The <kbd class="calibre11">setMatch</kbd> method does not only set the values, but also checks that the values are consistent. The sum of the two values cannot be more than the number of the columns. This check ensures that the caller, who uses the API of the <kbd class="calibre11">Row</kbd> class, does not use it inconsistently. If this API is used only from inside our code, this assertion should not be part of the code. A good coding style, in that case, will ensure that the method is never invoked inconsistently using unit tests. When we create API to use out of our control, we should check that the use is consistent. Failing to do so, our code may behave just weird when used inconsistently. When the caller sets matches to values that do not match any possible guess, the game may never finish and the caller may have a hard time figuring out what is going on. This figuring out probably will need the debug execution of our code.</p>
<p class="calibre2">If we throw an exception in this case, the program stops where the bug is. There is no need to debug the library.</p>
<pre class="calibre20">
public boolean guessMatches(Color[] guess) { <br class="title-page-name"/>     return nrMatchingColors(guess) == matchedColors &amp;&amp; <br class="title-page-name"/>             nrMatchingPositions(guess) == matchedPositions; <br class="title-page-name"/> }
</pre>
<p class="calibre2">The next method decides if a guess, given as an argument, matches the actual row. This method checks that the answers to the guess in the row can be valid if the current guess was in the hidden row. The implementation is fairly short and simple. A guess matches a row if the number of the colors matching and the number of positions matching are the same as the number given in the row. Do not be shy to write short methods. Do not think that a one-line method that essentially contains one statement is useless. Wherever we use this method, we could also write the expression, which is right after the return statement, but we do not for two reasons. The first and most important reason is that the algorithm, which decides that a row matches a guess belongs to the implementation of the class <kbd class="calibre11">Row</kbd>. If ever the implementation changes, the only location where the code is to be changed is here. The other reason is also important, and that is readability. In our codebase, we call this method from <kbd class="calibre11">abstract class Guesser</kbd>. It contains an <kbd class="calibre11">if</kbd> statement with the following expression:</p>
<pre class="calibre20">
if (!row.guessMatches(guess)) {
</pre>
<p class="calibre2">Would it be more readable in the following way:</p>
<pre class="calibre20">
if( !(nrMatchingColors(guess) == matchedColors &amp;&amp; nrMatchingPositions(guess) == matchedPositions)) {
</pre>
<p class="calibre2">I am certain that the majority of the programmers understand the intention of the first version easier. I would even recommend implementing the <kbd class="calibre11">doesNotMatchGuess</kbd> method to improve the readability of the code even more.</p>
<pre class="calibre20">
  public int nrMatchingColors(Color[] guess) { <br class="title-page-name"/>         int count = 0; <br class="title-page-name"/>         for (int i = 0; i &lt; guess.length; i++) { <br class="title-page-name"/>             for (int j = 0; j &lt; positions.length; j++) { <br class="title-page-name"/>                 if (i != j &amp;&amp; guess[i] == positions[j]) { <br class="title-page-name"/>                     count++; <br class="title-page-name"/>                 } <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>         return count; <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The number of matching colors is that which appears both in the row and the guess, but not in the same position. The definition, and how we calculate it, is fairly simple and unambiguous in case no color can appear twice in the hidden row. In case a color may appear multiple times in the hidden row, this implementation will count all occurrences of that color in the guess as many times as it appears in the hidden row. If we, for example, have a hidden <kbd class="calibre11">RRGB</kbd> row and the guess is <kbd class="calibre11">bYRR</kbd>, the calculation will say 4. It is a matter of agreement between the players how they count in this case. The important aspect is that they use the same algorithm, which should be true in our case, because we will ask the program to play both players. As we will program the code ourselves, we can trust that it will not cheat.</p>
<pre class="calibre20">
public int nrMatchingPositions(Color[] guess) { <br class="title-page-name"/>         int count = 0; <br class="title-page-name"/>         for (int i = 0; i &lt; guess.length; i++) { <br class="title-page-name"/>             if (guess[i] == positions[i]) { <br class="title-page-name"/>                 count++; <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>         return count; <br class="title-page-name"/>     }
</pre>
<p class="calibre2">Counting the colors that are OK, and also on the position where they are supposed to be, is even simpler.</p>
<pre class="calibre20">
public int nrOfColumns() { <br class="title-page-name"/>     return positions.length; <br class="title-page-name"/> }
</pre>
<p class="calibre2">This method tells the number of columns in the <kbd class="calibre11">Row</kbd>. This method is needed in the <kbd class="calibre11">Game</kbd> class that controls the flow of a whole game. As this class is in the same package as <kbd class="calibre11">Row</kbd>, it can access the field positions. I created the code to get the number of columns as <kbd class="calibre11">row.positions.length</kbd>. But then, I was reading the code next day and told myself: This is ugly and unreadable! What I am interested in here is not some mysterious positions' length; it is the number of columns. And the number of columns is the responsibility of the <kbd class="calibre11">Row</kbd> class and not the business of any other class. If I start to store the positions in a <kbd class="calibre11">List</kbd>, which does not have <kbd class="calibre11">length</kbd> (it has method <kbd class="calibre11">size</kbd>), it is the sole responsibility of <kbd class="calibre11">Row</kbd> and should not affect any other code. So, I created the <kbd class="calibre11">nrOfColumns</kbd> method to improve the code.</p>
<p class="calibre2">The rest of the class contains some more very simple methods that are needed only to display the game and not for the algorithm to play:</p>
<pre class="calibre20">
  public int nrColumns() { <br class="title-page-name"/>         return positions.length; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public Color position(int i) { <br class="title-page-name"/>         return positions[i]; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public int matchedPositions() { <br class="title-page-name"/>         return matchedPositions; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public int matchedColors() { <br class="title-page-name"/>         return matchedColors; <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">If you are a purist, you can encapsulate these methods into an inner class named <kbd class="calibre11">Output</kbd> or <kbd class="calibre11">Print</kbd> and call them through a final instance of it created as a field in the <kbd class="calibre11">Row</kbd> class. It is also possible to change the visibility of these fields from <kbd class="calibre11">private</kbd> to <kbd class="calibre11">protected</kbd> and implement these methods in a <kbd class="calibre11">PrintableRow</kbd> that can be instantiated from an already existing <kbd class="calibre11">Row</kbd> and implement these methods.</p>
<p class="calibre2">The first version of <kbd class="calibre11">PrintableRow</kbd> will look like this:</p>
<pre class="calibre20">
public class PrintableRow extends Row { <br class="title-page-name"/>     public PrintableRow(Row row) { <br class="title-page-name"/>         super(row.positions); <br class="title-page-name"/>         super.setMatch(row.matchedPositions,row.matchedColors); <br class="title-page-name"/>     } <br class="title-page-name"/> // the methods are deleted from the print ... <br class="title-page-name"/> }
</pre>
<p class="calibre2">The methods are exactly the same as in the preceding print; they are cut and pasted, or rather moved, using the IDE refactoring support from one class to the other.</p>
<div class="packttip">When you write a code, please never use copy and paste. However you can use cut and paste to move code fragments around. The danger is in the copy paste use. Many developers claim that their use of actual copy and paste is not copy paste programming. Their reasoning is that they change the pasted code so much that it has practically nothing to do with the original code.<br class="calibre23"/>
Really? In that case why did you need the copied code when you started the modification of it? Why not start from scratch? That is because if you use the IDE's copy and paste functionality then, no matter what, you do copy paste programming.</div>
<p class="calibre2">Class <kbd class="calibre11">PrintableRow</kbd> is pretty neat and separates the output concern from the core functionality. When you need an instance, it is not a problem that you have a <kbd class="calibre11">Row</kbd> instance already in hand. The constructor will essentially clone the original class and return a printable version. What bothers me is the implementation of the cloning. The code in the constructor calls the super constructor and then a method and all these work with the original functionality of the <kbd class="calibre11">Row</kbd> class. They have nothing to do with the printability that <kbd class="calibre11">PrintableRow</kbd> implements. This functionality actually belongs to the <kbd class="calibre11">Row</kbd> class. We should create a protected constructor that does the cloning:</p>
<pre class="calibre20">
protected Row(Row cloneFrom) { <br class="title-page-name"/>     this(cloneFrom.positions); <br class="title-page-name"/>     setMatch(cloneFrom.matchedPositions, cloneFrom.matchedColors); <br class="title-page-name"/> }
</pre>
<p class="calibre2">The constructor of <kbd class="calibre11">PrintableRow</kbd> should simply call <kbd class="calibre11">super(row)</kbd> and that is it.</p>
<div class="packttip">Code is never finished and never perfect. In a professional environment, programmers many times tend to finish polishing the code when it is good enough. There is no code that cannot be made better, but there is a deadline. The software has to be passed on to the testers and users and has to be used to help economy. After all, that is the final goal of a professional developer: have a code that supports the business. A code that never runs is worth nothing.<br class="calibre23"/>
I do not want you to think that the examples that I provided here were created perfect upfront. The reason for that is (did you read carefully?) because they are not perfect. As I said, code is never perfect.<br class="calibre23"/>
When I first created Row, it contained the printing methods in an inner class. I did not like it. The code was smelly. So, I decided to move the functionality to the <kbd class="calibre22">Row</kbd> class. However, I still did not like the solution. Then, I went to bed, slept, worked, and returned to it a few days later. What I could not create the day before now seemed obvious—these methods have to be moved to a subclass.<br class="calibre23"/>
Now comes another dilemma. Should I present this final solution or should I have here the different versions? In some cases, I will just present the final version. In other cases, like this, there are things to learn from the development step. In these cases, I present not only the code, but part of its evolution on how it was created. If you want to see those that I did not dare publishing, look at the Git history. I admit, sometimes, I create code that even makes me facepalm a day later.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Table</h1>
            

            <article>
                
<p class="calibre2">Table is a simple class that has only one very simple functionality.</p>
<pre class="calibre20">
public class Table { <br class="title-page-name"/>     final ColorManager manager; <br class="title-page-name"/>     final int nrColumns; <br class="title-page-name"/>     final List&lt;Row&gt; rows; <br class="title-page-name"/>  <br class="title-page-name"/>     public Table(int nrColumns, ColorManager manager) { <br class="title-page-name"/>         this.nrColumns = nrColumns; <br class="title-page-name"/>         this.rows = new LinkedList&lt;&gt;(); <br class="title-page-name"/>         this.manager = manager; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public void addRow(Row row) { <br class="title-page-name"/>         rows.add(row); <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">There is one thing to mention, which is nothing new, but worth repeating. The <kbd class="calibre11">rows</kbd> variable is declared as final and it gets the value in the constructor. This is a <kbd class="calibre11">List&lt;Row&gt;</kbd> type variable. The fact that it is <kbd class="calibre11">final</kbd> means that it will hold the same list object during its lifetime. The length, members, and other features of the list may and will change. We will add new rows to this list. Final object variables reference an object, but it does not guarantee that the object itself is immutable. It is only the variable that does not change.</p>
<div class="packttip">When you do code review and explain to your colleagues what a class does, and you find yourself starting the explanation "this class is very simple" many times, it means the code is good.<br class="calibre23"/>
Well, it may be wrong in other aspects, but the class' granularity seems to be okay.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Guesser</h1>
            

            <article>
                
<p class="calibre2">Guesser and the <kbd class="calibre11">UniqueGuesser</kbd> and <kbd class="calibre11">GeneralGuesser</kbd> subclasses are the most interesting classes of the program. They actually perform the task that is the core of the game. Given a <kbd class="calibre11">Table</kbd> with a hidden row, the guesser has to create newer and newer guesses.</p>
<p class="calibre2">To do this, a <kbd class="calibre11">Guesser</kbd> needs to get a <kbd class="calibre11">Table</kbd> when it is created. This is passed as a constructor argument. The only method it should implement is <kbd class="calibre11">guess</kbd>, which returns a new guess based on the table and on its actual state.</p>
<p class="calibre2">As we want to implement a guesser that assumes that all colors in the hidden row are different, and also one that does not make this assumption, we will implement three classes. <kbd class="calibre11">Guesser</kbd> is an abstract class that implements only the logic that is independent from the assumptions. These methods will be inherited by both actual implementations: <kbd class="calibre11">UniqueGuesser</kbd> and <kbd class="calibre11">GeneralGuesser</kbd>.</p>
<p class="calibre2">Let's go through the actual code of the class:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> public abstract class Guesser { <br class="title-page-name"/>     protected final Table table; <br class="title-page-name"/>     private final ColorManager manager; <br class="title-page-name"/>     public Guesser(Table table) { <br class="title-page-name"/>         this.table = table; <br class="title-page-name"/>         this.lastGuess = new Color[table.nrColumns]; <br class="title-page-name"/>         this.manager = table.manager; <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The state of the guesser is the last guess it made. Although this is on the last row of the table, it is more of an internal matter of the guesser. The guesser has all the possible guesses, one after the other; <kbd class="calibre11">lastGuess</kbd> is the one where it left off last time and it should continue from there when it is invoked again.</p>
<pre class="calibre20">
    abstract protected void setFirstGuess();
</pre>
<p class="calibre2">Setting the first guess very much depends on the assumption of color uniqueness. The first guess should not contain duplicated colors in case the hidden row does not (at least in our implementation), while <kbd class="calibre11">GeneralGuesser</kbd> is free to guess any time, even as <kbd class="calibre11">firstGuess</kbd> all colors to be the same.</p>
<pre class="calibre20">
    protected final Color[] lastGuess; <br class="title-page-name"/>    public static final Color[] none = new Color[]{Color.none};
</pre>
<p class="calibre2">Again, <kbd class="calibre11">none</kbd> in this class is just an object that we try to use instead of <kbd class="calibre11">null</kbd>, whenever we need to return something that is a reference to a <kbd class="calibre11">Guess</kbd> but is not really a guess.</p>
<pre class="calibre20">
  protected Color[] nextGuess() { <br class="title-page-name"/>         if (lastGuess[0] == null) { <br class="title-page-name"/>             setFirstGuess(); <br class="title-page-name"/>             return lastGuess; <br class="title-page-name"/>         } else { <br class="title-page-name"/>             return nextNonFirstGuess(); <br class="title-page-name"/>         } <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The <kbd class="calibre11">nextGuess</kbd> method is an internal method that generates the next guess, which just comes as we order the possible guesses. It does not check anything against the <kbd class="calibre11">Table</kbd>; it only generates the next guess almost without thinking. The implementation on how we do the first guess and how we do the consecutive guesses are different. Thus, we will implement these algorithms in different methods and invoke them from here.</p>
<p class="calibre2">The <kbd class="calibre11">nextNonFirstGuess</kbd> method represents the next guess in the special case when the guess is not the first one:</p>
<pre class="calibre20">
  private Color[] nextNonFirstGuess() { <br class="title-page-name"/>         int i = 0; <br class="title-page-name"/>         boolean guessFound = false; <br class="title-page-name"/>         while (i &lt; table.nrColumns &amp;&amp; !guessFound) { <br class="title-page-name"/>             if (manager.thereIsNextColor(lastGuess[i])) { <br class="title-page-name"/>                 lastGuess[i] = manager.nextColor(lastGuess[i]); <br class="title-page-name"/>                 guessFound = true; <br class="title-page-name"/>             } else { <br class="title-page-name"/>                 lastGuess[i] = manager.firstColor(); <br class="title-page-name"/>                 i++; <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>         if (guessFound) { <br class="title-page-name"/>             return lastGuess; <br class="title-page-name"/>         } else { <br class="title-page-name"/>             return none; <br class="title-page-name"/>         } <br class="title-page-name"/>     }
</pre>
<p class="calibre2">Look back a few pages where we detailed how the algorithm works. We made the statement that this way of working is very much like the way we count with decimal numbers. By now, you have enough Java knowledge and programming skill to understand what the method does. It is more interesting to know why it is coded that way.</p>
<p class="calibre2">Hint: as always, to be readable.</p>
<p class="calibre2">There is the temptation to eliminate the <kbd class="calibre11">guessFound</kbd> variable. Would it not be simpler to return from the middle of the method when we find the blessed guesses? If we did, there would be no need to check the <kbd class="calibre11">guessFound</kbd> value before returning <kbd class="calibre11">none</kbd> value. The code would not get there if we returned from the middle of the loop.</p>
<p class="calibre2">Yes, it would be simpler to write. But, we create code to be readable and not writable. Yes, but less code is more readable. Not in this case! Returning from a loop degrades the readability. Not to mention, the <kbd class="calibre11">return</kbd> statements are scattered around in the method at different stages of execution.</p>
<pre class="calibre20">
private Color[] nextNonFirstGuess() { <br class="title-page-name"/>     int i = 0; <br class="title-page-name"/>     while (i &lt; table.nrColumns) { <br class="title-page-name"/>         if (manager.thereIsNextColor(lastGuess[i])) { <br class="title-page-name"/>             lastGuess[i] = manager.nextColor(lastGuess[i]); <br class="title-page-name"/>             return lastGuess; <br class="title-page-name"/>         } else { <br class="title-page-name"/>             lastGuess[i] = manager.firstColor(); <br class="title-page-name"/>             i++; <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>     return none; <br class="title-page-name"/> }
</pre>
<p class="calibre2">When somebody writes a code optimized in that way, it is similar to a toddler who makes his first steps and then looks proudly at the mother. Okay boy/girl, you are great. Now go on and start walking. When you are the postman, walking will be boring. That will be your profession. So, slide aside the pride and write boring code. Professionals write boring code. Won't it be slow?</p>
<p class="calibre2">No! It will not be slow. First of all, it is not slow until the profiler proves that the code does not meet the business requirements. If it does, it is fast enough, no matter how slow it is. Slow is good as long as it is okay for the business. After all, JIT should have some task optimizing the code to run.</p>
<p class="calibre2">The next method checks if the guess matches the previous guesses and their results on the <kbd class="calibre11">Table</kbd>:</p>
<pre class="calibre20">
    private boolean guessMatch(Color[] guess) { <br class="title-page-name"/>         for (Row row : table.rows) { <br class="title-page-name"/>             if (!row.guessMatches(guess)) { <br class="title-page-name"/>                 return false; <br class="title-page-name"/>             } <br class="title-page-name"/>         } <br class="title-page-name"/>         return true; <br class="title-page-name"/>     } <br class="title-page-name"/>     private boolean guessDoesNotMatch(Color[] guess) { <br class="title-page-name"/>         return !guessMatch(guess); <br class="title-page-name"/>     }
</pre>
<p class="calibre2">As we have the guess matching already implemented in the class <kbd class="calibre11">Row</kbd>, all we have to do is invoke that method for each row in the table. If all rows match, then the guess can be good for the table. If any of the former guesses do not match, then this guess goes down the drain.</p>
<p class="calibre2">As we check the negated expression of matching, we created an English version of the method.</p>
<div class="packttip">In situations like this, it could be enough to create the <kbd class="calibre22">guessDoesNotMatch</kbd> version of the method. However, the logical execution of the code is more readable if the method is not negated. Therefore, it is more error prone to write the <kbd class="calibre22">guessDoesNotMatch</kbd> method alone. Instead, we will implement the original, readable version and the aux method to be nothing more than a negation.</div>
<p class="calibre2">After all the aux methods, here we are implementing the public method of the <kbd class="calibre11">Guesser</kbd>.</p>
<pre class="calibre20">
public Row guess() { <br class="title-page-name"/>         Color[] guess = nextGuess(); <br class="title-page-name"/>         while (guess != none &amp;&amp; guessDoesNotMatch(guess)) { <br class="title-page-name"/>             guess = nextGuess(); <br class="title-page-name"/>         } <br class="title-page-name"/>         if (guess == none) { <br class="title-page-name"/>             return Row.none; <br class="title-page-name"/>         } else { <br class="title-page-name"/>             return new Row(guess); <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/> }
</pre>
<p class="calibre2">It just takes the <kbd class="calibre11">nextGuess</kbd> and again and again until it finds one that matches the hidden row, or there is no more guess. If it finds a proper guess, it encapsulate it to a <kbd class="calibre11">Row</kbd> object and return it so that it can later be added to the <kbd class="calibre11">Table</kbd> by the <kbd class="calibre11">Game</kbd> objects.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">UniqueGuesser</h1>
            

            <article>
                
<p class="calibre2">Class <kbd class="calibre11">UniqueGuesser</kbd> has to implement <kbd class="calibre11">setFirstGuess</kbd> (all concrete classes extending an abstract class should implement the abstract method of the parent) and it can and will override the protected <kbd class="calibre11">nextGuess</kbd> method:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> import java.util.HashSet; <br class="title-page-name"/> import java.util.Set; <br class="title-page-name"/>  <br class="title-page-name"/> public class UniqueGuesser extends Guesser { <br class="title-page-name"/>  <br class="title-page-name"/>     public UniqueGuesser(Table table) { <br class="title-page-name"/>         super(table); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     protected void setFirstGuess() { <br class="title-page-name"/>         int i = lastGuess.length-1; <br class="title-page-name"/>         for (Color color = table.manager.firstColor(); <br class="title-page-name"/>              i &gt;= 0; <br class="title-page-name"/>              color = table.manager.nextColor(color)) { <br class="title-page-name"/>             lastGuess[i--] = color; <br class="title-page-name"/>         } <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The <kbd class="calibre11">setFirstGuess</kbd> method selects the first guess in such a way that any possible color variations that come after the first one create the guesses one after the other if we follow the algorithm.</p>
<p class="calibre2">The aux <kbd class="calibre11">isNotUnique</kbd> method returns true if the guess contains duplicate colors. It is not interesting to see how many. If all colors are the same, or only one color appears twice, it does not matter. The guess is not unique and does not fit our guesser. This method judges that.</p>
<pre class="calibre20">
   private boolean isNotUnique(Color[] guess) { <br class="title-page-name"/>         final Set&lt;Color&gt; alreadyPresent = new HashSet&lt;&gt;(); <br class="title-page-name"/>         for (Color color : guess) { <br class="title-page-name"/>             if (alreadyPresent.contains(color)) { <br class="title-page-name"/>                 return true; <br class="title-page-name"/>             } <br class="title-page-name"/>             alreadyPresent.add(color); <br class="title-page-name"/>         } <br class="title-page-name"/>         return false; <br class="title-page-name"/>     }
</pre>
<p class="calibre2">To do this, it uses a <kbd class="calibre11">Set</kbd>, and any time a new color is found in the <kbd class="calibre11">guess</kbd> array, the color is stored in the set. If the set contains the color when we find it in the array, it means that the color was already used before; the guess is not unique.</p>
<pre class="calibre20">
     @Override <br class="title-page-name"/>     protected Color[] nextGuess() { <br class="title-page-name"/>         Color[] guess = super.nextGuess(); <br class="title-page-name"/>         while (isNotUnique(guess)) { <br class="title-page-name"/>             guess = super.nextGuess(); <br class="title-page-name"/>         } <br class="title-page-name"/>         return guess; <br class="title-page-name"/>     } <br class="title-page-name"/>  
</pre>
<p class="calibre2">The overriding <kbd class="calibre11">nextGuess</kbd> method is simple. It asks the super <kbd class="calibre11">nextGuess</kbd> implementation to make guesses but throws away those that it does not like.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">GeneralGuesser</h1>
            

            <article>
                
<p class="calibre2">Class <kbd class="calibre11">GeneralGuesser</kbd> also has to implement the constructor and <kbd class="calibre11">setFirstGuess</kbd>, but generally, that is it.</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/>public class GeneralGuesser extends Guesser { <br class="title-page-name"/>  <br class="title-page-name"/>     public GeneralGuesser(Table table) { super(table); } <br class="title-page-name"/>  <br class="title-page-name"/>     @Override <br class="title-page-name"/>     protected void setFirstGuess() { <br class="title-page-name"/>         int i = 0; <br class="title-page-name"/>         for (Color color = table.manager.firstColor();  <br class="title-page-name"/>                                    i &lt; lastGuess.length; ) { <br class="title-page-name"/>             lastGuess[i++] = color; <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/> }
</pre>
<p class="calibre2">Setting the <kbd class="calibre11">lastGuess</kbd> it just puts the first color on all columns. Guess could not be simpler. Everything else is inherited from the <kbd class="calibre11">abstract class Guesser</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The Game class</h1>
            

            <article>
                
<p class="calibre2">An instance of the <kbd class="calibre11">Game</kbd> class contains a <kbd class="calibre11">Row</kbd> holding the secret color values and also contains a <kbd class="calibre11">Table</kbd>. When there is a new guess the <kbd class="calibre11">Game</kbd> instance stores the guess into the <kbd class="calibre11">Table</kbd> and also sets the number of positions and colors matching the secret row.</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> public class Game { <br class="title-page-name"/>  <br class="title-page-name"/>     final Table table; <br class="title-page-name"/>     final private Row secretRow; <br class="title-page-name"/>     boolean finished = false; <br class="title-page-name"/>  <br class="title-page-name"/>     public Game(Table table, Color[] secret ) { <br class="title-page-name"/>         this.table = table; <br class="title-page-name"/>         this.secretRow = new Row(secret); <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public void addNewGuess(Row row) { <br class="title-page-name"/>         if( isFinished()){ <br class="title-page-name"/>             throw new IllegalArgumentException( <br class="title-page-name"/>                        "You can not guess on a finished game."); <br class="title-page-name"/>         } <br class="title-page-name"/>         final int positionMatch = secretRow. <br class="title-page-name"/>                           nrMatchingPositions(row.positions); <br class="title-page-name"/>         final int colorMatch = secretRow. <br class="title-page-name"/>                           nrMatchingColors(row.positions); <br class="title-page-name"/>         row.setMatch(positionMatch, colorMatch); <br class="title-page-name"/>         table.addRow(row); <br class="title-page-name"/>         if( positionMatch == row.nrOfColumns() ){ <br class="title-page-name"/>             finished = true; <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     public boolean isFinished() { <br class="title-page-name"/>         return finished; <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">Think about what I wrote earlier about short methods, and when you download the code from GitHub to play with it, try to make it look more readable. You can, perhaps, create and use a method named <kbd class="calibre11">boolean itWasAWinningGuess(int positionMatch)</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating an integration test</h1>
            

            <article>
                
<p class="calibre2">We have created unit tests in the previous chapter and there are unit tests for the functionalities implemented in the classes of this chapter as well. We will just not print these unit tests here. Instead of listing the unit tests, we will look at an integration test.</p>
<p class="calibre2">Integration tests need the invocation of many classes working together. They check that the functionality can be delivered by the whole application, or at least a larger part of the application, and do not focus on a single unit. They are called integration tests because they test the integration between classes. The classes alone are all OK. They should not have any problem as it was already verified by the unit tests. Integration focuses on how they work together.</p>
<p class="calibre2">If we want to test the <kbd class="calibre11">Game</kbd> class, we will either have to create mocks that mimic the behavior of the other <kbd class="calibre11">Game</kbd> classes, or we will just write an integration test. Technically, an integration test is very similar to a unit test. Many times, the very same JUnit framework is used to execute the integration tests. This is the case for the integration test of this game.</p>
<p class="calibre2">The build tool, however, needs to be configured to execute the integration tests only when it is required. Usually, integration test executions need more time, and sometimes resources, such as external database that may not be available at each and every developer desktop. Unit tests run every time the application is compiled so they have to be fast. To separate the unit and integration tests, there are different techniques and configuration options, but there is no such more or less de-facto standard like the directory structure introduced by Maven (later adapted by Gradle).</p>
<p class="calibre2">In our case, the integration test does not need any extra resource and does not take enormous time to run. It plays a game from the start to the end and plays the role of both the players. It is very much like somebody playing chess with themselves, making a step and then turning the table.</p>
<p class="calibre2">The aim of this code is twofold. On one hand, we want to see that the code runs and plays a whole game. If the game finishes, then it is just OK. This is a very weak assertion and real integration tests perform lots of assertions (one test tests only one assertion though). We will focus on the other aim—deliver some joy and visualize the game on the console in text format so that the reader does not get bored.</p>
<p class="calibre2">To do that, we will create a utility class that prints out a color and assigns letters to the <kbd class="calibre11">Color</kbd> instances on the fly. This is the <kbd class="calibre11">PrettyPrintRow</kbd> class. There are several limitations in this class that we have to talk about after we look at the code. I'd say that this code is here only to demonstrate what not to do, to establish some reasoning for the next chapter, and why we need to refactor the code we created in this one.</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind; <br class="title-page-name"/>  <br class="title-page-name"/> import java.util.HashMap; <br class="title-page-name"/> import java.util.Map; <br class="title-page-name"/>  <br class="title-page-name"/> public class PrettyPrintRow { <br class="title-page-name"/>  <br class="title-page-name"/>     private static final Map&lt;Color, Character&gt; <br class="title-page-name"/>             letterMapping = new HashMap&lt;&gt;(); <br class="title-page-name"/>     private static final String letters = "RGBYWb"; <br class="title-page-name"/>     private static int counter = 0; <br class="title-page-name"/>  <br class="title-page-name"/>     private static char colorToChar(Color color) { <br class="title-page-name"/>         if (!letterMapping.containsKey(color)) { <br class="title-page-name"/>             letterMapping.put(color, letters.charAt(counter)); <br class="title-page-name"/>             counter++; <br class="title-page-name"/>  <br class="title-page-name"/>         } <br class="title-page-name"/>         return letterMapping.get(color); <br class="title-page-name"/>     }
</pre>
<p class="calibre2">This is the heart of this class. When a color is to be printed, it gets a letter assigned unless it already has one. As the <kbd class="calibre11">Map</kbd> containing the assignments in each and every game that is running in the JVM will use the same mapping, a new <kbd class="calibre11">Game</kbd> is started. It allocates new <kbd class="calibre11">Color</kbd>s and will soon run out of the six characters that we allocated here in the <kbd class="calibre11">String</kbd> constant.</p>
<p class="calibre2">If the <kbd class="calibre11">Game</kbd> instances are run parallel, then we are in even more trouble. The class is not thread safe at all. If two threads concurrently call the <kbd class="calibre11">colorToChar</kbd> method for the same <kbd class="calibre11">Color</kbd> instance, (which is not likely because each <kbd class="calibre11">Game</kbd> uses its own color, but note that <em class="calibre12">not likely</em> in programming is very much like a famous last words quote on a tombstone) then both threads may see at the same time that there is no letter assigned to the color and both will assign the letter (the same letter or two different letters, based on luck) and increase the counter once or twice. At least, what we can say is that the execution is nondeterministic.</p>
<p class="calibre2">You may recall that I said violating the hash contract is the second most difficult to find bug after multithread issues. Such a nondeterministic code is exactly that: a multithread issue. There is no prize to find the most difficult bug. When the application does not run, and a bug affects the production system for hours or days, no businessperson will be happy, and they will not be amazed after you find the bug. It may be an intellectual challenge, but the real value is not creating the bugs in the first place.</p>
<p class="calibre2">As a summary, this code can only be used once in a JVM by a single thread. For this chapter, it is good, though a smelly and shameful code, but it will be a good example for the next chapter, in which we will see, how to refactor the application so that it will not need such a hacking to print out the colors.</p>
<div class="packtinfobox">Code smell is a term minted by Kent Back, according to Martin Fowler (<a href="http://martinfowler.com/bliki/CodeSmell.html" class="calibre25"><span class="URLPACKT">http://martinfowler.com/bliki/CodeSmell.html</span></a>). It means that some code looks not good, nor apparently bad, but some constructs make the feeling in the developer that it may not be good. As it is defined on the web page, <em class="calibre27">"A code smell is a surface indication that usually corresponds to a deeper problem in the system."</em> The term is widely accepted and used in software development for the last 10 years.</div>
<p class="calibre2">The rest of the code is plain and simple:</p>
<pre class="calibre20">
   public static String pprint(Row row) { <br class="title-page-name"/>         String string = ""; <br class="title-page-name"/>         PrintableRow pRow = new PrintableRow(row); <br class="title-page-name"/>         for (int i = 0; i &lt; pRow.nrOfColumns(); i++) { <br class="title-page-name"/>             string += colorToChar(pRow.position(i)); <br class="title-page-name"/>         } <br class="title-page-name"/>         string += " "; <br class="title-page-name"/>         string += pRow.matchedPositions(); <br class="title-page-name"/>         string += "/"; <br class="title-page-name"/>         string += pRow.matchedColors(); <br class="title-page-name"/>         return string; <br class="title-page-name"/>     }
</pre>
<p class="calibre2">The integration test, or rather the demonstration code (as it does not contain any assertions other than it runs without exception), defines six colors and four columns. This is the size of the original game. It creates a color manager, and then it creates a table and a secret. The secret could be just any random color selection from the six colors that is available (there are 360 different possibilities tested in the <kbd class="calibre11">UniqueGuesserTest</kbd> unit test available from GitHub). As we know that the <kbd class="calibre11">Guesser</kbd> implementation starts from one end of the color set and creates the new guesses systematically, we want to set a secret that it will guess the last. This is not because we are evil, but rather because we want to see that our code really works.</p>
<p class="calibre2">The directory structure of the code is very similar to the one we used in case of the Maven build tool, as can be seen on the following screenshot created on a Windows machine:</p>
<div class="packtfigure"><img class="image-border31" src="../images/00043.gif"/></div>
<p class="calibre2">The source code is under the directory <kbd class="calibre11">src</kbd> and the <kbd class="calibre11">main</kbd> and <kbd class="calibre11">test</kbd> source code files are separated into two subdirectory structures. The compiled files will be generated in the directory <kbd class="calibre11">build</kbd> when we use Gradle. The code of the integration test class is the following:</p>
<pre class="calibre20">
package packt.java9.by.example.mastermind.integration; <br class="title-page-name"/>  <br class="title-page-name"/> import org.junit.Assert; <br class="title-page-name"/> import org.junit.Test; <br class="title-page-name"/> import packt.java9.by.example.mastermind.*; <br class="title-page-name"/>  <br class="title-page-name"/> public class IntegrationTest { <br class="title-page-name"/>  <br class="title-page-name"/>     final int nrColors = 6; <br class="title-page-name"/>     final int nrColumns = 4; <br class="title-page-name"/>     final ColorManager manager = new ColorManager(nrColors); <br class="title-page-name"/>  <br class="title-page-name"/>     private Color[] createSecret() { <br class="title-page-name"/>         Color[] secret = new Color[nrColumns]; <br class="title-page-name"/>         int count = 0; <br class="title-page-name"/>         Color color = manager.firstColor(); <br class="title-page-name"/>         while (count &lt; nrColors - nrColumns) { <br class="title-page-name"/>             color = manager.nextColor(color); <br class="title-page-name"/>             count++; <br class="title-page-name"/>         } <br class="title-page-name"/>         for (int i = 0; i &lt; nrColumns; i++) { <br class="title-page-name"/>             secret[i] = color; <br class="title-page-name"/>             color = manager.nextColor(color); <br class="title-page-name"/>         } <br class="title-page-name"/>         return secret; <br class="title-page-name"/>     } <br class="title-page-name"/>  <br class="title-page-name"/>     @Test <br class="title-page-name"/>     public void testSimpleGame() { <br class="title-page-name"/>         Table table = new Table(nrColumns, manager); <br class="title-page-name"/>         Color[] secret = createSecret(); <br class="title-page-name"/>         System.out.println( <br class="title-page-name"/>             PrettyPrintRow.pprint(new Row(secret))); <br class="title-page-name"/>         System.out.println(); <br class="title-page-name"/>         Game game = new Game(table, secret); <br class="title-page-name"/>  <br class="title-page-name"/>         Guesser guesser = new UniqueGuesser(table); <br class="title-page-name"/>         while (!game.isFinished()) { <br class="title-page-name"/>             Row guess = guesser.guess(); <br class="title-page-name"/>             if (guess == Row.none) { <br class="title-page-name"/>                 Assert.fail(); <br class="title-page-name"/>             } <br class="title-page-name"/>             game.addNewGuess(guess); <br class="title-page-name"/>             System.out.println(PrettyPrintRow.pprint(guess)); <br class="title-page-name"/>         } <br class="title-page-name"/>     } <br class="title-page-name"/> }
</pre>
<p class="calibre2">The easiest way to run the test is start it from inside the IDE. When the IDE imports the project based on the build file, be it a Maven <kbd class="calibre11">pom.xml</kbd> or Gradle <kbd class="calibre11">build.gradle</kbd>. IDE usually provides a run button or menu to start the code. Running the game will print out the following piece of code that we worked so hard on in this chapter:</p>
<pre class="calibre20">
RGBY 0/0<br class="title-page-name"/>GRWb 0/2<br class="title-page-name"/>YBbW 0/2<br class="title-page-name"/>BYGR 0/4<br class="title-page-name"/>RGYB 2/2<br class="title-page-name"/>RGBY 4/0
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we programmed a table game: Mastermind. We not only programmed the model of the game, but also created an algorithm that can guess. We revisited some OO principles and discussed why the model was created the way it was. While we created the model of the game, which we will refine in the next chapter, you have learned about Java collections, what an integration test is, and how to create JavaDoc.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>