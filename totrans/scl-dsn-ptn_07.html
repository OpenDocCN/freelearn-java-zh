<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Structural Design Patterns</h1>
                </header>
            
            <article>
                
<p class="mce-root">The next stop of our journey through design patterns will focus on the family of <strong>structural design patterns</strong>. We will be doing a Scala point of view exploration of the following structural design patterns:</p>
<ul>
<li>Adapter</li>
<li>Decorator</li>
<li>Bridge</li>
<li>Composite</li>
<li>Facade</li>
<li>Flyweight</li>
<li>Proxy</li>
</ul>
<p>This chapter will give a better understanding of what structural design patterns are and why they are useful. After familiarizing ourselves with what they are, we will be looking into each of them separately and in detail, including code examples and hints about when to use each of them and when to avoid them, as well as what to be careful with when using them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining structural design patterns</h1>
                </header>
            
            <article>
                
<p>Structural design patterns are concerned with composing objects and classes in our software. They use different approaches in order to obtain new functionality and larger and potentially more complex structures. These approaches include the following:</p>
<ul>
<li>Inheritance</li>
<li>Composition</li>
</ul>
<p>Properly identifying the relationships between objects in an application is key to simplifying the application's structure. In the following sections, we will be looking at different design patterns and provide examples, which will give us a better feel of how to use the various structural design patterns.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The adapter design pattern</h1>
                </header>
            
            <article>
                
<p>In many cases, we have to make applications work by combining different components together. However, quite often, we have a problem where the component interfaces are incompatible with each other. Similarly with using public or any libraries, which we cannot modify ourselves, it is quite rare that someone else's views will be exactly the same as ours in our current settings. This is where adapters help. Their purpose is to help incompatible interfaces work together without modifying their source code.</p>
<p>We will be showing how adapters work using a class diagram and an example in the next few subsections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>For the adapter class diagram, let's imagine that we want to switch to using a new logging library in our application. The library we are trying to use has a log method that takes the message and the severity of the log. However, throughout our whole application, we expect to have the <kbd>info</kbd>, <kbd>debug</kbd>, <kbd>warning</kbd>, and <kbd>error</kbd> methods that only take the message and automatically set the right severity. Of course, we cannot edit the original library code, so we have to use the adapter pattern. The following figure shows the class diagram that represents the adapter design pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2c53c864-1ecb-4912-b6da-524f164b035d.png" style="width:27.00em;height:23.50em;" width="531" height="461"/></div>
<p>In the preceding diagram, we can see our adapter (<strong>AppLogger</strong>) extend and also use an instance of <strong>Logger</strong> as a field. While implementing the methods, we then simply call the log method with different parameters. This is the general adapter implementation and we will see the code for it in the next subsection. There are some cases where extending might not be possible and we will show how Scala can deal with this. Also, we will show some advanced usage of the language features to achieve the adapter pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>First of all, let's see the code for our <kbd>Logger</kbd> that we assume that we cannot change:</p>
<pre><span>class </span>Logger {<br/>  <span>def </span><span>log</span>(message: <span>String</span><span>, </span>severity: <span>String</span>): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"</span><span>$</span>{severity.toUpperCase}<span>: </span><span>$</span>message<span>"</span>)<br/>  }<br/>}</pre>
<p>We've tried to keep it as simple as possible in order to not distract the reader from the main purpose of this book. Next, we could either just write a class that extends <kbd>Logger</kbd> or we could provide an interface for abstraction. Let's take the second approach:</p>
<pre><span>trait </span>Log {<br/>  <span>def </span><span>info</span>(message: <span>String</span>)<br/>  <span>def </span><span>debug</span>(message: <span>String</span>)<br/>  <span>def </span><span>warning</span>(message: <span>String</span>)<br/>  <span>def </span><span>error</span>(message: <span>String</span>)<br/>}</pre>
<p>Finally, we can create our <kbd>AppLogger</kbd>:</p>
<pre><span>class </span>AppLogger <span>extends </span>Logger <span>with </span>Log {<br/>  <span>override def </span><span>info</span>(message: <span>String</span>): <span>Unit </span>= log(message<span>, </span><span>"info"</span>)<br/>  <br/>  <span>override def </span><span>warning</span>(message: <span>String</span>): <span>Unit </span>= log(message<span>, </span><span>"warning"</span>)<br/><br/>  <span>override def </span><span>error</span>(message: <span>String</span>): <span>Unit </span>= log(message<span>, </span><span>"error"</span>)<br/><br/>  <span>override def </span><span>debug</span>(message: <span>String</span>): <span>Unit </span>= log(message<span>, </span><span>"debug"</span>)<br/>}</pre>
<p>We can then use it in the following program:</p>
<pre><span>object </span>AdapterExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>logger = <span>new </span>AppLogger<br/>    logger.info(<span>"This is an info message."</span>)<br/>    logger.debug(<span>"Debug something here."</span>)<br/>    logger.error(<span>"Show an error message."</span>)<br/>    logger.warning(<span>"About to finish."</span>)<br/>    logger.info(<span>"Bye!"</span>)<br/>  }<br/>}</pre>
<p>As expected, our output will look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d24f61fd-75e9-4fdc-b394-ee70ee9630c6.png" style="width:56.50em;height:11.50em;" width="722" height="146"/></div>
<div class="packt_infobox">You can see that we haven't implemented the class diagram exactly as shown. We don't need the <kbd>Logger</kbd> instance as a field of our class, because our class is an instance of <kbd>Logger</kbd> already and we have access to its methods anyway. If we were to expand the behavior of the original <kbd>log</kbd> method, then we would need an instance of <kbd>Logger</kbd> as well.</div>
<p>This is how we implement and use the basic adapter design pattern. However, there are cases where the class we want to adapt is declared as <kbd>final</kbd> and we are unable to extend it. We will show how to handle this in the next subsection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The adapter design pattern with final classes</h1>
                </header>
            
            <article>
                
<p>If we declare our original logger as final, we will see that our code will not compile. There is a different way to use the adapter pattern in this case. Here is the code:</p>
<pre><span>class </span>FinalAppLogger <span>extends </span>Log {<br/>  <span>private val </span><span>logger </span>= <span>new </span>FinalLogger<br/><br/>  <span>override def </span><span>info</span>(message: <span>String</span>): <span>Unit </span>= <span>logger</span>.log(message<span>, </span><span>"info"</span>)<br/><br/>  <span>override def </span><span>warning</span>(message: <span>String</span>): <span>Unit </span>= <span>logger</span>.log(message<span>,<br/>   </span><span>"warning"</span>)<br/><br/>  <span>override def </span><span>error</span>(message: <span>String</span>): <span>Unit </span>= <span>logger</span>.log(message<span>, </span><span>"error"</span>)<br/><br/>  <span>override def </span><span>debug</span>(message: <span>String</span>): <span>Unit </span>= <span>logger</span>.log(message<span>, </span><span>"debug"</span>)<br/>}</pre>
<p>In this case, we simply wrap the final logger inside a class and then use it to call the <kbd>log</kbd> method with different parameters. The usage is absolutely the same as before. This could have a variation where the logger is passed as a constructor parameter as well. This is useful in cases where creating the logger requires some extra parameterization during creation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The adapter design pattern the Scala way</h1>
                </header>
            
            <article>
                
<p>As we have already mentioned multiple times, Scala is a rich programming language. Because of this fact, we can use implicit classes to achieve what the adapter pattern does. We will be using the same <kbd>FinalLogger</kbd> that we had in the previous example.</p>
<p>Implicit classes provide implicit conversions in places where possible. In order for the implicit conversions to work, we need to have the implicits imported and that's why they are often defined in objects or package objects. For this example, we will use a package object. Here is the code:</p>
<pre><span>package object </span>adapter {<br/><br/>  <span>implicit class </span>FinalAppLoggerImplicit(logger: FinalLogger) <span>extends </span>Log {<br/>    <br/>    <span>override def </span><span>info</span>(message: <span>String</span>): <span>Unit </span>= logger.log(message<span>, </span><span>"info"</span>)<br/><br/>    <span>override def </span><span>warning</span>(message: <span>String</span>): <span>Unit </span>= logger.log(message<span>,<br/>     </span><span>"warning"</span>)<br/><br/>    <span>override def </span><span>error</span>(message: <span>String</span>): <span>Unit </span>= logger.log(message<span>,<br/>     </span><span>"error"</span>)<br/><br/>    <span>override def </span><span>debug</span>(message: <span>String</span>): <span>Unit </span>= logger.log(message<span>,<br/>     </span><span>"debug"</span>)<br/>  }<br/>}</pre>
<p>This is a <kbd>package object</kbd> for the package where our logger examples are defined. It will automatically convert a <kbd>FinalLogger</kbd> instance to our implicit class. The following code snippet shows an example usage of our logger:</p>
<pre><span>object </span>AdapterImplicitExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>logger: Log = <span>new </span>FinalLogger<br/>    logger.info(<span>"This is an info message."</span>)<br/>    logger.debug(<span>"Debug something here."</span>)<br/>    logger.error(<span>"Show an error message."</span>)<br/>    logger.warning(<span>"About to finish."</span>)<br/>    logger.info(<span>"Bye!"</span>)<br/>  }<br/>}</pre>
<p>The final output will be exactly the same as our first example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The adapter design pattern is useful in cases <em>after</em> the code is designed and written. It allows us to make, otherwise incompatible, interfaces work together. It is also pretty straightforward to implement and use.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>There is a problem with the last implementation mentioned in the preceding section. It is the fact that we will have to always import our package or normal object when using the logger. Also, implicit classes and conversions sometimes make the code much harder to read and understand. Implicit classes have some limitations, as described here: <a href="https://docs.scala-lang.org/overviews/core/implicit-classes.html">http://docs.scala-lang.org/overviews/core/implicitclasses.html.</a></p>
<p>As we already mentioned, the adapter design pattern is useful when we have code that we cannot change. If we are able to fix our source code, then this might be a better decision because using adapters throughout our program will make it difficult to maintain and hard to understand.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The decorator design pattern</h1>
                </header>
            
            <article>
                
<p>There are cases where we might want to add some extra functionality to a class in an application. This could be done via inheritance; however, we might not want to do this or it may affect all the other classes in our application. This is where the decorator design pattern is useful.</p>
<div class="packt_infobox">The purpose of the decorator design pattern is to add functionality to objects without extending them and without affecting the behavior of other objects from the same class.</div>
<p>The decorator design pattern works by wrapping the decorated object, and it can be applied during runtime. Decorators are extremely useful in the cases where there could be multiple extensions of a class and they could be combined in various ways. Instead of writing all the possible combinations, decorators can be created and they can stack the modifications on top of each other. The next few subsections will show how and when to use decorators in real-world situations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>As we saw previously with the adapter design pattern, its aim is to change an interface to a different one. The decorator, on the other hand, helps us to enhance an interface by adding extra functionality to methods. For the class diagram, we will use an example with data streams. Imagine that we have a basic stream. We might want to be able to encrypt it, compress it, replace its characters, and so on. Here is the class diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2d9bc629-779f-4eae-bf5b-a574a4fd21e5.png" width="1524" height="638"/></div>
<p>In the preceding diagram, the <kbd>AdvancedInputReader</kbd> provides a basic implementation of the <kbd>InputReader</kbd>. It wraps a standard <kbd>BufferedReader</kbd>. Then, we have an abstract <kbd>InputReaderDecorator</kbd> class that extends the <kbd>InputReader</kbd> and contains an instance of it. By extending the base decorator, we provide the possibility to have streams that capitalize, compress, or <kbd>Base64</kbd> encode the input they get. We might want to have different streams in our application and they could be able to do one or more of the preceding operations in different orders. Our code will quickly become difficult to maintain and messy if we try and provide all possibilities, especially when the number of possible operations is even more. With decorators, it is nice and clean, as we will see in the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Now, let's have a look at the actual code that describes the decorator design pattern shown in the previous diagram. First of all, we define our <kbd>InputReader</kbd> interface using a trait:</p>
<pre><span>trait </span>InputReader {<br/>  <span>def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>]<br/>}</pre>
<p>Then, we provide the basic implementation of the interface in the <kbd>AdvancedInputReader</kbd> class:</p>
<pre><span>class </span>AdvancedInputReader(reader: BufferedReader) <span>extends </span>InputReader {<br/>  <span>override def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>] =<br/>    reader.lines().iterator().asScala.toStream<br/>}</pre>
<p>In order to apply the decorator design pattern, we have to create different decorators. We have a base decorator that looks as follows:</p>
<pre><span>abstract class </span>InputReaderDecorator(inputReader: InputReader) <span>extends </span>InputReader {<br/>  <span>override def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>] =<br/>    inputReader.readLines()<br/>}</pre>
<p>Then, we have different implementations of our decorator. First, we implement a decorator that turns all text into upper case:</p>
<pre><span>class </span>CapitalizedInputReader(inputReader: InputReader) <span>extends </span>InputReaderDecorator(inputReader) {<br/>  <span>override def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>] =<br/>    <span>super</span>.readLines().map(_.toUpperCase)<br/>}</pre>
<p>Next, we implement a decorator that uses <kbd>gzip</kbd> to compress each line of our input separately:</p>
<pre><span>class </span>CompressingInputReader(inputReader: InputReader) <span>extends </span>InputReaderDecorator(inputReader) <span>with </span>LazyLogging {<br/>  <span>override def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>] = <span>super</span>.readLines().map {<br/>    <span>case </span>line =&gt;<br/>      <span>val </span>text = line.getBytes(Charset.forName(<span>"UTF-8"</span>))<br/>      logger.info(<span>"Length before compression: {}"</span><span>, </span>text.length.toString)<br/>      <span>val </span>output = <span>new </span>ByteArrayOutputStream()<br/>      <span>val </span>compressor = <span>new </span>GZIPOutputStream(output)<br/>      <span>try </span>{<br/>        compressor.write(text<span>, </span><span>0</span><span>, </span>text.length)<br/>        <span>val </span>outputByteArray = output.toByteArray<br/>        logger.info(<span>"Length after compression: {}"</span><span>,<br/>         </span>outputByteArray.length.toString)<br/>        <span>new </span><span>String</span>(outputByteArray<span>, </span>Charset.forName(<span>"UTF-8"</span>))<br/>      } <span>finally </span>{<br/>        compressor.close()<br/>        output.close()<br/>      }<br/>  }<br/>}</pre>
<p>Finally, a decorator that encodes each line to <kbd>Base64</kbd>:</p>
<pre><span>class </span>Base64EncoderInputReader(inputReader: InputReader) <span>extends </span>InputReaderDecorator(inputReader) {<br/>  <span>override def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>] = <span>super</span>.readLines().map {<br/>    <span>case </span>line =&gt; Base64.getEncoder.encodeToString(line.getBytes(Charset.forName(<span>"UTF-8"</span>)))<br/>  }<br/>}</pre>
<div class="packt_infobox">We have demonstrated the decorator design pattern using an intermediate abstract class that all decorators extend. We could have achieved this design pattern without the intermediate class and by just directly extending and wrapping <kbd>InputReader</kbd>. This implementation, however, adds a bit more structure to our code.</div>
<p>Now, we can use these decorators in our application to add extra functionality to our input stream as needed. The usage is straightforward. Here is an example:</p>
<pre><span>object </span>DecoratorExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>stream = <span>new </span>BufferedReader(<br/>      <span>new </span>InputStreamReader(<br/>        <span>new </span>BufferedInputStream(<span>this</span>.getClass.getResourceAsStream(<span>"data.txt"</span>))<br/>      )<br/>    )<br/>    <span>try </span>{<br/>      <span>val </span>reader = <span>new </span>CapitalizedInputReader(<span>new </span>AdvancedInputReader(stream))<br/>      reader.readLines().foreach(<span>println</span>)<br/>    } <span>finally </span>{<br/>      stream.close()<br/>    }<br/>  }<br/>}</pre>
<p>In the preceding example, we used the text file part of our classpath with the following contents:</p>
<pre>this is a data file<br/>which contains lines<br/>and those lines will be<br/>manipulated by our stream reader.</pre>
<p>As expected, the order in which we apply decorators will define the order in which their enhancements will be applied. The output of the preceding example will be the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/e5385309-e4b2-4a19-b217-d37d2fe3ee06.png" width="723" height="127"/></div>
<p>Let's see another example, but this time we will apply all the decorators we have:</p>
<pre><span>object </span>DecoratorExampleBig {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>stream = <span>new </span>BufferedReader(<br/>      <span>new </span>InputStreamReader(<br/>        <span>new </span>BufferedInputStream(<span>this</span>.getClass.getResourceAsStream(<span>"data.txt"</span>))<br/>      )<br/>    )<br/>    <span>try </span>{<br/>      <span>val </span>reader = <span>new </span>CompressingInputReader(<br/>        <span>new </span>Base64EncoderInputReader(<br/>          <span>new </span>CapitalizedInputReader(<br/>            <span>new </span>AdvancedInputReader(stream)<br/>          )<br/>        )<br/>      )<br/>      reader.readLines().foreach(<span>println</span>)<br/>    } <span>finally </span>{<br/>      stream.close()<br/>    }<br/>  }<br/>}</pre>
<p>This example will read the text, capitalize it, <kbd>Base64</kbd> encode it, and finally compress it with <kbd>gzip</kbd>. The following screenshot shows the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/deaa0b3e-110f-42d7-90cc-1ce7f0d09fa6.png" width="722" height="416"/></div>
<p>As you can see from the preceding screenshot, in the compressing decorator code, we are logging the size of the lines in bytes. The output is gzipped and this is the reason for the text showing up as unreadable characters. You can experiment and change the order of the application of the decorators or add new ones in order to see how things can differ.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The decorator design pattern the Scala way</h1>
                </header>
            
            <article>
                
<p>As with the other design patterns, this one has an implementation that takes advantage of the richness of Scala and uses some of the concepts we looked at throughout the initial chapters of this book. The decorator design pattern in Scala is also called <strong>stackable traits</strong>. Let's see what it looks like and how to use it. The <kbd>InputReader</kbd> and <kbd>AdvancedInputReader</kbd> code will remain exactly as shown in the previous section. We are actually reusing it in both examples.</p>
<p>Next, instead of defining an <kbd>abstract</kbd> decorator class, we will just define the different reader modifications in new traits as follows:</p>
<pre><span>trait </span>CapitalizedInputReaderTrait <span>extends </span>InputReader {<br/>  <span>abstract override def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>] =<br/>    <span>super</span>.readLines().map(_.toUpperCase)<br/>}</pre>
<p>Then, we define the compressing input reader:</p>
<pre><span>trait </span>CompressingInputReaderTrait <span>extends </span>InputReader <span>with </span>LazyLogging {<br/>  <span>abstract override def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>] =<br/>    <span>super</span>.readLines().map {<br/>      <span>case </span>line =&gt;<br/>        <span>val </span>text = line.getBytes(Charset.forName(<span>"UTF-8"</span>))<br/>        logger.info(<span>"Length before compression: {}"</span><span>, </span>text.length.toString)<br/>        <span>val </span>output = <span>new </span>ByteArrayOutputStream()<br/>        <span>val </span>compressor = <span>new </span>GZIPOutputStream(output)<br/>        <span>try </span>{<br/>          compressor.write(text<span>, </span><span>0</span><span>, </span>text.length)<br/>          <span>val </span>outputByteArray = output.toByteArray<br/>          logger.info(<span>"Length after compression: {}"</span><span>,<br/>           </span>outputByteArray.length.toString)<br/>          <span>new </span><span>String</span>(outputByteArray<span>, </span>Charset.forName(<span>"UTF-8"</span>))<br/>        } <span>finally </span>{<br/>          compressor.close()<br/>          output.close()<br/>        }<br/>    }<br/>}</pre>
<p>Finally, the <kbd>Base64</kbd> encoder reader is as follows:</p>
<pre><span>trait </span>Base64EncoderInputReaderTrait <span>extends </span>InputReader {<br/>  <span>abstract override def </span><span>readLines</span>(): <span>Stream</span>[<span>String</span>] =<br/>    <span>super</span>.readLines().map {<br/>      <span>case </span>line =&gt;<br/>        Base64.getEncoder.encodeToString(line.getBytes(Charset.forName(<span>"UTF-8"</span>)))<br/>    }<br/>}</pre>
<p>As you can see, the implementation here is not much different. Here, we used traits instead of classes, extended the base <kbd>InputReader</kbd> trait, and used <kbd>abstract override</kbd>.</p>
<div class="packt_infobox">Abstract override allows us to call <kbd>super</kbd> for a method in a trait that is declared abstract. This is permissible for traits as long as the trait is mixed in after another trait or a class that implements the preceding method. The abstract override tells the compiler that we are doing this on purpose and it will not fail our compilation—it will check later, when we use the trait, whether the requirements for using it are satisfied.</div>
<p>Previously, we presented two examples. We will now show you what they look like with stackable traits. The first one that only capitalizes will look as follows:</p>
<pre><span>object </span>StackableTraitsExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>stream = <span>new </span>BufferedReader(<br/>      <span>new </span>InputStreamReader(<br/>        <span>new </span>BufferedInputStream(<span>this</span>.getClass.getResourceAsStream(<span>"data.txt"</span>))<br/>      )<br/>    )<br/>    <span>try </span>{<br/>      <span>val </span>reader = <span>new </span>AdvancedInputReader(stream) <span>with </span>CapitalizedInputReaderTrait<br/>      reader.readLines().foreach(<span>println</span>)<br/>    } <span>finally </span>{<br/>      stream.close()<br/>    }<br/>  }<br/>}</pre>
<p>The second example that capitalizes, <kbd>Base64</kbd> encodes, and compresses the stream will look as follows:</p>
<pre><span>object </span>StackableTraitsBigExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>stream = <span>new </span>BufferedReader(<br/>      <span>new </span>InputStreamReader(<br/>        <span>new </span>BufferedInputStream(<span>this</span>.getClass.getResourceAsStream(<span>"data.txt"</span>))<br/>      )<br/>    )<br/>    <span>try </span>{<br/>      <span>val </span>reader = <span>new </span>AdvancedInputReader(stream) <span>with </span>CapitalizedInputReaderTrait <br/>        <span>with </span>Base64EncoderInputReaderTrait <br/>        <span>with </span>CompressingInputReaderTrait<br/>      reader.readLines().foreach(<span>println</span>)<br/>    } <span>finally </span>{<br/>      stream.close()<br/>    }<br/>  }<br/>}</pre>
<p>The output of both the examples will be exactly the same as in the original examples. Here, however, we are using mixin composition and things look somewhat cleaner. We also have one class less, as we don't need the abstract decorator class. Understanding how modifications are applied is also easy—we just follow the order in which the stackable traits are mixed in.</p>
<div class="packt_tip"><span class="packt_screen">Stackable traits follow the rules of linearization</span><strong><br/>
<br/></strong> The fact that in our current example the modifications are applied from left to right is deceiving. The reason this happens is because we push calls on the stack until we reach the basic implementation of <kbd>readLines</kbd> and then apply modifications in a reverse order. We will see more in-depth examples of stackable traits that will showcase all of their specifics in the coming chapters of this book.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>Decorators add a lot of flexibility to our applications. They don't change the original classes, hence they don't introduce errors in the older code and can save on a lot of code writing and maintenance. Also, they could prevent us from forgetting or not foreseeing some use cases with the classes we create.</p>
<p>In the previous examples, we showed some static behavior modifications. However, it is also possible to dynamically decorate instances at runtime.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>We have covered the positive aspects of using decorators; however, we should point out that overusing decorators could cause issues as well. We might end up with a high number of small classes and they could make our libraries much harder to use and more demanding in terms of requiring more domain knowledge. They also complicate the instantiation process, which would require other (creational) design patterns, for example, factories or builders.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The bridge design pattern</h1>
                </header>
            
            <article>
                
<p>Some applications can have multiple different implementations of a specific functionality. The implementations could be in the form of different algorithms or something to do with multiple platforms. The implementations tend to vary often and they could also have new implementations throughout the life cycle of a program. Moreover, the implementations could be used in different ways for different abstractions. In cases like these, it is good to decouple things in our code, or else we are in danger of a class explosion.</p>
<div class="packt_infobox">The purpose of the bridge design pattern is to decouple an abstraction from its implementation so that the two can vary independently.</div>
<p>The bridge design pattern is quite useful in the cases where the abstractions or the implementations could vary often and independently. If we directly implement an abstraction, variations to the abstraction or the implementations would always affect all other classes in the hierarchy. This makes it hard to extend, modify, and reuse classes independently.</p>
<p>The bridge design pattern eliminates a problem by directly implementing an abstraction, thus making the abstractions and implementations reusable and easier to change.</p>
<p>The bridge design pattern is very similar to the adapter design pattern. The difference between them is that in the former, we apply it when we design our application, and the latter is used for legacy or third-party code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>For the class diagram and the code example, let's imagine that we are writing a library that hashes passwords. In practice, storing passwords in plain text is something that should be avoided. This is what our library will help our users to do. There are many different hashing algorithms that can be used. Some are <strong>SHA-1</strong>, <strong>MD5</strong>, and <strong>SHA-256</strong>. We want to be able to support at least these and have the possibility to add new ones easily. There are different hashing strategies—you can hash multiple times, combine different hashes, add salt to the passwords, and so on. These strategies make our passwords harder to guess using rainbow tables, for example. For this example, we will show hashing with salt and simple hashing with any of the algorithms we have.</p>
<p>Here is our class diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9f53c6b0-bebc-4b1a-995a-5aab1e36e9be.png" width="1594" height="602"/></div>
<p>As you can see from the preceding diagram, we separated the implementation (<strong>Hasher</strong> and its implementations) from the abstraction (<strong>PasswordConverter</strong>). This allows us to easily add a new hashing implementation and then instantly use it by just providing an instance of it when creating a <strong>PasswordConverter</strong>. If we hadn't used the preceding builder pattern, we would probably have to create a password converter for each hashing algorithm separately—something that would make our code explode in size or become tedious to use.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Now, let's have a look at the previous class diagram from the point of view of Scala code. First, we will focus on the implementation side with the <kbd>Hasher</kbd> trait:</p>
<pre><span>trait </span>Hasher {<br/>  <span>def </span><span>hash</span>(data: <span>String</span>): <span>String<br/></span><span><br/></span><span>  </span><span>protected def </span><span>getDigest</span>(algorithm: <span>String</span><span>, </span>data: <span>String</span>) = {<br/>    <span>val </span>crypt = MessageDigest.getInstance(algorithm)<br/>    crypt.reset()<br/>    crypt.update(data.getBytes(<span>"UTF-8"</span>))<br/>    crypt<br/>  }<br/>}</pre>
<p>Then, we have three classes that implement it—<kbd>Md5Hasher</kbd>, <kbd>Sha1Hasher</kbd>, and <kbd>Sha256Hasher</kbd>. Their code is pretty simple and similar, but yields different results:</p>
<pre><span>class </span>Sha1Hasher <span>extends </span>Hasher {<br/>  <span>override def </span><span>hash</span>(data: <span>String</span>): <span>String </span>= <br/>    <span>new </span><span>String</span>(Hex.encodeHex(getDigest(<span>"SHA-1"</span><span>, </span>data).digest()))<br/>}<br/><br/><span>class </span>Sha256Hasher <span>extends </span>Hasher {<br/>  <span>override def </span><span>hash</span>(data: <span>String</span>): <span>String </span>= <br/>    <span>new </span><span>String</span>(Hex.encodeHex(getDigest(<span>"SHA-256"</span><span>, </span>data).digest()))<br/>}<br/><br/><span>class </span>Md5Hasher <span>extends </span>Hasher {<br/>  <span>override def </span><span>hash</span>(data: <span>String</span>): <span>String </span>= <br/>    <span>new </span><span>String</span>(Hex.encodeHex(getDigest(<span>"MD5"</span><span>, </span>data).digest()))<br/>}</pre>
<p>Now, let's take a look at the abstraction side of things. This is what our clients will use. The following listing shows the <kbd>PasswordConverter</kbd>:</p>
<pre><span>abstract class </span>PasswordConverter(hasher: Hasher) {<br/>  <span>def </span><span>convert</span>(password: <span>String</span>): <span>String<br/></span>}</pre>
<p>We have chosen to provide two different implementations here—<kbd>SimplePasswordConverter</kbd> and <kbd>SaltedPasswordConverter</kbd>. The code for them is as follows:</p>
<pre><span>class </span>SimplePasswordConverter(hasher: Hasher) <span>extends </span>PasswordConverter(hasher) {<br/>  <span>override def </span><span>convert</span>(password: <span>String</span>): <span>String </span>=<br/>    hasher.hash(password)<br/>}<br/><br/><span>class </span>SaltedPasswordConverter(salt: <span>String</span><span>, </span>hasher: Hasher) <span>extends </span>PasswordConverter(hasher) {<br/>  <span>override def </span><span>convert</span>(password: <span>String</span>): <span>String </span>=<br/>    hasher.hash(<span>s"</span><span>$</span>{salt}<span>:</span><span>$</span>{password}<span>"</span>)<br/>}</pre>
<p>Now, if a client wanted to use our library, they could write a program similar to the following one:</p>
<pre><span>object </span>BridgeExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>p1 = <span>new </span>SimplePasswordConverter(<span>new </span>Sha256Hasher)<br/>    <span>val </span>p2 = <span>new </span>SimplePasswordConverter(<span>new </span>Md5Hasher)<br/>    <span>val </span>p3 = <span>new </span>SaltedPasswordConverter(<span>"8jsdf32T^$%"</span><span>, </span><span>new </span>Sha1Hasher)<br/>    <span>val </span>p4 = <span>new </span>SaltedPasswordConverter(<span>"8jsdf32T^$%"</span><span>, </span><span>new </span>Sha256Hasher)<br/>    System.<span>out</span>.println(<span>s"'password' in SHA-256 is:<br/>     </span><span>$</span>{p1.convert (<span>"password"</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"'1234567890' in MD5 is:<br/>     </span><span>$</span>{p2.convert (<span>"1234567890"</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"'password' in salted SHA-1 is:<br/>     </span><span>$</span>{p3.convert (<span>"password"</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"'password' in salted SHA-256 is:<br/>     </span><span>$</span>{p4.convert (<span>"password"</span>)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output of this example application will look like the one in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1cb79fc0-190c-4630-8fae-63445a675fde.png" width="721" height="164"/></div>
<p>Our library now allows us to easily add new strategies or new hashing algorithms and use them instantly. We don't have to change any of the existing classes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The bridge design pattern the Scala way</h1>
                </header>
            
            <article>
                
<p>The bridge design pattern is another example of those that can be achieved with the powerful features of the Scala programming language. Here, we will be using self types. The initial <kbd>Hasher</kbd> trait remains unchanged. Then, the actual implementations become traits instead of classes as follows:</p>
<pre><span>trait </span>Sha1Hasher <span>extends </span>Hasher {<br/>  <span>override def </span><span>hash</span>(data: <span>String</span>): <span>String </span>= <br/>    <span>new </span><span>String</span>(Hex.encodeHex(getDigest(<span>"SHA-1"</span><span>, </span>data).digest()))<br/>}<br/><br/><span>trait </span>Sha256Hasher <span>extends </span>Hasher {<br/>  <span>override def </span><span>hash</span>(data: <span>String</span>): <span>String </span>= <br/>    <span>new </span><span>String</span>(Hex.encodeHex(getDigest(<span>"SHA-256"</span><span>, </span>data).digest()))<br/>}<br/><br/><span>trait </span>Md5Hasher <span>extends </span>Hasher {<br/>  <span>override def </span><span>hash</span>(data: <span>String</span>): <span>String </span>= <br/>    <span>new </span><span>String</span>(Hex.encodeHex(getDigest(<span>"MD5"</span><span>, </span>data).digest()))<br/>}</pre>
<p>Having traits would allow us to mix them in when needed later.</p>
<p>We've changed some names for this version of our example just to avoid confusion. The <kbd>PasswordConverter</kbd> (<kbd>PasswordConverterBase</kbd> in this case) abstraction now looks as follows:</p>
<pre><span>abstract class </span>PasswordConverterBase {<br/>  self: Hasher =&gt;<br/>  <span>def </span><span>convert</span>(password: <span>String</span>): <span>String<br/></span>}</pre>
<p>This tells the compiler that when we use <kbd>PasswordConverterBase</kbd>, we also need to have a <kbd>Hasher</kbd> mixed in. Then, we change the converter implementation to the following:</p>
<pre><span>class </span>SimplePasswordConverterScala <span>extends </span>PasswordConverterBase {<br/>  self: Hasher =&gt;<br/>  <span>override def </span><span>convert</span>(password: <span>String</span>): <span>String </span>= hash(password)<br/>}<br/><br/><span>class </span>SaltedPasswordConverterScala(salt: <span>String</span>) <span>extends </span>PasswordConverterBase {<br/>  self: Hasher =&gt;<br/>  <span>override def </span><span>convert</span>(password: <span>String</span>): <span>String </span>=<br/>    hash(<span>s"</span><span>$</span>{salt}<span>:</span><span>$</span>{password}<span>"</span>)<br/>}</pre>
<p>Finally, we can use our new implementations, as follows:</p>
<pre><span>object </span>ScalaBridgeExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>p1 = <span>new </span>SimplePasswordConverterScala <span>with </span>Sha256Hasher<br/>    <span>val </span>p2 = <span>new </span>SimplePasswordConverterScala <span>with </span>Md5Hasher<br/>    <span>val </span>p3 = <span>new </span>SaltedPasswordConverterScala(<span>"8jsdf32T^$%"</span>) <span>with<br/>     </span>Sha1Hasher<br/>    <span>val </span>p4 = <span>new </span>SaltedPasswordConverterScala(<span>"8jsdf32T^$%"</span>) <span>with<br/>     </span>Sha256Hasher<br/>    System.<span>out</span>.println(<span>s"'password' in SHA-256 is:<br/>     </span><span>$</span>{p1.convert(<span>"password"</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"'1234567890' in MD5 is:<br/>     </span><span>$</span>{p2.convert(<span>"1234567890"</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"'password' in salted SHA-1 is:<br/>     </span><span>$</span>{p3.convert(<span>"password"</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"'password' in salted SHA-256 is:<br/>     </span><span>$</span>{p4.convert(<span>"password"</span>)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output of this program will be identical to the original one. However, when we use our abstractions, we can mix in the hash algorithms we want to use. The benefits will become more obvious in the cases where we might have more implementations that we might want to combine together with hashing. Using mixins also looks more natural and is easier to understand.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>As we already said, the bridge design pattern is similar to the adapter. Here, however, we apply it when we design our applications. One obvious benefit of using it is that we don't end up with an exponential number of classes in our application, which could make the use and maintenance of the pattern pretty complicated. The separation of hierarchies allows us to independently extend them without affecting the other one.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>The bridge design pattern requires us to write some boilerplate. It could complicate the use of the library in terms of which implementation is exactly picked, and it might be a good idea to use the bridge design pattern together with some creational design patterns. All in all, it doesn't have any major drawbacks, but the developer should be wise whether to use it or not depending on the current circumstances.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The composite design pattern</h1>
                </header>
            
            <article>
                
<p>The composite design pattern is used to describe groups of objects that should be treated the same way as a single one.</p>
<div class="packt_infobox">The purpose of the composite design pattern is to compose objects into tree structures to represent whole-part hierarchies.</div>
<p>The composite design pattern is useful for removing code duplication and avoiding errors in cases where groups of objects are generally treated the same way. A popular example could be a filesystem in which we have directories, which can have other directories or files. Generally, the interface to interact with directories and files is the same, so they are good candidates for a composite design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, filesystems are a good candidate for the composite design pattern. Essentially, they are just tree structures, so for our example, we will show you how to build a tree using the composite design pattern.</p>
<p>Consider the following class diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/81048397-08ee-4e1c-a5cc-abb7b7b4f0dd.png" style="width:35.92em;height:16.58em;" width="921" height="425"/></div>
<p>As you can see from the preceding diagram, <strong>Tree</strong> is our composite object. It contains children, which could be either other <strong>Tree</strong> objects with more children nested recursively or just <strong>Leaf</strong> nodes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Let's take a look at the code representation for the previous diagram. First of all, we have to define the <kbd>Node</kbd> interface through a trait:</p>
<pre><span>trait </span>Node {<br/>  <span>def </span><span>print</span>(prefix: <span>String</span>): <span>Unit<br/></span>}</pre>
<div class="packt_infobox">The <kbd>prefix</kbd> parameter in the <kbd>print</kbd> method is used to aid visualization when printing the tree to a console.</div>
<p>After we have the interface, we can now define the implementation:</p>
<pre><span>class </span>Leaf(data: <span>String</span>) <span>extends </span>Node {<br/>  <span>override def </span><span>print</span>(prefix: <span>String</span>): <span>Unit </span>=<br/>    System.<span>out</span>.println(<span>s"</span><span>$</span>{prefix}<span>$</span>{data}<span>"</span>)<br/>}<br/><br/><span>class </span>Tree <span>extends </span>Node {<br/>  <span>private val </span><span>children </span>= ListBuffer.empty[Node]<br/><br/>  <span>override def </span><span>print</span>(prefix: <span>String</span>): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"</span><span>$</span>{prefix}<span>("</span>)<br/>    <span>children</span>.foreach(_.print(<span>s"</span><span>$</span>{prefix}<span>$</span>{prefix}<span>"</span>))<br/>    System.<span>out</span>.println(<span>s"</span><span>$</span>{prefix}<span>)"</span>)<br/>  }<br/><br/>  <span>def </span><span>add</span>(child: Node): <span>Unit </span>= {<br/>    <span>children </span>+= child<br/>  }<br/>  <br/>  <span>def </span><span>remove</span>(): <span>Unit </span>= {<br/>    <span>if </span>(<span>children</span>.nonEmpty) {<br/>      <span>children</span>.remove(<span>0</span>)<br/>    }<br/>  }<br/>}</pre>
<p>After this, using our code becomes pretty straightforward. While printing, we don't need to care whether we do it on a leaf or a tree. Our code will automatically take care of this:</p>
<pre><span>object </span>CompositeExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>tree = <span>new </span>Tree<br/>    tree.add(<span>new </span>Leaf(<span>"leaf 1"</span>))<br/>    <span>val </span>subtree1 = <span>new </span>Tree<br/>    subtree1.add(<span>new </span>Leaf(<span>"leaf 2"</span>))<br/>    <span>val </span>subtree2 = <span>new </span>Tree<br/>    subtree2.add(<span>new </span>Leaf(<span>"leaf 3"</span>))<br/>    subtree2.add(<span>new </span>Leaf(<span>"leaf 4"</span>))<br/>    subtree1.add(subtree2)<br/>    tree.add(subtree1)<br/>    <span>val </span>subtree3 = <span>new </span>Tree<br/>    <span>val </span>subtree4 = <span>new </span>Tree<br/>    subtree4.add(<span>new </span>Leaf(<span>"leaf 5"</span>))<br/>    subtree4.add(<span>new </span>Leaf(<span>"leaf 6"</span>))<br/>    subtree3.add(subtree4)<br/>    tree.add(subtree3)<br/>    tree.print(<span>"-"</span>)<br/>  }<br/>}</pre>
<p>What this code actually does is depth-first traversal of our data structure. The actual example data structure that we have looks as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2afbd256-5117-4f2e-a920-adc3218c5639.png" style="width:26.08em;height:20.83em;" width="709" height="567"/></div>
<p>The following screenshot shows the output of our program:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6171338c-ad8d-4fec-b25d-442f4f1cddd4.png" style="width:46.25em;height:22.08em;" width="722" height="344"/></div>
<p>As you can see, using composite, we can compose hierarchies of objects that have similar uses.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The composite design pattern is useful for reducing code duplication and simplification when we create hierarchies. The simplification part comes from the fact that clients do not need to know which type of objects they are dealing with. Adding new types of nodes is also easy and won't make us change anything else.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>The composite design pattern pattern does not have any major drawbacks. It really is applicable in specific cases. One thing developers should be careful about is when they deal with massive hierarchies. The reason is that in such cases, we could have really deeply recursive nested items and this could cause stack overflow issues.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The facade design pattern</h1>
                </header>
            
            <article>
                
<p>Whenever we are building libraries or big systems, we quite often depend on other libraries and functionality. Implementing methods sometimes requires the use of multiple classes at the same time. This requires knowledge. Whenever we build a library for someone, we usually try and make it simpler for the users by assuming they do not have (and do not need) as extensive knowledge as we do. Additionally, developers make sure that components are easy to use throughout their application. This is where the facade design pattern can become useful.</p>
<div class="packt_infobox">The purpose of the facade design pattern is to wrap a complex system with a simpler interface in order to hide the usage complexities and ease the client interaction.</div>
<p>We already looked at other design patterns based on wrapping. While the adapter design pattern transforms one interface to another and the decorator adds extra functionality, the facade makes things simpler.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>For the class diagram, let's imagine the following setting—we want our users to be able to download some data from a server and get it de-serialized in the form of objects. The server returns our data in encoded form, so we should decode it first, then parse it, and finally return the right objects. This involves many operations and makes things complicated. That's why we use a facade design pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d7608af3-84fd-4db5-ad28-4e9644fa97c5.png" style="width:58.67em;height:19.08em;" width="1417" height="461"/></div>
<p>When clients use the preceding application, they will just have to interact with the <strong>DataReader</strong>. Internally, it will take care of downloading, decoding, and deserializing the data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>The preceding diagram shows the <kbd>DataDownloader</kbd>, <kbd>DataDecoder</kbd>, and <kbd>DataDeserializer</kbd> as composed objects inside <kbd>DataReader</kbd>. This is straightforward and clear to achieve—they can be either created with their default constructors, or they can be passed as parameters. For the code representation of our example, however, we have chosen to use traits instead of classes and mix them in with the <kbd>DataReader</kbd> class.</p>
<p>Let's first take a look at the <kbd>DataDownloader</kbd>, <kbd>DataDecoder</kbd>, and <kbd>DataDeserializer</kbd> traits:</p>
<pre><span>trait </span>DataDownloader <span>extends </span>LazyLogging {<br/>  <span>def </span><span>download</span>(url: <span>String</span>): Array[<span>Byte</span>] = {<br/>    logger.info(<span>"Downloading from: {}"</span><span>, </span>url)<br/>    Thread.<span>sleep</span>(<span>5000</span>)<br/>    <span>// {<br/></span><span>    // "name": "Ivan",<br/></span><span>    // "age": 26<br/></span><span>    // }<br/></span><span>    // the string below is the Base64 encoded Json above.<br/></span><span>    </span><span>"ew0KICAgICJuYW1lIjogIkl2YW4iLA0KICAgICJhZ2UiOiAyNg0KfQ=="</span>.getBytes<br/>  }<br/>}</pre>
<p>The <kbd>DataDecoder</kbd> trait is as follows:</p>
<pre><span>trait </span>DataDecoder {<br/>  <span>def </span><span>decode</span>(data: Array[<span>Byte</span>]): <span>String </span>= <span>new</span><span> </span>String(Base64.getDecoder.decode(data)<span>, </span><span>"UTF-8"</span>)<br/>}</pre>
<p>The following code snippet is of the <kbd>DataDeserializer</kbd> trait:</p>
<pre><span>trait </span>DataDeserializer {<br/>  <span>implicit val </span><span>formats </span>= DefaultFormats<br/><br/>  <span>def </span><span>parse</span>[<span>T</span>](data: <span>String</span>)(<span>implicit </span>m: <span>Manifest</span>[<span>T</span>]): <span>T </span>=<br/>    JsonMethods.parse(StringInput(data)).extract[<span>T</span>]<br/>}</pre>
<p>The preceding implementations are pretty straightforward and they are separated from each other, since they deal with different tasks. Anyone can use them; however, it requires some knowledge and makes things more complicated. That's why we have a facade class called <kbd>DataReader</kbd>:</p>
<pre><span>class </span>DataReader <span>extends </span>DataDownloader <span>with </span>DataDecoder <span>with </span>DataDeserializer {<br/>  <span>def </span><span>readPerson</span>(url: <span>String</span>): Person = {<br/>    <span>val </span>data = download(url)<br/>    <span>val </span>json = decode(data)<br/>    parse[Person](json)<br/>  }<br/>}</pre>
<p>This example clearly shows that instead of using three different interfaces, we now have a simple method to call. All complexity is hidden inside this method. The following listing shows a sample usage of our class:</p>
<pre><span>object </span>FacadeExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>reader = <span>new </span>DataReader<br/>    System.<span>out</span>.println(<span>s"We just read the following person:<br/>     </span><span>$</span>{reader.readPerson(<span>"https://www.ivan-nikolov.com/"</span>)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The preceding code makes use of our libraries, which are hidden from the client, really easy. Here is a sample output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/bfd4cb1d-9cf4-4428-9444-28bef266e265.png" width="726" height="102"/></div>
<p>Of course, in the preceding example, we could have used classes inside <kbd>DataReader</kbd> instead of mixing traits in. This really depends on the requirements and should yield the same results anyway.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The facade design pattern is useful when we want to hide the implementation details of many libraries, make an interface much easier to use, and interact with complex systems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>A common mistake some people could make is try and put everything into a facade. This is something that usually doesn't help and the developers remain with a complex system, if not more, as before. Moreover, facade could prove to be restrictive for those users who have enough domain knowledge to use the original functionality. This is especially true if facade is the only way to interact with the underlying system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The flyweight design pattern</h1>
                </header>
            
            <article>
                
<p>Usually when software is written, developers try to make it fast and efficient. Normally, this means less processing cycles and a smaller memory footprint. There are different ways to achieve these two aspects. Most of the time, a good algorithm will take care of the first one. The amount of used memory can have many causes and solutions, and the flyweight design pattern is there to help and reduce the memory used.</p>
<div class="packt_infobox">The purpose of the flyweight design pattern is to minimize the memory usage with the help of an object that shares as much data as possible with other similar objects.</div>
<p>There are many cases where many objects share the same information. A common example when talking about flyweight is word processing. Instead of representing each character with all the information about font, size, color, image, and so on, we could just store the positions for similar characters and have a reference to one object that contains the common information. This makes the usage of memory significantly smaller. Otherwise, such applications would become unusable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>For the class diagram, first let's imagine that we are trying to represent a drawing for a color blindness test similar to the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ade3b12d-4f5e-4f46-9bcb-d1e166734227.png" style="width:14.83em;height:14.92em;" width="1440" height="1440"/></div>
<p>As we can see, it is composed of circles of different sizes and colors. Potentially, this can be an infinitely big picture and it can have any number of circles. To make things simple, let's just set a limitation where we can only have five different circle colors—red, green, blue, yellow, and magenta. Here is what our class diagram will look like in order to represent an image like the preceding one using the flyweight design pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b92d4fb5-f5d3-4ed4-b06e-cd9b52ef4481.png" style="width:27.33em;height:21.42em;" width="815" height="638"/></div>
<p>The actual flyweight design pattern is implemented through the <strong>CircleFactory</strong>, <strong>Circle</strong>, and <strong>Client</strong> classes. The client requests the factory and it returns either a new instance of <strong>Circle</strong> or if one with the required parameters exists, it returns it from the cache. For this example, the shared data will be the <strong>Circle</strong> objects with their colors, and then each specific circle will have its own position and a radius. The <strong>Graphic</strong> will contain the actual circles with all of their information. Things will get much clearer with our code example, which the preceding diagram is based on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>It is time to see how the flyweight design pattern looks like when expressed in Scala code. We will be using the same example as shown previously. It is worth noting that in the code version, some classes have different names than in the diagram. The reasons for this are Scala naming conventions. We will explicitly point out where this happens while going through the code.</p>
<p>An interesting thing about the flyweight design pattern and our example is that it actually uses other design patterns and techniques that we already went through before. We will also point them out while looking at the code.</p>
<p>The first thing we've done is represent the colors. This has nothing to do with the actual flyweight design pattern, but we've decided to use ADTs:</p>
<pre><span>sealed abstract class </span>Color<br/><span>case object </span>Red <span>extends </span>Color<br/><span>case object </span>Green <span>extends </span>Color<br/><span>case object </span>Blue <span>extends </span>Color<br/><span>case object </span>Yellow <span>extends </span>Color<br/><span>case object </span>Magenta <span>extends </span>Color</pre>
<p>After we have the colors defined, we can implement our <kbd>Circle</kbd> class:</p>
<pre><span>class </span>Circle(color: Color) {<br/>  System.<span>out</span>.println(<span>s"Creating a circle with </span><span>$</span>color<span> color."</span>)<br/><br/>  <span>override def </span><span>toString</span>(): <span>String </span>= <span>s"Circle(</span><span>$</span>color<span>)"<br/></span>}</pre>
<p>The circles will be flyweight objects, so the model only has the data that will be shared with the other circle instances. Now that we have the model for the circles, we can create our <kbd>CircleFactory</kbd>. As the name suggests, it uses the factory design pattern. Here is the code for it:</p>
<pre><span><span class="pl-k">import</span> <span class="pl-smi">scala.collection.mutable.</span><span class="pl-smi">Map</span><br/><br/>object </span>Circle {<br/>  <span>val </span><span>cache </span>= <span>Map</span>.<span>empty</span>[Color<span>, </span>Circle]<br/><br/>  <span>def </span><span>apply</span>(color: Color): Circle = <span>cache</span>.getOrElseUpdate(color<span>,<br/>   </span><span>new </span>Circle(color))<br/><br/>  <span>def </span>circlesCreated(): Int = cache.size<br/>}</pre>
<p>We have a companion object that is used to implement the factory design pattern in Scala. This is why the name here is different than in the diagram shown previously. This representation allows us to either get an old instance of a circle or create a new one using the following syntax:</p>
<pre>Circle(Green)</pre>
<p>Now that we have our circle and factory, we can implement the <kbd>Graphic</kbd> class:</p>
<pre><span><span class="pl-k">import</span> <span class="pl-smi">scala.collection.mutable.</span><span class="pl-smi">ListBuffer</span><br/><br/>class </span>Graphic {<br/>  <span>val </span><span>items </span>= ListBuffer.empty[(<span>Int, Int, Double, </span>Circle)]<br/><br/>  <span>def </span><span>addCircle</span>(x: <span>Int, </span>y: <span>Int, </span>radius: <span>Double, </span>circle: Circle): <span>Unit </span>= {<br/>    <span>items </span>+= ((x<span>, </span>y<span>, </span>radius<span>, </span>circle))<br/>  }<br/><br/>  <span>def </span><span>draw</span>(): <span>Unit </span>= {<br/>    <span>items</span>.foreach {<br/>      <span>case </span>(x<span>, </span>y<span>, </span>radius<span>, </span>circle) =&gt;<br/>        System.<span>out</span>.println(<span>s"Drawing a circle at (</span><span>$</span>x<span>, </span><span>$</span>y<span>) with radius<br/>         </span><span>$</span>radius<span>: </span><span>$</span>circle<span>"</span>)<br/>    }<br/>  }<br/>}</pre>
<p>The <kbd>Graphic</kbd> class will actually hold our circles with all other data related to them. The <kbd>Client</kbd> in the previous diagram does not have a specific representation in our code—it will just be the code that uses the factory to obtain circles. Similarly, the <kbd>Graphic</kbd> object will retrieve the circle objects by the program and not through explicit access to a client. Here is how all this is implemented in our example:</p>
<pre><span>object </span>FlyweightExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>graphic = <span>new </span>Graphic<br/>    graphic.addCircle(<span>1</span><span>, </span><span>1</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Green))<br/>    graphic.addCircle(<span>1</span><span>, </span><span>2</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Red))<br/>    graphic.addCircle(<span>2</span><span>, </span><span>1</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Blue))<br/>    graphic.addCircle(<span>2</span><span>, </span><span>2</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Green))<br/>    graphic.addCircle(<span>2</span><span>, </span><span>3</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Yellow))<br/>    graphic.addCircle(<span>3</span><span>, </span><span>2</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Magenta))<br/>    graphic.addCircle(<span>3</span><span>, </span><span>3</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Blue))<br/>    graphic.addCircle(<span>4</span><span>, </span><span>3</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Blue))<br/>    graphic.addCircle(<span>3</span><span>, </span><span>4</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Yellow))<br/>    graphic.addCircle(<span>4</span><span>, </span><span>4</span><span>, </span><span>1.0</span><span>, </span><span>Circle</span>(Red))<br/>    graphic.draw()<br/>    System.<span>out</span>.println(<span>s"Total number of circle objects created:<br/>     </span><span>$</span>{Circle.<span>circlesCreated</span>()}<span>"</span>)<br/>  }<br/>}</pre>
<p>If we run this code, we will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/912b9415-dcae-4af1-a9f5-34abfbb765a4.png" style="width:49.00em;height:23.33em;" width="723" height="344"/></div>
<p>While defining the <kbd>Circle</kbd> class earlier, we added a print message to the construction. From the preceding figure, we can see that each circle was created with a specific color only once, even though we requested it more times to build our graphic. The last line shows that we have exactly five distinct circle objects, even though our graphic contains 10 different circles.</p>
<p>This is just an example to illustrate how flyweight works. In real life, the flyweight objects will share many more attributes, thus lowering the overall memory footprint of the entire application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>As we already mentioned before, the flyweight design pattern is useful when we are trying to lower the memory used by an application. Using shared objects, our application will require less constructions and destructions of objects, which could further improve performance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>Depending on the amount of shared data, sometimes the number of distinct shared objects could dramatically grow and not bring too much benefit. Moreover, it can complicate the factory and its usage. Multithreaded applications need extra care while working with factories. Last but not least, the developers need to be really careful while using shared objects, as any change in them could affect the entire application. Luckily, in Scala, this is less of a concern due to immutability.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The proxy design pattern</h1>
                </header>
            
            <article>
                
<p>In some applications, developers could face the need to provide access control to objects. This could be due to many reasons. Some of them include hiding implementation details, improving interaction with expensive resources, interfacing with remote resources, caching, providing lazy or eager initialization, and so on. The proxy design pattern helps to achieve these.</p>
<div class="packt_infobox">The purpose of the proxy design pattern is to provide an interface to something else that then gets served behind the scenes to the user.</div>
<p>The proxy design pattern is another example of a wrapper. It is pretty similar to the decorator design pattern, but feels more basic and limited. The reason for this is that the relationship between the proxy and the wrapped object is established during compile time and decorators could be applied at runtime. In the end, its purpose is different.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>For the class diagram, let's imagine that we have an application that visualizes text from files. It might need to visualize the text, or might not depending on user actions. These files could be enormous or could be somewhere in a remote location. Here is how the proxy design pattern could help us achieve this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7e670c45-10ea-4aab-959a-9996977aa397.png" style="width:42.17em;height:20.25em;" width="886" height="425"/></div>
<p>According to the preceding diagram, we could use the <strong>FileReaderProxy</strong> objects and only when someone needs to access the file contents, we will delegate the functionality to the <strong>FileReaderReal</strong>. This design is nice and convenient because we can actually use the <strong>FileReader</strong> object; however, we can keep our application efficient by not needing to load everything at the same time, but just once when needed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Now, let's have a closer look at the code that implements the preceding class diagram. The first thing we need to define is the interface (using a Scala trait):</p>
<pre><span>trait </span>FileReader {<br/>  <span>def </span><span>readFileContents</span>(): <span>String<br/></span>}</pre>
<p>We then create two classes that implement it—<kbd>FileReaderReal</kbd> and <kbd>FileReaderProxy</kbd>. First, let's see how the former implements the file read as it has nothing of real significance:</p>
<pre><span>class </span>FileReaderReal(filename: <span>String</span>) <span>extends </span>FileReader {<br/>  <span>val </span><span>contents </span>= {<br/>    <span>val </span>stream = <span>this</span>.getClass.getResourceAsStream(filename)<br/>    <span>val </span>reader = <span>new </span>BufferedReader(<br/>      <span>new </span>InputStreamReader(<br/>        stream<br/>      )<br/>    )<br/>    <span>try </span>{<br/>      reader.lines().iterator().asScala.mkString<br/>      (System.<span>getProperty</span>(<span>"line.separator"</span>))<br/>    } <span>finally </span>{<br/>      reader.close()<br/>      stream.close()<br/>    }<br/>  }<br/>  System.<span>out</span>.println(<span>s"Finished reading the actual file: </span><span>$</span>filename<span>"</span>)<br/><br/>  <span>override def </span><span>readFileContents</span>(): <span>String </span>= <span>contents<br/></span>}</pre>
<p>During the construction of the object, it will get the file, read it, and store it in the contents variable. Then, whenever <kbd>readFileContents</kbd> is called, the class will return whatever it has buffered. Now, let's take a look at the <kbd>FileReaderProxy</kbd> implementation:</p>
<pre><span>class </span>FileReaderProxy(filename: <span>String</span>) <span>extends </span>FileReader {<br/>  <span>private var </span><span>fileReader</span>: FileReaderReal = <span>null<br/></span><span><br/></span><span>  override def </span><span>readFileContents</span>(): <span>String </span>= {<br/>    <span>if </span>(<span>fileReader </span>== <span>null</span>) {<br/>      <span>fileReader </span>= <span>new </span>FileReaderReal(filename)<br/>    }<br/>    <span>fileReader</span>.readFileContents()<br/>  }<br/>}</pre>
<p>The implementation contains an instance of <kbd>FileReaderReal</kbd>, which is created the first time <kbd>readFileContents</kbd> is called. The actual file read is then delegated to the <kbd>FileReaderReal</kbd> class.</p>
<div class="packt_infobox">A more elegant implementation of the <kbd>FileReaderProxy</kbd> would use a <kbd>lazy val</kbd> instead of a mutable variable. In such a case, the <kbd>if</kbd> statement won't be needed anymore.</div>
<p>Now, let's see how our proxy can be used in an application:</p>
<pre><span>object </span>ProxyExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>fileMap = <span>Map</span>(<br/>      <span>"file1.txt" </span>-&gt; <span>new </span>FileReaderProxy(<span>"file1.txt"</span>)<span>,<br/></span><span>      </span><span>"file2.txt" </span>-&gt; <span>new </span>FileReaderProxy(<span>"file2.txt"</span>)<span>,<br/></span><span>      </span><span>"file3.txt" </span>-&gt; <span>new </span>FileReaderProxy(<span>"file3.txt"</span>)<span>,<br/></span><span>      </span><span>"file4.txt" </span>-&gt; <span>new </span>FileReaderReal(<span>"file1.txt"</span>)<br/>    )<br/>    System.<span>out</span>.println(<span>"Created the map. You should have seen<br/>     file1.txt read because it wasn't used in a proxy."</span>)<br/>    System.<span>out</span>.println(<span>s"Reading file1.txt from the proxy:<br/>     </span><span>$</span>{fileMap(<span>"file1.txt"</span>).readFileContents()}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Reading file3.txt from the proxy:<br/>     </span><span>$</span>{fileMap(<span>"file3.txt"</span>).readFileContents()}<span>"</span>)<br/>  }<br/>}</pre>
<p>It's worth noting that each file is actually a resource in the application and contains a line of text in the form of <kbd>I am file x</kbd>. After running the preceding example, we will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/13ba72fe-f774-47b8-9f45-725ad691d1a2.png" width="723" height="181"/></div>
<p>As you can see from the preceding screenshot , the real object is lazily created and so the actual file read is done on demand. This causes our application to skip reading <kbd>file2.txt</kbd> because we don't even request for it. Someone might come up with a different solution that serves the same purpose, but it will probably be a different design pattern or something similar to proxy.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The proxy design pattern is good when we want to delegate some expensive operations to other classes, do operations lazily, and thus make our applications more efficient.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>The proxy design pattern is pretty simple and really, there are no drawbacks that could be mentioned. As with every other design pattern, they should be used carefully and only when actually needed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about structural design patterns and specifically about the following—adapter, decorator, bridge, composite, facade, flyweight, and proxy. We went through the details of each of them and showed a class diagram as well as a code example for each. Because of the richness of Scala, sometimes there can be a better implementation using some of the nice features of Scala, but sometimes the design pattern just looks the same as it would in a language such as Java.</p>
<p>In many cases, the structural design patterns seem quite similar. This, however, shouldn't confuse you as they still have different purposes. Some examples include:</p>
<ul>
<li><strong>Adapter versus Bridge</strong>: Adapter is used to convert one interface to another when we do not have access to the code. Bridge is used while designing software and it decouples abstraction from implementation for easier extensions in the future.</li>
<li><strong>Proxy versus Decorator</strong>: Decorators usually enhance an interface. Proxies provide the same interface, but help with application efficiency.</li>
</ul>
<p>Now, you should have a good understanding of the structural design patterns and will have enough knowledge to apply them in real-world projects.</p>
<p>In the next chapter, you will learn about <em>behavioral design patterns</em>.</p>


            </article>

            
        </section>
    </div>



  </body></html>