- en: Message Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](0bde3875-cd30-435c-9b32-b96fccb2e6d0.xhtml), *Configuring Kafka*,
    focused on how to set up a Kafka cluster and run a command-line producer and a
    consumer. Having the event producer, we now have to process those events.'
  prefs: []
  type: TYPE_NORMAL
- en: Before going into detail, let's present our case study. We need to model the
    systems of Monedero, a fictional company whose core business is cryptocurrency
    exchange. Monedero wants to base its IT infrastructure on an **enterprise service
    bus** (**ESB**) built with Apache Kafka. The Monedero IT department wants to unify
    the service backbone across the organization. Monedero also has worldwide, web-based,
    and mobile-app-based clients, so a real-time response is fundamental.
  prefs: []
  type: TYPE_NORMAL
- en: Online customers worldwide browse the Monedero website to exchange their cryptocurrencies.
    There are a lot of use cases that customers can perform in Monedero, but this
    example is focused on the part of the exchange workflow specifically from the
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the messages in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Kafka project with Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from Kafka with a Java client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to Kafka with a Java client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a processing engine pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a `Validator` in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise service bus in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Event processing consists of taking one or more events from an event stream
    and applying actions over those events. In general, in an enterprise service bus,
    there are commodity services; the most common are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Data transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message processing in the majority of cases involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Message structure validation against a message schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given an event stream, filtering the messages from the stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message enrichment with additional data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message aggregation (composition) from two or more message to produce a new
    message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is about event validation. The chapters that follow are about composition
    and enrichment.
  prefs: []
  type: TYPE_NORMAL
- en: Event modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in event modeling is to express the event in English in the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: Subject-verb-direct object
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we are modeling the event *customer consults the ETH price*:'
  prefs: []
  type: TYPE_NORMAL
- en: The subject in this sentence is *customer*, a noun in nominative case. The subject
    is the entity performing the action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The verb in this sentence is *consults*; it describes the action performed by
    the subject.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The direct object in this sentence is *ETH price*. The object is the entity
    in which the action is being done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can represent our message in several message formats (covered in other sections
    of this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Avro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Thrift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol Buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON is easily read and written by both humans and machines. For example, we
    could chose binary as the representation, but it has a rigid format and it was
    not designed for humans to read it; as counterweight, binary representation is
    very fast and lightweight in processing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2.1*, shows the representation of the `CUSTOMER_CONSULTS_ETHPRICE`
    event in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.1: customer_consults_ETHprice.json'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, the **Ethereum** (**ETH**) currency price is expressed in
    **Russian rouble** (**RUB**). This JSON message has four sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`event`: This is a string with the event''s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer`: This represents the person (in this case its `id` is `14862768`)
    consulting the Ethereum price. In this representation, there is a unique id for
    the customer, the name, and the browser `ipAddress`, which is the IP address of
    the computer the customer is logged on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currency`: This contains the cryptocurrency name and the currency in which
    the price is expressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timestamp`: The timestamp in which the customer made the request (UTC).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From another perspective, the message has two parts: the metadataâ€”this is the
    event name and the timestamp and two business entities, the customer and the currency.
    As we can see, this message can be read and understood by a human.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other messages from the same use case in JSON format could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if we want to represent our message in the Avro schema? Yes, the
    Avro schema of our message (note that it''s not the message, but the schema) is
    in *Listing 2.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.2: customer_consults_ethprice.avsc'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the Avro schema, check the Apache Avro specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://avro.apache.org/docs/1.8.2/spec.html](https://avro.apache.org/docs/1.8.2/spec.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, we are going to build our project with Gradle. The first step is
    to download and install Gradle from [http://www.gradle.org/downloads](http://www.gradle.org/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: Gradle only requires a Java JDK (version 7 or higher).
  prefs: []
  type: TYPE_NORMAL
- en: 'macOS users can install Gradle with the `brew` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Linux users can install Gradle with the `apt-get` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Unix users can install with sdkman, a tool for managing parallel versions of
    most Unix-based systems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that Gradle is installed correctly, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to create a directory called `monedero` and, from that directory,
    execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Gradle generates a skeleton project inside the directory. The directory should
    be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`- build.gradle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- gradle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-- wrapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--- gradle-wrapper.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--- gradle-vreapper.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- gradlew`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- gradle.bat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- settings.gradle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- src`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-- main`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--- java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`----- Library.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-- test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--- java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`----- LibraryTest.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two Java files, `Library.java` and `LibraryTest.java`, can be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, modify the Gradle build file called `build.gradle`, and replace it with
    *Listing 2.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.3: ProcessingEngine Gradle build file'
  prefs: []
  type: TYPE_NORMAL
- en: 'This file shows the library dependencies for the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kafka_2.12`, are the dependencies for Apache Kafka'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jackson-databind` is the library for JSON parsing and manipulation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To compile the sources and download the required libraries, type the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The project can be created with Maven or SBT, even from an IDE (IntelliJ, Eclipse,
    Netbeans). But for simplicity here, it was created with Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the build tools, visit the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle''s main page: [http://www.gradle.org](http://www.gradle.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maven''s main page: [http://maven.apache.org](http://maven.apache.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SBT''s main page: [http://www.scala-sbt.org/](http://www.scala-sbt.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading from Kafka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our project skeleton, let's recall the project requirements
    for the stream processing engine. Remember that our event customer consults ETH
    price occurs outside Monedero and that these messages may not be well formed,
    that is, they may have defects. The first step in our pipeline is to validate
    that the input events have the correct data and the correct structure. Our project
    will be called `ProcessingEngine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProcessingEngine` specification shall create a pipeline application that
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads each message from a Kafka topic called **input-messages**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validates each message, sending any invalid event to a specific Kafka topic
    called **invalid-messages**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writes the correct messages in a Kafka topic called **valid-messages**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These steps are detailed in *Figure 2.1*, the first sketch for the pipeline
    processing engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa921a59-34d9-4f98-9348-28e924f796e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The processing engine reads events from the input-messages topic,
    validates the messages, and routes the defective ones to invalid-messages topic
    and the correct ones to valid-messages topic'
  prefs: []
  type: TYPE_NORMAL
- en: 'The processing engine stream construction has two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple Kafka worker that reads from the **input-messages** topic in
    Kafka and writes the events to another topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the Kafka worker to make the validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's proceed with the first step. Build a Kafka worker that reads individual
    raw messages from the **input-messages** topic. We say in the Kafka jargon that
    a consumer is needed. If you recall, in the first chapter we built a command-line
    producer to write events to a topic and a command-line consumer to read the events
    from that topic. Now, we will code the same consumer in Java.
  prefs: []
  type: TYPE_NORMAL
- en: For our project, a consumer is a Java interface that contains all of the necessary
    behavior for all classes that implement consumers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `Consumer.java` in the `src/main/java/monedero/` directory
    with the content of *Listing 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.4: Consumer.java'
  prefs: []
  type: TYPE_NORMAL
- en: The consumer interface encapsulates the common behavior of the Kafka consumers.
    The consumer interface has the `createConfig` method that sets all of the properties
    needed by all of the Kafka consumers. Note that the deserializers are of the `StringDeserializer`
    type because the Kafka consumer reads Kafka key-value records where the value
    are of the type string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a file called `Reader.java` in the `src/main/java/monedero/` directory
    with the content of *Listing 2.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.5: Reader.java'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Reader` class implements the consumer interface. So, `Reader` is a Kafka
    consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: In line `//1`, `<String, String>` says that `KafkaConsumer` reads Kafka records
    where the key and value are both of the type string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//2`, the consumer subscribes to the Kafka topic specified in its constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, there is a `while(true)` infinite loop for demonstrative purposes;
    in practice, we need to deal with more robust code maybe, implementing `Runnable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, this consumer will be pooling data from the specified topics
    every 100 milliseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, the consumer sends the message to be processed by the producer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This consumer reads all of the messages from the specified Kafka topic and sends
    them to the process method of the specified producer. All of the configuration
    properties are specified in the consumer interface, but specifically the `groupId`
    property is important because it associates the consumer with a specific consumer
    group.
  prefs: []
  type: TYPE_NORMAL
- en: The consumer group is useful when we need to share the topic's events across
    all of the group's members. Consumer groups are also used to group or isolate
    different instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about the Kafka Consumer API, follow this link: [https://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html/](https://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to Kafka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `Reader` invokes the `process()` method; this method belonging to the `Producer`
    class. As with the consumer interface, the producer interface encapsulates all
    of the common behavior of the Kafka producers. The two producers in this chapter
    implement this producer interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a file called `Producer.java`, located in the `src/main/java/monedero` directory,
    copy the content of *Listing 2.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.6: Producer.java'
  prefs: []
  type: TYPE_NORMAL
- en: 'The producer interface has the following observations:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract method called process invoked in the `Reader` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static method called write that sends a message to the producer in the specified
    topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static method called `createConfig`, where it sets all of the properties required
    for a generic producer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with the consumer interface, an implementation of the producer interface
    is needed. In this first version, we just pass the incoming messages to another
    topic without modifying the messages. The implementation code is in *Listing 2.7*
    and should be saved in a file called `Writer.java` in the `src/main/java/m` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 2.7*, `Writer.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.7: Writer.java'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this implementation of the `Producer` class, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `createConfig` method is invoked to set the necessary properties from the
    producer interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process method writes each incoming message in the output topic. As the
    message arrives from the topic, it is sent to the target topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This producer implementation is very simple; it doesn't modify, validate, or
    enrich the messages. It just writes them to the output topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about the Kafka producer API, follow this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kafka.apache.org/0110/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaProducer.html](https://kafka.apache.org/0110/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaProducer.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Running the processing engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ProcessingEngine` class coordinates the `Reader` and `Writer` classes.
    It contains the main method to coordinate them. Create a new file called `ProcessingEngine.java`
    in the `src/main/java/monedero/` directory and copy therein the code in *Listing
    2.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 2.8*, `ProcessingEngine.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.8: ProcessingEngine.java'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProcessingEngine` receives four arguments from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`args[0]` `servers`, the host and port of the Kafka broker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[1]` `groupId`, the consumer group of the consumer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[2]` `sourceTopic`, `inputTopic` where `Reader` reads from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[3]` `targetTopic`, `outputTopic` where `Writer` writes to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To build the project, run this command from the `monedero` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is OK, the output is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the project, we need to open three different command-line windows. *Figure
    2.2* shows what the command-line windows should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a54e6f9-9d05-4ca0-9b0d-1d65736f1f7c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The three terminal windows to test the processing engine including
    message producer, message consumer, and the application itself'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first command-line terminal, move to the `Confluent` directory and start
    it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the control center (Zookeeper and Kafka included) is running in the same
    command-line terminal, generate the two necessary topics, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall, to display the topics running in our cluster type, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you had a mistyping error, to delete some topic (just in case), type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same command-line terminal, start the console producer running the `input-topic`
    topic, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This window is where the input messages are typed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second command-line terminal, start a console consumer listening to
    `output-topic` by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the third command-line terminal, start the processing engine. Go to the
    project root directory where the `gradle jar` command was executed and run, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, the show consists in reading all of the events from `input-topic` and writing
    them in `output-topic`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the first command-line terminal (the message producer) and send the following
    three messages (remember to type enter between messages and execute each one in
    just one line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If everything is working fine, the messages typed in the console-producer should
    be appearing in the console-consumer window, because the processing engine is
    copying from `input-topic` to `output-topic`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to move onto a more complex version involving message validation
    (this current chapter), message enrichment([Chapter 3](fa29d3d4-38ab-49c0-9e81-08bc59944488.xhtml),
    *Message Enrichment*), and message transformation ([Chapter 4](b444c6b4-4a8f-478c-9d3f-93a432d168b8.xhtml),
    *Serialization*).
  prefs: []
  type: TYPE_NORMAL
- en: Using the same suggestion made in the [Chapter 1](0bde3875-cd30-435c-9b32-b96fccb2e6d0.xhtml),
    *Configuring Kafka*, the replication-factor and partitions parameters where set
    to 1; try setting different values and see what happens when you stop one server.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a validator in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Writer` class implements the producer interface. The idea is to modify
    that `Writer` and build a validation class with minimum effort. The `Validator`
    process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the Kafka messages from the **input-messages** topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the messages, sending defective messages to the **invalid-messages**
    topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the well-formed messages to **valid-messages** topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the moment, for this example, the definition of a valid message is a message
    t0 which the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: It is in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It contains the four required fields: event, customer, currency, and timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If these conditions are not met, a new error message in JSON format is generated,
    sending it to the invalid-messages Kafka topic. The schema of this error message
    is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first step is create a new `Validator.java` file in the `src/main/java/monedero/`
    directory, and copy therein the content of *Listing 2.9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 2.9*, `Validator.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.9: Validator.java'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `Writer`, the `Validator` class also implements the `Producer` class,
    but with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In line `//1`, its constructor takes two topics: the valid and the invalid-messages
    topic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In line `//2`, the process method validates the fact that the message is in
    JSON format along with the existence of the fields: event, customer, currency,
    and timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//3`, in case the message doesn't have any required field, an error
    message is sent to the invalid-messages topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//4`, in case the message is valid, the message is sent to the valid-messages
    topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In line `//5`, in case the message is not in JSON format, an error message is
    sent to the invalid-messages topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, the `ProcessingEngine` class coordinates the `Reader` and `Writer`
    classes. It contains the main method to coordinate them. We have to edit the `ProcessingEngine`
    class located in the `src/main/java/monedero/` directory and change `Writer` with
    `Validator`, as in *Listing 2.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of *Listing 2.10*, `ProcessingEngine.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2.10: ProcessingEngine.java'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProcessingEngine` receives five arguments from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`args[0]` `servers`, indicates the host and port of the Kafka broker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[1]` `groupId`, indicates that the consumer is part of this Kafka consumer
    group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[2]` `inputTopic`, the topic where `Reader` reads from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[3]` `validTopic`, the topic where valid messages are sent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args[4]` `invalidTopic`, the topic where invalid messages are sent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To rebuild the project from the `monedero` directory, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is OK, the output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the project, we need four different command-line windows. *Figure 2.3*
    shows the command-line windows arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee505494-9d3a-4107-8adb-6d2780afa3cf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The four terminal windows to test the processing engine including:
    message producer, valid-message consumer, invalid-message consumer, and the processing
    engine itself'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first command-line terminal, go to the Kafka installation directory
    and generate the two necessary topics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start a console producer to the `input-topic` topic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This window is where the input messages are produced (typed).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second command-line window, start a command-line consumer listening
    to the valid-messages topic, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the third command-line window, start a command-line consumer listening to
    invalid-messages topic, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the fourth command-line terminal, start up the processing engine. From the
    project root directory (where the `gradle jar` command were executed), run the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'From the first command-line terminal (the console producer), send the following
    three messages (remember to type enter between messages and execute each one in
    just one line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As these are valid messages, the messages typed in the producer console should
    appear in the valid-messages consumer console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try sending defective messages; first, try messages that are not in JSON
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This message should be received in the invalid messages topic (and displayed
    in the window), as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s try something more complex, the first message but without a timestamp,
    as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This message should be received in the invalid messages topic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The message validation is complete and, as you can see, there is a lot more
    validation to do, for example, validation against JSON schemas, but this is covered
    in [Chapter 5](f7fa5729-8bf7-41c8-aba6-aa5f8663394f.xhtml), *Schema Registry*.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture detailed in *Figure 2.1* of this chapter will be used in [Chapter
    3](fa29d3d4-38ab-49c0-9e81-08bc59944488.xhtml), *Message Enrichment*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned how to model the messages in JSON format and how
    to set up a Kafka project with Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we learned how to write to and read from Kafka with a Java client, how
    to run the processing engine, how to code a validator in Java, and how to run
    the message validation.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](fa29d3d4-38ab-49c0-9e81-08bc59944488.xhtml), *Message Enrichment*,
    the architecture of this chapter will be redesigned to incorporate message enrichment.
  prefs: []
  type: TYPE_NORMAL
