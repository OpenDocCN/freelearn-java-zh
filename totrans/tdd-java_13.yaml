- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Driving the Domain Layer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动领域层
- en: We laid a lot of groundwork in previous chapters, covering a mixture of TDD
    techniques and software design approaches. Now we can apply those capabilities
    to build our Wordz game. We will be building on top of the useful code we have
    written throughout the book and working toward a well-engineered, well-tested
    design, written using the test-first approach.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们做了大量的准备工作，涵盖了TDD技术和软件开发方法。现在我们可以应用这些能力来构建我们的Wordz游戏。我们将在本书中编写的有用代码的基础上构建，并致力于一个经过良好工程和测试的设计，使用测试优先的方法编写。
- en: Our goal for this chapter is to create the domain layer of our system. We will
    adopt the hexagonal architecture approach as described in [*Chapter 9*](B18384_09.xhtml#_idTextAnchor179),
    *Hexagonal Architecture – Decoupling External Systems*. The domain model will
    contain all our core application logic. This code will not be tied to details
    of any external system technologies such as SQL databases or web servers. We will
    create abstractions for these external systems and use test doubles to enable
    us to test-drive the application logic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的目标是创建我们系统的领域层。我们将采用[第9章](B18384_09.xhtml#_idTextAnchor179)中描述的六边形架构方法，*六边形架构
    – 解耦外部系统*。领域模型将包含我们所有核心应用程序逻辑。此代码将不会绑定到任何外部系统技术（如SQL数据库或Web服务器）的细节。我们将为这些外部系统创建抽象，并使用测试替身来使我们能够测试驱动应用程序逻辑。
- en: Using hexagonal architecture in this way allows us to write FIRST unit tests
    for complete user stories, which is something often requiring integration or end-to-end
    testing in other design approaches. We will write our domain model code by applying
    the ideas presented in the book so far.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用六边形架构允许我们为完整用户故事编写FIRST单元测试，这在其他设计方法中通常需要集成或端到端测试。我们将通过应用书中至今为止提出的思想来编写我们的领域模型代码。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Starting a new game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: Playing the game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩游戏
- en: Ending the game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束游戏
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The final code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter13](B18384_13.xhtml#_idTextAnchor292).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter13](B18384_13.xhtml#_idTextAnchor292)找到。
- en: Starting a new game
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: In this section, we will make a start by coding our game. Like every project,
    starting is usually quite difficult, with the first decision being simply where
    to begin. A reasonable approach is to find a user story that will begin to flesh
    out the structure of the code. Once we have a reasonable structure for an application,
    it becomes much easier to figure out where new code should be added.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过编写游戏代码来开始。像每个项目一样，开始通常相当困难，第一个决定就是简单地确定从哪里开始。一个合理的方法是找到一个用户故事，这将开始充实代码的结构。一旦我们有一个合理的应用程序结构，就更容易确定新代码应该添加的位置。
- en: Given this, we can make a good start by considering what needs to happen when
    we start a new game. This must set things up ready to play and so will force some
    critical decisions to be made.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过考虑开始新游戏时需要发生的事情来有一个良好的开始。这必须设置好以便开始游戏，因此将迫使做出一些关键的决定。
- en: 'The first user story to work on is starting a new game:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要处理的用户故事是开始一个新游戏：
- en: As a player I want to start a new game so that I have a new word to guess
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名玩家，我想开始一个新游戏，以便我有一个新单词来猜测
- en: 'When we start a new game, we must do the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始新游戏时，我们必须执行以下操作：
- en: Select a word at random from the available words to guess
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可猜测的单词中随机选择一个单词
- en: Store the selected word so that scores for guesses can be calculated
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储所选单词，以便可以计算猜测的分数
- en: Record that the player may now make an initial guess
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录玩家现在可以做出一个初始猜测
- en: We will assume the use of hexagonal architecture as we code this story, meaning
    that any external system will be represented by a port in the domain model. With
    this in mind, we can create our first test and take it from there.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这个故事时，我们将假设使用六边形架构，这意味着任何外部系统都将由领域模型中的一个端口表示。考虑到这一点，我们可以创建我们的第一个测试，并从这里开始。
- en: Test-driving starting a new game
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开始新游戏
- en: In terms of a general direction, using hexagonal architecture means we are free
    to use an outside-in approach with TDD. Whatever design we come up with for our
    domain model, none of it is going to involve difficult-to-test external systems.
    Our unit tests are assured to be **FIRST** – **fast, isolated, repeatable, self-checking,**
    **and timely**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从一般方向来看，使用六边形架构意味着我们可以自由地使用TDD的外向内方法。无论我们为领域模型设计出什么，都不会涉及难以测试的外部系统。我们的单元测试确保是**FIRST**
    – **快速、隔离、可重复、自我检查**和**及时**。
- en: Importantly, we can write unit tests that cover the entire logic needed for
    a user story. If we wrote code that is bound to external systems – for example,
    it contained SQL statements and connected to a database – we would need an integration
    test to cover a user story. Our choice of hexagonal architecture frees us from
    that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们可以编写覆盖用户故事所需整个逻辑的单元测试。如果我们编写的代码绑定到外部系统（例如，包含SQL语句并连接到数据库），我们需要一个集成测试来覆盖用户故事。我们选择六边形架构使我们免于这种限制。
- en: On a tactical note, we will reuse classes that we have already test-driven,
    such as `class WordSelection`, `class Word`, and `class Score`. We will reuse
    existing code and third-party libraries whenever an opportunity presents itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在战术层面，我们将重用已经通过测试驱动开发的类，例如`class WordSelection`、`class Word`和`class Score`。只要有机会，我们将重用现有代码和第三方库。
- en: 'Our starting point is to write a test to capture our design decisions related
    to starting a new game:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点是编写一个测试来捕获我们与开始新游戏相关的设计决策：
- en: 'We will start with a test called `NewGameTest`. This test will act across the
    domain model to drive out our handling of everything we need to do to start a
    new game:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从名为`NewGameTest`的测试开始。这个测试将在领域模型中执行，以驱动出我们开始新游戏所需执行的所有操作：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For this test, we will start with the Act step first. We are assuming hexagonal
    architecture, so the design goal of the Act step is to design the port that handles
    the request to start a new game. In hexagonal architecture, a port is the piece
    of code that allows some external system to connect with the domain model. We
    begin by creating a class for our port:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个测试，我们将首先编写Act步骤。我们假设使用六边形架构，因此Act步骤的设计目标是设计处理启动新游戏请求的端口。在六边形架构中，端口是允许某些外部系统与领域模型连接的代码片段。我们首先创建一个端口类：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The key design decision here is to create a `controller` class to handle the
    request to start a game. It is a controller in the sense of the original Gang
    of Four’s *Design Patterns* book – a domain model object that will orchestrate
    other domain model objects. We will let the IntelliJ IDE create the empty `Game`
    class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键设计决策是创建一个`controller`类来处理启动游戏的请求。它符合原始《设计模式》书籍中的控制器概念 – 一个将协调其他领域模型对象的领域模型对象。我们将让IntelliJ
    IDE创建空的`Game`类：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s another advantage of TDD. When we write the test first, we give our IDE
    enough information to be able to generate boilerplate code for us. We enable the
    IDE autocomplete feature to really help us. If your IDE cannot autogenerate code
    after having written the test, consider upgrading your IDE.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是TDD的一个优点。当我们首先编写测试时，我们给IDE足够的信息来为我们生成样板代码。我们启用IDE自动完成功能以真正帮助我们。如果你的IDE在编写测试后不能自动生成代码，考虑升级你的IDE。
- en: 'The next step is to add a `start()` method on the controller class to start
    a new game. We need to know which player we are starting a game for, so we pass
    in a `Player` object. We write the Act step of our test:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在控制器类中添加一个`start()`方法来开始新游戏。我们需要知道我们要为哪个玩家开始游戏，因此我们传递一个`Player`对象。我们编写测试的Act步骤：
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We allow the IDE to generate the method in the controller:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许IDE在控制器中生成方法：
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tracking the progress of the game
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪游戏的进度
- en: 'The next design decisions concern the expected outcome of starting a new game
    for a player. There are two things that need to be recorded:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个设计决策涉及玩家开始新游戏预期的结果。需要记录以下两点：
- en: The selected word that the player attempts to guess
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家尝试猜测的选定单词
- en: That we expect their first guess next
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们期望他们下一个猜测
- en: The selected word and current attempt number will need to persist somewhere.
    We will use the repository pattern to abstract that. Our repository will need
    to manage some domain objects. Those objects will have the single responsibility
    of tracking our progress in a game.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的单词和当前尝试次数需要持久化存储。我们将使用存储库模式来抽象这一点。我们的存储库需要管理一些领域对象。这些对象将负责跟踪我们在游戏中的进度。
- en: Already, we see a benefit of TDD in terms of rapid design feedback. We haven’t
    written too much code yet, but already, it seems like the new class needed to
    track game progress would best be called `class Game`. However, we already have
    a `class Game`, responsible for starting a new game. TDD is providing feedback
    on our design – that our names and responsibilities are mismatched.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 已经，我们可以看到 TDD 在快速设计反馈方面的好处。我们还没有写太多代码，但已经，看起来需要跟踪游戏进度的新的类最好被称为 `class Game`。然而，我们已经有了一个
    `class Game`，负责启动新游戏。TDD 正在为我们提供设计反馈——我们的名称和责任不匹配。
- en: 'We must choose one of the following options to proceed:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须选择以下选项之一来继续：
- en: Keep our existing `class Game` as it is. Call this new class something such
    as `Progress` or `Attempt`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持现有的 `class Game` 不变。将这个新类命名为例如 `Progress` 或 `Attempt`。
- en: Change the `start()` method to a static method – a method that applies to all
    instances of a class.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `start()` 方法更改为静态方法——一个适用于类所有实例的方法。
- en: Rename `class Game` to something that better describes its responsibility. Then,
    we can create a new `class Game` to hold current player progress.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `class Game` 重命名为能更好地描述其责任的名字。然后，我们可以创建一个新的 `class Game` 来保存当前玩家的进度。
- en: The static method option is unappealing. When using object-oriented programming
    in Java, static methods rarely seem as good a fit as simply creating another object
    that manages all the relevant instances. The static method becomes a normal method
    on this new object. Using `class Game` to represent progress through a game seems
    to result in more descriptive code. Let’s go with that approach.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法选项不太吸引人。在 Java 中使用面向对象编程时，静态方法似乎很少像创建另一个管理所有相关实例的新对象那样合适。在这个新对象上，静态方法变成了一个普通方法。使用
    `class Game` 来表示游戏进度似乎会产生更具描述性的代码。让我们采用这种方法。
- en: 'Use the IntelliJ IDEA IDE to refactor/rename `class Game` `class Wordz`, which
    represents the entry point into our domain model. We also rename the local variable
    `game` to match:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 IntelliJ IDEA IDE 对 `class Game` 和 `class Wordz` 进行重构/重命名，它们代表进入我们的领域模型的入口点。我们还重命名了局部变量
    `game` 以匹配：
- en: '[PRE19]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The name of the `NewGameTest` test is still good. It represents the user story
    we are testing and is not related to any class names. The production code has
    been refactored by the IDE as well:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewGameTest` 测试的名称仍然很好。它代表了我们要测试的用户故事，并且与任何类名无关。IDE 也已对生产代码进行了重构：'
- en: '[PRE27]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use the IDE to refactor/rename the `start()` method `newGame()`. This seems
    to better describe the responsibility of the method, in the context of a class
    named `Wordz`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 IDE 对 `start()` 方法进行重构/重命名为 `newGame()`。这在 `Wordz` 类的上下文中似乎更好地描述了方法的责任：
- en: '[PRE28]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `class Wordz` production code also has the method renamed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Wordz` 的生产代码也将该方法重命名。'
- en: 'When we start a new game, we need to select a word to guess and start the sequence
    of attempts the player has. These facts need to be stored in a repository. Let’s
    create the repository first. We will call it `interface GameRepository` and add
    Mockito `@Mock` support for it in our test:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们开始新游戏时，我们需要选择一个要猜测的单词并开始玩家尝试的序列。这些事实需要存储在存储库中。让我们首先创建存储库。我们将它命名为 `interface
    GameRepository` 并在我们的测试中添加 Mockito 的 `@Mock` 支持：
- en: '[PRE36]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We add the `@ExtendWith` annotation to the class to enable the Mockito library
    to automatically create test doubles for us. We add a `gameRepository` field,
    which we annotated as a Mockito `@Mock`. We use the `@InjectMocks` convenience
    annotation built into Mockito to automatically inject this dependency into the
    `Wordz` constructor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向类添加 `@ExtendWith` 注解以启用 Mockito 库自动为我们创建测试替身。我们添加了一个 `gameRepository` 字段，将其标注为
    Mockito 的 `@Mock`。我们使用 Mockito 内置的 `@InjectMocks` 便利注解自动将这个依赖注入到 `Wordz` 构造函数中。
- en: 'We allow the IDE to create an empty interface for us:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们允许 IDE 为我们创建一个空接口：
- en: '[PRE53]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For the next step, we will confirm that `gameRepository` gets used. We decide
    to add a `create()` method on the interface, which takes a `class Game` object
    instance as its only parameter. We want to inspect that object instance of `class
    Game`, so we add an argument captor. This allows us to assert on the game data
    contained in that object:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将确认 `gameRepository` 是否被使用。我们决定在接口上添加一个 `create()` 方法，它只接受一个 `class
    Game` 对象实例作为其唯一参数。我们想要检查该对象实例的 `class Game`，因此添加了一个参数捕获器。这允许我们对该对象中包含的游戏数据进行断言：
- en: '[PRE56]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A good question is why we are asserting against those particular values. The
    reason is that we are going to cheat when we add the production code and *fake
    it until we make it*. We will return a `Game` object that hardcodes these values
    as a first step. We can then work in small steps. Once the cheat version makes
    the test pass, we can refine the test and test-drive the code to fetch the word
    for real. Smaller steps provide more rapid feedback. Rapid feedback enables better
    decision-making.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好问题是为什么我们要断言那些特定的值。原因是当我们添加生产代码时，我们将采取欺骗手段，直到我们成功。我们将首先返回一个硬编码这些值的 `Game`
    对象。然后我们可以分步骤工作。一旦欺骗版本使测试通过，我们可以完善测试并驱动代码以获取真正的单词。更小的步骤提供了更快的反馈。快速的反馈能够促进更好的决策。
- en: Note on using getters in the domain model
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在领域模型中使用获取器的注意事项
- en: The `Game` class has `getXxx()` methods, known as *getters* in Java terminology,
    for every one of its private fields. These methods break the encapsulation of
    data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 类为它的每个私有字段都有 `getXxx()` 方法，在 Java 术语中被称为 *获取器*。这些方法打破了数据的封装。'
- en: This is generally not recommended. It can lead to important logic being placed
    into other classes – a code smell known as a foreign method. Object-oriented programming
    is all about co-locating logic and data, encapsulating both. Getters should be
    few and far between. That does not mean we should never use them, however.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是不推荐的。它可能导致重要逻辑被放入其他类中——这是一种被称为“外来方法”的代码异味。面向对象编程的全部内容都是关于将逻辑和数据本地化，封装两者。获取器应该很少使用。但这并不意味着我们永远不会使用它们。
- en: In this case, the single responsibility of `class Game` is to transfer the current
    state of the game being played to `GameRepository`. The most direct way of implementing
    this is to add getters to the class. Writing simple, clear code beats following
    rules dogmatically.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`class Game` 的单一职责是将正在玩的游戏的当前状态传输到 `GameRepository`。实现这一点的最直接方式是为该类添加获取器。编写简单、清晰的代码胜过盲目遵循规则。
- en: Another reasonable approach is to add a `getXxx()` **diagnostic method** at
    package-level visibility purely for testing. Check with the team that this is
    not part of the public API and do not use it in production code. It is more important
    to get the code correct than obsess over design trivia.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种合理的方法是在包级别可见性下添加一个 `getXxx()` **诊断方法**，纯粹是为了测试。与团队确认这不应该成为公共 API 的一部分，并且在生产代码中不要使用它。正确地编写代码比过分关注设计细节更重要。
- en: 'We create empty methods for these new getters using the IDE. The next step
    is to run `NewGameTest` and confirm that it fails:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 IDE 为这些新的获取器创建空方法。下一步是运行 `NewGameTest` 并确认它失败：
- en: '![Figure 13.1 – Our failing test](img/Figure_13.1_B18384.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 我们失败的测试](img/Figure_13.1_B18384.jpg)'
- en: Figure 13.1 – Our failing test
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 我们失败的测试
- en: 'This is enough for us to write some more production code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就足够我们编写一些更多的生产代码：
- en: '[PRE73]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can rerun `NewGameTest` and watch it pass:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新运行 `NewGameTest` 并观察它通过：
- en: '![Figure 13.2 – The test passes](img/Figure_13.2_B18384.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 测试通过](img/Figure_13.2_B18384.jpg)'
- en: Figure 13.2 – The test passes
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 测试通过
- en: The test now passes. We can move from our red-green phase to thinking about
    refactoring. The thing that jumps out immediately is just how unreadable that
    `ArgumentCaptor` code is in the test. It contains too much detail about the mechanics
    of mocking and not enough detail about why we are using that technique. We can
    clarify that by extracting a well-named method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在通过了。我们可以从我们的红-绿阶段过渡到考虑重构。立即跳出来的是测试中的 `ArgumentCaptor` 代码是多么难以阅读。它包含太多关于模拟机制细节的信息，而关于为什么我们使用这种技术的信息却不够详细。我们可以通过提取一个命名良好的方法来澄清这一点。
- en: 'Extract the `getGameInRepository()` method for clarity:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰起见，提取 `getGameInRepository()` 方法：
- en: '[PRE84]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: That has made the test much simpler to read and see the usual Arrange, Act,
    and Assert pattern in it. It is a simple test by nature and should read as such.
    We can now rerun the test and confirm that it still passes. It does, and we are
    satisfied that our refactoring did not break anything.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试更容易阅读，并可以看到其中的常规 Arrange、Act 和 Assert 模式。本质上这是一个简单的测试，应该这样阅读。现在我们可以重新运行测试，并确认它仍然通过。它确实通过了，我们满意地认为我们的重构没有破坏任何东西。
- en: That completes our first test – a job well done! We’re making good progress
    here. It always feels good to me to see a test go green, and that feeling never
    gets old. This test is essentially an end-to-end test of a user story, acting
    only on the domain model. Using hexagonal architecture enables us to write tests
    that cover the details of our application logic, while avoiding the need for test
    environments. We get faster-running, more stable tests as a result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第一个测试——干得好！我们在这里取得了良好的进展。看到测试通过总是让我感到很高兴，这种感觉永远不会过时。这个测试本质上是一个用户故事的端到端测试，仅作用于领域模型。使用六边形架构使我们能够编写覆盖我们应用程序逻辑细节的测试，同时避免测试环境的需求。因此，我们得到了运行更快、更稳定的测试。
- en: There is more work to do in our next test, as we need to remove the hardcoded
    creation of the `Game` object. In the next section, we will address this by triangulating
    the word selection logic. We design the next test to drive out the correct behavior
    of selecting a word at random.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个测试中还有更多工作要做，因为我们需要移除硬编码创建`Game`对象的过程。在下一节中，我们将通过三角化单词选择逻辑来解决这个问题。我们设计下一个测试来驱动随机选择单词的正确行为。
- en: Triangulating word selection
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角化单词选择
- en: The next task is to remove the cheating that we used to make the previous test
    pass. We hardcoded some data when we created a `Game` object. We need to replace
    that with the correct code. This code must select a word at random from our repository
    of known five-letter words.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是移除我们用来使上一个测试通过的不诚实行为。我们在创建`Game`对象时硬编码了一些数据。我们需要用正确的代码来替换它。这个代码必须从我们的已知五字母单词库中随机选择一个单词。
- en: 'Add a new test to drive out the behavior of selecting a random word:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的测试来驱动随机选择单词的行为：
- en: '[PRE100]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Random word selection depends on two external systems – the database that holds
    the words to choose from and a source of random numbers. As we are using hexagonal
    architecture, the domain layer cannot access those directly. We will represent
    them with two interfaces – the ports to those systems. For this test, we will
    use **Mockito** to create stubs for those interfaces:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机单词选择依赖于两个外部系统——包含可供选择的单词的数据库和随机数字的来源。由于我们使用六边形架构，领域层不能直接访问这些系统。我们将用两个接口来表示它们——这些系统的端口。对于这个测试，我们将使用**Mockito**来创建这些接口的存根：
- en: '[PRE103]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This test introduces two new collaborating objects to `class Wordz`. These are
    instances of any valid implementations of both `interface WordRepository` and
    `interface RandomNumbers`. We need to inject those objects into the `Wordz` object
    to make use of them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试向`class Wordz`引入了两个新的协作对象。这些是`interface WordRepository`和`interface RandomNumbers`的有效实现实例。我们需要将这些对象注入到`Wordz`对象中以便使用它们。
- en: 'Using dependency injection, inject the two new interface objects into the `class`
    `Wordz` constructor:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用依赖注入，将两个新的接口对象注入到`class Wordz`构造函数中：
- en: '[PRE113]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We’ve added two parameters to the constructor. We do not need to store them
    directly as fields. Instead, we use the previously created `class WordSelection`.
    We create a `WordSelection` object and store it in a field called `wordSelection`.
    Note that our earlier use of `@InjectMocks` means that our test code will automatically
    pass in the mock objects to this constructor, without further code changes. It
    is very convenient.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中添加了两个参数。我们不需要直接将它们存储为字段。相反，我们使用之前创建的`class WordSelection`。我们创建一个`WordSelection`对象并将其存储在一个名为`wordSelection`的字段中。请注意，我们之前使用`@InjectMocks`的方式意味着我们的测试代码将自动将模拟对象传递给这个构造函数，而无需进一步修改代码。这非常方便。
- en: 'We set up the mocks. We want them to simulate the behavior we expect from `interface
    WordRepository` when we call the `fetchWordByNumber()` method and `interface RandomNumbers`
    when we call `next()`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了模拟。我们希望它们在调用`interface WordRepository`的`fetchWordByNumber()`方法时模拟我们期望的行为，以及当调用`interface
    RandomNumbers`的`next()`方法时：
- en: '[PRE122]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This will set up our mocks so that when `next()` is called, it will return
    the word number `2` every time, as a test double for the random number that will
    be produced in the full application. When `fetchWordByNumber()` is then called
    with `2` as an argument, it will return the word with word number `2`, which will
    be `"ABCDE"` in our test. Looking at that code, we can add clarity by using a
    local variable instead of that magic number `2`. To future readers of the code,
    the link between random number generator output and word repository will be more
    obvious:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置我们的模拟，以便当调用`next()`时，它将每次都返回单词编号`2`，作为将在完整应用程序中产生的随机数的测试替身。当使用`2`作为参数调用`fetchWordByNumber()`时，它将返回单词编号为`2`的单词，在我们的测试中将是`"ABCDE"`。查看那段代码，我们可以通过使用局部变量而不是那个魔法数字`2`来增加清晰度。对于代码的未来读者来说，随机数生成器输出和单词存储库之间的联系将更加明显：
- en: '[PRE128]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'That still looks too detailed once again. There is too much emphasis on mocking
    mechanics and too little on what the mocking represents. Let’s extract a method
    to explain why we are setting up this stub. We will also pass in the word we want
    to be selected. That will help us more easily understand the purpose of the test
    code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次看起来过于详细。对模拟机制的强调过多，而对模拟所代表的内容关注太少。让我们提取一个方法来解释为什么我们要设置这个存根。我们还将传入我们想要选择的单词。这将帮助我们更容易地理解测试代码的目的：
- en: '[PRE129]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now, we can write the assertion to confirm that this word is passed down to
    the `gameRepository` `create()` method – we can reuse our `getGameInRepository()`
    assert helper method:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以编写断言来确认这个单词被传递到`gameRepository`的`create()`方法 – 我们可以重用我们的`getGameInRepository()`断言辅助方法：
- en: '[PRE141]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This follows the same approach as the previous test, `startsNewGame`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的测试`startsNewGame`采用相同的方法。
- en: 'Watch the test fail. Write production code to make the test pass:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察测试失败。编写生产代码使测试通过：
- en: '[PRE149]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Watch the new test pass and then run all tests:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察新测试通过，然后运行所有测试：
- en: '![Figure 13.3 – Original test failing](img/Figure_13.3_B18384.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 原始测试失败](img/Figure_13.3_B18384.jpg)'
- en: Figure 13.3 – Original test failing
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 原始测试失败
- en: Our initial test has now failed. We’ve broken something during our latest code
    change. TDD has kept us safe by providing a regression test for us. What has happened
    is that after removing the hardcoded word `"ARISE"` that the original test relied
    on, it fails. The correct solution is to add the required mock setup to our original
    test. We can reuse our `givenWordToSelect()` helper method to do this.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的测试现在失败了。在我们最新的代码更改过程中，我们破坏了某些东西。TDD通过为我们提供回归测试来保护我们。发生的事情是在移除原始测试所依赖的硬编码单词`"ARISE"`之后，它失败了。正确的解决方案是在我们的原始测试中添加所需的模拟设置。我们可以重用我们的`givenWordToSelect()`辅助方法来完成这项工作。
- en: 'Add the mock setup to the original test:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模拟设置添加到原始测试中：
- en: '[PRE154]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Rerun all tests and confirm that they all pass:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行所有测试并确认它们都通过：
- en: '![Figure 13.4 – All tests passing](img/Figure_13.4_B18384.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 所有测试通过](img/Figure_13.4_B18384.jpg)'
- en: Figure 13.4 – All tests passing
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 所有测试通过
- en: 'We’ve test-driven our first piece of code to start a new game, with a randomly
    selected word to guess, and made the tests pass. Before we move on, it is time
    to consider what – if anything – we should refactor. We have been tidying the
    code as we write it, but there is one glaring feature. Take a look at the two
    tests. They seem very similar now. The original test has become a superset of
    the one we used to test-drive adding the word selection. The `selectsRandomWord()`
    test is a `Player` variable:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过测试驱动我们的第一段代码来启动新游戏，随机选择一个单词进行猜测，并使测试通过。在我们继续之前，是时候考虑我们应该重构什么了。我们一直在编写代码的同时整理代码，但有一个明显的特征。看看这两个测试。现在它们看起来非常相似。原始测试已经成为了我们用来测试驱动添加单词选择的测试的超集。`selectsRandomWord()`测试是一个`Player`变量：
- en: 'Extract a constant for the `Player` variable:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Player`变量中提取一个常量：
- en: '[PRE164]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: We’ll run all the tests after this to make sure that they all still pass and
    that `selectsRandomWord()` has gone.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在之后运行所有测试以确保它们仍然通过，并且`selectsRandomWord()`已经消失。
- en: '![Figure 13.5 – All tests passing](img/Figure_13.5_B18384.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 所有测试通过](img/Figure_13.5_B18384.jpg)'
- en: Figure 13.5 – All tests passing
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 所有测试通过
- en: That’s it! We have test-driven out all the behavior we need to start a game.
    It’s a significant achievement because that test covers a complete user story.
    All the domain logic has been tested and is known to be working. The design looks
    straightforward. The test code is a clear specification of what we expect our
    code to do. This is great progress.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经通过测试驱动了启动游戏所需的所有行为。这是一个重大的成就，因为该测试覆盖了一个完整的故事。所有领域逻辑都已测试，并且已知其工作正常。设计看起来很简单。测试代码是我们期望代码执行的操作的明确规范。这是巨大的进步。
- en: Following this refactoring, we can move on to the next development task – code
    that supports playing the game.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次重构之后，我们可以继续进行下一个开发任务——支持游戏玩法的代码。
- en: Playing the game
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行游戏
- en: In this section, we will build the logic to play the game. The gameplay consists
    of making a number of guesses at the selected word, reviewing the score for that
    guess, and having another guess. The game ends either when the word has been guessed
    correctly or when the maximum number of allowed attempts has been made.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建游戏的逻辑。游戏玩法包括对所选单词进行多次猜测，查看该猜测的得分，并进行另一次猜测。游戏在单词被正确猜中或达到允许尝试的最大次数时结束。
- en: We’ll begin by assuming that we are at the start of a typical game, about to
    make our first guess. We will also assume that this guess is not completely correct.
    This allows us to defer decisions about end-of-the-game behavior, which is a good
    thing, as we have enough to decide already.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先假设我们处于典型游戏的开头，即将进行第一次猜测。我们还将假设这次猜测并不完全正确。这允许我们推迟关于游戏结束行为的决策，这是好事，因为我们已经有足够的事情要决定了。
- en: Designing the scoring interface
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计评分界面
- en: 'The first design decision we must take is what we need to return following
    a guess at the word. We need to return the following information to the user:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做出的第一个设计决策是在对单词进行猜测后需要返回什么。我们需要向用户返回以下信息：
- en: The score for the current guess
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前猜测的得分
- en: Whether or not the game is still in play or has ended
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏是否仍在进行或已结束
- en: Possibly the previous history of scoring for each guess
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是每次猜测的评分历史
- en: Possibly a report of user input errors
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是用户输入错误的报告
- en: Clearly, the most important information for the player is the score for the
    current guess. Without that, the game cannot be played. As the game has a variable
    length – ending when either the word has been guessed, or when a maximum number
    of guesses has been attempted – we need an indicator that another guess will be
    allowed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对玩家来说最重要的信息是当前猜测的得分。没有这个信息，游戏就无法进行。由于游戏长度可变——当单词被猜中或尝试猜测的最大次数达到时结束——我们需要一个指示器来表示是否允许进行另一次猜测。
- en: The idea behind returning the history of scores for previous guesses is that
    it might help the consumer of our domain model – ultimately, a user interface
    of some sort. If we return only the score for the current guess, the user interface
    will most likely need to retain its own history of scores, in order to present
    them properly. If we return the entire history of scores for this game, that information
    is easily available. A good rule of thumb in software is to follow the **you ain’t
    gonna need it** (**YAGNI**) principle. As there is no requirement for a history
    of scores, we won’t build that at this stage.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 返回之前猜测的得分历史背后的想法是，这可能会帮助我们的领域模型消费者——最终，某种类型用户界面。如果我们只返回当前猜测的得分，用户界面很可能需要保留自己的得分历史，以便正确展示。如果我们返回整个游戏的得分历史，该信息将很容易获得。在软件中，一个好的经验法则是遵循**你不需要它**（**YAGNI**）原则。由于没有对得分历史的需要，我们不会在这个阶段构建它。
- en: 'The last decision we need to write our test is to think about the programming
    interface we want for this. We will choose an `assess()` method on `class Wordz`.
    It will accept `String`, which is the current guess from the player. It will return
    `record`, which is a modern Java (since Java 14) way of indicating a pure data
    structure is to be returned:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做出的最后一个决策是思考我们想要的编程接口。我们将在`class Wordz`上选择一个`assess()`方法。它将接受`String`，即玩家当前猜测的字符串。它将返回`record`，这是现代Java（自Java
    14起）表示纯数据结构应返回的一种方式：
- en: 'We''ve now got enough to write a test. We''ll make a new test for all guess-related
    behavior called `class GuessTest`. The test looks like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了足够的内容来编写测试。我们将为所有与猜测相关的行为创建一个新的测试，称为`GuessTest`。测试看起来像这样：
- en: '[PRE165]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'There are no new TDD techniques in the test. It drives out the calling interface
    for our new `assess()` method. We’ve used the static constructor idiom to create
    the game object using `Game.create()`. This method has been added to `class Game`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中没有新的TDD技术。它驱动了我们的新`assess()`方法的调用接口。我们使用了静态构造器习语，通过`Game.create()`创建游戏对象。这个方法已经被添加到`class
    Game`中：
- en: '[PRE166]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This clarifies the information necessary to create a new game. To get the test
    to compile, we create `record GuessResult`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这澄清了创建新游戏所需的信息。为了使测试能够编译，我们创建`record GuessResult`：
- en: '[PRE167]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'We can make the test pass by writing the production code for the `assess()`
    method in `class Wordz`. To do that, we will reuse the `class Word` class that
    we have already written:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`class Wordz`中编写`assess()`方法的产物代码来使测试通过。为了做到这一点，我们将重用我们已经编写的`class Word`类：
- en: '[PRE168]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The assertion checks only that the score for the first letter is correct. This
    is intentionally a weak test. The detailed testing for scoring behavior is done
    in `class WordTest`, which we wrote previously. The test is described as weak,
    as it does not fully test the returned score, only the first letter of it. Strong
    testing of the scoring logic happens elsewhere, in `class WordTest`. The weak
    test here confirms we have something capable of scoring at least one letter correctly
    and is enough for us to test-drive the production code. We avoid duplicating tests
    here.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 断言只检查第一个字母的分数是否正确。这是一个故意设计的弱测试。对评分行为的详细测试是在我们之前编写的`class WordTest`中完成的。这个测试被描述为弱测试，因为它并没有完全测试返回的分数，只是测试了它的第一个字母。评分逻辑的强测试发生在其他地方，在`class
    WordTest`中。这里的弱测试确认我们至少有一种能够正确评分一个字母的能力，这对于我们测试驱动产品代码来说是足够的。我们避免在这里重复测试。
- en: Running the test shows that it passes. We can review the test code and production
    code to see whether refactoring will improve their design. At this point, nothing
    needs our urgent attention. We can move on to tracking progress through the game.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试显示它通过了。我们可以审查测试代码和产品代码，看看重构是否会改善它们的设计。到目前为止，没有什么需要我们紧急关注的。我们可以继续通过游戏跟踪进度。
- en: Triangulating game progress tracking
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三角测量游戏进度跟踪
- en: 'We need to track the number of guesses that have been made so that we can end
    the game after a maximum number of attempts. Our design choice is to update the
    `attemptNumber` field in the `Game` object and then store it in `GameRepository`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪已经做出的猜测次数，以便在尝试次数达到最大值后结束游戏。我们的设计选择是更新`Game`对象中的`attemptNumber`字段，然后将其存储在`GameRepository`中：
- en: 'We add a test to drive this code out:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个测试来驱动这段代码：
- en: '[PRE169]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'This test introduces a new method, `update()`, into our `interface GameRepository`,
    responsible for writing the latest game information to storage. The Assert step
    uses a Mockito `ArgumentCaptor` to inspect the `Game` object that we pass into
    `update()`. We have written a `getUpdatedGameInRepository()` method to deemphasize
    the inner workings of how we check what was passed to the `gameRepository.update()`
    method. `assertThat()` in the test verifies that `attemptNumber` has been incremented.
    It started at zero, due to us creating a new game, and so the expected new value
    is `1`. This is the desired behavior for tracking an attempt to guess the word:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在我们的`interface GameRepository`中引入了一个新方法`update()`，负责将最新的游戏信息写入存储。断言步骤使用Mockito的`ArgumentCaptor`来检查我们传递给`update()`方法的`Game`对象。我们已经编写了一个`getUpdatedGameInRepository()`方法来淡化我们检查传递给`gameRepository.update()`方法的内容的内部工作原理。测试中的`assertThat()`验证`attemptNumber`已被增加。由于我们创建了一个新游戏，它从零开始，因此预期的新的值是`1`。这是跟踪猜测单词尝试的期望行为：
- en: 'We add the `update()` method to the `GameRepository` interface:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向`GameRepository`接口添加了`update()`方法：
- en: '[PRE183]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'We add the production code to the `assess()` method in `class Wordz` to increment
    `attemptNumber` and call `update()`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`class Wordz`中的`assess()`方法中添加了产物代码来增加`attemptNumber`并调用`update()`：
- en: '[PRE189]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'We add the `incrementAttemptNumber()` method to `class Game`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向`class Game`添加了`incrementAttemptNumber()`方法：
- en: '[PRE197]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'The test now passes. We can think about any refactoring improvements we want
    to make. There are two things that seem to stand out:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在通过了。我们可以考虑任何我们想要进行的重构改进。有两件事似乎很突出：
- en: The duplicated test setup between `class NewGameTest` and `class GuessTest`.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`class NewGameTest`和`class GuessTest`之间重复的测试设置。
- en: At this stage, we can live with this duplication. The options are to combine
    both tests into the same test class, to extend a common test base class, or to
    use composition. None of them seem likely to aid readability much. It seems quite
    nice to have the two different test cases separate for now.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以容忍这种重复。选项包括将两个测试合并到同一个测试类中，扩展一个公共的测试基类，或者使用组合。它们似乎都不太可能对可读性有很大帮助。现在将两个不同的测试用例分开似乎相当不错。
- en: 'The three lines inside the `assess()` method must always be called as a unit
    when we attempt another guess. It is possible to forget to call one of these,
    so it seems better to refactor to eliminate that possible error. We can refactor
    like this:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`assess()`方法内部的这三行必须在我们尝试另一次猜测时作为一个单元始终被调用。有可能忘记调用其中之一，因此似乎更好的做法是重构以消除这种可能错误。我们可以这样重构：
- en: '[PRE200]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'We move the code that used to be here into the newly created method: `attempt()`
    on `class Game`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前在这里的代码移动到新创建的方法：`class Game`中的`attempt()`：
- en: '[PRE206]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Renaming the method argument from `guess` to `latestGuess` improves readability.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法参数从`guess`重命名为`latestGuess`提高了可读性。
- en: That completes the code needed to take a guess at the word. Let’s move on to
    test-driving the code we will need to detect when a game has ended.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了猜测单词所需的代码。让我们继续测试驱动检测游戏何时结束所需的代码。
- en: Ending the game
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束游戏
- en: 'In this section, we will complete the tests and production code we need to
    drive out detecting the end of a game. This will happen when we do either of the
    following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将完成驱动检测游戏结束所需的测试和生产代码。这将在我们执行以下任一操作时发生：
- en: Guess the word correctly
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确猜测单词
- en: Make our final allowed attempt, based on a maximum number
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据最大次数进行最后的允许尝试
- en: We can make a start by coding the end-of-game detection when we guess the word
    correctly.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写在正确猜测单词时检测游戏结束的代码来开始。
- en: Responding to a correct guess
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对正确猜测做出响应
- en: 'In this case, the player guesses the target word correctly. The game is over,
    and the player is awarded a number of points, based on how few attempts were needed
    before the correct guess was made. We need to communicate that the game is over
    and how many points have been awarded, leading to two new fields in our `class
    GuessResult`. We can add a test to our existing `class GuessTest` as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，玩家正确猜出了目标单词。游戏结束，玩家根据在正确猜测之前所需的尝试次数获得一定数量的分数。我们需要传达游戏已经结束以及获得了多少分数，这导致在我们的`class
    GuessResult`中出现了两个新的字段。我们可以在现有的`class GuessTest`中添加一个测试，如下所示：
- en: '[PRE207]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'This drives out both a new `isGameOver(`)accessor in `class GuessResult` and
    the behavior to make that `true`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这驱动出`class GuessResult`中的一个新的`isGameOver()`访问器和使其为`true`的行为：
- en: '[PRE208]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'This itself drives out two new tests in `class WordTest`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身在`class WordTest`中驱动出两个新的测试：
- en: '[PRE209]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'These themselves drive out an implementation in `class Score`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这些本身就在`class Score`中驱动出一个实现：
- en: '[PRE210]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: With this, we have a valid implementation for the `isGameOver` accessor in `record
    GuessResult`. All tests pass. Nothing seems to need refactoring. We’ll move on
    to the next test.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们为`record GuessResult`中的`isGameOver`访问器提供了一个有效的实现。所有测试都通过了。看起来似乎不需要重构。我们将继续进行下一个测试。
- en: Triangulating the game over due to too many incorrect guesses
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 由于猜测错误过多而导致游戏结束
- en: 'The next test will drive out the response to exceeding the maximum number of
    guesses allowed in a game:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试将驱动超出游戏允许的最大猜测次数时的响应：
- en: '[PRE211]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: This test sets up `gameRepository` to allow one, final guess. It then sets up
    the guess to be incorrect. We assert that `isGameOver()` is `true` in this case.
    The test fails initially, as desired. We add an extra static constructor method
    in `class Game` to specify an initial number of attempts.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试设置`gameRepository`以允许一次，最后的猜测。然后设置猜测为不正确。我们断言在这种情况下`isGameOver()`是`true`。测试最初失败，正如预期的那样。我们在`class
    Game`中添加了一个额外的静态构造方法来指定初始尝试次数。
- en: 'We add the production code to end the game based on a maximum number of guesses:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了基于最大猜测次数结束游戏的生产代码：
- en: '[PRE212]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'We add this decision support method to `class Game`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个决策支持方法添加到`class Game`中：
- en: '[PRE213]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: All our tests now pass. There is something suspicious about the code, however.
    It has been very finely tuned to work only if a guess is correct and within the
    allowed number of guesses, or when the guess is incorrect and exactly at the allowed
    number. It’s time to add some boundary condition tests and double-check our logic.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有测试现在都通过了。然而，代码中有些可疑之处。它已经被非常精细地调整，只有在猜测正确且在允许的猜测次数内，或者猜测错误且正好在允许的次数时才会工作。是时候添加一些边界条件测试并双重检查我们的逻辑了。
- en: Triangulating response to guess after game over
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束后对猜测的响应三角化
- en: 'We need a couple more tests around the boundary conditions of the game over
    detection. The first one drives out the response to an incorrect guess being submitted
    after a correct guess:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在游戏结束检测的边界条件周围进行更多测试。第一个测试是针对在正确猜测之后提交错误猜测的响应：
- en: '[PRE214]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'There are a couple of design decisions captured in this test:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试中包含了一些设计决策：
- en: Once the game ends, we record this in a new field, `isGameOver`, in `class Game`.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦游戏结束，我们就在`class Game`中的新字段`isGameOver`中记录这一点。
- en: This new field will need to be set whenever the game ends. We will need more
    tests to drive that behavior out.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个新字段将在游戏结束时需要被设置。我们需要更多的测试来驱动这种行为。
- en: We will use a simple error-reporting mechanism – a new field, `isError`, in
    `class GuessResult`.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的错误报告机制——在`class GuessResult`中添加一个新字段`isError`。
- en: 'This leads to a bit of automated refactoring to add the fourth parameter to
    the `class Game` constructor. Then, we can add code to make the test pass:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一些自动重构，以向`class Game`构造函数添加第四个参数。然后，我们可以添加代码来使测试通过：
- en: '[PRE215]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'The design decision here is that as soon as we fetch the `Game` object, we
    check whether the game was previously marked as being over. If so, we report an
    error and we’re done. It’s simple and crude but adequate for our purposes. We
    also add a static constant, `GuessResult.ERROR`, for readability:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的设计决策是，一旦我们获取到`Game`对象，我们就检查游戏是否之前被标记为结束。如果是这样，我们就报告一个错误，然后结束。这很简单、很粗糙，但对我们来说足够了。我们还添加了一个静态常量`GuessResult.ERROR`以提高可读性：
- en: '[PRE216]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'One consequence of this design decision is that we must update `GameRepository`
    whenever the `Game.isGameOver` field changes to `true`. An example of one of these
    tests is this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这一设计决策的一个后果是，每当`Game.isGameOver`字段变为`true`时，我们必须更新`GameRepository`。这些测试中的一个例子如下：
- en: '[PRE217]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Here is the production code to add that recording logic:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是添加记录逻辑的生产代码：
- en: '[PRE218]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: We need another test to drive out the recording of game over when we run out
    of guesses. That will lead to a change in the production code. Those changes can
    be found in GitHub at the link given at the start of this chapter. They are very
    similar to the ones made previously.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个测试来驱动当我们用完猜测时记录游戏结束。这将导致生产代码的变化。这些变化可以在本章开头给出的链接在GitHub上找到。它们与之前所做的非常相似。
- en: Finally, let’s review our design and see whether we can improve it still further.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回顾我们的设计，看看我们是否还能进一步改进它。
- en: Reviewing our design
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查我们的设计
- en: We’ve been making small, tactical refactoring steps as we write the code, which
    is always a good idea. Like gardening, it is far easier to keep the garden tidy
    if we pull up weeds before they grow. Even so, it is worth taking a holistic look
    at the design of our code and tests before we move on. We may never get the chance
    to touch this code again, and it has our name on it. Let’s make it something that
    we are proud of and that will be safe and simple for our colleagues to work with
    in the future.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写代码的同时，一直在进行小的、战术性的重构步骤，这始终是一个好主意。就像园艺一样，如果我们能在杂草生长之前拔掉它们，保持花园整洁就更容易了。即便如此，在我们继续前进之前，审视一下我们代码和测试的设计是值得的。我们可能再也没有机会触摸这段代码了，而且它上面有我们的名字。让我们让它成为我们引以为豪的东西，并且在未来让我们的同事能够安全简单地与之合作。
- en: 'The tests we’ve already written enable us great latitude in refactoring. They
    have avoided testing specific implementations, instead testing desired outcomes.
    They also test larger units of code – in this case, the domain model of our hexagonal
    architecture. As a result, without changing any tests, it is possible to refactor
    our `class Wordz` to look like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写的测试使我们能够在重构时有很大的灵活性。它们避免了测试特定的实现，而是测试了期望的结果。它们还测试了更大的代码单元——在这种情况下，我们的六边形架构的领域模型。因此，在不更改任何测试的情况下，我们可以重构我们的`class
    Wordz`，使其看起来像这样：
- en: '[PRE219]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Our refactored `assess()` method now looks like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构后的`assess()`方法现在看起来是这样的：
- en: '[PRE220]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'That’s looking simpler. The `class GuessResult` constructor code now stands
    out as being particularly ugly. It features the classic anti-pattern of using
    multiple Boolean flag values. We need to clarify what the different combinations
    actually mean, to simplify creating the object. One useful approach is to apply
    the static constructor idiom once more:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更简单了。现在`class GuessResult`构造函数的代码显得特别丑陋。它具有使用多个布尔标志值的经典反模式。我们需要明确不同的组合实际上意味着什么，以简化对象的创建。一个有用的方法是一次再次应用静态构造函数习惯用法：
- en: '[PRE221]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'This simplifies the `assess()` method by eliminating the need to understand
    that final Boolean flag:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了 `assess()` 方法，消除了理解最终布尔标志的需要：
- en: '[PRE222]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Another improvement to aid understanding concerns creating new instances of
    `class Game`. The `rejectsGuessAfterGameOver()` test uses Boolean flag values
    in a four-argument constructor to set the test up in a game-over state. Let’s
    make the goal of creating a game-over state explicit. We can make the `Game` constructor
    private, and increase the visibility of the `end()` method, which is already used
    to end a game. Our revised test looks like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项改进是为了帮助理解，涉及创建 `class Game` 的新实例。`rejectsGuessAfterGameOver()` 测试使用四个参数构造函数中的布尔标志值来设置测试在游戏结束状态。让我们使创建游戏结束状态的目标明确化。我们可以将
    `Game` 构造函数设为私有，并提高 `end()` 方法的可见性，该方法已经被用来结束游戏。我们的修订测试看起来是这样的：
- en: '[PRE223]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The Arrange step is now more descriptive. The four-argument constructor is no
    longer accessible, steering future development to use the safer, more descriptive
    static constructor methods. This improved design helps prevent defects from being
    introduced in the future.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 安排步骤现在更具描述性。四个参数的构造函数不再可访问，引导未来的开发使用更安全、更具描述性的静态构造函数方法。这种改进的设计有助于防止未来引入缺陷。
- en: 'We have made great progress in this chapter. Following these final refactoring
    improvements, we have an easily readable description of the core logic of our
    game. It is fully backed by FIRST unit tests. We have even achieved a meaningful
    100% code coverage of lines of code executed by our tests. This is shown in the
    IntelliJ code coverage tool:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中取得了巨大的进步。在完成这些最终的重构改进之后，我们得到了一个易于阅读的游戏核心逻辑描述。它完全由 FIRST 单元测试支持。我们甚至实现了对测试执行代码行的有意义的
    100% 代码覆盖率。这可以在 IntelliJ 代码覆盖率工具中看到：
- en: '![Figure 13.6 – Code coverage report](img/Figure_13.6_B18384.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 代码覆盖率报告](img/Figure_13.6_B18384.jpg)'
- en: Figure 13.6 – Code coverage report
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 代码覆盖率报告
- en: That’s the core of our game finished. We can start a new game, play a game,
    and end a game. The game can be developed further to include features such as
    awarding a points score based on how quickly the word was guessed and a high score
    table for players. These would be added using the same techniques we have been
    applying throughout this chapter.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们游戏的核心部分就完成了。我们可以开始新游戏，玩游戏，结束游戏。游戏可以进一步开发，包括基于单词猜测速度的得分奖励和玩家高分榜等功能。这些功能将使用我们在本章中一直应用的技术添加。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve covered a lot of ground in this chapter. We have used TDD to drive out
    the core application logic for our Wordz game. We have taken small steps and used
    triangulation to steadily drive more details into our code implementation. We
    have used hexagonal architecture to enable us to use FIRST unit tests, freeing
    us from cumbersome integration tests with their test environments. We have employed
    test doubles to replace difficult-to-control objects, such as the database and
    random number generation.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了大量的内容。我们使用了 TDD 来驱动 Wordz 游戏的核心应用逻辑。我们采取了小步骤，并使用三角测量法稳步地将更多细节引入到我们的代码实现中。我们使用了六边形架构，使我们能够使用
    FIRST 单元测试，从而摆脱了繁琐的集成测试及其测试环境。我们使用了测试替身来替换难以控制的对象，例如数据库和随机数生成。
- en: We built up a valuable suite of unit tests that are decoupled from specific
    implementations. This enabled us to refactor the code freely, ending up with a
    very nice software design, based on the SOLID principles, which will reduce maintenance
    efforts significantly.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建立了一套宝贵的单元测试套件，这些测试与特定的实现解耦。这使得我们能够自由地重构代码，最终得到一个非常优秀的软件设计，基于 SOLID 原则，这将显著减少维护工作量。
- en: We finished with a meaningful code coverage report that showed 100% of the lines
    of production code were executed by our tests, giving us a high degree of confidence
    in our work.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个有意义的代码覆盖率报告结束，该报告显示生产代码的 100% 行都被我们的测试执行，这让我们对我们的工作有了很高的信心。
- en: Next, in [*Chapter 14*](B18384_14.xhtml#_idTextAnchor293), *Driving the Database
    Layer*, we will write the database adapter along with an integration test to implement
    our `GameRepository`, using the Postgres database.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在[*第 14 章*](B18384_14.xhtml#_idTextAnchor293) *驱动数据库层*中，我们将编写数据库适配器以及一个集成测试来实现我们的
    `GameRepository`，使用的是 Postgres 数据库。
- en: Questions and answers
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: Does every method in every class have to have its own unit test?
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个类中的每个方法都必须有自己的单元测试吗？
- en: No. That seems to be a common view, but it is harmful. If we use that approach,
    we are locking in the implementation details and will not be able to refactor
    without breaking tests.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 不。这似乎是一个常见的观点，但这是有害的。如果我们采用这种方法，我们将锁定实现细节，并且无法在不破坏测试的情况下进行重构。
- en: What is the significance of 100% code coverage when running our tests?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行测试时，100%的代码覆盖率有什么意义？
- en: Not much, by itself. It simply means that all the lines of code in the units
    under the test were executed during the test run. For us, it means a little more
    due to our use of test-first TDD. We know that every line of code was driven by
    a meaningful test of behavior that is important to our application. Having 100%
    coverage is a double-check that we didn’t forget to add a test.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 本身并不多。它仅仅意味着在测试运行期间，测试单元中的所有代码行都已被执行。对于我们来说，由于我们使用的是测试驱动开发（TDD），这意味着更多。我们知道每一行代码都是由一个对我们应用程序重要的行为测试所驱动的。拥有100%的覆盖率是一个双重检查，确保我们没有忘记添加测试。
- en: Does 100% code coverage during the test run mean we have perfect code?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试运行期间100%的代码覆盖率是否意味着我们拥有完美的代码？
- en: No. Testing can only reveal the presence of defects, never their absence. We
    can have 100% coverage with very low-quality code in terms of readability and
    edge case handling. It is important to not attach too much importance to code
    coverage metrics. For TDD, they serve as a cross-check that we haven’t missed
    any boundary condition tests.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 不。测试只能揭示缺陷的存在，而不能揭示它们的缺失。在可读性和边缘情况处理方面，我们可以有100%的覆盖率，但代码质量可能很低。不要过分重视代码覆盖率指标。对于TDD来说，它们作为交叉检查，确保我们没有遗漏任何边界条件测试。
- en: Is all this refactoring normal?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些重构是否正常？
- en: Yes. TDD is all about rapid feedback loops. Feedback helps us explore design
    ideas and change our minds as we uncover better designs. It frees us from the
    tyranny of having to understand every detail – somehow – before we start work.
    We discover a design by doing the work and have working software to show for it
    at the end.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。测试驱动开发（TDD）全部关于快速反馈循环。反馈帮助我们探索设计想法，并在我们发现更好的设计时改变主意。它使我们免于在开始工作之前必须理解每个细节的暴政。我们通过做工作来发现设计，并在结束时展示出有实际工作的软件。
- en: Further reading
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'AssertJ documentation – read more about the various kinds of assertion matchers
    built into AssertJ, as well as details on how to create custom assertions here:
    [https://assertj.github.io/doc/](B18384_13.xhtml#_idTextAnchor291).'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AssertJ 文档 – 了解更多关于 AssertJ 内置的各种断言匹配器，以及如何创建自定义断言的详细信息，请参阅：[https://assertj.github.io/doc/](B18384_13.xhtml#_idTextAnchor291)。
- en: '*Refactoring – Improving the Design of Existing Code*, Martin Fowler (first
    edition), ISBN 9780201485677:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构 – 改进现有代码的设计*，马丁·福勒（第一版），ISBN 9780201485677：'
- en: The bulk of our work in TDD is refactoring code, continuously providing a good-enough
    design to support our new features. This book contains excellent advice on how
    to approach refactoring in a disciplined, step-by-step way.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试驱动开发（TDD）中，我们的大部分工作是对代码进行重构，持续提供足够好的设计以支持我们的新功能。这本书提供了关于如何以纪律性、分步骤的方式进行重构的极好建议。
- en: The first edition of the book uses Java for all its examples, so is more useful
    to us than the JavaScript-based second edition.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的初版使用Java作为所有示例，因此对我们来说比基于JavaScript的第二版更有用。
- en: '*Design Patterns – Elements of Reusable Object-Oriented Software*, Gamma, Helm,
    Vlissides, Johnson, ISBN 9780201633610:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计模式 – 可复用面向对象软件元素*，Gamma, Helm, Vlissides, Johnson，ISBN 9780201633610：'
- en: A landmark book that cataloged common combinations of classes that occur in
    object-oriented software. Earlier in the chapter, we used a controller class.
    This is described as a façade pattern, in the terms of this book. The listed patterns
    are free of any kind of framework or software layer and so are very useful in
    building the domain model of hexagonal architecture.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 一本里程碑式的书籍，记录了在面向对象软件中常见的类组合。在章节的早期，我们使用了控制器类。这本书将其描述为外观模式。列出的模式不包含任何类型的框架或软件层，因此在构建六边形架构的领域模型时非常有用。
