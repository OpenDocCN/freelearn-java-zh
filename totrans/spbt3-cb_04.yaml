- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern systems, you may find several microservices interacting with each
    other. Spring Cloud offers easy-to-deploy components that simplify the interaction
    and coordination of distributed systems to tackle large-scale application challenges
    such as scalability, availability, observability, and resilience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use Spring Cloud components to develop
    a scalable and resilient distributed system. You will build upon the learnings
    of the previous chapters and configure security and observability in this Spring
    Cloud setup. This will help you effectively monitor and troubleshoot your distributed
    architecture. By the end of this journey, you will know how to design and develop
    cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will be taught how to deploy Spring Boot Admin, a widely used open
    source project in the Spring ecosystem. This project offers a user-friendly web
    interface that enables you to monitor and manage multiple Spring Boot applications
    centrally. Additionally, it can be effortlessly integrated with other Spring Cloud
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Eureka Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating an application in Eureka Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling out the RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Spring Cloud Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting Spring Cloud Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating distributed tracing with Spring Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Spring Boot Admin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires some services to be running on your computer, such as
    OpenZipkin. As usual, the easiest way to run them on your computer is by using
    Docker. You can get Docker from the Docket product page at https://www.docker.com/products/docker-desktop/.
    I will explain how to deploy each tool in its corresponding recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The *Setting up Spring Cloud Config* recipe requires a git repository. You can
    create a GitHub account for free ([https://github.com/join](https://github.com/join)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for all the recipes in this chapter here: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter4](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter4).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Eureka Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eureka Server is a service registry that’s used in microservices architectures
    to register instances that other applications can discover. It’s a valuable service
    that allows services to locate and communicate with each other dynamically. This
    service registry performs health checks on the registered services’ instances,
    automatically removing the unhealthy or unresponsive ones. When a service needs
    to communicate with another service, Eureka Server provides the available instances,
    allowing load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create an application that implements
    Eureka Server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe doesn’t have any additional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll create a new Eureka Server that we’ll reuse in the rest
    of the recipes. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create a new application for Eureka Server. For that, open [https://start.spring.io](https://start.spring.io)
    and use the same parameters that you did in the *Creating a RESTful API* recipe
    of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except change the following
    options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `registry`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Eureka Server**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, in the generated project, in the `resources` folder, create a file named
    `application.yml` and set the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open the `RegistryApplication` class and annotate it with `@EnableEurekaServer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can start the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s verify that Eureka Server is running. Open `http://locahost:8761` in
    your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1: Eureka Server](img/B21646_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Eureka Server'
  prefs: []
  type: TYPE_NORMAL
- en: On the Eureka Server page, you can see general information about the server
    and, most importantly, the applications registered on the server. Now, we don’t
    have any applications registered yet. Once we connect the applications in the
    following recipes, we will see them under **Instances currently registered** **with
    Eureka**.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Eureka Server dependency in a Spring Boot application allows you to set
    up and run a service registry. When you use the `@EnableEurekaServer` annotation,
    the Eureka Server autoconfiguration is activated. The Eureka Server application
    must be configured so that it can stop itself from being registered as a service,
    which is why the `eureka.client.registerWithEureka` and `eureka.client.fetchRegistry`
    settings are both set to `false`. The other required Eureka Server configuration
    is the port. We configured Eureka Server to listen on port `8761`.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating an application in Eureka Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll integrate two applications into Eureka Server, which we
    deployed in the previous recipe. One application provides football data, which
    the other application consumes. We’ll use Eureka Server to register both applications,
    at which point the consumer will use Eureka Server to discover the provider application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to Eureka Server, which we deployed in the previous recipe, we’ll
    reuse the applications we created in the *Defining responses and data model exposed
    by the API* and *Consuming a RESTful API from another Spring Boot application*
    recipes in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a starting point, you can use the applications that I’ve prepared in this
    book’s repository: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
    You can find the code in the `chapter4/recipe4-2/start` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll integrate the `football` and `albums` applications from the *Consuming
    a RESTful API from another Spring application using RestClient* recipe in [*Chapter
    1*](B21646_01.xhtml#_idTextAnchor020), into Eureka Server, which we deployed in
    the previous recipe. Let’s make the required adjustments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will modify the applications so that they connect to the Eureka Server
    instance. We will start with the `football` application. Make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following dependencies to the `pom.xml` file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure the `pom.xml` file has configured dependency management for Spring Cloud:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that the `spring-cloud.version` property is defined in the `pom.xml`
    file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `resources` folder, add a file named `application.yml` with the following
    content:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Start the `football` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, you’ll be able to see the application registered in Eureka Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2: The RESTful application registered in Eureka Server](img/B21646_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The RESTful application registered in Eureka Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify the RESTful API `albums` consumer application by making the following
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `org.springframework.cloud:spring-cloud- starter-netflix-eureka-client`
    and `org.springframework.cloud:spring-cloud-starter-openfeign` dependencies to
    the `pom.xml` file:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `AlbumsApplication.` class, add the `@``EnableDiscoveryClient` annotation:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `resources` folder, add an `application.yml` file with the following
    configuration:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '@FeignClient("FootballServer")'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: public interface FootballClient {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '@RequestMapping(method = RequestMethod.GET, value = "/players")'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: List<Player> getPlayers();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that we no longer use the remote RESTful API server address, just the application
    name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you can run the `albums` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you can test the entire deployment. For that, execute the following
    `curl` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The consumer application will discover which instances of the server application
    are available by asking Eureka Server, after which point it will call the server
    application and return the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up the client connection to Eureka Server, it is necessary to add the
    `org.springframework.cloud:spring-cloud-starter-openfeign` and `org.springframework.cloud:spring-cloud-starter-netflix-eureka-client`
    dependencies and configure the connection to Eureka Server. The configuration
    on the client side consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eureka.client.serviceUrl.defaultZone`: This is the address of Eureka Server.
    In our case, this is `http://localhost:8761/eureka`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.appication.name`: This is the name that can be used to discover the
    service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenFeign and Eureka clients use Eureka Server to discover instances of a service.
    Remember that in the `@OpenFeignClient` configuration, we used the server application
    name instead of a server address. The OpenFeign client connects to Eureka Server,
    requests the instances that have been registered for that service, and returns
    one.
  prefs: []
  type: TYPE_NORMAL
- en: For clients, this is more straightforward as knowing the address where the server
    instances will be hosted in advance is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: The discovery mechanism is also very convenient for server applications as they
    don’t need to be hosted in a predefined server and port. You probably noticed
    that the RESTful API server was configured with `server.port=0`, which means it
    will start in a random port. The server address and port are stored when it’s
    registered in Eureka Server. When the consumer application asks for Eureka Server,
    it returns information about the registered instance – that is, the server address
    and port. This feature is helpful as we run our applications locally and we don’t
    need to care about which port we are running each instance on. In previous recipes,
    we started one application on port `8080` and another on `8081`. In the *Scaling
    out the RESTful API service* recipe, we will see that it is possible to have more
    than one instance of a given service.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A key feature of Eureka Server is detecting unhealthy or unresponsive application
    instances and removing them from the registry. This feature requires that registered
    services use **Actuator**. Spring Actuator provides production-ready features
    that help you monitor and manage your Spring applications. It’s particularly useful
    for microservices and other distributed systems, where operational visibility
    and management are critical. You can include the Actuator dependency in your projects
    by applying the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find more information about Actuator on the project page: [https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling out the RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaling out is a technique that improves the availability and capacity of a
    system by adding multiple instances for a given service.
  prefs: []
  type: TYPE_NORMAL
- en: In modern application platforms, such as container orchestrators such as Kubernetes
    or cloud providers hosting platforms such as Azure App Services or AWS Elastic
    Beanstalk, the systems may scale out and scale in automatically. For instance,
    in Kubernetes, you can configure an autoscale rule that increases the number of
    instances of your service when the average CPU has been over 70% for the last
    5 minutes. You can also configure it in another way – when the usage of your application
    is low, you can scale in your application. This means you can decrease the number
    of instances of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling out an application shouldn’t necessarily be automated; you can scale
    it manually, as we’ll do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling out involves distributing incoming requests across multiple instances
    of a service. In this recipe, we will learn how to use Eureka Server capabilities
    to register and discover instances to distribute the requests across available
    service instances.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the services we utilized in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eureka Server**: This service will act as a service registry and provide
    service discovery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RESTful API**: This will provide a service to be consumed by the client application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client application**: This will consume the RESTful API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven’t completed the previous recipe, you can find the completed exercise
    in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code to start this recipe in the `chapter4/recipe4-3/start`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will modify the RESTful API so that it returns the service instance’s information.
    That way, we can validate that the requests are balanced among available instances.
    Then, we will execute more than one instance of the RESTful API. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the RESTful API project, modify the `application.yml` file in the `resources`
    folder by adding the following property at the beginning of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The file should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@RequestMapping("/serviceinfo")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@RestController'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class ServiceInformationController {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Value("${football.instanceId}")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private String instanceId;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@GetMapping'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public String getInstanceId() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return instanceId;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute three instances of the RESTful API. Instead of using `mvnw spring-boot:run`,
    we will build the JAR file and execute it using the Java runtime. To do this,
    follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the root folder of the project, build the application using the following
    command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, open three Terminals and execute the following command in all of them:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open Eureka Server at `localhost:8761`. You’ll see three instances of the RESTful
    API service:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3: Eureka Server with three instances of FootballServer running](img/B21646_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Eureka Server with three instances of FootballServer running'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the client application project, make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `FootballClient` class, add the following method:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `AlbumsController` controller, add the following method:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start the client application and test the application multiple times.
    You can do that by executing the following `curl` request several times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see that the results change when you execute the previous command
    multiple times:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.4: Results of executing the RESTful API from the client application](img/B21646_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Results of executing the RESTful API from the client application'
  prefs: []
  type: TYPE_NORMAL
- en: The client application distributes requests across Eureka Server’s registered
    service instances, resulting in different outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the Eureka client starts, it registers itself in Eureka Server. The registration
    details include the service name and network location. After the registration
    process, the client sends heartbeats to inform the server that it is still alive.
    In this exercise, we initiated three instances of the RESTful API server with
    the same service name; each of the instances had a separate network location.
  prefs: []
  type: TYPE_NORMAL
- en: The Feign client in the consumer application uses Eureka Server to discover
    the available instances of the RESTful API server application. In that way, it
    can balance the request across the service instances.
  prefs: []
  type: TYPE_NORMAL
- en: Just for demonstration purposes, we added a configuration setting, `football.InstanceId`,
    with a unique random value to distinguish the service instance. To retrieve that
    configuration, we used the `@Value` annotation. Spring Boot injected the value
    when the application was started.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating complex applications with different services, we don’t want to
    expose all those services to consumer applications so that we can avoid unnecessary
    complexity exposure. To address this scenario, we can use **Spring Cloud Gateway**.
    Spring Cloud Gateway can be deployed in such a way that it’s the only component
    that’s accessible to consumer applications, while the rest of the services will
    be accessed either internally or just from Spring Cloud Gateway. This is illustrated
    in *Figure 4**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: A typical Spring Cloud Gateway deployment](img/B21646_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: A typical Spring Cloud Gateway deployment'
  prefs: []
  type: TYPE_NORMAL
- en: A note on deployment
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the complexity and requirements of the solution, I recommend using
    additional networking protections, such as Layer 7 load balancers, **web application
    firewalls** (**WAFs**), or other protection mechanisms. For learning purposes,
    I will not describe them in this book and focus on Spring and Spring Cloud mechanisms
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the role of an API gateway offering a unique entry point for
    the application, Spring Cloud Gateway has interesting benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load balancing**: It can balance requests across the available service instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic routing**: Spring Cloud Gateway can be integrated with a service
    registry, such as Eureka Server, and dynamically route requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: It can apply authentication and authorization using authentication
    providers, such as Spring Security and OAuth2, and propagate to downstream services.
    You can do this in a single place if you need to configure CORS for your consumer
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSL termination**: You can configure Spring Cloud Gateway to terminal SSL/TLS
    connections and pass unencrypted traffic to the services. With this feature, you
    can offload the SSL/TLS decryption from the services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiting**: You can implement rate limiting to prevent your services
    from being abused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request/response transformation**: You can use Spring Cloud Gateway to transform
    requests and responses – for instance, by adding requests or response headers.
    You can also convert payload formats, such as XML, into JSON. These transformations
    can be applied at the gateway level; hence, it is not necessary to modify your
    downstream services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breaking**: You can use Spring Cloud Gateway to implement circuit
    breakers to handle failures gracefully. For instance, you can prevent requests
    from being sent to an unhealthy service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some added benefits are *request filtering*, *global exception handling*, *logging
    and monitoring*, and *path Rewriting*.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend visiting the project page at https://spring.io/projects/spring-cloud-gateway
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will deploy an instance of Spring Cloud Gateway and integrate
    it with Eureka Server, which we deployed in previous recipes, to route requests
    to registered services.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the projects we implemented in previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eureka Server**: This service will act as a service registry and provide
    service discovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`football` application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`album` application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven’t completed the previous recipe, you can find the completed exercise
    in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook.
    The code to start this recipe can be found in the `chapter4/recipe4-4/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s deploy a Spring Cloud Gateway. We will configure Gateway so that it exposes
    some functionality of the RESTful API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://start.spring.io](https://start.spring.io) and use the same parameters
    that you did in the *Creating a RESTful API* recipe, except change the following
    options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `gateway`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Gateway** and **Eureka** **Discovery Client**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the project you’ve downloaded, create a file in the `resources` folder named
    `application.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can run the gateway application. One important thing to note is that
    the other application should be running as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the gateway by executing the following request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see the RESTful API’s results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s add a new method in the other RESTful API applications in `Albums`
    and then add it as a new route in Spring Cloud Gateway. So, open the `AlbumsController`
    controller and add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same project, open the `application.yml` file and add the following
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a new route in the Spring Cloud Gateway configuration. For that, open
    the `application.yml` file of the Spring Cloud Gateway project and add the following
    highlighted text. I’ve added the entire configuration file for clarity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart Spring Cloud Gateway and test the new route by executing the following
    `curl` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you should see the response of the second RESTful API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we connected Spring Cloud Gateway to Eureka Server. For that,
    we only needed to include the Eureka discovery client and its configuration –
    that is, `eureka.client.serviceUrl.defaultZone property` in the `application.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Once connected to Eureka Server, we configured a couple of routings. A routing
    definition specifies a combination of criteria and actions to be taken when a
    request matches the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'We established the criteria for route definition by employing predicates. Specifically,
    we configured two routes: one using the `/api/players/**` path pattern and the
    other using `/api/albums/**`. This configuration dictates that the first route
    will match requests starting with `/api/player`, while the second route will match
    requests commencing with `/api/albums`. For example, a request such as `http://localhost:8080/api/player`
    would match the first route. Beyond the request path, you can utilize other request
    properties, such as headers, query parameters, or the request host.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the target services expect the requests as `/players` in one case and
    `/albums` in the other, without `/api` in both cases, removing this part of the
    path is necessary. We configured this using the `StripPrefix=1` filter, which
    removed the first part of the path.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, those routes needed to hit a target service, so we configured this
    using the `uri` property. We could have used the DNS host and port, something
    like `http://server:8081`, but instead, we used `lb://servicename`. Using this
    approach, we configured Spring Cloud Gateway to discover the target service using
    Eureka and leverage client-side load balancing. We deployed all our services locally,
    and the only way to distinguish each instance is by dynamically assigning each
    service a port.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To assign a port dynamically, we set the `server.port=0` property.
  prefs: []
  type: TYPE_NORMAL
- en: If the hosting environment provides an alternative balancing method, it is acceptable
    to use it. For instance, in a Kubernetes environment, you can create a deployment
    for your service with multiple running instances. By doing this, your service
    can be discovered through Kubernetes DNS, and the underlying infrastructure will
    balance requests.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I recommend reading Spring Cloud Gateway documentation, which you can find
    here: [https://spring.io/projects/spring-cloud-gateway](https://spring.io/projects/spring-cloud-gateway).
    Familiarize yourself with routing capabilities and understand how to configure
    your routes using all the properties that are available in the requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Circuit Breaker is also an interesting design pattern that can be very useful
    for handling failures gracefully. If you are unfamiliar with this pattern, I recommend
    looking at this *Azure Cloud Design Patterns* article: [https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker](https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker).
    The good news is that this pattern is relatively easy to implement using Spring
    Cloud Gateway – see [https://spring.io/guides/gs/gateway/](https://spring.io/guides/gs/gateway/)
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the Spring Cloud Gateway rules are processed at runtime, they can sometimes
    be difficult to test. In addition to the rules themselves, the target applications
    must be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to test Spring Cloud Gateway using the *Spring
    Cloud Contract Stub Runner* starter, which emulates the target services using
    the Wiremock library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll create tests for the Spring Cloud Gateway project we set
    up in the previous recipe. I’ve prepared a working version of Spring Cloud Gateway
    in case you haven’t set it up yet. You can find it in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
    The code to start this recipe can be found in the `chapter4/recipe4-5/start` folder.
    I’ve added all the projects that were used in the previous recipe – that is, the
    `football`, the `albums`, and the `gateway` projects – but we’ll only be using
    `gateway` here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll adjust the gateway project to allow for test execution.
    Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll add the *Spring Cloud Contract Stub Runner* starter. For that,
    add the following dependency in the `gateway` project’s `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this dependency is used for testing purposes only.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, modify the `application.yml` configuration to parameterize the destination
    URIs. Replace the addresses in `spring.cloud.gateway.routes.uri` so that they
    use a configuration parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before creating our first test, we need to set up the test class. Let’s create
    a new class named `RoutesTests` in the `test` folder. To set it up, you must do
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the class with `@AutoConfigureWireMock(port =` `0)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate the class with `@SpringBootTest` using the `properties` field to pass
    the destination URIs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `WebTestClient` field that the Spring Boot tests context will inject
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The skeleton of this class should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create our first test. We’ll add a new method annotated with `@Test`
    to check the `players` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the method `playersRouteTest`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, arrange the response of the target server when calling the `/players`
    path. We’ll use the Wiremock library:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can call Spring Cloud Gateway by using `WebTestClient` and assert that
    it’s working as expected:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can test the `albums` route using the same approach. This book’s GitHub
    repository contains more tests for Spring Cloud Gateway: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When configuring the Spring Cloud Gateway project, two dependencies need to
    be considered: Eureka Server and the target RESTful API. However, the main purpose
    is to verify the Gateway routes during testing. To achieve this, we removed the
    dependency on Eureka Server and allowed the target RESTful API URI to be configured.
    By using the `${key:default}` notation in *Step 2*, we created a fallback mechanism
    that uses the configured value for the load balancer address. If no value is provided,
    then it defaults to the original URI. This notation specifies that if the key
    is provided, then it uses that key; otherwise, it uses the default value specified
    after the colon symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the configuration mechanism described previously and the Wiremock provided
    by the *Spring Cloud Contract Stub Runner* starter, we configured the address
    of the remote RESTful APIs, considering that the Wiremock server is running on
    localhost and the port is provided by the Wiremock server. In the `@AutoConfigureWireMock`
    annotation, we used port `0` to ensure the port is assigned randomly. Then, using
    `${wiremock.server.port}`, we retrieved the assigned port.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the test follows the same mocking mechanism that we explained in
    the *Mocking a RESTful API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020).
    Note that the mocked RESTful API responds to `/players`, while the test requests
    `/api/players`. In this test, we want to validate that the Spring Cloud Gateway
    configuration is correct, so when making a request to `/api/players`, it redirects
    the call to the target API on the `/players` path. So long as the test is implemented
    correctly and Spring Cloud Gateway is configured properly, the test should pass
    without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud Config enables centralized configuration management for applications,
    allowing you to store configuration properties in a central repository and distribute
    them to connected services.
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides the following features, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows version control configurations – for instance, using git as a backend
    to store the configuration. With this feature, you can track changes and audit
    configurations, and facilitate performing rollbacks to previous versions when
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables dynamic configuration updates with no need to restart services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It externalizes the configuration; hence, it is possible to make configuration
    changes without modifying or redeploying the services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will deploy a configuration server and connect our existing
    RESTful APIs to the configuration service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Git repository. I recommend using GitHub as
    this recipe has been tested and validated with this service, but I don’t foresee
    any issue if you use another git provider. If you want to use GitHub and don’t
    have an account yet, visit [https://github.com](https://github.com). You will
    also need a git client.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will reuse the RESTful APIs that we configured in the previous recipe. These
    are the services we must configure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`football` (RESTful API)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`albums` (RESTful API)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you haven’t completed the previous recipe yet, you can use the completed
    recipe in this book’s GitHub repository: https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook.'
  prefs: []
  type: TYPE_NORMAL
- en: The code to start this recipe can be found in the `chapter4/recipe4-6/start`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll create a new service using Spring Initializr to host
    Spring Cloud Config. Next, we’ll configure the service to use a GitHub repository
    as a backend. Finally, we’ll connect existing services to the Config server. Let’s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://start.spring.io](https://start.spring.io) and use the same parameters
    that you did in the *Creating a RESTful API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    except changing the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `config`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Config Server**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a GitHub repository in your GitHub account. Since we won’t be managing
    anything secretive, the repository can be public. Name it `spring3-recipes-config`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the repository on your computer. To do that, open a Terminal and execute
    the following command, replacing `felipmiguel` with your GitHub account’s name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create `spring3-recipes-config` as the root folder for that repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the following steps, we will create files in that folder that will later
    be pushed to GitHub’s central repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the root folder of the configuration repository, create the following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`application.yml`, with the following content:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`gatewayserver.yml`, with the following content:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, push the files to `github.com`. To do this, execute the following commands
    in your Terminal in the repository root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure your repository as the backend of the Config service. For this, go
    to the Config Service project and add a file named `application.yml` in the `resources`
    folder with the following content (make sure you replace `[your account]` with
    your GitHub account’s name):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@EnableConfigServer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@SpringBootApplication'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class ConfigApplication
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can start the Config server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, modify the projects so that you can connect to the Config server. To
    do so, follow these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add dependencies to the `pom.xml` file for all the applications we want to
    connect to the Config server. These applications are `football`, `album`, `registry`,
    and `gateway`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the `application.yml` file for all the applications we want to connect
    to the Config server. All of them will contain the Config server configuration
    and the respective application’s name. For instance, the `album` service will
    look like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `football` service (the RESTful API service), set the following content:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `gateway` service, set the following content:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now, it’s time to verify that everything is working. Let’s start all services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the services by executing a request to Spring Cloud Gateway:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Validate that it returns a JSON file containing a list of players.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Boot provides an extensible mechanism to load the configuration from
    external sources using the `spring.config.import` setting. Adding the `org.springframework.cloud:spring-cloud-starter-config`
    dependency registers an extension that can retrieve the configuration from a config
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the configuration server, the only requirement is adding the `org.springframework.cloud:spring-cloud-config-server`
    dependency and enabling the configuration server using the `@EnableConfigServer`
    annotation. Enabling the configuration server exposes an endpoint that allows
    consumer applications to query for their configuration. The configuration endpoint
    exposes the following paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at each path fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application` is the application name that’s configured by the `spring.application.name`
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile` is the currently active profile. By default, the profile’s name is
    `default`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label` refers to a git branch; if not specified, it applies to the default
    branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our applications provide the following queries for the Config server:'
  prefs: []
  type: TYPE_NORMAL
- en: '`football`: As it contains the `spring.application.name=FootballServer` property,
    it requests `http://localhost:8888/FootballServer-default.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`albums`: Its application name is `AlbumsServer`, so it requests `http://localhost:8888/AlbumsServer-default.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateway`: Its application name is `GatewayServer`, so it requests `http://localhost:8888/GatewayServer-default.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see the results by executing a request. For instance, for `GatewayServer`,
    you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze what the Config server did. The Config server resolves the configuration
    by merging the configurations it found in the git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: The base configuration starts with the `application.yml` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It merges the base configuration with a more specific configuration for the
    requested application. The more specific configuration is defined using a `[application
    name].yml` file, where `[application name]` is defined in the `spring.application.name`
    property. In our scenario, we haven’t defined specific configuration files for
    the `football` and `albums` applications, but we did define the `gatewayserver.yml`
    file for the `gateway` service. By doing this, `gateway` will merge the content
    of `application.yml` and `gatewayserver.yml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If settings are defined in multiple files, the most specific one is used. In
    this case, the settings defined by `gatewayserver.yml` will take precedence over
    the settings defined in `application.yml`. You can see this behavior for the `server.port`
    setting, which is specified in both files and takes the most specific one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In production environments, you probably want to protect your applications’
    configurations. For that reason, you must use a private git repository, your configuration
    service will require authentication, and your secrets, such as connection strings,
    will be encrypted. You can do all that using Spring Cloud Config. I recommend
    visiting the project page at [https://spring.io/projects/spring-cloud-gateway](https://spring.io/projects/spring-cloud-gateway)
    for details on the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Another exciting feature related to configuration is the possibility to dynamically
    refresh the configuration without restarting the application. You can achieve
    this by using Spring Actuator. We will revisit this topic in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We just used non-sensitive information in this recipe, but applications usually
    manage configurations we don’t want to disclose, such as database connection strings
    or credentials to access other systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first measure we should apply is removing public access to the configuration
    repository. We can use private repositories and configure the git credentials
    in the Config server like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To avoid storing sensitive information in a git repository, Spring Cloud Config
    has an extension to integrate with Vault services, such as Hashicorp Vault and
    Azure Key Vault. The configuration file that’s stored in the git repository contains
    references to secrets stored in the Vault service. The applications resolve the
    configuration, retrieving the referenced secrets from the Vault service.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the Spring Cloud Config quickstart guide at [https://docs.spring.io/spring-cloud-config/docs/current/reference/html/](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/)
    for more advanced scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating distributed tracing with Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the number of services composing the `football` application suite grew,
    you deployed the following Spring Cloud components: Spring Cloud Gateway, Eureka
    Server (a registry and discovery service), and Spring Cloud Configuration. You
    want to configure distributed tracing to monitor the transactions across microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will integrate distributed tracing with Actuator and OpenZipkin
    into a system composed of different application microservices and Spring Cloud
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will monitor distributed transactions using OpenZipkin. As explained in
    the *Implementing distributed tracing* recipe in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103),
    you can deploy an OpenZipkin server on your computer using Docker. For that, you
    can run the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You will reuse the outcome of the *Setting up Spring Cloud Config* recipe.
    I’ve prepared a working version in case you haven’t completed that recipe yet.
    You can find it in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter4/recipe4-7/start` folder. It includes the following projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config`: The Spring Cloud Config service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry`: The Spring Cloud registry and discovery service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateway`: Spring Cloud Gateway. It exposes the `football` and `albums` services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`football`: The `football` service, which provides information about teams
    and players.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`albums`: The `albums` service, which manages sticker albums. It uses the `football`
    service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s configure our Spring Cloud solution so that we can integrate distributed
    tracing with OpenZipkin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must add a dependency to Actuator, the Micrometer bridge to OpenTelemetry,
    and the exporter from OpenTelemetry to OpenZipkin to all projects. For that, add
    the following dependencies to all `pom.xml` project files, - that is, the `config`,
    `registry`, `gateway`, `football`, and `albums` projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `albums` project also makes some calls to the `football` project using
    the `OpenFeign` client. For that reason, you should also add the following dependencies
    to that project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s change the configuration to enable 100% sampling. Since we’re using
    a central config server, we can change the configuration in the repository that
    contains the configuration for all applications. In my case, that repository is
    hosted at [https://github.com/felipmiguel/spring3-recipes-config](https://github.com/felipmiguel/spring3-recipes-config).
    As the *Setting up Spring Cloud Config* recipe explains, you should replace `felipmiguel`
    with your GitHub account. In my repository, I added the following configuration
    to the `application.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can create a branch for this feature in the configuration repository. Once
    you’ve done this, you will need to modify the configuration in the client applications
    by adding the following setting in the client `application.yml` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, you should replace `<your branch name>` with the branch name you created
    in GitHub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now run the applications. You should start the `config` service first,
    then `registry`, at which point you can start all the rest in no specific order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s test the solution. You can run the following requests for testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, the request is initially handled by `gateway` and served by the
    `albums` service, which simultaneously calls the `football` service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you can see the traces in OpenZipkin. For that, open `http://localhost:9411`
    in your browser. Go to **Find a trace** to view the traces. You will see some
    traces that were initiated in the gateway. These are the ones you executed in
    *Step 5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6: Distributed traces for Spring Cloud](img/B21646_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Distributed traces for Spring Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: The other traces are from the applications synchronizing with Eureka Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the traces for `gatewayserver` with five spans – that is, the one
    corresponding to `/api/albums/players` – you will see that the `gateway` server
    called the `albums` server, which called the `football` server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Distributed tracing starting in the gateway server, which calls
    the albums service, which, in turn, calls the football service](img/B21646_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Distributed tracing starting in the gateway server, which calls
    the albums service, which, in turn, calls the football service'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the **Dependencies** section, you will see the dependencies between
    the microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: The dependencies between Spring Cloud microservices](img/B21646_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: The dependencies between Spring Cloud microservices'
  prefs: []
  type: TYPE_NORMAL
- en: This view is interesting in complex scenarios with different microservices calling
    each other when you need to understand the relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in the *Implementing distributed tracing* recipe in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103),
    just by adding Actuator and Micrometer dependencies, the applications send traces
    to the OpenZipkin server using the default configuration. The default configuration
    is `http://localhost:9411` for the OpenZipkin server and 10% of sampling. Sampling
    means that only a percentage of the traces is processed, so only 10% is processed
    by default. For demonstration purposes, we wanted to send 100% of the traces;
    for that reason, we took advantage of having a centralized configuration and only
    changed the `application.yml` file in the configuration repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `albums` application uses an `OpenFeign` client, which, by default, does
    not propagate the distributed traces as `WebClient.Builder` and `RestTemplateBuilder`
    do. Therefore, we needed to add two additional dependencies to `io.micrometer:micrometer-tracing`
    and `io.github.openfeign:feign-micrometer`. On the other hand, Spring Cloud Gateway
    uses `WebClient.Builder` to make requests to the downstream services. For that
    reason, the traces are created and propagated correctly from Spring Cloud Gateway
    with no additional configurations required.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Spring Boot Admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After deploying several microservices, you will appreciate having a single dashboard
    to monitor and manage all of them in one place. Spring Boot Admin is an open source
    community project that provides a web interface where you can manage and monitor
    Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will reuse the applications from the *Integrating distributed tracing with
    Spring Cloud* recipe. I’ve prepared a working version in case you haven’t completed
    that recipe yet. You can find it in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter4/recipe4-8/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to deploy a Spring Boot Admin server and ensure it connects to the
    discovery service to monitor and manage all applications. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new application for Spring Boot Admin using the *Spring Initializr*
    tool. Open [https://start.spring.io](https://start.spring.io) and use the same
    parameters that you did in the *Creating a RESTful API* recipe of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    except change the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `fooballadmin`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web**, **Codecentric’s Spring Boot Admin
    (Server)**, **Config Client**, and **Eureka** **Discovery Client**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, you must configure Spring Boot Admin. For that, add an `application.yml`
    file to the `resources` folder with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I’m using `spring.cloud.config.label` in this configuration. As I don’t want
    to mix the configuration from different recipes, I’ve created a new branch for
    the recipes in this chapter, the name of which is `distributed-tracing`. However,
    if you made all configurations in the same GitHub repository and the same branch,
    this setting is not necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is a required additional configuration, but it should be done in the
    central repository this time since we are using the Spring Cloud Config service.
    In my case, the configuration is saved at [https://github.com/felipmiguel/spring3-recipes-config](https://github.com/felipmiguel/spring3-recipes-config);
    you should replace `felipmiguel` with your GitHub account, as explained in the
    *Setting up Spring Cloud Config* recipe. As mentioned in the previous step, I
    prepared the changes in the `distributed-tracing` branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, expose Spring Boot Admin through Spring Cloud Gateway. To do so, create
    a new route in the `gatewayserver.yml` file, as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'management:'
  prefs: []
  type: TYPE_NORMAL
- en: 'endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'web:'
  prefs: []
  type: TYPE_NORMAL
- en: 'exposure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'include: health,env,metrics,beans,loggers,prometheus'
  prefs: []
  type: TYPE_NORMAL
- en: 'tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'sampling:'
  prefs: []
  type: TYPE_NORMAL
- en: 'probability: 1.0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '@SpringBootApplication'
  prefs: []
  type: TYPE_NORMAL
- en: '@EnableAdminServer'
  prefs: []
  type: TYPE_NORMAL
- en: '@EnableDiscoveryClient'
  prefs: []
  type: TYPE_NORMAL
- en: public class FootballadminApplication
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: <dependency>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <groupId>org.springframework.cloud</groupId>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependency>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <dependencyManagement>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <dependencies>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <dependency>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <groupId>org.springframework.cloud</groupId>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <artifactId>spring-cloud-dependencies</artifactId>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <version>${spring-cloud.version}</version>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <type>pom</type>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <scope>import</scope>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependency>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependencies>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependencyManagement>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <properties>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <spring-cloud.version>2022.0.4</spring-cloud.version>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </properties>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'eureka:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'client:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'serviceUrl:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'defaultZone: http://localhost:8761/eureka/'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'spring:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: football-api'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'server:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'port: 0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <dependency>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <groupId>org.springframework.boot</groupId>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependency>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: spring
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'security:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'oauth2:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resourceserver:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'jwt:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'audiences:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- football'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- football-ui'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'issuer-uri: http://localhost:9000'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'spring:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'cloud:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'gateway:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'routes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- id: teams'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'uri: lb://football-api'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'predicates:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Path=/football/**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cloud label.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: curl --location 'http://localhost:9000/oauth2/token' \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '--header ''Content-Type: application/x-www-form-urlencoded'' \'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --data-urlencode 'grant_type=client_credentials' --data-urlencode 'client_id=football'
    \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --data-urlencode 'client_secret=SuperSecret' --data-urlencode 'scope=football:read'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'curl --location http://localhost:8080/football/teams -H "Authorization: Bearer
    <access token> with the access token you obtained from the authorization server.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Part 2: Database Technologies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all applications need to persist and access data efficiently, and for
    that, Spring Boot offers many choices, from relational and NoSQL databases to
    repositories, templates, **Java Persistence Query Language** (**JPQL**), and native
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21646_05.xhtml#_idTextAnchor203), *Data Persistence and Relational
    Database Integration with Spring Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21646_06.xhtml#_idTextAnchor266), *Data Persistence and NoSQL
    Database Integration with Spring Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
