- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Spring Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud
- en: In modern systems, you may find several microservices interacting with each
    other. Spring Cloud offers easy-to-deploy components that simplify the interaction
    and coordination of distributed systems to tackle large-scale application challenges
    such as scalability, availability, observability, and resilience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代系统中，您可能会发现几个微服务相互交互。Spring Cloud提供了易于部署的组件，这些组件简化了分布式系统的交互和协调，以应对大规模应用程序的挑战，如可扩展性、可用性、可观察性和弹性。
- en: In this chapter, you will learn how to use Spring Cloud components to develop
    a scalable and resilient distributed system. You will build upon the learnings
    of the previous chapters and configure security and observability in this Spring
    Cloud setup. This will help you effectively monitor and troubleshoot your distributed
    architecture. By the end of this journey, you will know how to design and develop
    cloud-native applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Spring Cloud组件开发一个可扩展且具有弹性的分布式系统。您将基于前几章的学习内容，并在本Spring Cloud配置中配置安全和可观察性。这将帮助您有效地监控和排查您的分布式架构。到本章结束时，您将了解如何设计和开发云原生应用程序。
- en: Finally, you will be taught how to deploy Spring Boot Admin, a widely used open
    source project in the Spring ecosystem. This project offers a user-friendly web
    interface that enables you to monitor and manage multiple Spring Boot applications
    centrally. Additionally, it can be effortlessly integrated with other Spring Cloud
    components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将学习如何部署Spring Boot Admin，这是一个在Spring生态系统中被广泛使用的开源项目。该项目提供了一个用户友好的Web界面，使您能够集中监控和管理多个Spring
    Boot应用程序。此外，它可以轻松地与其他Spring Cloud组件集成。
- en: 'In this chapter, we’re going to cover the following main recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要菜谱：
- en: Setting up Eureka Server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Eureka Server
- en: Integrating an application in Eureka Server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Eureka Server中集成应用程序
- en: Scaling out the RESTful API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展RESTful API
- en: Setting up Spring Cloud Gateway
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Gateway
- en: Testing Spring Cloud Gateway
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Spring Cloud Gateway
- en: Setting up Spring Cloud Config
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Config
- en: Protecting Spring Cloud Gateway
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护Spring Cloud Gateway
- en: Integrating distributed tracing with Spring Cloud
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分布式跟踪与Spring Cloud集成
- en: Deploying Spring Boot Admin
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署Spring Boot Admin
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires some services to be running on your computer, such as
    OpenZipkin. As usual, the easiest way to run them on your computer is by using
    Docker. You can get Docker from the Docket product page at https://www.docker.com/products/docker-desktop/.
    I will explain how to deploy each tool in its corresponding recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要一些服务在您的计算机上运行，例如OpenZipkin。像往常一样，在您的计算机上运行它们的最简单方法是使用Docker。您可以从Docker产品页面https://www.docker.com/products/docker-desktop/获取Docker。我将在相应的菜谱中解释如何部署每个工具。
- en: The *Setting up Spring Cloud Config* recipe requires a git repository. You can
    create a GitHub account for free ([https://github.com/join](https://github.com/join)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*设置Spring Cloud Config*菜谱需要Git仓库。您可以通过免费创建GitHub账户来创建一个([https://github.com/join](https://github.com/join))。'
- en: 'You can find the code for all the recipes in this chapter here: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter4](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter4).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章所有菜谱的代码：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter4](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter4).
- en: Setting up Eureka Server
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Eureka Server
- en: Eureka Server is a service registry that’s used in microservices architectures
    to register instances that other applications can discover. It’s a valuable service
    that allows services to locate and communicate with each other dynamically. This
    service registry performs health checks on the registered services’ instances,
    automatically removing the unhealthy or unresponsive ones. When a service needs
    to communicate with another service, Eureka Server provides the available instances,
    allowing load balancing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka Server是一个服务注册中心，在微服务架构中用于注册其他应用程序可以发现的实例。这是一个非常有价值的服务，它允许服务动态地定位和相互通信。此服务注册中心对已注册服务的实例执行健康检查，自动移除不健康或不响应的实例。当服务需要与其他服务通信时，Eureka
    Server提供可用的实例，允许负载均衡。
- en: In this recipe, you will learn how to create an application that implements
    Eureka Server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，您将学习如何创建一个实现Eureka Server的应用程序。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe doesn’t have any additional requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱没有其他额外要求。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we’ll create a new Eureka Server that we’ll reuse in the rest
    of the recipes. Let’s get started:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个新的 Eureka 服务器，我们将在其余的菜谱中重用它。让我们开始吧：
- en: 'First, we’ll create a new application for Eureka Server. For that, open [https://start.spring.io](https://start.spring.io)
    and use the same parameters that you did in the *Creating a RESTful API* recipe
    of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except change the following
    options:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为 Eureka 服务器创建一个新的应用程序。为此，打开 [https://start.spring.io](https://start.spring.io)
    并使用与 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中 “创建 RESTful API” 菜谱中相同的参数，除了更改以下选项：
- en: For `registry`
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `registry`
- en: For **Dependencies**, select **Eureka Server**
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **依赖项**，选择 **Eureka Server**
- en: 'Then, in the generated project, in the `resources` folder, create a file named
    `application.yml` and set the following configuration:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在生成的项目中，在 `resources` 文件夹中，创建一个名为 `application.yml` 的文件，并设置以下配置：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, open the `RegistryApplication` class and annotate it with `@EnableEurekaServer`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `RegistryApplication` 类，并使用 `@EnableEurekaServer` 注解：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, you can start the application.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以启动应用程序。
- en: 'Let’s verify that Eureka Server is running. Open `http://locahost:8761` in
    your browser:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证 Eureka 服务器是否正在运行。在您的浏览器中打开 `http://locahost:8761`：
- en: '![Figure 4.1: Eureka Server](img/B21646_04_1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：Eureka 服务器](img/B21646_04_1.jpg)'
- en: 'Figure 4.1: Eureka Server'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：Eureka 服务器
- en: On the Eureka Server page, you can see general information about the server
    and, most importantly, the applications registered on the server. Now, we don’t
    have any applications registered yet. Once we connect the applications in the
    following recipes, we will see them under **Instances currently registered** **with
    Eureka**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eureka 服务器页面上，您可以查看有关服务器的一般信息，最重要的是，注册在服务器上的应用程序。现在，我们还没有任何应用程序注册。一旦我们将以下菜谱中的应用程序连接起来，我们将在
    **当前注册的实例** 下看到它们。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Eureka Server dependency in a Spring Boot application allows you to set
    up and run a service registry. When you use the `@EnableEurekaServer` annotation,
    the Eureka Server autoconfiguration is activated. The Eureka Server application
    must be configured so that it can stop itself from being registered as a service,
    which is why the `eureka.client.registerWithEureka` and `eureka.client.fetchRegistry`
    settings are both set to `false`. The other required Eureka Server configuration
    is the port. We configured Eureka Server to listen on port `8761`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 应用程序中的 Eureka 服务器依赖项允许您设置和运行服务注册。当您使用 `@EnableEurekaServer` 注解时，Eureka
    服务器自动配置被激活。Eureka 服务器应用程序必须进行配置，以便它可以停止自己作为服务注册，这就是为什么 `eureka.client.registerWithEureka`
    和 `eureka.client.fetchRegistry` 设置都设置为 `false` 的原因。其他必需的 Eureka 服务器配置是端口号。我们已将
    Eureka 服务器配置为监听端口 `8761`。
- en: Integrating an application in Eureka Server
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Eureka 服务器中集成应用程序
- en: In this recipe, we’ll integrate two applications into Eureka Server, which we
    deployed in the previous recipe. One application provides football data, which
    the other application consumes. We’ll use Eureka Server to register both applications,
    at which point the consumer will use Eureka Server to discover the provider application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将把两个应用程序集成到之前菜谱中部署的 Eureka 服务器中。一个应用程序提供足球数据，另一个应用程序消费这些数据。我们将使用 Eureka
    服务器来注册这两个应用程序，此时消费者将使用 Eureka 服务器来发现提供者应用程序。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In addition to Eureka Server, which we deployed in the previous recipe, we’ll
    reuse the applications we created in the *Defining responses and data model exposed
    by the API* and *Consuming a RESTful API from another Spring Boot application*
    recipes in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前菜谱中部署的 Eureka 服务器外，我们还将重用我们在 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020)
    中的 “定义 API 暴露的响应和数据模型” 和 “从另一个 Spring Boot 应用程序消费 RESTful API” 菜谱中创建的应用程序。
- en: 'As a starting point, you can use the applications that I’ve prepared in this
    book’s repository: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
    You can find the code in the `chapter4/recipe4-2/start` folder.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，您可以使用我在本书的存储库中准备的应用程序：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。您可以在
    `chapter4/recipe4-2/start` 文件夹中找到代码。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We’ll integrate the `football` and `albums` applications from the *Consuming
    a RESTful API from another Spring application using RestClient* recipe in [*Chapter
    1*](B21646_01.xhtml#_idTextAnchor020), into Eureka Server, which we deployed in
    the previous recipe. Let’s make the required adjustments:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把来自 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 的 *从另一个 Spring 应用程序使用 RestClient
    消费 RESTful API* 菜单中的 `football` 和 `albums` 应用程序集成到 Eureka 服务器中，该服务器我们在之前的菜谱中部署。让我们进行必要的调整：
- en: 'First, we will modify the applications so that they connect to the Eureka Server
    instance. We will start with the `football` application. Make the following changes:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将修改应用程序，使它们连接到 Eureka 服务器实例。我们将从 `football` 应用程序开始。进行以下更改：
- en: 'Add the following dependencies to the `pom.xml` file:'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到 `pom.xml` 文件中：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Ensure the `pom.xml` file has configured dependency management for Spring Cloud:'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在 `pom.xml` 文件中配置了 Spring Cloud 的依赖管理：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Ensure that the `spring-cloud.version` property is defined in the `pom.xml`
    file:'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在 `pom.xml` 文件中定义了 `spring-cloud.version` 属性：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `resources` folder, add a file named `application.yml` with the following
    content:'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `resources` 文件夹中，添加一个名为 `application.yml` 的文件，内容如下：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Start the `football` application.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `football` 应用程序。
- en: 'At this point, you’ll be able to see the application registered in Eureka Server:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，您将能够看到注册在 Eureka 服务器上的应用：
- en: '![Figure 4.2: The RESTful application registered in Eureka Server](img/B21646_04_2.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：注册在 Eureka 服务器上的 RESTful 应用](img/B21646_04_2.jpg)'
- en: 'Figure 4.2: The RESTful application registered in Eureka Server'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：注册在 Eureka 服务器上的 RESTful 应用
- en: 'Next, modify the RESTful API `albums` consumer application by making the following
    changes:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过以下更改修改 RESTful API `albums` 消费者应用程序：
- en: 'Add the `org.springframework.cloud:spring-cloud- starter-netflix-eureka-client`
    and `org.springframework.cloud:spring-cloud-starter-openfeign` dependencies to
    the `pom.xml` file:'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `org.springframework.cloud:spring-cloud-starter-netflix-eureka-client` 和 `org.springframework.cloud:spring-cloud-starter-openfeign`
    依赖项添加到 `pom.xml` 文件中：
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `AlbumsApplication.` class, add the `@``EnableDiscoveryClient` annotation:'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `AlbumsApplication.` 类中添加 `@EnableDiscoveryClient` 注解：
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `resources` folder, add an `application.yml` file with the following
    configuration:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `resources` 文件夹中添加一个 `application.yml` 文件，配置如下：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '@FeignClient("FootballServer")'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@FeignClient("FootballServer")'
- en: public interface FootballClient {
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: public interface FootballClient {
- en: '@RequestMapping(method = RequestMethod.GET, value = "/players")'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@RequestMapping(method = RequestMethod.GET, value = "/players")'
- en: List<Player> getPlayers();
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: List<Player> getPlayers();
- en: '}'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we no longer use the remote RESTful API server address, just the application
    name.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们不再使用远程 RESTful API 服务器地址，只需使用应用程序名称。
- en: Now, you can run the `albums` application.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以运行 `albums` 应用程序。
- en: 'Finally, you can test the entire deployment. For that, execute the following
    `curl` request:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以测试整个部署。为此，执行以下 `curl` 请求：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The consumer application will discover which instances of the server application
    are available by asking Eureka Server, after which point it will call the server
    application and return the result.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消费者应用程序将通过询问 Eureka 服务器来发现服务器应用程序的可用实例，之后它将调用服务器应用程序并返回结果。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To set up the client connection to Eureka Server, it is necessary to add the
    `org.springframework.cloud:spring-cloud-starter-openfeign` and `org.springframework.cloud:spring-cloud-starter-netflix-eureka-client`
    dependencies and configure the connection to Eureka Server. The configuration
    on the client side consists of the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置客户端连接到 Eureka 服务器，需要添加 `org.springframework.cloud:spring-cloud-starter-openfeign`
    和 `org.springframework.cloud:spring-cloud-starter-netflix-eureka-client` 依赖项，并配置连接到
    Eureka 服务器。客户端的配置包括以下内容：
- en: '`eureka.client.serviceUrl.defaultZone`: This is the address of Eureka Server.
    In our case, this is `http://localhost:8761/eureka`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eureka.client.serviceUrl.defaultZone`: 这是 Eureka 服务器地址。在我们的例子中，这是 `http://localhost:8761/eureka`。'
- en: '`spring.appication.name`: This is the name that can be used to discover the
    service.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.appication.name`: 这是用于发现服务的名称。'
- en: OpenFeign and Eureka clients use Eureka Server to discover instances of a service.
    Remember that in the `@OpenFeignClient` configuration, we used the server application
    name instead of a server address. The OpenFeign client connects to Eureka Server,
    requests the instances that have been registered for that service, and returns
    one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFeign 和 Eureka 客户端使用 Eureka 服务器来发现服务的实例。记住，在 `@OpenFeignClient` 配置中，我们使用服务器应用程序名称而不是服务器地址。OpenFeign
    客户端连接到 Eureka 服务器，请求已注册为该服务的实例，并返回一个。
- en: For clients, this is more straightforward as knowing the address where the server
    instances will be hosted in advance is unnecessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端来说，这更为直接，因为事先知道服务器实例的地址是不必要的。
- en: The discovery mechanism is also very convenient for server applications as they
    don’t need to be hosted in a predefined server and port. You probably noticed
    that the RESTful API server was configured with `server.port=0`, which means it
    will start in a random port. The server address and port are stored when it’s
    registered in Eureka Server. When the consumer application asks for Eureka Server,
    it returns information about the registered instance – that is, the server address
    and port. This feature is helpful as we run our applications locally and we don’t
    need to care about which port we are running each instance on. In previous recipes,
    we started one application on port `8080` and another on `8081`. In the *Scaling
    out the RESTful API service* recipe, we will see that it is possible to have more
    than one instance of a given service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 发现机制对于服务器应用程序也非常方便，因为它们不需要托管在预定义的服务器和端口上。你可能已经注意到，RESTful API 服务器被配置为 `server.port=0`，这意味着它将在一个随机端口启动。服务器地址和端口在注册到
    Eureka 服务器时被存储。当消费者应用程序请求 Eureka 服务器时，它返回有关注册实例的信息——即服务器地址和端口。这个特性很有帮助，因为我们本地运行应用程序，我们不需要关心每个实例运行在哪个端口上。在之前的菜谱中，我们启动了一个在端口
    `8080` 上的应用程序，另一个在 `8081` 上。在 *扩展 RESTful API 服务* 菜谱中，我们将看到可以有一个给定服务的多个实例。
- en: There’s more...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A key feature of Eureka Server is detecting unhealthy or unresponsive application
    instances and removing them from the registry. This feature requires that registered
    services use **Actuator**. Spring Actuator provides production-ready features
    that help you monitor and manage your Spring applications. It’s particularly useful
    for microservices and other distributed systems, where operational visibility
    and management are critical. You can include the Actuator dependency in your projects
    by applying the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka 服务器的一个关键特性是检测不健康或无响应的应用程序实例，并将它们从注册表中移除。这个特性要求注册的服务使用**Actuator**。Spring
    Actuator 提供了生产就绪的功能，帮助你监控和管理你的 Spring 应用程序。它特别适用于微服务和其他分布式系统，在这些系统中，操作可见性和管理至关重要。你可以通过以下代码将
    Actuator 依赖项包含到你的项目中：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can find more information about Actuator on the project page: [https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目页面找到有关 Actuator 的更多信息：[https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html)。
- en: Scaling out the RESTful API
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 RESTful API
- en: Scaling out is a technique that improves the availability and capacity of a
    system by adding multiple instances for a given service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展是一种通过为给定服务添加多个实例来提高系统可用性和容量的技术。
- en: In modern application platforms, such as container orchestrators such as Kubernetes
    or cloud providers hosting platforms such as Azure App Services or AWS Elastic
    Beanstalk, the systems may scale out and scale in automatically. For instance,
    in Kubernetes, you can configure an autoscale rule that increases the number of
    instances of your service when the average CPU has been over 70% for the last
    5 minutes. You can also configure it in another way – when the usage of your application
    is low, you can scale in your application. This means you can decrease the number
    of instances of the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代应用程序平台中，例如 Kubernetes 这样的容器编排器或 Azure App Services 或 AWS Elastic Beanstalk
    这样的云服务提供商托管平台，系统可能会自动扩展和缩减。例如，在 Kubernetes 中，你可以配置一个自动扩展规则，当过去 5 分钟的平均 CPU 使用率超过
    70% 时，增加你的服务实例数量。你也可以以另一种方式配置它——当你的应用程序使用率低时，你可以缩减应用程序。这意味着你可以减少应用程序实例的数量。
- en: Scaling out an application shouldn’t necessarily be automated; you can scale
    it manually, as we’ll do in this recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展应用程序不一定需要自动化；你可以手动扩展它，就像我们在本菜谱中所做的那样。
- en: Scaling out involves distributing incoming requests across multiple instances
    of a service. In this recipe, we will learn how to use Eureka Server capabilities
    to register and discover instances to distribute the requests across available
    service instances.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展涉及将传入请求分配到多个服务实例。在这个菜谱中，我们将学习如何使用 Eureka 服务器的能力来注册和发现实例，以便将请求分配到可用的服务实例。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the services we utilized in the previous recipe:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用在之前菜谱中使用的服务：
- en: '**Eureka Server**: This service will act as a service registry and provide
    service discovery'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Eureka Server**`：此服务将作为服务注册表并提供服务发现'
- en: '**RESTful API**: This will provide a service to be consumed by the client application'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**RESTful API**`：这将提供一个由客户端应用程序消费的服务'
- en: '**Client application**: This will consume the RESTful API'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**Client application**`：这将消费RESTful API'
- en: If you haven’t completed the previous recipe, you can find the completed exercise
    in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有完成前面的食谱，你可以在本书的GitHub存储库中找到完成的练习，网址为https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook。
- en: You can find the code to start this recipe in the `chapter4/recipe4-3/start`
    folder.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`chapter4/recipe4-3/start`文件夹中找到启动此食谱的代码。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will modify the RESTful API so that it returns the service instance’s information.
    That way, we can validate that the requests are balanced among available instances.
    Then, we will execute more than one instance of the RESTful API. Let’s get started:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改RESTful API，使其返回服务实例的信息。这样，我们可以验证请求是否在可用的实例之间均衡。然后，我们将执行多个RESTful API实例。让我们开始吧：
- en: 'In the RESTful API project, modify the `application.yml` file in the `resources`
    folder by adding the following property at the beginning of the file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RESTful API`项目中的`resources`文件夹中，修改`application.yml`文件，在文件开头添加以下属性：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The file should look like this:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件应该看起来像这样：
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '@RequestMapping("/serviceinfo")'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@RequestMapping("/serviceinfo")`'
- en: '@RestController'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@RestController`'
- en: public class ServiceInformationController {
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`public class ServiceInformationController {`'
- en: '@Value("${football.instanceId}")'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@Value("${football.instanceId}")`'
- en: private String instanceId;
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`private String instanceId;`'
- en: '@GetMapping'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@GetMapping`'
- en: public String getInstanceId() {
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`public String getInstanceId() {`'
- en: return instanceId;
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return instanceId;`'
- en: '}'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`}`'
- en: '}'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`}`'
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Execute three instances of the RESTful API. Instead of using `mvnw spring-boot:run`,
    we will build the JAR file and execute it using the Java runtime. To do this,
    follow these steps:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行三个RESTful API实例。我们不会使用`mvnw spring-boot:run`，而是构建JAR文件并使用Java运行时执行它。为此，请按照以下步骤操作：
- en: 'In the root folder of the project, build the application using the following
    command:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下，使用以下命令构建应用程序：
- en: '[PRE15]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, open three Terminals and execute the following command in all of them:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开三个终端，在所有终端中执行以下命令：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open Eureka Server at `localhost:8761`. You’ll see three instances of the RESTful
    API service:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`localhost:8761`打开Eureka服务器。你会看到三个RESTful API服务的实例：
- en: '![Figure 4.3: Eureka Server with three instances of FootballServer running](img/B21646_04_3.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：运行着三个FootballServer实例的Eureka服务器](img/B21646_04_3.jpg)'
- en: 'Figure 4.3: Eureka Server with three instances of FootballServer running'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：运行着三个FootballServer实例的Eureka服务器
- en: 'In the client application project, make the following changes:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端应用程序项目中，进行以下更改：
- en: 'In the `FootballClient` class, add the following method:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`FootballClient`类中，添加以下方法：
- en: '[PRE17]'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `AlbumsController` controller, add the following method:'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AlbumsController`控制器中，添加以下方法：
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, start the client application and test the application multiple times.
    You can do that by executing the following `curl` request several times:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启动客户端应用程序并多次测试应用程序。你可以通过多次执行以下`curl`请求来实现：
- en: '[PRE19]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will see that the results change when you execute the previous command
    multiple times:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你多次执行前面的命令时，你会看到结果发生变化：
- en: '![Figure 4.4: Results of executing the RESTful API from the client application](img/B21646_04_4.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：从客户端应用程序执行RESTful API的结果](img/B21646_04_4.jpg)'
- en: 'Figure 4.4: Results of executing the RESTful API from the client application'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：从客户端应用程序执行RESTful API的结果
- en: The client application distributes requests across Eureka Server’s registered
    service instances, resulting in different outcomes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序将请求分配到Eureka服务器注册的服务实例中，导致不同的结果。
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the Eureka client starts, it registers itself in Eureka Server. The registration
    details include the service name and network location. After the registration
    process, the client sends heartbeats to inform the server that it is still alive.
    In this exercise, we initiated three instances of the RESTful API server with
    the same service name; each of the instances had a separate network location.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当Eureka客户端启动时，它会在Eureka服务器中注册自己。注册详情包括服务名称和网络位置。在注册过程之后，客户端发送心跳来通知服务器它仍然存活。在这个练习中，我们使用相同的服务名称启动了三个RESTful
    API服务器的实例；每个实例都有一个单独的网络位置。
- en: The Feign client in the consumer application uses Eureka Server to discover
    the available instances of the RESTful API server application. In that way, it
    can balance the request across the service instances.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者应用程序中的Feign客户端使用Eureka服务器来发现RESTful API服务器应用程序的可用实例。这样，它可以在服务实例之间平衡请求。
- en: Just for demonstration purposes, we added a configuration setting, `football.InstanceId`,
    with a unique random value to distinguish the service instance. To retrieve that
    configuration, we used the `@Value` annotation. Spring Boot injected the value
    when the application was started.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用于演示目的，我们添加了一个配置设置，`football.InstanceId`，具有唯一的随机值以区分服务实例。为了检索该配置，我们使用了`@Value`注解。Spring
    Boot在应用程序启动时注入了该值。
- en: Setting up Spring Cloud Gateway
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Gateway
- en: 'When creating complex applications with different services, we don’t want to
    expose all those services to consumer applications so that we can avoid unnecessary
    complexity exposure. To address this scenario, we can use **Spring Cloud Gateway**.
    Spring Cloud Gateway can be deployed in such a way that it’s the only component
    that’s accessible to consumer applications, while the rest of the services will
    be accessed either internally or just from Spring Cloud Gateway. This is illustrated
    in *Figure 4**.5*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建具有不同服务的复杂应用程序时，我们不希望将所有这些服务暴露给消费者应用程序，以避免不必要的复杂性暴露。为了应对这种情况，我们可以使用**Spring
    Cloud Gateway**。Spring Cloud Gateway可以部署成这样，它是消费者应用程序唯一可访问的组件，而其余的服务将通过内部访问或仅从Spring
    Cloud Gateway访问。这如图*图4.5*所示：
- en: '![Figure 4.5: A typical Spring Cloud Gateway deployment](img/B21646_04_5.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：典型的Spring Cloud Gateway部署](img/B21646_04_5.jpg)'
- en: 'Figure 4.5: A typical Spring Cloud Gateway deployment'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：典型的Spring Cloud Gateway部署
- en: A note on deployment
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于部署的注意事项
- en: Depending on the complexity and requirements of the solution, I recommend using
    additional networking protections, such as Layer 7 load balancers, **web application
    firewalls** (**WAFs**), or other protection mechanisms. For learning purposes,
    I will not describe them in this book and focus on Spring and Spring Cloud mechanisms
    instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据解决方案的复杂性和要求，我建议使用额外的网络保护措施，例如第7层负载均衡器、**Web应用防火墙（WAF**）或其他保护机制。为了学习目的，我将在本书中不描述它们，而是专注于Spring和Spring
    Cloud机制。
- en: 'In addition to the role of an API gateway offering a unique entry point for
    the application, Spring Cloud Gateway has interesting benefits:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为提供独特入口点的API网关的角色外，Spring Cloud Gateway还有有趣的优点：
- en: '**Load balancing**: It can balance requests across the available service instances.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**: 它可以在可用的服务实例之间平衡请求。'
- en: '**Dynamic routing**: Spring Cloud Gateway can be integrated with a service
    registry, such as Eureka Server, and dynamically route requests.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态路由**: Spring Cloud Gateway可以与服务注册中心，如Eureka服务器，集成，并动态路由请求。'
- en: '**Security**: It can apply authentication and authorization using authentication
    providers, such as Spring Security and OAuth2, and propagate to downstream services.
    You can do this in a single place if you need to configure CORS for your consumer
    application.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**: 它可以使用认证和授权提供者，例如Spring Security和OAuth2，并将它们传播到下游服务。如果您需要为您的消费者应用程序配置CORS，可以在一个地方完成这项操作。'
- en: '**SSL termination**: You can configure Spring Cloud Gateway to terminal SSL/TLS
    connections and pass unencrypted traffic to the services. With this feature, you
    can offload the SSL/TLS decryption from the services.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSL终止**: 您可以配置Spring Cloud Gateway以终止SSL/TLS连接并将未加密的流量传递到服务。使用此功能，您可以将SSL/TLS解密从服务中卸载。'
- en: '**Rate limiting**: You can implement rate limiting to prevent your services
    from being abused.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制**: 您可以实现速率限制以防止您的服务被滥用。'
- en: '**Request/response transformation**: You can use Spring Cloud Gateway to transform
    requests and responses – for instance, by adding requests or response headers.
    You can also convert payload formats, such as XML, into JSON. These transformations
    can be applied at the gateway level; hence, it is not necessary to modify your
    downstream services.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求/响应转换**: 您可以使用Spring Cloud Gateway来转换请求和响应 – 例如，通过添加请求或响应头。您还可以将有效载荷格式，如XML，转换为JSON。这些转换可以在网关级别应用；因此，没有必要修改您的下游服务。'
- en: '**Circuit breaking**: You can use Spring Cloud Gateway to implement circuit
    breakers to handle failures gracefully. For instance, you can prevent requests
    from being sent to an unhealthy service.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断路器**：你可以使用Spring Cloud Gateway来实现断路器，以优雅地处理故障。例如，你可以防止请求发送到不健康的服务。'
- en: Some added benefits are *request filtering*, *global exception handling*, *logging
    and monitoring*, and *path Rewriting*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外的优点包括*请求过滤*、*全局异常处理*、*日志和监控*以及*路径重写*。
- en: I recommend visiting the project page at https://spring.io/projects/spring-cloud-gateway
    for more details.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议访问https://spring.io/projects/spring-cloud-gateway的项目页面以获取更多详细信息。
- en: In this recipe, we will deploy an instance of Spring Cloud Gateway and integrate
    it with Eureka Server, which we deployed in previous recipes, to route requests
    to registered services.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将部署Spring Cloud Gateway的一个实例，并将其与我们在前面的食谱中部署的Eureka服务器集成，以将请求路由到已注册的服务。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the projects we implemented in previous recipes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用我们在前面的食谱中实现的项目：
- en: '**Eureka Server**: This service will act as a service registry and provide
    service discovery.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eureka服务器**：此服务将作为服务注册表并提供服务发现。'
- en: '`football` application.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`football`应用。'
- en: '`album` application.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`album`应用。'
- en: If you haven’t completed the previous recipe, you can find the completed exercise
    in this book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook.
    The code to start this recipe can be found in the `chapter4/recipe4-4/start` folder.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有完成前面的食谱，你可以在本书的GitHub仓库中找到完成的练习，网址为https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook。启动此食谱的代码可以在`chapter4/recipe4-4/start`文件夹中找到。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s deploy a Spring Cloud Gateway. We will configure Gateway so that it exposes
    some functionality of the RESTful API:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署一个Spring Cloud Gateway。我们将配置网关，使其公开RESTful API的一些功能：
- en: 'Open [https://start.spring.io](https://start.spring.io) and use the same parameters
    that you did in the *Creating a RESTful API* recipe, except change the following
    options:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://start.spring.io](https://start.spring.io)，使用与你在*创建RESTful API*食谱中相同的参数，除了更改以下选项：
- en: For `gateway`
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`gateway`
- en: For **Dependencies**, select **Gateway** and **Eureka** **Discovery Client**
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**依赖项**，选择**Gateway**和**Eureka** **发现客户端**
- en: 'In the project you’ve downloaded, create a file in the `resources` folder named
    `application.yml` with the following content:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你下载的项目中，在`resources`文件夹中创建一个名为`application.yml`的文件，内容如下：
- en: '[PRE20]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, you can run the gateway application. One important thing to note is that
    the other application should be running as well.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以运行网关应用。需要注意的是，其他应用也应该在运行。
- en: 'Test the gateway by executing the following request:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下请求来测试网关：
- en: '[PRE21]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should see the RESTful API’s results.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能看到RESTful API的结果。
- en: 'Now, let’s add a new method in the other RESTful API applications in `Albums`
    and then add it as a new route in Spring Cloud Gateway. So, open the `AlbumsController`
    controller and add the following method:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`Albums`中的其他RESTful API应用中添加一个新的方法，然后将其作为新的路由添加到Spring Cloud Gateway中。因此，打开`AlbumsController`控制器并添加以下方法：
- en: '[PRE22]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the same project, open the `application.yml` file and add the following
    property:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个项目中，打开`application.yml`文件并添加以下属性：
- en: '[PRE23]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, add a new route in the Spring Cloud Gateway configuration. For that, open
    the `application.yml` file of the Spring Cloud Gateway project and add the following
    highlighted text. I’ve added the entire configuration file for clarity:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在Spring Cloud Gateway配置中添加一个新的路由。为此，打开Spring Cloud Gateway项目的`application.yml`文件并添加以下突出显示的文本。为了清晰起见，我添加了整个配置文件：
- en: '[PRE24]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Restart Spring Cloud Gateway and test the new route by executing the following
    `curl` request:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Spring Cloud Gateway，并通过执行以下`curl`请求来测试新的路由：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, you should see the response of the second RESTful API.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你应该能看到第二个RESTful API的响应。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we connected Spring Cloud Gateway to Eureka Server. For that,
    we only needed to include the Eureka discovery client and its configuration –
    that is, `eureka.client.serviceUrl.defaultZone property` in the `application.yml`
    file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们连接了Spring Cloud Gateway到Eureka服务器。为此，我们只需要包含Eureka发现客户端及其配置——即在`application.yml`文件中的`eureka.client.serviceUrl.defaultZone`属性。
- en: Once connected to Eureka Server, we configured a couple of routings. A routing
    definition specifies a combination of criteria and actions to be taken when a
    request matches the criteria.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接到Eureka服务器，我们配置了一些路由。路由定义指定了当请求匹配标准时要采取的准则和动作的组合。
- en: 'We established the criteria for route definition by employing predicates. Specifically,
    we configured two routes: one using the `/api/players/**` path pattern and the
    other using `/api/albums/**`. This configuration dictates that the first route
    will match requests starting with `/api/player`, while the second route will match
    requests commencing with `/api/albums`. For example, a request such as `http://localhost:8080/api/player`
    would match the first route. Beyond the request path, you can utilize other request
    properties, such as headers, query parameters, or the request host.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用谓词来建立路由定义的标准。具体来说，我们配置了两个路由：一个使用`/api/players/**`路径模式，另一个使用`/api/albums/**`。此配置规定第一个路由将匹配以`/api/player`开头的请求，而第二个路由将匹配以`/api/albums`开头的请求。例如，一个如`http://localhost:8080/api/player`的请求将匹配第一个路由。除了请求路径之外，您还可以利用其他请求属性，例如头部、查询参数或请求主机。
- en: Since the target services expect the requests as `/players` in one case and
    `/albums` in the other, without `/api` in both cases, removing this part of the
    path is necessary. We configured this using the `StripPrefix=1` filter, which
    removed the first part of the path.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标服务在一种情况下期望请求为`/players`，在另一种情况下为`/albums`，且两种情况都不包含`/api`，因此删除路径的这一部分是必要的。我们使用`StripPrefix=1`过滤器来配置这一点，该过滤器删除了路径的第一部分。
- en: Finally, those routes needed to hit a target service, so we configured this
    using the `uri` property. We could have used the DNS host and port, something
    like `http://server:8081`, but instead, we used `lb://servicename`. Using this
    approach, we configured Spring Cloud Gateway to discover the target service using
    Eureka and leverage client-side load balancing. We deployed all our services locally,
    and the only way to distinguish each instance is by dynamically assigning each
    service a port.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，那些路由需要击中目标服务，因此我们使用`uri`属性来配置这一点。我们本可以使用DNS主机和端口，例如`http://server:8081`，但相反，我们使用了`lb://servicename`。使用这种方法，我们配置Spring
    Cloud Gateway使用Eureka发现目标服务并利用客户端负载均衡。我们本地部署了所有服务，区分每个实例的唯一方法是通过动态为每个服务分配端口。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To assign a port dynamically, we set the `server.port=0` property.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要动态分配端口，我们设置`server.port=0`属性。
- en: If the hosting environment provides an alternative balancing method, it is acceptable
    to use it. For instance, in a Kubernetes environment, you can create a deployment
    for your service with multiple running instances. By doing this, your service
    can be discovered through Kubernetes DNS, and the underlying infrastructure will
    balance requests.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果托管环境提供了替代的负载均衡方法，则可以使用它。例如，在Kubernetes环境中，您可以为您的服务创建一个具有多个运行实例的部署。通过这样做，您的服务可以通过Kubernetes
    DNS进行发现，底层基础设施将进行请求均衡。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'I recommend reading Spring Cloud Gateway documentation, which you can find
    here: [https://spring.io/projects/spring-cloud-gateway](https://spring.io/projects/spring-cloud-gateway).
    Familiarize yourself with routing capabilities and understand how to configure
    your routes using all the properties that are available in the requests.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议阅读Spring Cloud Gateway文档，您可以在以下链接找到：[https://spring.io/projects/spring-cloud-gateway](https://spring.io/projects/spring-cloud-gateway)。熟悉路由功能，并了解如何使用请求中所有可用的属性来配置您的路由。
- en: 'Circuit Breaker is also an interesting design pattern that can be very useful
    for handling failures gracefully. If you are unfamiliar with this pattern, I recommend
    looking at this *Azure Cloud Design Patterns* article: [https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker](https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker).
    The good news is that this pattern is relatively easy to implement using Spring
    Cloud Gateway – see [https://spring.io/guides/gs/gateway/](https://spring.io/guides/gs/gateway/)
    for more details.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器（Circuit Breaker）也是一个有趣的设计模式，它可以非常有助于优雅地处理故障。如果您不熟悉这个模式，我建议查看这篇*Azure Cloud
    Design Patterns*文章：[https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker](https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker)。好消息是这个模式相对容易使用Spring
    Cloud Gateway实现——有关更多详细信息，请参阅[https://spring.io/guides/gs/gateway/](https://spring.io/guides/gs/gateway/)。
- en: Testing Spring Cloud Gateway
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Spring Cloud Gateway
- en: As the Spring Cloud Gateway rules are processed at runtime, they can sometimes
    be difficult to test. In addition to the rules themselves, the target applications
    must be up and running.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Cloud Gateway规则是在运行时处理的，因此有时很难进行测试。除了规则本身外，目标应用程序也必须处于运行状态。
- en: In this recipe, we’ll learn how to test Spring Cloud Gateway using the *Spring
    Cloud Contract Stub Runner* starter, which emulates the target services using
    the Wiremock library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用*Spring Cloud Contract Stub Runner*启动器测试Spring Cloud Gateway，该启动器使用Wiremock库模拟目标服务。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll create tests for the Spring Cloud Gateway project we set
    up in the previous recipe. I’ve prepared a working version of Spring Cloud Gateway
    in case you haven’t set it up yet. You can find it in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
    The code to start this recipe can be found in the `chapter4/recipe4-5/start` folder.
    I’ve added all the projects that were used in the previous recipe – that is, the
    `football`, the `albums`, and the `gateway` projects – but we’ll only be using
    `gateway` here.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为之前菜谱中设置的Spring Cloud Gateway项目创建测试。我准备了一个Spring Cloud Gateway的工作版本，以防你还没有设置它。你可以在本书的GitHub仓库中找到它：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。启动此菜谱的代码可以在`chapter4/recipe4-5/start`文件夹中找到。我已经添加了之前菜谱中使用的所有项目——即`football`、`albums`和`gateway`项目——但我们在这里只会使用`gateway`。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we’ll adjust the gateway project to allow for test execution.
    Let’s get started:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将调整网关项目以允许测试执行。让我们开始吧：
- en: 'First, we’ll add the *Spring Cloud Contract Stub Runner* starter. For that,
    add the following dependency in the `gateway` project’s `pom.xml` file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加*Spring Cloud Contract Stub Runner*启动器。为此，在`gateway`项目的`pom.xml`文件中添加以下依赖项：
- en: '[PRE26]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that this dependency is used for testing purposes only.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个依赖项仅用于测试目的。
- en: 'Next, modify the `application.yml` configuration to parameterize the destination
    URIs. Replace the addresses in `spring.cloud.gateway.routes.uri` so that they
    use a configuration parameter:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改`application.yml`配置以参数化目标URI。替换`spring.cloud.gateway.routes.uri`中的地址，使其使用配置参数：
- en: '[PRE27]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Before creating our first test, we need to set up the test class. Let’s create
    a new class named `RoutesTests` in the `test` folder. To set it up, you must do
    the following:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建我们的第一个测试之前，我们需要设置测试类。让我们在`test`文件夹中创建一个名为`RoutesTests`的新类。为了设置它，你必须执行以下操作：
- en: Annotate the class with `@AutoConfigureWireMock(port =` `0)`
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@AutoConfigureWireMock(port =)` `0`注解类
- en: Annotate the class with `@SpringBootTest` using the `properties` field to pass
    the destination URIs
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`properties`字段用`@SpringBootTest`注解类，以传递目标URI
- en: Add the `WebTestClient` field that the Spring Boot tests context will inject
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`WebTestClient`字段，Spring Boot测试上下文将注入此字段
- en: 'The skeleton of this class should look like this:'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类的骨架应该看起来像这样：
- en: '[PRE28]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can create our first test. We’ll add a new method annotated with `@Test`
    to check the `players` route:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的第一个测试。我们将添加一个带有`@Test`注解的新方法来检查`players`路由：
- en: 'Name the method `playersRouteTest`:'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方法命名为`playersRouteTest`：
- en: '[PRE29]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'First, arrange the response of the target server when calling the `/players`
    path. We’ll use the Wiremock library:'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安排目标服务器在调用`/players`路径时的响应。我们将使用Wiremock库：
- en: '[PRE30]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can call Spring Cloud Gateway by using `WebTestClient` and assert that
    it’s working as expected:'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用`WebTestClient`并断言它按预期工作来调用Spring Cloud Gateway：
- en: '[PRE31]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, you can test the `albums` route using the same approach. This book’s GitHub
    repository contains more tests for Spring Cloud Gateway: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用相同的方法测试`albums`路由。这本书的GitHub仓库包含更多关于Spring Cloud Gateway的测试：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When configuring the Spring Cloud Gateway project, two dependencies need to
    be considered: Eureka Server and the target RESTful API. However, the main purpose
    is to verify the Gateway routes during testing. To achieve this, we removed the
    dependency on Eureka Server and allowed the target RESTful API URI to be configured.
    By using the `${key:default}` notation in *Step 2*, we created a fallback mechanism
    that uses the configured value for the load balancer address. If no value is provided,
    then it defaults to the original URI. This notation specifies that if the key
    is provided, then it uses that key; otherwise, it uses the default value specified
    after the colon symbol.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Using the configuration mechanism described previously and the Wiremock provided
    by the *Spring Cloud Contract Stub Runner* starter, we configured the address
    of the remote RESTful APIs, considering that the Wiremock server is running on
    localhost and the port is provided by the Wiremock server. In the `@AutoConfigureWireMock`
    annotation, we used port `0` to ensure the port is assigned randomly. Then, using
    `${wiremock.server.port}`, we retrieved the assigned port.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the test follows the same mocking mechanism that we explained in
    the *Mocking a RESTful API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020).
    Note that the mocked RESTful API responds to `/players`, while the test requests
    `/api/players`. In this test, we want to validate that the Spring Cloud Gateway
    configuration is correct, so when making a request to `/api/players`, it redirects
    the call to the target API on the `/players` path. So long as the test is implemented
    correctly and Spring Cloud Gateway is configured properly, the test should pass
    without any issues.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Config
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud Config enables centralized configuration management for applications,
    allowing you to store configuration properties in a central repository and distribute
    them to connected services.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides the following features, among others:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: It allows version control configurations – for instance, using git as a backend
    to store the configuration. With this feature, you can track changes and audit
    configurations, and facilitate performing rollbacks to previous versions when
    needed.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables dynamic configuration updates with no need to restart services.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It externalizes the configuration; hence, it is possible to make configuration
    changes without modifying or redeploying the services.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will deploy a configuration server and connect our existing
    RESTful APIs to the configuration service.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Git repository. I recommend using GitHub as
    this recipe has been tested and validated with this service, but I don’t foresee
    any issue if you use another git provider. If you want to use GitHub and don’t
    have an account yet, visit [https://github.com](https://github.com). You will
    also need a git client.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'I will reuse the RESTful APIs that we configured in the previous recipe. These
    are the services we must configure:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`football` (RESTful API)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`albums` (RESTful API)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateway`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you haven’t completed the previous recipe yet, you can use the completed
    recipe in this book’s GitHub repository: https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The code to start this recipe can be found in the `chapter4/recipe4-6/start`
    folder.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’ll create a new service using Spring Initializr to host
    Spring Cloud Config. Next, we’ll configure the service to use a GitHub repository
    as a backend. Finally, we’ll connect existing services to the Config server. Let’s
    get started:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://start.spring.io](https://start.spring.io) and use the same parameters
    that you did in the *Creating a RESTful API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    except changing the following options:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `config`
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Config Server**
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a GitHub repository in your GitHub account. Since we won’t be managing
    anything secretive, the repository can be public. Name it `spring3-recipes-config`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the repository on your computer. To do that, open a Terminal and execute
    the following command, replacing `felipmiguel` with your GitHub account’s name:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will create `spring3-recipes-config` as the root folder for that repository.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the following steps, we will create files in that folder that will later
    be pushed to GitHub’s central repository.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the root folder of the configuration repository, create the following files:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`application.yml`, with the following content:'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`gatewayserver.yml`, with the following content:'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, push the files to `github.com`. To do this, execute the following commands
    in your Terminal in the repository root folder:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Configure your repository as the backend of the Config service. For this, go
    to the Config Service project and add a file named `application.yml` in the `resources`
    folder with the following content (make sure you replace `[your account]` with
    your GitHub account’s name):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '@EnableConfigServer'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@SpringBootApplication'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class ConfigApplication
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, you can start the Config server.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, modify the projects so that you can connect to the Config server. To
    do so, follow these steps:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add dependencies to the `pom.xml` file for all the applications we want to
    connect to the Config server. These applications are `football`, `album`, `registry`,
    and `gateway`:'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Configure the `application.yml` file for all the applications we want to connect
    to the Config server. All of them will contain the Config server configuration
    and the respective application’s name. For instance, the `album` service will
    look like this:'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the `football` service (the RESTful API service), set the following content:'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the `gateway` service, set the following content:'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, it’s time to verify that everything is working. Let’s start all services.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the services by executing a request to Spring Cloud Gateway:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Validate that it returns a JSON file containing a list of players.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Boot provides an extensible mechanism to load the configuration from
    external sources using the `spring.config.import` setting. Adding the `org.springframework.cloud:spring-cloud-starter-config`
    dependency registers an extension that can retrieve the configuration from a config
    server.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the configuration server, the only requirement is adding the `org.springframework.cloud:spring-cloud-config-server`
    dependency and enabling the configuration server using the `@EnableConfigServer`
    annotation. Enabling the configuration server exposes an endpoint that allows
    consumer applications to query for their configuration. The configuration endpoint
    exposes the following paths:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s take a look at each path fragment:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '`application` is the application name that’s configured by the `spring.application.name`
    property.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile` is the currently active profile. By default, the profile’s name is
    `default`.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label` refers to a git branch; if not specified, it applies to the default
    branch.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our applications provide the following queries for the Config server:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '`football`: As it contains the `spring.application.name=FootballServer` property,
    it requests `http://localhost:8888/FootballServer-default.yml`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`albums`: Its application name is `AlbumsServer`, so it requests `http://localhost:8888/AlbumsServer-default.yml`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateway`: Its application name is `GatewayServer`, so it requests `http://localhost:8888/GatewayServer-default.yml`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see the results by executing a request. For instance, for `GatewayServer`,
    you can run the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The result should look like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s analyze what the Config server did. The Config server resolves the configuration
    by merging the configurations it found in the git repository:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The base configuration starts with the `application.yml` file.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It merges the base configuration with a more specific configuration for the
    requested application. The more specific configuration is defined using a `[application
    name].yml` file, where `[application name]` is defined in the `spring.application.name`
    property. In our scenario, we haven’t defined specific configuration files for
    the `football` and `albums` applications, but we did define the `gatewayserver.yml`
    file for the `gateway` service. By doing this, `gateway` will merge the content
    of `application.yml` and `gatewayserver.yml`.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If settings are defined in multiple files, the most specific one is used. In
    this case, the settings defined by `gatewayserver.yml` will take precedence over
    the settings defined in `application.yml`. You can see this behavior for the `server.port`
    setting, which is specified in both files and takes the most specific one.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In production environments, you probably want to protect your applications’
    configurations. For that reason, you must use a private git repository, your configuration
    service will require authentication, and your secrets, such as connection strings,
    will be encrypted. You can do all that using Spring Cloud Config. I recommend
    visiting the project page at [https://spring.io/projects/spring-cloud-gateway](https://spring.io/projects/spring-cloud-gateway)
    for details on the configuration.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Another exciting feature related to configuration is the possibility to dynamically
    refresh the configuration without restarting the application. You can achieve
    this by using Spring Actuator. We will revisit this topic in later chapters.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: We just used non-sensitive information in this recipe, but applications usually
    manage configurations we don’t want to disclose, such as database connection strings
    or credentials to access other systems.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'The first measure we should apply is removing public access to the configuration
    repository. We can use private repositories and configure the git credentials
    in the Config server like so:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To avoid storing sensitive information in a git repository, Spring Cloud Config
    has an extension to integrate with Vault services, such as Hashicorp Vault and
    Azure Key Vault. The configuration file that’s stored in the git repository contains
    references to secrets stored in the Vault service. The applications resolve the
    configuration, retrieving the referenced secrets from the Vault service.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the Spring Cloud Config quickstart guide at [https://docs.spring.io/spring-cloud-config/docs/current/reference/html/](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/)
    for more advanced scenarios.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Integrating distributed tracing with Spring Cloud
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the number of services composing the `football` application suite grew,
    you deployed the following Spring Cloud components: Spring Cloud Gateway, Eureka
    Server (a registry and discovery service), and Spring Cloud Configuration. You
    want to configure distributed tracing to monitor the transactions across microservices.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will integrate distributed tracing with Actuator and OpenZipkin
    into a system composed of different application microservices and Spring Cloud
    components.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will monitor distributed transactions using OpenZipkin. As explained in
    the *Implementing distributed tracing* recipe in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103),
    you can deploy an OpenZipkin server on your computer using Docker. For that, you
    can run the following command in your Terminal:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will reuse the outcome of the *Setting up Spring Cloud Config* recipe.
    I’ve prepared a working version in case you haven’t completed that recipe yet.
    You can find it in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter4/recipe4-7/start` folder. It includes the following projects:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '`config`: The Spring Cloud Config service.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registry`: The Spring Cloud registry and discovery service.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateway`: Spring Cloud Gateway. It exposes the `football` and `albums` services.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`football`: The `football` service, which provides information about teams
    and players.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`albums`: The `albums` service, which manages sticker albums. It uses the `football`
    service.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s configure our Spring Cloud solution so that we can integrate distributed
    tracing with OpenZipkin.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'You must add a dependency to Actuator, the Micrometer bridge to OpenTelemetry,
    and the exporter from OpenTelemetry to OpenZipkin to all projects. For that, add
    the following dependencies to all `pom.xml` project files, - that is, the `config`,
    `registry`, `gateway`, `football`, and `albums` projects:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `albums` project also makes some calls to the `football` project using
    the `OpenFeign` client. For that reason, you should also add the following dependencies
    to that project:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let’s change the configuration to enable 100% sampling. Since we’re using
    a central config server, we can change the configuration in the repository that
    contains the configuration for all applications. In my case, that repository is
    hosted at [https://github.com/felipmiguel/spring3-recipes-config](https://github.com/felipmiguel/spring3-recipes-config).
    As the *Setting up Spring Cloud Config* recipe explains, you should replace `felipmiguel`
    with your GitHub account. In my repository, I added the following configuration
    to the `application.yml` file:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can create a branch for this feature in the configuration repository. Once
    you’ve done this, you will need to modify the configuration in the client applications
    by adding the following setting in the client `application.yml` file:'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Then, you should replace `<your branch name>` with the branch name you created
    in GitHub.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now run the applications. You should start the `config` service first,
    then `registry`, at which point you can start all the rest in no specific order.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s test the solution. You can run the following requests for testing:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this case, the request is initially handled by `gateway` and served by the
    `albums` service, which simultaneously calls the `football` service.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you can see the traces in OpenZipkin. For that, open `http://localhost:9411`
    in your browser. Go to **Find a trace** to view the traces. You will see some
    traces that were initiated in the gateway. These are the ones you executed in
    *Step 5*:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6: Distributed traces for Spring Cloud](img/B21646_04_6.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Distributed traces for Spring Cloud'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The other traces are from the applications synchronizing with Eureka Server.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the traces for `gatewayserver` with five spans – that is, the one
    corresponding to `/api/albums/players` – you will see that the `gateway` server
    called the `albums` server, which called the `football` server:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Distributed tracing starting in the gateway server, which calls
    the albums service, which, in turn, calls the football service](img/B21646_04_7.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Distributed tracing starting in the gateway server, which calls
    the albums service, which, in turn, calls the football service'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the **Dependencies** section, you will see the dependencies between
    the microservices:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: The dependencies between Spring Cloud microservices](img/B21646_04_8.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: The dependencies between Spring Cloud microservices'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: This view is interesting in complex scenarios with different microservices calling
    each other when you need to understand the relationship between them.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in the *Implementing distributed tracing* recipe in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103),
    just by adding Actuator and Micrometer dependencies, the applications send traces
    to the OpenZipkin server using the default configuration. The default configuration
    is `http://localhost:9411` for the OpenZipkin server and 10% of sampling. Sampling
    means that only a percentage of the traces is processed, so only 10% is processed
    by default. For demonstration purposes, we wanted to send 100% of the traces;
    for that reason, we took advantage of having a centralized configuration and only
    changed the `application.yml` file in the configuration repository.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The `albums` application uses an `OpenFeign` client, which, by default, does
    not propagate the distributed traces as `WebClient.Builder` and `RestTemplateBuilder`
    do. Therefore, we needed to add two additional dependencies to `io.micrometer:micrometer-tracing`
    and `io.github.openfeign:feign-micrometer`. On the other hand, Spring Cloud Gateway
    uses `WebClient.Builder` to make requests to the downstream services. For that
    reason, the traces are created and propagated correctly from Spring Cloud Gateway
    with no additional configurations required.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Spring Boot Admin
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After deploying several microservices, you will appreciate having a single dashboard
    to monitor and manage all of them in one place. Spring Boot Admin is an open source
    community project that provides a web interface where you can manage and monitor
    Spring Boot applications.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will reuse the applications from the *Integrating distributed tracing with
    Spring Cloud* recipe. I’ve prepared a working version in case you haven’t completed
    that recipe yet. You can find it in this book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter4/recipe4-8/start` folder.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to deploy a Spring Boot Admin server and ensure it connects to the
    discovery service to monitor and manage all applications. Follow these steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new application for Spring Boot Admin using the *Spring Initializr*
    tool. Open [https://start.spring.io](https://start.spring.io) and use the same
    parameters that you did in the *Creating a RESTful API* recipe of [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    except change the following options:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `fooballadmin`
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web**, **Codecentric’s Spring Boot Admin
    (Server)**, **Config Client**, and **Eureka** **Discovery Client**
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, you must configure Spring Boot Admin. For that, add an `application.yml`
    file to the `resources` folder with the following content:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: I’m using `spring.cloud.config.label` in this configuration. As I don’t want
    to mix the configuration from different recipes, I’ve created a new branch for
    the recipes in this chapter, the name of which is `distributed-tracing`. However,
    if you made all configurations in the same GitHub repository and the same branch,
    this setting is not necessary.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is a required additional configuration, but it should be done in the
    central repository this time since we are using the Spring Cloud Config service.
    In my case, the configuration is saved at [https://github.com/felipmiguel/spring3-recipes-config](https://github.com/felipmiguel/spring3-recipes-config);
    you should replace `felipmiguel` with your GitHub account, as explained in the
    *Setting up Spring Cloud Config* recipe. As mentioned in the previous step, I
    prepared the changes in the `distributed-tracing` branch:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, expose Spring Boot Admin through Spring Cloud Gateway. To do so, create
    a new route in the `gatewayserver.yml` file, as follows:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'management:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'endpoints:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'web:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'exposure:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'include: health,env,metrics,beans,loggers,prometheus'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'tracing:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'sampling:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'probability: 1.0'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '@SpringBootApplication'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '@EnableAdminServer'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '@EnableDiscoveryClient'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: public class FootballadminApplication
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <dependency>
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <groupId>org.springframework.cloud</groupId>
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependency>
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <dependencyManagement>
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <dependencies>
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <dependency>
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <groupId>org.springframework.cloud</groupId>
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <artifactId>spring-cloud-dependencies</artifactId>
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <version>${spring-cloud.version}</version>
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <type>pom</type>
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <scope>import</scope>
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependency>
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependencies>
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependencyManagement>
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <properties>
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <spring-cloud.version>2022.0.4</spring-cloud.version>
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </properties>
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'eureka:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'client:'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'serviceUrl:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'defaultZone: http://localhost:8761/eureka/'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'spring:'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'application:'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: football-api'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'server:'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'port: 0'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <dependency>
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <groupId>org.springframework.boot</groupId>
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </dependency>
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: spring
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'security:'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'oauth2:'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'resourceserver:'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'jwt:'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'audiences:'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- football'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- football-ui'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'issuer-uri: http://localhost:9000'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'spring:'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'cloud:'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'gateway:'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'routes:'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- id: teams'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'uri: lb://football-api'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'predicates:'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- Path=/football/**'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cloud label.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: curl --location 'http://localhost:9000/oauth2/token' \
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '--header ''Content-Type: application/x-www-form-urlencoded'' \'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --data-urlencode 'grant_type=client_credentials' --data-urlencode 'client_id=football'
    \
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --data-urlencode 'client_secret=SuperSecret' --data-urlencode 'scope=football:read'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'curl --location http://localhost:8080/football/teams -H "Authorization: Bearer
    <access token> with the access token you obtained from the authorization server.'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Part 2: Database Technologies'
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all applications need to persist and access data efficiently, and for
    that, Spring Boot offers many choices, from relational and NoSQL databases to
    repositories, templates, **Java Persistence Query Language** (**JPQL**), and native
    SQL.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21646_05.xhtml#_idTextAnchor203), *Data Persistence and Relational
    Database Integration with Spring Data*'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21646_06.xhtml#_idTextAnchor266), *Data Persistence and NoSQL
    Database Integration with Spring Data*'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
