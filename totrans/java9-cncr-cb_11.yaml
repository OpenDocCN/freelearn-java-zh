- en: Concurrent Programming Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发编程设计
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using immutable objects when possible
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用不可变对象
- en: Avoiding deadlocks by ordering locks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过排序锁来避免死锁
- en: Using atomic variables instead of synchronization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子变量而不是同步
- en: Holding locks for as short time as possible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能短时间持有锁
- en: Delegating the management of threads to executors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将线程的管理委托给执行器
- en: Using concurrent data structures instead of programming yourselves
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发数据结构而不是自己编程
- en: Taking precautions using lazy initialization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用懒初始化时采取预防措施
- en: Using the fork/join framework instead of executors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fork/join框架而不是执行器
- en: Avoiding the use of blocking operations inside a lock
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在锁内使用阻塞操作
- en: Avoiding the use of deprecated methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用已弃用方法
- en: Using executors instead of thread groups
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器而不是线程组
- en: Using streams to process big data sets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流来处理大数据集
- en: Other tips and tricks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他技巧和窍门
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Implementing a concurrent application is a difficult task. You have more than
    one thread in an execution at a time and all of them share resources, such as
    files, memory, objects, and so on. You have to be very careful with the design
    decisions you take. A bad decision can affect your program in a way that it would
    lead to poor performance or simply provoke data inconsistency situations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个并发应用程序是一项困难的任务。在执行过程中，你同时有多个线程，并且它们共享资源，如文件、内存、对象等。你必须对你的设计决策非常小心。一个糟糕的决定可能会以影响你的程序的方式导致性能下降或简单地引发数据不一致的情况。
- en: In this chapter, I've included some suggestions to help you take correct design
    decisions, which would make your concurrent application better.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提供了一些建议，以帮助您做出正确的设计决策，这将使您的并发应用程序变得更好。
- en: Using immutable objects when possible
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尽可能使用不可变对象
- en: When you develop an application in Java using object-oriented programming, you
    create some classes formed by attributes and methods. The methods of a class determine
    the operations that you can do with the class. Attributes store the data that
    defines the object. Normally, in each class, you implement some methods to establish
    the value of the attributes. Also, objects change as the application runs, and
    you use those methods to change the value of their attributes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用面向对象的编程在Java中开发应用程序时，你创建了一些由属性和方法组成的类。类的方法决定了你可以对该类执行的操作。属性存储定义对象的 数据。通常，在每一个类中，你实现一些方法来设置属性值。此外，对象在应用程序运行时也会发生变化，你使用这些方法来改变它们的属性值。
- en: When you develop a concurrent application, you have to pay special attention
    to the objects shared by more than one thread. You must use a synchronization
    mechanism to protect access to such objects. If you don't use it, you may have
    data inconsistency problems in your application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发一个并发应用程序时，你必须特别注意多个线程共享的对象。你必须使用同步机制来保护对这些对象的访问。如果你不使用它，你可能在应用程序中遇到数据不一致的问题。
- en: There are special kinds of objects that you can implement when you work with
    concurrent applications. They are called **immutable objects**; their main characteristic
    is that they can't be modified after they are created. If you need to change an
    immutable object, you must create a new one instead of changing the values of
    the attributes of the object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与并发应用程序一起工作时，你可以实现一些特殊类型的对象。它们被称为**不可变对象**；它们的主要特征是它们在创建后不能被修改。如果你需要更改不可变对象，你必须创建一个新的对象，而不是更改对象的属性值。
- en: 'This mechanism presents the following advantages when you use them in concurrent
    applications:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在并发应用程序中使用此机制时，它具有以下优点：
- en: These objects cannot be modified by any thread once they are created, so you
    won't need to use any synchronization mechanism to protect access to their attributes.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些对象一旦创建，就不能被任何线程修改，因此你不需要使用任何同步机制来保护对其属性的访问。
- en: You won't have any data inconsistency problems. As the attributes of these objects
    cannot be modified, you will always have access to a coherent copy of the data.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会遇到任何数据不一致的问题。由于这些对象的属性不能被修改，你将始终能够访问数据的一致副本。
- en: 'The only drawback of this approach is the overhead: creating new objects instead
    of modifying existing ones.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的唯一缺点是开销：创建新对象而不是修改现有对象。
- en: 'Java provides some immutable classes, such as the `String` class. When you
    have a `String` object and you try to assign a new value to it, you are creating
    a new `String` object instead of modifying the old value of the object. For example,
    check out the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一些不可变类，例如`String`类。当您有一个`String`对象，并尝试为其分配新值时，您实际上是在创建一个新的`String`对象，而不是修改对象的旧值。例如，查看以下代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the second line, JVM creates a new `String` object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，JVM创建了一个新的`String`对象。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的配方已使用Eclipse IDE实现。如果您使用Eclipse或不同的IDE，例如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement an immutable class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现不可变类：
- en: Mark the class as `final`. It should not be extended by another class.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类标记为`final`。它不应该被另一个类扩展。
- en: All the attributes must be `final` and `private`. You can assign a value to
    an attribute only once.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有属性都必须是`final`和`private`。您只能给属性赋值一次。
- en: Don't provide methods that can assign a value to an attribute. Attributes must
    be initialized in the constructor of the class.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要提供可以分配属性值的函数。属性必须在类的构造函数中初始化。
- en: If any field value object is mutable (for example, `java.util.Date`), always
    return a defensive copy in the getter field.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何字段值对象是可变的（例如，`java.util.Date`），在getter字段中始终返回防御性副本。
- en: 'Don''t leak the `this` reference from the immutable class constructor (for
    example, the following code that leaks the `this` reference before the constructor
    is complete):'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要从不可变类构造函数中泄露`this`引用（例如，在构造函数完成之前泄露`this`引用的以下代码）：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you want to implement a class that stores the first and last name of a person,
    you would normally implement something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想实现一个存储人的姓名和姓氏的类，您通常会实现如下：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can convert this class into an immutable class by following the rules explained
    earlier. The following is the result:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过遵循前面解释的规则将此类转换为不可变类。以下就是结果：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Essentially, you followed the basic principles of an immutable class, which
    are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您遵循了不可变类的基本原则，如下所示：
- en: The class is marked as `final`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类被标记为`final`。
- en: The attributes are marked as `final` and `private`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性被标记为`final`和`private`。
- en: The value of the attributes can only be established in the constructor of the
    class.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的值只能在类的构造函数中建立。
- en: Its methods return the value of an attribute, but they don't modify them.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们的方法返回属性的值，但不会修改它们。
- en: For mutable attributes (the `birthDate` attribute in our case), we return a
    defensive copy of the `get()` method by creating a new object.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可变属性（在我们的例子中是`birthDate`属性），我们通过创建一个新对象来返回`get()`方法的防御性副本。
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Immutable objects can't always be used. Analyze each class of your application
    to decide whether you can implement them as immutable objects or not. If you can't
    implement a class as an immutable class and its objects are shared by more than
    one thread, you must use a synchronization mechanism to protect access to the
    attributes of the class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象并不总是可以使用。分析您应用程序的每个类，以确定您是否可以将它们实现为不可变对象。如果您无法将一个类实现为不可变类，并且其对象被多个线程共享，您必须使用同步机制来保护对类属性的访问。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using atomic variables instead of synchronization* recipe in this chapter
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于“使用原子变量代替同步”的配方
- en: Avoiding deadlocks by ordering locks
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过排序锁来避免死锁
- en: When you need to acquire more than one lock in the methods of your application,
    you must be very careful with the order in which you get control of your locks.
    A bad choice can lead to a deadlock situation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在应用程序的方法中获取多个锁时，您必须非常小心地控制锁的获取顺序。错误的选择可能导致死锁情况。
- en: In this recipe, you will implement an example of a deadlock situation, then
    learn how to solve it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将实现一个死锁情况的示例，然后学习如何解决它。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `BadLocks` with two methods, named `operation1()` and
    `operation2()`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`BadLocks`的类，其中包含两个方法，分别命名为`operation1()`和`operation2()`：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's analyze the preceding code. If a thread calls the `operation1()` method
    and another thread calls the `operation2()` method, you can have a deadlock. If
    both `operation1()` and `operation2()` execute their respective first sentences
    at the same time, you will have the `operation1()` method waiting to get control
    of `lock2` and the `operation2()` method waiting to get control of `lock1`. Now
    you have a deadlock situation.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码。如果一个线程调用 `operation1()` 方法，而另一个线程调用 `operation2()` 方法，你可能会遇到死锁。如果
    `operation1()` 和 `operation2()` 同时执行它们各自的第一句话，那么 `operation1()` 方法将等待获取 `lock2`
    的控制权，而 `operation2()` 方法将等待获取 `lock1` 的控制权。现在你有一个死锁的情况。
- en: 'To solve this situation, you can follow this rule:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解决这个问题，你可以遵循以下规则：
- en: If you have to get control of more than one lock in different operations, try
    to lock them in the same order in all methods.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你必须在不同的操作中控制多个锁，尝试在所有方法中以相同的顺序锁定它们。
- en: Then, release them in inverse order and encapsulate the locks and their unlocks
    in a single class. This is so that you don't have synchronization-related code
    distributed throughout the code.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，以相反的顺序释放它们，并将锁及其解锁封装在单个类中。这样，你就不需要在代码中分散同步相关的代码。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using this rule, you will avoid deadlock situations. For example, in the case
    presented earlier, you can change `operation2()` to first get `lock1` and then
    `lock2`. Now if both `operation1()` and `operation2()` execute their respective
    first sentences, one of them will be blocked waiting for `lock1` and the other
    will get `lock1` and `lock2` and they will do their operations. After this, the
    blocked thread will get the `lock1` and `lock2` locks and it will do its operation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个规则，你将避免死锁情况。例如，在前面提到的案例中，你可以将 `operation2()` 改为首先获取 `lock1`，然后获取 `lock2`。现在如果
    `operation1()` 和 `operation2()` 同时执行它们各自的第一句话，其中一个将被阻塞等待 `lock1`，而另一个将获取 `lock1`
    和 `lock2` 并执行它们的操作。之后，被阻塞的线程将获取 `lock1` 和 `lock2` 锁，并执行其操作。
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can find a situation where a requirement prevents you from getting the locks
    in the same order in all the operations. In this situation, you can use the `tryLock()`
    method of the `Lock` class. This method returns a `Boolean` value to indicate
    whether you have control of the lock. You can try to get all the locks that you
    need to do the operation using the `tryLock()` method. If you can't get control
    of one of the locks, you must release all the locks that you may have had and
    start the operation again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一种情况，其中某个要求阻止你在所有操作中以相同的顺序获取锁。在这种情况下，你可以使用 `Lock` 类的 `tryLock()` 方法。此方法返回一个
    `Boolean` 值，以指示你是否控制了锁。你可以尝试使用 `tryLock()` 方法获取你需要的所有锁来完成操作。如果你无法控制其中一个锁，你必须释放你可能拥有的所有锁，并重新开始操作。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Holding locks for as short a time period as possible* recipe in this chapter
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *尽可能短时间持有锁* 的配方
- en: Using atomic variables instead of synchronization
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子变量而不是同步
- en: When you have to share data between multiple threads, you have to protect access
    to that piece of data using a synchronization mechanism. You can use the `synchronized`
    keyword in the declaration of the method that modifies the data so that only one
    thread can modify data at a time. Another possibility is the utilization of a
    `Lock` class to create a critical section with instructions that modify data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在多个线程之间共享数据时，你必须使用同步机制来保护对这块数据的访问。你可以在修改数据的方法的声明中使用 `synchronized` 关键字，以确保一次只有一个线程可以修改数据。另一种可能性是使用
    `Lock` 类来创建一个临界区，其中包含修改数据的指令。
- en: 'Since version 5, Java includes atomic variables. When a thread is doing an
    operation with an atomic variable, the implementation of the class includes a
    mechanism to check that the operation is done in one step. Basically, the operation
    gets the value of the variable, changes the value in a local variable, and then
    tries to change the old value with the new one. If the old value is still the
    same, it does the change. If not, the method begins the operation again. Java
    provides the following types of atomic variables:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 5 以来，Java 包含原子变量。当一个线程使用原子变量执行操作时，类的实现包括一个机制来检查操作是否一步完成。基本上，操作获取变量的值，在一个局部变量中更改值，然后尝试用新值替换旧值。如果旧值仍然是相同的，它就会进行更改。如果不是，方法将重新开始操作。Java
    提供以下类型的原子变量：
- en: '`AtomicBoolean`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicBoolean`'
- en: '`AtomicInteger`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicInteger`'
- en: '`AtomicLong`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicLong`'
- en: '`AtomicReference`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicReference`'
- en: In some cases, Java's atomic variables offer a better performance than solutions
    based on synchronization mechanisms (specially when we care about atomicity within
    each separate variable). Some classes of the `java.util.concurrent` package use
    atomic variables instead of synchronization. In this recipe, you will develop
    an example that shows how an atomic attribute provides better performance than
    synchronization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Java 的原子变量比基于同步机制的解决方案（尤其是当我们关心每个单独变量的原子性时）提供更好的性能。`java.util.concurrent`
    包中的某些类使用原子变量而不是同步。在这个菜谱中，你将开发一个示例，展示原子属性如何比同步提供更好的性能。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例已经使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，如 NetBeans，打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `TaskAtomic` and specify that it implements the `Runnable`
    interface:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TaskAtomic` 的类并指定它实现 `Runnable` 接口：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Declare a private `AtomicInteger` attribute named `number`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `number` 的私有 `AtomicInteger` 属性：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the `run()` method. In a loop with 1,000,000 steps, assign the number
    of steps to the atomic attribute as a value, using the `set()` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。在一个包含 1,000,000 步的循环中，使用 `set()` 方法将步数作为值分配给原子属性：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a class named `TaskLock` and specify that it implements the `Runnable`
    interface:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TaskLock` 的类并指定它实现 `Runnable` 接口：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Declare a private `int` attribute named `number` and a private `Lock` attribute
    named `lock`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `number` 的私有 `int` 属性和一个名为 `lock` 的私有 `Lock` 属性：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement the `run()` method. In a loop with 1,000,000 steps, assign the number
    of the steps to the integer attribute. You have to get the lock before the assignment
    and release it after:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。在一个包含 1,000,000 步的循环中，将步数分配给整数属性。你必须在分配之前获取锁，并在分配之后释放它：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a `TaskAtomic` object named `atomicTask`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `atomicTask` 的 `TaskAtomic` 对象：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a `TaskLock` object named `lockTask`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `lockTask` 的 `TaskLock` 对象：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Declare the number of threads and create an array of `Thread` objects to store
    the threads:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明线程数并创建一个 `Thread` 对象数组来存储线程：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Launch the specified number of threads to execute the `TaskLock` object. Calculate
    and write its execution time in the console:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动指定数量的线程来执行 `TaskLock` 对象。计算并写入其执行时间到控制台：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Launch the specified number of threads to execute the `TaskAtomic` object.
    Calculate and write its execution time in the console:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动指定数量的线程来执行 `TaskAtomic` 对象。计算并写入其执行时间到控制台：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you execute the example, you will see how the execution time of the `TaskAtomic`
    tasks that use atomic variables are always better than the `TaskLock` tasks that
    use locks. You will obtain a similar result if you use the `synchronized` keyword
    instead of locks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行示例时，你会看到使用原子变量的 `TaskAtomic` 任务的执行时间总是比使用锁的 `TaskLock` 任务的执行时间更好。如果你使用 `synchronized`
    关键字而不是锁，你将获得类似的结果。
- en: The conclusion of this recipe is that utilization of atomic variables will give
    you better performance than other synchronization methods. If you don't have an
    atomic type that fits your needs, maybe you can try to implement your own atomic
    type.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的结论是，利用原子变量将比其他同步方法提供更好的性能。如果你没有适合你需求的原子类型，也许你可以尝试实现你自己的原子类型。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing your own atomic object* recipe in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736), *Customizing
    Concurrency Classes*
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 8 章 [实现自己的原子对象](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736) 的
    *自定义并发类* 菜谱中
- en: Holding locks for as short time as possible
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尽可能短时间持有锁
- en: Locks, just like other synchronization mechanisms, allow the definition of a
    critical section that only one thread can execute at a time. You must be very
    careful to define the critical section. It must only include those instructions
    that really need mutual exclusion. This is especially true if the critical section
    includes long operations. If the critical section includes lengthy operations
    that do not use shared resources, application performance will be worse than it
    could be.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 锁，就像其他同步机制一样，允许定义一个临界区，一次只有一个线程可以执行。您必须非常小心地定义临界区。它必须只包括真正需要互斥的指令。如果临界区包括长时间操作，这一点尤为重要。如果临界区包括不使用共享资源的长时间操作，应用程序的性能将比可能的情况更差。
- en: In this recipe, you will implement an example to see the difference in the performance
    of a task with a long operation inside the critical section and a task with a
    long operation outside the critical section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，您将实现一个示例，以查看临界区内部有长时间操作的任务与临界区外部有长时间操作的任务之间的性能差异。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该菜谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Operations`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Operations` 的类：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement a `public static` method named `readData()`. It puts the current
    thread to sleep for 500 milliseconds:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `readData()` 的 `public static` 方法。它使当前线程休眠 500 毫秒：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Implement a `public static` method named `writeData()`. It puts the current
    thread to sleep for 500 milliseconds:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `writeData()` 的 `public static` 方法。它使当前线程休眠 500 毫秒：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Implement a `public static` method named `processData()`. It puts the current
    thread to sleep for 2,000 milliseconds:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `processData()` 的 `public static` 方法。它使当前线程休眠 2,000 毫秒：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement a class named `Task1` and specify that it implements the `Runnable`
    interface:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `Task1` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Declare a private `Lock` attribute named `lock`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `lock` 的私有 `Lock` 属性：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the `run()` method. Acquire the lock, call the three operations of
    the `Operations` class, and release the lock:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。获取锁，调用 `Operations` 类的三个操作，并释放锁：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement a class named `Task2` and specify that it implements the `Runnable`
    interface:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `Task2` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare a private `Lock` attribute named `lock`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `lock` 的私有 `Lock` 属性：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `run()` method. Acquire the lock, call the `readData()` operation,
    and release the lock. Then, call the `processData()` method, acquire the lock,
    call the `writeData()` operation, and release the lock:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。获取锁，调用 `readData()` 操作，并释放锁。然后，调用 `processData()` 方法，获取锁，调用 `writeData()`
    操作，并释放锁：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a `Lock` object named `lock`, a `Task1` object named `task1`, a `Task2`
    object named `task2`, and an array of 10 threads:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `lock` 的 `Lock` 对象，一个名为 `task1` 的 `Task1` 对象，一个名为 `task2` 的 `Task2` 对象，以及一个包含
    10 个线程的数组：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Launch 10 threads to execute the first task by controlling its execution time:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过控制执行时间来启动 10 个线程以执行第一个任务：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Launch 10 threads to execute the second task by controlling its execution time:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过控制执行时间来启动 10 个线程以执行第二个任务：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you execute the example, you will see a big difference between the execution
    time of the two approaches. The task that has all the operations inside the critical
    section takes longer than the other task.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行示例，您将看到两种方法执行时间之间的巨大差异。所有操作都在临界区内的任务比其他任务花费的时间更长。
- en: When you need to implement a block of code protected by a lock, analyze it carefully
    to only include necessary instructions. Split the method into various critical
    sections, and use more than one lock if necessary to get the best performance
    of your application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要实现一个受锁保护的代码块时，仔细分析它，只包括必要的指令。将方法拆分为多个关键部分，并在必要时使用多个锁以获得最佳的应用程序性能。
- en: See also
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Avoiding deadlocks by ordering locks* recipe in this chapter
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*通过排序锁避免死锁*的配方
- en: Delegating the management of threads to executors
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将线程管理委托给执行器
- en: Before Java 5, the Java Concurrency API, when we wanted to implement a concurrent
    application, we had to manage the threads by ourselves. First we used to implement
    the `Runnable` interface or an extension of the `Thread` class. Then, we used
    to create a `thread` object and start its execution using its `start()` method.
    We also had to control its status to know whether the thread had finished its
    execution or was still running.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 5之前，当我们想要实现一个并发应用程序时，我们必须自己管理线程。最初，我们通常实现`Runnable`接口或`Thread`类的扩展。然后，我们创建一个`thread`对象，并使用其`start()`方法启动其执行。我们还需要控制其状态，以了解线程是否已经完成执行或仍在运行。
- en: 'In Java version 5, the concept of executor as a provider of a pool of execution
    threads appeared. This mechanism, implemented by the `Executor` and `ExecutorService`
    interfaces and the `ThreadPoolExecutor` and `ScheduledThreadPoolExecutor` classes,
    allows you to concentrate only on the implementation of the logic of the task.
    You implement the task and send it to the executor. It has a pool of threads,
    and it is this pool that is responsible for the creation, management, and finalization
    of the threads. In Java version 7, another implementation of the executor mechanism
    in the fork/join framework, specialized in problems that can be broken down into
    smaller subproblems, appeared. This approach has numerous advantages, which are
    as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 5版本中，执行器作为提供执行线程池的提供者的概念出现。这种机制由`Executor`和`ExecutorService`接口以及`ThreadPoolExecutor`和`ScheduledThreadPoolExecutor`类实现，它允许您只关注任务的逻辑实现。您实现任务并将其发送到执行器。它有一个线程池，并且是这个池负责线程的创建、管理和最终化。在Java
    7版本中，在fork/join框架中出现了执行器机制的另一种实现，专门用于可以分解为更小子问题的任务。这种方法具有许多优势，如下所述：
- en: We don't have to create threads for all the tasks. When we send a task to the
    executor and it's executed by a thread of the pool, we save the time used in creating
    a new thread. If our application has to execute a lot of tasks, the total saved
    time will be significant and the performance of the application will be better.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要为所有任务创建线程。当我们向执行器发送任务，并由池中的线程执行时，我们节省了创建新线程所需的时间。如果我们的应用程序必须执行大量任务，那么节省的总时间将会非常显著，并且应用程序的性能将会更好。
- en: If we create fewer threads, our application will use less memory as well. This
    can also extract better performance from our application.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们创建的线程较少，我们的应用程序也将使用更少的内存。这也可以从我们的应用程序中提取更好的性能。
- en: We can build concurrent tasks executed in the executor by implementing either
    the `Runnable` or `Callable` interface. The `Callable` interface allows us to
    implement tasks that return a result, which provide a big advantage over traditional
    tasks.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过实现`Runnable`或`Callable`接口来构建由执行器执行的任务。`Callable`接口允许我们实现返回结果的任务，这比传统任务提供了很大的优势。
- en: When we send a task to an executor, it returns a `Future` object that allows
    us to know the status of the task and the returned result, whether it has finished
    its execution easily.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们向执行器发送任务时，它返回一个`Future`对象，允许我们轻松了解任务的状态和返回的结果，无论它是否已经完成执行。
- en: We can schedule our tasks and execute them repeatedly with the special executor
    implemented by the `ScheduledThreadPoolExecutor` class.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`ScheduledThreadPoolExecutor`类实现的特殊执行器来安排我们的任务并重复执行它们。
- en: We can easily control the resources used by an executor. We can establish the
    maximum number of threads in the pool, so our executor will never have more than
    that number of tasks running at a time.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松控制执行器使用的资源。我们可以设置池中线程的最大数量，这样我们的执行器就不会同时运行超过这个数量的任务。
- en: The use of executors has a lot of advantages over direct utilization of threads.
    In this recipe, you are going to implement an example that shows how you can obtain
    better performance using an executor than creating the threads yourself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接使用线程相比，使用执行器有很多优势。在本配方中，您将实现一个示例，展示如何使用执行器而不是自己创建线程来获得更好的性能。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方示例使用Eclipse IDE实现。如果您使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement the `run()` method. Create a loop with 1,000,000 steps, and in each
    step, do some mathematical operations with an integer variable:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现运行方法。创建一个包含 1,000,000 步的循环，并在每一步中，对一个整型变量进行一些数学运算：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例中的主类：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create 1,000 threads to execute 1,000 task objects and wait for their finalization,
    controlling the total execution time:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 1,000 个线程来执行 1,000 个任务对象并等待它们完成，控制总执行时间：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create an `Executor` object, send 1,000 `Task` objects to it, and wait for
    their finalization. Measure the total execution time:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Executor` 对象，发送 1,000 个 `Task` 对象给它，并等待它们完成。测量总执行时间：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the entire execution of this example, we always obtained a smaller execution
    time for the executor than creating the thread directly. If your application has
    to execute a lot of tasks, better employ an executor.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个示例执行过程中，我们总是获得了比直接创建线程更小的执行时间。如果你的应用程序必须执行大量任务，最好使用执行器。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using executors instead of thread groups* and *Using the fork/join framework
    instead of executors* recipes in this chapter
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用执行器而不是线程组* 和 *使用 fork/join 框架而不是执行器* 的食谱
- en: Using concurrent data structures instead of programming yourself
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发数据结构而不是自己编程
- en: Data structures are an essential part of every program. You always have to manage
    the data that you store in a data structure. Arrays, lists, or trees are examples
    of common data structures. The Java API provides a lot of ready-to-use data structures,
    but when you work with concurrent applications, you have to be careful because
    not all structures provided by the Java API are **thread-safe**. If you choose
    a data structure that is not thread-safe, you can have inconsistent data in your
    applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是每个程序的基本组成部分。你必须始终管理存储在数据结构中的数据。数组、列表或树是常见的数据结构示例。Java API 提供了许多现成可用的数据结构，但在处理并发应用程序时，你必须小心，因为
    Java API 提供的所有结构并不都是 **线程安全** 的。如果你选择了一个非线程安全的数据结构，你的应用程序中可能会有不一致的数据。
- en: 'When you want to use a data structure in your concurrent application, you have
    to review the documentation of the class that implements that data structure to
    check that it supports concurrent operations. Java provides the following two
    kinds of concurrent data structures:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在你的并发应用程序中使用一种数据结构时，你必须审查实现该数据结构的类的文档，以检查它是否支持并发操作。Java 提供以下两种类型的并发数据结构：
- en: '**Non-blocking data structures**: All the operations provided by these data
    structures to either insert in or take off elements from the data structure return
    a null value if they can''t be done currently because the data structure is full
    or empty respectively.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞数据结构**：这些数据结构提供的所有操作，无论是向数据结构中插入元素还是从中移除元素，如果当前无法执行（因为数据结构已满或为空），都会返回
    null 值。'
- en: '**Blocking data structures**: These data structures provide the same operations
    that are provided by non-blocking data structures. However, they also provide
    operations to insert and take off data that, if not done immediately, would block
    the thread until you''re able to do the operations.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞数据结构**：这些数据结构提供了与非阻塞数据结构相同的操作。然而，它们还提供了插入和移除数据操作，如果未立即执行，将阻塞线程，直到你能够执行操作。'
- en: 'These are some data structures provided by the Java API that you can use in
    your concurrent applications:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Java API 提供的一些数据结构，你可以在你的并发应用程序中使用：
- en: '`ConcurrentLinkedDeque`: This is a non-blocking data structure based on linked
    nodes that allow you to insert data at the beginning or end of the structure.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedDeque`：这是一个基于链节点的非阻塞数据结构，允许你在结构的开始或末尾插入数据。'
- en: '`LinkedBlockingDeque`: This is a blocking data structure based on linked nodes.
    It can have fixed capacity. You can insert elements at the beginning or end of
    the structure. It provides operations that, if not done immediately, block the
    thread until you''re able to do the operation.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedBlockingDeque`：这是一个基于链节点的阻塞数据结构。它可以具有固定容量。你可以在结构的开始或末尾插入元素。它提供了操作，如果未立即执行，将阻塞线程，直到你能够执行操作。'
- en: '`ConcurrentLinkedQueue`: This is a non-blocking queue that allows you to insert
    elements at the end of the queue and take elements from its beginning.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedQueue`：这是一个非阻塞队列，允许您在队列末尾插入元素并从其开头取出元素。'
- en: '`ArrayBlockingQueue`: This is a blocking queue with fixed size. You insert
    elements at the end of the queue and take elements from its beginning. It provides
    operations that, if not done because the queue is either full or empty, puts the
    thread to sleep until you''re able to do the operation.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayBlockingQueue`：这是一个固定大小的阻塞队列。您可以在队列的末尾插入元素，并从其开头取出元素。它提供了操作，如果因为队列已满或为空而没有执行，则将线程休眠，直到您能够执行操作。'
- en: '`LinkedBlockingQueue`: This is a blocking queue that allows you to insert elements
    at the end of the queue and take off elements from its beginning. It provides
    operations that, if not done because the queue is either full or empty, puts the
    thread to sleep until you''re able to do the operation.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedBlockingQueue`：这是一个允许您在队列末尾插入元素并从其开头取出元素的阻塞队列。它提供了操作，如果因为队列已满或为空而没有执行，则将线程休眠，直到您能够执行操作。'
- en: '`DelayQueue`: This is a `LinkedBlockingQueue` queue with delayed elements.
    Every element inserted in this queue must implement the `Delayed` interface. An
    element can''t be taken off the list until its delay is 0.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DelayQueue`：这是一个带有延迟元素的`LinkedBlockingQueue`队列。每个插入到该队列的元素都必须实现`Delayed`接口。一个元素不能从列表中移除，直到其延迟时间为0。'
- en: '`LinkedTransferQueue`: This is a blocking queue that provides operations to
    work in situations that can be implemented as a producer/consumer problem. It
    provides operations that, if not done because the queue is either full or empty,
    puts the thread to sleep until you''re able to do the operation.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedTransferQueue`：这是一个阻塞队列，提供在可以表示为生产者/消费者问题的场景中工作的操作。它提供了操作，如果因为队列已满或为空而没有执行，则将线程休眠，直到您能够执行操作。'
- en: '`PriorityBlockingQueue`: This is a blocking queue that orders its elements
    based on priority. All the elements inserted in this queue must implement the
    `Comparable` interface. The value returned by the `compareTo()` method will determine
    the position of the element in the queue. Just like all the blocking data structures,
    it provides operations that, if done immediately, puts the thread to sleep until
    you''re able to do the operation.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`：这是一个基于优先级对元素进行排序的阻塞队列。所有插入到该队列的元素都必须实现`Comparable`接口。`compareTo()`方法返回的值将确定元素在队列中的位置。就像所有阻塞数据结构一样，它提供了操作，如果立即执行，则将线程休眠，直到您能够执行操作。'
- en: '`SynchronousQueue`: This is a blocking queue where every `insert` operation
    must wait for a `remove` operation for the other thread. The two operations must
    be done at the same time.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SynchronousQueue`：这是一个阻塞队列，其中每个`insert`操作都必须等待另一个线程的`remove`操作。这两个操作必须同时进行。'
- en: '`ConcurrentHashMap`: This is a `HashMap` that allows concurrent operations.
    It''s a non-blocking data structure.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`：这是一个允许并发操作的自定义`HashMap`。它是一个非阻塞的数据结构。'
- en: '`ConcurrentSkipListMap`: This data structure associates keys with values. Every
    key can have only one value. It stores the keys in an ordered way and provides
    a method to find elements and get some elements from the map. It''s a non-blocking
    data structure.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListMap`：此数据结构将键与值关联。每个键只能有一个值。它以有序方式存储键并提供方法来查找元素和从映射中获取一些元素。它是一个非阻塞数据结构。'
- en: There's more...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you need to use a data structure in your concurrent application, look in
    the Java API documentation to find the data structure that best fits your needs.
    Implement your own concurrent data structure that has some problems, which are
    as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在您的并发应用程序中使用数据结构，请查看Java API文档以找到最适合您需求的数据结构。实现您自己的并发数据结构，它存在以下问题：
- en: They have a complex internal structure
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有复杂的内部结构
- en: You have to take into account a lot of different situations
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须考虑许多不同的情况
- en: You have to design a lot of tests to guarantee that it works correctly
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须设计大量的测试来确保其正确性
- en: If you don't find a data structure that fits your needs completely, try to extend
    one of the existing concurrent data structures to implement one adequately to
    your problem.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到完全符合您需求的数据结构，请尝试扩展现有的并发数据结构之一，以适当地实现您的问题。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The recipes in [Chapter 7](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736),
    *Concurrent Collections*
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](part0304.html#91TB00-69b77957c9a14e36a0bec5f5a1363736)中的食谱，*并发集合*'
- en: Taking precautions using lazy initialization
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用懒加载时的注意事项
- en: '**Lazy initialization** is a common programming technique that delays object
    creation until it is needed for the first time. This normally causes the initialization
    of the objects to be made in the implementation of the operations, instead of
    the constructor of the classes. The main advantage of this technique is that you
    can save memory. This is because you only create the indispensable objects needed
    for the execution of your applications. You could have declared a lot of objects
    in one class, but you don''t use every object in every execution of your program;
    therefore, your application doesn''t use the memory needed for the objects that
    you don''t use in an execution of the program. This advantage can be very useful
    for applications that run in environments with limited resources.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒加载**是一种常见的编程技术，它将对象创建推迟到第一次需要时。这通常会导致对象初始化是在操作的实现中而不是在类的构造函数中进行的。这种技术的优点是您可以节省内存。这是因为您只为应用程序的执行创建必需的对象。您可以在一个类中声明很多对象，但在程序的每次执行中，您并不使用每个对象；因此，您的应用程序不会使用在程序执行中不使用的对象的内存。这种优势对于在资源有限的环境中运行的应用程序非常有用。'
- en: By contrast, this technique has the disadvantage of having performance issues
    in your application, as you create objects the first time they are used inside
    an operation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，这种技术在第一次在操作中使用对象时创建对象，可能会在应用程序中引起性能问题。
- en: 'This technique can also provoke problems if you use it in concurrent applications.
    As more than one thread can be executing an operation at a time, they can be creating
    an object at the same time, and this situation can be problematic. This has a
    special importance with **singleton** classes. An application has only one object
    of these classes and, as mentioned earlier, a concurrent application can create
    more than one object. Consider the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在并发应用程序中使用此技术，它也可能引发问题。由于一次可以有多个线程执行操作，它们可以在同一时间创建对象，这种情况可能会出现问题。这对于**单例**类尤为重要。应用程序只有一个这些类的对象，如前所述，并发应用程序可以创建多个对象。考虑以下代码：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is the typical method in a singleton class to obtain the reference of the
    unique object of that class existing in the application, using lazy initialization.
    If the object hasn't been created yet, it creates the object. Finally, it always
    returns it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单例类中获取该类在应用程序中存在的唯一对象引用的典型方法，使用懒加载初始化。如果对象尚未创建，则创建该对象。最后，它总是返回它。
- en: If two or more threads executes at the same time the comparison of the first
    sentence (`connection == null`), all of them will create a `Connection` object.
    This isn't a desirable situation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个或多个线程同时执行第一句话的比较（`connection == null`），它们都会创建一个 `Connection` 对象。这不是一个理想的情况。
- en: In this recipe, you will implement an elegant solution to the lazy initialization
    problem.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将实现一个优雅的懒初始化问题的解决方案。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `DBConnectionOK`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DBConnectionOK` 的类：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare a `private` constructor. Write the name of the thread that executes
    it:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `private` 构造函数。写上执行它的线程名称：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Declare a `private static` class named `LazyDBConnectionOK`. It has a `private
    static final DBConnectionOK` instance named `INSTANCE`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `LazyDBConnectionOK` 的 `private static` 类。它有一个名为 `INSTANCE` 的 `private
    static final DBConnectionOK` 实例：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `getConnection()` method. It doesn''t receive any parameter and
    returns a `DBConnectionOK` object. It returns the `INSTANCE` object:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `getConnection()` 方法。它不接受任何参数，并返回一个 `DBConnectionOK` 对象。它返回 `INSTANCE` 对象：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface.
    Implement the `run()` method. Call the `getConnection()` method of the `DBConnectionOK()`
    method:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口。实现 `run()` 方法。调用 `DBConnectionOK()` 方法的
    `getConnection()` 方法：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create 20 `Task` objects and 20 threads to execute them:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建20个 `Task` 对象和20个线程来执行它们：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key of the example is the `getConnection()` method and the `private static
    class LazyDBConnection` instance. When the first thread calls the `getConnection()`
    method, the `LazyDBConnection` class initializes the `INSTANCE` object by calling
    the constructor of the `DBConnection` class. This object is returned by the `getConnection()`
    method. When the rest of the threads call the `getConnection()` method, the object
    is already created, so all the threads use the same object that is created only
    once.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的关键是 `getConnection()` 方法以及 `private static class LazyDBConnection` 实例。当第一个线程调用
    `getConnection()` 方法时，`LazyDBConnection` 类通过调用 `DBConnection` 类的构造函数来初始化 `INSTANCE`
    对象。这个对象由 `getConnection()` 方法返回。当其他线程调用 `getConnection()` 方法时，对象已经创建，所以所有线程都使用只创建一次的同一个对象。
- en: When you run the example, you will see the start and end messages of 20 tasks,
    but only one creation message.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行示例时，你会看到20个任务的开始和结束消息，但只有一个创建消息。
- en: Using the fork/join framework instead of executors
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fork/join 框架而不是执行器
- en: Executors allow you to avoid the creation and management of threads. You implement
    tasks by implementing `Runnable` or `Callable` interfaces and sending them to
    the executor. It has a pool of threads and uses one of them to execute the tasks.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Executors 允许你避免创建和管理线程。你通过实现 `Runnable` 或 `Callable` 接口来执行任务，并将它们发送到执行器。它有一个线程池，并使用其中的一个来执行任务。
- en: Java 7 provides a new kind of executor with the fork/join framework. This executor,
    implemented in the `ForkJoinPool` class, is designed for problems that can be
    split into smaller parts using the divide and conquer technique. When you implement
    a task for the fork/join framework, you have to check the size of the problem
    you have to resolve. If it's bigger than a predefined size, you divide the problem
    into two or more subcategories and create as many subtasks as the number of divisions
    you have made. The task sends these subtasks to the `ForkJoinPool` class using
    the `fork()` operation and waits for its finalization using the `join()` operation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 提供了一种新的 executor，即 fork/join 框架。这个在 `ForkJoinPool` 类中实现的 executor，旨在解决可以使用划分和征服技术划分为更小部分的问题。当你为
    fork/join 框架实现任务时，你必须检查你要解决的问题的大小。如果它大于预定义的大小，你将问题划分为两个或更多子类别，并创建与划分次数相等的子任务。任务使用
    `fork()` 操作将这些子任务发送到 `ForkJoinPool` 类，并使用 `join()` 操作等待它们的最终化。
- en: For these kinds of problems, fork/join pools get better performance than classical
    executors. In this recipe, you are going to implement an example where you can
    check this point.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类问题，fork/join 池比经典执行器有更好的性能。在这个菜谱中，你将实现一个示例，以检查这个点。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例是使用 Eclipse IDE 实现的。如果你使用 Eclipse 或其他 IDE，例如 NetBeans，打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `TaskFJ` and specify that it extends the `RecursiveAction`
    class:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TaskFJ` 的类，并指定它扩展 `RecursiveAction` 类：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declare a private array of `int` numbers named `array`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `array` 的私有 `int` 数组：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Declare two private `int` attributes, named `start` and `end`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为 `start` 和 `end` 的私有 `int` 属性：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the `compute()` method. If this task has to process a block of more
    than 1,000 elements (determined by the `start` and `end` attributes), create two
    `TaskFJ` objects, send them to the `ForkJoinPool` class using the `fork()` method,
    and wait for their finalization using the `join()` method:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `compute()` 方法。如果这个任务需要处理超过1,000个元素的块（由 `start` 和 `end` 属性确定），创建两个 `TaskFJ`
    对象，使用 `fork()` 方法将它们发送到 `ForkJoinPool` 类，并使用 `join()` 方法等待它们的最终化：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Otherwise, increment the elements that this task has to process. After every
    increment operation, put the thread to sleep for 1 millisecond:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，增加这个任务需要处理的元素。在每次增加操作后，让线程休眠1毫秒：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Declare a private array of `int` number named `array`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `array` 的私有 `int` 数组：
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Implement the `run()` method. Increment all the elements of the array. After
    every increment operation, put the thread to sleep for 1 millisecond:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`run()`方法。增加数组中所有元素。在每次增加操作后，让线程休眠1毫秒：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create an `int` array with 100,000 elements:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含100,000个元素的`int`数组：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create a `Task` object and a `ThreadPoolExecutor` object and execute them.
    Execute the task by controlling the time during which the task is running:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Task`对象和一个`ThreadPoolExecutor`对象并执行它们。通过控制任务运行的时间来执行任务：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a `TaskFJ` object and a `ForkJoinPool` object and execute them. Execute
    the task by controlling the time during which the task is running:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TaskFJ`对象和一个`ForkJoinPool`对象并执行它们。通过控制任务运行的时间来执行任务：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you execute the example, you will see how the `ForkJoinPool` and `TaskFJ`
    classes get better performance than the `ThreadPoolExecutor` and `Task` classes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行示例时，你会看到`ForkJoinPool`和`TaskFJ`类比`ThreadPoolExecutor`和`Task`类有更好的性能。
- en: If you have to solve a problem that can be split using the divide and conquer
    technique, use a `ForkJoinPool` class instead of a `ThreadPoolExecutor` class.
    You will get better performance.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须解决一个可以使用分而治之技术分割的问题，请使用`ForkJoinPool`类而不是`ThreadPoolExecutor`类。你将获得更好的性能。
- en: See also
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Delegating the management of threads to executors* recipe of this chapter
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*将线程管理委托给执行器*食谱
- en: Avoiding the use of blocking operations inside a lock
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在锁内部使用阻塞操作
- en: '**Blocking operations** are operations that block the execution of the current
    thread until an event occurs. Typical blocking operations are those that involve
    input or output operations with the console, a file, or network.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻塞操作**是那些在事件发生之前阻止当前线程执行的操作。典型的阻塞操作包括与控制台、文件或网络的输入或输出操作。'
- en: If you use a blocking operation inside the critical section of a lock, you're
    deteriorating the performance of the application. While a thread is waiting for
    the event that would finish the blocking operation, the rest of the application
    might be waiting for the same event as well; however, none of the other threads
    will have access to the critical section and execute its code (the code of the
    critical section).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个锁的临界区内部使用阻塞操作，你会降低应用程序的性能。当一个线程正在等待完成阻塞操作的事件时，应用程序的其余部分可能也在等待相同的事件；然而，其他线程将无法访问临界区并执行其代码（临界区的代码）。
- en: In this recipe, you will implement an example of this situation. The threads
    read a line from the console inside the critical section. This instruction makes
    the rest of the threads of the application will be blocked until the user introduces
    the line.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将实现这种情况的一个示例。线程在临界区内部从控制台读取一行。这条指令使得应用程序的其他线程将被阻塞，直到用户输入该行。
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类并指定它实现`Runnable`接口：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Declare a private `Lock` attribute named `lock`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`lock`的私有`Lock`属性：
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Implement the `run()` method:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`run()`方法：
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Acquire the lock using the `lock()` method:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lock()`方法获取锁：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Call the `criticalSection()` method:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`criticalSection()`方法：
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Read a line from the console:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制台读取一行：
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Free the lock using the `unlock()` method in the finally section:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`finally`部分中的`unlock()`方法释放锁：
- en: '[PRE72]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Implement the `criticalSection()` method. Wait for a random period of time:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`criticalSection()`方法。等待一个随机的时间段：
- en: '[PRE73]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Implement the main class of the application by creating a class named `Main`
    and adding the `main()` method to it:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现应用程序的主类：
- en: '[PRE74]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create a new `ReentrantLock` object named `lock`. Create 10 `Task` objects
    and 10 threads to execute them:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`lock`的新`ReentrantLock`对象。创建10个`Task`对象和10个线程来执行它们：
- en: '[PRE75]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you execute this example, 10 threads start their execution, but only one
    enters in the critical section, which gets implemented in the `run()` method.
    As every task reads a line from the console before releasing the lock, all the
    applications will be blocked until you introduce text in the console.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行此示例时，10个线程开始执行，但只有一个进入临界区，该临界区在`run()`方法中实现。由于每个任务在释放锁之前都会从控制台读取一行文本，因此所有应用程序都将被阻塞，直到您在控制台中输入文本。
- en: See also
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Holding locks for as short a time period as possible* recipe
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能短地持有锁*的技巧'
- en: Avoiding the use of deprecated methods
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用已弃用的方法
- en: The Java concurrency API also has deprecated operations. These are operations
    that were included in the first versions of the API, but now you shouldn't use
    them. They have been replaced by other operations that implement better practices
    than the original ones.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API也有一些已弃用的操作。这些是包含在API的第一个版本中的操作，但现在您不应使用它们。它们已被其他操作所取代，这些操作实现了比原始操作更好的实践。
- en: 'The more critical deprecated operations are those that are provided by the
    `Thread` class. These operations are:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最关键的已弃用操作是那些由`Thread`类提供的。这些操作包括：
- en: '`destroy()`: In the past, this method destroyed the thread. Actually, it throws
    a `NoSuchMethodError` exception.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy()`: 在过去，此方法销毁线程。实际上，它抛出`NoSuchMethodError`异常。'
- en: '`suspend()`: This method suspends the execution of the thread until it''s resumed.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend()`: 此方法将线程的执行挂起，直到它被恢复。'
- en: '`stop()`: This method forces the thread to finish its execution.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`: 此方法强制线程完成其执行。'
- en: '`resume()`: This method resumes the execution of the thread.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume()`: 此方法恢复线程的执行。'
- en: 'The `ThreadGroup` class also has some deprecated methods, which are as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadGroup`类也有一些已弃用的方法，如下所示：'
- en: '`suspend()`: This method suspends the execution of all the threads that belong
    to this thread group until they resume'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend()`: 此方法将此线程组中属于此线程的所有线程的执行挂起'
- en: '`stop()`: This method forces the execution of all the threads of this thread
    group to finish'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop()`: 此方法强制此线程组中所有线程的执行完成'
- en: '`resume()`: This method resumes the execution of all the threads of this thread
    group'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume()`: 此方法恢复此线程组中所有线程的执行'
- en: The `stop()` operation has been deprecated because it can provoke inconsistent
    errors. As it forces the thread to finish its execution, you can have a thread
    that finishes its execution before the completion of an operation and can leave
    the data in an inconsistent status. For example, if you have a thread that is
    modifying a bank account and it's stopped before it is finished, the bank account
    will probably have erroneous data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop()`操作已被弃用，因为它可能引发不一致的错误。因为它强制线程完成其执行，您可能会遇到线程在操作完成之前完成其执行，并可能使数据处于不一致状态的情况。例如，如果您有一个正在修改银行账户的线程，并且在完成之前被停止，那么银行账户可能包含错误数据。'
- en: The `stop()` operation can also cause a deadlock situation. If this operation
    is called when the thread is executing a critical section protected by a synchronization
    mechanism (for example, a lock), this synchronization mechanism will continue
    to block and no thread will be able to enter the critical section. This is the
    reason why the `suspend()` and `resume()` operations have been deprecated.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop()`操作也可能导致死锁情况。如果在线程执行由同步机制（例如，锁）保护的临界区时调用此操作，则此同步机制将继续阻塞，并且没有线程能够进入临界区。这就是为什么`suspend()`和`resume()`操作已被弃用的原因。'
- en: If you need an alternative to these operations, you can use an internal attribute
    to store the status of the thread. This attribute must be protected with synchronized
    access, or use an atomic variable. You must check the value of this attribute
    and take actions according to it. Take into account that you have to avoid data
    inconsistency and deadlock situations to guarantee the correct operation of your
    application.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要这些操作的替代方案，可以使用一个内部属性来存储线程的状态。此属性必须使用同步访问进行保护，或者使用原子变量。您必须检查此属性值并根据它采取行动。请注意，您必须避免数据不一致和死锁情况，以确保应用程序的正确运行。
- en: Using executors instead of thread groups
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用执行器而不是线程组
- en: The `ThreadGroup` class provides a mechanism to group threads in a hierarchical
    structure so you can do operations with all the threads that belong to a thread
    group with only one call. By default, all the threads belong to the same group,
    but you can specify a different one when you create the thread.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, thread groups don''t provide any features that make their use interesting:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: You have to create the threads and manage their status
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods that control the status of all the threads of the thread group have
    been deprecated and their use is discouraged
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need to group threads under a common structure, it is better to use
    an `Executor` implementation, such as `ThreadPoolExecutor`. It provides more functionalities,
    which are as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to worry about the management of the threads. The executor creates
    and reuses them to save execution resources.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can implement your concurrent tasks by implementing either the `Runnable`
    or `Callable` interface. The `Callable` interface allows you to implement tasks
    that return a result, which provides a big advantage over traditional tasks.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you send a task to an executor, it returns a `Future` object that allows
    you to know the status of the task and the returned result if it has finished
    its execution easily.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can schedule your tasks and execute them repeatedly with the special executor
    implemented by the `ScheduledThreadPoolExecutor` class.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can easily control the resources used by an executor. You can establish
    the maximum number of threads in the pool so your executor will never have more
    than that number of tasks running at a time.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, it is better that you don't use thread groups and use executors
    instead.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Delegating the management of threads to executors* recipe in this chapter
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using streams to process big data sets
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Stream` interface is a sequence of elements that can be filtered and transformed
    to get a final result sequentially or in parallel. This final result can be a
    primitive data type (an integer, a long ...), an object or a data structure. These
    are the characteristics that better define `Stream`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: A stream is a sequence of data, not a data structure.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create streams from different sources as collections (lists, arrays...),
    files, strings, or a class that provides the elements of the stream.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't access an individual element of the streams.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't modify the source of the stream.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Streams define two kinds of operations: intermediate operations that produce
    a new `Stream` interface that allows you to transform, filter, map, or sort the
    elements of the stream and terminal operations that generate the final result
    of the operation. A stream pipeline is formed by zero or more intermediate operations
    and a final operation.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediate operations are lazy. They're not executed until the terminal operation
    begins its execution. Java can avoid the execution of an intermediate operation
    over an element or a set of elements of the stream if it detects that it doesn't
    affect the final result of the operation.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间操作是懒执行的。它们不会在终端操作开始执行之前执行。如果Java检测到中间操作不会影响操作最终结果，它可以避免对流中的元素或元素集合执行中间操作。
- en: When you need to implement an operation that processes a big set of data in
    a concurrent way, you can use different elements of the **Java Concurrency API**
    to implement it. Java threads to either the **fork/join framework** or the **Executor
    framework**, but I think parallel streams are the best option. In this recipe,
    we will implement an example to explain the advantages that are provided by the
    use of parallel streams.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要以并发方式实现处理大量数据的操作时，你可以使用**Java并发API**的不同元素来实现它。你可以将Java线程分配给**fork/join框架**或**Executor框架**，但我认为并行流是最佳选择。在这个菜谱中，我们将实现一个示例来解释使用并行流提供的优势。
- en: Getting ready
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Person`. This class will have six attributes to define
    some basic characteristics of a person. We will implement the methods to `get()`
    and `set()` the values of the attributes, but they won''t be included here:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Person`的类。这个类将有六个属性来定义一个人的基本特征。我们将实现获取和设置属性值的方法，但它们将不包括在这里：
- en: '[PRE76]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, implement a class named `PersonGenerator`. This class will only have a
    method named `generatedPersonList()` to generate a list of `Person` objects with
    random values with the size specified in parameters. This is the source code of
    this class:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现一个名为`PersonGenerator`的类。这个类将只有一个名为`generatedPersonList()`的方法，用于生成具有指定参数大小的随机`Person`对象列表。这是该类的源代码：
- en: '[PRE77]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, implement a task named `PersonMapTask`. The main purpose of this task
    will be to convert a list of persons on a map, where the keys will be the name
    of the persons and the values will be a list with `Person` objects whose name
    is equal to the key. We will use the fork/join framework to implement this transformation,
    so the `PersonMapTask`  will extend the `RecursiveAction` class:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现一个名为`PersonMapTask`的任务。这个任务的主要目的是将人员列表转换为映射，其中键将是人员的姓名，值将是具有与键相同名称的`Person`对象的列表。我们将使用fork/join框架来实现这种转换，因此`PersonMapTask`将扩展`RecursiveAction`类：
- en: '[PRE78]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `PersonMapTask` class will have two private attributes: `List` of `Person`
    objects to process and `ConcurrentHashMap` to store results. We will use the constructor
    of the class to initialize both the attributes:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PersonMapTask`类将有两个私有属性：要处理的`Person`对象列表和用于存储结果的`ConcurrentHashMap`。我们将使用类的构造函数来初始化这两个属性：'
- en: '[PRE79]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now it''s time to implement the `compute()` method. If the list has less than
    1,000 elements, we will process the elements and insert them in `ConcurrentHashMap`.
    We will use the `computeIfAbsent()` method to get `List` associated with a key
    or generate a new `ConcurrentMapedDeque` object if the key doesn''t exist in the
    map:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候实现`compute()`方法了。如果列表少于1,000个元素，我们将处理元素并将它们插入到`ConcurrentHashMap`中。我们将使用`computeIfAbsent()`方法获取与键关联的`List`或如果键不存在于映射中，则生成一个新的`ConcurrentMapedDeque`对象：
- en: '[PRE80]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If `List` has more than 1,000 elements, we will create two child tasks and
    delegate the process of a part of the list to them:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`List`有超过1,000个元素，我们将创建两个子任务并将列表的一部分处理过程委托给它们：
- en: '[PRE82]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, implement the `Main` class with the `main()` method. First, generate
    a list with 100,000 random `Person` objects:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现带有`main()`方法的`Main`类。首先，生成一个包含100,000个随机`Person`对象的列表：
- en: '[PRE83]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, compare two methods to generate `Map` with the names as keys, which are
    part of `List`, and `Person` as value. List will use a parallel `Stream` function
    and the `collect()` method using the `groupingByConcurrent()` collector:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，比较两种方法来生成以名称作为键、`Person`作为值的`Map`。列表将使用并行`Stream`函数和`collect()`方法使用`groupingByConcurrent()`收集器：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The second option is using the fork/join framework and the `PersonMapTask`
    class:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种选择是使用fork/join框架和`PersonMapTask`类：
- en: '[PRE85]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How it works...
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we implemented two different versions of the same algorithm
    to obtain `Map` from `List`. If you execute it, you will obtain the same results
    and a similar execution time (at least the latter is true in my case when I executed
    the example in a four core computer). The biggest advantage we obtained using
    streams is the simplicity of the solution and its development time. With only
    one line of code, we implemented the solution. While in the other case, we implemented
    a new class (the `PersonMapTask`) using concurrent data structures and then executed
    it in the fork/join framework.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了从`List`到`Map`的同一算法的两个不同版本。如果你执行它，你会得到相同的结果和相似的执行时间（至少在我用四核计算机执行示例时，后者是正确的）。我们使用流获得的最大优势是解决方案的简单性和其开发时间。我们只用一行代码就实现了解决方案。而在另一种情况下，我们使用并发数据结构实现了一个新的类（`PersonMapTask`），然后在fork/join框架中执行它。
- en: With Streams, you can divide your algorithm into simple steps that can be expressed
    in an elegant way, be easy to program and understand.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流，你可以将你的算法分解成简单的步骤，这些步骤可以用优雅的方式表达，易于编程和理解。
- en: See also
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Sorting the elements of a stream* recipes in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and reactive streams*
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736)中的*从不同来源创建流*、*减少流元素*和*排序流元素*的菜谱，*并行和反应流*'
- en: Other tips and tricks
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他技巧和窍门
- en: 'In this final recipe, we have included other tips and tricks that haven''t
    been included in other recipes of the chapter:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的菜谱中，我们包括了本章其他菜谱中没有包含的其他技巧和窍门：
- en: 'Whenever possible, use concurrent design patterns: In software engineering,
    a design pattern is a solution to a common problem. They are commonly used in
    software development and concurrency applications and are not an exception. Patterns
    such as signaling, rendezvous, and mutex define how to implement concurrent applications
    in concrete situations, and they have been used to implement concurrent utilities.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用并发设计模式：在软件工程中，设计模式是解决常见问题的方案。它们在软件开发和并发应用中普遍使用，并不例外。如信号量、 rendezvous
    和互斥锁等模式定义了如何在具体情况下实现并发应用程序，并且它们已被用于实现并发工具。
- en: 'Implement concurrency at the highest possible level: Rich threading APIs, such
    as the Java concurrency API, offer you different classes to implement concurrency
    in your applications. Try to use the ones that provide you a higher level of abstraction.
    It will make it easier for you to implement your algorithm, and they are optimized
    to give better performance than using threads directly. Therefore, performance
    won''t be a problem.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尽可能高的级别上实现并发：丰富的线程API，如Java并发API，为你提供了不同的类来实现应用程序中的并发。尽量使用那些提供更高抽象级别的类。这将使你更容易实现你的算法，并且它们被优化以提供比直接使用线程更好的性能。因此，性能不会成为问题。
- en: 'Take scalability into account: One of the main objectives when you implement
    a concurrent algorithm is to take advantage of all the resources of your computer,
    especially the number of processors or cores. But this number may change over
    time. When you design a concurrent algorithm, don''t presuppose the number of
    cores or processors that your application will execute on. Get information about
    the system dynamically. For example, in Java, you can get it with the `Runtime.getRuntime().availableProcessors()` method
    and make your algorithm use this information to calculate the number of tasks
    it''s going to execute.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑可伸缩性：当你实现一个并发算法时，主要目标之一是利用你计算机的所有资源，特别是处理器或核心的数量。但这个数字可能会随时间变化。当你设计一个并发算法时，不要预设你的应用程序将要执行的核心或处理器的数量。动态获取系统信息。例如，在Java中，你可以使用`Runtime.getRuntime().availableProcessors()`方法来获取它，并让你的算法使用这些信息来计算它将要执行的任务数量。
- en: 'Prefer local thread variables over static and shared when possible: Thread
    local variables are a special kind of variable. Every task will have an independent
    value for this variable, so you don''t need any synchronization mechanism to protect
    access to it.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，优先使用局部线程变量而不是静态和共享变量：线程局部变量是一种特殊的变量。每个任务都将为这个变量有一个独立的值，因此你不需要任何同步机制来保护对它的访问。
- en: See also
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: All the recipes in this chapter
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章所有菜谱
