<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Java Messaging Service</h1>
                </header>
            
            <article>
                
<p>The <strong>Java</strong> <strong>Messaging</strong> <strong>API</strong> (<strong>JMS</strong>) provides a mechanism for Java EE applications to send messages to each other. Java EE 7 introduced JMS 2.0, which greatly simplified the development of applications involving messaging functionality.</p>
<p>JMS applications do not communicate directly; instead, message producers send messages to a destination, and message consumers receive messages from that destination.</p>
<p>A message destination is a message queue when the <strong>Point-To-Point</strong> (<strong>PTP</strong>) messaging domain is used, or a message topic when the Publish/Subscribe (pub/sub) messaging domain is used.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Working with message queues</li>
<li>Working with message topics</li>
</ul>
<p>Most application servers need to be configured in order for JMS applications to work properly. The <a href="e125af24-9bf3-427d-a71c-22461bbf34fc.xhtml">Appendix</a>, <em>Configuring and deploying to GlassFish</em>, includes instructions for configuring GlassFish. Consult your application server documentation for instructions on configuring other Java EE 8 compliant application servers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message queues</h1>
                </header>
            
            <article>
                
<p>As we mentioned earlier, Message queues are used when our JMS code uses the Point-To-Point (PTP) Messaging Domain. For the PTP Messaging Domain, there is usually one message producer and one message consumer. The message producer and the message consumer don't need to be running concurrently in order to communicate. The messages placed in the message queue by the message producer will stay in the message queue until the message consumer executes and requests the messages from the queue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending messages to a message queue</h1>
                </header>
            
            <article>
                
<p>The following example illustrates how to add messages to a message queue:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jmsptpproducer; 
 
import java.util.logging.Level; 
import java.util.logging.Logger; 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.jms.ConnectionFactory; 
import javax.jms.JMSContext; 
import javax.jms.JMSProducer; 
import javax.jms.Queue; 
 
@Named 
@RequestScoped 
public class MessageSender { 
 
<strong>    @Resource</strong><strong>    <br/>    private ConnectionFactory connectionFactory;</strong><strong>   <br/>    @Resource(mappedName = "jms/JavaEE8BookQueue")</strong><strong>    <br/>    private Queue queue;</strong> 
 
    private static final Logger LOG = 
        Logger.getLogger(MessageSender.class.getName()); 
 
    public void produceMessages() { 
 
        JMSContext jmsContext = connectionFactory.createContext(); 
        JMSProducer jmsProducer = jmsContext.createProducer(); 
 
        String msg1 = "Testing, 1, 2, 3. Can you hear me?"; 
        String msg2 = "Do you copy?"; 
        String msg3 = "Good bye!"; 
 
        LOG.log(Level.INFO, "Sending the following message: {0}",  <br/>            msg1); 
<strong>        jmsProducer.send(queue, msg1);</strong> 
        LOG.log(Level.INFO, "Sending the following message: {0}",  <br/>            msg2); 
<strong>        jmsProducer.send(queue, msg2);</strong> 
        LOG.log(Level.INFO, "Sending the following message: {0}", <br/>        msg3); 
<strong>        jmsProducer.send(queue, msg3);</strong> 
 
    } 
} </pre>
<p>The <kbd>produceMessages()</kbd> method in the <kbd>MessageSender</kbd> class performs all the necessary steps to send messages to a message queue.</p>
<p>The first thing this method does is create an instance of <kbd>javax.jms.JMSContext</kbd> by invoking the <kbd>createContext()</kbd> method on the injected instance of <kbd>javax.jms.ConnectionFactory</kbd>. Notice that the <kbd>mappedName</kbd> attribute of the <kbd>@Resource</kbd> annotation decorating the connection factory object matches the JNDI name of the connection factory we set up in the GlassFish web console. Behind the scenes, a JNDI lookup is made using this name to obtain the connection factory object.</p>
<p>Next, we create an instance of <kbd>javax.jms.JMSProducer</kbd> by invoking the <kbd>createProducer()</kbd> method on the <kbd>JMSContext</kbd> instance we just created.</p>
<p>After obtaining an instance of <kbd>JMSProducer</kbd>, the code sends a series of text messages by invoking its <kbd>send()</kbd> method. This method takes the message destination as its first parameter, and a <kbd>String</kbd> containing the message text as its second parameter.</p>
<p>There are several overloaded versions of the <kbd>send()</kbd> method in <kbd>JMSProducer</kbd>. The one we used in our example is a convenience method that creates an instance of <kbd>javax.jms.TextMessage</kbd> and sets its text to the <kbd>String</kbd> we provide as the second parameter in the method invocation.</p>
<p>Although the above example sends only text messages to the queue, we are not limited to this type of message. The JMS API provides several types of messages that can be sent and received by JMS applications. All message types are defined as interfaces in the <kbd>javax.jms</kbd> package.</p>
<p>The following table lists all of the available message types:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Message Type</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>BytesMessage</kbd></p>
</td>
<td>
<p>Allows sending an array of bytes as a message. <kbd>JMSProducer</kbd> has a convenience <kbd>send()</kbd> method that takes an array of bytes as one of its parameters. This method creates an instance of <kbd>javax.jms.BytesMessage</kbd> on the fly as the message is being sent.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>MapMessage</kbd></p>
</td>
<td>
<p>Allows sending an implementation of <kbd>java.util.Map</kbd> as a message. <kbd>JMSProducer</kbd> has a convenience <kbd>send()</kbd> method that takes <kbd>Map</kbd> as one of its parameters. This method creates an instance of <kbd>javax.jms.MapMessage</kbd> on the fly as the message is being sent.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ObjectMessage</kbd></p>
</td>
<td>
<p>Allows sending any Java object implementing <kbd>java.io.Serializable</kbd> as a message. <kbd>JMSProducer</kbd> <span class="NormalPACKTChar">has a convenience</span> <kbd>send()</kbd> <span class="NormalPACKTChar">method that takes an instance of a class implementing</span> <kbd>java.io.Serializable</kbd> <span class="NormalPACKTChar">as its second parameter. This method creates an instance of</span> <kbd>javax.jms.ObjectMessage</kbd> <span class="NormalPACKTChar">on the fly as the message is being sent.</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd>StreamMessage</kbd></p>
</td>
<td>
<p>Allows sending an array of bytes as a message. Differs from <kbd>BytesMessage</kbd> in that it stores the type of each primitive type added to the stream.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TextMessage</kbd></p>
</td>
<td>
<p>Allows sending a <kbd>java.lang.String</kbd> as a message. As seen in their above example, <kbd>JMSProducer</kbd> <span class="NormalPACKTChar">has a convenience</span> <kbd>send()</kbd> <span class="NormalPACKTChar">method that takes a</span> <kbd>String</kbd> <span class="NormalPACKTChar">as its second parameter, this method creates an instance of</span> <kbd>javax.jms.TextMessage</kbd> <span class="NormalPACKTChar">on the fly as the message is being sent.</span></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox">For more information on all of the above message types, consult the JavaDoc documentation at <a href="https://javaee.github.io/javaee-spec/javadocs/"><span class="InternetLink">https://javaee.github.io/javaee-spec/javadocs/</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving messages from a message queue</h1>
                </header>
            
            <article>
                
<p>Of course, there is no point in sending messages from a queue if nothing is going to receive them. The following example illustrates how to retrieve messages from a JMS message queue:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jmsptpconsumer; 
 
import java.io.Serializable; 
import java.util.logging.Level; 
import java.util.logging.Logger; 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.jms.ConnectionFactory; 
import javax.jms.JMSConsumer; 
import javax.jms.JMSContext; 
import javax.jms.Queue; 
 
@Named 
@RequestScoped 
public class MessageReceiver implements Serializable{ 
 
<strong>    @Resource</strong><strong>   <br/>    private ConnectionFactory connectionFactory;</strong><strong>     <br/>    @Resource(mappedName = "jms/JavaEE8BookQueue")</strong><strong> <br/>    private Queue queue;</strong> 
    private static final Logger LOG =   <br/>     Logger.getLogger(MessageReceiver.class.getName()); 
     
 
    public void receiveMessages() { 
        String message; 
        boolean goodByeReceived = false; 
 
<strong>        JMSContext jmsContext = connectionFactory.createContext();</strong><strong>         <br/>        JMSConsumer jMSConsumer = jmsContext.createConsumer(queue);</strong> 
 
        LOG.log(Level.INFO, "Waiting for messages..."); 
        while (!goodByeReceived) { 
<strong>            message = jMSConsumer.receiveBody(String.class);</strong> 
 
            if (message != null) { 
                LOG.log(Level.INFO,<br/>                 "Received the following message: {0}", message); 
                if (message.equals("Good bye!")) { 
                    goodByeReceived = true; 
                } 
            } 
        } 
    } 
} </pre>
<p>Just as in the previous example, an instance of <kbd>javax.jms.ConnectionFactory</kbd> and an instance of <kbd>javax.jms.Queue</kbd> are injected by using the <kbd>@Resource</kbd> annotation.</p>
<p>In our code, we get an instance of <kbd>javax.jms.JMSContext</kbd> by invoking the <kbd>createContext()</kbd> method of <kbd>ConnectionFactory</kbd>, just as in the previous example.</p>
<p>In this example, we obtain an instance of <kbd>javax.jms.JMSConsumer</kbd> by calling the <kbd>createConsumer()</kbd> method on our <kbd>JMSContext</kbd> instance.</p>
<p>Messages are received by invoking the <kbd>receiveBody()</kbd> method on our instance of <kbd>JMSConsumer</kbd>. This method takes the type of the message we are expecting as its sole parameter (<kbd>String.class</kbd> in our example) and returns an object of the type specified in its parameter (an instance of <kbd>java.lang.String</kbd> in our example).</p>
<p>In this particular example, we placed this method call in a <kbd>while</kbd> loop, since we are expecting a message that will let us know that no more messages are coming. Specifically, we are looking for a message containing the text <kbd>Good bye !</kbd> Once we receive said message, we break out of the loop and continue processing. In this particular case, there is no more processing to do, therefore, execution ends after we break out of the loop.</p>
<p>After executing the code, we should see the following output in the server log:</p>
<pre><strong>Waiting for messages...</strong>
<strong>Received the following message: Testing, 1, 2, 3. Can you hear me?</strong>
    
<strong>Received the following message: Do you copy?</strong>
    
<strong>Received the following message: Good bye!</strong></pre>
<p>This, of course, assumes that the previous example was already executed and placed messages in the message queue.</p>
<div class="packt_infobox">A disadvantage of processing JMS messages as discussed in this section is that message processing is synchronous. In a Java EE environment, we can process JMS messages asynchronously by employing message-driven beans, as discussed in <a href="ec90b829-514a-4375-8ab7-dcd6a9aa9866.xhtml">Chapter 4</a>, <em>Enterprise JavaBeans</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Browsing message queues</h1>
                </header>
            
            <article>
                
<p>JMS provides a way to browse message queues without actually removing messages from those queues. The following example illustrates how to do this:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jmsqueuebrowser; 
 
import java.util.Enumeration; 
import java.util.logging.Level; 
import java.util.logging.Logger; 
 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.jms.ConnectionFactory; 
import javax.jms.JMSContext; 
import javax.jms.JMSException; 
import javax.jms.Queue; 
import javax.jms.QueueBrowser; 
import javax.jms.TextMessage; 
 
@Named 
@RequestScoped 
public class MessageQueueBrowser { 
 
<strong>    @Resource</strong><strong>   <br/>    private ConnectionFactory connectionFactory;</strong><strong>     <br/>    @Resource(mappedName = "jms/JavaEE8BookQueue")<br/></strong><strong>    private Queue queue;</strong> 
    private static final Logger LOG =  <br/>    Logger.getLogger(MessageQueueBrowser.class.getName()); 
 
    public void browseMessages() { 
        try { 
            Enumeration messageEnumeration; 
            TextMessage textMessage; 
            JMSContext jmsContext =   <br/>        connectionFactory.createContext(); 
<strong>            QueueBrowser browser = jmsContext.createBrowser(queue);</strong><strong>             <br/>            messageEnumeration = browser.getEnumeration();</strong> 
 
            if (messageEnumeration != null) { 
                if (!messageEnumeration.hasMoreElements()) { 
                    LOG.log(Level.INFO, "There are no messages " 
                            + "in the queue."); 
                } else { 
                    LOG.log(Level.INFO, 
                            "The following messages are in the    <br/>                             queue:"); 
<strong>                    while (messageEnumeration.hasMoreElements()) {</strong><strong>                            <br/>                        textMessage = (TextMessage)  <br/>                         messageEnumeration.</strong><strong>nextElement();</strong><strong>                       <br/>                        LOG.log(Level.INFO, textMessage.getText());</strong><strong>              <br/>                    }</strong> 
                } 
            } 
        } catch (JMSException e) { 
            LOG.log(Level.SEVERE, "JMS Exception caught", e); 
        } 
    } 
 
    public static void main(String[] args) { 
        new MessageQueueBrowser().browseMessages(); 
    } 
} </pre>
<p>As we can see, the procedure to browse messages in a message queue is straightforward. We obtain a JMS connection factory, a JMS queue, and a JMS context in the usual way, then invoke the <kbd>createBrowser()</kbd> method on the JMS context object. This method returns an implementation of the <kbd>javax.jms.QueueBrowser</kbd> interface. This interface contains a <kbd>getEnumeration()</kbd> method that we can invoke to obtain an <kbd>Enumeration</kbd> containing all of the messages in the queue. To examine the messages in the queue, we simply traverse this enumeration and obtain the messages one by one. In the above example, we simply invoke the <kbd>getText()</kbd> method of each message in the queue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message topics</h1>
                </header>
            
            <article>
                
<p>Message topics are used when our JMS code uses the Publish/Subscribe (pub/sub) messaging domain. When using this messaging domain, the same message can be sent to all subscribers to the topic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending messages to a message topic</h1>
                </header>
            
            <article>
                
<p>The following example illustrates how to send messages to a message topic:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jmspubsubproducer; 
 
import java.util.logging.Level; 
import java.util.logging.Logger; 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.jms.ConnectionFactory; 
import javax.jms.JMSContext; 
import javax.jms.JMSProducer; 
import javax.jms.Topic; 
 
@Named 
@RequestScoped 
public class MessageSender { 
 
    @Resource 
    private ConnectionFactory connectionFactory; 
<strong>    @Resource(mappedName = "jms/JavaEE8BookTopic")</strong> 
    private Topic topic; 
    private static final Logger LOG = 
        Logger.getLogger(MessageSender.class.getName()); 
 
    public void produceMessages() { 
        JMSContext jmsContext = connectionFactory.createContext(); 
        JMSProducer jmsProducer = jmsContext.createProducer(); 
 
        String msg1 = "Testing, 1, 2, 3. Can you hear me?"; 
        String msg2 = "Do you copy?"; 
        String msg3 = "Good bye!"; 
 
        LOG.log(Level.INFO, "Sending the following message: {0}", <br/>            msg1); 
<strong>        jmsProducer.send(topic, msg1);</strong> 
        LOG.log(Level.INFO, "Sending the following message: {0}",  <br/>            msg2); 
<strong>        jmsProducer.send(topic, msg2);</strong> 
        LOG.log(Level.INFO, "Sending the following message: {0}", <br/>            msg3); 
<strong>        jmsProducer.send(topic, msg3);</strong> 
 
    } 
} </pre>
<p>As we can see, the preceding code is nearly identical to the <kbd>MessageSender</kbd> class we saw when we discussed Point-To-Point messaging. As a matter of fact, the only lines of code that are different are the ones that are highlighted. The JMS API was designed this way so that application developers do not have to learn two different APIs for the PTP and pub/sub domains.</p>
<p>Since the code is nearly identical to the corresponding example in the <em>Message queues</em> section, we will only explain the differences between the two examples. In this example, instead of declaring an instance of a class implementing <kbd>javax.jms.Queue</kbd>, we declare an instance of a class implementing <kbd>javax.jms.Topic</kbd>. We then pass this instance of <kbd>javax.jms.Topic</kbd> as the first method of the <kbd>send()</kbd> method of our <kbd>JMSProducer</kbd> object, along with the message we wish to send.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Receiving messages from a message topic</h1>
                </header>
            
            <article>
                
<p>Just as sending messages to a message topic is almost identical to sending messages to a message queue, receiving messages from a message topic is almost identical to receiving messages from a message queue:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jmspubsubconsumer; 
 
import java.util.logging.Level; 
import java.util.logging.Logger; 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.jms.ConnectionFactory; 
import javax.jms.JMSConsumer; 
import javax.jms.JMSContext; 
import javax.jms.Topic; 
 
@Named 
@RequestScoped 
public class MessageReceiver { 
 
    @Resource 
    private ConnectionFactory connectionFactory; 
<strong>    @Resource(mappedName = "jms/JavaEE8BookTopic")</strong><strong> <br/>   private Topic topic;</strong> 
    private static final Logger LOG = 
      Logger.getLogger(MessageReceiver.class.getName()); 
 
    public void receiveMessages() { 
        String message; 
        boolean goodByeReceived = false; 
 
        JMSContext jmsContext = connectionFactory.createContext(); 
<strong>        JMSConsumer jMSConsumer = jmsContext.createConsumer(topic);</strong> 
 
        LOG.log(Level.INFO, "Waiting for messages..."); 
        while (!goodByeReceived) { 
<strong>            message = jMSConsumer.receiveBody(String.class);</strong> 
 
            if (message != null) {<br/>                System.out.print(<br/>                "Received the following message: ");<br/>                LOG.log(Level.INFO, message);<br/>                if (message.equals("Good bye!")) {<br/>                    goodByeReceived = true;<br/>                }<br/>            }
        } 
    } 
} </pre>
<p>Once again, the differences between this code and the corresponding code for PTP are trivial. Instead of declaring an instance of a class implementing <kbd>javax.jms.Queue</kbd>, we declare a class implementing <kbd>javax.jms.Topic</kbd>, and we use the <kbd>@Resource</kbd> annotation to inject an instance of this class into our code, using the JNDI name we used when configuring our application server. We then obtain an instance of <kbd>JMSContext</kbd> and <kbd>JMSConsumer</kbd>, as before, then receive the messages from the topic by invoking the <kbd>receiveBody()</kbd> method on <kbd>JMSConsumer</kbd>.</p>
<p>Using the pub/sub messaging domain as illustrated in this section has the advantage that messages can be sent to several message consumers. This can be easily tested by concurrently executing two instances of the <kbd>MessageReceiver</kbd> class we developed in this section, then executing the <kbd>MessageSender</kbd> class we developed in the previous section. We should see console output for each instance, indicating that both instances received all messages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating durable subscribers</h1>
                </header>
            
            <article>
                
<p>The disadvantage of using the pub/sub messaging domain is that message consumers must be executing when the messages are sent to the topic. If a message consumer is not executing at the time, it will not receive the messages, whereas, in PTP, messages are kept in the queue until the message consumer executes. Fortunately, the JMS API provides a way to use the pub/sub messaging domain and keep messages in the topic until all subscribed message consumers execute and receive the message. This can be accomplished by creating durable subscribers to a JMS Topic.</p>
<p>In order to be able to service durable subscribers, we need to set the <kbd>ClientId</kbd> property of our JMS connection factory. Each durable subscriber must have a unique client ID, therefore, a unique connection factory must be declared for each potential durable subscriber.</p>
<p>The procedure to set the <kbd>ClientId</kbd> property of a JMS connection factory varies depending on the application server being used. The <a href="e125af24-9bf3-427d-a71c-22461bbf34fc.xhtml">Appendix</a>, <em>Configuring and deploying to GlassFish</em> has instructions on setting this property on GlassFish. Consult your application server documentation for instructions on setting this property when using other Java EE compliant application servers.</p>
<div class="packt_tip"><span><span class="packt_screen">Invalid ClientId Exception?</span></span> Only one JMS client can connect to a topic for a specific client ID. If more than one JMS client attempts to obtain a JMS connection using the same connection factory, a <kbd>JMSException</kbd> stating that the Client ID is already in use will be thrown. The solution is to create a connection factory for each potential client that will be receiving messages from the durable topic.</div>
<p>Once we have set up our application server to be able to provide durable subscriptions, we are ready to write some code to take advantage of them:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jmspubsubdurablesubscriber; 
 
import java.util.logging.Level; 
import java.util.logging.Logger; 
import javax.annotation.Resource; 
import javax.enterprise.context.ApplicationScoped; 
import javax.inject.Named; 
import javax.jms.ConnectionFactory; 
import javax.jms.JMSConsumer; 
import javax.jms.JMSContext; 
import javax.jms.Topic; 
 
@Named 
@ApplicationScoped 
public class MessageReceiver { 
 
<strong>    @Resource(mappedName =</strong><strong>   <br/>     "jms/JavaEE8BookDurableConnectionFactory")</strong><strong>   <br/>    private ConnectionFactory connectionFactory;</strong> 
    @Resource(mappedName = "jms/JavaEE8BookTopic") 
    private Topic topic; 
    private static final Logger LOG = 
      Logger.getLogger(MessageReceiver.class.getName()); 
 
    public void receiveMessages() { 
        String message; 
        boolean goodByeReceived = false; 
 
        JMSContext jmsContext = connectionFactory.createContext(); 
<strong>        JMSConsumer jMSConsumer =</strong><strong>          <br/>        jmsContext.createDurableConsumer(topic, "Subscriber1");</strong> 
 
        LOG.log(Level.INFO, "Waiting for messages..."); 
        while (!goodByeReceived) { 
            message = jMSConsumer.receiveBody(String.class); 
 
              if (message != null) {<br/>                LOG.log(Level.INFO, <br/>                  "Received the following message: {0}", message);<br/>                if (message.equals("Good bye!")) {<br/>                    goodByeReceived = true;<br/>                }<br/>            }
        } 
 
    } 
 
} </pre>
<p>As we can see, the preceding code is not much different from previous examples whose purpose was to retrieve messages. There are only two differences from previous examples: The instance of <kbd>ConnectionFactory</kbd> we are injecting is set up to handle durable subscriptions, and instead of calling the <kbd>createConsumer()</kbd> method on the JMS context object, we are calling <kbd>createDurableConsumer()</kbd>. The <kbd>createDurableConsumer()</kbd> method takes two arguments: a JMS <kbd>Topic</kbd> object to retrieve messages from, and a <kbd>String</kbd> designating a name for this subscription. This second parameter must be unique for all subscribers to the durable topic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered how to set up JMS connection factories, JMS message queues, and JMS message topics in GlassFish, by using the GlassFish web console. We also covered how to send messages to a message queue via the <kbd>javax.jms.JMSProducer</kbd> interface. Additionally, we covered how to receive messages from a message queue via the <kbd>javax.jms.JMSConsumer</kbd> interface. We also covered how to asynchronously receive messages from a message queue by implementing the <kbd>javax.jms.MessageListener</kbd> interface and saw how to use the above interfaces to send and receive messages to and from a JMS message topic. We also looked at how to browse messages in a message queue without removing those messages from the queue via the <kbd>javax.jms.QueueBrowser</kbd> interface. Finally, we saw how to set up and interact with durable subscriptions to JMS topics.</p>


            </article>

            
        </section>
    </body></html>