- en: Libraries for Pure Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数式编程库
- en: In the previous chapter, we discussed the purely functional style with the help
    of essential libraries such as `cats`. This library performs quite well on tasks
    of purely functional programming, but in practice, that is not quite enough for
    comfortable programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们借助`cats`等基本库讨论了纯函数式风格。这个库在纯函数式编程的任务上表现相当出色，但在实践中，这并不足以舒适地进行编程。
- en: If you take a look at conventional imperative languages such as Java, you will
    see that they usually have a lot of libraries and infrastructure for performing
    specific tasks. Moreover, it is also possible to argue that the choice of programming
    language is primarily driven by the infrastructure it provides.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看传统的命令式语言，如Java，你会发现它们通常有很多库和基础设施来执行特定任务。此外，也可以争论说，编程语言的选择主要是受其提供的基础设施驱动的。
- en: This way, for example, Python is a de facto standard for machine learning, because
    it provides an elaborate set of scientific libraries to perform scientific computing,
    and R is a de facto standard for statistical computing. Companies often choose
    Scala because it provides access to Spark and Akka libraries for machine learning
    and distributed computing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，例如，Python 是机器学习的既定标准，因为它提供了一套复杂的科学库来执行科学计算，而R是统计计算的既定标准。公司通常选择Scala，因为它提供了访问Spark和Akka库的途径，这些库用于机器学习和分布式计算。
- en: Hence, when talking about a particular programming style, it is of great importance
    to also mention that it is an infrastructure that is developed around the staff.
    In this chapter, we will cover this infrastructure by looking at a bunch of other
    libraries that exist for purely functional programming in Scala with `cats`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在讨论特定的编程风格时，同时提到它是一个围绕员工开发的基础设施，这一点非常重要。在本章中，我们将通过查看一些Scala中用于纯函数式编程的`cats`库之外的库来介绍这个基础设施。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The Cats effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The Cats effect
- en: Server-side programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端编程
- en: We will start this chapter by looking at the concurrency library for `cats`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，查看`cats`的并发库。
- en: Cats effect
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cats effect
- en: The Cats effect is a library for concurrent programming in `cats`. Its main
    feature is a bunch of type classes, data types, and concurrency primitives to
    describe concurrent programming in Scala with `cats`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Cats effect 是一个用于`cats`库中并发编程的库。其主要特点是提供一系列类型类、数据类型和并发原语，用于描述使用`cats`在Scala中进行并发编程。
- en: 'The concurrency primitives support among other things:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并发原语支持以下内容：
- en: Resource management—think try-with-resources.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理——想想try-with-resources。
- en: Seamless composition of parallel computations.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平行计算的无缝组合。
- en: Communication between parallel computations.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平行计算之间的通信。
- en: We will start discussing the library by looking at its central concurrency primitive, `IO`,
    and some capabilities of Cats that we will need in the process of discussing it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过查看其核心并发原语`IO`以及我们在讨论过程中需要的Cats的一些功能来讨论这个库。
- en: ProductR
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ProductR
- en: Before diving deep into the library and discussing its features, we need to
    mention a particular operator that is frequently used throughout this library.
    We have already discussed the Applicative type class, and that it is useful for
    parallel composition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨库并讨论其功能之前，我们需要提到一个在这个库中经常使用的特定操作符。我们已经讨论了 Applicative 类型类，并且它对并行组合很有用。
- en: An operator from this type class that is frequently used in `cats` is a so-called
    right product operator.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cats`中经常使用的这个类型类的一个操作符是所谓的右乘操作符。
- en: The operator in question takes two computations, performs a product between
    them, and takes only the right-hand result. Particularly in the Cats effect, the
    operator is frequently used to specify that one event should happen after another.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符接受两个计算，在它们之间执行乘法，并只取右手边的结果。特别是在 Cats effect 中，这个操作符经常用来指定一个事件应该在另一个事件之后发生。
- en: It also has a symbolic form, which looks like this: `*>`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个符号形式，看起来像这样：`*>`。
- en: IO – the concurrence data type
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IO – 并发数据类型
- en: 'The primary data type that the Cats effect offers is IO. This is a data type
    that defines a computation that is to be performed at some point in the future.
    For example, you can have the following expression:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Cats effect 提供的主要数据类型是 IO。这是一个在未来的某个时刻要执行的计算的数据类型。例如，你可以有以下表达式：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Crucial detail to notice about IO is that it is precisely a description of the
    computation. Here, `cats` supports a so-called computation as a value paradigm.
    Computation as a value dictates that you should not evaluate your competition
    straight away, but you should store the descriptions of these computations. This
    way, you will be able to evaluate them at any point in the future.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于IO的一个关键细节是，它恰好是对计算的描述。在这里，`cats`支持所谓的计算作为值范式。计算作为值规定你不应该立即评估你的竞争，而应该存储这些计算的描述。这样，你将能够在未来的任何时刻评估它们。
- en: This approach has a number of benefits, and this is what we are going to discuss
    next.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有许多优点，这就是我们接下来要讨论的。
- en: Referential transparency
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明性
- en: 'The first benefit Cats has is referential transparency. In the preceding example,
    the computation to print hello world to the command line will not be evaluated
    right away. It is side effecting, and the fact that we do not evaluate it right
    away means it is referentially transparent. You can evaluate the computation as
    follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Cats 的第一个优点是引用透明性。在先前的例子中，将“hello world”打印到命令行的计算不会立即执行。它是副作用，而我们没有立即执行它的事实意味着它是引用透明的。你可以如下评估这个计算：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: IO has a bunch of methods, the names of which are prepended with the `unsafe`
    word.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: IO有一系列方法，这些方法的名称前面都带有`unsafe`这个词。
- en: Unsafe methods are generally what their prefix says, `unsafe`. This means that
    they may block, produce side effects, throw exceptions, and do other things that
    may cause you a headache. Following the description of the IO type in the documentation
    itself, you should only call such a method once, ideally at the end of your program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全的方法通常如它们的名称所示，是“不安全的”。这意味着它们可能会阻塞，产生副作用，抛出异常，并做其他可能让你头疼的事情。根据文档中对IO类型的描述，你应该只调用这样的方法一次，理想情况下是在程序末尾。
- en: So, basically, the main idea is that you describe your entire program in terms
    of the IO primitive, using the conveniences provided by this primitive by the
    Cats effect library. Once your entire application is described, you can run the
    application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，主要思想是使用Cats效果库提供的便利，用IO原语来描述你的整个程序。一旦你的整个应用程序被描述，你就可以运行应用程序。
- en: Inversion of control
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制反转
- en: Since a computation expressed in terms of IO is not executed immediately but
    is merely stored as a description of a computation, it is possible to execute
    the computation against different execution strategies. For example, you may want
    to run the computation against various concurrent backends, each with its own
    concurrency strategies. You may want to run a competition synchronously or asynchronously.
    Later in this chapter, we will see how exactly this is done.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用IO术语表达的计算不是立即执行，而仅仅是作为计算描述的存储，因此可以针对不同的执行策略执行计算。例如，你可能希望在不同的并发后端上运行计算，每个后端都有自己的并发策略。你可能希望同步或异步地运行一个竞争。在本章的后面部分，我们将看到这是如何做到的。
- en: Asynchrony with IO
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步与IO
- en: The central domain of the application of the Cats effect is asynchronous programming.
    Asynchronous programming is an event-driven style of programming, where you do
    not waste threads and other resources on blocking, waiting for some event to happen.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Cats效果的应用中心领域是异步编程。异步编程是一种事件驱动风格的编程，在这种编程中，你不会浪费线程和其他资源在阻塞，等待某个事件发生。
- en: Consider, for example, that you have a web server that handles incoming HTTP
    requests. It has a pool of threads that are used by the server to handle each
    request. Now, the handlers themselves may require some blocking operations. For
    example, contacting a database for contacting an external HTTP API can be a potentially
    blocking operation. This is because the database or an HTTP API does not respond
    immediately as a rule. This means that if a request handler needs to contact such
    a resource, it will need to wait for the service to reply.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个处理传入HTTP请求的Web服务器。服务器有一组线程，用于处理每个请求。现在，处理器本身可能需要进行一些阻塞操作。例如，联系数据库或外部HTTP
    API可能是一个潜在的阻塞操作。这是因为数据库或HTTP API通常不会立即响应。这意味着如果请求处理器需要联系这样的资源，它将需要等待服务回复。
- en: If such waiting is done naively, by blocking an entire thread and reviving it
    once the request is available, we have a situation where we waste threads. If
    such a server comes under a high load, there is a danger that all of the threads
    will be blocked for the majority of the time. Blocking means that they do not
    do anything and are just waiting for a response from a resource. Since they are
    not doing anything, these threads could have well been used to handle other requests
    that possibly do not require such kinds of blocking.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种等待是天真地通过阻塞整个线程，一旦请求可用就恢复它，那么我们就会有一个浪费线程的情况。如果这样的服务器在高负载下运行，有危险的是，所有线程的大部分时间都将被阻塞。阻塞意味着它们什么也不做，只是等待资源的响应。由于它们什么也不做，这些线程本可以用来处理其他可能不需要这种阻塞类型的请求。
- en: Precisely for this reason, current server-side programming is aimed toward asynchronous
    processing, which means that if a handler needs to contact some potentially blocking
    resource, it contacts it. However, once it has nothing else to do, it is supposed
    to release its thread. It will continue the computation once the response it is
    waiting for is available.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，当前的服务器端编程旨在实现异步处理，这意味着如果处理程序需要联系某些可能阻塞的资源，它会联系它。然而，一旦它没有其他事情可做，它应该释放其线程。一旦它等待的响应可用，它将继续计算。
- en: This kind of strategy allows for very lightweight concurrent modules that do
    not waste threads. This also ensures that the threads are busy with useful work
    most of the time, and not with blocking.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略允许创建非常轻量级的并发模块，不会浪费线程。这也确保了线程大部分时间都在忙于有用的工作，而不是阻塞。
- en: However, this model requires dedicated libraries and server-side technologies
    that are specifically built with asynchrony in mind. The Cats effect precisely
    aims to meet such asynchronous requirements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模型需要专门的库和服务器端技术，这些技术是专门为异步设计的。Cats效果正是为了满足这种异步需求而精确设计的。
- en: Now, let's take a look at some examples which demonstrate in practice how blocking
    differs from asynchrony and how Cats facilitates asynchrony. You will also learn
    a bunch of Cats effect APIs in the process of looking at these examples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些示例，这些示例在实践中展示了阻塞与异步的不同之处，以及Cats如何促进异步操作。在这个过程中，你还将学习到许多Cats效果API。
- en: Blocking example
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞示例
- en: 'First, let''s take a look at the API behind creating an asynchronous IO action:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看创建异步IO操作的API背后的内容：
- en: '![](img/265727b1-1148-4184-84d6-4729f59758c3.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/265727b1-1148-4184-84d6-4729f59758c3.png)'
- en: So, you can supply an arbitrary task into an `apply` method of IO, and this
    will construct the description of this task.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将一个任意任务提供给IO的`apply`方法，这将构建这个任务的描述。
- en: 'We can model blocking of a computation by using the `Thread.sleep` Java API
    under the IO apply method as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在IO的`apply`方法下使用`Thread.sleep` Java API来模拟计算的阻塞，如下所示：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the preceding example will block its thread. IO may be just a description
    of a computation. However, the computations are supposed to get executed at some
    point. In the JVM world, any computation runs on a thread. In the preceding example,
    we are using the Java `Thread.sleep` API to explicitly say that we need to block
    a thread the computation is running on for one second, or 1,000 milliseconds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的示例将阻塞其线程。IO可能只是对计算的描述。然而，计算应该在某个时刻执行。在JVM世界中，任何计算都是在线程上运行的。在前面示例中，我们使用Java
    `Thread.sleep` API来明确表示我们需要阻塞正在运行的线程一秒钟，即1,000毫秒。
- en: 'With the help of the preceding primitive, let''s compose an infinite computation
    that will be easy for us to trace and study. If we have a long-running computation
    that outputs something to the command line in equal periods of time, we can easily
    see whether and how the computation is progressing. Typically, such an infinite
    computation would be possible in terms of a loop. In functional programming, a
    loop can be created in terms of Monad''s `tailRecM`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 借助于前面的原始方法，让我们构建一个无限计算，这将使我们容易追踪和研究。如果我们有一个长时间运行的计算，它以相等的时间间隔向命令行输出某些内容，我们就可以很容易地看到计算是否以及如何进行。通常，这种无限计算可以通过循环来实现。在函数式编程中，循环可以通过Monad的`tailRecM`来创建：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, you can see a Monadic infinite loop that utilizes IO
    to describe an infinite computation. First of all, the computation will output
    the name of the current thread, the name of the current task, and the number that
    will be incremented from iteration to iteration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到一个使用IO描述无限计算的Monadic无限循环。首先，计算将输出当前线程的名称、当前任务的名称以及从迭代到迭代将递增的数字。
- en: The thread output can be useful to trace which thread the computation is running
    on. This information can be used to see how threads in a given thread pool are
    allocated. The prefix is necessary to distinguish one task from another in case
    we want to run several such computations at once. We will do this in order to
    see how such a task performs in a concurrency setting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 线程输出可以用来跟踪计算正在哪个线程上运行。这些信息可以用来查看给定线程池中的线程是如何分配的。前缀是必要的，以便在我们要同时运行多个此类计算时区分一个任务与另一个任务。我们将这样做，以便看到此类任务在并发环境下的表现。
- en: Testing out such a blocking task in concurrent environment models requires an
    HTTP server under a high load. There, you also have a multitude of tasks of the
    same nature running concurrently. The preceding example models a situation where
    a handler task blocks the underlying thread.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发环境模型中测试这样的阻塞任务需要在一个高负载的HTTP服务器下进行。在那里，你也有许多性质相同的任务正在并发运行。前面的例子模拟了一个处理任务阻塞底层线程的情况。
- en: Finally, the identifier number is used to identify the progress of a given task
    so that we can see how evenly the tasks progress and whether any task is getting
    choked.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，标识号用于识别给定任务的进度，这样我们就可以看到任务进度是否均匀，以及是否有任何任务被阻塞。
- en: Since, in the preceding example, we were motivated by the ability to test tasks
    in the concurrency settings, next, we will talk briefly about the concurrency
    environment we are going to run the tasks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在前面的例子中，我们受到在并发设置中测试任务的能力的激励，接下来，我们将简要介绍我们将运行任务的并发环境。
- en: Concurrency infrastructure
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发基础设施
- en: 'The concurrency environment is represented by an execution context, which is
    a Scala class. The official documentation defines it as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并发环境由一个执行上下文表示，这是一个Scala类。官方文档将其定义为如下：
- en: '![](img/fe9abd00-668c-4d79-b98a-3d458518d117.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe9abd00-668c-4d79-b98a-3d458518d117.png)'
- en: 'It is a standard Scala class with a single method to run a Java `Runnable`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的Scala类，它有一个方法来运行Java `Runnable`：
- en: '![](img/420e034c-d13b-48e7-99fa-839c77d0e4d1.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/420e034c-d13b-48e7-99fa-839c77d0e4d1.png)'
- en: 'An execution context is necessary whenever we are dealing with concurrency
    primitives in Scala, such as Future. The Cats effect also relies on this type
    to describe its own execution environment. We can construct an execution context
    and specify the number of threads available in its thread pool as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中处理并发原语，如Future时，需要一个执行上下文。Cats effect也依赖于这种类型来描述其自己的执行环境。我们可以构建一个执行上下文，并指定其线程池中可用的线程数，如下所示：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we are using the `fromExecutor` method of the `ExecutionContext` class,
    which is defined as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在使用`fromExecutor`方法，这是`ExecutionContext`类定义的如下：
- en: '![](img/9b80d494-eb16-4fa8-8471-db9199cbe54a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b80d494-eb16-4fa8-8471-db9199cbe54a.png)'
- en: This method uses the Java API to construct the execution context. In our concrete
    preceding example, we are constructing an execution contact that possesses a fixed
    thread pool that has two threads.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用Java API构建执行上下文。在我们具体的上一个例子中，我们正在构建一个具有固定线程池的执行联系，该线程池有两个线程。
- en: Another motivating factor for our example was running multiple instances of
    the same concurrently. Next, we will be looking at the API to provide this functionality.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子另一个激励因素是运行多个相同并发实例。接下来，我们将查看API以提供此功能。
- en: Running tasks in bunches
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量运行任务
- en: 'We can define a function to run an arbitrary IO task on a given execution context
    in multiple instances, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个函数，在给定的执行上下文中以多个实例运行任意IO任务，如下所示：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `bunch` function takes the number of tasks we need to launch concurrently
    as the first argument. As a second argument, it takes a function `gen` to construct
    tasks. The function takes a string as its first argument, which is the name of
    the task. In the conditions where we have the same task to run in multiple instances,
    it is crucial to distinguish them somehow. Therefore, we need to provide the name
    to the generator function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`bunch`函数将需要并发启动的任务数量作为第一个参数。作为第二个参数，它接受一个函数`gen`来构建任务。该函数以字符串作为其第一个参数，即任务的名称。在我们需要运行相同任务的多实例的情况下，区分它们是至关重要的。因此，我们需要将名称提供给生成函数。'
- en: To understand the output type of the function, let's take a look at the body
    of the function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解函数的输出类型，让我们看看函数的主体。
- en: 'First of all, the body constructs a list of `n` elements. The intention is
    to use the list to specify the loop to create the tasks. We then create the required
    number of tasks by using the `map` function on the list we have created:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，主体构建了一个包含`n`个元素的列表。意图是使用这个列表来指定创建任务的循环。然后，我们使用我们创建的列表上的`map`函数来创建所需数量的任务：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we are using the traverse function, which does something to each task
    we have just created. Let''s take a look at what happens inside the traverse function
    to see how parallelism is achieved in the Cats effect:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`traverse`函数，它会对我们刚刚创建的每个任务执行一些操作。让我们看看`traverse`函数内部发生了什么，以了解Cats effect中如何实现并行性：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The main point of interest is the `start` function. Let''s take a look at how
    it is defined:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的焦点是`start`函数。让我们看看它是如何定义的：
- en: '![](img/549d348a-3e20-48a5-a6a9-a12295d0cd1e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/549d348a-3e20-48a5-a6a9-a12295d0cd1e.png)'
- en: 'The function in question produces a so-called `Fiber` under the IO primitive.
    Let''s take a look at how `Fiber` is defined and what it is all about:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关的问题函数在IO原语下产生所谓的`Fiber`。让我们看看`Fiber`是如何定义的以及它是什么：
- en: '![](img/64e6ee05-fe69-4637-b758-18ff6a2f310d.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64e6ee05-fe69-4637-b758-18ff6a2f310d.png)'
- en: 'It defines the following API:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了以下API：
- en: '![](img/f0a504b4-e6f5-4b0f-b3d9-cf7761afa4c7.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0a504b4-e6f5-4b0f-b3d9-cf7761afa4c7.png)'
- en: Usually, waiting in an IO-based Monadic flow blocks execution. Of course, that
    blocking is done asynchronously. However, if you're calling the `start` method
    on an IO, it will not block the Monadic flow. Instead, it will return immediately
    with a `Fiber` object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在基于IO的Monadic流程中等待会阻塞执行。当然，这种阻塞是异步进行的。然而，如果你在IO上调用`start`方法，它不会阻塞Monadic流程。相反，它会立即返回一个`Fiber`对象。
- en: Think of a `Fiber` object as a remote control unit for the underlying alpha
    complication. It defines two methods, `cancel` and `join`. These two methods can
    be used to communicate with the underlying computation. The `cancel` method cancels
    the competition, and the `join` method blocks the current Monadic flow until an
    underlying IO computation finishes. `join` returns the value of this computation
    in the Monadic floor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个`Fiber`对象视为底层alpha复杂度的遥控单元。它定义了两个方法，`cancel`和`join`。这两个方法可以用来与底层计算进行通信。`cancel`方法取消竞争，而`join`方法会阻塞当前的Monadic流程，直到底层IO计算完成。`join`方法返回这个计算在Monadic层中的值。
- en: Also, notice that these `cancel` and `join` methods are all returning an IO
    primitive. This means that you can use this method from a Monadic flow.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些`cancel`和`join`方法都是返回一个IO原语。这意味着你可以从Monadic流程中使用这个方法。
- en: So, why are we using the `start` method from our bunch example?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们在bunch示例中使用`start`方法呢？
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember, our tasks are infinite. We have defined them has an infinite loop
    that blocks every second. The job of traverse is to evaluate all of the tasks
    supplied to it and return a combined task under a single effect type, in this
    case, IO. However, our tasks cannot be evaluated to some concrete result since
    they are infinite. Hence, we will perform the start call on every task in order
    to specify that we do not need the task's result itself; we can only be satisfied
    with the remote control unit for this task. This way, the traverse method will
    not wait for any single task to finish, but will start all of them asynchronously
    on the execution context we discussed previously.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的任务是无限的。我们定义了它们为一个每秒阻塞一次的无穷循环。`traverse`的任务是评估它所提供的所有任务，并返回一个在单一效果类型下的组合任务，在这种情况下是IO。然而，由于我们的任务是无限的，它们不能被评估为某个具体的结果。因此，我们将对每个任务执行`start`调用，以指定我们不需要任务本身的结果；我们只能对这个任务的遥控单元感到满意。这样，`traverse`方法将不会等待任何单个任务完成，而是在我们之前讨论的执行上下文中异步启动所有任务。
- en: Heavy load with blocking
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带阻塞的重负载
- en: 'Now, imagine that our `taskHeavy` is a handler for an HTTP server. The server
    is undergoing a heavy load and has `1000` ongoing requests. This means that we
    need to create `1000` tasks to handle them. With the `bunch` method, we can define
    such handling as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的 `taskHeavy` 是一个 HTTP 服务器的处理器。服务器正在经历重负载，有 `1000` 个正在进行的请求。这意味着我们需要创建
    `1000` 个任务来处理它们。使用 `bunch` 方法，我们可以定义如下处理方式：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that we have encountered another new primitive in this example. It is
    a `shift` method that''s defined on the IO data type. It is defined as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，我们又遇到了另一个新的原语。它是在 IO 数据类型上定义的 `shift` 方法。它定义如下：
- en: '![](img/03d84edb-7e47-49b6-b2c3-54e99d37edd0.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03d84edb-7e47-49b6-b2c3-54e99d37edd0.png)'
- en: 'The `shift` method is an instruction for the execution to get shifted to an `ExecutionContext`,
    which is present as an implicit dependency in scope. Here, we implicitly depend
    on a `Timer` object and not an `ExecutionContext`. The `ExecutionContext` can
    be used to derive a `Timer` object using an implicit method that is a part of
    the IO API:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`shift` 方法是执行转移到 `ExecutionContext` 的指令，它作为作用域中的隐式依赖项存在。在这里，我们隐式依赖于一个 `Timer`
    对象，而不是 `ExecutionContext`。可以使用 IO API 的一部分隐式方法从 `ExecutionContext` 获取 `Timer`
    对象：'
- en: '![](img/95318aa0-2298-4dab-83bd-5d9e062f295a.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95318aa0-2298-4dab-83bd-5d9e062f295a.png)'
- en: 'Since we have an `ExecutionContext` in the implicit scope, we can call the
    `shift` method to shift the execution of the current IO computation to the thread
    pool with have defined. Also notice the `*>` operator here, which we discussed
    previously in this chapter. It says that the second competition should be executed
    after the first one, which is the shift to a concurrent context. We also ran the
    example in place to see how it goes with the help of `unsafeRunSync`. The output
    of the program is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在隐式作用域中有一个 `ExecutionContext`，我们可以调用 `shift` 方法将当前 IO 计算的执行转移到我们已定义的线程池中。注意这里的
    `*>` 操作符，我们之前在本章中讨论过。它表示第二个竞争应该在第一个之后执行，即转移到并发上下文中。我们还通过 `unsafeRunSync` 的帮助在现场运行了示例，以查看其执行情况。程序的输出如下：
- en: '![](img/1af49cec-3c98-4209-80b5-1541648c31b3.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1af49cec-3c98-4209-80b5-1541648c31b3.png)'
- en: The first thing to notice here is that both of the threads we have in our `ExecutionContext`
    are used to process the tasks. You can see that by looking at the name of the
    threads output by the task. It changes from task to task. However, also take note
    that it is only the first two tasks that get the chance to be executed. This is
    because we are using a blocking call to `Thread.sleep` to specify and delay our
    execution. So, in the setting of the infinite handling tasks, such a server, it
    would only be able to handle two requests at a time. In a setting where you need
    to handle `1000` requests, this is inadequate.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先要注意的是，我们 `ExecutionContext` 中的两个线程都用于处理任务。你可以通过查看任务输出的线程名称来看到这一点。它会随着任务的变化而变化。然而，也要注意，只有前两个任务有机会被执行。这是因为我们使用
    `Thread.sleep` 的阻塞调用来指定和延迟我们的执行。所以，在无限处理任务的设置中，这样的服务器一次只能处理两个请求。在一个需要处理 `1000`
    个请求的设置中，这是不够的。
- en: Now, let's see how we can benefit from asynchrony to specify lightweight concurrency
    primitives to handle that volume of requests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何利用异步性来指定轻量级并发原语来处理那么多的请求。
- en: Synchronous tasks
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步任务
- en: 'You can asynchronously define the preceding computation as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以异步地定义前面的计算如下：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that this method is defined similarly to the previous task. However,
    we no longer block the thread. Instead, we are using a built-in IO primitive called `sleep`.
    `sleep` is a non-blocking primitive, meaning that it does not block the underlying
    thread. That is, it is a description of the `sleep` operation. Remember, all of
    the computations happening defined in terms of IO are descriptions of computations
    and not computations themselves. So, you can define a `sleep` operation as you
    please. Hence, it is reasonable to define this operation in an unblocking manner
    so that the underlying thread gets released when this `sleep` operation is encountered,
    and the computation is resumed when the execution environment receives a signal
    stating that the `sleep` operation was terminated successfully. A similar principle
    is used in all asynchronous computations. We can run this task as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种方法与之前的任务定义方式相似。然而，我们不再阻塞线程。相反，我们正在使用一个内置的IO原语称为`sleep`。`sleep`是一个非阻塞原语，这意味着它不会阻塞底层线程。也就是说，这是对`sleep`操作的描述。记住，所有用IO术语定义的计算都是计算的描述，而不是计算本身。因此，你可以按需定义`sleep`操作。因此，以非阻塞方式定义此操作是合理的，这样当遇到`sleep`操作时，底层线程就会释放，当执行环境收到表示`sleep`操作成功终止的信号时，计算就会继续。所有异步计算都使用类似的原则。我们可以如下运行此任务：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the program is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/8e1949a9-6ba6-46fb-b263-03a0460e5133.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e1949a9-6ba6-46fb-b263-03a0460e5133.png)'
- en: Notice how all of the `1000` tasks get enough resources to get executed. This
    is because each of these tasks releases the underlying thread once they do not
    need it anymore. Hence, even with two threads, we are able to handle 1,000 tasks
    at once successfully. So, computations described asynchronously are quite lightweight
    and can be used in systems that are designed for high loads. Next, let's take
    a look at how you can create an asynchronous IO primitive yourself.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有的`1000`个任务都得到了足够的资源来执行。这是因为一旦这些任务不再需要它们，它们就会释放底层线程。因此，即使只有两个线程，我们也能成功一次性处理1,000个任务。所以，异步描述的计算相当轻量级，可以用于设计用于高负载的系统。接下来，让我们看看如何自己创建异步IO原语。
- en: Constructing asynchronous tasks
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建异步任务
- en: IO provides an API that allows you to transform an existing computation based
    on callbacks into an asynchronous IO. This can be used to port existing computation
    to IO in an asynchronous manner.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: IO提供了一个API，允许你将基于回调的现有计算转换为异步IO。这可以用来以异步方式将现有计算迁移到IO。
- en: 'Suppose you have the following computation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个以下计算：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Like we saw previously, it is blocking a thread as it uses `Thread.sleep` to
    block the computation. The entire point of the computation is that it does not
    return immediately.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，它通过使用`Thread.sleep`来阻塞计算而阻塞了一个线程。整个计算的目的就是它不会立即返回。
- en: 'Now, let''s take a look at how you can asynchronously run the computation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何异步运行计算：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we are using an already familiar way to lift a synchronous computation
    into an IO data type. We have already seen the consequences of doing so in our
    previous example. This time, since our computation is not infinite, let''s take
    a look at the time difference of handling this computation versus an asynchronous
    competition we are about to construct from it. To do so, we will need a benchmarking
    capability:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一种已经熟悉的方法将同步计算提升到IO数据类型。我们在之前的例子中已经看到了这样做的影响。这次，由于我们的计算不是无限的，让我们来看看处理这种计算与我们将要从中构建的异步竞争处理的时间差异。为此，我们需要一个基准测试能力：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we are constructing a benchmarking capability that will
    run IO and will report on how long it took to run the computation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在构建一个基准测试能力，它将运行IO并报告计算运行所需的时间。
- en: The first thing to notice here is how computation as a value strategy that IO
    implies can be beneficial to augment computations. Here, the benchmark method
    accepts an IO that is not yet evaluated. It is just a description of a computation.
    Next, it wraps this computation in a capability to measure time, and, finally,
    it returns the result of the computation, together with the benchmark.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先要注意的，是IO作为值策略如何有益于增强计算。在这里，基准方法接受一个尚未评估的IO。它只是一个计算的描述。接下来，它将这个计算包装在一个可以测量时间的功能中，最后，它返回计算的最终结果，以及基准。
- en: 'Also, notice how we are using the `Timer` data type here. We have already briefly
    touched on the `Timer` class in the context of the execution context of the IO
    primitive. The `Timer` class happens to be an execution context that IO uses to
    manage its threading:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意我们在这里是如何使用 `Timer` 数据类型的。我们已经在 IO 原语的执行上下文背景下简要提到了 `Timer` 类。`Timer` 类恰好是
    IO 用于管理其线程的执行上下文：
- en: '![](img/8bbf3032-f573-4fe7-a84c-5655149ca804.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bbf3032-f573-4fe7-a84c-5655149ca804.png)'
- en: '`Timer` defines the following abstract methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer` 定义了以下抽象方法：'
- en: '![](img/5ac021b4-7fd1-4bc1-a0b6-00ba741ac609.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ac021b4-7fd1-4bc1-a0b6-00ba741ac609.png)'
- en: We are already familiar with the `shift` method. It can be used to shift the
    execution context of a given IO flow into this `Timer`. Remember that `Timer`
    can be constructed from a standard Scala `ExecutionContext`. Other methods that
    `Timer` defines are needed for time measurement. One of them is `clockMonotonic`,
    which we are using for our preceding benchmark.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了 `shift` 方法。它可以用来将给定 IO 流的执行上下文移入这个 `Timer`。记住，`Timer` 可以从标准的 Scala `ExecutionContext`
    构造。`Timer` 定义的其他方法用于时间测量。其中之一是 `clockMonotonic`，我们用它来进行前面的基准测试。
- en: 'Finally, we may want to define a `benchmarkFlush` method to report the measurements
    to the command line as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可能想要定义一个 `benchmarkFlush` 方法来将测量结果报告到命令行，如下所示：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we will try and run our synchronous example concurrently in multiple
    instances while measuring its time. But first of all, we will need a `bunch` function
    to launch multiple instances of this task:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试在多个实例中并发运行我们的同步示例，并测量其时间。但首先，我们需要一个 `bunch` 函数来启动这个任务的多个实例：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first part of this function is similar to the one we had in the previous
    example. However, we have this function slightly extended with the following appendix:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的第一部分与我们在上一个例子中看到的是相似的。然而，我们通过以下附录稍微扩展了这个函数：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that the original version of our bunch function started computations
    asynchronously from its `traverse` method. The result was a list of `Fibers` that
    we were not interested in. In the task of benchmarking, we are interested in the
    time when all the computations terminate. Hence, we would like to use the `join`
    method of the `Fibers` that are returned to create a combined IO data type that
    succeeds when all of the computations succeed. Notice that we still need the `start`
    capability for the tasks to be started asynchronously and not sequentially. If
    you don't use the `start` method from the `traverse` method here, tasks we are
    trying to start in the bunch will be executed synchronously, and we need parallel
    execution to utilize our shared thread pool.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们原来的 `bunch` 函数是从其 `traverse` 方法异步开始计算的。结果是返回了一个我们并不感兴趣的 `Fibers` 列表。在基准测试的任务中，我们感兴趣的是所有计算终止的时间。因此，我们希望使用返回的
    `Fibers` 的 `join` 方法来创建一个组合的 IO 数据类型，当所有计算成功时它才会成功。注意，我们仍然需要 `start` 能力来异步启动任务而不是顺序执行。如果你在这里不使用从 `traverse`
    方法来的 `start` 方法，我们试图在 `bunch` 中启动的任务将会以同步方式执行，而我们需要并行执行来利用我们的共享线程池。
- en: 'Next, we can run the synchronous example in a `bunch` under the benchmark,
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在基准测试下运行同步示例的 `bunch`，如下所示：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面程序的输出如下：
- en: '![](img/0262cf11-caa9-44e5-a3ee-b93cd1fdf274.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0262cf11-caa9-44e5-a3ee-b93cd1fdf274.png)'
- en: It took us five seconds to compute 10 tasks. This is because each of the tasks
    blocks the underlying thread for one second, and we have two threats in our execution
    context.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用了五秒钟来计算 10 个任务。这是因为每个任务都会阻塞底层线程一秒钟，并且我们在执行上下文中有两个线程。
- en: Next, we'll take a look at how to define an asynchronous version of the same
    task.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何定义相同任务的异步版本。
- en: Asynchronous API
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步 API
- en: First of all, we need to remark what exactly we mean by the word asynchronous.
    We mean asynchronous with respect to the thread pool that the IO data type is
    executed on. We assume that we have no control of the task itself, and we are
    not able to redefine it. In fact, we do not care about how it is implemented;
    all we care about is the precise moment when it terminates. The task here is to
    prevent the threads of this precise IO execution from blocking.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要指出我们所说的“异步”究竟是什么意思。我们指的是相对于在执行 IO 数据类型的线程池中的异步。我们假设我们无法控制任务本身，并且无法重新定义它。实际上，我们并不关心它是如何实现的；我们只关心它终止的确切时刻。这里的任务是防止这个精确的
    IO 执行的线程阻塞。
- en: 'To achieve this, we can use the `IO.async` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用 `IO.async` 方法：
- en: '![](img/c27285a4-05d7-4659-ab0e-21e329817001.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c27285a4-05d7-4659-ab0e-21e329817001.png)'
- en: This method has a somewhat tricky signature. So, first, let's take a look in
    brief at what it does. Given a particular computation, it provides a callback
    with which it can notify the IO task to be constructed. The IO task returned from
    the `async` method will be considered completed once the underlying computation
    calls the callback provided to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有一个有点棘手的签名。所以，首先，让我们简要地看看它做了什么。给定一个特定的计算，它提供了一个回调，它可以通知要构建的IO任务。从`async`方法返回的IO任务将在底层计算调用它提供的回调时被视为已完成。
- en: The benefit of this approach is that the IO does not care about where or how
    the computational runs. It only cares about when it is completed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是IO不关心计算在哪里或如何运行。它只关心何时完成。
- en: 'So, the `async` method is a function, the argument to which is another function
    with the following signature:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`async`方法是一个函数，它的参数是另一个具有以下签名的函数：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is a callback that an underlying computation will call on its completion.
    It is provided to the user of the `async` method by IO, and acts as a notification
    stating that the IO should be considered completed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个回调，底层计算在完成时会调用它。它由IO提供给`async`方法的用户，并作为通知表示IO应该被视为已完成。
- en: Next, let's take a look at how this method can be used to create asynchronous
    computations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个方法如何用于创建异步计算。
- en: Asynchronous example
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步示例
- en: 'We can redefine our previous example in terms of `async` as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`async`重新定义先前的例子，如下所示：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, here, we are using the `IO.async` primitive to lift our computation into
    an asynchronous context. First of all, this `async` method gives us a callback
    as an input. We are supposed to call this callback once we are done with our computation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们使用`IO.async`原语将我们的计算提升到异步上下文中。首先，这个`async`方法给我们一个回调作为输入。我们完成计算后应该调用这个回调。
- en: Next, we dispatch our heavy computation to some other execution context. In
    our case, it is merely starting another thread that does not belong to the thread
    pool on which we are executing our IO. Many scenarios are possible here, especially
    in the context of purely asynchronous computations, that is, the ones that do
    not use blocking at all. For example, you could imagine registering a callback
    on another asynchronous action from `async`. This can be useful, for example,
    for GUI programming. However, in this example, using a separate thread will suffice.
    The only thing to keep in mind is that threads are heavyweight primitives. Although
    we are not blocking the IO thread pool, we are still creating threads, and we
    are still blocking them. This can drain the resources of the system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的重计算调度到其他执行上下文中。在我们的例子中，这仅仅是启动另一个不属于我们执行IO的线程池的线程。这里有许多可能的场景，特别是在纯异步计算的情况下，即完全不使用阻塞的计算。例如，你可以想象从`async`注册另一个异步操作的回调。这可能对GUI编程很有用。然而，在这个例子中，使用单独的线程就足够了。唯一需要注意的是，线程是重量级的原语。尽管我们没有阻塞IO线程池，但我们仍在创建线程，并且我们仍在阻塞它们。这可能会耗尽系统的资源。
- en: 'Next, we can run our computation as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以这样运行我们的计算：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/1fd47afc-5165-460d-8b33-80023744919c.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1fd47afc-5165-460d-8b33-80023744919c.png)'
- en: Notice that we were able to compute the operation in two seconds. This is because
    the IO tasks are no longer blocking the underlying execution thread pull the IO
    is executed on. So, once one IO goes to sleep, it releases its thread.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够在两秒钟内完成操作。这是因为IO任务不再阻塞底层执行线程，IO执行时释放了它的线程。
- en: Next, we will pay a little bit more attention to `Fibers` and how you can utilize
    them for concurrent programming.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更关注一下`Fibers`以及如何利用它们进行并发编程。
- en: Fibers
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纤维
- en: As we previously discussed, Fibers are essentially remote control units for
    IO. Let's see how this can be used in practice to run operations in parallel.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，纤维是IO的远程控制单元。让我们看看这在实践中如何用于并行运行操作。
- en: The computation
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算示例
- en: 'Suppose that you have some long-running competition. Suppose that the computation
    in question has the task of finding a sum of numbers on a specific range. The
    computation is long-running because the invocation must pause for half a second
    from number to number:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个长时间运行的竞赛。假设相关的计算任务是找到特定范围内的数字之和。计算是长时间运行的，因为从数字到数字的调用必须暂停半秒：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are defining our competition in terms of a Monadic loop. In the body of the
    flow of the loop, we have two terminal cases. The first terminal case is when
    the current number is equal to the upper bound of our range. In that case, the
    result is the running total plus that number.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Another terminal case is when the number is greater than the upper range of
    the loop. In principle, this situation should never arise, but it is still a good
    idea to guard against it to prevent infinite loops. In this scenario, we return
    the running total without adding the current number.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice the `pure` method, which is used in these non-terminal cases. It
    is defined as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0ce1cee-5993-40ce-acab-b8b440442402.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: It lifts a value into the IO context without doing anything else with it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a non-terminal case of the Monadic loop:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have some debugging output stating the current thread and the current status
    of the computation. Then, we block the execution asynchronously by using the `IO.sleep`
    primitive.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return with a new state of the computation, that is, the next number,
    and the updated running total.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The computation is long-running because it will pause for half a second on each
    number.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see what happens if we want to combine the results of two such computations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: IO combination without Fibers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider that we need to compute a sum of two ranges, and then sum the results.
    A naive way to combine is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, we combine our computations using the Monadic flow.
    Let''s see what happens if we try and run the competition under a benchmark function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result of the preceding execution is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/380011da-dc89-4732-a245-542013df5c1a.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: First, notice that the first range gets computed first. The second range does
    not even start until the first range finishes. Also notice how both of the threads
    of the thread pool get utilized in the process of computation. This can be considered
    a waste of threads and resources since we could use both of the threads to compute
    sums in parallel. However, we are doing so sequentially here.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'We may argue that the preceding scenario occurs because we are using the Monadic
    flow. As you may recall, Monads define sequential composition. It is not possible
    to start the next computation until the previous computation finishes. Also, we
    know that Applicative is used for cases of parallelism. Can we apply the `traverse`
    function to compute all of our computations in parallel? Let''s try:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the computations are independent one from another. What happens if we run
    them?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output looks precisely the same as it did in the preceding sequential example,
    which means that the default implementation of Applicative for IO runs the computations
    one by one, even though they are independent.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: How can the situation be remedied with the help of Fibers? Let's take a look
    at how we can launch the computations in parallel with Fibers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: IO combination with Fibers
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we briefly touched on the topic of Fibers. They are remote control
    units for underlying computations. We know that on any IO, we can call a `start`
    method, and that will cause it to run asynchronously, which means that it will
    not block the current execution flow of the IO effect type. Also, you know that
    we can later block on a Fiber in order to obtain the result. Notice that, here,
    we are blocking with respect to the Monadic flow. It is precisely the Monadic
    flow that is getting blocked, that is, the execution of the Monadic instructions
    gets suspended. The underlying thread IO used to run is not blocked by anything.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们简要地提到了Fibers的主题。它们是底层计算的遥控单元。我们知道在任何IO上，我们可以调用一个`start`方法，这将导致它异步运行，这意味着它不会阻塞当前执行流的IO效应类型。你还知道我们可以稍后阻塞在Fiber上以获取结果。注意，这里我们是相对于Monadic流进行阻塞的。正是Monadic流的执行被阻塞，即Monadic指令的执行被暂停。用于运行的底层线程IO没有被任何东西阻塞。
- en: 'Let''s see how we can implement our sum example with the help of Fibers:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何借助Fibers实现我们的求和示例：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our sum instructions are executed asynchronously with respect to the Monadic
    flow, which means that the Monadic flow application will not wait for either of
    the two sums to finish and will proceed directly through the first two instructions
    without blocking. The result is that both of the computations get submitted for
    execution and will be executed in parallel.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的求和指令相对于Monadic流异步执行，这意味着Monadic流应用程序将不会等待两个求和中的任何一个完成，并且将直接通过前两个指令而不会阻塞。结果是，两个计算都会提交以执行，并且将并行执行。
- en: 'After that, we can block on the Fibers to obtain the results. We can run the
    application as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以阻塞在Fibers上以获取结果。我们可以按照以下方式运行应用程序：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/045e158b-fc1d-4da4-9f04-91698eacc9f8.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/045e158b-fc1d-4da4-9f04-91698eacc9f8.png)'
- en: Now, both of the tasks are executed concurrently. The time needed to compute
    the tasks is reduced by a factor of 2.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个任务都是并发执行的。计算任务所需的时间减少了2倍。
- en: Next, let's take a look at another capability of Fibers, namely to cancel the
    underlying computation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看Fibers的另一个功能，即取消底层计算。
- en: Canceling Fibers
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消Fibers
- en: 'Suppose we have one range shorter than another, and we would like to cancel
    the longer range computation when the first one is completed. You can do this
    with Fibers as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个比另一个短的range，我们希望在第一个完成时取消较长的range计算。你可以用Fibers这样做：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can run it as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式运行它：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And the result of the execution is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结果如下：
- en: '![](img/6c17f512-d4b0-451a-8d3c-e05cb5b6897d.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c17f512-d4b0-451a-8d3c-e05cb5b6897d.png)'
- en: Notice that the second range gets cancelled once the first range finishes its
    execution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦第一个范围完成执行，第二个范围就会被取消。
- en: In this chapter, we have discussed the currency capabilities of the Cats effects
    library in detail. It is the primary objective of the library. However, it has
    a bunch of other useful methods and primitives. So, next, we will take a look
    at one of these primitives—the `bracket` primitive—which is a try-with-resources
    for Cats.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了Cats效应库的货币能力。这是库的主要目标。然而，它还有许多其他有用的方法和原始操作。因此，接下来，我们将查看这些原始操作之一——`bracket`原始操作，它是Cats的try-with-resources。
- en: Bracket
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 括号
- en: 'Often, we encounter a situation where we need to access a resource that we
    need to close afterwards. This can be a file reference, a database session, a
    HTTP connection, or something else. The Cats effect has a dedicated primitive
    to allow you to work with such resources securely. In Java, there is a dedicated
    statement for handling resources, which is try-with-resources. Scala does not
    have a similar statement. However, the situation changes with the `bracket` method,
    which is defined on the IO primitive:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，我们会遇到需要访问之后需要关闭的资源的情况。这可能是一个文件引用、数据库会话、HTTP连接或其他东西。Cats效应有一个专门的原始操作，允许您安全地处理此类资源。在Java中，有一个专门处理资源的语句，即try-with-resources。Scala没有类似的语句。然而，情况随着在IO原始操作上定义的`bracket`方法而改变：
- en: '![](img/75d5b6ae-baa6-4740-9c31-0c12b9eab7dd.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75d5b6ae-baa6-4740-9c31-0c12b9eab7dd.png)'
- en: As it says in the documentation, the `bracket` primitive makes the underlying
    execution engine treat the result of this IO as a resource to be closed. With
    the `bracket` function, you can pass two arguments. The first one specifies what
    you wanted to do with the underlying process. It is very much like the argument
    to the `flatMap` function. The second function is the specification of how to
    close the underlying resource. This second function will be called after the computation
    is finished, no matter how it finished. It could have finished with an error or
    canceled, however, the cleanup function will be called in any situation. This
    prevents memory leaks that can be a problem in the situation of a high-performance
    environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文档中所述，`bracket`原始功能使底层执行引擎将此IO的结果视为一个需要关闭的资源。使用`bracket`函数，你可以传递两个参数。第一个参数指定了你对底层过程想要做什么。它非常类似于`flatMap`函数的参数。第二个函数是关闭底层资源的指定。这个函数将在计算完成后被调用，无论它是如何完成的。它可能以错误或取消结束，但是，在任何情况下都会调用清理函数。这防止了在性能环境中的内存泄漏问题。
- en: 'Let''s take a look at how we can use it as an example. First of all, we need
    a closable resource, the closed status of which we can easily check. We can define
    it as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用它的一个例子。首先，我们需要一个可关闭的资源，我们可以轻松检查其关闭状态。我们可以定义如下：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we have defined a database session connection. It has
    a `closed` flag which prevents any statements to be run against this session when
    it is set. Next, we have the `runStatement` method, which performs some execution
    logic to model a statement run against a database.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们定义了一个数据库会话连接。它有一个`closed`标志，当设置时，防止对会话运行任何语句。接下来，我们有`runStatement`方法，它执行一些执行逻辑来模拟对数据库运行的语句。
- en: This `runStatement` method deserves special attention because it demonstrates
    the power of treating computations as values. First of all, you can see that we
    define the computation logic in the `computation` value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`runStatement`方法值得特别注意，因为它展示了将计算作为值处理的强大功能。首先，你可以看到我们在`computation`值中定义了计算逻辑。
- en: 'Afterwards, we check whether the `closed` flag is set. If it isn''t, we return
    the computation as usual. However, if it is, we return an error. The error method
    is defined as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们检查`closed`标志是否已设置。如果没有设置，我们像往常一样返回计算。但是，如果设置了，我们返回一个错误。错误方法定义如下：
- en: '![](img/3f2cdf87-1612-4ac3-a978-c1fa2f792c19.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f2cdf87-1612-4ac3-a978-c1fa2f792c19.png)'
- en: It terminates the ongoing IO computation due to a failure.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于失败，它终止了正在进行的IO计算。
- en: 'Next, let''s define a few helper methods with which we are going to test our
    bracket primitive:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一些辅助方法，我们将使用这些方法来测试我们的括号原始功能：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we have a function to create a database, and a function
    to query users from this database connection. Everything is done under the IO
    data type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们有一个创建数据库的函数，以及一个从数据库连接查询用户的函数。所有这些都是在IO数据类型下完成的。
- en: 'Next, let''s create a setup that will allow us to see whether a connection
    was closed or not. We can do so by creating a Monadic flow under the bracket primitive,
    and from the flow, we are going to leak the reference to our session to a variable
    outside the flow that we are going to check afterward:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个设置，以便我们可以看到连接是否已关闭。我们可以通过在括号原始功能下创建一个Monadic流程来实现这一点，然后从流程中，我们将把我们的会话引用泄露到流程外的变量中，稍后我们将检查它：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, in the preceding code, we are using the bracket from the computation value.
    We are on the Monadic flow inside this bracket, and as a part of this Monadic flow,
    we are selecting the users to verify that our program works correctly. Finally,
    we leak the resource to a variable outside the flow. The cleanup function is defined
    as closing the session.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在先前的代码中，我们使用了计算值中的括号。我们在括号内部处于Monadic流程中，作为这个Monadic流程的一部分，我们选择用户以验证我们的程序是否正确工作。最后，我们将资源泄露到流程外的变量中。清理函数定义为关闭会话。
- en: 'The result of running the preceding computation is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行先前的计算的结果如下：
- en: '![](img/07d634ce-1bad-4bc0-b32a-18c7077b728a.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07d634ce-1bad-4bc0-b32a-18c7077b728a.png)'
- en: Together with the asynchronous capabilities of IO, bracket provides you with
    a great primitive that can be used in an asynchronous environment where you would
    like to guard against memory leaks.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 结合IO的异步能力，括号为你提供了一个在异步环境中使用、并希望防止内存泄漏的强大原始功能。
- en: Server-side programming
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端编程
- en: One large domain for applying functional programming is server-side programming.
    Server-side programming refers to web applications that constantly run on a server,
    and have the ability to communicate with the outer world. Such an application
    will typically listen on a port for incoming HTTP requests. After a request arrives,
    it will perform some work on the server, and reply back to the requesting client
    with the result of the computation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Applications of such systems are wide. Everything from regular websites to mobile
    applications to **Software as a Service** (**SaaS**) systems are made as web applications.
    Also, once you have a web application that constantly runs on a server, communicates
    with the outer world via a well-defined protocol, and performs some computations,
    you can have a multitude of clients for such an application. For example, you
    may have an HTML-based frontend, together with a mobile application, together
    with integration with third-party applications via API.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Scala and the Cats infrastructure happens to have great support for server-side
    programming. They contain all the primitives that you will need to accept HTTP
    requests, map them to your domain model objects, communicate with the database,
    and reply back to the client. In this section, we will see how exactly it is done.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: But first of all, let's get a brief overview of the general architecture of
    server-side applications, as well as specify the application we are going to be
    using as an example for this chapter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of a server-side application
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, a server application includes a server. A server is an application
    that will constantly run on the given machine and listen to a given HTTP port
    for incoming connections. The incoming connections are typically HTTP connections
    that follow a certain protocol.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Communication protocol
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular way to structure a communication protocol of a web application is
    to follow the RESTful paradigm of communication.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the application listens for HTTP requests, it is reasonable that these
    requests are made to a certain path. For example, a typical HTTP request contains
    the following headers:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, as you can see, the request contains a destination string or a so-called
    path, together with HTTP headers. You can reason about the resources the server
    exposes as entities that have certain behaviors and data defined on them. The
    RESTful paradigm dictates that the capabilities the server side exposes via HTTP
    must have the paths and HTTP methods reflect the resources and their behavior
    that is to be performed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider that you have a server that manages a forum. We will have
    users and forum posts. Regarding the behaviors, over time, we will want to create
    new posts and users, list existing posts and users, and modify and delete them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'These behaviors can be exposed via the HTTP RESTful API as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, the HTTP methods reflect the nature of the behavior to be performed by the
    server. The paths reflect the nature of resources involved in the given behavior.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，HTTP方法反映了服务器要执行的行为的性质。路径反映了给定行为中涉及资源的性质。
- en: The client must frequently send extra information to the server. The server
    is supposed to reply to the client with a certain result. This request and response
    data must follow a certain format that is understandable to both the client and
    the server. Furthermore, since a web application can be exposed not only to one
    client but to a multitude of potential third-party clients, it is necessary that
    such a protocol must be standardized. The same way as the HTTP protocol is a standard
    protocol which a multitude of independent parties understand and implement, the
    same way the requests and responses protocol must also be supported by a multitude
    of independent parties. This is because they will need some libraries to encode
    and decode this request, and we do not want an overhead for them so that they
    can implement them themselves.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 客户必须经常向服务器发送额外的信息。服务器应向客户回复一定的结果。这种请求和响应数据必须遵循一种双方都能理解的一定格式。此外，由于Web应用程序不仅可能面向一个客户，还可能面向众多潜在第三方客户，因此有必要使这种协议标准化。就像HTTP协议是一个众多独立各方都理解并实施的标准化协议一样，请求和响应协议也必须得到众多独立各方的支持。这是因为它们将需要一些库来编码和解码这种请求，我们不希望给他们带来额外的开销，以便他们可以自行实现。
- en: So, a standard way to encode the requests and responses is to use JSON or XML.
    In this example, we will be using JSON because it has much better support than
    XML in Scala. Furthermore, the Cats family of libraries includes capabilities
    to work with JSON easily.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一种标准的编码请求和响应的方式是使用JSON或XML。在这个例子中，我们将使用JSON，因为它在Scala中比XML有更好的支持。此外，Cats库系列包括轻松处理JSON的能力。
- en: The communication protocol is only a small part of what is involved in the server
    architecture. Next, we will briefly discuss which components a server is composed
    of.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通信协议只是服务器架构中涉及的一部分。接下来，我们将简要讨论服务器由哪些组件组成。
- en: The software architecture of a server
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器的软件架构
- en: The first component that any server must have is an application that is capable
    of listening to HTTP requests and responding to them. Such a component is called
    an HTTP server software. Besides that, most servers need some persistence component—a
    database. Next, the server will need a way to communicate with the database. So,
    we need the database access layer.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 任何服务器必须拥有的第一个组件是一个能够监听HTTP请求并对它们做出响应的应用程序。这样的组件被称为HTTP服务器软件。除此之外，大多数服务器还需要一些持久化组件——数据库。接下来，服务器将需要一种与数据库通信的方式。因此，我们需要数据库访问层。
- en: Finally, an orchestration solution is necessary for the preceding components
    to play well together, which means that we need an easy capability to bootstrap
    both the server and the database, and a way to define the communication between
    them. It is important that the orchestration is well-defined and is reproducible,
    with minimal setup on a variety of different environments. This is important because
    you do not want to write the server once for one platform and not be able to port
    it easily to other platforms.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要一个编排解决方案，以便上述组件能够良好地协同工作，这意味着我们需要一个简单的启动服务器和数据库的能力，以及定义它们之间通信的方式。编排必须是明确定义的，并且可重复的，在多种不同的环境中设置最小。这很重要，因为你不希望为某个平台编写一次服务器，却无法轻松将其移植到其他平台。
- en: The preceding components are the basic components for any server-side software.
    Of course, more complex server-side applications involve much more complex architectures;
    however, for the purposes of our example, this will suffice.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上述组件是任何服务器端软件的基本组件。当然，更复杂的服务器端应用程序涉及更复杂的架构；然而，为了我们示例的目的，这已经足够了。
- en: Now, let's discuss the example we are going to use to demonstrate server-side
    programming with the cats and Typelevel libraries.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论我们将要使用的示例，以展示使用cats和Typelevel库进行服务器端编程。
- en: Example specification
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例规范
- en: The example in question will be an online store. So, we will have the entities
    for the customers, the goods, and we will have an ability to describe orders that
    the customers make.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的示例将是一个在线商店。因此，我们将有客户、商品实体，以及描述客户下订单的能力。
- en: We will store all of these entities in a database, and we will expose the functionality
    to create new users and new orders, and to list existing orders and goods via
    an HTTP interface.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些实体存储在数据库中，并且将通过HTTP接口暴露创建新用户和新订单的功能，以及列出现有订单和商品的功能。
- en: Next, let's take a look at how this architecture can be put into practice. We
    will be discussing the architecture as a whole, and we will be introducing various
    functional programming libraries in the process. This will facilitate an integrated
    view of how server-side programming can be done with Cats.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何将这种架构付诸实践。我们将讨论整个架构，并在过程中介绍各种函数式编程库。这将有助于全面了解如何使用Cats进行服务端编程。
- en: Please keep in mind that we will not be going in-depth into any of the libraries
    we are going to discuss, as this would deserve its own book. Also, we have already
    mentioned that cat is on the leading edge of functional programming technology,
    which means that the library develops quickly, and the in-depth information that
    we could have covered would have become obsolete very soon. However, the general
    architectural principles will probably stay the same for a substantial time to
    come.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们不会深入讨论我们将要讨论的任何库，因为这值得一本自己的书。此外，我们已经提到，猫是函数式编程技术的尖端，这意味着这个库发展迅速，我们可能涵盖的深入信息很快就会过时。然而，总体架构原则可能在未来相当长一段时间内保持不变。
- en: Orchestration and infrastructure
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编排和基础设施
- en: First of all, we will be talking about our infrastructure and the software we
    will use to implement our architecture.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论我们的基础设施以及我们将用于实现我们架构的软件。
- en: There will be two separate components to our server-side software. First of
    all, it is Scala-based server-side software, and second of all, it is a Postgres-based
    database.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务端软件将包含两个独立的部分。首先，它是一个基于Scala的服务端软件，其次，它是一个基于Postgres的数据库。
- en: These two components are orchestrated together via Docker.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件通过Docker一起编排。
- en: Although the topics discussed in this subsection do not deal with functional
    programming, it is necessary to understand the big picture in order to understand
    which setting the functional server will operate in.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本小节讨论的主题不涉及函数式编程，但为了理解函数式服务器将在哪种设置下运行，理解整体情况是必要的。
- en: Docker
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: We will define all of the components involved in other software as Docker services
    in a `docker-compose` file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`docker-compose`文件中将涉及的其他软件的所有组件定义为Docker服务。
- en: Docker-compose
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker-compose
- en: 'The file as a whole will look as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件看起来如下：
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The file consists of two services—the Postgres service and the backend service.
    The Postgres service is defined as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 文件由两个服务组成——Postgres服务和后端服务。Postgres服务的定义如下：
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This service defines a container named `mastering_postgres`. The `build` directive
    specifies that we want to build the contents of the `Postgres` folder, which is
    located in the current folder, to a separate Docker image. The port's directive
    specifies which ports the container will expose. The container in question will
    run the database, so we need to expose the ports that the database will be running
    on. Basically, it is a mapping from the ports of the container to the ports of
    the host machine.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务定义了一个名为`mastering_postgres`的容器。`build`指令指定我们想要将当前文件夹中`Postgres`文件夹的内容构建到一个单独的Docker镜像中。端口指令指定了容器将暴露哪些端口。这个容器将运行数据库，因此我们需要暴露数据库将运行的端口。基本上，这是一个从容器端口到主机机端口映射。
- en: 'The second service is defined as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个服务定义如下：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It also provides the name of its container, and it specifies that we want to
    build the contents of the current folder into a separate image. Docker will look
    for a `Dockerfile` in the provided directory and will build it into a separate
    image. Next, since this container will host an HTTP server, we also need to perform
    the port mapping so that we can listen to HTTP connection of the host machine
    from the container.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了其容器的名称，并指定我们想要将当前文件夹的内容构建到一个单独的镜像中。Docker将在提供的目录中查找`Dockerfile`并将其构建到一个单独的镜像中。接下来，由于这个容器将托管一个HTTP服务器，我们还需要进行端口映射，以便我们可以从容器中监听主机机的HTTP连接。
- en: After that, we have the `volumes` array. This array specifies the directories
    on the local machine to be mounted to the directories on the container. In the
    current example, we mount a set of directories of the container that are responsible
    for caching. The first entry is an `ivy2` cache that is used by Scala and SBT
    to store their dependencies. After that, we also mount the SBT root folder, which
    hosts the SBT installation. Finally, we mount the cache folder, which is another
    location where SBT stores its dependencies.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: We perform these mounts of the cache directories so that the container remembers
    what it fetched from invocation to invocation. So, you will not need to wait for
    the application to fetch its dependencies every time you restart the Docker container
    because all of the dependencies will be stored on the host machine under the directories
    that we have mounted.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we mount the current directory to the examples directory under the
    container. This is done so that we can access the Scala sources from the container.
    So, we will be able to run the application from the context of the Docker container,
    which means that we will be able to access all of the infrastructure defined by
    the `docker-compose` file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have an `environment` array. This array specifies the environmental
    variables set the container will be initialized with. We have the variables that
    specify the host and port of the Postgres database. We will use these environmental
    variables in the Scala sources to specify the location of the database.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have two technical entries in the file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These are related to the ability to access the running Docker container from
    the command line. So, we should be able to open a command line on a running Docker
    container due to these two entries. Basically, they specify how the Docker container
    should allocate and treat a console device. If you are interested more in this
    or any other of the Docker entries, please consult the Docker documentation.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss the two Dockerfiles corresponding to the two services we
    have defined in `docker-compose`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfiles
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dockerfiles contain the descriptions of how a particular image must be built.
    We have two images: one is for the database, and the other one is for the backend.
    Let''s start with the database image first:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The Docker file only contains two lines of code. First of all, we inherit from
    an existing image of Postgres. Second, we copy all of the SQL files from the current
    directory to a special directory in the Docker image. This is a standard initialization
    procedure described in the documentation of the Postgres image we inherit from.
    The main idea is to initialize the database with a schema that we are going to
    use. Our schema is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We also have three tables. First, we have a table for customers and goods. Both
    customers and goods have an ID that uniquely identifies them. Also, goods has
    some goods-specific parameters, such as the price and the stock count. Finally,
    we have a table that will link customers to goods as orders.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will populate our database with some sample goods that we are
    going to run our test queries on.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at our backend image:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The image inherits from a standard Scala SBT image so that we are going to have
    Scala and SBT in scope. After that, we define some SBT plugins that we are going
    to use. The first one is to speed up downloading the dependencies, and the second
    one is used to start the server in a separate JVM. We are going to start a server
    in a separate JVM because, in this way, we will retain the possibility to manage
    the server, and start and restart it from the SBT console.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the working directory to our examples directory.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: You will find the instructions on how to run the `Dockerfile` in the `README`
    file of the examples repository.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the architecture of the components involved, let's
    start by taking a more detailed look at how the backend software is constructed
    using Scala.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Backend architecture
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The backend is composed of three separate layers. We have a model layer for
    the model of our business domain, the database access later, and the server layer
    itself. Let's take a look at these layers in turn and see how they can be implemented
    with Typelevel libraries.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Model
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The model is represented by a single Scala file. It contains case classes that
    model our database. Notice that here, we are using plain Scala case classes without
    any other augmentations. If you are familiar with libraries for the Java-like
    Hibernate, you will know that there is an entire class of libraries for so-called
    **object-relational mapping** (**ORM**). These libraries intend to provide a seamless
    mapping of object-oriented concepts to the database schema. The main idea is to
    be able to manage the database, query it, and update it without the need to perform
    SQL statements explicitly. Such libraries aim to provide you with an object-oriented
    API that allows performing these operations while abstracting the underlying SQL
    engine.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Such libraries proved to be a bad idea because of the leaking abstractions.
    There are corner cases that these kinds of ORM libraries are not able to handle
    well. These libraries may not allow you to perform certain functionality that's
    native to a given database.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: In modern functional programming, object-relational mapping is considered a
    bad practice. The current consensus seems to be that executing plain old SQL statements
    is the best way to model interaction with the database. So, unlike object-relational
    mapping libraries, we are not required to modify our domain model specifically
    to match the needs of the object-relational framework we are working under. We
    are not required to implement an interface from our model classes. We are able
    to define our domain model in terms of plain old case classes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Database layer
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A database layer is implemented in terms of the Doobie library. Each entity
    has a separate Scala file, where there is a singleton object, which has all of
    the methods that we need for the purposes of this application. For example, let''s
    take a look at the API that the `customer` object exposes:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, we have several database access methods, and each of them returns an IO—precisely
    the same IO we were learning about in the previous section. The Doobie library
    we are going to have a look at in this section integrates nicely with the Cats
    effect, and we are able to leverage the IO in order to communicate with the database.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how one such method is implemented in terms of Doobie,
    and what the model of operation of Doobie is:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we have several things going on. First, we have an SQL statement under
    a string interpolator that Doobie provides. Now, in Scala, you are able to define
    custom string interpolators that have a form of a certain keyword, written just
    before the string literal. In our case, such a keyword is `sql`. The main idea
    of string interpolators is that, on compile time, they are going to transform
    a string in a certain way, possibly producing an entirely different object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s find out what exactly the string interpolator is doing to the
    string. To do so, we will consult the documentation:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81f43873-0ac5-4116-a4c7-6712015180e9.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: 'So, `sql` is an alias for `fr0` and is defined as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c438f9f5-ed8b-4bc4-8a72-c52ddc267f4c.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: 'This object has two methods to it:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abf5e587-0a33-4d05-bd0b-fb2e71003f30.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: Notice that one of these methods is a macro definition. The macro definition
    is a special method in Scala, which is invoked at compile time. It is used for
    metaprogramming in Scala. String interpolators are usually implemented in terms
    of macros.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, macro transforms a string into a `Fragment` object. A fragment is a model
    of an SQL statement under a string interpolator. Notice that, in the preceding
    screenshot, the string interpolator also gives us external variables to be used
    in SQL statements, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Interpolation is done by the dedicated Doobie macro. It interpolates the variables
    in a secure way so that you do not need to worry about escaping the variables
    that you are inserting into an SQL query—this way, you don't get an SQL injection.
    Doobie performs the escapes for you.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice about the technique employed by Doobie here is that your
    SQL code to interact with the database is defined as a string. However, this string
    is processed at compile time. This provides you with a measure of type safety
    and compiler assistance at compile time.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the fragment definition:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/770bf606-5a06-446b-bc62-9fde80a8edb1.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Fragment has the following API exposed:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6eab09be-6bb4-45d4-b227-ef3221d25647.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: 'For our purposes, the following two methods are of particular importance:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/072fecec-8741-42f5-aef7-787e71b7d31e.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: The preceding method is used for query operations, such as selecting from the
    database.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method is used for update operations, such as making modifications
    to the database:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a2e3322-9895-459b-a06d-e1064a9e382f.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: A fragment is a model of the statement that you have passed to the string interpolator.
    However, this model does not store the information about which exact operation
    you want to perform against the database. So, to specify this kind of operation,
    you call the `update` or `query` methods on `Fragment`. An `update` method is
    used for insert and update operations, and the `query` method is used for `select`
    operations.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are calling the `update` method because we perform an insert
    query. Next, an `Update0` object is generated from the fragment:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cf9f196-062f-4790-9b6b-35a083d155f1.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: 'It exposes the following API:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ec0d938-de5c-41ec-a42f-9540ea301778.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: Note that its API is divided into two sections. First, there is the diagnostics
    section. Since Doobie constructs an internal model of your query, it allows you
    to run certain tests on it to check whether your parameters passed to the query
    are of correct types and whether the query itself is composed correctly. We also
    have the execution API. The execution API is what you use in order to run the
    query.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all of the methods from the execution category return a type under
    the `ConnectionIO` effect type. `ConnectionIO` is essentially a so-called free
    object. If a fragment and `Update0` are models of the SQL query you are about
    to run, the free object of `ConnectionIO` models the precise steps the program
    needs to take against the database to run this query. The free object is a concept
    that comes from abstract algebra. Essentially, the idea is to model the computation
    under the free object without actually running it. The idea is precisely the same
    as with the IO effect type that we looked at in the previous section. That type
    is also a free object.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are calling the `UniqueGeneratedKeys` method in our example.
    The method is aware that the underlying database will generate a primary key for
    the insert operation we are about to perform. In our case, the primary key is
    an integer, and we are passing a type parameter of integer to the method.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a look at the `ConnectionIO` definition, you will see that it is
    a `Free` Monad:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47d743ae-9497-4e10-baf5-df4e81da8e22.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: So, the underlying implementation of DB operations is done using the free Monad
    library, which is also a part of the Cats infrastructure. As we have previously
    said, we will not go into detail about these auxiliary libraries and ideas since,
    by themselves, they deserve a separate book. So, here, the main catch to make
    is that the Doobie library starts from constructing a model of your SQL query
    and provides you with an API to gradually transform it into the model of the computation
    to be performed against your database. Everywhere, the paradigm of computation
    as a value is maintained, and nothing is run until explicitly instructed to.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'We are able to run the `ConnectionIO` under the given effect type using the `transact`
    operation on it. This operation is injected via a Rich Wrapper, which is defined
    as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25bb8703-cbed-40d3-8de5-6ff523ca346d.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: 'The following constructor is used to construct the wrapper:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/836cd659-1ef3-4859-8013-79eb3bc9fc82.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: 'It exposes only a single method:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9d8c294-10b2-49e9-aebd-7788738616ac.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: Essentially, the method is tasked by running the computation under a certain
    effect type when given a transactor for the database. Now, the transactor for
    the database is a driver that knows how to communicate with the underlying database.
    Notice that so far, Doobie exposes the database-independent API, which is expected
    of this kind of library. So, the information that is database-specific is stored
    under the `Transactor` object, which must be implemented for your database in
    order for you to run database queries against that database.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that the effect type that we are passing to the `transact` method
    has a type parameter. This parameter specifies the effect type under which we
    are going to run our computation. Remember that `ConnectionIO` is just a description
    of the computation to be performed. In order to perform it, we need to specify
    which effect type we are going to perform it under.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are using the `tr` variable as the transactor. So, let''s
    take a look at how it is defined to understand the semantics of our example:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we are using the built-in Doobie method to construct the transactor, given
    the full class name of the database driver for the database that we are going
    to use. In our case, we are using Postgres, and we are passing the fully qualified
    name of the Postgres driver to the driver manager construction API.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The next argument to the driver manager construction method is the address of
    the database we are going to connect to. Here, we are connecting to a Postgres
    database, and we are reading its host and port from the environmental variables.
    Remember that, when we were discussing the Docker orchestration of the backend
    and the database, we discussed that the backend has environmental variables populated
    from the `docker-compose` file. These variables specify where the database resides
    for the backend to connect to it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: After the connection string, we have a login and password for the database.
    In our case, login and password are standard connection strings for the Docker
    Postgres image that we are using.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that our transactor is constructed for the effects type of IO.
    This means that when we are going to run the query against this transactor, the
    result will be an IO.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Let's recall what IO is. It is a description of the computation to take place.
    However, `ConnectionIO` is also a description of a computation that is going to
    take place. So, when we are executing the `transact` statement on the `ConnectionIO`,
    we are not actually running it as a computation but translating it from one free
    language to another. We are translating it from `ConnectionIO` to IO. This kind
    of translation from one free language to another is quite common in purely functional
    programming. A useful intuition for when it may be useful may be that of high-level
    programming languages versus low-level programming languages. When you compile
    a language such as Scala or Java, a translation happens from the high-level language
    to the low-level language of the bytecode.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: For humans, it is more convenient to program in a high-level language, but for
    the machines, it is more convenient to consume a low-level language. Hence, before
    we actually run the program, we must first translate it from a high-level language
    to a low-level language.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Something along these lines can also be said about translating from one free
    effect type to another free effect type. Essentially, when aiming to specify all
    of our computations as values, we will sooner or later encounter a situation when
    certain tasks can be easily described using one, higher level language. However,
    it is more convenient to run them when they are expressed in a lower level language.
    So, the translation takes place from a higher level language to a lower level
    language.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we are performing their translation from `ConnectionIO`, which
    is a domain-specific language for describing interactions with a database, to
    the IO language, which is a general purpose low-level language that can describe
    any input-output operation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, our create method of the `customer` object outputs as IO, which we
    can later run when we need their results.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the additional methods that we have already mentioned
    are members of the `customer` object. First of all, let''s take a look at the `list`
    method that is supposed to list all of the customers that are present in the database:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `selectCustomerSql` variable is defined as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We define this query in a separate variable since we are going to reuse it
    in other queries, as we will see a little bit later. Notice how we are using the
    other string interpolators that are available as part of Doobie:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cc07c35-73d0-4d5d-a879-d355063a882c.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: As you can see from the documentation, Doobie provides you with several ways
    to specify fragments as string interpolators. The main difference is whether or
    not they have a trailing whitespace after them. Such a trailing whitespace may
    be very useful if you want to compose your fragments with other fragments later.
    To make sure that you don't need to worry about the separating two fragments you
    are going to concatenate with a whitespace, there is a default string interpolator
    which injects the white space for you. We will see how this is useful later.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our `list` example, as you can see, we are running the query method
    on a fragment. This is to be contrasted with the `update` method on the `create`
    method of the `customer` object. We are performing a `select` query, and so we
    are going to run the `query` method.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The method generates a `Query` object. An interesting thing to notice here is
    that Doobie can automatically convert the result from the raw data returned from
    the database to the data type of your choice. So, we provide the `Customer` type
    as the type parameter to the query, and Doobie is able to automatically infer
    a way to convert the results to this type. In general, such conversions are supported
    out of the box for case classes, tuples, and primitive types. This is accomplished
    at compile time metaprogramming, via macros and type-level computations. This
    useful feature from Doobie places allows it to pose a direct competition to traditional
    object-relational mapping libraries because you are able to map your results to
    your domain model at no additional cost.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query0` object produced by the `query` method is defined as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/781e4d0b-8ecd-458a-b1cf-7767c2c5e8ea.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at its API. It consists of two parts we are interested in.
    First, the Diagnostics part:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0c6047c-4807-4cb2-a191-487163ac3e62.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: 'Next, the Results part:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d5879ce-e5d7-437a-a542-9525c01432c6.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: As with the case of `Update`, the API is separated into diagnostics and results
    sections. It is the results section that is most interesting to us here. Notice
    that it contains various methods specifying which kind of result you are expecting
    to retrieve from your database query. For example, the `option` method is to be
    called when you expect that the query may be returned empty. The `unique` method
    is to be called when you expect one and only one result from the query. Finally,
    the `to` method is to be called whenever you would like to convert your result
    to some collection. Actually, as you can see, there is no restriction that you
    can only build a collection from the given result here. As long as your result
    type conforms to the `F[_]` type form, you should be able to build whatever you
    want, provided that you have a type class this method implicitly depends on. Most
    frequently, this method is used to create collections from the database.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Other methods for this API can also be used for other types of the results.
    However, for the purpose of this tutorial, these three will suffice.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our list example, we are calling the `to` method on it to produce
    a list of all of the customers. As a result, we are getting a `ConnectionIO` type,
    which we have already discussed. We then run it against our transactor, like we
    did previously.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `get` method of the `Customer` object:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first thing to notice here is that we are performing fragment concatenation.
    So, the query to select the customers from the database remains the same. However,
    we are using the concatenation method defined on `Fragment` to concatenate it
    with another fragment and produce a compound fragment. The concatenation method
    is defined on the fragment as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b43747e3-3a49-4b8e-8923-ebcf38b7afde.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
- en: Notice that the trailing white space on the left-hand `Fragment` comes in handy
    here. Remember that we have discussed that the `selectCustomerSql` fragment is
    constructed with a strength interpolator that injects a trailing whitespace into
    the resulting fragment. This is useful precisely for these concatenation situations
    where we need to concatenate two fragments sequentially. Notice that we do not
    need to prepend a white space to the second fragment with the filter condition
    because the first fragment is already built with concatenation in mind.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: After that, we run the `query` method similarly to the way we did in the example
    of listing all customers. However, here, we are only expecting one customer. Hence,
    we will call the `unique` method on the query object. Finally, we will call the `transact`
    method to convert the `ConnectionIO` to `IO`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the `findByName` method:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This method performs a lookup of customers by name. Notice that it is defined
    very similarly to getting a customer by ID. However, we are not calling the `unique`
    method on the query object, but the `option` method. This is because we built
    the method with the possibility of an empty query result in mind. Whenever we
    request a user by ID, we are assuming that the user with the given ID exists in
    the database, at least for the purposes of this example. However, when we are
    looking up a user in the database, we assume that the user with a given name might
    not exist.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Hence, our `findByName` method returns an `Option[Customer]`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Two final methods that we are going to discuss are the `update` and `delete`
    methods:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These methods bring nothing new in terms of the Doobie API and are constructed
    using the API, which we have already learned about.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let ''s see how this example works against a live database. To test this
    example, we will use the following application:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding application tests all of the methods that we have discussed so
    far. First, we create a few customers to work with. Then, we test lookup by name.
    After that, we test the listing of all customers in the database. After that,
    we test getting a customer by ID. Finally, we test the `update` and `delete` operations
    on the customers. The result of running the preceding application is as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b35e16d4-4f96-4b6b-b7d4-f0a42259841f.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: 'Besides the methods for the customers, we will also need methods that define
    how to work with the goods. So, we will need a method to create a good, and we
    can define it as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will need methods to query the goods table, too:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we will need `update` and `delete` methods to modify the database:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We also need a database access object for the orders so that we can modify
    and list them. We will need the following method defined on the order object:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Since these methods do not introduce any new functionality and only demonstrate
    the use of what we have learned of Doobie so far, we will not go into detail regarding
    these methods.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how server-side programming can be performed with purely functional
    style, and how it can leverage the database objects we have defined so far.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Server-side programming
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purposes of server-side programming, we will be using libraries called
    `HTTP4S` and `Circe`. `HTTP4S` is a library with which you can bootstrap an HTTP
    server, accept requests, and define how to respond to them. `Circe` is a library
    with which you can convert JSON strings to domain objects.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '`HTTP4S` leverages IO under the hood so that it can be nicely integrated into
    our existing database infrastructure that outputs IO, as well as so that we can
    be sure that our server runs asynchronously. `Circe` uses a technique of compile-time
    programming via macros (which we have already discussed briefly) to define how
    to convert JSON strings into Scala case classes or traits.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to bootstrap our server as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Under the hood, `HTTP4S` relies on the other library for server-side programming,
    that is, the `Blaze` library. As we have already mentioned, the infrastructure
    for server-side programming involves a wide range of various libraries, so the
    gist to capture here is the big picture of how server-side programming is done.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: We are calling several configuration methods on the `BlazeBuilder` object. The
    `bindHttp` method specifies which host and port we are going to listen to. In
    this case, the host is set to `localhost` or `0.0.0.0`, and the port is set to
    `8888`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the handlers that the server will use. This is done by the `mountService`
    method. In this case, we bind a single handler, `all`, to the root path of this
    server. The `all` handler is a handler we are about to define.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: When we are done configuring the server, we will call the `serve` method on
    it. The method returns a Stream which is a member of another library that is a
    part of the Cats infrastructure. The library is called FS2 (for Functional Streams)
    and is a dedicated library for working with Streams in a functional way. The Stream
    is lazily evaluated,  and in order to run it under IO, we are going to run the compile
    and drain methods on this Stream. The gist of this method is that it is going
    to run a lazy, side-effecting Stream, under the effects type of IO. The IO is
    returned from the drain method. Next, we run the IO using the `unsafeRunSync`
    method.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, quite a lot of libraries are involved in bootstrapping an
    HTTP server in functional programming. However, the central idea is the same across
    all of these libraries. They all leverage the same effect type, IO, and they all
    subscribe to the idea of lazily evaluated, referentially transparent computations
    as values. This means that no computation is run by default; they all are stored
    as descriptions of computations. Since every library has its own domain, some
    libraries might have their own language to describe their computations. However,
    these domain-specific languages are ultimately translated into the single, low-level
    IO language.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in understanding what is going on here in more detail,
    the best way to do so is to examine the Scala API documentation for the libraries
    that we have mentioned. Examining the methods that you are calling, the types
    that they are returning, and understanding the meaning of the methods and the
    types in question can get you a long way in understanding what is going on inside
    this library.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at how the handlers for the web server are defined.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'The `all` handler is defined as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is a combination of several other handlers. The technique to be noted here
    is composability. So, we are capable of composing the other handlers with the
    help of the composition operator.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'The composition in question is an `or` composition, which means that incoming
    requests will be checked against every handler specified by the composition operator
    in turn. The first handler that is capable of handling the request will be used.
    The individual handlers that compose the whole `all` handler are as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will create our new customer handler with the help of the `HttpService`
    object. The method we are calling is defined as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3f87af-eec2-437e-b9d0-24d8112ed349.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
- en: 'It takes a partial function that maps a request to a response under an effect
    type `F`. A request contains what you would expect a request to have. Here is
    a definition and some of the API methods that it exposes:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18b6e019-d271-4815-9585-cd59bce53628.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: 'It exposes the following API:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e6bb790-b11f-4f15-ab34-c7b736fd6167.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
- en: The partial function passed into the request returns a response under an effect
    type. Currently, the only supported effect type is IO. The fact that it returns
    the response under an effect type means that the server is built with asynchrony
    in mind.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: A handler constructed this way will match any incoming request against the partial
    function.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HttpService` constructed by the call is defined as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae184c6b-9d91-4688-ac2f-78a4702bcdf3.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
- en: 'It is an alias for the `Kleisli` type. `Kleisli` is a part of the `cats` core
    library and is defined as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62090901-0506-4e45-b694-3e9d92ee6420.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
- en: 'So, essentially, it is nothing more than a function you would pass to, say,
    the `flatMap` method. It is a function of the following kind:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The partial function we are using to construct the handler does a few things
    here. First of all, notice that there's a DSL to conveniently extract the HTTP
    method and a path from the request. These extractors come from the `HTTP4S` API
    and can be used to match on requests conveniently.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are starting a Monadic flow over IO:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `as` call is supposed to extract the `Customer` object from the incoming
    request body. The assumption is made that the body is a valid JSON string, and
    the `Circe` library will be used under the hood to convert the incoming request
    body to the requested data type. You do not need to perform any other specifications
    of how exactly a JSON must be converted to a case class, as `Circe` defines how
    to do that under the hood.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The next thing that we do is we create a customer in the database. We are using
    the database access object that we defined previously in this section to do this.
    As a result, we get the ID of a newly created customer.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we construct the response to our query:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We are using the call to the `Ok` method to define the `Ok` response code `200`.
    `Ok` is defined as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac62b2a5-d356-482b-b2d4-56cbdeed2d88.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
- en: '`Status` is an abstract class that does not have an `apply` method, which is
    necessary for the object to be callable. So, we should not be able to call it.
    The reason we are able to call it in our program is because the method is injected
    into the `Ok` object via the following Rich Wrapper:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab064298-efbc-4a60-a2e2-3e4eea60c613.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
- en: 'It exposes the following API:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b18ddcf-459e-4802-922a-b7928a55689b.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
- en: This wrapper is parametrized by an effect type under which the response is computed
    and returned. Currently, `HTTP4S` only supports the IO effect type, but this is
    not a problem since all of the other libraries of Typelevel infrastructure also
    speak the language of IO.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we specify a `payload` for the response. It is specified with the `success`
    method, which is defined as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So, the payload is set to an ordinary Scala, `Map[String, Int]` (Int is inferred
    because the argument to `success` is an integer). Since we are using `Circe`,
    this Scala collection will be automatically encoded into JSON and returned to
    the requesting client. Again, this is provided out of the box at no additional
    cost.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `placeOrder` handler is defined as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'It largely uses the functionality that we have already discussed. However,
    a few remarks should be made:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'First of all, `HTTP4S` provides the capability to extract various parameters
    from requests, such as cookies. In the preceding code, we extract the cookie header
    from all of the request headers. If the operation was not successful, we would
    raise an error via an `IO` method. Essentially, rising an error from IO gets the
    entire Monadic flow short-circuited. This is similar to throwing an exception
    from imperative code, except that the IO effect type will take care of error handling:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the preceding line, notice how we are able to extract the JSON body of the
    incoming request as a Scala map. So, not only the primitive types and case classes
    are supported by `Circe`, but also the Scala collection types. `Circe` automatically
    derives encoders and decoders for JSON on compile time:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notice that the preceding response sets the entire case class as its payload.
    We are returning a case class that's nested inside a Scala map. `Circe` is able
    to encode this data structure into JSON seamlessly.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, two list handlers are defined as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Since our database returns the result in IO and since we are using `Circe` to
    encode the model objects into JSON automatically, we can `flatMap` the response
    from the database to wrap it into the response status code. We are able to specify
    this entire handler as a thin wrapper on top of a database access method in just
    one line.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Querying the server
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the example repository, there is a shell script that you can use to query
    the server once you start it. You can start the server with the following command
    from the SBT console:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Notice that this command must be run under the Docker image. So, it will not
    work if you just run an SBT console on your machine from the example repository;
    you will need first to run the Docker image, then run the command from the SBT
    console that is started on that Docker image.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you can use the client shell script to query the database server.
    For example, we can create the new customer as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c7932d1-7da4-4e9e-8521-67f1977287c3.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
- en: Notice how the response is a nicely formatted JSON with an ID of the created
    customer.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can list all of the goods that are present in the database so that
    we can place an order:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ad70984-cf8f-4312-b97a-0709089576c9.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
- en: 'So, we got a JSON array of all the goods as the response. We can place an order
    as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c5d0905-7e09-4d31-b46f-d621609dac43.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
- en: 'And finally, we can list all of the orders to confirm that we have the order
    in the database:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b69642e6-4426-49c6-b3da-6bafa2b13682.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the broad infrastructure that the Typelevel
    umbrella of libraries provides for purely functional programming. First, we learned
    the foundation for asynchronous programming with Cats, that is, the Cats effect
    library. We discussed the `IO` concurrency primitive and the philosophy of computations
    as values. After that, we learned the foundations for the server-side programming,
    which involves a range of libraries. The libraries in question were responsible
    for HTTP request handling and database access, while utilizing a JSON conversion
    library under the hood. We have had a birds-eye overview of what programming with
    these may look like.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: By now, we have covered enough of material for us to start writing industrial
    software in a purely functional way. In the next chapter, we will see more advanced
    patterns of functional programming. These patterns will help our architectures
    solve broader range of problems and make them more flexible.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explain the difference between blocking and non-blocking programming.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is asynchronous programming mandatory for high-load systems?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does computation as a value approach benefit concurrent programming?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an `IO` effect type?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What capabilities for asynchronous programming does `IO` expose?
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
