<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Authentication Using CAS and JAAS</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>This chapter picks up from where we left off in the previous chapter by looking at other authentication mechanisms, namely CAS and JAAS, supported by Spring Security. Again, this is also a fully hands-on coding chapter, and we will build small applications, most of them starting from the base application that we built in <a href="e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml">Chapter 2</a>, <em>Deep Diving into Spring Security</em>. These authentication mechanisms are well-known in the industry and many enterprises have these as established mechanism by which they authenticate the user and give access to many of their employee and consumer facing applications.</span></p>
<p><span>Each of the authentication mechanisms has a project that you can see in the book’s GitHub page. However, in the book, we will only cover important aspects of the sample code to reduce clutter within the chapter.</span></p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>CAS</li>
<li>Java Authentication and Authorization Service</li>
<li>Kerberos</li>
<li>Custom AuthenticationEntryPoint</li>
<li>Password Encoder</li>
<li>Custom Filter</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CAS</h1>
                </header>
            
            <article>
                
<p class="mce-root packt_quote"><q>The</q> Central Authentication Service (CAS) <q>is a single-sign-on/single-sign-off protocol for the web. It permits a user to access multiple applications while providing their credentials (such as userid and password) only once to a central CAS Server application.</q></p>
<p class="mce-root packt_quote CDPAlignRight CDPAlign"><q>– CAS Protocol Specification</q></p>
<p>CAS is an open source, platform-independent, central <strong>single sign-on</strong> (<strong>SSO</strong>) service supporting a variety of well-known protocols. Spring Security has first-class support for CAS, and the implementation is quite simple for an enterprise having a central CAS server. CAS is based on Spring Framework, and the architecture is quite simple, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aed55c9b-b2b1-43d3-99ad-f9414a16474a.png" style="width:22.25em;height:29.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 1: CAS architecture (figure adapted from https://apereo.github.io)</div>
<p>The <strong>CAS server</strong><span> is a</span> Java servlet-based application built on Spring Framework (Spring MVC and Spring Web Flow). It authenticates and grants access to CAS-enabled services.</p>
<p>Upon the successful login of the user, an SSO session is created, and the server issues a <strong>ticket-granting-ticket</strong> (<strong>TGT</strong>), and this token is validated against the backend for subsequent calls from the client.</p>
<p>The <strong>CA</strong><strong>S</strong> <strong>client</strong><span> is a</span> CAS-enabled application that communicates with CAS using supported protocols (CAS, SAML, OAuth, and so on). A number of language supports are already available for CAS, and a number of applications have implemented this methodology. Some of the well-known applications are Atlassian products (JIRA and Confluence), Drupal, and so on.</p>
<p>The following diagram shows the authentication flow (sequence diagram) involving a CAS server and client:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b60a7c9a-1ea7-4707-ab9f-066eeaec965c.png" style="width:36.17em;height:25.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 2: CAS authentication flow</div>
<p><span>Let's see a working hands-on example now. We will have to create a CAS server and then a client that uses the CAS server to connect and get itself authenticated.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CAS server setup</h1>
                </header>
            
            <article>
                
<p>The CAS project source code can be found in GitHub at<span> </span><a href="https://github.com/apereo/cas">https://github.com/apereo/cas</a>. It is not really required to check out the source code, build the CAS server, and then deploy it. WAR overlay is an approach wherein, rather than downloading the source and building, we get a pre-built CAS web application and then we can customize certain behavior as needed for achieving our use case. We will be using this approach to set up our CAS server. Also, we will use Maven-based WAR overlay, which can be found in GitHub at<span> </span><a href="https://github.com/apereo/cas-overlay-template">https://github.com/apereo/cas-overlay-template</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Git clone</h1>
                </header>
            
            <article>
                
<p>Launch your favorite command prompt and clone the CAS overlay project into your desired project. I am going to create a folder named <kbd>cas-sample</kbd>, wherein I will clone the server in the <kbd>server</kbd> folder by executing the following command from the <kbd>cas-sample</kbd> folder:</p>
<pre><strong>git clone https://github.com/apereo/cas-overlay-template.git server</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding additional dependencies</h1>
                </header>
            
            <article>
                
<p>The CAS server doesn't allow any client to connect to it. Each client has to be registered with the desired CAS server. There are multiple mechanisms by which we can register a client to the server. We will use the JSON/YML configuration to register our client to the server. Go ahead and add the following dependency to your <kbd>pom.xml</kbd> file within the server project that you just cloned:</p>
<pre>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;<br/>   &lt;artifactId&gt;cas-server-support-json-service-registry&lt;/artifactId&gt;<br/>   &lt;version&gt;${cas.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;<br/>   &lt;artifactId&gt;cas-server-support-yaml-service-registry&lt;/artifactId&gt;<br/>   &lt;version&gt;${cas.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>Most of the versions in the<span> </span><kbd>pom.xml</kbd><span> </span>file are managed by the parent POM.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the resources folder in the project</h1>
                </header>
            
            <article>
                
<p>In the <kbd>server</kbd> project, create a folder called <kbd>src/main/resources</kbd>. Copy the <kbd>etc</kbd> folder within the <kbd>server</kbd> folder into<span> </span><kbd>src/main/resources</kbd>:</p>
<pre><strong>mkdir -p src/main/resources</strong><br/><strong>cp -R etc src/main/resources</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the application.properties file</h1>
                </header>
            
            <article>
                
<p>Create a file named<span> </span><kbd>application.properties</kbd><span>:</span></p>
<pre><strong>touch src/main/resources/application.properties</strong></pre>
<p>Now fill in the following details in the<span> </span><kbd>application.properties</kbd><span> </span>file:</p>
<pre>server.context-path=/cas<br/>server.port=6443<br/><br/>server.ssl.key-store=classpath:/etc/cas/thekeystore<br/>server.ssl.key-store-password=changeit<br/>server.ssl.key-password=changeit<br/><br/>cas.server.name: https://localhost:6443<br/>cas.server.prefix: https://localhost:6443/cas<br/><br/>cas.adminPagesSecurity.ip=127\.0\.0\.1<br/><br/>cas.authn.accept.users=casuser::password</pre>
<p>The preceding file sets the port and SSL keystore values (a very important step in setting up a CAS server), and also sets up the CAS server <kbd>config</kbd> folder. Clearly, we need to create a keystore as indicated in this file.</p>
<p>Please note, the overlay project has a file, namely the <kbd>build.sh</kbd> file, that contains most of these details in it. We are manually doing this to have a clear understanding.</p>
<p>The last line in <kbd>application.properties</kbd> sets up a test user with the credentials<span> </span><kbd>casuser</kbd>/<kbd>password</kbd>, which can be used to log into the CAS server for various demo purposes. This approach is not recommended in the production setup.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a local SSL keystore</h1>
                </header>
            
            <article>
                
<p>Navigate to the<span> </span><kbd>cas-sample/server/src/main/resources/etc/cas</kbd><span> </span>folder in a shell and execute the following command:</p>
<pre><strong>keytool -genkey -keyalg RSA -alias thekeystore -keystore thekeystore -storepass password -validity 360 -keysize 2048</strong></pre>
<p>The following figure shows the successful execution of the preceding command in a command prompt window:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ca9b9d48-46a3-4470-aac9-c83c8c497c6c.png" style="width:48.42em;height:16.25em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 3: Creation of SSL keystore</div>
<p>It's important to note that for the SSL handshake to work properly, most of the values while generating the keystore are put as localhost. This is an important step and needs to be followed without fail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the .crt file to be used by the client</h1>
                </header>
            
            <article>
                
<p>For the client to connect to the CAS server, out of the generated keystore, we need to create a <kbd>.crt</kbd> file. In the same folder (<kbd>cas-sample/server/src/main/resources/etc/cas</kbd>), run the following command:</p>
<pre><strong>keytool -export -alias thekeystore -file thekeystore.crt -keystore thekeystore</strong></pre>
<p>When asked for a password, provide the same password (we have set the password as <kbd>password</kbd>). Executing the preceding command will create<span> </span><kbd>thekeystore.crt</kbd><span> </span>file.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exporting the .crt file to Java and the JRE cacert keystore</h1>
                </header>
            
            <article>
                
<p>Execute the following command to find your Java installation directory:</p>
<pre><strong>/usr/libexec/java_home</strong></pre>
<p>Alternatively, execute the following command directly to add the <kbd>.crt</kbd> file to Java cacerts:</p>
<pre><strong>keytool -import -alias thekeystore -storepass password -file thekeystore.crt -keystore "$(/usr/libexec/java_home)\jre\lib\security\cacerts"</strong></pre>
<p>The following figure shows successful execution of the preceding command in a command prompt window:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7d6189e2-8121-45a1-84e2-d61464d841a4.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 4: Exporting .crt file to Java keystore</div>
<p>When setting up a client, make sure that the JDK used is the same as the one in which we have added the <kbd>.crt</kbd> file. To reflect the certification addition on to Java, a restart of the machine is suggested.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a CAS server project and running it</h1>
                </header>
            
            <article>
                
<p>From within the <span>cas-sample/cas-server</span><span> folder</span><span>, execute the following two commands:</span></p>
<pre><strong>./build.sh package</strong><br/><strong>./build.sh run</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">If everything goes well, as shown in the following figure, you should see a log message which says <span class="packt_screen">READY</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/60793f9a-7ac4-424f-8cb7-c3ed8951cf73.png" style="width:38.92em;height:9.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 5: CAS server ready logging</div>
<p>Now open a browser and navigate to the URL <kbd>https://localhost:6443/cas</kbd>. This will navigate you to the default login form of the CAS server. Enter the default credentials (<kbd>casuser</kbd>/<kbd>Mellon</kbd>) and you are in. Most browsers would say that the connection is insecure. Add the domain as an exception and soon after that the application will work fine:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6bae5e52-91be-4143-9e0e-4dd08597257a.png" style="width:38.00em;height:28.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 6: Default CAS server login form</div>
<p class="mce-root"/>
<p>Log in with the demo test user (<kbd>testcasuser</kbd>/<kbd>password</kbd>) and you should be logged in and navigated to a user home page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering a client with the CAS server</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, every client has to be registered with the CAS server to allow participation in SSO. The section shows how we can register a client with the CAS server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON service configuration</h1>
                </header>
            
            <article>
                
<p>There are many ways by which a client/service can register itself to a CAS server.<span> </span>We will be using JSON configuration here and have already included dependencies to our<span> </span><kbd>pom.xml</kbd><span> </span>file in the earlier step.<span> </span><span>Apart from JSON, </span>other formats such as YAML, Mongo, LDAP and others do exist.</p>
<p class="mce-root">Create a new folder named <kbd>clients</kbd> in the<span> </span><kbd>src/main/resources</kbd><span> </span>folder. Create a new file in the newly created folder with the following content:</p>
<pre>--- !&lt;org.apereo.cas.services.RegexRegisteredService&gt;<br/>serviceId: "^(http?|https?)://.*"<br/>name: "YAML"<br/>id: 5000<br/>description: "description"<br/>attributeReleasePolicy: !&lt;org.apereo.cas.services.ReturnAllAttributeReleasePolicy&gt; {}<br/>accessStrategy: !&lt;org.apereo.cas.services.DefaultRegisteredServiceAccessStrategy&gt;<br/> enabled: true<br/> ssoEnabled: true</pre>
<p>Save the file with the name <kbd>newYmlFile-5000.yml</kbd>. Let's go into the details of a couple of important attributes:</p>
<ul>
<li><kbd>serviceId</kbd><span>: </span>URL, in a regular expression pattern, of clients who want to connect to the CAS server. In our example, we refer to a client Spring Boot application running on port <kbd>9090</kbd>, which connects to the CAS server.</li>
<li><kbd>id</kbd>: unique identifier for this configuration.</li>
</ul>
<p>Other configurable attributes are documented in the official website at<span> </span><a href="https://goo.gl/CGsDp1">https://goo.gl/CGsDp1</a>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional application.properties file changes</h1>
                </header>
            
            <article>
                
<p>In this step, we let the CAS server about the usage of YML configuration and the location to find these YMLs in the server. Add the following property to the <kbd>application.properties</kbd> file:</p>
<pre>cas.serviceRegistry.yaml.location=classpath:/clients</pre>
<p>It's good practice to separate CAS-related configuration properties into a different properties file. So, go ahead and create a <kbd>cas.properties</kbd> file and include CAS-related properties there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CAS client setup</h1>
                </header>
            
            <article>
                
<p>We will use Spring Initializr to create our CAS client project setup. We used a similar approach earlier. Let's go through it once again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bootstrap Spring project using Spring Initializr</h1>
                </header>
            
            <article>
                
<p class="mce-root">Visit<span> </span><a href="http://start.spring.io/">http://start.spring.io/</a><span> </span>and enter the following details as shown in the following figure. Make sure you select the right dependencies:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dbf118e6-2bf0-48f2-ab88-21c044d2548f.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 7: Spring Initializr for creating secured-cas-client project</div>
<p class="mce-root"/>
<p>Click on the <span class="packt_screen">Generate Project</span> button and download the ZIP file to a folder of your choice (I will be keeping this inside the <kbd>cas-sample</kbd> folder). Execute the <kbd>unzip</kbd> command as follows. I am using macOS for running all my sample application, so I will be using commands, if any, suitable for this platform:</p>
<pre><strong>unzip -a spring-boot-cas-client.zip</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Including CAS libraries in pom.xml</h1>
                </header>
            
            <article>
                
<p>Modify your project's<span> </span><kbd>pom.xml</kbd><span> </span>by adding the following dependencies:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-security-cas&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the application.properties file</h1>
                </header>
            
            <article>
                
<p>Just to make sure that we don't use any other commonly used ports, we are going to set the client to listen to port <kbd>9090</kbd>. In the CAS server, we have also configured it so that the client will be listening to port <kbd>9090</kbd>. Add the following property to the <kbd>application.properties</kbd> file:</p>
<pre>server.port=9090</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional bean configuration</h1>
                </header>
            
            <article>
                
<p>We will now set up various beans, as needed by the CAS Spring Security module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ServiceProperties bean</h1>
                </header>
            
            <article>
                
<p>Convey to CAS that this is your CAS client/service by setting up this bean. Open<span> </span><kbd>SpringBootCasClientApplication.java</kbd><span> </span>and add the following bean definition:</p>
<pre>@Bean<br/>public ServiceProperties serviceProperties() {<br/>ServiceProperties serviceProperties = new ServiceProperties();<br/>    serviceProperties.setService("http://localhost:9090/login/cas");<br/>    serviceProperties.setSendRenew(false);<br/>    return serviceProperties;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The URL <kbd>http://localhost:9090/login/cas</kbd> that is configured will internally get mapped to<span> </span><kbd>CasAuthenticationFilter</kbd>. The parameter<span> </span><kbd>sendRenew<span> </span></kbd>is set to <kbd>false</kbd>. Being set as <kbd>false</kbd>, this tells the login service that username/password is required to gain access to the service, every time. It also gives the user access to all services/client without having to enter a username/password (if already done once). When logged out, the user is logged out automatically from all services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AuthenticationEntryPoint bean</h1>
                </header>
            
            <article>
                
<p><span>Take a look at the following code. Quite straightforward</span>, isn't it?<span>. This is where we let </span><span> know where our CAS server is running. When a user tries to log in, the application will be redirected to this URL:</span></p>
<pre>@Bean<br/>public AuthenticationEntryPoint authenticationEntryPoint() {<br/>    CasAuthenticationEntryPoint casAuthEntryPoint = new CasAuthenticationEntryPoint();<br/>    casAuthEntryPoint.setLoginUrl("https://localhost:6443/cas/login");<br/>    casAuthEntryPoint.setServiceProperties(serviceProperties());<br/>    return casAuthEntryPoint;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TicketValidator bean</h1>
                </header>
            
            <article>
                
<p>When the client application gets a ticket that has already been given to a particular user, this bean is used to validate its authenticity:</p>
<pre>@Bean<br/>public TicketValidator ticketValidator() {<br/>    return new Cas30ServiceTicketValidator("https://localhost:6443/cas");<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CasAuthenticationProvider bean</h1>
                </header>
            
            <article>
                
<p class="mce-root">Bind all the beans declared earlier to the authentication provider bean. We will be loading users from a static list provided as part of<span> </span><kbd>UserDetailsService<span> </span></kbd>in the authentication provider. In a production scenario, this will point to a database:</p>
<pre>@Bean<br/>public CasAuthenticationProvider casAuthenticationProvider() {<br/>  CasAuthenticationProvider provider = new CasAuthenticationProvider();<br/>  provider.setServiceProperties(serviceProperties());<br/>  provider.setTicketValidator(ticketValidator());<br/>  provider.setUserDetailsService((s) -&gt; new User("casuser", "password",<br/>        true, true, true, true,<br/>        AuthorityUtils.createAuthorityList("ROLE_ADMIN")));<br/>  provider.setKey("CAS_PROVIDER_PORT_9090");<br/>  return provider;<br/>}</pre>
<p>With this we are ready to set up the all-important Spring Security configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Spring Security</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's bring in the bean references that we have done in the previous step to the Spring Security configuration file. Create a new Java file called<span> </span><kbd>SpringSecurityConfig</kbd><span> </span>and add member variables. After that, create a constructor with<span> </span><kbd>@Autowired</kbd><span> </span>annotation as follows:</p>
<pre>private AuthenticationProvider authenticationProvider;<br/>private AuthenticationEntryPoint authenticationEntryPoint;<br/><br/>@Autowired<br/>public SpringSecurityConfig(CasAuthenticationProvider casAuthenticationProvider,<br/>                     AuthenticationEntryPoint authenticationEntryPoint) {<br/>   this.authenticationProvider = casAuthenticationProvider;<br/>   this.authenticationEntryPoint = authenticationEntryPoint;<br/>}</pre>
<p>When a user accesses a client application that is secured by a CAS server,<span> the configured bean </span><kbd>AuthenticationEntryPoint</kbd> is triggered, and the user is taken to the CAS server URL that is configured in this bean. Once the user enters credentials and submits the page, the CAS server authenticates the user and creates a service ticket. This ticket is now appended to the URL and the user is taken to the requested client application. The client application uses the<span> </span><kbd>TicketValidator<span> </span></kbd>bean to validate the ticket with the CAS server and, if valid, allows user to access the requested page.</p>
<p class="mce-root">We need to override a couple of important methods before we configure our HTTP security. The first method uses<span> </span><kbd>AuthenticationManagerBuilder</kbd>,<span> </span>in which we tell it to use our<span> </span><kbd>AuthenticationProvider</kbd>. Please create the method as follows:</p>
<pre>@Override<br/>protected void configure(AuthenticationManagerBuilder auth) throws Exception {<br/>    auth.authenticationProvider(authenticationProvider);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>We now override another method that indicates to the<span> </span><kbd>AuthenticationManager<span> </span></kbd>to put our created<span> </span><kbd>AuthenticationProvider</kbd><span> </span>in it:</p>
<pre>@Override<br/>protected AuthenticationManager authenticationManager() throws Exception {<br/>    return new ProviderManager(Arrays.asList(authenticationProvider));<br/>}</pre>
<p>We are now ready to create a filter named <kbd>CasAuthenticationFilter<span> </span></kbd>(as a bean), which actually intercepts the requests and does CAS ticket validation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the CasAuthenticationFilter bean</h1>
                </header>
            
            <article>
                
<p><span>Creating the <kbd>CasAuthenticationFilter</kbd> bean is quite straightforward</span>,<span> as we just assign the</span><span> </span><kbd>serviceProperties<span> </span></kbd><span>that we created to</span> <span>the</span><span> </span><kbd>CasAuthenticationFilter</kbd><span>:</span></p>
<pre>@Bean<br/>public CasAuthenticationFilter casAuthenticationFilter(ServiceProperties serviceProperties) throws Exception {<br/>    CasAuthenticationFilter filter = new CasAuthenticationFilter();<br/>    filter.setServiceProperties(serviceProperties);<br/>    filter.setAuthenticationManager(authenticationManager());<br/>    return filter;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the controller</h1>
                </header>
            
            <article>
                
<p>This is the final setup in our CAS client project setup. We will have an unsecured page containing a link to a secured page. When the secured page is accessed, CAS SSO kicks in and the user is navigated to the CAS authentication page. Once you log in using the credentials (<kbd>casuser</kbd>/<kbd>password</kbd>), the user is taken to the secured page, where we display the authenticated username.</p>
<p>We will create an <kbd>ndexController</kbd> that has the root folder routing (<kbd>/</kbd>). This navigates the user to the <kbd>index.html</kbd> page.</p>
<p>Create<span> </span><kbd>IndexController.java</kbd><span> </span>in a new package (preferably in the controllers package):</p>
<pre>@Controller<br/>public class IndexController {<br/>    @GetMapping("/")<br/>    public String index() {<br/>        return "index";<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Create the<span> </span><kbd>index.html</kbd><span> </span>file in<span> the </span><kbd>src/resources/templates</kbd><span> </span>folder with the following content:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html &gt;<br/>&lt;head&gt;<br/>   &lt;meta charset="UTF-8" /&gt;<br/>   &lt;title&gt;Spring Security CAS Sample - Unsecured page&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Spring Security CAS Sample - Unsecured page&lt;/h1&gt;<br/>&lt;br&gt;<br/>&lt;a href="/secured"&gt;Go to Secured Page&lt;/a&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>Now create a new controller named<span> </span><kbd>CasController.java</kbd><span> </span>within the same controllers package. We will be mapping all secured pages as well as setting up various request mappings in this controller. In the controller class, copy the following code snippet:</p>
<pre>@Controller<br/>@RequestMapping(value = "/secured")<br/>public class CasController {<br/><br/>   @GetMapping<br/>   public String secured(ModelMap modelMap) {<br/>     Authentication auth = SecurityContextHolder.getContext().getAuthentication();<br/>     if( auth != null &amp;&amp; auth.getPrincipal() != null<br/>         &amp;&amp; auth.getPrincipal() instanceof UserDetails) {<br/>       modelMap.put("authusername", ((UserDetails) auth.getPrincipal()).getUsername());<br/>     }<br/>     return "secured";<br/>   }<br/>}</pre>
<p>Create a new HTML file named<span> </span><kbd>secured.html</kbd><span> </span>with the following content. This is our secured page and will just display the authenticated username:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html &gt;<br/>&lt;head&gt;<br/>   &lt;meta charset="UTF-8" /&gt;<br/>   &lt;title&gt;Spring Security CAS Sample - Secured page&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Spring Security CAS Sample - Secured page&lt;/h1&gt;<br/>&lt;br&gt;<br/>&lt;h3 th:text="${authusername} ? 'Hello authenticated user, ' + ${authusername} + '!' : 'Hello non-logged in user!'"&gt;Hello non-logged in user!&lt;/h3&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>Start the CAS server (within <kbd>cas-server</kbd>, run<span> </span><kbd>./build.sh run</kbd>). After that, start the spring boot project (<kbd>secured-cas-client</kbd>) by executing<span> </span><kbd>./mvnw spring-boot:run</kbd>. Navigate your browser to <kbd>http://localhost:9090</kbd>. This will take the user to <kbd>index.html</kbd>, and when they click on the link (which navigates to the <kbd>secured.html</kbd> page), the user is taken to the CAS authentication page. To be authenticated, enter the CAS credentials and, with the ticket set as query string, you will then be taken to the secured page. The secured page validates the ticket with the CAS server and then displays the username.</p>
<p>With this, we complete our CAS sample using Spring Security. In the next section, similar to CAS, we will detail usage of JAAS authentication by employing Spring Security.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java Authentication and Authorization Service</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Java Authentication and Authorization Service</strong> (<strong>JAAS</strong>) (<a href="https://docs.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html">https://docs.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html</a>) implements a Java version of the standard <strong>Pluggable Authentication Module</strong> (<strong>PAM</strong>) framework. It was introduced as an optional package (extension) to the J2SDK (1.3) and then was integrated into the J2SDK 1.4.</p>
<p>JAAS is a standard library which provides your application with the following:</p>
<ul>
<li>A representation of identity (principal) by providing credentials (username/password – subject).</li>
<li>A login service that will call back your application to gather credentials from user and then returns a subject after successful authentication.</li>
<li>A mechanism to grant necessary grants (authorization) to a user after successful authentication:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0cdf1f55-cdf8-4ce3-a790-4a1a28c1f976.png" style="width:23.25em;height:22.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 8: Working of JAAS</div>
<p>As shown in the preceding figure, JAAS has predefined login modules for most of the login mechanisms built in. Custom login modules can be imported or built according to application requirements. JAAS allows application to be independent from the actual authentication mechanism. <span>It's truly pluggable, as new login modules can be integrated without any change to the application code.</span></p>
<p>JAAS is simple and the process is as follows:</p>
<ul>
<li>The application instantiates a <kbd>LoginContext</kbd> object and invokes appropriate (controlled by configuration) <kbd>LoginModule</kbd>, which performs authentication.</li>
<li>Once the authentication is successful, the<span> <em>s</em></span><em>ubject</em><span> </span>(who runs the code) is updated with<span> p</span>rinciple<span> </span>and<span> </span>credentials<span> </span>by<span> </span><kbd>LoginModule</kbd>.</li>
<li>Soon after that, JAAS kick starts the authorization process (using standard Java SE access control model). Access is granted based on the following:
<ul>
<li><strong>Codesource</strong>: where the code originated and who signed the code</li>
<li><strong>The user</strong>: who (also called as <strong>subject</strong>) is running the code</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p>Now that we have a rough idea of JAAS and its working, we will see working of JAAS using Spring Security by going through an example in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a project</h1>
                </header>
            
            <article>
                
<p><span>The sample application that we are going to build is very similar to the one that we created at the start of <a href="69913c59-1186-44b2-8707-dceca721e206.xhtml">Chapter 3</a>, <em>Authentication Using SAML, LDAP, and OAuth/OIDC</em>. Many aspects are similar but differ in a subtle manner. Each step will be explained; however, at times we won't go into details as we have seen some aspects in earlier samples.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up Maven project</h1>
                </header>
            
            <article>
                
<p>We will be creating a Maven project using the IntelliJ IDE. Add the following dependencies and build setup in your<span> </span><kbd>pom.xml</kbd><span> </span>file:</p>
<pre>&lt;groupId&gt;com.packtpub.book.ch04.springsecurity&lt;/groupId&gt;<br/>&lt;artifactId&gt;jetty-jaas-authentication&lt;/artifactId&gt;<br/>&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br/>&lt;packaging&gt;war&lt;/packaging&gt;<br/>&lt;properties&gt;<br/>   &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;<br/>   &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;<br/>   &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;<br/>&lt;/properties&gt;<br/>&lt;dependencies&gt;<br/>   &lt;!--Spring Security Dependencies--&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>       &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;<br/>       &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>       &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;<br/>       &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;!--Spring Framework Dependencies--&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>       &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br/>       &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br/>       &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br/>       &lt;version&gt;5.0.4.RELEASE&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;!-- JSP, JSTL and Tag Libraries--&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br/>       &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br/>       &lt;version&gt;3.1.0&lt;/version&gt;<br/>       &lt;scope&gt;provided&lt;/scope&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br/>       &lt;artifactId&gt;jstl&lt;/artifactId&gt;<br/>       &lt;version&gt;1.2&lt;/version&gt;<br/>       &lt;scope&gt;provided&lt;/scope&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;<br/>       &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;<br/>       &lt;version&gt;2.3.1&lt;/version&gt;<br/>       &lt;scope&gt;provided&lt;/scope&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;<br/>       &lt;artifactId&gt;javax.servlet.jsp.jstl-api&lt;/artifactId&gt;<br/>       &lt;version&gt;1.2.1&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;taglibs&lt;/groupId&gt;<br/>       &lt;artifactId&gt;standard&lt;/artifactId&gt;<br/>       &lt;version&gt;1.1.2&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;!--SLF4J and logback--&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br/>       &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;<br/>       &lt;version&gt;1.7.25&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br/>       &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;<br/>       &lt;version&gt;1.7.25&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;<br/>       &lt;artifactId&gt;logback-core&lt;/artifactId&gt;<br/>       &lt;version&gt;1.2.3&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;<br/>       &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;<br/>       &lt;version&gt;1.2.3&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/>&lt;/dependencies&gt;<br/><br/>&lt;build&gt;<br/>   &lt;plugins&gt;<br/>       &lt;plugin&gt;<br/>           &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;<br/>           &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;<br/>           &lt;version&gt;9.4.10.v20180503&lt;/version&gt;<br/>       &lt;/plugin&gt;<br/>   &lt;/plugins&gt;<br/>&lt;/build&gt;</pre>
<p>We add Spring Framework, Spring Security, JSP/JSTL, and the logging framework (SLF4J and Logback) dependencies. We will be using an embedded jetty server (look at the build section) to run our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up LoginModule</h1>
                </header>
            
            <article>
                
<p><kbd>LoginModule</kbd><span> </span>is responsible for authenticating a user. We will be creating our own<span> </span><kbd>LoginModule</kbd><span> </span>named<span> </span><kbd>JaasLoginModule<span> </span></kbd>and then implementing the <kbd>login</kbd> method. Being a sample application, our login logic is quite trivial. The<span> </span><kbd>LoginModule</kbd><span> </span>interface has to be implemented for you to write your own custom login module.</p>
<p class="mce-root">Create a class, <kbd>JaasLoginModule.java</kbd> (which implements<span> </span><kbd>LoginModule</kbd>),<span> </span>and implement all the methods. In this class, we will be focusing on two important methods. In the <kbd>initialize</kbd> method, we get all the necessary information, such as username/password/subject, that is stored as field variables to be used in our main <kbd>login</kbd> method:</p>
<pre>// Gather information and then use this in the login method<br/>@Override<br/>public void initialize(Subject subject, CallbackHandler callbackHandler, Map&lt;String, <br/>            ?&gt; sharedState, Map&lt;String, ?&gt; options) {<br/>    this.subject = subject;<br/><br/>    NameCallback nameCallback = new NameCallback("Username:");<br/>    PasswordCallback passwordCallback = new PasswordCallback("Password:", false);<br/>    try {<br/>        callbackHandler.handle(new Callback[] { nameCallback, passwordCallback });<br/>    } catch (IOException e) {<br/>        e.printStackTrace();<br/>    } catch (UnsupportedCallbackException e) {<br/>        e.printStackTrace();<br/>    }<br/>    username = nameCallback.getName();<br/>    password = new String(passwordCallback.getPassword());<br/>}</pre>
<p class="mce-root">In the <kbd>login</kbd> method, we will log in using the values stored in the <kbd>initialize</kbd> method. In our case, if the hard-coded username/password is valid, set the principal in the subject:</p>
<pre>// Code where actual login happens. Implement any logic as required by your application<br/>// In our sample we are just doing a hard-coded comparison of username and password<br/>@Override<br/>public boolean login() throws LoginException {<br/>    if (username == null || (username.equalsIgnoreCase("")) ||<br/>        password == null || (password.equalsIgnoreCase(""))) {<br/>        throw new LoginException("Username and password is mandatory.");<br/>    } else if (username.equalsIgnoreCase("admin") &amp;&amp;        <br/>        password.equalsIgnoreCase("password")) {<br/>        subject.getPrincipals().add(new JaasPrincipal(username));<br/>        return true;<br/>    } else if (username.equalsIgnoreCase("user") &amp;&amp; <br/>        password.equalsIgnoreCase("password")) {<br/>        subject.getPrincipals().add(new JaasPrincipal(username));<br/>        return true;<br/>    }<br/>    return false;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a custom principal</h1>
                </header>
            
            <article>
                
<p>We have created our own custom principal class by implementing the <kbd>java.security.Principal</kbd> interface. It's a very simple class in which we take in the username through a constructor and then use that to return in the <kbd>getName</kbd> method:</p>
<pre>public class JaasPrincipal implements Principal, Serializable {<br/>    private String username;<br/>    public JaasPrincipal(String username) {<br/>        this.username = username;<br/>    }<br/>    @Override<br/>    public String getName() {<br/>        return "Authenticated_"+this.username;<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a custom AuthorityGranter</h1>
                </header>
            
            <article>
                
<p><kbd>AuthorityGranter<span> </span></kbd>is entrusted to provide relevant roles to the authenticated user. We will be creating our own custom class by implementing<span> </span><kbd>org.springframework.security.authentication.jaas.AuthorityGranter</kbd>:</p>
<pre>public class JaasAuthorityGranter implements AuthorityGranter {<br/>    @Override<br/>    public Set&lt;String&gt; grant(Principal principal) {<br/>        if (principal.getName().equalsIgnoreCase("Authenticated_admin")) {<br/>            return Collections.singleton("ROLE_ADMIN");<br/>        } else if (principal.getName().equalsIgnoreCase("Authenticated_user")) {<br/>            return Collections.singleton("ROLE_USER");<br/>        }<br/>        return Collections.singleton("ROLE_USER");<br/>    }<br/>}</pre>
<p>Being a sample implementation, in this class, we look at the logged in users username and grant a hard-coded role to it. In real-life applications, we would be doing something more serious in here by actually querying a database and then granting appropriate roles to the logged in user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration files</h1>
                </header>
            
            <article>
                
<p>We need to have a number of configuration files (Java configuration) in our sample, most of which have been covered earlier. For the remaining files (yet to be covered), we will either run through them quickly or go into details when they are covered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application configuration</h1>
                </header>
            
            <article>
                
<p>We don't have any application-specific configuration here but it's always good to have such a file in your application. We have <kbd>ApplicationConfig.java</kbd> as our application-level Java configuration (it doesn't have any content in it).</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring MVC configuration</h1>
                </header>
            
            <article>
                
<p>As shown in the following code, here we will be creating Spring MVC specific Java configurations (<kbd>SpringMVCConfig.java</kbd>):</p>
<pre>@Configuration<br/>@EnableWebMvc<br/>@ComponentScan( basePackages = "com.packtpub")<br/>public class SpringMVCConfig implements WebMvcConfigurer {<br/>    @Override<br/>    public void configureViewResolvers(ViewResolverRegistry registry) {<br/>        registry.jsp().prefix("/WEB-INF/views/").suffix(".jsp");<br/>    }<br/>    @Override<br/>    public void addViewControllers(ViewControllerRegistry registry) {<br/>        registry.addViewController("/login");<br/>    }<br/>}</pre>
<p>In this configuration, set the view's <em>prefix</em> and <em>suffix</em>. Make sure that your login view controller is added explicitly, as we don't have a route defined in our controller (we will see the controller later).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Spring Security configuration</h1>
                </header>
            
            <article>
                
<p>This is a very important configuration example.</p>
<p class="mce-root">We will create an<span> </span><kbd>AuthenticationProvider<span> </span></kbd>bean. We will be using our custom<span> </span><kbd>LoginModule<span> </span></kbd>and then use <kbd>org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider</kbd><span> </span>to set things up. We then set this authentication provider as the global provider. Any request will pass through this provider (<kbd>SpringSecurityConfig.java</kbd>):</p>
<pre>@Bean<br/>DefaultJaasAuthenticationProvider jaasAuthenticationProvider() {<br/>   AppConfigurationEntry appConfig = new AppConfigurationEntry("com.packtpub.book.ch04.springsecurity.loginmodule.JaasLoginModule",<br/>           AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, new HashMap());<br/><br/>   InMemoryConfiguration memoryConfig = new InMemoryConfiguration(new AppConfigurationEntry[] { appConfig });<br/><br/>   DefaultJaasAuthenticationProvider def = new DefaultJaasAuthenticationProvider();<br/>   def.setConfiguration(memoryConfig);<br/>   def.setAuthorityGranters(new AuthorityGranter[] {jaasAuthorityGranter});<br/>   return def;<br/>}<br/><br/>//We are configuring jaasAuthenticationProvider as our global AuthenticationProvider<br/>@Autowired<br/>public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {<br/>   auth.authenticationProvider(jaasAuthenticationProvider());<br/>}</pre>
<p>The next most important method is the <kbd>configure</kbd> method, in which we will make sure that we set the right path which need to be secured and we will also set up some important configurations:</p>
<pre>// Setting up our HTTP security<br/>@Override<br/>protected void configure(HttpSecurity http) throws Exception {<br/><br/>   // Setting up security<br/>   http.authorizeRequests()<br/>           .regexMatchers("/admin/.*").hasRole("ADMIN")<br/>           .anyRequest().authenticated().and().httpBasic();<br/><br/>   // Setting our login page and to make it public<br/>   http.formLogin().loginPage("/login").permitAll();<br/>   // Logout configuration<br/>   http.logout().logoutSuccessUrl("/");<br/>   // Exception handling, for access denied<br/>   http.exceptionHandling().accessDeniedPage("/noaccess");<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controllers</h1>
                </header>
            
            <article>
                
<p>We just have one controller in which we will configure all the routes (<kbd>JaasController.java</kbd>):</p>
<pre>@Controller<br/>public class JaasController {<br/>    @RequestMapping(value="/", method = RequestMethod.GET)<br/>    public ModelAndView userPage() {<br/>        ModelAndView modelAndView = new ModelAndView("user");<br/>        return modelAndView;<br/>    }<br/>    @RequestMapping(value = "/admin/moresecured", method = RequestMethod.GET)<br/>    public ModelAndView adminPage(HttpServletRequest request) {<br/>        ModelAndView modelAndView = new ModelAndView();<br/>        modelAndView.setViewName("moresecured");<br/>        return modelAndView;<br/>    }<br/>    @RequestMapping(value="/noaccess", method = RequestMethod.GET)<br/>    public ModelAndView accessDenied() {<br/>        ModelAndView modelAndView = new ModelAndView("noaccess");<br/>        return modelAndView;<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up pages</h1>
                </header>
            
            <article>
                
<p>We have a few trivial pages. I don't want to paste the code in here, as it is quite self-explanatory:</p>
<ul>
<li><kbd>login.jsp</kbd>: Our custom login page, which is used to collect username and password from the end user.</li>
<li><kbd>user.jsp</kbd>: The page that is set as root in the sample. After login, the user is navigated to this page. We just print the session ID and also the username to showcase the login.</li>
<li><kbd>moresecured.jsp</kbd>: This is just to showcase how the role of the user matters. This page can only be accessed by a user having the <kbd>ADMIN</kbd> role.</li>
<li><kbd>noaccess.jsp</kbd>: When the user doesn't have access to any page, this dummy page comes in for the user.</li>
</ul>
<p>A full sample project can be found in the book’s GitHub page within the <em>jetty-jaas-authentication </em><span>project</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>From the root of the project, execute the following command:</p>
<pre><strong>mvn jetty:run</strong></pre>
<p>Open a browser and navigate to<span> </span><kbd>http://localhost:8080</kbd>. You will be provided with a dirty-looking login page. Enter username/password (admin/password or user/password) and you will be navigated to the root page (<kbd>user.jsp</kbd>).</p>
<p class="mce-root"/>
<p>This completes our JAAS example using Spring Security. As shown in Figure 8 above, JAAS can be used to achieve authentication using other protocols. One of the well-known mechanism is authentication using Kerberos protocol. Next brief section gives you a rough idea of how JAAS can be used to achieve Kerberos based authentication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kerberos</h1>
                </header>
            
            <article>
                
<p>JAAS provides a number of built-in types of<span> </span><kbd>LoginModule<span> </span></kbd>and one of them is<span> </span><kbd>rb5LoginModule</kbd>, which is used to authenticate users using the Kerberos protocol. So, indeed, JAAS methodology can be used to achieve Kerberos authentication within your Spring-based application with ease.</p>
<p>Let's get into some more important details about authentication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom AuthenticationEntryPoint</h1>
                </header>
            
            <article>
                
<p>A custom <kbd>AuthenticationEntryPoint</kbd> can be used to set necessary response headers, content-type, and so on before sending the response back to the client.</p>
<p class="mce-root">The<span> </span><kbd>org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint</kbd><span> </span><span>class </span><span>is a built-in</span><span> </span><kbd>AuthenticationEntryPoint</kbd><span> </span><span>implementation, which will get invoked for basic authentication to commence. A custom entry point can be created by implementing the</span><span> </span><kbd>org.springframework.security.web.AuthenticationEntryPoint</kbd><span> </span><span>interface. The following is an example implementation:</span></p>
<pre>@Component<br/>public final class CustomAuthenticationEntryPoint implements <br/>        AuthenticationEntryPoint {<br/>    @Override<br/>    public void commence(final HttpServletRequest request, final <br/>            HttpServletResponse response, final AuthenticationException <br/>        authException) throws IOException {<br/>        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");<br/>    }<br/>}</pre>
<p>When a client accesses resources without authentication, this entry point kicks in and throws a 401 status code (<kbd>Unauthorized</kbd>).</p>
<p class="mce-root"/>
<p>In the Spring Security Java configuration file, make sure that the <kbd>configure</kbd> method has this custom<span> </span><kbd>AuthenticationEntryPoint</kbd><span> </span>defined, as shown in the following code snippet:</p>
<pre>@Override<br/>protected void configure(HttpSecurity http) throws Exception {<br/>    http<br/>        .authorizeRequests()<br/>        .antMatchers("/public").permitAll()<br/>        .anyRequest().authenticated()<br/>        .and()<br/>        .httpBasic()<br/>        .authenticationEntryPoint(customAuthenticationEntryPoint);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple AuthenticationEntryPoint</h1>
                </header>
            
            <article>
                
<p>Spring Security does allow you to configure multiple <kbd>AuthenticationEntryPoint</kbd><span> </span>for your application, if needed.</p>
<p>Since Spring Security 3.0.2, <kbd>org.springframework.security.web.authentication.DelegatingAuthenticationEntryPoint</kbd> looks at all declared <kbd>AuthenticationEntryPoint</kbd> in the configurations and executes them.</p>
<p>Since Spring Security 5.x, we have <kbd>org.springframework.security.web.server.DelegatingServerAuthenticationEntryPoint</kbd><span>,</span> which uses reactive data types and brings in asynchronous nature to its execution.</p>
<p class="mce-root">The <kbd>defaultAuthenticationEntryPointFor()</kbd><span> </span>method in the Spring Security configuration can also be employed to set up multiple entry points looking at different URL matching (see the following code snippet):</p>
<pre>@Override<br/>protected void configure(HttpSecurity http) throws Exception {<br/>    http<br/>    .authorizeRequests()<br/>        .antMatchers("/public").permitAll()<br/>        .anyRequest().authenticated()<br/>        .and()<br/>        .httpBasic()<br/>    .defaultAuthenticationEntryPointFor(<br/>        loginUrlAuthenticationEntryPointUser(),<br/>        new AntPathRequestMatcher("/secured/user/**"))<br/>    .defaultAuthenticationEntryPointFor(<br/>        loginUrlAuthenticationEntryPointAdmin(),<br/>        new AntPathRequestMatcher("/secured/admin/**"));<br/>}<br/>@Bean<br/>public AuthenticationEntryPoint loginUrlAuthenticationEntryPointUser(){<br/>    return new LoginUrlAuthenticationEntryPoint("/userAuth");<br/>}      <br/>@Bean<br/>public AuthenticationEntryPoint loginUrlAuthenticationEntryPointAdmin(){<br/>    return new LoginUrlAuthenticationEntryPoint("/adminAuth");<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PasswordEncoder</h1>
                </header>
            
            <article>
                
<p>Before Spring Security 5, the framework allowed only one <kbd>PasswordEncoder</kbd> throughout the application and also had weak password encoders such as MD5 and SHA. These encoders also didn't have dynamic salt, rather it had more static salt which had to be supplied. With Spring Security 5, there have been huge changes in this area and with the new version, the password encoding concept employs delegation and allows multiple password encoding within the same application. The password which has been encoded has a identifier prefixed to indicate what algorithm has been used (see the following example):</p>
<pre class="mce-root">{bcrypt}$2y$10$zsUaFDpkjg01.JVipZhtFeOHpC2/LCH3yx6aNJpTNDOA8zDqhzgR6</pre>
<p>This approach enables multiple encoding as needed within the application to be employed. If no identifier is mentioned, this means it uses the default encoder, which is<span> </span><kbd>StandardPasswordEncoder</kbd>.</p>
<p>Once you decide on the password encoding, this can be used within the<span> </span><kbd>AuthenticationManager</kbd>. One such example is the following <span>code </span>snippet:</p>
<pre>@Autowired<br/>public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {<br/>    auth<br/>        .inMemoryAuthentication()<br/>        .passwordEncoder(new StandardPasswordEncoder())    <br/>        .withUser("user")<br/>        .password("025baf3868bc8f785267d4aec1f02fa50809b7f715576198eda6466")<br/>        .roles("USER");<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Spring Security 5, as mentioned earlier, introduced a delegation approach by introducing <kbd>DelegationPasswordEncoder</kbd>. <kbd>DelegatingPasswordEncoder</kbd> has replaced <kbd>PasswordEncoder</kbd> and can be created by two approaches as follows:</p>
<ul>
<li>Approach 1:</li>
</ul>
<pre style="padding-left: 60px">PasswordEncoder passwordEncoder = <br/>    PasswordEncoderFactories.createDelegatingPasswordEncoder();<br/>passwordEncoder.setDefaultPasswordEncoderForMatches(new BCryptPasswordEncoder());</pre>
<ul>
<li>Approach 2:</li>
</ul>
<pre style="padding-left: 60px">String defaultEncode = "bcrypt";<br/>Map encoders = new HashMap&lt;&gt;();<br/>encoders.put(defaultEncode, new BCryptPasswordEncoder());<br/>encoders.put("scrypt", new SCryptPasswordEncoder());<br/>encoders.put("sha256", new StandardPasswordEncoder());<br/><br/>PasswordEncoder passwordEncoder =<br/>    new DelegatingPasswordEncoder(defaultEncode, encoders);</pre>
<p><kbd>DelegatingPasswordEncoder</kbd><span> </span>allows passwords to be validated against old encoding approaches and upgrades the password over a period of time without any hassle. This approach can be used to automatically upgrade passwords (old encoding to new encoding) as and when the user authenticates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Salt</h1>
                </header>
            
            <article>
                
<p>To make brute force attacks harder, while encoding we also can supply a random string. This random string is called <strong>salt</strong>. Salt text is included in <kbd>PasswordEncoder</kbd> as shown in the following code snippet:</p>
<pre>auth<br/>    .inMemoryAuthentication()<br/>    .passwordEncoder(new StandardPasswordEncoder(“random-text-salt”));</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom filters</h1>
                </header>
            
            <article>
                
<p>As explained earlier, Spring Security works on servlet filters. There are number of built-in servlet filters that do almost all the necessary functionalities. If needed, Spring Security does provide a mechanism to write your own custom filter and can be plugged in at the right point in the filter chain execution. Create your own filter by extending <kbd>org.springframework.web.filter.GenericFilterBean</kbd> as shown in the following code snippet:</p>
<pre class="mce-root">public class NewLogicFilter extends GenericFilterBean {<br/>    @Override<br/>    public void doFilter(ServletRequest request, ServletResponse response,<br/>            FilterChain chain) throws IOException, ServletException {<br/>        // Custom logic<br/>        chain.doFilter(request, response);<br/>    }<br/>}</pre>
<p class="mce-root">Once you create your own filter, plug it into the filter chain in the Spring Security configuration file as follows:</p>
<pre class="mce-root">@Configuration<br/>public class SpringSecurityConfiguration extends WebSecurityConfigurerAdapter {<br/>    @Override<br/>    protected void configure(HttpSecurity http) throws Exception {<br/>        http<br/>            .addFilterBefore(new NewLogicFilter(), <br/>                BasicAuthenticationFilter.class);<br/>    }<br/>}</pre>
<p>You can place the new filter before, after, or at a particular location in the filter chain. If you want to extend an existing filter, you have that provision as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered two more authentication mechanisms, namely CAS and JAAS, supported by Spring Security, through hands-on coding examples. Again, we have used the sample application build as part of <a href="e43a2e26-5b28-4d37-a7f8-d3c992a07bc2.xhtml">Chapter 2</a>, <span><em>Deep Diving into Spring Security</em>,</span> as a base to explain the working and implementation of other authentication mechanisms. We then covered some important concepts and the customization possible in Spring Security.</p>
<p>In this chapter, we <span>intentionally </span><span>didn't use reactive programming in our coding examples. This chapter was aimed at making you understand the core concepts of each CAS and JAAS authentication mechanism by making use of the familiar Spring Web MVC application framework. We will cover reactive programming in more detail in <a href="df488f9c-24a7-4d0f-ac82-1d126a391fcc.xhtml">Chapter 5</a>, <em>Integrating with Spring WebFlux</em>. We will start the next chapter by introducing you to Spring WebFlux and, in due course, implement Spring Security. While going through the main contents of <a href="https://cdp.packtpub.com/hands_on_spring_security_5_for_reactive_applications/wp-admin/post.php?post=168&amp;action=edit#post_29">Chapter 5</a>, <em>Integrating with Spring WebFlux</em>, you will clearly understand that making the code examples in this chapter comply to reactive is quite easy.</span></p>


            </article>

            
        </section>
    </body></html>