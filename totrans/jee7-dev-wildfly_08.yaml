- en: Chapter 8. Adding WebSockets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。添加WebSocket
- en: '**WebSockets** are one of the biggest additions in Java EE 7\. In this chapter,
    we will explore the new possibilities that they provide to a developer. In our
    ticket booking applications, we already used a wide variety of approaches to inform
    the clients about events occurring on the server side. These include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket**是Java EE 7中最大的新增功能之一。在本章中，我们将探讨它们为开发者提供的新可能性。在我们的票务预订应用程序中，我们已经使用了多种方法来通知客户端服务器端发生的事件。以下是一些方法：'
- en: JSF polling
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF轮询
- en: Java Messaging Service (JMS) messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java消息服务（JMS）消息
- en: REST requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST请求
- en: Remote EJB requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程EJB请求
- en: All of them, besides JMS, were based on the assumption that the client will
    be responsible for asking the server about the state of the application. In some
    cases, such as checking whether someone else has not booked a ticket during our
    interaction with the application, this is a wasteful strategy; the server is in
    the position to inform clients when it is needed. What's more, it feels like the
    developer must hack the HTTP protocol to get a notification from a server to the
    client. This is a requirement that has to be implemented in most web applications,
    and therefore, deserves a standardized solution that can be applied by the developers
    in multiple projects without much effort.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了JMS之外，所有这些方法都基于客户端将负责询问服务器应用程序状态的假设。在某些情况下，例如在我们与应用程序交互时检查是否有人预订了票，这是一种浪费的策略；服务器在需要时可以通知客户端。更重要的是，感觉开发者必须修改HTTP协议才能从服务器获取通知发送到客户端。这是一个大多数Web应用程序都必须实现的要求，因此，值得有一个标准化的解决方案，开发者可以在多个项目中轻松应用，而无需付出太多努力。
- en: WebSockets are changing the game for developers. They replace the request-response
    paradigm in which the client always initiates the communication with a two-point
    bidirectional messaging system. After the initial connection, both sides can send
    independent messages to each other as long as the session is alive. This means
    that we can easily create web applications that will automatically refresh their
    state with up-to-date data from the server. You probably have already seen this
    kind of behavior in Google Docs or live broadcasts on news sites. Now we can achieve
    the same effect in a simpler and more efficient way than in earlier versions of
    Java Enterprise Edition. In this chapter, we will try to leverage these new, exciting
    features that come with WebSockets in Java EE 7 thanks to JSR 356 ([https://jcp.org/en/jsr/detail?id=356](https://jcp.org/en/jsr/detail?id=356))
    and HTML5.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets正在改变开发者的游戏规则。它们取代了客户端始终通过双向消息系统发起通信的请求-响应范式。在初始连接之后，只要会话保持活跃，双方就可以相互发送独立的消息。这意味着我们可以轻松创建那些会自动使用来自服务器的最新数据刷新其状态的Web应用程序。你可能已经在Google
    Docs或新闻网站的现场直播中见过这种行为。现在，我们可以以比Java企业版早期版本更简单、更高效的方式实现相同的效果。在本章中，我们将尝试利用Java EE
    7中随着WebSocket带来的这些新、令人兴奋的功能，这得益于JSR 356 ([https://jcp.org/en/jsr/detail?id=356](https://jcp.org/en/jsr/detail?id=356))
    和HTML5。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: How WebSockets work
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket是如何工作的
- en: How to create a WebSocket endpoint in Java EE 7
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Java EE 7中创建WebSocket端点
- en: How to create an HTML5/AngularJS client that will accept push notifications
    from an application deployed on WildFly
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个HTML5/AngularJS客户端，该客户端将接受部署在WildFly上的应用程序的推送通知
- en: An overview of WebSockets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket概述
- en: A WebSocket session between the client and server is built upon a standard TCP
    connection. Although the WebSocket protocol has its own control frames (mainly
    to create and sustain the connection) coded by the Internet Engineering Task Force
    in the RFC 6455 ([http://tools.ietf.org/html/rfc6455](http://tools.ietf.org/html/rfc6455)),
    the peers are not obliged to use any specific format to exchange application data.
    You may use plaintext, XML, JSON, or anything else to transmit your data. As you
    probably remember, this is quite different from SOAP-based WebServices, which
    had bloated specifications of the exchange protocol. The same goes for RESTful
    architectures; we no longer have the predefined verb methods from HTTP (GET, PUT,
    POST, and DELETE), status codes, and the whole semantics of an HTTP request.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的WebSocket会话建立在标准的TCP连接之上。尽管WebSocket协议有自己的控制帧（主要用于创建和维持连接），这些控制帧由互联网工程任务组在RFC
    6455中编码（[http://tools.ietf.org/html/rfc6455](http://tools.ietf.org/html/rfc6455)），但对等方并不强制使用任何特定的格式来交换应用数据。你可以使用纯文本、XML、JSON或其他任何东西来传输你的数据。你可能还记得，这与基于SOAP的WebServices大不相同，后者有膨胀的交换协议规范。同样，这也适用于RESTful架构；我们不再有HTTP预定义的动词方法（GET、PUT、POST和DELETE）、状态码以及整个HTTP请求的语义。
- en: This liberty means that WebSockets are pretty low level compared to the technologies
    that we have used up to this point, but thanks to this, the communication overhead
    is minimal. The protocol is less verbose than SOAP or RESTful HTTP, which allows
    us to achieve higher performance. This, however, comes with a price. We usually
    like to use the features of higher-level protocols (such as horizontal scaling
    and rich URL semantics), and with WebSockets, we would need to write them by hand.
    For standard CRUD-like operations, it would be easier to use a REST endpoint than
    create everything from scratch.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自由意味着与到目前为止我们所使用的相比，WebSocket相当低级，但正因为如此，通信开销最小。该协议比SOAP或RESTful HTTP更简洁，这使我们能够实现更高的性能。然而，这也有代价。我们通常喜欢使用高级协议的功能（如水平扩展和丰富的URL语义），而使用WebSocket，我们需要手动编写它们。对于标准的CRUD-like操作，使用REST端点比从头开始创建一切要容易得多。
- en: What do we get from WebSockets compared to the standard HTTP communication?
    First of all, a direct connection between two peers. Normally, when you connect
    to a web server (which can, for instance, handle a REST endpoint), every subsequent
    call is a new TCP connection, and your machine is treated like it is a different
    one every time you make a request. You can, of course, simulate a stateful behavior
    (so that the server will recognize your machine between different requests) using
    cookies and increase the performance by reusing the same connection in a short
    period of time for a specific client, but basically, it is a workaround to overcome
    the limitations of the HTTP protocol.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准HTTP通信相比，我们从WebSocket获得了什么？首先，两个对等体之间的直接连接。通常，当你连接到Web服务器（例如，可以处理REST端点）时，每次后续调用都是一个新的TCP连接，你的机器每次请求时都被视为一个不同的机器。当然，你可以使用cookie模拟有状态的行为（这样服务器将在不同的请求之间识别你的机器），并通过在短时间内为特定客户端重用相同的连接来提高性能，但这基本上是一个解决HTTP协议限制的权宜之计。
- en: Once you establish a WebSocket connection between a server and client, you can
    use the same session (and underlying TCP connection) during the whole communication.
    Both sides are aware of it and can send data independently in a full-duplex manner
    (both sides can send and receive data simultaneously). Using plain HTTP, there
    is no way for the server to spontaneously start sending data to the client without
    any request from its side. What's more, the server is aware of all of its connected
    WebSocket clients, and can even send data between them!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在服务器和客户端之间建立WebSocket连接，你可以在整个通信过程中使用相同的会话（以及底层的TCP连接）。双方都清楚这一点，并且可以以全双工方式独立发送数据（双方可以同时发送和接收数据）。使用纯HTTP，服务器在没有来自其侧的任何请求的情况下，无法自发地向客户端发送数据。更重要的是，服务器知道所有连接的WebSocket客户端，甚至可以在它们之间发送数据！
- en: The current solution that includes trying to simulate real-time data delivery
    using HTTP protocol can put a lot of stress on the web server. Polling (asking
    the server about updates), long polling (delaying the completion of a request
    to the moment when an update is ready), and streaming (a Comet-based solution
    with a constantly open HTTP response) are all ways to hack the protocol to do
    things that it wasn't designed for and have their own limitations. Thanks to the
    elimination of unnecessary checks, WebSockets can heavily reduce the number of
    HTTP requests that have to be handled by the web server. The updates are delivered
    to the user with a smaller latency because we only need one round-trip through
    the network to get the desired information (it is pushed by the server immediately).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当前解决方案包括尝试使用HTTP协议模拟实时数据传输，这会给Web服务器带来很大压力。轮询（询问服务器更新）、长轮询（延迟请求完成直到更新准备好）和流（基于Comet的解决方案，具有始终打开的HTTP响应）都是通过黑客协议来实现它未设计的功能，并且各自都有局限性。由于消除了不必要的检查，WebSocket可以大幅减少Web服务器需要处理的HTTP请求数量。由于我们只需要通过网络进行一次往返即可获取所需信息（由服务器立即推送），因此更新以更小的延迟传递给用户。
- en: All of these features make WebSockets a great addition to the Java EE platform,
    which fills the gaps needed to easily finish specific tasks, such as sending updates,
    notifications, and orchestrating multiple client interactions. Despite these advantages,
    WebSockets are not intended to replace REST or SOAP WebServices. They do not scale
    so well horizontally (they are hard to distribute because of their stateful nature),
    and they lack most of the features that are utilized in web applications. URL
    semantics, complex security, compression, and many other features are still better
    realized using other technologies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性使WebSocket成为Java EE平台的一个很好的补充，它填补了完成特定任务所需的空白，例如发送更新、通知和编排多个客户端交互。尽管有这些优势，WebSocket并不打算取代REST或SOAP
    Web服务。它们在水平扩展方面表现不佳（由于它们的状态性，难以分发），并且缺乏大多数在Web应用程序中使用的功能。URL语义、复杂的安全、压缩以及许多其他功能仍然最好使用其他技术来实现。
- en: How do WebSockets work
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSockets是如何工作的
- en: 'To initiate a WebSocket session, the client must send an HTTP request with
    an `Upgrade: websocket` header field. This informs the server that the peer client
    has asked the server to switch to the WebSocket protocol.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '要启动WebSocket会话，客户端必须发送一个带有`Upgrade: websocket`头字段的HTTP请求。这通知服务器对等客户端已请求服务器切换到WebSocket协议。'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may notice that the same happens in WildFly for Remote EJBs; the initial
    connection is made using an HTTP request, and is later switched to the remote
    protocol thanks to the `Upgrade` mechanism. The standard `Upgrade` header field
    can be used to handle any protocol, other than HTTP, which is accepted by both
    sides (the client and server). In WildFly, this allows you to reuse the HTTP port
    (`80`/`8080`) for other protocols and therefore minimise the number of required
    ports that should be configured.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在WildFly的远程EJB中也会发生同样的事情；初始连接是通过HTTP请求建立的，后来通过`Upgrade`机制切换到远程协议。标准的`Upgrade`头字段可以用来处理任何协议，除了HTTP，这是客户端和服务器双方都接受的。在WildFly中，这允许你重用HTTP端口（`80`/`8080`）用于其他协议，从而最小化需要配置的端口号数量。
- en: 'If the server can "understand" the WebSocket protocol, the client and server
    then proceed with the handshaking phase. They negotiate the version of the protocol,
    exchange security keys, and if everything goes well, the peers can go to the data
    transfer phase. From now on, the communication is only done using the WebSocket
    protocol. It is not possible to exchange any HTTP frames using the current connection.
    The whole life cycle of a connection can be summarized in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器能够“理解”WebSocket协议，客户端和服务器随后将进入握手阶段。它们协商协议版本，交换安全密钥，如果一切顺利，对等方可以进入数据传输阶段。从现在开始，通信仅使用WebSocket协议进行。使用当前连接无法交换任何HTTP帧。整个连接的生命周期可以总结如下图所示：
- en: '![How do WebSockets work](img/00072.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![WebSockets是如何工作的](img/00072.jpeg)'
- en: 'A sample HTTP request from a JavaScript application to a WildFly server would
    look similar to this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个JavaScript应用程序向WildFly服务器发送的示例HTTP请求看起来可能如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that the client requests an upgrade connection with WebSocket as
    the target protocol on the URL `/ticket-agency-websockets/tickets`. It additionally
    passes information about the requested version and key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，客户端在`/ticket-agency-websockets/tickets` URL上请求一个升级连接，目标协议为WebSocket。它还传递了请求的版本和密钥信息。
- en: 'If the server supports the request protocol and all the required data is passed
    by the client, then it would respond with the following frame:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器支持请求协议并且客户端传递了所有必要的数据，那么它将响应以下帧：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The status code of the response is `101` (switching protocols) and we can see
    that the server is now going to start using the WebSocket protocol. The TCP connection
    initially used for the HTTP request is now the base of the WebSocket session and
    can be used for transmissions. If the client tries to access a URL, which is only
    handled by another protocol, then the server can ask the client to do an upgrade
    request. The server uses the `426` (upgrade required) status code in such cases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的状态码是`101`（切换协议），我们可以看到服务器现在将开始使用WebSocket协议。最初用于HTTP请求的TCP连接现在是WebSocket会话的基础，并可用于传输。如果客户端尝试访问仅由另一个协议处理的URL，则服务器可以要求客户端进行升级请求。在这种情况下，服务器使用`426`（需要升级）状态码。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The initial connection creation has some overhead (because of the HTTP frames
    that are exchanged between the peers), but after it is completed, new messages
    have only 2 bytes of additional headers. This means that when we have a large
    number of small messages, WebSocket will be an order of magnitude faster than
    REST protocols simply because there is less data to transmit!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 初始连接创建有一些开销（因为对等体之间交换的HTTP帧），但完成后，新消息只有2个字节的额外头部。这意味着当我们有大量的小消息时，WebSocket将比REST协议快一个数量级，仅仅是因为传输的数据更少！
- en: 'If you are wondering about the browser support of WebSockets, you can look
    it up at [http://caniuse.com/websockets](http://caniuse.com/websockets). All new
    versions of major browsers currently support WebSockets; the total coverage is
    estimated (at the time of writing) at 74 percent. You can see this in the following
    screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想浏览器的WebSocket支持情况，你可以在[http://caniuse.com/websockets](http://caniuse.com/websockets)上查找。目前所有主流浏览器的所有新版本都支持WebSocket；据估算（在撰写本文时），总覆盖率为74%。你可以在以下屏幕截图中看到这一点：
- en: '![How do WebSockets work](img/00073.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![WebSocket是如何工作的](img/00073.jpeg)'
- en: After this theoretical introduction, we are ready to jump into action. We can
    now create our first WebSocket endpoint!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个理论介绍之后，我们准备好采取行动。我们现在可以创建我们的第一个WebSocket端点！
- en: Creating our first endpoint
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个端点
- en: 'Let''s start with a simple example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Java EE 7 specification has taken into account developer friendliness, which
    can be clearly seen in the given example. In order to define your WebSocket endpoint,
    you just need a few annotations on a **Plain Old Java Object** (**POJO**). The
    first annotation `@ServerEndpoint("/hello")` defines a path to your endpoint.
    It''s a good time to discuss the endpoint''s full address. We placed this sample
    in the application named `ticket-agency-websockets`. During the deployment of
    application, you can spot information in the WildFly log about endpoints creation,
    as shown in the following command line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 7规范考虑了开发者的友好性，这在给定的示例中可以清楚地看到。为了定义你的WebSocket端点，你只需要在**普通Java对象**（**POJO**）上添加几个注解。第一个注解`@ServerEndpoint("/hello")`定义了端点的路径。现在是讨论端点完整地址的好时机。我们将这个示例放在名为`ticket-agency-websockets`的应用程序中。在部署应用程序时，你可以在WildFly日志中找到有关端点创建的信息，如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The full URL of the endpoint is `ws://localhost:8080/ticket-agency-websockets/hello`,
    which is just a concatenation of the server and application address with an endpoint
    path on an appropriate protocol.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 端点的完整URL是`ws://localhost:8080/ticket-agency-websockets/hello`，这仅仅是服务器和应用程序地址与适当协议上的端点路径的连接。
- en: 'The second used annotation `@OnOpen` defines the endpoint behavior when the
    connection from the client is opened. It''s not the only behavior-related annotation
    of the WebSocket endpoint. Let''s look to the following table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个使用的注解`@OnOpen`定义了客户端连接打开时端点的行为。这不是WebSocket端点唯一的行为相关注解。让我们看看以下表格：
- en: '| Annotation | Description |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 标注 | 描述 |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@OnOpen` | The connection is open. With this annotation, we can use the
    `Session` and `EndpointConfig` parameters. The first parameter represents the
    connection to the user and allows further communication. The second one provides
    some client-related information. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `@OnOpen` | 连接已打开。使用这个注解，我们可以使用 `Session` 和 `EndpointConfig` 参数。第一个参数代表与用户的连接，允许进一步的通信。第二个参数提供一些与客户端相关的信息。|'
- en: '| `@OnMessage` | This annotation is executed when a message from the client
    is being received. In such a method, you can just have `Session` and for example,
    the `String` parameter, where the `String` parameter represents the received message.
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `@OnMessage` | 当客户端的消息被接收时，这个注解会被执行。在这样的方法中，你只需要有 `Session` 和例如 `String`
    参数，其中 `String` 参数代表接收到的消息。|'
- en: '| `@OnError` | There are bad times when an error occurs. With this annotation,
    you can retrieve a `Throwable` object apart from standard `Session`. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `@OnError` | 当发生错误时，会有一些不好的时候。使用这个注解，你可以除了标准的 `Session` 之外检索一个 `Throwable`
    对象。|'
- en: '| `@OnClose` | When the connection is closed, it is possible to get some data
    concerning this event in the form of the `CloseReason` type object. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `@OnClose` | 当连接关闭时，可以以 `CloseReason` 类型对象的形式获取一些关于此事件的数据。|'
- en: There is one more interesting line in our `HelloEndpoint`. Using the `Session`
    object, it is possible to communicate with the client. This clearly shows that
    in WebSockets, two-directional communication is easily possible. In this example,
    we decided to respond to a connected user synchronously (`getBasicRemote()`) with
    just a text message *Hi!* (`sendText (String)`). Of course, it's also possible
    to communicate asynchronously and send, for example, sending binary messages using
    your own binary bandwidth saving protocol. We will present some of these processes
    in the next example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `HelloEndpoint` 中还有一条有趣的线。使用 `Session` 对象，我们可以与客户端进行通信。这清楚地表明，在 WebSocket
    中，双向通信是很容易实现的。在这个例子中，我们决定通过只发送一条文本消息 *Hi!* (`sendText (String)`) 来同步响应已连接的用户 (`getBasicRemote()`)。当然，也可以异步通信，例如，使用你自己的二进制带宽节省协议发送二进制消息。我们将在下一个示例中展示一些这些过程。
- en: Expanding our client application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展我们的客户端应用程序
- en: 'It''s time to show how you can leverage the WebSocket features in real life.
    In the previous chapter, [Chapter 7](part0038_split_000.html#page "Chapter 7. Adding
    Web Services to Your Applications"), *Adding Web Services to Your Applications*,
    we created the ticket booking application based on the REST API and AngularJS
    framework. It was clearly missing one important feature: the application did not
    show information concerning ticket purchases of other users. This is a perfect
    use case for WebSockets!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候展示你如何在现实生活中利用 WebSocket 的特性了。在前一章中，[第 7 章](part0038_split_000.html#page "第
    7 章。将 Web 服务添加到您的应用程序中")，*将 Web 服务添加到您的应用程序中*，我们基于 REST API 和 AngularJS 框架创建了票务预订应用程序。显然，它缺少一个重要的功能：应用程序没有显示有关其他用户票务购买的信息。这是一个完美的
    WebSocket 应用场景！
- en: Since we're just adding a feature to our previous app, we will only describe
    the changes we will introduce to it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只是在添加之前应用程序的一个功能，所以我们只描述我们将要引入到其中的更改。
- en: 'In this example, we would like to be able to inform all current users about
    other purchases. This means that we have to store information about active sessions.
    Let''s start with the registry type object, which will serve this purpose. We
    can use a `Singleton` session bean for this task, as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望能够通知所有当前用户关于其他购买的信息。这意味着我们必须存储有关活动会话的信息。让我们从注册类型对象开始，它将为此目的服务。我们可以使用一个
    `Singleton` 会话豆来完成这个任务，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We could use `Collections.synchronizedSet` from standard Java libraries but
    it's a great chance to remember what we described in [Chapter 3](part0023_split_000.html#page
    "Chapter 3. Introducing Java EE 7 – EJBs"), *Introducing Java EE 7 – EJBs*, about
    container-based concurrency. In `SessionRegistry`, we defined some basic methods
    to add, get, and remove sessions. For the sake of collection thread safety during
    retrieval, we return an unmodifiable view.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准 Java 库中的 `Collections.synchronizedSet`，但这是一个很好的机会来回忆我们在 [第 3 章](part0023_split_000.html#page
    "第 3 章。介绍 Java EE 7 – EJBs") 中描述的内容，*介绍 Java EE 7 – EJBs*，关于基于容器的并发。在 `SessionRegistry`
    中，我们定义了一些基本方法来添加、获取和删除会话。为了在检索期间保证集合的线程安全，我们返回一个不可修改的视图。
- en: 'We defined the registry, so now we can move to the endpoint definition. We
    will need a POJO, which will use our newly defined registry as shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了注册，现在我们可以转向端点定义。我们需要一个 POJO，它将使用我们新定义的注册，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our endpoint is defined in the `/tickets` address. We injected a `SessionRepository`
    to our endpoint. During `@OnOpen`, we add `Sessions` to the registry, and during
    `@OnClose`, we just remove them. Message sending is performed on the CDI event
    (the `@Observers` annotation), which is already fired in our code during `TheatreBox.buyTicket(int)`.
    In our `send` method, we retrieve all sessions from `SessionRepository`, and for
    each of them, we asynchronously send information about booked seats. We don't
    really need information about all the `Seat` fields to realize this feature. That's
    the reason why we don't use the automatic JSON serialization we know from the
    last chapter here. Instead, we decided to use a minimalistic `JSON` object, which
    provides only the required data. To do this, we used the new Java API for JSON
    Processing (JSR-353). Using a fluent-like API, we're able to create a `JSON` object
    and add two fields to it. Then, we just convert JSON to the string, which is sent
    in a text message.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定义端点在`/tickets`地址。我们向端点注入了`SessionRepository`。在`@OnOpen`期间，我们将`Sessions`添加到注册表中，在`@OnClose`期间，我们只需移除它们。消息发送是在CDI事件（`@Observers`注解）上执行的，该事件已经在我们的代码中通过`TheatreBox.buyTicket(int)`触发。在我们的`send`方法中，我们从`SessionRepository`检索所有会话，并对每个会话异步发送关于已预订座位的消息。我们并不真的需要所有`Seat`字段的信息来实现这个功能。这就是为什么我们在这里没有使用从上一章了解到的自动JSON序列化的原因。相反，我们决定使用一个简约的`JSON`对象，它只提供所需的数据。为此，我们使用了新的Java
    API for JSON Processing (JSR-353)。使用类似流畅的API，我们能够创建一个`JSON`对象并向其中添加两个字段。然后，我们只需将JSON转换为字符串，通过文本消息发送。
- en: Because in our example we send messages in response to a CDI event, we don't
    have (in the event handler) an out-of-the-box reference to any of the sessions.
    We have to use our `sessionRegistry` object to access the active ones. However,
    if we would like to do the same thing but, for example, in the `@OnMessage` method,
    then it is possible to get all active sessions just by executing the `session.getOpenSessions()`
    method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在我们的例子中，我们是在响应CDI事件时发送消息，所以在事件处理器中，我们没有对任何会话的现成引用。我们必须使用我们的`sessionRegistry`对象来访问活动会话。然而，如果我们想在例如`@OnMessage`方法中做同样的事情，那么只需执行`session.getOpenSessions()`方法就可以获取所有活动会话。
- en: 'These are all the changes required to perform on the backend side. Now, we
    have to modify our AngularJS frontend to leverage the added feature. The good
    news is that JavaScript already includes classes that can be used to perform WebSocket
    communication! There are a few lines of code we have to add inside the module
    defined in the `seat.js` file, which are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是在后端执行所需的所有更改。现在，我们必须修改我们的AngularJS前端以利用新增的功能。好消息是JavaScript已经包含了可以用来执行WebSocket通信的类！我们只需要在`seat.js`文件中定义的模块内添加几行代码，如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code is very simple. We just create the `WebSocket` object using the URL
    to our endpoint, and then we define the `onmessage` function in that object. During
    the function execution, the received message is automatically parsed from the
    JSON to JavaScript object. Then, in `$scope.$apply`, we just iterate through our
    seats, and if the ID matches, we update the booked state. We have to use `$scope.$apply`
    because we are touching an Angular object from outside the Angular world (the
    `onmessage` function). Modifications performed on `$scope.seats` are automatically
    visible on the website. With this, we can just open our ticket booking website
    in two browser sessions, and see that when one user buys a ticket, the second
    users sees almost instantly that the seat state is changed to *booked*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。我们只需使用端点的URL创建`WebSocket`对象，然后在该对象中定义`onmessage`函数。在函数执行期间，接收到的消息会自动从JSON解析为JavaScript对象。然后，在`$scope.$apply`中，我们只需遍历我们的座位，如果ID匹配，我们更新预订状态。我们必须使用`$scope.$apply`，因为我们正在从Angular世界之外（`onmessage`函数）触摸Angular对象。对`$scope.seats`进行的修改会自动在网站上可见。有了这个，我们只需在两个浏览器会话中打开我们的票务预订网站，就可以看到当一个用户购买票时，第二个用户几乎立即看到座位状态已更改为*已预订*。
- en: 'We can enhance our application a little to inform users if the WebSocket connection
    is really working. Let''s just define `onopen` and `onclose` functions for this
    purpose:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微增强我们的应用程序，以便在WebSocket连接真正工作的情况下通知用户。让我们只为这个目的定义`onopen`和`onclose`函数：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To inform users about a connection's state, we push different types of alerts.
    Of course, again we're touching the Angular world from the outside, so we have
    to perform all operations on Angular from the `$scope.$apply` function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知用户连接的状态，我们推送不同类型的警报。当然，我们再次从外部触及 Angular 世界，因此我们必须在 `$scope.$apply` 函数上执行所有操作。
- en: 'Running the described code results in the notification, which is visible in
    the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所描述的代码会导致通知，这在下面的屏幕截图中可见：
- en: '![Expanding our client application](img/00074.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![扩展我们的客户端应用程序](img/00074.jpeg)'
- en: 'However, if the server fails after opening the website, you might get an error
    as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果在打开网站后服务器失败，你可能会得到以下屏幕截图所示的错误：
- en: '![Expanding our client application](img/00075.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![扩展我们的客户端应用程序](img/00075.jpeg)'
- en: Transforming POJOs to JSON
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 POJO 转换为 JSON
- en: In our current example, we transformed our `Seat` object to JSON manually. Normally,
    we don't want to do it this way; there are many libraries that will do the transformation
    for us. One of them is GSON from Google. Additionally, we can register an `encoder/decoder`
    class for a WebSocket endpoint that will do the transformation automatically.
    Let's look at how we can refactor our current solution to use an encoder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的示例中，我们手动将 `Seat` 对象转换为 JSON。通常，我们不希望这样做；有许多库会为我们完成转换。其中之一是来自 Google 的
    GSON。此外，我们还可以为 WebSocket 端点注册一个 `encoder/decoder` 类，该类将自动执行转换。让我们看看我们如何重构当前的解决方案以使用编码器。
- en: 'First of all, we must add `GSON` to our classpath. The required Maven dependency
    is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须将 `GSON` 添加到我们的类路径中。所需的 Maven 依赖项如下：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to provide an implementation of the `javax.websocket.Encoder.Text`
    interface. There are also versions of the `javax.websocket.Encoder.Text` interface
    for binary and streamed data (for both binary and text formats). A corresponding
    hierarchy of interfaces is also available for decoders (`javax.websocket.Decoder`).
    Our implementation is rather simple. This is shown in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供一个 `javax.websocket.Encoder.Text` 接口的实现。也有 `javax.websocket.Encoder.Text`
    接口的二进制和流式数据版本（对于二进制和文本格式）。对于解码器（`javax.websocket.Decoder`）也有相应的接口层次结构。我们的实现相当简单。如下代码片段所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we create an instance of GSON in the `init` method; this action will
    be executed when the endpoint is created. Next, in the `encode` method, which
    is called every time, we send an object through an endpoint. We use JSON command
    to create JSON from an object. This is quite concise when we think how reusable
    this little class is. If you want more control on the JSON generation process,
    you can use the `GsonBuilder` class to configure the `Gson` object before creation.
    We have the encoder in place. Now it''s time to alter our endpoint:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 `init` 方法中创建 GSON 的实例；这个动作将在端点创建时执行。接下来，在每次调用的 `encode` 方法中，我们通过端点发送一个对象。我们使用
    JSON 命令从对象创建 JSON。当我们想到这个小程序的可重用性时，这相当简洁。如果你想在 JSON 生成过程中有更多控制，你可以在创建之前使用 `GsonBuilder`
    类来配置 `Gson` 对象。我们已经有了编码器。现在，是时候修改我们的端点了：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first change is done on the `@ServerEndpoint` annotation. We have to define
    a list of supported encoders; we simply pass our `JSONEncoder.class` wrapped in
    an array. Additionally, we have to pass the endpoint name using the `value` attribute.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改是在 `@ServerEndpoint` 注解上进行的。我们必须定义一个支持编码器的列表；我们只需将我们的 `JSONEncoder.class`
    包裹在数组中传递。此外，我们必须使用 `value` 属性传递端点名称。
- en: Earlier, we used the `sendText` method to pass a string containing a manually
    created JSON. Now, we want to send an object and let the encoder handle the JSON
    generation; therefore, we'll use the `getAsyncRemote().sendObject()` method. And
    that's all. Our endpoint is ready to be used. It will work the same as the earlier
    version, but now our objects will be fully serialized to JSON, so they will contain
    every field, not only `id` and `booked`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用 `sendText` 方法传递一个包含手动创建的 JSON 的字符串。现在，我们想要发送一个对象，并让编码器处理 JSON 生成；因此，我们将使用
    `getAsyncRemote().sendObject()` 方法。就这样。我们的端点已经准备好使用。它将像早期版本一样工作，但现在我们的对象将被完全序列化为
    JSON，因此它们将包含每个字段，而不仅仅是 `id` 和 `booked`。
- en: 'After deploying the server, you can connect to the WebSocket endpoint using
    one of the Chrome extensions, for instance, the `Dark WebSocket` terminal from
    the Chrome store (use the `ws://localhost:8080/ticket-agency-websockets/tickets`
    address). When you book tickets using the web application, the WebSocket terminal
    should show something similar to the output shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署服务器后，你可以使用Chrome扩展程序之一连接到WebSocket端点，例如，Chrome商店中的`Dark WebSocket`终端（使用`ws://localhost:8080/ticket-agency-websockets/tickets`地址）。当你使用Web应用程序预订票务时，WebSocket终端应该显示类似于以下截图所示的内容：
- en: '![Transforming POJOs to JSON](img/00076.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![将POJO转换为JSON](img/00076.jpeg)'
- en: Of course, it is possible to use different formats other than JSON. If you want
    to achieve better performance (when it comes to the serialization time and payload
    size), you may want to try out binary serializers such as **Kryo** ([https://github.com/EsotericSoftware/kryo](https://github.com/EsotericSoftware/kryo)).
    They may not be supported by JavaScript, but may come in handy if you would like
    to use WebSockets for other clients too. **Tyrus** ([https://tyrus.java.net/](https://tyrus.java.net/))
    is a reference implementation of the WebSocket standard for Java; you can use
    it in your standalone desktop applications. In that case, besides the encoder
    (which is used to send messages), you would also need to create a decoder, which
    can automatically transform incoming messages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了JSON之外，还可以使用其他格式。如果你想获得更好的性能（尤其是在序列化时间和负载大小方面），你可能想尝试二进制序列化器，例如**Kryo**
    ([https://github.com/EsotericSoftware/kryo](https://github.com/EsotericSoftware/kryo))。它们可能不被JavaScript支持，但如果你也想为其他客户端使用WebSocket，它们可能很有用。**Tyrus**
    ([https://tyrus.java.net/](https://tyrus.java.net/))是Java的WebSocket标准的参考实现；你可以在你的独立桌面应用程序中使用它。在这种情况下，除了用于发送消息的编码器之外，你还需要创建一个解码器，它可以自动转换传入的消息。
- en: An alternative to WebSockets
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket的替代方案
- en: The example we presented in this chapter is possible to be implemented using
    an older, lesser-known technology named **Server-Sent Events** (**SSE**). SSE
    allows for one-way communication from the server to client over HTTP. It is much
    simpler than WebSockets but has a built-in support for things such as automatic
    reconnection and event identifiers. WebSockets are definitely more powerful, but
    are not the only way to pass events, so when you need to implement some notifications
    from the server side, remember about SSE.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们提供的示例可以使用一个较老、不太知名的技术来实现，该技术名为**服务器发送事件**（**SSE**）。SSE允许通过HTTP从服务器到客户端进行单向通信。它比WebSocket简单得多，但内置了对自动重连和事件标识符等事物的支持。WebSocket确实更强大，但并非传递事件的唯一方式，所以当你需要从服务器端实现一些通知时，记得SSE。
- en: Another option is to explore the mechanisms oriented around the Comet techniques.
    Multiple implementations are available and most of them use different methods
    of transportation to achieve their goals. A comprehensive comparison is available
    at [http://cometdaily.com/maturity.html](http://cometdaily.com/maturity.html).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是探索围绕Comet技术的机制。有多种实现方式，其中大多数使用不同的传输方法来实现目标。一个全面的比较可以在[http://cometdaily.com/maturity.html](http://cometdaily.com/maturity.html)找到。
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we managed to introduce the new low-level type of communication.
    We presented how it works underneath and compares to SOAP and REST introduced
    in the previous chapter. We also discussed how the new approach changes the development
    of web applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功介绍了新的低级别通信类型。我们介绍了它是如何工作的，以及与上一章中介绍的SOAP和REST相比。我们还讨论了新的方法如何改变Web应用程序的开发。
- en: Our ticket booking application was further enhanced to show users the changing
    state of the seats using push-like notifications. The new additions required very
    little code changes in our existing project when we take into account how much
    we are able to achieve with them. The fluent integration of WebSockets from Java
    EE 7 with the AngularJS application is another great showcase of flexibility,
    which comes with the new version of the Java EE platform.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的票务预订应用程序得到了进一步增强，使用类似推送的通知向用户显示座位的变化状态。当我们考虑到我们能够用它们实现多少时，新的添加在现有项目中只需要很少的代码更改。Java
    EE 7中WebSocket的流畅集成与AngularJS应用程序是Java EE平台新版本带来的灵活性的另一个绝佳展示。
- en: In the next chapter, you will learn more about WildFly administration and management,
    so that we can explore more system-wide features of Java EE 7 in the following
    chapters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习更多关于WildFly管理和配置的知识，以便我们可以在接下来的章节中探索Java EE 7的更多系统级特性。
