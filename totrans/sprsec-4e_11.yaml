- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Fine-Grained Access Control
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精细粒度访问控制
- en: In this chapter, we will first examine two ways to implement fine-grained authorization—authorization
    that may affect portions of a page of the application. Next, we will look at Spring
    Security’s approach to securing the business tier through method annotation and
    the use of interface-based proxies to accomplish **Aspect-Oriented** **Programming**
    (**AOP**). Then, we will review an interesting capability of annotation-based
    security that allows for role-based filtering on collections of data. Lastly,
    we will look at how class-based proxies differ from interface-based proxies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先探讨两种实现细粒度授权的方法——可能影响应用程序页面部分的授权。接下来，我们将探讨 Spring Security 通过方法注解和使用基于接口的代理来实现业务层安全的方法。然后，我们将回顾基于注解的安全性的一个有趣功能，该功能允许对数据集合进行基于角色的过滤。最后，我们将探讨基于类的代理与基于接口的代理之间的区别。
- en: 'During this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring and experimenting with different methods of performing in-page authorization
    checks on content, given the security context of a user request
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和实验不同的方法，在用户请求的安全上下文中对内容执行页面级授权检查
- en: Performing configuration and code annotation to make caller preauthorization
    a key part of our application’s business-tier security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行配置和代码注解，使调用者预授权成为我们应用程序业务层安全的关键部分
- en: Several alternative approaches to implement method-level security, and reviewing
    the pros and cons of each type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现方法级安全性的几种替代方法，并审查每种类型的优缺点
- en: Implementing data-based filters on collections and arrays using method-level
    annotations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法级注解在集合和数组上实现基于数据的过滤器
- en: Implementing method-level security on our `Spring MVC` controllers to avoid
    configuring `requestMatchers()` methods and `<``intercept-url>` elements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `Spring MVC` 控制器上实现方法级安全以避免配置 `requestMatchers()` 方法和 `<intercept-url>`
    元素
- en: 'This chapter’s code in action link is here: [https://packt.link/Mxijd](https://packt.link/Mxijd).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例链接在此：[https://packt.link/Mxijd](https://packt.link/Mxijd)。
- en: Integrating Spring Expression Language (SpEL)
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 Spring 表达式语言 (SpEL)
- en: 'Spring Security leverages `requestMatchers()` method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 利用 `requestMatchers()` 方法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Spring Security provides an `o.s.s.access.expression.SecurityExpressionRoot`
    object that provides the methods and objects available for use, in order to make
    an access control decision. For example, one of the methods available to use is
    `hasRole` method, which accepts a string. This corresponds to the value of the
    access attribute (in the preceding code snippet). In fact, there are a number
    of other expressions available, as shown in the following table:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 提供了一个 `o.s.s.access.expression.SecurityExpressionRoot` 对象，该对象提供了可用于访问控制决策的方法和对象。例如，可用的方法之一是
    `hasRole` 方法，它接受一个字符串。这对应于访问属性（在先前的代码片段中）。实际上，还有许多其他表达式可用，如下表所示：
- en: '| **Expression** | **Description** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `hasRole`(`String role`)`hasAuthority`(`String role`) | Returns `true` if
    the current user has the specified authority. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `hasRole`(`String role`)`hasAuthority`(`String role`) | 如果当前用户具有指定的权限，则返回
    `true`。|'
- en: '| `hasAnyRole`(`String... role`) `hasAnyAuthority`(`String... authority`) |
    Returns `true` if the current user has any of the specified authorities. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `hasAnyRole`(`String... role`) `hasAnyAuthority`(`String... authority`) |
    返回 `true` 如果当前用户具有指定的任何权限。|'
- en: '| `authentication` | Obtains the current `Authentication` object from the `SecurityContext`
    interface returned by the `getContext()` method of the `SecurityContextHolder`
    class. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `authentication` | 从 `SecurityContextHolder` 类的 `getContext()` 方法返回的 `SecurityContext`
    接口获取当前的 `Authentication` 对象。|'
- en: '| `permitAll` | This request does not necessitate authorization and serves
    as a public endpoint. It’s essential to clarify that `Authentication` is never
    retrieved from the session in this scenario. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `permitAll` | 此请求不需要授权，并作为公共端点。重要的是要明确，在这种情况下，`Authentication` 永远不会从会话中检索。|'
- en: '| `denyAll` | Under no circumstances is the request permitted; it’s important
    to emphasize that `Authentication` is never retrieved from the session in this
    instance. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `denyAll` | 在任何情况下都不允许请求；重要的是要强调，在这种情况下，`Authentication` 永远不会从会话中检索。|'
- en: '| `isAnonymous()` | Returns `true` if the current principal is anonymous (is
    not authenticated). |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `isAnonymous()` | 如果当前主体是匿名（未认证），则返回 `true`。|'
- en: '| `isRememberMe()` | Returns `true` if the current principal was authenticated
    using the remember-me feature. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `isRememberMe()` | 如果当前主体是通过记住我功能进行认证的，则返回`true`。 |'
- en: '| `isAuthenticated()` | Returns `true` if the user is not an anonymous user
    (that is, they are authenticated). |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `isAuthenticated()` | 如果用户不是匿名用户（即，他们已认证），则返回`true`。 |'
- en: '| `isFullyAuthenticated()` | Returns `true` if the user is authenticated through
    a means other than **remember-me**. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `isFullyAuthenticated()` | 如果用户是通过除“记住我”之外的方式认证的，则返回`true`。 |'
- en: '| `hasPermission`(`Object target`, `Object permission`) | Returns `true` if
    the user has permission to access the specified object for the given permission.
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `hasPermission`(Object target, Object permission) | 如果用户具有访问指定对象的给定权限，则返回`true`。
    |'
- en: '| `hasPermission`(`String targetId`, `String targetType`, `Object permission`)
    | Returns `true` if the user has permission to access the specified identifier
    for a given type and permission. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `hasPermission`(String targetId, String targetType, Object permission) |
    如果用户具有访问给定类型和权限的指定标识符的权限，则返回`true`。 |'
- en: Table 11.1 – Summary of the authorization rules
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 – 授权规则摘要
- en: 'We have provided some examples of using these SpEL expressions in the following
    code snippet. Keep in mind that we will go into more detail throughout this and
    the next chapter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下面的代码片段中提供了一些使用这些SpEL表达式的示例。请注意，我们将在本章和下一章中详细介绍：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Go ahead and start up the JBCP calendar application. Visit `https://localhost:8443`
    and log in with the user `user1@example.com` and the password `user1`. You will
    observe that the **My Events** navigation menu item is displayed, and the **All
    Events** navigation menu item is displayed as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 开始启动JBCP日历应用程序。访问`https://localhost:8443`，使用用户`user1@example.com`和密码`user1`进行登录。您将观察到“我的事件”导航菜单项被显示，同样“所有事件”导航菜单项也被显示。
- en: Important note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter11.00-calendar`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter11.00-calendar`的代码开始。
- en: The WebSecurityExpressionRoot class
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSecurityExpressionRoot类
- en: 'The `o.s.s.web.access.expression.WebSecurityExpressionRoot` class makes a few
    additional properties available to us. These properties, along with the standard
    properties already mentioned, are made available in the access attribute of the
    `requestMatchers()` method and in the `JSP/Thymeleaf access` attribute of the
    `<sec:authorize>` tag, as we will discuss shortly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.s.web.access.expression.WebSecurityExpressionRoot`类为我们提供了一些额外的属性。这些属性，连同之前提到的标准属性，都可在`requestMatchers()`方法的访问属性和`<sec:authorize>`标签的`JSP/Thymeleaf访问`属性中使用，正如我们很快将要讨论的：'
- en: '| **Expression** | **Description** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `request` | The current `HttpServletRequest` method. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `request` | 当前的`HttpServletRequest`方法。 |'
- en: '| `hasIpAddress`(`String... ipAddress`) | Returns `true` if the current IP
    address matches the `ipAddress` value. This can be an exact IP address or the
    IP address/network mask. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `hasIpAddress`(String... ipAddress) | 如果当前IP地址与`ipAddress`值匹配，则返回`true`。这可以是精确的IP地址或IP地址/网络掩码。
    |'
- en: Table 11.2 – hasIpAddress usage with WebSecurityExpressionRoot
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 – 使用WebSecurityExpressionRoot的hasIpAddress用法
- en: The MethodSecurityExpressionRoot class
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MethodSecurityExpressionRoot类
- en: 'Method SpEL expressions also provide a few additional properties that can be
    used through the `o.s.s.access.expression.method.MethodSecurityExpressionRoot`
    class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 方法SpEL表达式也提供了一些额外的属性，可以通过`o.s.s.access.expression.method.MethodSecurityExpressionRoot`类使用：
- en: '| **Expression** | **Description** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `target` | Refers to this or the current object being secured. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 指的是这个或当前被保护的对象。 |'
- en: '| `returnObject` | Refers to the object returned by the annotated method. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `returnObject` | 指的是由注解方法返回的对象。 |'
- en: '| `filterObject` | Can be used on a collection or array in conjunction with
    `@PreFilter` or `@PostFilter`, to only include the elements that match the expression.
    The `filterObject` object represents the loop variable of the collection or array.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `filterObject` | 可以与`@PreFilter`或`@PostFilter`一起用于集合或数组，以仅包括匹配表达式的元素。`filterObject`对象代表集合或数组的循环变量。
    |'
- en: '| `#<``methodArg>` | Any argument to a method can be referenced by prefixing
    the argument name with `#`. For example, a method argument named `id` can be referred
    to using `#id`. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `#<methodArg>` | 可以通过在参数名称前加`#`来引用方法的一个参数。例如，名为`id`的方法参数可以使用`#id`来引用。 |'
- en: Table 11.3 – MethodSecurityExpressionRoot properties
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.3 – MethodSecurityExpressionRoot属性
- en: If the description of these expressions appears a bit brief, don’t worry; we’ll
    work through a number of examples later in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些表达式的描述看起来有点简短，请不要担心；我们将在本章后面通过一些示例来详细讲解。
- en: 'We hope that you have a decent grasp of the power of Spring Security’s SpEL
    support. To learn more about SpEL, refer to the Spring reference documentation
    at: [https://docs.spring.io/spring-framework/reference/core/expressions.xhtml](https://docs.spring.io/spring-framework/reference/core/expressions.xhtml).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您已经对Spring Security的SpEL支持能力有了相当的了解。要了解更多关于SpEL的信息，请参阅Spring参考文档：[https://docs.spring.io/spring-framework/reference/core/expressions.xhtml](https://docs.spring.io/spring-framework/reference/core/expressions.xhtml)。
- en: Page-level authorization
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面级授权
- en: '**Page-level authorization** refers to the availability of application features
    based on the context of a particular user’s request. Unlike coarse-grained authorization
    that we explored in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting
    Started with Spring Security*, fine-grained authorization typically refers to
    the selective availability of the portions of a page, rather than restricting
    access to a page entirely. Most real-world applications will spend a considerable
    amount of time on the details of fine-grained authorization planning.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面级授权**指的是根据特定用户请求的上下文来提供应用程序功能。与我们在[*第2章*](B21757_02.xhtml#_idTextAnchor043)“Spring
    Security入门”中探讨的粗粒度授权不同，细粒度授权通常指的是页面部分的选择性可用性，而不是完全限制对页面的访问。大多数实际应用都会在细粒度授权规划细节上花费相当多的时间。'
- en: 'Spring Security provides us with the following three methods of selective display
    functionality:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security为我们提供了以下三种选择性显示功能的方法：
- en: '**Spring Security JSP** tag libraries allow conditional access declarations
    to be placed within a page declaration itself, using the standard JSP tag library
    syntax.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Security JSP** 标签库允许在页面声明本身内放置条件访问声明，使用标准的JSP标签库语法。'
- en: '**Thymeleaf Spring Security** tag libraries allow conditional access declarations
    to be placed within a page declaration itself, using the standard Thymeleaf tag
    library syntax.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Thymeleaf Spring Security** 标签库允许在页面声明本身内放置条件访问声明，使用标准的Thymeleaf标签库语法。'
- en: Checking user authorization in an MVC application’s controller layer allows
    the controller to make an access decision and bind the results of the decision
    to the model data provided to the view. This approach relies on standard JSTL
    conditional page rendering and data binding and is slightly more complicated than
    Spring Security tag libraries; however, it is more in line with the standard web
    application MVC logical design.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MVC应用程序的控制器层检查用户授权允许控制器做出访问决策并将决策结果绑定到提供给视图的模型数据。这种方法依赖于标准的JSTL条件页面渲染和数据绑定，比Spring
    Security标签库稍微复杂一些；然而，它更符合标准Web应用程序MVC逻辑设计。
- en: Any of these approaches are perfectly valid when developing fine-grained authorization
    models for a web application. Let’s explore how each approach is implemented through
    a JBCP calendar use case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Web应用程序开发细粒度授权模型时，这些方法中的任何一种都是完全有效的。让我们通过一个JBCP日历用例来探讨每种方法是如何实现的。
- en: Conditional rendering with the Thymeleaf Spring Security tag library
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Thymeleaf Spring Security标签库进行条件渲染
- en: The most common functionality used in the Thymeleaf Spring Security tag library
    is to conditionally render portions of the page based on authorization rules.
    This is done with the `<sec:authorize*>` tag that functions similarly to the `<if>`
    tag in the core JSTL library, in that the tag’s body will render depending on
    the conditions provided in the tag attributes. We have already seen a very brief
    demonstration of how the Spring Security tag library can be used to restrict the
    viewing of content if the user is not logged in.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Thymeleaf Spring Security标签库中最常用的功能是基于授权规则条件性地渲染页面部分。这是通过使用`<sec:authorize*>`标签来实现的，该标签的功能类似于核心JSTL库中的`<if>`标签，即标签体将根据标签属性中提供的条件进行渲染。我们已经看到了Spring
    Security标签库如何被用来限制未登录用户的查看内容的简要演示。
- en: Conditional rendering based on URL access rules
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于URL访问规则的条件渲染
- en: The Spring Security tag library provides functionality to render content based
    on the existing URL authorization rules that are already defined in the security
    configuration file. This is done via the use of the `authorizeHttpRequests()`
    method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security标签库提供了基于已在安全配置文件中定义的现有URL授权规则渲染内容的功能。这是通过使用`authorizeHttpRequests()`方法来实现的。
- en: If there are multiple HTTP elements, the `authorizeHttpRequests()` method uses
    the currently matched HTTP element’s rules.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个HTTP元素，`authorizeHttpRequests()`方法将使用当前匹配的HTTP元素的规则。
- en: 'For example, we could ensure that the `All` `Events` navigation menu item is
    displayed only when appropriate, that is, for users who are administrators—recall
    that the access rules we’ve previously defined are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以确保`All Events`导航菜单项仅在适当的情况下显示，即对于管理员用户——回想一下我们之前定义的访问规则如下：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Update the `header.xhtml` file to utilize this information and conditionally
    render the link to the `All` `Events` page:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`header.xhtml`文件以利用此信息并条件渲染到`All Events`页面链接：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will ensure that the content of the tag is not displayed unless the user
    has sufficient privileges to access the stated URL. It is possible to further
    qualify the authorization check using the `HTTP` method, by including the method
    attribute before the URL, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保除非用户有足够的权限访问指定的URL，否则标签的内容不会显示。可以通过在URL之前包含方法属性来进一步限定授权检查，如下所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the `authorize-url` attribute to define authorization checks on blocks
    of code is convenient because it abstracts the knowledge of the actual authorization
    checks from your pages and keeps it in your security configuration file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`authorize-url`属性在代码块上定义授权检查是方便的，因为它将实际授权检查的知识从你的页面中抽象出来，并将其保留在安全配置文件中。
- en: Be aware that the `HTTP` method should match the case specified in your security
    `requestMatchers()` method, otherwise they may not match as you expect. Also,
    note that the URL should always be relative to the web application context root
    (as your URL access rules are).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`HTTP`方法应该与你的安全`requestMatchers()`方法中指定的案例匹配，否则它们可能不会如你所期望地匹配。此外，请注意，URL应始终相对于Web应用程序上下文根（正如你的URL访问规则一样）。
- en: For many purposes, the use of the `<sec>` tag’s `authorize-url` attribute will
    suffice to correctly display link- or action-related content only when the user
    is allowed to see it. Remember that the tag need not only surround a link; it
    could even surround a whole form if the user doesn’t have permission to submit
    it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多用途，使用`<sec>`标签的`authorize-url`属性足以在用户被允许查看时正确显示与链接或操作相关的内容。记住，标签不仅需要围绕一个链接；如果用户没有提交权限，它甚至可以围绕整个表单。
- en: Conditional rendering using SpEL
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SpEL进行条件渲染
- en: 'An additional, more flexible method of controlling the display of JSP content
    is available when the `<sec>` tag is used in conjunction with a SpEL expression.
    Let’s review what we learned in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. We could hide the `My Events` link from
    any unauthenticated users by changing our `header.xhtml` file, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`<sec>`标签与SpEL表达式结合时，还有一个更灵活的方法来控制JSP内容的显示。让我们回顾一下我们在[*第2章*](B21757_02.xhtml#_idTextAnchor043)中学到的内容，“Spring
    Security入门”。我们可以通过更改`header.xhtml`文件来隐藏`My Events`链接，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The SpEL evaluation is performed by the same code behind the scenes as the expressions
    utilized in the `requestMatchers()` method access declaration rules (assuming
    the expressions have been configured). Hence, the same set of built-in functions
    and properties are accessible from the expressions built using the `<``sec>` tag.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL评估是由与`requestMatchers()`方法访问声明规则中使用的表达式背后的相同代码执行的（假设表达式已经配置）。因此，从使用`<sec>`标签构建的表达式中可以访问相同的内置函数和属性。
- en: Both of these methods of utilizing the `<sec>` tag provide powerful, fine-grained
    control over the display of page content based on security authorization rules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种利用`<sec>`标签的方法都提供了基于安全授权规则的强大、细粒度控制，以显示页面内容。
- en: Go ahead and start up the JBCP calendar application. Visit `https://localhost:8443`
    and log in with the user `user1@example.com` and the password `user1`. You will
    observe that the `admin1@example.com` with the password `admin1`. Now both links
    are visible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 继续启动JBCP日历应用程序。访问`https://localhost:8443`并使用用户`user1@example.com`和密码`user1`登录。你会观察到`admin1@example.com`用户名和密码`admin1`。现在两个链接都是可见的。
- en: Important note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter11.01-calendar`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter11.01-calendar`中的代码开始。
- en: Using controller logic to conditionally render content
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用控制器逻辑进行条件渲染内容
- en: In this section, we will demonstrate how we can use Java-based code to determine
    if we should render some content. We can choose to only show the `user`. This
    will hide the **Create Event** link on the **Welcome** page from users who are
    not logged in as administrators.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用基于Java的代码来确定是否应该渲染某些内容。我们可以选择只显示`user`。这将隐藏**欢迎**页面上未登录为管理员的用户的**创建事件**链接。
- en: 'The welcome controller from the sample code for this chapter has been updated
    to populate the model with an attribute named `showCreateLink`, derived from the
    method name, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例代码中的欢迎控制器已被更新，以将一个名为`showCreateLink`的属性填充到模型中，该属性来源于方法名，如下所示：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may notice that Spring MVC can automatically obtain the `Authentication`
    object for us. This is because Spring Security maps our current `Authentication`
    object to the `HttpServletRequest.getPrincipal()` method. Since Spring MVC will
    automatically resolve any object of the `java.security.Principal` type to the
    value of `HttpServletRequest.getPrincipal()`, specifying `Authentication` as an
    argument to our controller is an easy way to access the current `Authentication`
    object. We could also decouple the code from Spring Security by specifying an
    argument of the `Principal` type instead. However, we chose `Authentication` in
    this scenario to help demonstrate how everything connects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到Spring MVC可以自动为我们获取`Authentication`对象。这是因为Spring Security将我们的当前`Authentication`对象映射到`HttpServletRequest.getPrincipal()`方法。由于Spring
    MVC会自动将任何`java.security.Principal`类型的对象解析为`HttpServletRequest.getPrincipal()`的值，因此将`Authentication`作为我们控制器的参数是一种访问当前`Authentication`对象的简单方法。我们也可以通过指定`Principal`类型的参数来解耦代码与Spring
    Security。然而，在这个场景中，我们选择了`Authentication`来帮助展示一切是如何连接起来的。
- en: If we were working in another framework that did not know how to do this, we
    could obtain the `Authentication` object using the `SecurityContextHolder` class,
    as we did in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*.
    Also note that if we were not using Spring MVC, we could just set the `HttpServletRequest`
    attribute directly rather than populating it on the model. The attribute that
    we populated on the request would then be available to our JSP, just as it is
    when using a `ModelAndView` object with Spring MVC.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在另一个不知道如何做到这一点的框架中工作，我们可以使用`SecurityContextHolder`类来获取`Authentication`对象，就像我们在[*第3章*](B21757_03.xhtml#_idTextAnchor068)中做的那样，*自定义认证*。此外，请注意，如果我们不使用Spring
    MVC，我们只需直接设置`HttpServletRequest`属性，而不是在模型中填充它。我们填充在请求上的属性将像使用带有Spring MVC的`ModelAndView`对象时一样，对我们的JSP可用。
- en: 'Next, we will need to use the `HttpServletRequest` attribute in our `index.xhtml`
    file to determine if we should display the `Create Event` link. Update `index.xhtml`,
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`index.xhtml`文件中使用`HttpServletRequest`属性来确定是否应该显示`创建事件`链接。按照以下方式更新`index.xhtml`：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, start the application, log in using `admin1@example.com` as the username
    and `admin1` as the password, and visit the **All Events** page. You should no
    longer see the **Create Events** navigation menu item (although it will still
    be present on the page).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动应用程序，使用`admin1@example.com`作为用户名和`admin1`作为密码登录，并访问**所有活动**页面。你将不再看到**创建活动**导航菜单项（尽管它仍然会出现在页面上）。
- en: Important note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter11.02-calendar`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter11.02-calendar`的代码开始。
- en: The WebInvocationPrivilegeEvaluator class
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`WebInvocationPrivilegeEvaluator`类'
- en: There may be times when an application will not be written using JSPs and will
    need to be able to determine access based upon a URL, as we did with `<... sec:authorize-
    url="/events/">`. This can be done by using the `o.s.s.web.access.WebInvocationPrivilegeEvaluator`
    interface, which is the same interface that backs the JSP tag library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，应用程序可能不会使用JSP编写，并且需要能够根据URL确定访问权限，就像我们使用`<... sec:authorize-url="/events/">`时做的那样。这可以通过使用`o.s.s.web.access.WebInvocationPrivilegeEvaluator`接口来完成，这是支持JSP标签库的相同接口。
- en: 'In the following code snippet, we demonstrate the use of `WebInvocationPrivilegeEvaluator`
    by populating our model with an attribute named `showAdminLink`. We are able to
    obtain `WebInvocationPrivilegeEvaluator` using the `@``Autowired` annotation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们通过在模型中添加一个名为`showAdminLink`的属性来展示如何使用`WebInvocationPrivilegeEvaluator`。我们能够通过使用`@Autowired`注解来获取`WebInvocationPrivilegeEvaluator`：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the framework you are using is not being managed by Spring, `@Autowire`
    will not be able to provide you with `WebInvocationPrivilegeEvaluator`. Instead,
    you can use Spring’s `org.springframework.web.context.WebApplicationContextUtils`
    interface to obtain an instance of `WebInvocationPrivilegeEvaluator`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的框架不是由Spring管理的，`@Autowire` 将无法为你提供 `WebInvocationPrivilegeEvaluator`。相反，你可以使用Spring的
    `org.springframework.web.context.WebApplicationContextUtils` 接口来获取 `WebInvocationPrivilegeEvaluator`
    的实例，如下所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To try it out, go ahead and update `index.xhtml` to use the `showAdminLink`
    request attribute, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试一下，请更新 `index.xhtml` 以使用 `showAdminLink` 请求属性，如下所示：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Restart the application and view the `admin1@example.com`/`admin1`, and you
    should see it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序并查看 `admin1@example.com`/`admin1`，你应该能看到它。
- en: Important note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter11.03-calendar`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从 `chapter11.03-calendar` 的代码开始。
- en: What is the best way to configure in-page authorization?
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳的页面内授权配置方式是什么？
- en: 'In many cases, the use of the `authorize-url` attribute of the tag can appropriately
    isolate the code from changes in authorization rules. You should use the `authorize-url`
    attribute of the tag in the following scenarios:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用标签的 `authorize-url` 属性可以适当地将代码与授权规则的变化隔离开来。以下是在以下场景下应使用标签的 `authorize-url`
    属性：
- en: The tag is preventing display functionality that can be clearly identified by
    a single URL
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该标签阻止了可以通过单个URL清晰识别的显示功能。
- en: The contents of the tag can be unambiguously isolated to a single URL
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签的内容可以明确地隔离到单个URL。
- en: Unfortunately, in a typical application, the likelihood that you will be able
    to use the `authorize-url` attribute of the tag frequently is somewhat low. The
    reality is that applications are usually much more complex than this and require
    more involved logic when deciding to render portions of a page.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，在典型的应用程序中，你频繁使用标签的 `authorize-url` 属性的可能性相对较低。现实是，应用程序通常比这更复杂，在决定渲染页面的一部分时需要更复杂的逻辑。
- en: 'It’s tempting to use the Thymeleaf Spring Security tag library to declare bits
    of rendered pages as off-limits based on security criteria in other methods. However,
    there are a number of reasons why (in many cases) this isn’t a great idea, as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Thymeleaf Spring Security标签库根据其他方法中的安全标准声明渲染页面的部分为受限内容，这很有诱惑力。然而，有多个原因（在许多情况下）这并不是一个好主意，如下所述：
- en: Complex conditions beyond role membership are not supported by the tag library.
    For example, if our application incorporated customized attributes on the `UserDetails`
    implementation, IP filters, geolocation, and so on, none of these would be supported
    by the standard `<``sec>` tag.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签库不支持超出角色成员资格的复杂条件。例如，如果我们的应用程序在 `UserDetails` 实现中包含了自定义属性、IP过滤器、地理位置等，标准 `<sec>`
    标签将不支持这些。
- en: These could, however, conceivably be supported by the custom tags or using SpEL
    expressions. Even in this case, the page is more likely to be directly tied to
    business logic rather than what is typically encouraged.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，这些可能可以通过自定义标签或使用SpEL表达式来支持。即使在这种情况下，页面更有可能直接与业务逻辑相关，而不是通常鼓励的方式。
- en: The `<sec>` tag must be referenced on every page that it’s used in. This leads
    to potential inconsistencies between the rulesets that are intended to be common,
    but may be spread across different physical pages. A good object-oriented system
    design would suggest that conditional rule evaluations be located in only one
    place, and logically referred to from where they should be applied.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sec>` 标签必须在它被使用的每一页上引用。这可能导致旨在通用的规则集在不同物理页面上出现潜在的不一致性。一个良好的面向对象系统设计会建议条件规则评估只位于一个地方，并且从它们应该应用的地方进行逻辑引用。'
- en: It is possible (and we illustrate this using our common header page) to encapsulate
    and reuse portions of pages to reduce the occurrence of this type of problem,
    but it is virtually impossible to eliminate in a complex application.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能（我们使用我们的公共页眉页面来说明这一点）封装和重用页面的一部分以减少此类问题的发生，但在复杂的应用程序中几乎不可能消除。
- en: There is no way to validate the correctness of rules stated at compile time.
    Whereas compile-time constants can be used in typical Java-based, object- oriented
    systems, the tag library requires (in typical use) hardcoded role names where
    a simple typo might go undetected for some time.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时验证规则的正确性是没有办法的。虽然编译时常量可以在典型的基于Java的面向对象系统中使用，但标签库（在典型使用中）需要硬编码的角色名称，而简单的打字错误可能一段时间内不会被察觉。
- en: To be fair, such typos could be caught easily by comprehensive functional tests
    on the running application, but they are far easier to test using a standard Java
    component unit testing techniques.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公平地说，这样的错误可以通过对运行中的应用程序进行全面的函数测试来轻松捕捉，但使用标准的 Java 组件单元测试技术进行测试要容易得多。
- en: We can see that, although the *template-based approach* for conditional content
    rendering is convenient, there are some significant downsides.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到，尽管基于模板的方法进行条件内容渲染很方便，但也有一些显著的缺点。
- en: All of these issues can be solved by the use of code in controllers that can
    be used to push data into the application view model. Additionally, performing
    advanced authorization determinations in code allows for the benefits of reuse,
    compile-time checks, and proper logical separation of the model, view, and controller.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都可以通过在控制器中使用代码来解决，这些代码可以用来将数据推送到应用程序视图模型。此外，在代码中执行高级授权判断可以带来复用、编译时检查以及模型、视图和控制器适当逻辑分离的好处。
- en: Method-level security
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法级安全
- en: Our primary focus up to this point in the book has been on securing the web-facing
    portion of the JBCP calendar application; however, in real-world planning of secured
    systems, equal attention should be paid to securing the service methods that allow
    users access to the most critical part of any system—its data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书的主要重点是保护 JBCP 日历应用程序的 Web 面向部分；然而，在实际规划安全系统时，我们应同样关注保护允许用户访问任何系统最关键部分——其数据的服务方法。
- en: Why we secure in layers?
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么我们要分层进行安全防护？
- en: Let’s take a minute to see why it is important to secure our methods, even though
    we have already secured our URLs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间看看为什么即使我们已经保护了我们的 URL，保护我们的方法仍然很重要。
- en: Start the JBCP calendar application up. Log in using `user1@example.com` as
    the username and `user1` as the password.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 JBCP 日历应用程序。使用 `user1@example.com` 作为用户名和 `user1` 作为密码进行登录。
- en: Visit the `https://localhost:8443/events/`. You will see the custom **Access**
    **Denied** page.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `https://localhost:8443/events/`。您将看到自定义的**访问被拒绝**页面。
- en: Now, add `backdoor` to the end of the URL in the browser so that the URL is
    now `https://localhost:8443/events/backdoor`. You will now see a response with
    the same data as the **All Events** page. This data should only be visible to
    an administrator, but we have bypassed it by finding a URL that was not configured
    properly.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中的 URL 末尾添加 `backdoor`，这样 URL 现在是 `https://localhost:8443/events/backdoor`。您现在将看到一个与**所有活动**页面相同数据的响应。这些数据只应该对管理员可见，但我们通过找到一个未正确配置的
    URL 而绕过了它。
- en: 'We can also view the details of an event that we do not own and are not invited
    to. Change `backdoor` with `102` so that the URL is now `https://localhost:8443/events/102`:
    You will now see an **Vacation Event** that is not listed on your **My Events**
    page. This should not be visible to us because we are not an administrator, and
    this is not our event.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以查看我们未拥有且未被邀请参加的活动详情。将 `backdoor` 替换为 `102`，这样 URL 现在是 `https://localhost:8443/events/102`：您现在将看到一个未列在您的**我的活动**页面上的**休假活动**。这不应该对我们可见，因为我们不是管理员，这不是我们的活动。
- en: As you can see, our URL rules are not quite strong enough to entirely secure
    our application. These exploits do not even need to take advantage of more complex
    problems, such as differences in how containers handle URL normalization. In short,
    there are often ways to bypass URL-based security. Let’s see how adding a security
    layer to our business tier can help with our new security vulnerability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 URL 规则并不足以完全保护我们的应用程序。这些漏洞甚至不需要利用更复杂的问题，例如容器处理 URL 规范化的差异。简而言之，通常有绕过基于
    URL 的安全性的方法。让我们看看在业务层添加安全层如何帮助我们解决新的安全漏洞。
- en: Securing the business tier
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护业务层
- en: Spring Security has the ability to add a layer of authorization (or authorization-based
    data pruning) to the invocation of any Spring-managed bean in your application.
    While many developers focus on web-tier security, business-tier security is arguably
    just as important, as a malicious user may be able to penetrate the security of
    your web tier or access services exposed through a non-UI frontend, such as a
    web service.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 有能力为应用程序中任何 Spring 管理的 bean 的调用添加一层授权（或基于授权的数据修剪）。虽然许多开发者关注
    Web 层安全，但业务层安全同样重要，因为恶意用户可能能够渗透您的 Web 层安全或通过非 UI 前端（如 Web 服务）访问公开的服务。
- en: 'Let’s examine the following logical diagram to see why we’re interested in
    applying a secondary layer of security:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下逻辑图，看看为什么我们对应用二级安全层感兴趣：
- en: '![Figure 11.1 – Logical application Layers](img/B21757_11_1.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 逻辑应用层](img/B21757_11_1.jpg)'
- en: Figure 11.1 – Logical application Layers
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 逻辑应用层
- en: 'Spring Security has the following two main techniques for securing methods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security有以下两种主要技术用于保护方法：
- en: '`GrantedAuthority`, such as `ROLE_ADMIN`. Failure to satisfy the declared constraints
    means that the method call will fail.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GrantedAuthority`，例如`ROLE_ADMIN`。未能满足声明的约束意味着方法调用将失败。'
- en: '**Postauthorization**: This technique ensures that the calling principal still
    satisfies declared constraints after the method returns. This is rarely used but
    can provide an extra layer of security around some complex, interconnected business
    tier methods.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后授权**：这项技术确保在方法返回后调用者仍然满足声明的约束。这很少使用，但可以为一些复杂且相互关联的业务层方法提供额外的安全层。'
- en: The preauthorization and postauthorization techniques provide formalized support
    for what are generally called preconditions and postconditions in a classic, object-oriented
    design. Preconditions and postconditions allow a developer to declare through
    runtime checks that certain constraints around a method’s execution must always
    hold true. In the case of security preauthorization and postauthorization, the
    business tier developer makes a conscious decision about the security profile
    of particular methods by encoding expected runtime conditions as part of an interface
    or class API declaration. As you may imagine, this requires a great deal of forethought
    to avoid unintended consequences!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 预授权和后授权技术为通常在经典面向对象设计中称为预条件和后条件的概念提供了正式支持。预条件和后条件允许开发者通过运行时检查声明，方法执行周围的一定约束必须始终为真。在安全预授权和后授权的情况下，业务层开发者通过将预期的运行时条件作为接口或类API声明的一部分来编码，有意识地决定特定方法的网络安全配置。正如你可能想象的那样，这需要大量的前瞻性思考，以避免意外的后果！
- en: Adding the @PreAuthorize method annotation
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加@PreAuthorize方法注解
- en: 'Our first design decision will be to augment method security at the business
    tier by ensuring that a user must be logged in as an `ADMIN` user before he/she
    is allowed to access the `getEvents()` method. This is done with a simple annotation
    added to the method in the service interface definition, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项设计决策将是通过确保用户在允许访问`getEvents()`方法之前必须以`ADMIN`用户身份登录，来增强业务层的方法安全性。这是通过在服务接口定义中添加到方法的简单注解来实现的，如下所示：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is all that is required to ensure that anyone invoking our `getEvents()`
    method is an administrator. Spring Security will use a runtime AOP pointcut to
    execute `BeforeAdvice` on the method, and throw `o.s.s.access.AccessDeniedException`
    if the security constraints aren’t met.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足以确保调用我们的`getEvents()`方法的任何人都必须是管理员。Spring Security将使用运行时AOP切入点来在方法上执行`BeforeAdvice`，如果安全约束不满足，则抛出`o.s.s.access.AccessDeniedException`异常。
- en: Instructing Spring Security to use method annotations
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指示Spring Security使用方法注解
- en: 'We’ll also need to make a one-time change to `SecurityConfig.java`, where we’ve
    got the rest of our Spring Security configuration. Simply add the following annotation
    to the class declaration:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对`SecurityConfig.java`进行一次性修改，其中包含我们剩余的Spring Security配置。只需将以下注解添加到类声明中：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next section, let’s test the method security validation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们测试方法安全性验证。
- en: Validating method security
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证方法安全性
- en: Don’t believe it was that easy? Log in with `user1@example.com` as the username
    and `user1` as the password, and try accessing `https://localhost:8443/events/backdoor`.
    You should see the **Access Denied** page now.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你不相信这会那么简单吗？使用用户名`user1@example.com`和密码`user1`登录，并尝试访问`https://localhost:8443/events/backdoor`。你现在应该看到**访问被拒绝**页面。
- en: Important note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: You should start with the code from `chapter11.04-calendar`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter11.04-calendar`的代码开始。
- en: 'If you look at the *Tomcat console*, you’ll see a very long stack trace, starting
    with the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看*Tomcat控制台*，你会看到一个非常长的堆栈跟踪，从以下输出开始：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Based on the `getEvents` method invocation, we can see that the user was appropriately
    denied access to the business method because it lacked the `GrantedAuthority`
    of `ROLE_ADMIN`. If you run the same with the username `admin1@example.com` and
    the password `admin1`, you will discover that access will be granted.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`getEvents`方法的调用，我们可以看到用户由于缺少`GrantedAuthority`的`ROLE_ADMIN`权限，被适当地拒绝访问业务方法。如果你使用用户名`admin1@example.com`和密码`admin1`运行相同的操作，你会发现访问将被允许。
- en: Isn’t it amazing that with a simple declaration in our interface, we’re able
    to ensure that the method in question is secure? But how does AOP work?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 难道不是很神奇，仅仅在我们的接口中声明一下，我们就能确保相关方法是安全的？但是AOP是如何工作的呢？
- en: Interface-based proxies
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于接口的代理
- en: 'In the given example from the previous section, Spring Security used an interface-based
    proxy to secure our `getEvents` method. Let’s take a look at the simplified pseudocode
    of what happened to understand how this works:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节给出的示例中，Spring Security使用基于接口的代理来保护我们的`getEvents`方法。让我们看看简化后的伪代码，以了解它是如何工作的：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that Spring creates the original `CalendarService` just as it normally
    does. However, it instructs our code to use another implementation of `CalendarService`
    that performs a security check before returning the result of the original method.
    The secure implementation can be created with no prior knowledge of our interface
    because Spring uses Java’s `java.lang.reflect.Proxy` APIs to dynamically create
    new implementations of the interface.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，Spring创建原始的`CalendarService`就像它通常做的那样。然而，它指示我们的代码使用另一个`CalendarService`的实现，在返回原始方法的结果之前执行安全检查。由于Spring使用Java的`java.lang.reflect.Proxy`
    API动态创建接口的新实现，因此无需了解我们的接口即可创建安全实现。
- en: Note that the object returned is no longer an instance of `DefaultCalendarService`,
    since it is a new implementation of `CalendarService`, that is, it is an anonymous
    implementation of `CalendarService`. This means that we must program against an
    interface in order to use the secure implementation, otherwise, a `ClassCastException`
    exception will occur.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，返回的对象不再是`DefaultCalendarService`的实例，因为它是一个新的`CalendarService`实现，即它是`CalendarService`的匿名实现。这意味着我们必须针对接口编程，才能使用安全实现，否则将发生`ClassCastException`异常。
- en: To learn more about Spring AOP, refer to the Spring reference documentation
    at [https://docs.spring.io/spring-framework/reference/core/aop/proxying.xhtml#aop-understanding-aop-proxies](https://docs.spring.io/spring-framework/reference/core/aop/proxying.xhtml#aop-understanding-aop-proxies).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Spring AOP的信息，请参阅Spring参考文档中的[https://docs.spring.io/spring-framework/reference/core/aop/proxying.xhtml#aop-understanding-aop-proxies](https://docs.spring.io/spring-framework/reference/core/aop/proxying.xhtml#aop-understanding-aop-proxies)。
- en: In addition to the `@PreAuthorize` annotation, there are several other ways
    of declaring security preauthorization requirements on methods. We can examine
    these different ways of securing methods and then evaluate their pros and cons
    in different circumstances.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`@PreAuthorize`注解之外，还有几种方法可以在方法上声明安全预授权要求。我们可以检查这些不同的方法保护方式，然后评估它们在不同情况下的优缺点。
- en: JSR-250 compliant standardized rules
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSR-250兼容的标准化规则
- en: '**JSR-250 Common Annotations** for the Java platform defines a series of annotations,
    some that are security-related, which are intended to be portable across JSR-250
    compliant runtime environments. The Spring Framework became compliant with JSR-250
    as part of the Spring 2.x release, including the Spring Security framework.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSR-250通用注解**为Java平台定义了一系列注解，其中一些与安全相关，旨在在JSR-250兼容的运行环境中可移植。Spring框架在Spring
    2.x版本中成为JSR-250的合规者，包括Spring Security框架。'
- en: Gradle dependencies
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gradle依赖项
- en: There are several optional dependencies that may be required, depending on what
    features you decide to use for example to enable the support of JSR 250 `@RolesAllowed`
    annotation. Many of these dependencies are commented as Spring Boot includes them
    already in the starter parent.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您决定使用的功能，可能需要几个可选依赖项，例如，为了启用对JSR 250 `@RolesAllowed`注解的支持。其中许多依赖项已被注释，因为Spring
    Boot已经在启动器父项目中包含了它们。
- en: 'You will find that our `build.gradle` file already includes the above dependency
    (transitively):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现我们的`build.gradle`文件已经包含了上述依赖项（间接包含）：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While JSR-250 annotations are not as expressive as Spring native annotations,
    they have the benefit that the declarations they provide are compatible across
    implementing Jakarta EE application servers. Depending on your application’s needs
    and requirements for portability, you may decide that the trade-off of reduced
    specificity is worth the portability of the code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JSR-250注解不如Spring原生注解表达性强，但它们的好处是，它们提供的声明可以在实现Jakarta EE应用服务器的环境中兼容。根据您应用程序的需求和可移植性的要求，您可能会决定减少特定性的权衡是值得的。
- en: 'To implement the rule we specified in the first example, we make a few changes
    by performing the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们在第一个示例中指定的规则，我们通过以下步骤进行了一些更改：
- en: 'First, we need to update our `SecurityConfig` file to use the JSR-250 annotations:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要更新我们的`SecurityConfig`文件以使用JSR-250注解：
- en: '[PRE16]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Lastly, the `@PreAuthorize` annotation needs to change to the `@RolesAllowed`
    annotation. As we might anticipate, the `@RolesAllowed` annotation does not support
    SpEL expressions, so we edit `CalendarService` as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，需要将`@PreAuthorize`注解更改为`@RolesAllowed`注解。正如我们可能预料的，`@RolesAllowed`注解不支持SpEL表达式，因此我们需要如下编辑`CalendarService`：
- en: '[PRE17]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Restart the application, log in as `user1@example.com`/`user1`, and try to access
    `https://localhost:8443/events/backdoor`. You should see **the Access Denied**
    page again.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用程序，以`user1@example.com`/`user1`的身份登录，并尝试访问`https://localhost:8443/events/backdoor`。你应该再次看到**访问被拒绝**页面。
- en: Important note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter11.05-calendar`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter11.05-calendar`的代码开始。
- en: 'Note that it’s also possible to provide a list of allowed `GrantedAuthority`
    names using the standard Java 5 String array annotation syntax:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，也可以使用标准的Java 5 String数组注解语法提供一个允许的`GrantedAuthority`名称列表：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are also two additional annotations specified by JSR-250, namely `@PermitAll`
    and `@DenyAll`, which function as you might expect, permitting and denying all
    requests to the method in question.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JSR-250还指定了两个额外的注解，即`@PermitAll`和`@DenyAll`，它们的功能正如你所预期的那样，允许和拒绝针对所涉及方法的全部请求。
- en: Important note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be aware that method-level security annotations can be applied at the class
    level as well! Method-level annotations, if supplied, will always override annotations
    specified at the class level. This can be helpful if your business needs to dictate
    the specification of security policies for an entire class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，方法级别的安全注解也可以应用于类级别！如果提供了方法级别的注解，它们将始终覆盖类级别指定的注解。如果你的业务需要为整个类指定安全策略的规范，这可能会很有帮助。
- en: Take care to use this functionality in conjunction with good comments and coding
    standards, so that developers are very clear about the security characteristics
    of the class and its methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细使用此功能，并结合良好的注释和编码标准，以确保开发者非常清楚类及其方法的安全特性。
- en: Method security using Spring’s @Secured annotation
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring的@Secured注解进行方法安全
- en: 'Spring itself provides a simpler annotation style that is similar to the JSR-250
    `@RolesAllowed` annotation. The `@Secured` annotation is functionally and syntactically
    the same as `@RolesAllowed`. The only notable differences are that it does not
    require the external dependency, cannot be processed by other frameworks, and
    the processing of these annotations must be explicitly enabled with another attribute
    on the `@``EnableMethodSecurity` annotation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Spring本身提供了一个类似于JSR-250 `@RolesAllowed`注解的简单注解风格。`@Secured`注解在功能和语法上与`@RolesAllowed`相同。唯一的显著区别是它不需要外部依赖，不能被其他框架处理，并且必须通过`@EnableMethodSecurity`注解上的另一个属性显式启用这些注解的处理：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As `@Secured` functions in the same way as the JSR standard `@RolesAllowed`
    annotation, there’s no real compelling reason to use it in new code, but you may
    run across it in older Spring code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`@Secured`注解与JSR标准`@RolesAllowed`注解功能相同，因此在新代码中实际上没有使用它的真正理由，但你可能会在旧的Spring代码中遇到它。
- en: Method security rules incorporating method parameters
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合方法参数的方法安全规则
- en: 'Logically, writing rules that refer to method parameters in their constraints
    seem sensible for certain types of operations. For example, it might make sense
    for us to restrict the `findForUser(int userId)` method to meet the following
    constraints:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，在约束条件中引用方法参数的规则对于某些类型的操作似乎是合理的。例如，我们可能需要将`findForUser(int userId)`方法限制为满足以下约束：
- en: The `userId` argument must be equal to the current user’s ID
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userId`参数必须等于当前用户的ID'
- en: The user must be an administrator (in this case, it is valid for the user to
    see any event)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须是管理员（在这种情况下，用户可以查看任何事件）
- en: While it’s easy to see how we could alter the rule to restrict the method invocation
    only to administrators, it’s not clear how we would determine if the user were
    attempting to change their own password.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以很容易地看到如何修改规则以仅允许管理员调用方法，但并不清楚我们如何确定用户是否试图更改自己的密码。
- en: 'Fortunately, SpEL binding, used by the Spring Security method annotations,
    supports more sophisticated expressions, including expressions that incorporate
    method parameters. You will also want to ensure that you have enabled pre- and
    post-annotations in the `SecurityConfig` file, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Spring Security方法注解使用的SpEL绑定支持更复杂的表达式，包括包含方法参数的表达式。您还希望确保您已在`SecurityConfig`文件中启用了前注解和后注解，如下所示：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can see here that we’ve augmented the SpEL directive we used in the first
    exercise with a check against the ID of the principal and against the `userId`
    method parameter `(#userId`, the method parameter name, is prefixed with a `#`
    symbol). The fact that this powerful feature of method parameter binding is available
    should get your creative juices flowing and allow you to secure method invocations
    with a very precise set of logical rules.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处看到，我们已将我们在第一个练习中使用的SpEL指令与对主体ID的检查以及`userId`方法参数（方法参数名称`(#userId`）的检查相结合。这个强大的方法参数绑定功能可用的事实应该激发您的创造力，并允许您使用一组非常精确的逻辑规则来确保方法调用安全。
- en: Important note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Our principal is currently an instance of `CalendarUser` due to the custom authentication
    setup from [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*.
    This means that the principal has all of the properties that our `CalendarUser`
    application has on it. If we had not done this customization, only the properties
    of the `UserDetails` object would be available.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从[*第3章*](B21757_03.xhtml#_idTextAnchor068) *自定义认证*中自定义了认证设置，我们的主体目前是`CalendarUser`的一个实例。这意味着主体具有我们`CalendarUser`应用程序上的所有属性。如果我们没有进行此自定义，则只有`UserDetails`对象的属性将可用。
- en: 'SpEL variables are referenced with the hash (`#`) prefix. One important note
    is that in order for method argument names to be available at runtime, debugging
    symbol table information must be retained after compilation. Common methods to
    retain the debugging symbol table information are listed as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL变量使用哈希（`#`）前缀进行引用。一个重要的注意事项是，为了在运行时使方法参数名称可用，必须在编译后保留调试符号表信息。以下列出了一些保留调试符号表信息的方法：
- en: If you are using the `javac` compiler, you will need to include the `-g` flag
    when building your classes.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用`javac`编译器，您在构建类时需要包含`-g`标志。
- en: When using the `<javac>` task in Ant, add the attribute `debug="true"`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在Ant中使用`<javac>`任务时，添加属性`debug="true"`。
- en: In Gradle, ensure to add `--debug` when running the main method, or the `bootRun`
    task.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Gradle中，确保在运行主方法或`bootRun`任务时添加`--debug`。
- en: In Maven, ensure the `maven.compiler.debug=true` property (the default is `true`).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Maven中，确保`maven.compiler.debug=true`属性（默认为`true`）。
- en: Consult your compiler, **build tool**, or IDE documentation for assistance on
    configuring this same setting in your environment.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请咨询您的编译器、**构建工具**或IDE文档，以获取在您的环境中配置此相同设置的协助。
- en: Start up your application and try logging in with `user1@example.com` as the
    username and `user1` as the password.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的应用程序，并尝试使用`user1@example.com`作为用户名和`user1`作为密码进行登录。
- en: On the `admin1@example.com`) link to see an **Access** **Denied** page.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`admin1@example.com`)链接上查看一个**访问被拒绝**页面。
- en: Try again with `email=user1@example.com`) to see it work.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试使用`email=user1@example.com`)来查看它是否工作。
- en: Note that the displayed user on the `admin1@example.com`/`admin1`. You will
    be able to see both pages since you are logged in as a user with the `ROLE_ADMIN`
    permission.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`admin1@example.com`/`admin1`上显示的用户。由于您登录的用户具有`ROLE_ADMIN`权限，您将能够看到两个页面。
- en: Important note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: You should start with the code from `chapter11.06-calendar`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter11.06-calendar`的代码开始。
- en: Method security rules incorporating returned values
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合返回值的方法安全规则
- en: 'Just as we were able to leverage the parameters to the method, we can also
    leverage the returned value of the method call. Let’s update the `getEvent` method
    to meet the following constraints on the returned value:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们能够利用方法参数一样，我们也可以利用方法调用的返回值。让我们更新`getEvent`方法以满足以下返回值约束：
- en: The attendee’s ID must be the current user’s ID
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与者的ID必须是当前用户的ID
- en: The owner’s ID must be the current user’s ID
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有者的ID必须是当前用户的ID
- en: The user must be an administrator (in this case, it is valid for the user to
    see any event)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须是管理员（在这种情况下，用户查看任何事件都是有效的）
- en: 'Add the following code to the `CalendarService` interface:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CalendarService`接口中：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, try logging in with the username `user1@example.com` and the password `user1`.
    Next, try accessing the **Vacation Event** using the link on the **Welcome** page.
    You should now see the **Access** **Denied** page.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请尝试使用用户名 `user1@example.com` 和密码 `user1` 登录。接下来，请使用**欢迎**页面上的链接访问**假期活动**。你现在应该看到**访问被拒绝**页面。
- en: If you log in using the username `user2@example.com` and the password `user2`,
    the `user2@example.com` is the attendee at the **Vacation Event**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用用户名 `user2@example.com` 和密码 `user2` 登录，`user2@example.com` 是**假期活动**的参会者。
- en: Important note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter11.07-calendar`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从 `chapter11.07-calendar` 中的代码开始。
- en: Securing method data using role-based filtering
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于角色的过滤保护方法数据
- en: The two final Spring Security-dependent annotations are `@PreFilter` and `@PostFilter`,
    which are used to apply security-based filtering rules to collections or arrays
    (with `@PostFilter` only). This type of functionality is referred to as security
    trimming or security pruning and involves using the security credentials of principal
    at runtime to selectively remove members from a set of objects. As you might expect,
    this filtering is performed using SpEL expression notation within the annotation
    declaration.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个依赖于 Spring Security 的注解是 `@PreFilter` 和 `@PostFilter`，它们用于将基于安全性的过滤规则应用于集合或数组（仅使用
    `@PostFilter`）。这种功能被称为安全修剪或安全剪枝，它涉及在运行时使用主体的安全凭证来选择性地从一组对象中删除成员。正如你所期望的，这种过滤是在注解声明中使用
    SpEL 表达式符号进行的。
- en: 'We’ll work through an example with JBCP calendar, as we want to filter the
    `getEvents` method to only return the events that this user is allowed to see.
    In order to do this, we remove any existing security annotations and add the `@PostFilter`
    annotation to our `CalendarService` interface, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 JBCP 日历的示例进行操作，因为我们想过滤 `getEvents` 方法，使其只返回该用户允许看到的活动。为了做到这一点，我们移除任何现有的安全注解，并将
    `@PostFilter` 注解添加到我们的 `CalendarService` 接口，如下所示：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Important note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter11.08-calendar`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从 `chapter11.08-calendar` 中的代码开始。
- en: Remove the `requestMatchers()` method, restricting access to `/events/ URL`
    so that we can test our annotation. Start up the application and view the `user1@example.com`
    and password `user1`. You will observe that only the events that are associated
    with our user are displayed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 `requestMatchers()` 方法，限制对 `/events/` URL 的访问，以便我们可以测试我们的注解。启动应用程序并查看 `user1@example.com`
    和密码 `user1`。你会观察到只有与我们的用户关联的活动被显示。
- en: With `filterObject` acting as the loop variable that refers to the current event,
    Spring Security will iterate over the `List<Event>` returned by our service and
    modify it to only contain the `Event` objects that match our SpEL expression.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `filterObject` 作为引用当前事件的循环变量时，Spring Security 将遍历我们服务返回的 `List<Event>` 并将其修改为仅包含与我们的
    SpEL 表达式匹配的 `Event` 对象。
- en: In general, the `@PostFilter` method behaves in the following way. For brevity,
    we refer to the collection as the method return value, but be aware that `@PostFilter`
    works with either collection or array method return types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`@PostFilter` 方法的行为如下。为了简洁起见，我们将集合称为方法返回值，但请注意，`@PostFilter` 适用于集合或数组方法返回类型。
- en: The `filterObject` object is rebound to the SpEL context for each element in
    the collection. This means that if your method is returning a collection with
    100 elements, the SpEL expression will be evaluated for each.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterObject` 对象被重新绑定到 SpEL 上下文中的集合的每个元素。这意味着如果你的方法返回一个包含 100 个元素的集合，SpEL
    表达式将针对每个元素进行评估。'
- en: The SpEL expression must return a Boolean value. If the expression evaluates
    to true, the object will remain in the collection, while if the expression evaluates
    to false, the object will be removed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL 表达式必须返回一个布尔值。如果表达式评估为 true，对象将保留在集合中，如果表达式评估为 false，对象将被移除。
- en: In most cases, you’ll find that collection post filtering saves you from the
    complexity of writing boilerplate code that you would likely be writing anyway.
    Take care that you understand how `@PostFilter` works conceptually; unlike `@PreAuthorize`,
    `@PostFilter` specifies method behavior and not a precondition. Some object-oriented
    purists may argue that `@PostFilter` isn’t appropriate for inclusion as a method
    annotation, and such filtering should instead be handled through code in a method
    implementation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会发现集合后过滤可以让你避免编写样板代码的复杂性，你可能会编写这些代码。务必理解`@PostFilter`的概念；与`@PreAuthorize`不同，`@PostFilter`指定方法行为而不是先决条件。一些面向对象的纯粹主义者可能会认为`@PostFilter`不适合作为方法注解，这种过滤应该通过方法实现中的代码来处理。
- en: Important note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be aware that the actual collection returned from your method will be modified!
    In some cases, this isn’t desirable behavior, so you should ensure that your method
    returns a collection that can be safely modified. This is especially important
    if the returned collection is an ORM-bound one, as post-filter modifications could
    inadvertently be persisted to the ORM data store!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从你的方法返回的实际集合将会被修改！在某些情况下，这种行为可能不是期望的，因此你应该确保你的方法返回一个可以被安全修改的集合。这尤其重要，如果返回的集合是ORM绑定的，因为后过滤修改可能会意外地持久化到ORM数据存储中！
- en: Spring Security also offers functionality to prefilter method parameters that
    are collections; let’s try implementing that now.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security还提供了预处理方法参数集合的功能；现在让我们尝试实现它。
- en: Prefiltering collections with @PreFilter
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@PreFilter预过滤集合
- en: 'The `@PreFilter` annotation can be applied to a method to filter collection
    elements that are passed into a method based on the current security context.
    Functionally, once it has a reference to a collection, this annotation behaves
    exactly the same as the `@PostFilter` annotation, with a couple of exceptions,
    as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PreFilter`注解可以应用于方法，根据当前安全上下文过滤传递给方法的方法参数集合。功能上，一旦它获得对集合的引用，这个注解的行为就与`@PostFilter`注解完全相同，但有以下几个例外：'
- en: The `@PreFilter` annotation supports only collection arguments and does not
    support array arguments.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PreFilter`注解只支持集合参数，不支持数组参数。'
- en: The `@PreFilter` annotation takes an additional, optional `filterTarget` attribute
    which is used to specifically identify the method parameter and filter it when
    the annotated method has more than one argument.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PreFilter`注解接受一个额外的、可选的`filterTarget`属性，用于特别标识方法参数并在注解的方法有多个参数时对其进行过滤。'
- en: As with `@PostFilter`, keep in mind that the original collection passed to the
    method is permanently modified. This may not be desirable behavior, so ensure
    that callers know that the collection’s security may be trimmed after the method
    is invoked!
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像`@PostFilter`一样，请注意，传递给方法的原始集合将被永久修改。这可能不是期望的行为，所以确保调用者知道在方法调用后集合的安全性可能会被裁剪！
- en: 'Imagine if we had a `save` method that accepted a collection of event objects,
    and we wanted to only allow the saving of events that were owned by the currently
    logged-in user. We could do this as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个接受事件对象集合的`save`方法，并且我们只想允许保存由当前登录用户拥有的事件。我们可以这样做：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Much like our `@PostFilter` method, this annotation causes Spring Security to
    iterate over each event with the loop variable `filterObject`. It then compares
    the current user’s ID against the event owner’s ID. If they match, the event is
    retained. If they do not match, the result is discarded.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的`@PostFilter`方法一样，这个注解会导致Spring Security遍历每个事件，使用循环变量`filterObject`。然后它将当前用户的ID与事件所有者的ID进行比较。如果它们匹配，则保留事件。如果不匹配，则结果被丢弃。
- en: Comparing method authorization types
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较方法授权类型
- en: 'The following quick reference chart may assist you in selecting a type of method
    authorization check to use:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下快速参考图表可以帮助你选择要使用的方法授权检查类型：
- en: '| **Method** **authorization type** | **Specified as** | **JSR standard** |
    **Allows** **SpEL expressions** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **方法** **授权类型** | **指定为** | **JSR标准** | **允许** **SpEL表达式** |'
- en: '| `@``PreAuthorize`, `@PostAuthorize` | Annotation | No | Yes |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `@PreAuthorize`, `@PostAuthorize` | 注解 | 否 | 是 |'
- en: '| `@RolesAllowed`, `@``PermitAll`, `@DenyAll` | Annotation | Yes | No |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `@RolesAllowed`, `@PermitAll`, `@DenyAll` | 注解 | 是 | 否 |'
- en: '| `@``Secure` | Annotation | No | No |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `@Secure` | 注解 | 否 | 否 |'
- en: '| `protect-pointcut` | XML | No | No |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `protect-pointcut` | XML | 否 | 否 |'
- en: Table 11.4 – Method authorization types
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.4 – 方法授权类型
- en: Most Java consumers of Spring Security will probably opt to use the JSR-250
    annotations for maximum compatibility and reuse their business classes (and relevant
    constraints) across an IT organization. Where needed, these basic declarations
    can be replaced with the annotations that tie the code to the Spring Security
    implementation itself.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用 Spring Security 的 Java 消费者可能会选择使用 JSR-250 注解以实现最大兼容性和重用其业务类（以及相关约束）在整个
    IT 组织中。在需要的情况下，这些基本声明可以被与 Spring Security 实现本身绑定的注解所替代。
- en: If you are using Spring Security in an environment that doesn’t support annotations,
    unfortunately, your choices are somewhat limited to method security enforcement.
    Even in this situation, the use of AOP provides a reasonably rich environment
    in which we can develop basic security declarations.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个不支持注解的环境中使用 Spring Security，不幸的是，你的选择相当有限，主要是方法安全执行。即使在这种情况之下，使用 AOP 也提供了一个相当丰富的环境，我们可以在这个环境中开发基本的声明性安全声明。
- en: Practical considerations for annotation-based security
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于注解的安全性的实际考虑
- en: One thing to consider is that when returning a collection of real-world applications,
    there is likely to be some sort of paging. This means that our `@PreFilter` and
    `@PostFilter` annotations cannot be used as the sole means of selecting which
    objects to return. Instead, we need to ensure that our queries only select the
    data that the user is allowed to access.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一件事是，当返回一组现实世界的应用程序时，很可能会进行某种分页。这意味着我们的 `@PreFilter` 和 `@PostFilter` 注解不能作为选择返回哪些对象的唯一手段。相反，我们需要确保我们的查询只选择用户允许访问的数据。
- en: This means that the security annotations become redundant checks. However, it
    is important to remember our lesson at the beginning of this chapter; we want
    to secure layers in case one layer is able to be bypassed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着安全注解变成了冗余检查。然而，重要的是要记住本章开头我们学到的教训；我们想要保护层，以防万一某一层被绕过。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered most of the remaining areas in standard Spring
    Security implementations that deal with authorization. We’ve learned enough to
    take a thorough pass through the JBCP calendar application and verify that proper
    authorization checks are in place in all tiers of the application, to ensure that
    malicious users cannot manipulate or access data to which they do not have access.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了标准 Spring Security 实现中处理授权的大部分剩余领域。我们已经学到了足够多的知识，可以彻底检查 JBCP 日历应用程序，并验证应用程序的所有层都设置了适当的授权检查，以确保恶意用户无法操纵或访问他们没有访问权限的数据。
- en: We developed two techniques for micro-authorization, namely filtering out in-page
    content based on authorization or other security criteria using the Thymeleaf
    Spring Security tag library and Spring MVC controller data binding. We also explored
    several methods of securing business functions and data in the business tier of
    our application and supporting a rich, declarative security model that was tightly
    integrated with the code. We also learned how to secure our Spring MVC controllers
    and the differences between interface and class proxy objects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了两种微授权技术，即使用 Thymeleaf Spring Security 标签库和 Spring MVC 控制器数据绑定，根据授权或其他安全标准过滤页面内容。我们还探索了在应用程序的业务层中保护业务功能和数据以及支持与代码紧密集成的丰富声明性安全模型的方法。我们还学习了如何保护我们的
    Spring MVC 控制器以及接口和类代理对象之间的区别。
- en: At this point, we’ve wrapped up coverage of much of the important Spring Security
    functionality that you’re likely to encounter in most standard, secure web application
    development scenarios.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了对大多数重要 Spring Security 功能的覆盖，这些功能你很可能在大多数标准、安全的 Web 应用程序开发场景中会遇到。
- en: In the next chapter, we will discuss the ACL (domain object model) module of
    Spring Security. This will allow us to explicitly declare authorization, rather
    than relying on existing data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Spring Security 的 ACL（域对象模型）模块。这将使我们能够明确声明授权，而不是依赖于现有数据。
