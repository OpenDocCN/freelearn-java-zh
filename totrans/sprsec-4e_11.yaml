- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fine-Grained Access Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will first examine two ways to implement fine-grained authorization—authorization
    that may affect portions of a page of the application. Next, we will look at Spring
    Security’s approach to securing the business tier through method annotation and
    the use of interface-based proxies to accomplish **Aspect-Oriented** **Programming**
    (**AOP**). Then, we will review an interesting capability of annotation-based
    security that allows for role-based filtering on collections of data. Lastly,
    we will look at how class-based proxies differ from interface-based proxies.
  prefs: []
  type: TYPE_NORMAL
- en: 'During this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and experimenting with different methods of performing in-page authorization
    checks on content, given the security context of a user request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing configuration and code annotation to make caller preauthorization
    a key part of our application’s business-tier security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several alternative approaches to implement method-level security, and reviewing
    the pros and cons of each type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing data-based filters on collections and arrays using method-level
    annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing method-level security on our `Spring MVC` controllers to avoid
    configuring `requestMatchers()` methods and `<``intercept-url>` elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/Mxijd](https://packt.link/Mxijd).'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Spring Expression Language (SpEL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security leverages `requestMatchers()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Security provides an `o.s.s.access.expression.SecurityExpressionRoot`
    object that provides the methods and objects available for use, in order to make
    an access control decision. For example, one of the methods available to use is
    `hasRole` method, which accepts a string. This corresponds to the value of the
    access attribute (in the preceding code snippet). In fact, there are a number
    of other expressions available, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `hasRole`(`String role`)`hasAuthority`(`String role`) | Returns `true` if
    the current user has the specified authority. |'
  prefs: []
  type: TYPE_TB
- en: '| `hasAnyRole`(`String... role`) `hasAnyAuthority`(`String... authority`) |
    Returns `true` if the current user has any of the specified authorities. |'
  prefs: []
  type: TYPE_TB
- en: '| `authentication` | Obtains the current `Authentication` object from the `SecurityContext`
    interface returned by the `getContext()` method of the `SecurityContextHolder`
    class. |'
  prefs: []
  type: TYPE_TB
- en: '| `permitAll` | This request does not necessitate authorization and serves
    as a public endpoint. It’s essential to clarify that `Authentication` is never
    retrieved from the session in this scenario. |'
  prefs: []
  type: TYPE_TB
- en: '| `denyAll` | Under no circumstances is the request permitted; it’s important
    to emphasize that `Authentication` is never retrieved from the session in this
    instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `isAnonymous()` | Returns `true` if the current principal is anonymous (is
    not authenticated). |'
  prefs: []
  type: TYPE_TB
- en: '| `isRememberMe()` | Returns `true` if the current principal was authenticated
    using the remember-me feature. |'
  prefs: []
  type: TYPE_TB
- en: '| `isAuthenticated()` | Returns `true` if the user is not an anonymous user
    (that is, they are authenticated). |'
  prefs: []
  type: TYPE_TB
- en: '| `isFullyAuthenticated()` | Returns `true` if the user is authenticated through
    a means other than **remember-me**. |'
  prefs: []
  type: TYPE_TB
- en: '| `hasPermission`(`Object target`, `Object permission`) | Returns `true` if
    the user has permission to access the specified object for the given permission.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `hasPermission`(`String targetId`, `String targetType`, `Object permission`)
    | Returns `true` if the user has permission to access the specified identifier
    for a given type and permission. |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – Summary of the authorization rules
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided some examples of using these SpEL expressions in the following
    code snippet. Keep in mind that we will go into more detail throughout this and
    the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and start up the JBCP calendar application. Visit `https://localhost:8443`
    and log in with the user `user1@example.com` and the password `user1`. You will
    observe that the **My Events** navigation menu item is displayed, and the **All
    Events** navigation menu item is displayed as well.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSecurityExpressionRoot class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `o.s.s.web.access.expression.WebSecurityExpressionRoot` class makes a few
    additional properties available to us. These properties, along with the standard
    properties already mentioned, are made available in the access attribute of the
    `requestMatchers()` method and in the `JSP/Thymeleaf access` attribute of the
    `<sec:authorize>` tag, as we will discuss shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `request` | The current `HttpServletRequest` method. |'
  prefs: []
  type: TYPE_TB
- en: '| `hasIpAddress`(`String... ipAddress`) | Returns `true` if the current IP
    address matches the `ipAddress` value. This can be an exact IP address or the
    IP address/network mask. |'
  prefs: []
  type: TYPE_TB
- en: Table 11.2 – hasIpAddress usage with WebSecurityExpressionRoot
  prefs: []
  type: TYPE_NORMAL
- en: The MethodSecurityExpressionRoot class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Method SpEL expressions also provide a few additional properties that can be
    used through the `o.s.s.access.expression.method.MethodSecurityExpressionRoot`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `target` | Refers to this or the current object being secured. |'
  prefs: []
  type: TYPE_TB
- en: '| `returnObject` | Refers to the object returned by the annotated method. |'
  prefs: []
  type: TYPE_TB
- en: '| `filterObject` | Can be used on a collection or array in conjunction with
    `@PreFilter` or `@PostFilter`, to only include the elements that match the expression.
    The `filterObject` object represents the loop variable of the collection or array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `#<``methodArg>` | Any argument to a method can be referenced by prefixing
    the argument name with `#`. For example, a method argument named `id` can be referred
    to using `#id`. |'
  prefs: []
  type: TYPE_TB
- en: Table 11.3 – MethodSecurityExpressionRoot properties
  prefs: []
  type: TYPE_NORMAL
- en: If the description of these expressions appears a bit brief, don’t worry; we’ll
    work through a number of examples later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We hope that you have a decent grasp of the power of Spring Security’s SpEL
    support. To learn more about SpEL, refer to the Spring reference documentation
    at: [https://docs.spring.io/spring-framework/reference/core/expressions.xhtml](https://docs.spring.io/spring-framework/reference/core/expressions.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Page-level authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Page-level authorization** refers to the availability of application features
    based on the context of a particular user’s request. Unlike coarse-grained authorization
    that we explored in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting
    Started with Spring Security*, fine-grained authorization typically refers to
    the selective availability of the portions of a page, rather than restricting
    access to a page entirely. Most real-world applications will spend a considerable
    amount of time on the details of fine-grained authorization planning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security provides us with the following three methods of selective display
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Security JSP** tag libraries allow conditional access declarations
    to be placed within a page declaration itself, using the standard JSP tag library
    syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thymeleaf Spring Security** tag libraries allow conditional access declarations
    to be placed within a page declaration itself, using the standard Thymeleaf tag
    library syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking user authorization in an MVC application’s controller layer allows
    the controller to make an access decision and bind the results of the decision
    to the model data provided to the view. This approach relies on standard JSTL
    conditional page rendering and data binding and is slightly more complicated than
    Spring Security tag libraries; however, it is more in line with the standard web
    application MVC logical design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of these approaches are perfectly valid when developing fine-grained authorization
    models for a web application. Let’s explore how each approach is implemented through
    a JBCP calendar use case.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering with the Thymeleaf Spring Security tag library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common functionality used in the Thymeleaf Spring Security tag library
    is to conditionally render portions of the page based on authorization rules.
    This is done with the `<sec:authorize*>` tag that functions similarly to the `<if>`
    tag in the core JSTL library, in that the tag’s body will render depending on
    the conditions provided in the tag attributes. We have already seen a very brief
    demonstration of how the Spring Security tag library can be used to restrict the
    viewing of content if the user is not logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering based on URL access rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Spring Security tag library provides functionality to render content based
    on the existing URL authorization rules that are already defined in the security
    configuration file. This is done via the use of the `authorizeHttpRequests()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple HTTP elements, the `authorizeHttpRequests()` method uses
    the currently matched HTTP element’s rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could ensure that the `All` `Events` navigation menu item is
    displayed only when appropriate, that is, for users who are administrators—recall
    that the access rules we’ve previously defined are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `header.xhtml` file to utilize this information and conditionally
    render the link to the `All` `Events` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that the content of the tag is not displayed unless the user
    has sufficient privileges to access the stated URL. It is possible to further
    qualify the authorization check using the `HTTP` method, by including the method
    attribute before the URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using the `authorize-url` attribute to define authorization checks on blocks
    of code is convenient because it abstracts the knowledge of the actual authorization
    checks from your pages and keeps it in your security configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the `HTTP` method should match the case specified in your security
    `requestMatchers()` method, otherwise they may not match as you expect. Also,
    note that the URL should always be relative to the web application context root
    (as your URL access rules are).
  prefs: []
  type: TYPE_NORMAL
- en: For many purposes, the use of the `<sec>` tag’s `authorize-url` attribute will
    suffice to correctly display link- or action-related content only when the user
    is allowed to see it. Remember that the tag need not only surround a link; it
    could even surround a whole form if the user doesn’t have permission to submit
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering using SpEL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An additional, more flexible method of controlling the display of JSP content
    is available when the `<sec>` tag is used in conjunction with a SpEL expression.
    Let’s review what we learned in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. We could hide the `My Events` link from
    any unauthenticated users by changing our `header.xhtml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The SpEL evaluation is performed by the same code behind the scenes as the expressions
    utilized in the `requestMatchers()` method access declaration rules (assuming
    the expressions have been configured). Hence, the same set of built-in functions
    and properties are accessible from the expressions built using the `<``sec>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these methods of utilizing the `<sec>` tag provide powerful, fine-grained
    control over the display of page content based on security authorization rules.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and start up the JBCP calendar application. Visit `https://localhost:8443`
    and log in with the user `user1@example.com` and the password `user1`. You will
    observe that the `admin1@example.com` with the password `admin1`. Now both links
    are visible.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Using controller logic to conditionally render content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how we can use Java-based code to determine
    if we should render some content. We can choose to only show the `user`. This
    will hide the **Create Event** link on the **Welcome** page from users who are
    not logged in as administrators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The welcome controller from the sample code for this chapter has been updated
    to populate the model with an attribute named `showCreateLink`, derived from the
    method name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that Spring MVC can automatically obtain the `Authentication`
    object for us. This is because Spring Security maps our current `Authentication`
    object to the `HttpServletRequest.getPrincipal()` method. Since Spring MVC will
    automatically resolve any object of the `java.security.Principal` type to the
    value of `HttpServletRequest.getPrincipal()`, specifying `Authentication` as an
    argument to our controller is an easy way to access the current `Authentication`
    object. We could also decouple the code from Spring Security by specifying an
    argument of the `Principal` type instead. However, we chose `Authentication` in
    this scenario to help demonstrate how everything connects.
  prefs: []
  type: TYPE_NORMAL
- en: If we were working in another framework that did not know how to do this, we
    could obtain the `Authentication` object using the `SecurityContextHolder` class,
    as we did in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*.
    Also note that if we were not using Spring MVC, we could just set the `HttpServletRequest`
    attribute directly rather than populating it on the model. The attribute that
    we populated on the request would then be available to our JSP, just as it is
    when using a `ModelAndView` object with Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to use the `HttpServletRequest` attribute in our `index.xhtml`
    file to determine if we should display the `Create Event` link. Update `index.xhtml`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, start the application, log in using `admin1@example.com` as the username
    and `admin1` as the password, and visit the **All Events** page. You should no
    longer see the **Create Events** navigation menu item (although it will still
    be present on the page).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: The WebInvocationPrivilegeEvaluator class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There may be times when an application will not be written using JSPs and will
    need to be able to determine access based upon a URL, as we did with `<... sec:authorize-
    url="/events/">`. This can be done by using the `o.s.s.web.access.WebInvocationPrivilegeEvaluator`
    interface, which is the same interface that backs the JSP tag library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we demonstrate the use of `WebInvocationPrivilegeEvaluator`
    by populating our model with an attribute named `showAdminLink`. We are able to
    obtain `WebInvocationPrivilegeEvaluator` using the `@``Autowired` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the framework you are using is not being managed by Spring, `@Autowire`
    will not be able to provide you with `WebInvocationPrivilegeEvaluator`. Instead,
    you can use Spring’s `org.springframework.web.context.WebApplicationContextUtils`
    interface to obtain an instance of `WebInvocationPrivilegeEvaluator`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To try it out, go ahead and update `index.xhtml` to use the `showAdminLink`
    request attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Restart the application and view the `admin1@example.com`/`admin1`, and you
    should see it.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: What is the best way to configure in-page authorization?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many cases, the use of the `authorize-url` attribute of the tag can appropriately
    isolate the code from changes in authorization rules. You should use the `authorize-url`
    attribute of the tag in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The tag is preventing display functionality that can be clearly identified by
    a single URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of the tag can be unambiguously isolated to a single URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, in a typical application, the likelihood that you will be able
    to use the `authorize-url` attribute of the tag frequently is somewhat low. The
    reality is that applications are usually much more complex than this and require
    more involved logic when deciding to render portions of a page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It’s tempting to use the Thymeleaf Spring Security tag library to declare bits
    of rendered pages as off-limits based on security criteria in other methods. However,
    there are a number of reasons why (in many cases) this isn’t a great idea, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Complex conditions beyond role membership are not supported by the tag library.
    For example, if our application incorporated customized attributes on the `UserDetails`
    implementation, IP filters, geolocation, and so on, none of these would be supported
    by the standard `<``sec>` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These could, however, conceivably be supported by the custom tags or using SpEL
    expressions. Even in this case, the page is more likely to be directly tied to
    business logic rather than what is typically encouraged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<sec>` tag must be referenced on every page that it’s used in. This leads
    to potential inconsistencies between the rulesets that are intended to be common,
    but may be spread across different physical pages. A good object-oriented system
    design would suggest that conditional rule evaluations be located in only one
    place, and logically referred to from where they should be applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible (and we illustrate this using our common header page) to encapsulate
    and reuse portions of pages to reduce the occurrence of this type of problem,
    but it is virtually impossible to eliminate in a complex application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no way to validate the correctness of rules stated at compile time.
    Whereas compile-time constants can be used in typical Java-based, object- oriented
    systems, the tag library requires (in typical use) hardcoded role names where
    a simple typo might go undetected for some time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be fair, such typos could be caught easily by comprehensive functional tests
    on the running application, but they are far easier to test using a standard Java
    component unit testing techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that, although the *template-based approach* for conditional content
    rendering is convenient, there are some significant downsides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these issues can be solved by the use of code in controllers that can
    be used to push data into the application view model. Additionally, performing
    advanced authorization determinations in code allows for the benefits of reuse,
    compile-time checks, and proper logical separation of the model, view, and controller.
  prefs: []
  type: TYPE_NORMAL
- en: Method-level security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our primary focus up to this point in the book has been on securing the web-facing
    portion of the JBCP calendar application; however, in real-world planning of secured
    systems, equal attention should be paid to securing the service methods that allow
    users access to the most critical part of any system—its data.
  prefs: []
  type: TYPE_NORMAL
- en: Why we secure in layers?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a minute to see why it is important to secure our methods, even though
    we have already secured our URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Start the JBCP calendar application up. Log in using `user1@example.com` as
    the username and `user1` as the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the `https://localhost:8443/events/`. You will see the custom **Access**
    **Denied** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add `backdoor` to the end of the URL in the browser so that the URL is
    now `https://localhost:8443/events/backdoor`. You will now see a response with
    the same data as the **All Events** page. This data should only be visible to
    an administrator, but we have bypassed it by finding a URL that was not configured
    properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also view the details of an event that we do not own and are not invited
    to. Change `backdoor` with `102` so that the URL is now `https://localhost:8443/events/102`:
    You will now see an **Vacation Event** that is not listed on your **My Events**
    page. This should not be visible to us because we are not an administrator, and
    this is not our event.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, our URL rules are not quite strong enough to entirely secure
    our application. These exploits do not even need to take advantage of more complex
    problems, such as differences in how containers handle URL normalization. In short,
    there are often ways to bypass URL-based security. Let’s see how adding a security
    layer to our business tier can help with our new security vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the business tier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spring Security has the ability to add a layer of authorization (or authorization-based
    data pruning) to the invocation of any Spring-managed bean in your application.
    While many developers focus on web-tier security, business-tier security is arguably
    just as important, as a malicious user may be able to penetrate the security of
    your web tier or access services exposed through a non-UI frontend, such as a
    web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the following logical diagram to see why we’re interested in
    applying a secondary layer of security:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Logical application Layers](img/B21757_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Logical application Layers
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security has the following two main techniques for securing methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GrantedAuthority`, such as `ROLE_ADMIN`. Failure to satisfy the declared constraints
    means that the method call will fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postauthorization**: This technique ensures that the calling principal still
    satisfies declared constraints after the method returns. This is rarely used but
    can provide an extra layer of security around some complex, interconnected business
    tier methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preauthorization and postauthorization techniques provide formalized support
    for what are generally called preconditions and postconditions in a classic, object-oriented
    design. Preconditions and postconditions allow a developer to declare through
    runtime checks that certain constraints around a method’s execution must always
    hold true. In the case of security preauthorization and postauthorization, the
    business tier developer makes a conscious decision about the security profile
    of particular methods by encoding expected runtime conditions as part of an interface
    or class API declaration. As you may imagine, this requires a great deal of forethought
    to avoid unintended consequences!
  prefs: []
  type: TYPE_NORMAL
- en: Adding the @PreAuthorize method annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our first design decision will be to augment method security at the business
    tier by ensuring that a user must be logged in as an `ADMIN` user before he/she
    is allowed to access the `getEvents()` method. This is done with a simple annotation
    added to the method in the service interface definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is all that is required to ensure that anyone invoking our `getEvents()`
    method is an administrator. Spring Security will use a runtime AOP pointcut to
    execute `BeforeAdvice` on the method, and throw `o.s.s.access.AccessDeniedException`
    if the security constraints aren’t met.
  prefs: []
  type: TYPE_NORMAL
- en: Instructing Spring Security to use method annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll also need to make a one-time change to `SecurityConfig.java`, where we’ve
    got the rest of our Spring Security configuration. Simply add the following annotation
    to the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, let’s test the method security validation.
  prefs: []
  type: TYPE_NORMAL
- en: Validating method security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don’t believe it was that easy? Log in with `user1@example.com` as the username
    and `user1` as the password, and try accessing `https://localhost:8443/events/backdoor`.
    You should see the **Access Denied** page now.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the *Tomcat console*, you’ll see a very long stack trace, starting
    with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Based on the `getEvents` method invocation, we can see that the user was appropriately
    denied access to the business method because it lacked the `GrantedAuthority`
    of `ROLE_ADMIN`. If you run the same with the username `admin1@example.com` and
    the password `admin1`, you will discover that access will be granted.
  prefs: []
  type: TYPE_NORMAL
- en: Isn’t it amazing that with a simple declaration in our interface, we’re able
    to ensure that the method in question is secure? But how does AOP work?
  prefs: []
  type: TYPE_NORMAL
- en: Interface-based proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the given example from the previous section, Spring Security used an interface-based
    proxy to secure our `getEvents` method. Let’s take a look at the simplified pseudocode
    of what happened to understand how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that Spring creates the original `CalendarService` just as it normally
    does. However, it instructs our code to use another implementation of `CalendarService`
    that performs a security check before returning the result of the original method.
    The secure implementation can be created with no prior knowledge of our interface
    because Spring uses Java’s `java.lang.reflect.Proxy` APIs to dynamically create
    new implementations of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the object returned is no longer an instance of `DefaultCalendarService`,
    since it is a new implementation of `CalendarService`, that is, it is an anonymous
    implementation of `CalendarService`. This means that we must program against an
    interface in order to use the secure implementation, otherwise, a `ClassCastException`
    exception will occur.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Spring AOP, refer to the Spring reference documentation
    at [https://docs.spring.io/spring-framework/reference/core/aop/proxying.xhtml#aop-understanding-aop-proxies](https://docs.spring.io/spring-framework/reference/core/aop/proxying.xhtml#aop-understanding-aop-proxies).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `@PreAuthorize` annotation, there are several other ways
    of declaring security preauthorization requirements on methods. We can examine
    these different ways of securing methods and then evaluate their pros and cons
    in different circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: JSR-250 compliant standardized rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSR-250 Common Annotations** for the Java platform defines a series of annotations,
    some that are security-related, which are intended to be portable across JSR-250
    compliant runtime environments. The Spring Framework became compliant with JSR-250
    as part of the Spring 2.x release, including the Spring Security framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Gradle dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several optional dependencies that may be required, depending on what
    features you decide to use for example to enable the support of JSR 250 `@RolesAllowed`
    annotation. Many of these dependencies are commented as Spring Boot includes them
    already in the starter parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find that our `build.gradle` file already includes the above dependency
    (transitively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While JSR-250 annotations are not as expressive as Spring native annotations,
    they have the benefit that the declarations they provide are compatible across
    implementing Jakarta EE application servers. Depending on your application’s needs
    and requirements for portability, you may decide that the trade-off of reduced
    specificity is worth the portability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the rule we specified in the first example, we make a few changes
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to update our `SecurityConfig` file to use the JSR-250 annotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, the `@PreAuthorize` annotation needs to change to the `@RolesAllowed`
    annotation. As we might anticipate, the `@RolesAllowed` annotation does not support
    SpEL expressions, so we edit `CalendarService` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart the application, log in as `user1@example.com`/`user1`, and try to access
    `https://localhost:8443/events/backdoor`. You should see **the Access Denied**
    page again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it’s also possible to provide a list of allowed `GrantedAuthority`
    names using the standard Java 5 String array annotation syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are also two additional annotations specified by JSR-250, namely `@PermitAll`
    and `@DenyAll`, which function as you might expect, permitting and denying all
    requests to the method in question.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that method-level security annotations can be applied at the class
    level as well! Method-level annotations, if supplied, will always override annotations
    specified at the class level. This can be helpful if your business needs to dictate
    the specification of security policies for an entire class.
  prefs: []
  type: TYPE_NORMAL
- en: Take care to use this functionality in conjunction with good comments and coding
    standards, so that developers are very clear about the security characteristics
    of the class and its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Method security using Spring’s @Secured annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring itself provides a simpler annotation style that is similar to the JSR-250
    `@RolesAllowed` annotation. The `@Secured` annotation is functionally and syntactically
    the same as `@RolesAllowed`. The only notable differences are that it does not
    require the external dependency, cannot be processed by other frameworks, and
    the processing of these annotations must be explicitly enabled with another attribute
    on the `@``EnableMethodSecurity` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As `@Secured` functions in the same way as the JSR standard `@RolesAllowed`
    annotation, there’s no real compelling reason to use it in new code, but you may
    run across it in older Spring code.
  prefs: []
  type: TYPE_NORMAL
- en: Method security rules incorporating method parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logically, writing rules that refer to method parameters in their constraints
    seem sensible for certain types of operations. For example, it might make sense
    for us to restrict the `findForUser(int userId)` method to meet the following
    constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: The `userId` argument must be equal to the current user’s ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user must be an administrator (in this case, it is valid for the user to
    see any event)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it’s easy to see how we could alter the rule to restrict the method invocation
    only to administrators, it’s not clear how we would determine if the user were
    attempting to change their own password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, SpEL binding, used by the Spring Security method annotations,
    supports more sophisticated expressions, including expressions that incorporate
    method parameters. You will also want to ensure that you have enabled pre- and
    post-annotations in the `SecurityConfig` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that we’ve augmented the SpEL directive we used in the first
    exercise with a check against the ID of the principal and against the `userId`
    method parameter `(#userId`, the method parameter name, is prefixed with a `#`
    symbol). The fact that this powerful feature of method parameter binding is available
    should get your creative juices flowing and allow you to secure method invocations
    with a very precise set of logical rules.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Our principal is currently an instance of `CalendarUser` due to the custom authentication
    setup from [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*.
    This means that the principal has all of the properties that our `CalendarUser`
    application has on it. If we had not done this customization, only the properties
    of the `UserDetails` object would be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'SpEL variables are referenced with the hash (`#`) prefix. One important note
    is that in order for method argument names to be available at runtime, debugging
    symbol table information must be retained after compilation. Common methods to
    retain the debugging symbol table information are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the `javac` compiler, you will need to include the `-g` flag
    when building your classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using the `<javac>` task in Ant, add the attribute `debug="true"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Gradle, ensure to add `--debug` when running the main method, or the `bootRun`
    task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Maven, ensure the `maven.compiler.debug=true` property (the default is `true`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consult your compiler, **build tool**, or IDE documentation for assistance on
    configuring this same setting in your environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start up your application and try logging in with `user1@example.com` as the
    username and `user1` as the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `admin1@example.com`) link to see an **Access** **Denied** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try again with `email=user1@example.com`) to see it work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the displayed user on the `admin1@example.com`/`admin1`. You will
    be able to see both pages since you are logged in as a user with the `ROLE_ADMIN`
    permission.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.06-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Method security rules incorporating returned values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we were able to leverage the parameters to the method, we can also
    leverage the returned value of the method call. Let’s update the `getEvent` method
    to meet the following constraints on the returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: The attendee’s ID must be the current user’s ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The owner’s ID must be the current user’s ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user must be an administrator (in this case, it is valid for the user to
    see any event)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following code to the `CalendarService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, try logging in with the username `user1@example.com` and the password `user1`.
    Next, try accessing the **Vacation Event** using the link on the **Welcome** page.
    You should now see the **Access** **Denied** page.
  prefs: []
  type: TYPE_NORMAL
- en: If you log in using the username `user2@example.com` and the password `user2`,
    the `user2@example.com` is the attendee at the **Vacation Event**.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.07-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Securing method data using role-based filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two final Spring Security-dependent annotations are `@PreFilter` and `@PostFilter`,
    which are used to apply security-based filtering rules to collections or arrays
    (with `@PostFilter` only). This type of functionality is referred to as security
    trimming or security pruning and involves using the security credentials of principal
    at runtime to selectively remove members from a set of objects. As you might expect,
    this filtering is performed using SpEL expression notation within the annotation
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll work through an example with JBCP calendar, as we want to filter the
    `getEvents` method to only return the events that this user is allowed to see.
    In order to do this, we remove any existing security annotations and add the `@PostFilter`
    annotation to our `CalendarService` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.08-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `requestMatchers()` method, restricting access to `/events/ URL`
    so that we can test our annotation. Start up the application and view the `user1@example.com`
    and password `user1`. You will observe that only the events that are associated
    with our user are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: With `filterObject` acting as the loop variable that refers to the current event,
    Spring Security will iterate over the `List<Event>` returned by our service and
    modify it to only contain the `Event` objects that match our SpEL expression.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the `@PostFilter` method behaves in the following way. For brevity,
    we refer to the collection as the method return value, but be aware that `@PostFilter`
    works with either collection or array method return types.
  prefs: []
  type: TYPE_NORMAL
- en: The `filterObject` object is rebound to the SpEL context for each element in
    the collection. This means that if your method is returning a collection with
    100 elements, the SpEL expression will be evaluated for each.
  prefs: []
  type: TYPE_NORMAL
- en: The SpEL expression must return a Boolean value. If the expression evaluates
    to true, the object will remain in the collection, while if the expression evaluates
    to false, the object will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you’ll find that collection post filtering saves you from the
    complexity of writing boilerplate code that you would likely be writing anyway.
    Take care that you understand how `@PostFilter` works conceptually; unlike `@PreAuthorize`,
    `@PostFilter` specifies method behavior and not a precondition. Some object-oriented
    purists may argue that `@PostFilter` isn’t appropriate for inclusion as a method
    annotation, and such filtering should instead be handled through code in a method
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the actual collection returned from your method will be modified!
    In some cases, this isn’t desirable behavior, so you should ensure that your method
    returns a collection that can be safely modified. This is especially important
    if the returned collection is an ORM-bound one, as post-filter modifications could
    inadvertently be persisted to the ORM data store!
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security also offers functionality to prefilter method parameters that
    are collections; let’s try implementing that now.
  prefs: []
  type: TYPE_NORMAL
- en: Prefiltering collections with @PreFilter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@PreFilter` annotation can be applied to a method to filter collection
    elements that are passed into a method based on the current security context.
    Functionally, once it has a reference to a collection, this annotation behaves
    exactly the same as the `@PostFilter` annotation, with a couple of exceptions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@PreFilter` annotation supports only collection arguments and does not
    support array arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@PreFilter` annotation takes an additional, optional `filterTarget` attribute
    which is used to specifically identify the method parameter and filter it when
    the annotated method has more than one argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with `@PostFilter`, keep in mind that the original collection passed to the
    method is permanently modified. This may not be desirable behavior, so ensure
    that callers know that the collection’s security may be trimmed after the method
    is invoked!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine if we had a `save` method that accepted a collection of event objects,
    and we wanted to only allow the saving of events that were owned by the currently
    logged-in user. We could do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Much like our `@PostFilter` method, this annotation causes Spring Security to
    iterate over each event with the loop variable `filterObject`. It then compares
    the current user’s ID against the event owner’s ID. If they match, the event is
    retained. If they do not match, the result is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing method authorization types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following quick reference chart may assist you in selecting a type of method
    authorization check to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** **authorization type** | **Specified as** | **JSR standard** |
    **Allows** **SpEL expressions** |'
  prefs: []
  type: TYPE_TB
- en: '| `@``PreAuthorize`, `@PostAuthorize` | Annotation | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `@RolesAllowed`, `@``PermitAll`, `@DenyAll` | Annotation | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `@``Secure` | Annotation | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `protect-pointcut` | XML | No | No |'
  prefs: []
  type: TYPE_TB
- en: Table 11.4 – Method authorization types
  prefs: []
  type: TYPE_NORMAL
- en: Most Java consumers of Spring Security will probably opt to use the JSR-250
    annotations for maximum compatibility and reuse their business classes (and relevant
    constraints) across an IT organization. Where needed, these basic declarations
    can be replaced with the annotations that tie the code to the Spring Security
    implementation itself.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Spring Security in an environment that doesn’t support annotations,
    unfortunately, your choices are somewhat limited to method security enforcement.
    Even in this situation, the use of AOP provides a reasonably rich environment
    in which we can develop basic security declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Practical considerations for annotation-based security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to consider is that when returning a collection of real-world applications,
    there is likely to be some sort of paging. This means that our `@PreFilter` and
    `@PostFilter` annotations cannot be used as the sole means of selecting which
    objects to return. Instead, we need to ensure that our queries only select the
    data that the user is allowed to access.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the security annotations become redundant checks. However, it
    is important to remember our lesson at the beginning of this chapter; we want
    to secure layers in case one layer is able to be bypassed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered most of the remaining areas in standard Spring
    Security implementations that deal with authorization. We’ve learned enough to
    take a thorough pass through the JBCP calendar application and verify that proper
    authorization checks are in place in all tiers of the application, to ensure that
    malicious users cannot manipulate or access data to which they do not have access.
  prefs: []
  type: TYPE_NORMAL
- en: We developed two techniques for micro-authorization, namely filtering out in-page
    content based on authorization or other security criteria using the Thymeleaf
    Spring Security tag library and Spring MVC controller data binding. We also explored
    several methods of securing business functions and data in the business tier of
    our application and supporting a rich, declarative security model that was tightly
    integrated with the code. We also learned how to secure our Spring MVC controllers
    and the differences between interface and class proxy objects.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve wrapped up coverage of much of the important Spring Security
    functionality that you’re likely to encounter in most standard, secure web application
    development scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the ACL (domain object model) module of
    Spring Security. This will allow us to explicitly declare authorization, rather
    than relying on existing data.
  prefs: []
  type: TYPE_NORMAL
