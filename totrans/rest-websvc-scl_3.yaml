- en: Chapter 3. A Pattern-matching Approach to REST Services with Unfiltered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll introduce a light-weight REST framework called **Unfiltered**.
    With Unfiltered, you can use standard Scala pattern matching to take complete
    control over how to process an HTTP request and create an HTTP response. In this
    chapter, we''ll look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the basic skeleton for an Unfiltered-based REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using matchers and extractors to process incoming HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing requests in synchronous and asynchronous ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting and validating incoming requests and parameters using extractors
    and directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing response codes and response formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Unfiltered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfiltered is an easy to use light-weight REST framework, which provides a set
    of constructs you can use to create your own REST services. For this, Unfiltered
    uses Scala pattern matching, together with a set of matchers and extractors. One
    of the interesting parts of Unfiltered is that it gives you complete control over
    how you handle your request and define your response. The framework itself won't
    add any headers, or makes assumptions regarding content-types or response codes
    unless you tell it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfiltered has been around for a couple of years and is used by a large number
    of companies. Some of the best-known ones are the following two:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remember the Milk**: Remember the Milk is one of the best-known to-do apps.
    It uses Unfiltered to handle all its public APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meetup**: With Meetup, groups of people who share interests come together
    to share knowledge and schedule meetups. Meetup uses Unfiltered to serve its real-time
    APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information and documentation about Unfiltered, you can check out the
    website at [http://unfiltered.databinder.net/](http://unfiltered.databinder.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Your first Unfiltered service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like we did in the previous chapter, we will start by creating the most
    basic Unfiltered REST service. The dependencies for the examples and frameworks
    used in this chapter can be found in the `Dependencies.scala` file, which is located
    in the `project` directory. For the Unfiltered examples explained in this chapter,
    we use the following SBT dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To work with Unfiltered, we at least need the `unfiltered-filter` module, which
    contains the core classes we need to create routes and handle requests and responses.
    We also need to define which type of server we want to use to run Unfiltered on.
    In this case, we run Unfiltered on an embedded Jetty ([http://www.eclipse.org/jetty/](http://www.eclipse.org/jetty/))
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these dependencies in place, we can create a minimal Unfiltered service.
    You can find the code for this service in the `HelloUnfiltered.scala` source file,
    which is located in the sources for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What we do here is create a simple route that responds to a `GET` request on
    the `/hello` path. When Unfiltered receives this request, it will respond with
    the `Hello Unfiltered` response using the `ResponseString` object to create a
    response (we will discuss this more later). This route is bound to a Jetty server,
    which runs on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You probably have noticed the strange `Thread.currentThread().setName` call
    at the beginning of this example. The reason we do this is to avoid Unfiltered
    starting in daemon mode. Unfiltered tries to detect whether we have started from
    SBT or run normally; if run from SBT, it allows us to stop the server by just
    pressing a key (the behavior we want). If not, it runs in the background and requires
    a shutdown hook to stop the server. It does this by checking the name of the current
    thread. If the name is `main`, it will run Unfiltered in daemon mode, if it is
    something else, it will run normally, which allows us to easily stop the server.
    So by setting the name of the main thread to something else, we can also have
    this nice shutdown behavior when run from the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we also need to set up logging for Jetty, which is the engine
    used by Unfiltered. Jetty has some prolific logging in its default configuration.
    To minimize the logging of Jetty to only log useful information, we need to add
    a `logback.xml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s start the server and use Postman to make a call to the Unfiltered
    service. To start this example, run `sbt runCH03-HelloUnfiltered` from the root
    directory of the sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up Postman, click on the collection name **Chapter 03**, and open the
    first request. Once you click on **Send**, you should see the response, **Hello
    Unfiltered**, being returned by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your first Unfiltered service](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll look a bit more closely at how Unfiltered uses pattern
    matching to map incoming requests to functions.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP verb and URL matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unfiltered uses standard Scala pattern matching to determine what to do with
    a specific request. The following code shows how Unfiltered provides matchers
    for a number of simple REST calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot to see in this code fragment, so let''s start at the beginning.
    To create a REST API in Unfiltered, we need to create a `Plan` object. A `Plan`
    describes how to respond to specific requests. There are two different ways to
    create such a `Plan`. You can directly pass in a partial function to `unfiltered.filter.Planify`,
    like we did in the getting started example earlier in this chapter or explicitly
    extend from `unfiltered.filter.Plan` and set the `intent val` to your route configuration.
    In the rest of this chapter, we''ll use the latter approach since it allows us
    to combine API parts in an easy manner. Let''s start with the first set of matchers
    from the `taskApi` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we use standard pattern matching from Scala. These patterns
    will be checked against the current `HttpRequest` instance and will make use of
    a number of matchers provided by Unfiltered:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Matcher | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` and the other HTTP verbs. | With this matcher, we match the HTTP verb
    of the request. Unfiltered provides the following number of standard matchers
    for this: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `CONNECT`, `OPTIONS`, `TRACE`,
    `PATCH`, `LINK`, and `UNLINK`.Should you have edge cases where you need to match
    other verbs, you can easily create your own matcher like this: `object WOW extends
    Method("WOW")` |'
  prefs: []
  type: TYPE_TB
- en: '| `Path` | The next matcher we see is the `Path` matcher. With this matcher,
    you check whether you match the complete URL path. So in the preceding example,
    the first pattern only matches when the exact `/tasks` path is called. |'
  prefs: []
  type: TYPE_TB
- en: '| `Seq` | If you want to extract path segments or match more flexibly on multiple
    path segments, you can use the `Seq` matcher. This matcher will check the URL
    on which the request was made, splits it into path segments, and check whether
    individual path segments match or extract path segments for further processing.
    |'
  prefs: []
  type: TYPE_TB
- en: 'So, in our API:'
  prefs: []
  type: TYPE_NORMAL
- en: The first case matches a `GET` request on the `/tasks` path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second case matches a `GET` request on the `/tasks/:id` path. The ID is
    passed into the function handling this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third case does the same as the second, but this time for a `DELETE` request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides these matchers shown in this example, Unfiltered also provides the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Matcher | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `HTTP` and `HTTPS` | These two matchers allow you to check whether the request
    was received over an HTTP or HTTPS connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `Json`/`JavaScript`/`XML` and more | Unfiltered also allows you to check
    the Accepts header of a request. For instance, the JSON matcher will match when
    the `Accepts` header is `application/json` or a request is made on a URL with
    the extension `.js`, without an `Accepts` header. Unfiltered provides the following
    set of standard matchers of this type: `Json`, `JavaScript`, `AppJavaScript`,
    `Jsonp`, `Xml`, `Html`, and `Csv`. If you want to specify a new content-type matcher,
    you can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `HTTP_1_0`/`HTTP_1_1` | Check whether the protocol was made using HTTP version
    1.0 or HTTP version 1.1. |'
  prefs: []
  type: TYPE_TB
- en: '| `Mime` | This matcher allows you to check whether the request conforms to
    a specific mime-type. |'
  prefs: []
  type: TYPE_TB
- en: '| Any header | Unfiltered also provides matchers and extractors for a large
    set of other HTTP headers. There are too many to list here; for a complete overview
    look at the objects in the `headers.scala` file from the Unfiltered sources. |'
  prefs: []
  type: TYPE_TB
- en: '| `Params` | With this matcher-extractor, you can match a specific request
    parameter. We will show an example of this extractor in the next section. |'
  prefs: []
  type: TYPE_TB
- en: '| `RemoteAddr` | Specific matcher that checks whether the `XForwaredFor` header
    contains a trusted address. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look back at the example, especially the `PUT` and `POST` calls on the
    `/tasks` URL. For these two routes, we used an alternative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first match on the `Path("/tasks")` route and then use the matching
    request to determine what to do for the different verbs. This is a convenient
    way to handle multiple verbs that can be used to make a call to the same URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can handle a `POST` and a `PUT` call, and just ignore any
    other call by returning `Pass`. When we return `Pass`, we just tell Unfiltered
    that this intent can''t handle the request. When Unfiltered can''t match a request
    with the current intent, it will just try the next. We''ve used this approach
    in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `Plan`, we defined two intents: one that handled our API, the `taskAPI`
    intent, and one that could serve as fallback when the `taskAPI` intent didn''t
    match, aptly named `fallback` (we''ll explain more about this later in this chapter).
    The `fallback` intent returns the HTTP code, `NotImplemented`, with a message.
    By calling `taskApi.onPass(fallback)`, we tell Unfiltered that when the `taskAPI`
    intent returns a `Pass` result, it should try the `fallback` intent. The `fallback`
    intent can also configure an `onPass` result, and this way, you can easily chain
    and combine APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this service, start it with the `sbt runCH03-runCH03Step1` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The collection for **Chapter 03** in Postman provides you with a number of
    requests you can use to test this server. For instance, the call to create a new
    task looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP verb and URL matching](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And when we hit the `fallback` route, we see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP verb and URL matching](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So far, we've only focused on routing and matching requests. In the next section,
    we'll look at how we can access the request parameters and use the Scala `Future`
    object to create asynchronous responses.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting request parameters and using futures for asynchronous responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve got the basics covered, let''s see what we need to do to convert
    the incoming request parameters and body into our domain model (our case classes).
    In this section, we''ll take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the incoming request to a `Task` case class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the converted `Task` in our dummy `TaskService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `TaskService` object returns a `Future[Task]`; we will change the Unfiltered
    configuration to start handling requests asynchronously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with the first part and look at the route configuration and how
    to convert the incoming request to a `Task` case class. The complete source for
    this example can be found in the `Step2.scala` file in the `rest-with-scala/chapter-03/src/main/scala/org/restwithscala/chapter3/steps/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first show you the complete code and then we''ll look at the individual
    parts in more detail. Note that we''ve only implemented a part of the complete
    task API here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first part we'll look at more closely is how to convert an incoming request
    to a `Task` case class.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a request to a Task class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code fragment shows how we can convert a request to a `Task`
    case class with Unfiltered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a function named `requestToTask` which converts an incoming `HttpRequest`
    and an ID to a `Task`. The first step we take in this function is to create a
    custom extractor, based on a number of standard Unfiltered constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we create a custom extractor by extending the `Extract` class
    provided by Unfiltered. This class has a constructor with two arguments. The first
    one is the name of the parameter we want to extract and the second is a function
    with the `Seq[String] => Option[T]` signature. The second parameter can be used
    to provide a set of predicates, which Unfiltered uses to check whether the value
    is available, and has the correct format. In this scenario, we used two predicates
    provided by Unfiltered. `Params.first` returns the first parameter value with
    the provided name or `None`, and the `Params.nonempty` returns `None` if the result
    from `Params.first` is empty, and returns `Some[String]` if it isn't. As you can
    see, we can use the `~>` operator to chain predicates together (this operator
    is just syntactic sugar for the `andThen` function).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now can use this extractor in our pattern matching logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that this pattern will only match if one of the provided parameters
    has the name `title` and isn''t empty. Out of the box Unfiltered provides the
    following constructs you can use when creating new matchers and extractors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Predicate | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `even` | This returns the parameter value if it can be converted to an integer
    and the result is even. |'
  prefs: []
  type: TYPE_TB
- en: '| `odd` | This returns the parameter value if it can be converted to an integer
    and the result is odd. |'
  prefs: []
  type: TYPE_TB
- en: '| `nonempty` | This returns the parameter value if it isn''t empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `first` | This returns the first value of a parameter. For example, in the
    case of `?id=10&id=20`, it will return `10`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | If the parameter value can be converted to an integer, it will return
    the integer value. |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | If the parameter value can be converted to a long, it will return
    the long value. |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | If the parameter value can be converted to a float, it will return
    the float value. |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | If the parameter value can be converted to a double, it will return
    the double value. |'
  prefs: []
  type: TYPE_TB
- en: '| `trimmed` | This will use `String.trim` to trim the parameter value. |'
  prefs: []
  type: TYPE_TB
- en: '| `~>` | This creates a sequence of predicates, for example, `first ~> nonempty
    ~> trimmed`. |'
  prefs: []
  type: TYPE_TB
- en: At this point, we check whether we've got a non-empty title parameter, and if
    we do, we convert the incoming request to a `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unfiltered also provides a way you can use multiple extractors at the same
    time. With the `&` matcher, you can combine two extractors. The pattern will only
    match if both sides of the `&` matched succeed. For instance, we could check whether
    the parameters contain a non-empty title and an integer amount like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And use it in a pattern, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We'll see more of this in the section on validation later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finally convert the request into a `Task`, we just call the constructor
    directly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can convert a request to a `Task`, let's look at how we call this
    from our route and store it.
  prefs: []
  type: TYPE_NORMAL
- en: Storing a request in the TaskService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To store the request in the `TaskService`, we have to call the `TaskService.insert`
    function. We use the following code to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When we receive a `POST` or `PUT` request on `/tasks`, we pass the request on
    to the `handleCreateTask` function. In this function, we convert the request to
    a `Task` using the code we discussed previously, and store it with the `TaskService.insert`
    function. For now, we'll just return the `toString` of the created `Task` if we
    converted and stored the `Task` successfully. If something went wrong, we return
    a simple error message, also a string. We then return the created `Task` or the
    error message using the `ResponseString` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `handleCreateTask` function returns a `Future[String]` object, so what we
    have to do is make sure that our Unfiltered configuration can handle futures.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Unfiltered to work with futures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Changing the configuration from a synchronous to an asynchronous model is very
    easy. The first thing we need to do is change the underlying server from Jetty
    to Netty. We need to do this because the asynchronous functionality is built on
    top of Netty, and thus, won''t work with Jetty. To use Netty, we need to add the
    following two dependencies to our SBT configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to change the way we create our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of extending from `unfiltered.filter.Plan`, we extend from `future.Plan`
    (with `ServerErrorResponse`, which you can use to handle exception in a generic
    way). If we work with futures, we also need to define the execution context we
    want to use. This is used by Unfiltered to run futures asynchronously. In this
    case, we just use the default global execution context. Note that we need to add
    the `io.netty.channel.ChannelHandler.Sharable` annotation to our API. If we don''t
    do this, Netty will block any incoming requests, and only one thread can access
    the API at the same time. Since we move our service to Netty, we also need to
    start the server in a slightly different way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step we need to take to work with futures is to make sure that all
    our pattern match cases also return a `Future` object. We do this simply by wrapping
    the responses in a `Future`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Most of the responses are explicitly wrapped in a `Future` object. For the `handleCreateTask`
    function, we already receive a `Future[String]` object, so just use `map` to convert
    it to the correct type using a `ResponseString` instance.
  prefs: []
  type: TYPE_NORMAL
- en: As for all the examples, we've also provided a set of sample requests you can
    use to test this REST API. You can find the requests in the **Chapter 03** collection
    in Postman. The most interesting requests to play around with are **Step 02 –
    CreateTask**, **Step 02 – Create Task – Invalid**, and **Step 02 – Trigger Fallback**.
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation to parameter processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we haven't really validated the incoming request. We just checked whether
    a parameter was provided, and if not, completely failed the request. This works,
    but is a rather cumbersome way of validating input parameters. Luckily, Unfiltered
    provides an alternative way of validation by using something called directives.
    With a directive, you tell Unfiltered what you expect, for example, a parameter
    that can be converted to an int, and Unfiltered will either get the value or respond
    with an appropriate response message. In other words, with a directive, you define
    a set of criteria the request must fulfill.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we look at how we can use a directive in our scenario, let''s look at
    how you can use a directive in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this intent, we use `Directive.Intent` to indicate that we want to create
    an intent that uses directives to process the request. In this sample, `Accepts.Json`,
    `GET`, and `data.as.Option[Int].named("amount")` are all directives. When one
    of the directives fails, an appropriate error response is returned automatically.
    With directives, you can pretty much move your matcher and extractor logic to
    a set of directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box, Unfiltered comes with a number of directives, which automatically
    return a response when they don''t match:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Directive | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET`, `POST`, and the other HTTP verbs | You can match on all the methods.
    If a method doesn''t match, a `MethodNotAllowed` response is returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `Accepts.Json` | All the `Accepts.Accepting` definitions are supported. If
    one of these should fail, you get a `NotAcceptable` response. |'
  prefs: []
  type: TYPE_TB
- en: '| `QueryParams` | Get all the query parameters from the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `Params` | You can check whether a single parameter is available. If not,
    a `BadRequest` response is returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `data.as` | The `data.as` directive allows you to get a parameter and convert
    it to a specific value. It provides standard directives to convert a parameter
    to: BigDecimal, BigInt, Double, Float, Int, Long, and String. Besides that, it
    also allows you to specify whether a value is an option or required. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look a bit closer at the `data.as` directive since that is the most
    interesting one when trying to validate input. To use this directive, we first
    define an implicit function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And use it from the `for` comprehension like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the request parameter with the name `amount` is present and can be converted
    to an int, we''ll retrieve that value. If it isn''t present, nothing will happen,
    and if it can''t be converted to an int, the specified `BadRequest` message will
    be returned. We can also make it `Optional` by just requesting `data.as.Option[Int]`
    instead. Having a value as an option is nice, but sometimes you want to make sure
    that a specific query parameter is always present. For that, we can use `Required`.
    To use `Required`, we first have to add another `implicit` function to define
    what happens when a required field isn''t present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we return a `BadRequest` message with the specified response
    when a `Required` field is missing. To use the `Required` field, we simply change
    `data.as.Int` to `data.as.Required[Int]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, Unfiltered will first check if the field is present, and if it is, will
    check whether it can be converted to an int. When one of the checks fails, the
    correct response message will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Adding search functionality to our API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s move on to our example. For this scenario, we''ll add a `search`
    function to our API. This `search` function will allow you to search on the status
    and the text of a task, and return a list of tasks that match. Let''s first look
    at the complete code before we dive into the individual parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Lots of code and some of it might look a bit strange. In the following sections,
    we'll see why we did it this way.
  prefs: []
  type: TYPE_NORMAL
- en: Directives and working with futures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into the directives, you might notice some additional code regarding
    d2\. For this example, we needed to use the `Directives2` library from [https://github.com/shiplog/directives2/](https://github.com/shiplog/directives2/)
    so that we can correctly work combining futures and directives. The standard directives,
    as provided by Unfiltered, don't support asynchronous plans and only allow you
    to use the synchronous Jetty approach. With the `Directives2` directives, we can
    work with futures and use one of the available asynchronous plans provided by
    Unfiltered.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, some glue code required for this to get it to work. The
    following changes needed to be made to the previous step to make directives work
    nicely together with futures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Move from `future.Plan` to `async.Plan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The d2 directives support the `async.Plan` class, but don''t support the `future.Plan`.
    Luckily, this doesn''t change the rest of the code for us. The next step is to
    import the d2 classes and objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With these imports, we get the ability to work with futures as directives,
    and it allows us to convert standard Unfiltered directives to d2 directives. The
    next step to do is to use the `d2.Async.Mapping` object to glue our new asynchronous
    directives to our `async.Plan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this setup, we''ll just pass any request we receive to a partial function,
    which we define like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now whenever we receive a request on the `/search` path, we pass it on to the
    `handleSearchSingleError` function. The final step we do is that we create a simple
    helper method to make converting our standard directives to d2 directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When this `implicit` is in scope, we can just call `toD2` on our normal directives
    so that they can work correctly with the ones from the d2 library.
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation to the request parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve got the d2 stuff out of the way, let''s look at the definition
    of our validations. We''ve defined all our directives implicitly in a `Conversions`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define three implicit values—`required` checks whether a value is
    present, `toStringInterpreter` tries to convert a parameter to a string, and `inStatus`
    checks whether a string is one of the specific set of values. If one of them fails,
    the `fail` function is called and an error is returned. Here, however, we don''t
    directly return the error as an `HttpResponse`, but return it as a `BadParam`
    class. This `BadParam` case class serves as a collector of errors and allows a
    standard way to report one or more errors. In the next section, we''ll come back
    to this. For now, we''ll just report the first error we see. We do this by setting
    up a `for` comprehension like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This `for` comprehension works just like any normal one. First, we check whether
    the status query parameter is valid. If it is, we get the text value and then
    we use both these values to search through the `TaskService`, and finally return
    the result from the `TaskService` as a string. One remark here is the `successValue`
    function we call on the `Future` returned from the `TaskService`. This is a d2
    specific call, which transforms the `Future` into a directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open Postman and first make a request with an invalid status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding validation to the request parameters](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the error message shows what we expect. However, as you might
    have noticed, we also didn't enter a text value, but the error message didn't
    show that. The reason is that our `for` comprehension stops at the first error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Unfiltered provides a way to combine errors. All we have to do is
    change our `for` loop to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `&` operator we can combine directives together. Now each part
    of the combined directives will log its errors using the `BadParam` case class,
    which will respond with all the errors it has collected. You can see how this
    works in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding validation to the request parameters](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw some of the most important aspects of Unfiltered. You
    learned how to handle requests, use matchers and extractors to route requests,
    and access parameters and path segments. You also learned that Unfiltered provides
    different processing models, synchronous and asynchronous, and how to run your
    service either on top of Jetty or on Netty. In the last section, we explored how
    directives in Unfiltered can be used to extract parameters in a more powerful
    way and the additional steps you need to take to use those in an asynchronous
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, as you saw, Unfiltered is a very flexible framework, which is easily
    extensible, and gives you full control over the response-request cycle.
  prefs: []
  type: TYPE_NORMAL
