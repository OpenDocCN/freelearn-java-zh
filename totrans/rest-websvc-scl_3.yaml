- en: Chapter 3. A Pattern-matching Approach to REST Services with Unfiltered
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用Unfiltered的REST服务模式匹配方法
- en: 'In this chapter, we''ll introduce a light-weight REST framework called **Unfiltered**.
    With Unfiltered, you can use standard Scala pattern matching to take complete
    control over how to process an HTTP request and create an HTTP response. In this
    chapter, we''ll look at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一个名为**Unfiltered**的轻量级REST框架。使用Unfiltered，您可以使用标准的Scala模式匹配来完全控制如何处理HTTP请求和创建HTTP响应。在本章中，我们将探讨以下主题：
- en: Setting up the basic skeleton for an Unfiltered-based REST service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基于Unfiltered的REST服务设置基本框架
- en: Using matchers and extractors to process incoming HTTP requests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匹配器和提取器处理传入的HTTP请求
- en: Processing requests in synchronous and asynchronous ways
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以同步和异步方式处理请求
- en: Converting and validating incoming requests and parameters using extractors
    and directives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提取器和指令转换和验证传入的请求和参数
- en: Customizing response codes and response formats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义响应代码和响应格式
- en: What is Unfiltered
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Unfiltered
- en: Unfiltered is an easy to use light-weight REST framework, which provides a set
    of constructs you can use to create your own REST services. For this, Unfiltered
    uses Scala pattern matching, together with a set of matchers and extractors. One
    of the interesting parts of Unfiltered is that it gives you complete control over
    how you handle your request and define your response. The framework itself won't
    add any headers, or makes assumptions regarding content-types or response codes
    unless you tell it to.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Unfiltered是一个易于使用的轻量级REST框架，它提供了一组您可以使用来创建自己的REST服务的构造。为此，Unfiltered使用Scala模式匹配，以及一组匹配器和提取器。Unfiltered有趣的部分之一是它让您完全控制如何处理请求和定义响应。除非您告诉它，否则框架本身不会添加任何标题，也不会对内容类型或响应代码做出假设。
- en: 'Unfiltered has been around for a couple of years and is used by a large number
    of companies. Some of the best-known ones are the following two:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unfiltered已经存在了几年，并被许多公司使用。其中一些最知名的是以下两个：
- en: '**Remember the Milk**: Remember the Milk is one of the best-known to-do apps.
    It uses Unfiltered to handle all its public APIs.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Remember the Milk**: Remember the Milk是众所周知的待办事项应用之一。它使用Unfiltered来处理所有其公开API。'
- en: '**Meetup**: With Meetup, groups of people who share interests come together
    to share knowledge and schedule meetups. Meetup uses Unfiltered to serve its real-time
    APIs.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Meetup**: 使用Meetup，有共同兴趣的人们可以聚集在一起分享知识和安排聚会。Meetup使用Unfiltered来提供其实时API。'
- en: For more information and documentation about Unfiltered, you can check out the
    website at [http://unfiltered.databinder.net/](http://unfiltered.databinder.net/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Unfiltered的更多信息以及文档，您可以查看网站[http://unfiltered.databinder.net/](http://unfiltered.databinder.net/)。
- en: Your first Unfiltered service
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个Unfiltered服务
- en: 'Just like we did in the previous chapter, we will start by creating the most
    basic Unfiltered REST service. The dependencies for the examples and frameworks
    used in this chapter can be found in the `Dependencies.scala` file, which is located
    in the `project` directory. For the Unfiltered examples explained in this chapter,
    we use the following SBT dependencies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章中所做的那样，我们将从创建最基础的Unfiltered REST服务开始。本章中使用的示例和框架的依赖项可以在`Dependencies.scala`文件中找到，该文件位于`project`目录中。对于本章中解释的Unfiltered示例，我们使用以下SBT依赖项：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To work with Unfiltered, we at least need the `unfiltered-filter` module, which
    contains the core classes we need to create routes and handle requests and responses.
    We also need to define which type of server we want to use to run Unfiltered on.
    In this case, we run Unfiltered on an embedded Jetty ([http://www.eclipse.org/jetty/](http://www.eclipse.org/jetty/))
    instance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Unfiltered一起工作，我们至少需要`unfiltered-filter`模块，它包含我们创建路由和处理请求和响应所需的核心类。我们还需要定义我们想要使用哪种类型的服务器来运行Unfiltered。在这种情况下，我们在嵌入的Jetty([http://www.eclipse.org/jetty/](http://www.eclipse.org/jetty/))实例上运行Unfiltered。
- en: 'With these dependencies in place, we can create a minimal Unfiltered service.
    You can find the code for this service in the `HelloUnfiltered.scala` source file,
    which is located in the sources for this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些依赖项就绪后，我们可以创建一个最小的Unfiltered服务。您可以在本章的源文件中找到此服务的代码，该文件位于`HelloUnfiltered.scala`，它位于本章的源文件中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What we do here is create a simple route that responds to a `GET` request on
    the `/hello` path. When Unfiltered receives this request, it will respond with
    the `Hello Unfiltered` response using the `ResponseString` object to create a
    response (we will discuss this more later). This route is bound to a Jetty server,
    which runs on port `8080`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是创建一个简单的路由，它响应 `/hello` 路径上的 `GET` 请求。当 Unfiltered 收到这个请求时，它将使用 `ResponseString`
    对象创建响应来返回 `Hello Unfiltered` 响应（我们将在稍后讨论这个问题）。这个路由绑定到一个运行在端口 `8080` 上的 Jetty 服务器。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You probably have noticed the strange `Thread.currentThread().setName` call
    at the beginning of this example. The reason we do this is to avoid Unfiltered
    starting in daemon mode. Unfiltered tries to detect whether we have started from
    SBT or run normally; if run from SBT, it allows us to stop the server by just
    pressing a key (the behavior we want). If not, it runs in the background and requires
    a shutdown hook to stop the server. It does this by checking the name of the current
    thread. If the name is `main`, it will run Unfiltered in daemon mode, if it is
    something else, it will run normally, which allows us to easily stop the server.
    So by setting the name of the main thread to something else, we can also have
    this nice shutdown behavior when run from the IDE.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了这个例子开头奇怪的 `Thread.currentThread().setName` 调用。我们这样做的原因是为了避免 Unfiltered
    以守护进程模式启动。Unfiltered 尝试检测我们是否是从 SBT 启动或正常运行；如果是通过 SBT 运行，它允许我们只需按下一个键（我们想要的操作）来停止服务器。如果不是，它将在后台运行，并需要一个关闭钩子来停止服务器。它是通过检查当前线程的名称来做到这一点的。如果名称是
    `main`，它将以守护进程模式运行 Unfiltered，如果名称是其他内容，它将正常运行，这允许我们轻松地停止服务器。所以通过将主线程的名称设置为其他内容，我们也可以在从
    IDE 运行时获得这种良好的关闭行为。
- en: 'Additionally, we also need to set up logging for Jetty, which is the engine
    used by Unfiltered. Jetty has some prolific logging in its default configuration.
    To minimize the logging of Jetty to only log useful information, we need to add
    a `logback.xml` configuration file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要为 Jetty 设置日志记录，Jetty 是 Unfiltered 所使用的引擎。Jetty 在其默认配置中具有一些繁多的日志记录。为了将
    Jetty 的日志记录最小化，只记录有用的信息，我们需要添加一个 `logback.xml` 配置文件：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let''s start the server and use Postman to make a call to the Unfiltered
    service. To start this example, run `sbt runCH03-HelloUnfiltered` from the root
    directory of the sources:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动服务器并使用 Postman 调用 Unfiltered 服务。要启动这个示例，从源代码的根目录运行 `sbt runCH03-HelloUnfiltered`：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open up Postman, click on the collection name **Chapter 03**, and open the
    first request. Once you click on **Send**, you should see the response, **Hello
    Unfiltered**, being returned by the server:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Postman，点击集合名称 **第三章**，然后打开第一个请求。一旦你点击 **发送**，你应该会看到服务器返回的响应，**Hello Unfiltered**：
- en: '![Your first Unfiltered service](img/00023.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![您的第一个 Unfiltered 服务](img/00023.jpeg)'
- en: In the next section, we'll look a bit more closely at how Unfiltered uses pattern
    matching to map incoming requests to functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地看看 Unfiltered 是如何使用模式匹配将传入的请求映射到函数的。
- en: HTTP verb and URL matching
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 动词和 URL 匹配
- en: 'Unfiltered uses standard Scala pattern matching to determine what to do with
    a specific request. The following code shows how Unfiltered provides matchers
    for a number of simple REST calls:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Unfiltered 使用标准的 Scala 模式匹配来确定如何处理特定的请求。以下代码显示了 Unfiltered 为许多简单的 REST 调用提供匹配器的方式：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is a lot to see in this code fragment, so let''s start at the beginning.
    To create a REST API in Unfiltered, we need to create a `Plan` object. A `Plan`
    describes how to respond to specific requests. There are two different ways to
    create such a `Plan`. You can directly pass in a partial function to `unfiltered.filter.Planify`,
    like we did in the getting started example earlier in this chapter or explicitly
    extend from `unfiltered.filter.Plan` and set the `intent val` to your route configuration.
    In the rest of this chapter, we''ll use the latter approach since it allows us
    to combine API parts in an easy manner. Let''s start with the first set of matchers
    from the `taskApi` instance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中有很多东西可以看，所以让我们从开始的地方开始。要在 Unfiltered 中创建一个 REST API，我们需要创建一个 `Plan`
    对象。一个 `Plan` 描述了如何响应特定的请求。有两种不同的方式来创建这样的 `Plan`。你可以直接传递一个部分函数到 `unfiltered.filter.Planify`，就像我们在本章前面的入门示例中所做的那样，或者显式地扩展
    `unfiltered.filter.Plan` 并设置 `intent val` 为你的路由配置。在本章的其余部分，我们将使用后一种方法，因为它允许我们以简单的方式组合
    API 部分。让我们从 `taskApi` 实例的第一个匹配器集合开始：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we use standard pattern matching from Scala. These patterns
    will be checked against the current `HttpRequest` instance and will make use of
    a number of matchers provided by Unfiltered:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了 Scala 的标准模式匹配。这些模式将与当前的 `HttpRequest` 实例进行匹配，并使用 Unfiltered 提供的多个匹配器：
- en: '| Matcher | Description |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 匹配器 | 描述 |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GET` and the other HTTP verbs. | With this matcher, we match the HTTP verb
    of the request. Unfiltered provides the following number of standard matchers
    for this: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `CONNECT`, `OPTIONS`, `TRACE`,
    `PATCH`, `LINK`, and `UNLINK`.Should you have edge cases where you need to match
    other verbs, you can easily create your own matcher like this: `object WOW extends
    Method("WOW")` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `GET` 和其他 HTTP 动词。 | 使用此匹配器，我们可以匹配请求的 HTTP 动词。Unfiltered 为此提供了以下标准匹配器：`GET`、`POST`、`PUT`、`DELETE`、`HEAD`、`CONNECT`、`OPTIONS`、`TRACE`、`PATCH`、`LINK`
    和 `UNLINK`。如果您有需要匹配其他动词的边缘情况，您可以轻松创建自己的匹配器，例如：`object WOW extends Method("WOW")`
    |'
- en: '| `Path` | The next matcher we see is the `Path` matcher. With this matcher,
    you check whether you match the complete URL path. So in the preceding example,
    the first pattern only matches when the exact `/tasks` path is called. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `Path` | 我们接下来看到的匹配器是 `Path` 匹配器。使用此匹配器，您可以检查是否匹配完整的 URL 路径。因此，在前面的示例中，第一个模式仅在精确的
    `/tasks` 路径被调用时匹配。 |'
- en: '| `Seq` | If you want to extract path segments or match more flexibly on multiple
    path segments, you can use the `Seq` matcher. This matcher will check the URL
    on which the request was made, splits it into path segments, and check whether
    individual path segments match or extract path segments for further processing.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Seq` | 如果您想提取路径段或更灵活地在多个路径段上进行匹配，您可以使用 `Seq` 匹配器。此匹配器将检查请求所发生的 URL，将其拆分为路径段，并检查单个路径段是否匹配或提取路径段以进行进一步处理。
    |'
- en: 'So, in our API:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的 API 中：
- en: The first case matches a `GET` request on the `/tasks` path.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个案例匹配 `/tasks` 路径上的 `GET` 请求。
- en: The second case matches a `GET` request on the `/tasks/:id` path. The ID is
    passed into the function handling this case.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个案例匹配 `/tasks/:id` 路径上的 `GET` 请求。ID 将传递到处理此案例的函数中。
- en: The third case does the same as the second, but this time for a `DELETE` request.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个案例与第二个案例相同，但这次是为 `DELETE` 请求。 |
- en: 'Besides these matchers shown in this example, Unfiltered also provides the
    following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本例中显示的匹配器之外，Unfiltered 还提供了以下功能：
- en: '| Matcher | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 匹配器 | 描述 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `HTTP` and `HTTPS` | These two matchers allow you to check whether the request
    was received over an HTTP or HTTPS connection. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `HTTP` 和 `HTTPS` | 这两个匹配器允许您检查请求是否通过 HTTP 或 HTTPS 连接接收。 |'
- en: '| `Json`/`JavaScript`/`XML` and more | Unfiltered also allows you to check
    the Accepts header of a request. For instance, the JSON matcher will match when
    the `Accepts` header is `application/json` or a request is made on a URL with
    the extension `.js`, without an `Accepts` header. Unfiltered provides the following
    set of standard matchers of this type: `Json`, `JavaScript`, `AppJavaScript`,
    `Jsonp`, `Xml`, `Html`, and `Csv`. If you want to specify a new content-type matcher,
    you can do it like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Json`/`JavaScript`/`XML` 等 | Unfiltered 还允许您检查请求的 `Accepts` 标头。例如，当 `Accepts`
    标头为 `application/json` 或请求的 URL 有 `.js` 扩展名（没有 `Accepts` 标头）时，JSON 匹配器将匹配。Unfiltered
    为此类型提供了以下标准匹配器：`Json`、`JavaScript`、`AppJavaScript`、`Jsonp`、`Xml`、`Html` 和 `Csv`。如果您想指定新的内容类型匹配器，可以这样做：'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `HTTP_1_0`/`HTTP_1_1` | Check whether the protocol was made using HTTP version
    1.0 or HTTP version 1.1. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `HTTP_1_0`/`HTTP_1_1` | 检查是否使用了 HTTP 版本 1.0 或 HTTP 版本 1.1 的协议。 |'
- en: '| `Mime` | This matcher allows you to check whether the request conforms to
    a specific mime-type. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Mime` | 此匹配器允许您检查请求是否符合特定的 MIME 类型。 |'
- en: '| Any header | Unfiltered also provides matchers and extractors for a large
    set of other HTTP headers. There are too many to list here; for a complete overview
    look at the objects in the `headers.scala` file from the Unfiltered sources. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 任何标题 | Unfiltered 还提供了一组其他 HTTP 标头的匹配器和提取器。这里列出的太多，无法一一列举；要获取完整概述，请查看 Unfiltered
    源代码中的 `headers.scala` 文件中的对象。 |'
- en: '| `Params` | With this matcher-extractor, you can match a specific request
    parameter. We will show an example of this extractor in the next section. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Params` | 使用此匹配器提取器，您可以匹配特定的请求参数。我们将在下一节中展示此提取器的示例。 |'
- en: '| `RemoteAddr` | Specific matcher that checks whether the `XForwaredFor` header
    contains a trusted address. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `RemoteAddr` | 特定匹配器，用于检查 `XForwaredFor` 标头是否包含受信任的地址。 |'
- en: 'Let''s look back at the example, especially the `PUT` and `POST` calls on the
    `/tasks` URL. For these two routes, we used an alternative approach:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下示例，特别是对`/tasks` URL上的`PUT`和`POST`调用。对于这两个路由，我们使用了另一种方法：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we first match on the `Path("/tasks")` route and then use the matching
    request to determine what to do for the different verbs. This is a convenient
    way to handle multiple verbs that can be used to make a call to the same URL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先匹配`Path("/tasks")`路由，然后使用匹配的请求来确定对不同动词的处理。这是处理可以使用相同URL进行调用的多个动词的便捷方式。
- en: 'In this case, we can handle a `POST` and a `PUT` call, and just ignore any
    other call by returning `Pass`. When we return `Pass`, we just tell Unfiltered
    that this intent can''t handle the request. When Unfiltered can''t match a request
    with the current intent, it will just try the next. We''ve used this approach
    in our example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以处理`POST`和`PUT`调用，并忽略任何其他调用，通过返回`Pass`。当我们返回`Pass`时，我们只是告诉Unfiltered，这个意图无法处理请求。当Unfiltered无法匹配当前意图的请求时，它将尝试下一个。我们在示例中使用了这种方法：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In our `Plan`, we defined two intents: one that handled our API, the `taskAPI`
    intent, and one that could serve as fallback when the `taskAPI` intent didn''t
    match, aptly named `fallback` (we''ll explain more about this later in this chapter).
    The `fallback` intent returns the HTTP code, `NotImplemented`, with a message.
    By calling `taskApi.onPass(fallback)`, we tell Unfiltered that when the `taskAPI`
    intent returns a `Pass` result, it should try the `fallback` intent. The `fallback`
    intent can also configure an `onPass` result, and this way, you can easily chain
    and combine APIs.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`计划`中，我们定义了两个意图：一个处理我们的API，即`taskAPI`意图，另一个在`taskAPI`意图不匹配时可以作为后备，命名为`fallback`（我们将在本章后面详细解释这一点）。`fallback`意图返回带有消息的HTTP代码`NotImplemented`。通过调用`taskApi.onPass(fallback)`，我们告诉Unfiltered，当`taskAPI`意图返回`Pass`结果时，它应该尝试`fallback`意图。`fallback`意图还可以配置`onPass`结果，这样，你可以轻松地链式和组合API。
- en: 'To test this service, start it with the `sbt runCH03-runCH03Step1` command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此服务，请使用`sbt runCH03-runCH03Step1`命令启动它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The collection for **Chapter 03** in Postman provides you with a number of
    requests you can use to test this server. For instance, the call to create a new
    task looks similar to this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Postman中的**第03章**集合为您提供了许多可以用来测试此服务器的请求。例如，创建新任务的调用看起来像这样：
- en: '![HTTP verb and URL matching](img/00024.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP动词和URL匹配](img/00024.jpeg)'
- en: 'And when we hit the `fallback` route, we see the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问`fallback`路由时，我们看到以下截图：
- en: '![HTTP verb and URL matching](img/00025.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP动词和URL匹配](img/00025.jpeg)'
- en: So far, we've only focused on routing and matching requests. In the next section,
    we'll look at how we can access the request parameters and use the Scala `Future`
    object to create asynchronous responses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了路由和请求匹配。在下一节中，我们将探讨如何访问请求参数并使用Scala的`Future`对象创建异步响应。
- en: Extracting request parameters and using futures for asynchronous responses
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取请求参数和使用未来进行异步响应
- en: 'Now that we''ve got the basics covered, let''s see what we need to do to convert
    the incoming request parameters and body into our domain model (our case classes).
    In this section, we''ll take the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基础知识，让我们看看我们需要做什么来将传入的请求参数和正文转换为我们的领域模型（我们的案例类）。在本节中，我们将采取以下步骤：
- en: Convert the incoming request to a `Task` case class.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传入的请求转换为`Task`案例类。
- en: Store the converted `Task` in our dummy `TaskService`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将转换后的`Task`存储在我们的虚拟`TaskService`中。
- en: The `TaskService` object returns a `Future[Task]`; we will change the Unfiltered
    configuration to start handling requests asynchronously.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskService`对象返回`Future[Task]`；我们将更改Unfiltered配置以开始异步处理请求。'
- en: Let's start with the first part and look at the route configuration and how
    to convert the incoming request to a `Task` case class. The complete source for
    this example can be found in the `Step2.scala` file in the `rest-with-scala/chapter-03/src/main/scala/org/restwithscala/chapter3/steps/`
    directory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一部分开始，看看路由配置以及如何将传入的请求转换为`Task`案例类。此示例的完整源代码可以在`rest-with-scala/chapter-03/src/main/scala/org/restwithscala/chapter3/steps/`目录下的`Step2.scala`文件中找到。
- en: 'Let''s first show you the complete code and then we''ll look at the individual
    parts in more detail. Note that we''ve only implemented a part of the complete
    task API here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先展示完整的代码，然后我们将更详细地查看各个部分。请注意，我们在这里只实现了完整任务API的一部分：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first part we'll look at more closely is how to convert an incoming request
    to a `Task` case class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地探讨的第一部分是如何将一个传入的请求转换为`Task`案例类。
- en: Converting a request to a Task class
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将请求转换为Task类
- en: 'The following code fragment shows how we can convert a request to a `Task`
    case class with Unfiltered:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何使用Unfiltered将请求转换为`Task`案例类：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We defined a function named `requestToTask` which converts an incoming `HttpRequest`
    and an ID to a `Task`. The first step we take in this function is to create a
    custom extractor, based on a number of standard Unfiltered constructs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`requestToTask`的函数，该函数将传入的`HttpRequest`和一个ID转换为`Task`。在这个函数中，我们采取的第一步是创建一个基于多个标准Unfiltered构建的自定义提取器：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this function, we create a custom extractor by extending the `Extract` class
    provided by Unfiltered. This class has a constructor with two arguments. The first
    one is the name of the parameter we want to extract and the second is a function
    with the `Seq[String] => Option[T]` signature. The second parameter can be used
    to provide a set of predicates, which Unfiltered uses to check whether the value
    is available, and has the correct format. In this scenario, we used two predicates
    provided by Unfiltered. `Params.first` returns the first parameter value with
    the provided name or `None`, and the `Params.nonempty` returns `None` if the result
    from `Params.first` is empty, and returns `Some[String]` if it isn't. As you can
    see, we can use the `~>` operator to chain predicates together (this operator
    is just syntactic sugar for the `andThen` function).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们通过扩展Unfiltered提供的`Extract`类来创建一个自定义提取器。这个类有一个带有两个参数的构造函数。第一个参数是我们想要提取的参数名称，第二个参数是一个具有`Seq[String]
    => Option[T]`签名的函数。第二个参数可以用来提供一组断言，Unfiltered使用这些断言来检查值是否可用，并且格式是否正确。在这种情况下，我们使用了Unfiltered提供的两个断言。`Params.first`返回具有提供名称的第一个参数值或`None`，而`Params.nonempty`如果`Params.first`的结果为空，则返回`None`，如果不为空，则返回`Some[String]`。正如你所见，我们可以使用`~>`运算符来链接断言（这个运算符只是`andThen`函数的语法糖）。
- en: 'We now can use this extractor in our pattern matching logic:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的模式匹配逻辑中使用这个提取器：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This means that this pattern will only match if one of the provided parameters
    has the name `title` and isn''t empty. Out of the box Unfiltered provides the
    following constructs you can use when creating new matchers and extractors:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个模式只有在提供的参数中有一个名为`title`且不为空的情况下才会匹配。Unfiltered默认提供以下构建块，您可以在创建新的匹配器和提取器时使用：
- en: '| Predicate | Description |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 断言 | 描述 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `even` | This returns the parameter value if it can be converted to an integer
    and the result is even. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `even` | 如果参数值可以转换为整数并且结果是偶数，它将返回参数值。|'
- en: '| `odd` | This returns the parameter value if it can be converted to an integer
    and the result is odd. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `odd` | 如果参数值可以转换为整数并且结果是奇数，它将返回参数值。|'
- en: '| `nonempty` | This returns the parameter value if it isn''t empty. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `nonempty` | 如果参数值不为空，则返回参数值。|'
- en: '| `first` | This returns the first value of a parameter. For example, in the
    case of `?id=10&id=20`, it will return `10`. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `first` | 这返回参数的第一个值。例如，在`?id=10&id=20`的情况下，它将返回`10`。|'
- en: '| `int` | If the parameter value can be converted to an integer, it will return
    the integer value. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 如果参数值可以转换为整数，它将返回整数值。|'
- en: '| `long` | If the parameter value can be converted to a long, it will return
    the long value. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 如果参数值可以转换为长整型，它将返回长整数值。|'
- en: '| `float` | If the parameter value can be converted to a float, it will return
    the float value. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 如果参数值可以转换为浮点数，它将返回浮点数值。|'
- en: '| `double` | If the parameter value can be converted to a double, it will return
    the double value. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 如果参数值可以转换为双精度浮点数，它将返回双精度浮点数值。|'
- en: '| `trimmed` | This will use `String.trim` to trim the parameter value. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `trimmed` | 这将使用`String.trim`来修剪参数值。|'
- en: '| `~>` | This creates a sequence of predicates, for example, `first ~> nonempty
    ~> trimmed`. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `~>` | 这创建了一组断言，例如，`first ~> nonempty ~> trimmed`。|'
- en: At this point, we check whether we've got a non-empty title parameter, and if
    we do, we convert the incoming request to a `Task`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们检查是否有一个非空的标题参数，如果有，我们就将传入的请求转换为`Task`。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Unfiltered also provides a way you can use multiple extractors at the same
    time. With the `&` matcher, you can combine two extractors. The pattern will only
    match if both sides of the `&` matched succeed. For instance, we could check whether
    the parameters contain a non-empty title and an integer amount like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Unfiltered还提供了一种您可以同时使用多个提取器的方法。使用`&`匹配器，您可以组合两个提取器。模式只有在`&`两边的匹配都成功时才会匹配。例如，我们可以检查参数是否包含非空标题和一个整数值，如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And use it in a pattern, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用模式使用它，如下所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We'll see more of this in the section on validation later in this chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的验证部分看到更多关于此的内容。
- en: 'To finally convert the request into a `Task`, we just call the constructor
    directly, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要最终将请求转换为`Task`，我们只需直接调用构造函数，如下所示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we can convert a request to a `Task`, let's look at how we call this
    from our route and store it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将请求转换为`Task`，让我们看看我们如何从我们的路由调用它并将其存储。
- en: Storing a request in the TaskService
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在TaskService中存储请求
- en: 'To store the request in the `TaskService`, we have to call the `TaskService.insert`
    function. We use the following code to do that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要将请求存储在`TaskService`中，我们必须调用`TaskService.insert`函数。我们使用以下代码来完成：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When we receive a `POST` or `PUT` request on `/tasks`, we pass the request on
    to the `handleCreateTask` function. In this function, we convert the request to
    a `Task` using the code we discussed previously, and store it with the `TaskService.insert`
    function. For now, we'll just return the `toString` of the created `Task` if we
    converted and stored the `Task` successfully. If something went wrong, we return
    a simple error message, also a string. We then return the created `Task` or the
    error message using the `ResponseString` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`/tasks`上接收到`POST`或`PUT`请求时，我们将请求传递给`handleCreateTask`函数。在这个函数中，我们使用之前讨论的代码将请求转换为`Task`，并使用`TaskService.insert`函数将其存储。目前，如果我们成功转换并存储了`Task`，我们将只返回创建的`Task`的`toString`。如果出现问题，我们将返回一个简单的错误消息，也是一个字符串。然后我们使用`ResponseString`函数返回创建的`Task`或错误消息。
- en: The `handleCreateTask` function returns a `Future[String]` object, so what we
    have to do is make sure that our Unfiltered configuration can handle futures.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleCreateTask`函数返回一个`Future[String]`对象，所以我们必须确保我们的Unfiltered配置可以处理未来。'
- en: Configuring Unfiltered to work with futures
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Unfiltered以与未来一起工作
- en: 'Changing the configuration from a synchronous to an asynchronous model is very
    easy. The first thing we need to do is change the underlying server from Jetty
    to Netty. We need to do this because the asynchronous functionality is built on
    top of Netty, and thus, won''t work with Jetty. To use Netty, we need to add the
    following two dependencies to our SBT configuration:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置从同步模型更改为异步模型非常简单。我们首先需要做的是将底层服务器从Jetty更改为Netty。我们需要这样做是因为异步功能建立在Netty之上，因此不会与Jetty一起工作。要使用Netty，我们需要将以下两个依赖项添加到我们的SBT配置中：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we need to change the way we create our API:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更改我们创建API的方式：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead of extending from `unfiltered.filter.Plan`, we extend from `future.Plan`
    (with `ServerErrorResponse`, which you can use to handle exception in a generic
    way). If we work with futures, we also need to define the execution context we
    want to use. This is used by Unfiltered to run futures asynchronously. In this
    case, we just use the default global execution context. Note that we need to add
    the `io.netty.channel.ChannelHandler.Sharable` annotation to our API. If we don''t
    do this, Netty will block any incoming requests, and only one thread can access
    the API at the same time. Since we move our service to Netty, we also need to
    start the server in a slightly different way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是从`unfiltered.filter.Plan`扩展，而是从`future.Plan`（带有`ServerErrorResponse`，您可以用它以通用方式处理异常）。如果我们使用未来，我们还需要定义我们想要使用的执行上下文。这是Unfiltered用来异步运行未来的。在这种情况下，我们只是使用默认的全局执行上下文。请注意，我们需要在我们的API上添加`io.netty.channel.ChannelHandler.Sharable`注解。如果我们不这样做，Netty将阻止任何传入的请求，并且同一时间只有一个线程可以访问API。由于我们将我们的服务移至Netty，我们还需要以稍微不同的方式启动服务器：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last step we need to take to work with futures is to make sure that all
    our pattern match cases also return a `Future` object. We do this simply by wrapping
    the responses in a `Future`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是与未来一起工作，确保所有我们的模式匹配案例也返回一个`Future`对象。我们只需通过将响应包装在`Future`中即可完成此操作：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Most of the responses are explicitly wrapped in a `Future` object. For the `handleCreateTask`
    function, we already receive a `Future[String]` object, so just use `map` to convert
    it to the correct type using a `ResponseString` instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数响应都明确地封装在 `Future` 对象中。对于 `handleCreateTask` 函数，我们已接收到一个 `Future[String]`
    对象，因此只需使用 `map` 并通过一个 `ResponseString` 实例将其转换为正确的类型即可。
- en: As for all the examples, we've also provided a set of sample requests you can
    use to test this REST API. You can find the requests in the **Chapter 03** collection
    in Postman. The most interesting requests to play around with are **Step 02 –
    CreateTask**, **Step 02 – Create Task – Invalid**, and **Step 02 – Trigger Fallback**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有示例，我们还提供了一组您可以用来测试此 REST API 的样本请求。您可以在 Postman 的 **第 03 章** 收集中找到这些请求。最有趣的请求是
    **步骤 02 – 创建任务**、**步骤 02 – 创建任务 – 无效** 和 **步骤 02 – 触发回退**。
- en: Adding validation to parameter processing
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为参数处理添加验证
- en: So far, we haven't really validated the incoming request. We just checked whether
    a parameter was provided, and if not, completely failed the request. This works,
    but is a rather cumbersome way of validating input parameters. Luckily, Unfiltered
    provides an alternative way of validation by using something called directives.
    With a directive, you tell Unfiltered what you expect, for example, a parameter
    that can be converted to an int, and Unfiltered will either get the value or respond
    with an appropriate response message. In other words, with a directive, you define
    a set of criteria the request must fulfill.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有真正验证传入的请求。我们只是检查是否提供了参数，如果没有，就完全拒绝请求。这可行，但验证输入参数的方式相当繁琐。幸运的是，Unfiltered
    通过使用称为指令的东西提供了一种替代的验证方式。使用指令，您告诉 Unfiltered 您期望什么，例如，一个可以转换为 int 的参数，Unfiltered
    将获取该值或返回适当的响应消息。换句话说，使用指令，您定义了一组请求必须满足的标准。
- en: Introducing directives
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍指令
- en: 'Before we look at how we can use a directive in our scenario, let''s look at
    how you can use a directive in your code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看如何在我们的场景中使用指令之前，让我们看看您如何在代码中使用指令：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this intent, we use `Directive.Intent` to indicate that we want to create
    an intent that uses directives to process the request. In this sample, `Accepts.Json`,
    `GET`, and `data.as.Option[Int].named("amount")` are all directives. When one
    of the directives fails, an appropriate error response is returned automatically.
    With directives, you can pretty much move your matcher and extractor logic to
    a set of directives.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意图中，我们使用 `Directive.Intent` 来表示我们想要创建一个使用指令处理请求的意图。在这个示例中，`Accepts.Json`、`GET`
    和 `data.as.Option[Int].named("amount")` 都是指令。当其中一个指令失败时，会自动返回适当的错误响应。使用指令，您几乎可以将您的匹配器和提取器逻辑移动到一组指令中。
- en: 'Out of the box, Unfiltered comes with a number of directives, which automatically
    return a response when they don''t match:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unfiltered 包含一系列指令，当它们不匹配时将自动返回响应：
- en: '| Directive | Description |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GET`, `POST`, and the other HTTP verbs | You can match on all the methods.
    If a method doesn''t match, a `MethodNotAllowed` response is returned. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `GET`、`POST` 以及其他 HTTP 动词 | 您可以匹配所有方法。如果方法不匹配，将返回 `MethodNotAllowed` 响应。
    |'
- en: '| `Accepts.Json` | All the `Accepts.Accepting` definitions are supported. If
    one of these should fail, you get a `NotAcceptable` response. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Accepts.Json` | 所有 `Accepts.Accepting` 定义都受支持。如果其中之一失败，您将收到 `NotAcceptable`
    响应。 |'
- en: '| `QueryParams` | Get all the query parameters from the request. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `QueryParams` | 从请求中获取所有查询参数。 |'
- en: '| `Params` | You can check whether a single parameter is available. If not,
    a `BadRequest` response is returned. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `Params` | 您可以检查单个参数是否可用。如果没有，将返回 `BadRequest` 响应。 |'
- en: '| `data.as` | The `data.as` directive allows you to get a parameter and convert
    it to a specific value. It provides standard directives to convert a parameter
    to: BigDecimal, BigInt, Double, Float, Int, Long, and String. Besides that, it
    also allows you to specify whether a value is an option or required. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `data.as` | `data.as` 指令允许您获取一个参数并将其转换为特定值。它提供标准指令以将参数转换为：BigDecimal、BigInt、Double、Float、Int、Long
    和 String。除此之外，它还允许您指定一个值是可选的还是必需的。 |'
- en: 'Let''s look a bit closer at the `data.as` directive since that is the most
    interesting one when trying to validate input. To use this directive, we first
    define an implicit function like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `data.as` 指令，因为当尝试验证输入时，这是最有趣的一个。要使用此指令，我们首先定义一个隐式函数，如下所示：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And use it from the `for` comprehension like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 并像这样从 `for` 推导中使用它：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the request parameter with the name `amount` is present and can be converted
    to an int, we''ll retrieve that value. If it isn''t present, nothing will happen,
    and if it can''t be converted to an int, the specified `BadRequest` message will
    be returned. We can also make it `Optional` by just requesting `data.as.Option[Int]`
    instead. Having a value as an option is nice, but sometimes you want to make sure
    that a specific query parameter is always present. For that, we can use `Required`.
    To use `Required`, we first have to add another `implicit` function to define
    what happens when a required field isn''t present:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This means that we return a `BadRequest` message with the specified response
    when a `Required` field is missing. To use the `Required` field, we simply change
    `data.as.Int` to `data.as.Required[Int]`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, Unfiltered will first check if the field is present, and if it is, will
    check whether it can be converted to an int. When one of the checks fails, the
    correct response message will be returned.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Adding search functionality to our API
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s move on to our example. For this scenario, we''ll add a `search`
    function to our API. This `search` function will allow you to search on the status
    and the text of a task, and return a list of tasks that match. Let''s first look
    at the complete code before we dive into the individual parts:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Lots of code and some of it might look a bit strange. In the following sections,
    we'll see why we did it this way.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Directives and working with futures
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into the directives, you might notice some additional code regarding
    d2\. For this example, we needed to use the `Directives2` library from [https://github.com/shiplog/directives2/](https://github.com/shiplog/directives2/)
    so that we can correctly work combining futures and directives. The standard directives,
    as provided by Unfiltered, don't support asynchronous plans and only allow you
    to use the synchronous Jetty approach. With the `Directives2` directives, we can
    work with futures and use one of the available asynchronous plans provided by
    Unfiltered.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, some glue code required for this to get it to work. The
    following changes needed to be made to the previous step to make directives work
    nicely together with futures:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Move from `future.Plan` to `async.Plan`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The d2 directives support the `async.Plan` class, but don''t support the `future.Plan`.
    Luckily, this doesn''t change the rest of the code for us. The next step is to
    import the d2 classes and objects:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With these imports, we get the ability to work with futures as directives,
    and it allows us to convert standard Unfiltered directives to d2 directives. The
    next step to do is to use the `d2.Async.Mapping` object to glue our new asynchronous
    directives to our `async.Plan`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this setup, we''ll just pass any request we receive to a partial function,
    which we define like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now whenever we receive a request on the `/search` path, we pass it on to the
    `handleSearchSingleError` function. The final step we do is that we create a simple
    helper method to make converting our standard directives to d2 directives:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When this `implicit` is in scope, we can just call `toD2` on our normal directives
    so that they can work correctly with the ones from the d2 library.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation to the request parameters
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve got the d2 stuff out of the way, let''s look at the definition
    of our validations. We''ve defined all our directives implicitly in a `Conversions`
    object:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we define three implicit values—`required` checks whether a value is
    present, `toStringInterpreter` tries to convert a parameter to a string, and `inStatus`
    checks whether a string is one of the specific set of values. If one of them fails,
    the `fail` function is called and an error is returned. Here, however, we don''t
    directly return the error as an `HttpResponse`, but return it as a `BadParam`
    class. This `BadParam` case class serves as a collector of errors and allows a
    standard way to report one or more errors. In the next section, we''ll come back
    to this. For now, we''ll just report the first error we see. We do this by setting
    up a `for` comprehension like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This `for` comprehension works just like any normal one. First, we check whether
    the status query parameter is valid. If it is, we get the text value and then
    we use both these values to search through the `TaskService`, and finally return
    the result from the `TaskService` as a string. One remark here is the `successValue`
    function we call on the `Future` returned from the `TaskService`. This is a d2
    specific call, which transforms the `Future` into a directive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open Postman and first make a request with an invalid status:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding validation to the request parameters](img/00026.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: As you can see, the error message shows what we expect. However, as you might
    have noticed, we also didn't enter a text value, but the error message didn't
    show that. The reason is that our `for` comprehension stops at the first error.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Unfiltered provides a way to combine errors. All we have to do is
    change our `for` loop to the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By using the `&` operator we can combine directives together. Now each part
    of the combined directives will log its errors using the `BadParam` case class,
    which will respond with all the errors it has collected. You can see how this
    works in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding validation to the request parameters](img/00027.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw some of the most important aspects of Unfiltered. You
    learned how to handle requests, use matchers and extractors to route requests,
    and access parameters and path segments. You also learned that Unfiltered provides
    different processing models, synchronous and asynchronous, and how to run your
    service either on top of Jetty or on Netty. In the last section, we explored how
    directives in Unfiltered can be used to extract parameters in a more powerful
    way and the additional steps you need to take to use those in an asynchronous
    manner.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Unfiltered的一些最重要的方面。你学习了如何处理请求，使用匹配器和提取器来路由请求，以及如何访问参数和路径段。你还了解到Unfiltered提供了不同的处理模型，即同步和异步，以及如何在Jetty或Netty之上运行你的服务。在最后一节中，我们探讨了如何在Unfiltered中使用指令以更强大的方式提取参数，以及在使用异步方式时需要采取的额外步骤。
- en: All in all, as you saw, Unfiltered is a very flexible framework, which is easily
    extensible, and gives you full control over the response-request cycle.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，正如你所见，Unfiltered是一个非常灵活的框架，易于扩展，并让你完全控制响应-请求周期。
