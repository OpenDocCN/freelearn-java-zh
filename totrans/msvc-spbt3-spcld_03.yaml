- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Set of Cooperating Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build our first couple of microservices. We will learn
    how to create cooperating microservices with minimalistic functionality. In upcoming
    chapters, we will add more and more functionality to these microservices. By the
    end of this chapter, we will have a RESTful API exposed by a composite microservice.
    The composite microservice will call three other microservices using their RESTful
    APIs to create an aggregated response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the microservice landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating skeleton microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a composite microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the APIs manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding automated tests of microservices in isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding semi-automated tests to a microservice landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For instructions on how to install tools used in this book and how to access
    the source code for this book, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter03`.
    With the tools and source code in place, we can start learning about the system
    landscape of microservices that we will create in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the microservice landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *Introduction to Microservices*, we were briefly introduced
    to the microservice-based system landscape that we will use throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The microservice landscape'
  prefs: []
  type: TYPE_NORMAL
- en: It consists of three core microservices, the **product, review**, and **recommendation**
    services, all of which deal with one type of resource, and a composite microservice
    called the **Product Composite** service, which aggregates information from the
    three core services.
  prefs: []
  type: TYPE_NORMAL
- en: Information handled by the microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep the source code examples in this book easy to understand, they have
    a minimal amount of business logic. The information model for the business objects
    they process is kept minimal for the same reason. In this section, we will go
    through the information that’s handled by each microservice, including infrastructure-related
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The product service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The product service manages product information and describes each product
    with the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Product ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The review service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The review service manages product reviews and stores the following information
    about each review:'
  prefs: []
  type: TYPE_NORMAL
- en: Product ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommendation service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The recommendation service manages product recommendations and stores the following
    information about each recommendation:'
  prefs: []
  type: TYPE_NORMAL
- en: Product ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product composite service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The product composite service aggregates information from the three core services
    and presents information about a product as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Product information, as described in the product service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of product reviews for the specified product, as described in the review
    service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of product recommendations for the specified product, as described in
    the recommendation service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure-related information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we start to run our microservices as containers that are managed by the
    infrastructure (first Docker and later on Kubernetes), it will be of interest
    to track which containers actually responded to our requests. As a simple solution,
    a `serviceAddress` attribute has been added to all responses, formatted as `hostname/ip-address:port`.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 18*, *Using a Service Mesh to Improve Observability and Management*,
    and *Chapter 19*, *Centralized Logging with the EFK Stack*, we will learn about
    more powerful solutions to track requests that are processed by the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily replacing service discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since, at this stage, we don’t have any service discovery mechanism in place,
    we will run all microservices on `localhost` and use hardcoded port numbers for
    each microservice. We will use the following ports:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The product composite service: `7000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The product service: `7001`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The review service: `7002`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The recommendation service: `7003`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will get rid of the hardcoded ports later when we start using Docker and
    Kubernetes!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have been introduced to the microservices we are going to
    create and the information that they will handle. In the next section, we will
    use Spring Initializr to create skeleton code for the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Generating skeleton microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it’s time to see how we can create projects for our microservices. The final
    result for this topic can be found in the `$BOOK_HOME/Chapter03/1-spring-init`
    folder. To simplify setting up the projects, we will use **Spring Initializr**
    to generate a skeleton project for each microservice. A skeleton project contains
    the necessary files for building the project, along with an empty `main` class
    and test class for the microservice. After that, we will see how we can build
    all our microservices with one command using multi-project builds in the build
    tool that we will use, Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Initializr to generate skeleton code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with developing our microservices, we will use a tool called
    Spring Initializr to generate skeleton code for us. Spring Initializr is provided
    by the Spring team and can be used to configure and generate new Spring Boot applications.
    The tool helps developers to choose additional Spring modules to be used by the
    application and ensures that dependencies are configured to use compatible versions
    of the selected modules. The tool supports the use of either Maven or Gradle as
    a build system and can generate source code for either Java, Kotlin, or Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: It can either be invoked from a web browser using the URL [https://start.spring.io/](https://start.spring.io/)
    or using a command-line tool, `spring init`. To make it easier to reproduce the
    creation of the microservices, we will use the command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each microservice, we will create a Spring Boot project that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses Gradle as a build tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generates code for Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages the project as a fat JAR file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brings in dependencies for the `Actuator` and `WebFlux` Spring modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is based on Spring Boot v3.0.4 (which depends on Spring Framework v6.0.6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Boot Actuator** enables a number of valuable endpoints for management
    and monitoring. We will see them in action later on. **Spring WebFlux** will be
    used here to create our RESTful APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the skeleton code for our microservices, we need to run the following
    command for `product-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you want to learn more about the `spring init` CLI, you can run the `spring
    help init` command. To see what dependencies you can add, run the `spring init
    --list` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create the four projects on your own instead of using the source
    code in this book’s GitHub repository, try out `$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating our four projects using `create-projects.bash`, we will have
    the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For each project, we can list the created files. Let’s do this for the `product-service`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Listing the files we created for product-service'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Initializr created a number of files for Gradle, a `.gitignore` file,
    and three Spring Boot files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductServiceApplication.java`, our main application class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application.properties`, an empty property file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductServiceApplicationTests.java`, a test class that’s been configured
    to run tests on our Spring Boot application using JUnit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `main` application class, `ProductServiceApplication.java`, looks as we’d
    expect based on the *The magic @SpringBootApplication annotation* section in the
    previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The test class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `@SpringBootTest` annotation will initialize our application in the same
    way that `@SpringBootApplication` does when running the application; that is,
    the Spring application context will be set up before the tests are executed using
    component scanning and auto-configuration, as described in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also look at the most important Gradle file, `build.gradle`. The content
    of this file describes how to build the project – for example, how to resolve
    dependencies and compile, test, and package the source code. The Gradle file starts
    by listing what plugins to apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The declared plugins are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `java` plugin adds the Java compiler to the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plugins `org.springframework.boot` and `io.spring.dependency-management`
    are declared, which together ensure that Gradle will build a fat JAR file and
    that we don’t need to specify any explicit version numbers on our Spring Boot
    starter dependencies. Instead, they are implied by the version of the `org.springframework.boot`
    plugin, that is, 3.0.4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the rest of the build file, we basically declare a group name and version
    for our project, Java version, and its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Some notes regarding the dependencies used and the final test declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are, as with the preceding plugins, fetched from the central Maven
    repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies are set up as specified in the Actuator and WebFlux modules, along
    with a couple of useful test dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, JUnit is configured to be used to run our tests in the Gradle builds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can build each microservice separately with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note how we use the `gradlew` executables that are created by Spring Initializr;
    that is, we don’t need to have Gradle installed!
  prefs: []
  type: TYPE_NORMAL
- en: The first time we run a command with `gradlew`, it will download Gradle automatically.
    The Gradle version that’s used is determined by the `distributionUrl` property
    in the `gradle/wrapper/gradle-wrapper.properties` files.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up multi-project builds in Gradle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make it a bit simpler to build all the microservices with one command, we
    can set up a multi-project build in Gradle. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the `settings.gradle` file, which describes what projects
    Gradle should build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we copy the Gradle executable files that were generated from one of the
    projects so that we can reuse them for the multi-project builds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We no longer need the generated Gradle executable files in each project, so
    we can remove them with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result should be similar to the code you can find in the folder `$BOOK_HOME/Chapter03/1-spring-init`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can build all the microservices with one command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you haven’t run the preceding commands, you can simply go to the book’s
    source code and build the microservices from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Output upon successful build'
  prefs: []
  type: TYPE_NORMAL
- en: With skeleton projects for the microservices created using Spring Initializr
    and successfully built using Gradle, we are ready to add some code to the microservices
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: From a DevOps perspective, a multi-project setup might not be preferred. Instead,
    to enable each microservice to have its own build and release cycle, setting up
    a separate build pipeline for each microservice project would probably be preferred.
    However, for the purposes of this book, we will use the multi-project setup to
    make it easier to build and deploy the whole system landscape with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: Adding RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have projects set up for our microservices, let’s add some RESTful
    APIs to our three core microservices!
  prefs: []
  type: TYPE_NORMAL
- en: The final result of this and the remaining topics in this chapter can be found
    in the `$BOOK_HOME/Chapter03/2-basic-rest-services` folder.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will add two projects (`api` and `util`) that will contain code that
    is shared by the microservice projects, and then we will implement the RESTful
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an API and a util project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add an `api` project, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will set up a separate Gradle project where we can place our API definitions.
    We will use Java interfaces in order to describe our RESTful APIs and model classes
    to describe the data that the API uses in its requests and responses. To describe
    what types of errors can be returned by the API, a number of exception classes
    are also defined. Describing a RESTful API in a Java interface instead of directly
    in the Java class is, to me, a good way of separating the API definition from
    its implementation. We will further extend this pattern later in this book when
    we add more API information in the Java interfaces to be exposed in an OpenAPI
    specification. See *Chapter 5*, *Adding an API Description Using OpenAPI*, for
    more information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is debatable whether it is a good practice to store API definitions for a
    group of microservices in a common API module. It could potentially cause undesired
    dependencies between the microservices, resulting in monolithic characteristics,
    for example, causing a more complex and slow development process. To me, it is
    a good choice for microservices that are part of the same delivery organization,
    that is, whose releases are governed by the same organization (compare this to
    a **bounded context** in **domain-driven design**, where our microservices are
    placed in a single bounded context). As already discussed in *Chapter 1*, *Introduction
    to Microservices*, microservices within the same bounded context need to have
    API definitions that are based on a common information model, so storing these
    API definitions in the same API module doesn’t add any undesired dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a `util` project that can hold some helper classes that
    are shared by our microservices, for example, for handling errors in a uniform
    way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, from a DevOps perspective, it would be preferable to build all the projects
    in their own build pipeline and have version-controlled dependencies for the `api`
    and `util` projects in the microservice projects, that is, so that each microservice
    can choose what versions of the `api` and `util` projects to use. But to keep
    the build and deployment steps simple in the context of this book, we will make
    the `api` and `util` projects part of the multi-project build.
  prefs: []
  type: TYPE_NORMAL
- en: The api project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `api` project will be packaged as a library; that is, it won’t have its
    own `main` application class. Unfortunately, Spring Initializr doesn’t support
    the creation of library projects. Instead, a library project has to be created
    manually from scratch. The source code for the API project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/api`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of a library project is the same as for an application project,
    except that we no longer have the `main` application class, as well as some minor
    differences in the `build.gradle` file. The Gradle plugin `org.springframework.boot`
    is replaced with an `implementation platform` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to retain Spring Boot dependency management while we are replacing
    the construction of a fat JAR in the build step with the creation of a normal
    JAR file that only contains the project’s own classes and property files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java files in the `api` project for our three core microservices are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The structure of the Java classes looks very similar for the three core microservices,
    so we will only go through the source code for the `product` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will look at the `ProductService.java` Java interface, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java interface declaration works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `product` service only exposes one API method, `getProduct()` (we will extend
    the API later in this book, in *Chapter 6,* *Adding Persistence*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To map the method to an HTTP `GET` request, we use the `@GetMapping` Spring
    annotation, where we specify what URL path the method will be mapped to (`/product/{productId}`)
    and what format the response will be in– in this case, JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `{productId}` part of the path maps to a path variable named `productId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `productId` method parameter is annotated with `@PathVariable`, which will
    map the value that’s passed in the HTTP request to the parameter. For example,
    an HTTP `GET` request to `/product/123` will result in the `getProduct()` method
    being called with the `productId` parameter set to `123`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method returns a `Product` object, a plain POJO-based model class with
    the member variables corresponding to attributes for `Product`, as described at
    the start of this chapter. `Product.java` looks as follows (with constructors
    and getter methods excluded):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This type of POJO class is also known as a **Data Transfer Object** (**DTO**)
    as it is used to transfer data between the API implementation and the caller of
    the API. When we get to *Chapter 6*, *Adding Persistence*, we will look at another
    type of POJO that can be used to describe how data is stored in the databases,
    also known as entity objects.
  prefs: []
  type: TYPE_NORMAL
- en: The API project also contains the exception classes `InvalidInputException`
    and `NotFoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: The util project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `util` project will be packaged as a library in the same way as the `api`
    project. The source code for the `util` project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/util`.
    The project contains the following utility classes: `GlobalControllerExceptionHandler`,
    `HttpErrorInfo`, and `ServiceUtil`.'
  prefs: []
  type: TYPE_NORMAL
- en: Except for the code in `ServiceUtil.java`, these classes are reusable utility
    classes that we can use to map Java exceptions to proper HTTP status codes, as
    described in the later section *Adding error handling*. The main purpose of `ServiceUtil.java`
    is to find out the hostname, IP address, and port used by the microservice. The
    class exposes a method, `getServiceAddress()`, that can be used by the microservices
    to find their hostname, IP address, and port, as described in the previous section,
    *Infrastructure-related information*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can start to implement our APIs in the core microservices!
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation looks very similar for the three core microservices, so
    we will only go through the source code for the `product` service. You can find
    the other files in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices`.
    Let’s see how we go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the `api` and `util` projects as dependencies to our `build.gradle`
    file, in the `product-service` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable Spring Boot’s autoconfiguration feature to detect Spring Beans in
    the `api` and `util` projects, we also need to add a `@ComponentScan` annotation
    to the main application class, which includes the packages of the `api` and `util`
    projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create our service implementation file, `ProductServiceImpl.java`,
    in order to implement the Java interface, `ProductService`, from the `api` project
    and annotate the class with `@RestController` so that Spring will call the methods
    in this class according to the mappings specified in the `Interface` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To be able to use the `ServiceUtil` class from the `util` project, we will
    inject it into the constructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can implement the API by overriding the `getProduct()` method from
    the interface in the `api` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we aren’t currently using a database, we simply return a hardcoded response
    based on the input of `productId`, along with the service address supplied by
    the `ServiceUtil` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the final result, including logging and error handling, see `ProductServiceImpl.java`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we also need to set up some runtime properties – what port to use
    and the desired level of logging. This is added to the property file `application.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the empty `application.properties` file generated by Spring Initializr
    has been replaced by a YAML file, `application.yml`. YAML files provide better
    support for grouping related properties compared to `.properties` files. See the
    log level setting above as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try out the `product` service on its own. Build and start the microservice
    with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wait until the following is printed in the Terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_04.png)Figure 3.4:
    Starting ProductServiceApplication'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a test call to the `product` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It should respond with something similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B19825_03_05.png)Figure 3.5: Expected response to test call'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, stop the `product` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now built, run, and tested our first single microservice. In the next
    section, we will implement the composite microservice that will use the three
    core microservices we’ve created so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Spring Boot v2.5.0, two JAR files are created when running the
    `./gradlew build` command: the ordinary JAR file, plus a plain JAR file containing
    only the class files resulting from compiling the Java files in the Spring Boot
    application. Since we don’t need the new plain JAR file, its creation has been
    disabled to make it possible to refer to the ordinary JAR file using a wildcard
    when running the Spring Boot application, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of the new plain JAR file has been disabled by adding the following
    lines to the `build.gradle` file for each microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For further details, see [https://docs.spring.io/spring-boot/docs/3.0.4/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives](https://docs.spring.io/spring-boot/docs/3.0.4/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a composite microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it’s time to tie things together by adding the composite service that will
    call the three core services!
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the composite services is divided into two parts: an
    integration component that handles the outgoing HTTP requests to the core services
    and the composite service implementation itself. The main reason for this division
    of responsibility is that it simplifies automated unit and integration testing;
    we can test the service implementation in isolation by replacing the integration
    component with a mock.'
  prefs: []
  type: TYPE_NORMAL
- en: As we will see later on in this book, this division of responsibility will also
    make it easier to introduce a circuit breaker!
  prefs: []
  type: TYPE_NORMAL
- en: Before we look into the source code of the two components, we need to take a
    look at the API classes that the composite microservices will use and also learn
    about how runtime properties are used to hold address information for the core
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The full implementation of both the integration component and the implementation
    of the composite service can be found in the Java package `se.magnus.microservices.composite.product.services`.
  prefs: []
  type: TYPE_NORMAL
- en: API classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at the classes that describe the API of
    the composite component. They can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/api`.
    The following are the API classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java interface class `ProductCompositeService.java` follows the same pattern
    that’s used by the core services and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The model class `ProductAggregate.java` is a bit more complex than the core
    models since it contains fields for lists of recommendations and reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The remaining API classes are plain POJO-based model objects and have the same
    structure as the model objects for the core APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid hardcoding the address information for the core services into the
    source code of the composite microservice, the latter uses a property file where
    information on how to find the core services is stored. The property file, `application.yml`,
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will, as already noted, be replaced by a service discovery
    mechanism later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The integration component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the first part of the implementation of the composite microservice,
    the integration component, `ProductCompositeIntegration.java`. It is declared
    as a Spring Bean using the `@Component` annotation and implements the three core
    services’ API interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The integration component uses a helper class in the Spring Framework, `RestTemplate`,
    to perform the actual HTTP requests to the core microservices. Before we can inject
    it into the integration component, we need to configure it. We do that in the
    `main` application class, `ProductCompositeServiceApplication.java`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A `RestTemplate` object is highly configurable, but we’ll leave it with its
    default values for now.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Spring WebFlux* section in *Chapter 2,* *Introduction to Spring Boot*,
    we introduced the reactive HTTP client, `WebClient`. Using `WebClient` instead
    of `RestTemplate` in this chapter would require all source code where `WebClient`
    is used to also be reactive, including the declaration of the RESTful API in the
    API project and the source code in the composite microservice. In *Chapter 7*,
    *Developing Reactive Microservices*, we will learn how to change the implementation
    of our microservices to follow a reactive programming model. As one of the steps
    in that update, we will replace the `RestTemplate` helper class with the `WebClient`
    class. But until we have learned about reactive development in Spring, we will
    use the `RestTemplate` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now inject the `RestTemplate`, along with a JSON `mapper`, which is
    used for accessing error messages in case of errors, and the configuration values
    that we have set up in the property file. Let’s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The objects and configuration values are injected into the constructor as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The body of the constructor stores the injected objects and builds the URLs
    based on the injected values, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the integration component implements the API methods for the three
    core services by using `RestTemplate` to make the actual outgoing calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Some interesting notes regarding the methods implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: For the `getProduct()` implementation, the `getForObject()` method can be used
    in `RestTemplate`. The expected response is a `Product` object. It can be expressed
    in the call to `getForObject()` by specifying the `Product.class` class that `RestTemplate`
    will map the JSON response to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the calls to `getRecommendations()` and `getReviews()`, a more advanced
    method, `exchange()`, has to be used. The reason for this is the automatic mapping
    from a JSON response to a model class that `RestTemplate` performs. The `getRecommendations()`
    and `getReviews()` methods expect a generic list in the responses, that is, `List<Recommendation>`
    and `List<Review>`. Since generics don’t hold any type of information at runtime,
    we can’t specify that the methods expect a generic list in their responses. Instead,
    we can use a helper class from the Spring Framework, `ParameterizedTypeReference`,
    which is designed to resolve this problem by holding the type information at runtime.
    This means that `RestTemplate` can figure out what class to map the JSON responses
    to. To utilize this helper class, we have to use the more involved `exchange()`
    method instead of the simpler `getForObject()` method on `RestTemplate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Composite API implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we will look at the last piece of the implementation of the composite
    microservice: the API implementation class `ProductCompositeServiceImpl.java`.
    Let’s go through it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that we did for the core services, the composite service implements
    its API interface, `ProductCompositeService`, and is annotated with `@RestController`
    to mark it as a REST service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The implementation class requires the `ServiceUtil` bean and its own integration
    component, so they are injected into its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the API method is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The integration component is used to call the three core services, and a helper
    method, `createProductAggregate()`, is used to create a response object of the
    `ProductAggregate` type based on the responses from the calls to the integration
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the helper method, `createProductAggregate()`, is quite
    lengthy and not very important and so has been omitted from this chapter; however,
    it can be found in this book’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: The full implementation of both the integration component and the composite
    service can be found in the Java package `se.magnus.microservices.composite.product.services`.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the implementation of the composite microservice from a functional
    point of view. In the next section, we will see how we handle errors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling errors in a structured and well-thought-out way is essential in a microservice
    landscape where a large number of microservices communicate with each other using
    synchronous APIs, for example, using HTTP and JSON. It is also important to separate
    protocol-specific handling of errors, such as HTTP status codes, from the business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: It could be argued that a separate layer for the business logic should be added
    when implementing the microservices. This should ensure that business logic is
    separated from the protocol-specific code, making it easier both to test and reuse.
    To avoid unnecessary complexity in the examples provided in this book, we have
    left out a separate layer for business logic, so the microservices implement their
    business logic directly in the `@RestController` components.
  prefs: []
  type: TYPE_NORMAL
- en: I have created a set of Java exceptions in the `util` project that are used
    by both the API implementations and the API clients, initially `InvalidInputException`
    and `NotFoundException`. Look into the Java package `se.magnus.util.exceptions`
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: The global REST controller exception handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To separate protocol-specific error handling from the business logic in the
    REST controllers, that is, the API implementations, I have created a utility class,
    `GlobalControllerExceptionHandler.java`, in the `util` project, which is annotated
    as `@RestControllerAdvice`.
  prefs: []
  type: TYPE_NORMAL
- en: For each Java exception that the API implementations throw, the utility class
    has an exception handler method that maps the Java exception to a proper HTTP
    response, that is, with a proper HTTP status and HTTP response body.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if an API implementation class throws `InvalidInputException`,
    the utility class will map it to an HTTP response with the status code set to
    `422` (`UNPROCESSABLE_ENTITY`). The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, `NotFoundException` is mapped to a `404` (`NOT_FOUND`) HTTP
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a REST controller throws any of these exceptions, Spring will use the
    utility class to create an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Spring itself returns the HTTP status code `400` (`BAD_REQUEST`) when
    it detects an invalid request, for example, if the request contains a non-numeric
    product ID (`productId` is specified as an integer in the API declaration).
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code of the utility class, see `GlobalControllerExceptionHandler.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in API implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'API implementations use the exceptions in the `util` project to signal errors.
    They will be reported back to the REST client as HTTPS status codes indicating
    what went wrong. For example, the `Product` microservice implementation class,
    `ProductServiceImpl.java`, uses the `InvalidInputException` exception to return
    an error that indicates invalid input, as well as the `NotFoundException` exception
    to tell us that the product that was asked for does not exist. The code looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Since we currently aren’t using a database, we have to simulate when to throw
    `NotFoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in the API client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The API client, that is, the integration component of the `Composite` microservice,
    does the reverse; it maps the `422` (`UNPROCESSABLE_ENTITY`) HTTP status code
    to `InvalidInputException` and the `404` (`NOT_FOUND`) HTTP status code to `NotFoundException`.
    See the `getProduct()` method in `ProductCompositeIntegration.java` for the implementation
    of this error-handling logic. The source code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The error handling for `getRecommendations()` and `getReviews()` in the integration
    component is a bit more relaxed – classed as best-effort, meaning that if it succeeds
    in getting product information but fails to get either recommendations or reviews,
    it is still considered to be okay. However, a warning is written to the log.
  prefs: []
  type: TYPE_NORMAL
- en: For details, see `ProductCompositeIntegration.java`.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the implementation of both the code and composite microservices.
    In the next section, we will test the microservices and the API that they expose.
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That concludes the implementation of our microservices. Let’s try them out
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build and start the microservices as background processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `curl` to call the composite API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, build and start up each microservice as a background process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build completes, we can launch our microservices as background processes
    to the Terminal process with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of log messages will be written to the Terminal, but after a few seconds,
    things will calm down and we will find the following messages written to the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Log messages after applications start'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that they are all ready to receive requests. Try this out with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After some log output, we will get a JSON response that looks something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: JSON response after the request'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the JSON response pretty-printed, you can use the `jq` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output (some details have been replaced by `...`
    for increased readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Pretty-printed JSON response'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to, you can also try out the following commands to verify that
    the error handling works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can shut down the microservices with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you are using an IDE such as Visual Studio Code with Spring Tool Suite, you
    can use their support for the Spring Boot Dashboard to start and stop your microservices
    with one click. For instructions on how to install Spring Tool Suite, see [https://github.com/spring-projects/sts4/wiki/Installation](https://github.com/spring-projects/sts4/wiki/Installation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the use of the Spring Boot Dashboard in Visual
    Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Spring Boot Dashboard in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to manually start, test, and stop the system
    landscape of cooperating microservices. These types of tests are time-consuming,
    so they clearly need to be automated.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, we will take our first steps toward learning how to
    automate testing, testing both a single microservice in isolation and a whole
    system landscape of cooperating microservices. Throughout this book, we will improve
    how we test our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Adding automated microservice tests in isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we wrap up the implementation, we also need to write some automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have much business logic to test at this time, so we don’t need to
    write any unit tests. Instead, we will focus on testing the APIs that our microservices
    expose; that is, we will start them up in integration tests with their embedded
    web server and then use a test client to perform HTTP requests and validate the
    responses. With Spring WebFlux comes a test client, `WebTestClient`, that provides
    a fluent API for making a request and then applying assertions on its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example where we test the composite product API by doing
    the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending in `productId` for an existing product and asserting that we get back
    `200` as an HTTP response code and a JSON response that contains the requested
    `productId` along with one recommendation and one review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending in a missing `productId` and asserting that we get back `404` as an
    HTTP response code and a JSON response that contains relevant error information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation for these two tests is shown in the following code. The
    first test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The test code works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The test uses the fluent `WebTestClient` API to set up the URL to call `"/product-composite/"
    + PRODUCT_ID_OK` and specify the accepted response format, JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After executing the request using the `exchange()` method, the test verifies
    that the response status is `OK` (`200`) and that the response format actually
    is JSON (as requested).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the test inspects the response body and verifies that it contains the
    expected information in terms of `productId` and the number of recommendations
    and reviews.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second test looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'One important note regarding this test code is:'
  prefs: []
  type: TYPE_NORMAL
- en: This negative test is very similar to the preceding test in terms of its structure;
    the main difference is that it verifies that it got an error status code back,
    `Not Found` (`404`), and that the response body contains the expected error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test the composite product API in isolation, we need to mock its dependencies,
    that is, the requests to the other three microservices that were performed by
    the integration component, `ProductCompositeIntegration`. We use **Mockito** to
    do this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The mock implementation works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we declare three constants that are used in the test class: `PRODUCT_ID_OK`,
    `PRODUCT_ID_NOT_FOUND`, and `PRODUCT_ID_INVALID`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the annotation `@MockBean` is used to configure Mockito to set up a mock
    for the `ProductCompositeIntegration` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()`, `getRecommendations()`, and `getReviews()` methods are
    called on the integration component, and `productId` is set to `PRODUCT_ID_OK`,
    the mock will return a normal response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_NOT_FOUND`,
    the mock will throw `NotFoundException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_INVALID`,
    the mock will throw `InvalidInputException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full source code for the automated integration tests on the composite product
    API can be found in the test class `ProductCompositeServiceApplicationTests.java`.
  prefs: []
  type: TYPE_NORMAL
- en: The automated integration tests on the API exposed by the three core microservices
    are similar, but simpler since they don’t need to mock anything! The source code
    for the tests can be found in each microservice’s `test` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests are run automatically by Gradle when performing a build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, however, specify that you only want to run the tests (and not the
    rest of the build):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This was an introduction to how to write automated tests for microservices in
    isolation. In the next section, we will learn how to write tests that automatically
    test a microservice landscape. In this chapter, these tests will only be semi-automated.
    In upcoming chapters, the tests will be fully automated, a significant improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Adding semi-automated tests of a microservice landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to automatically run unit and integration tests for each microservice
    in isolation using plain Java, JUnit, and Gradle is very useful during development,
    but insufficient when we move over to the operation side. In operation, we also
    need a way to automatically verify that a *system landscape* of cooperating microservices
    delivers what we expect. Being able to, at any time, run a script that verifies
    that a number of cooperating microservices all work as expected in operation is
    very valuable – the more microservices there are, the higher the value of such
    a verification script.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, I have written a simple `bash` script that can verify the functionality
    of a deployed system landscape by performing calls to the RESTful APIs exposed
    by the microservices. It is based on the `curl` commands we learned about and
    used above. The script verifies return codes and parts of the JSON responses using
    `jq`. The script contains two helper functions, `assertCurl()` and `assertEqual()`,
    to make the test code compact and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, making a normal request and expecting `200` as the status code,
    as well as asserting that we get back a JSON response that returns the requested
    `productId` along with three recommendations and three reviews, looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Verifying that we get `404 (Not Found)` back as an HTTP response code (when
    we try to look up a product that doesn’t exist) looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The test script, `test-em-all.bash`, implements the manual tests that were described
    in the section *Testing APIs manually* and can be found in the top-level folder
    `$BOOK_HOME/Chapter03/2-basic-rest-services`. We will extend the functionality
    of the test script as we add more functionality to the system landscape in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 20*, *Monitoring Microservices*, we will learn about complementary
    techniques for automatically keeping an eye on a system landscape in operation.
    Here we will learn about a monitoring tool that continuously monitors the state
    of the deployed microservices and how alarms can be raised if the collected metrics
    exceed configured thresholds, such as overuse of CPU or memory.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the test script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To try out the test script, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the microservices, as we did previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once they’ve all started up, run the test script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect the output to look similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Output after running the test script'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap this up by shutting down the microservices with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we have taken the first steps toward automating testing for
    a system landscape of cooperating microservices, all of which will be improved
    in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now built our first few microservices using Spring Boot. After being
    introduced to the microservice landscape that we will use throughout this book,
    we learned how to use Spring Initializr to create skeleton projects for each microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to add APIs using Spring WebFlux for the three core services
    and implemented a composite service that uses the three core services’ APIs to
    create an aggregated view of the information in them. The composite service uses
    the `RestTemplate` class in the Spring Framework to perform HTTP requests to APIs
    that are exposed by the core services. After adding logic for error handling to
    the services, we ran some manual tests on the microservice landscape.
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped this chapter up by learning how to add tests for microservices in
    isolation and when they work together as a system landscape. To provide controlled
    isolation for the composite service, we mocked its dependencies to the core services
    using Mockito. Testing the whole system landscape is performed by a Bash script
    that uses `curl` to perform calls to the API of the composite service.
  prefs: []
  type: TYPE_NORMAL
- en: With these skills in place, we are ready to take the next step, entering the
    world of Docker and containers in the next chapter! Among other things, we will
    learn how to use Docker to fully automate the testing of a system landscape of
    cooperating microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the command that lists available dependencies when you create a new
    Spring Boot project using the `spring init` Spring Initializr CLI tool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you set up Gradle to build multiple related projects with one command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the `@PathVariable` and `@RequestParam` annotations used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you separate protocol-specific error handling from the business logic
    in an API implementation class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Mockito used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
