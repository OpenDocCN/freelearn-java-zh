- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Creating a Set of Cooperating Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一组协作微服务
- en: In this chapter, we will build our first couple of microservices. We will learn
    how to create cooperating microservices with minimalistic functionality. In upcoming
    chapters, we will add more and more functionality to these microservices. By the
    end of this chapter, we will have a RESTful API exposed by a composite microservice.
    The composite microservice will call three other microservices using their RESTful
    APIs to create an aggregated response.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的第一个几个微服务。我们将学习如何创建具有最小功能的协作微服务。在未来的章节中，我们将向这些微服务添加更多和更多的功能。到本章结束时，我们将通过组合微服务公开一个RESTful
    API。组合微服务将调用其他三个微服务，使用它们的RESTful API来创建聚合响应。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the microservice landscape
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微服务景观
- en: Generating skeleton microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成骨架微服务
- en: Adding RESTful APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加RESTful API
- en: Adding a composite microservice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加组合微服务
- en: Adding error handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加错误处理
- en: Testing the APIs manually
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试API
- en: Adding automated tests of microservices in isolation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务添加隔离的自动化测试
- en: Adding semi-automated tests to a microservice landscape
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向微服务景观添加半自动化测试
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install tools used in this book and how to access
    the source code for this book, see the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅以下内容：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章*，*macOS的安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章*，*使用WSL 2和Ubuntu的Microsoft Windows安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter03`.
    With the tools and source code in place, we can start learning about the system
    landscape of microservices that we will create in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都来自`$BOOK_HOME/Chapter03`中的源代码。有了工具和源代码，我们可以开始学习我们将在本章中创建的微服务系统景观。
- en: Introducing the microservice landscape
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务景观
- en: 'In *Chapter 1*, *Introduction to Microservices*, we were briefly introduced
    to the microservice-based system landscape that we will use throughout this book:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*微服务简介*中，我们简要介绍了本书将使用的基于微服务的系统景观：
- en: '![Diagram  Description automatically generated](img/B19825_03_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_03_01.png)'
- en: 'Figure 3.1: The microservice landscape'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：微服务景观
- en: It consists of three core microservices, the **product, review**, and **recommendation**
    services, all of which deal with one type of resource, and a composite microservice
    called the **Product Composite** service, which aggregates information from the
    three core services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它由三个核心微服务组成，即**产品**、**评论**和**推荐**服务，它们都处理一种类型的资源，以及一个名为**产品组合**的组合微服务，该服务从三个核心服务中聚合信息。
- en: Information handled by the microservices
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务处理的信息
- en: To keep the source code examples in this book easy to understand, they have
    a minimal amount of business logic. The information model for the business objects
    they process is kept minimal for the same reason. In this section, we will go
    through the information that’s handled by each microservice, including infrastructure-related
    information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本书中的源代码示例易于理解，它们包含的业务逻辑量最小。出于同样的原因，它们处理的企业对象的信息模型也保持最小。在本节中，我们将了解每个微服务处理的信息，包括与基础设施相关的信息。
- en: The product service
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品服务
- en: 'The product service manages product information and describes each product
    with the following attributes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 产品服务管理产品信息，并使用以下属性描述每个产品：
- en: Product ID
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Name
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Weight
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量
- en: The review service
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评论服务
- en: 'The review service manages product reviews and stores the following information
    about each review:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 评论服务管理产品评论，并存储以下关于每个评论的以下信息：
- en: Product ID
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Review ID
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论ID
- en: Author
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Subject
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: Content
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容
- en: The recommendation service
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推荐服务
- en: 'The recommendation service manages product recommendations and stores the following
    information about each recommendation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐服务管理产品推荐，并存储以下关于每个推荐的以下信息：
- en: Product ID
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Recommendation ID
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐ID
- en: Author
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Rate
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分
- en: Content
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容
- en: The product composite service
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品组合服务
- en: 'The product composite service aggregates information from the three core services
    and presents information about a product as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 产品组合服务从三个核心服务中聚合信息，并按以下方式展示产品信息：
- en: Product information, as described in the product service
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如产品服务所述的产品信息
- en: A list of product reviews for the specified product, as described in the review
    service
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如审查服务所述的指定产品的产品评论列表
- en: A list of product recommendations for the specified product, as described in
    the recommendation service
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如推荐服务所述的指定产品的产品推荐列表
- en: Infrastructure-related information
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施相关信息
- en: Once we start to run our microservices as containers that are managed by the
    infrastructure (first Docker and later on Kubernetes), it will be of interest
    to track which containers actually responded to our requests. As a simple solution,
    a `serviceAddress` attribute has been added to all responses, formatted as `hostname/ip-address:port`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始以由基础设施管理的容器形式运行我们的微服务（首先是Docker，然后是Kubernetes），跟踪哪些容器实际上响应了我们的请求将变得很有兴趣。作为一个简单的解决方案，已向所有响应添加了一个`serviceAddress`属性，格式为`hostname/ip-address:port`。
- en: In *Chapter 18*, *Using a Service Mesh to Improve Observability and Management*,
    and *Chapter 19*, *Centralized Logging with the EFK Stack*, we will learn about
    more powerful solutions to track requests that are processed by the microservices.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第18章“使用服务网格提高可观察性和管理”和第19章“使用EFK堆栈进行集中式日志记录”中，我们将了解跟踪微服务处理请求的更强大解决方案。
- en: Temporarily replacing service discovery
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时替换服务发现
- en: 'Since, at this stage, we don’t have any service discovery mechanism in place,
    we will run all microservices on `localhost` and use hardcoded port numbers for
    each microservice. We will use the following ports:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在此阶段我们没有设置任何服务发现机制，因此我们将所有微服务运行在`localhost`上，并为每个微服务使用硬编码的端口号。我们将使用以下端口号：
- en: 'The product composite service: `7000`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品组合服务：`7000`
- en: 'The product service: `7001`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品服务：`7001`
- en: 'The review service: `7002`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查服务：`7002`
- en: 'The recommendation service: `7003`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐服务：`7003`
- en: We will get rid of the hardcoded ports later when we start using Docker and
    Kubernetes!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在开始使用Docker和Kubernetes时删除硬编码的端口号！
- en: In this section, we have been introduced to the microservices we are going to
    create and the information that they will handle. In the next section, we will
    use Spring Initializr to create skeleton code for the microservices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了将要创建的微服务和它们将处理的信息。在下节中，我们将使用Spring Initializr为微服务创建骨架代码。
- en: Generating skeleton microservices
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成骨架微服务
- en: Now it’s time to see how we can create projects for our microservices. The final
    result for this topic can be found in the `$BOOK_HOME/Chapter03/1-spring-init`
    folder. To simplify setting up the projects, we will use **Spring Initializr**
    to generate a skeleton project for each microservice. A skeleton project contains
    the necessary files for building the project, along with an empty `main` class
    and test class for the microservice. After that, we will see how we can build
    all our microservices with one command using multi-project builds in the build
    tool that we will use, Gradle.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们如何为我们的微服务创建项目了。本主题的最终结果可以在`$BOOK_HOME/Chapter03/1-spring-init`文件夹中找到。为了简化项目设置，我们将使用**Spring
    Initializr**为每个微服务生成一个骨架项目。骨架项目包含构建项目所需的所有文件，以及微服务的空`main`类和测试类。之后，我们将了解如何使用我们将使用的构建工具Gradle中的多项目构建命令来构建所有微服务。
- en: Using Spring Initializr to generate skeleton code
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring Initializr生成骨架代码
- en: To get started with developing our microservices, we will use a tool called
    Spring Initializr to generate skeleton code for us. Spring Initializr is provided
    by the Spring team and can be used to configure and generate new Spring Boot applications.
    The tool helps developers to choose additional Spring modules to be used by the
    application and ensures that dependencies are configured to use compatible versions
    of the selected modules. The tool supports the use of either Maven or Gradle as
    a build system and can generate source code for either Java, Kotlin, or Groovy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始开发我们的微服务，我们将使用一个名为Spring Initializr的工具为我们生成骨架代码。Spring Initializr由Spring团队提供，可用于配置和生成新的Spring
    Boot应用程序。该工具帮助开发者选择应用程序将使用的附加Spring模块，并确保依赖项配置为使用所选模块的兼容版本。该工具支持使用Maven或Gradle作为构建系统，并可以为Java、Kotlin或Groovy生成源代码。
- en: It can either be invoked from a web browser using the URL [https://start.spring.io/](https://start.spring.io/)
    or using a command-line tool, `spring init`. To make it easier to reproduce the
    creation of the microservices, we will use the command-line tool.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过 URL [https://start.spring.io/](https://start.spring.io/) 或使用命令行工具 `spring
    init` 从网络浏览器中调用。为了更容易地重现微服务的创建，我们将使用命令行工具。
- en: 'For each microservice, we will create a Spring Boot project that does the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个微服务，我们将创建一个执行以下操作的 Spring Boot 项目：
- en: Uses Gradle as a build tool
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Gradle 作为构建工具
- en: Generates code for Java 8
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Java 8 生成代码
- en: Packages the project as a fat JAR file
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目打包成一个胖 JAR 文件
- en: Brings in dependencies for the `Actuator` and `WebFlux` Spring modules
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入 `Actuator` 和 `WebFlux` Spring 模块的依赖
- en: Is based on Spring Boot v3.0.4 (which depends on Spring Framework v6.0.6)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Spring Boot v3.0.4（它依赖于 Spring Framework v6.0.6）
- en: '**Spring Boot Actuator** enables a number of valuable endpoints for management
    and monitoring. We will see them in action later on. **Spring WebFlux** will be
    used here to create our RESTful APIs.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Boot Actuator** 为管理和监控提供了一些有价值的端点。我们将在稍后看到它们的作用。**Spring WebFlux**
    将用于创建我们的 RESTful API。'
- en: 'To create the skeleton code for our microservices, we need to run the following
    command for `product-service`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的微服务创建骨架代码，我们需要为 `product-service` 运行以下命令：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you want to learn more about the `spring init` CLI, you can run the `spring
    help init` command. To see what dependencies you can add, run the `spring init
    --list` command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 `spring init` CLI 的信息，可以运行 `spring help init` 命令。要查看可以添加的依赖项，请运行
    `spring init --list` 命令。
- en: 'If you want to create the four projects on your own instead of using the source
    code in this book’s GitHub repository, try out `$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash`,
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自己创建四个项目而不是使用本书 GitHub 仓库中的源代码，请尝试 `$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash`，如下所示：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After creating our four projects using `create-projects.bash`, we will have
    the following file structure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `create-projects.bash` 创建我们的四个项目后，我们将有以下文件结构：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For each project, we can list the created files. Let’s do this for the `product-service`
    project:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，我们可以列出创建的文件。让我们为 `product-service` 项目做这件事：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will receive the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '![Text  Description automatically generated](img/B19825_03_02.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_03_02.png)'
- en: 'Figure 3.2: Listing the files we created for product-service'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：列出我们为 product-service 创建的文件
- en: 'Spring Initializr created a number of files for Gradle, a `.gitignore` file,
    and three Spring Boot files:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr 为 Gradle 创建了多个文件，一个 `.gitignore` 文件和三个 Spring Boot 文件：
- en: '`ProductServiceApplication.java`, our main application class'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductServiceApplication.java`，我们的主应用程序类'
- en: '`application.properties`, an empty property file'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application.properties`，一个空属性文件'
- en: '`ProductServiceApplicationTests.java`, a test class that’s been configured
    to run tests on our Spring Boot application using JUnit'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductServiceApplicationTests.java`，一个配置为使用 JUnit 在我们的 Spring Boot 应用程序上运行测试的测试类'
- en: 'The `main` application class, `ProductServiceApplication.java`, looks as we’d
    expect based on the *The magic @SpringBootApplication annotation* section in the
    previous chapter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前一章中 *The magic @SpringBootApplication annotation* 部分的描述，`main` 应用程序类 `ProductServiceApplication.java`
    看起来应该是这样的：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The test class looks as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类看起来如下：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `@SpringBootTest` annotation will initialize our application in the same
    way that `@SpringBootApplication` does when running the application; that is,
    the Spring application context will be set up before the tests are executed using
    component scanning and auto-configuration, as described in the previous chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SpringBootTest` 注解将以与 `@SpringBootApplication` 相同的方式初始化我们的应用程序；也就是说，在执行测试之前，将使用组件扫描和自动配置设置
    Spring 应用程序上下文，正如前一章所述。'
- en: 'Let’s also look at the most important Gradle file, `build.gradle`. The content
    of this file describes how to build the project – for example, how to resolve
    dependencies and compile, test, and package the source code. The Gradle file starts
    by listing what plugins to apply:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看最重要的 Gradle 文件，`build.gradle`。此文件的内容描述了如何构建项目——例如，如何解决依赖关系和编译、测试和打包源代码。Gradle
    文件首先列出要应用的插件：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The declared plugins are used as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的插件如下使用：
- en: The `java` plugin adds the Java compiler to the project.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java` 插件将 Java 编译器添加到项目中。'
- en: The plugins `org.springframework.boot` and `io.spring.dependency-management`
    are declared, which together ensure that Gradle will build a fat JAR file and
    that we don’t need to specify any explicit version numbers on our Spring Boot
    starter dependencies. Instead, they are implied by the version of the `org.springframework.boot`
    plugin, that is, 3.0.4.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明了`org.springframework.boot`和`io.spring.dependency-management`插件，这两个插件一起确保Gradle将构建一个胖JAR文件，并且我们不需要在Spring
    Boot启动器依赖项上指定任何显式的版本号。相反，它们由`org.springframework.boot`插件的版本隐含，即3.0.4。
- en: 'In the rest of the build file, we basically declare a group name and version
    for our project, Java version, and its dependencies:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建文件的其余部分，我们基本上声明了项目的组名和版本、Java版本及其依赖项：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some notes regarding the dependencies used and the final test declaration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用的依赖项和最终测试声明的几点说明：
- en: Dependencies are, as with the preceding plugins, fetched from the central Maven
    repository.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项，就像前面的插件一样，从中央Maven仓库获取。
- en: Dependencies are set up as specified in the Actuator and WebFlux modules, along
    with a couple of useful test dependencies.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项的设置与Actuator和WebFlux模块中指定的设置相同，以及一些有用的测试依赖项。
- en: Finally, JUnit is configured to be used to run our tests in the Gradle builds.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，JUnit被配置为在Gradle构建中运行我们的测试。
- en: 'We can build each microservice separately with the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令分别构建每个微服务：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note how we use the `gradlew` executables that are created by Spring Initializr;
    that is, we don’t need to have Gradle installed!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用由Spring Initializr创建的`gradlew`可执行文件；也就是说，我们不需要安装Gradle！
- en: The first time we run a command with `gradlew`, it will download Gradle automatically.
    The Gradle version that’s used is determined by the `distributionUrl` property
    in the `gradle/wrapper/gradle-wrapper.properties` files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行带有`gradlew`的命令时，它会自动下载Gradle。使用的Gradle版本由`gradle/wrapper/gradle-wrapper.properties`文件中的`distributionUrl`属性确定。
- en: Setting up multi-project builds in Gradle
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Gradle中设置多项目构建
- en: 'To make it a bit simpler to build all the microservices with one command, we
    can set up a multi-project build in Gradle. The steps are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使使用一个命令构建所有微服务变得简单一些，我们可以在Gradle中设置一个多项目构建。步骤如下：
- en: 'First, we create the `settings.gradle` file, which describes what projects
    Gradle should build:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建`settings.gradle`文件，该文件描述了Gradle应该构建哪些项目：
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we copy the Gradle executable files that were generated from one of the
    projects so that we can reuse them for the multi-project builds:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们复制从其中一个项目中生成的Gradle可执行文件，以便我们可以为多项目构建重用它们：
- en: '[PRE10]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We no longer need the generated Gradle executable files in each project, so
    we can remove them with the following commands:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要每个项目中生成的Gradle可执行文件，因此我们可以使用以下命令删除它们：
- en: '[PRE11]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result should be similar to the code you can find in the folder `$BOOK_HOME/Chapter03/1-spring-init`.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果应该与你在文件夹`$BOOK_HOME/Chapter03/1-spring-init`中找到的代码类似。
- en: 'Now, we can build all the microservices with one command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用一个命令构建所有微服务：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you haven’t run the preceding commands, you can simply go to the book’s
    source code and build the microservices from there:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有运行前面的命令，你可以直接进入书籍的源代码，并从那里构建微服务：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should result in the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '![Text  Description automatically generated](img/B19825_03_03.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_03_03.png)'
- en: 'Figure 3.3: Output upon successful build'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：成功构建后的输出
- en: With skeleton projects for the microservices created using Spring Initializr
    and successfully built using Gradle, we are ready to add some code to the microservices
    in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Initializr创建的微服务骨架项目和成功使用Gradle构建后，我们就可以在下一节中为微服务添加一些代码了。
- en: From a DevOps perspective, a multi-project setup might not be preferred. Instead,
    to enable each microservice to have its own build and release cycle, setting up
    a separate build pipeline for each microservice project would probably be preferred.
    However, for the purposes of this book, we will use the multi-project setup to
    make it easier to build and deploy the whole system landscape with a single command.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从DevOps的角度来看，多项目设置可能不是首选。相反，为了使每个微服务都有其自己的构建和发布周期，为每个微服务项目设置单独的构建管道可能更受欢迎。然而，为了本书的目的，我们将使用多项目设置，以便可以使用单个命令轻松构建和部署整个系统景观。
- en: Adding RESTful APIs
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加RESTful API
- en: Now that we have projects set up for our microservices, let’s add some RESTful
    APIs to our three core microservices!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的微服务设置了项目，让我们为我们的三个核心微服务添加一些RESTful API！
- en: The final result of this and the remaining topics in this chapter can be found
    in the `$BOOK_HOME/Chapter03/2-basic-rest-services` folder.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终结果以及剩余主题可以在`$BOOK_HOME/Chapter03/2-basic-rest-services`文件夹中找到。
- en: First, we will add two projects (`api` and `util`) that will contain code that
    is shared by the microservice projects, and then we will implement the RESTful
    APIs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加两个项目（`api`和`util`），这两个项目将包含由微服务项目共享的代码，然后我们将实现RESTful API。
- en: Adding an API and a util project
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加API和util项目
- en: 'To add an `api` project, we need to do the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个`api`项目，我们需要做以下几步：
- en: First, we will set up a separate Gradle project where we can place our API definitions.
    We will use Java interfaces in order to describe our RESTful APIs and model classes
    to describe the data that the API uses in its requests and responses. To describe
    what types of errors can be returned by the API, a number of exception classes
    are also defined. Describing a RESTful API in a Java interface instead of directly
    in the Java class is, to me, a good way of separating the API definition from
    its implementation. We will further extend this pattern later in this book when
    we add more API information in the Java interfaces to be exposed in an OpenAPI
    specification. See *Chapter 5*, *Adding an API Description Using OpenAPI*, for
    more information.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将设置一个单独的Gradle项目，我们可以在这个项目中放置我们的API定义。我们将使用Java接口来描述我们的RESTful API和模型类来描述API在其请求和响应中使用的数据。为了描述API可以返回的错误类型，还定义了一系列异常类。在Java接口中而不是直接在Java类中描述RESTful
    API，对我来说，是一种将API定义与其实现分离的好方法。我们将在本书的后面进一步扩展这种模式，当我们向Java接口添加更多API信息以在OpenAPI规范中公开时。有关更多信息，请参阅*第5章*，*使用OpenAPI添加API描述*。
- en: It is debatable whether it is a good practice to store API definitions for a
    group of microservices in a common API module. It could potentially cause undesired
    dependencies between the microservices, resulting in monolithic characteristics,
    for example, causing a more complex and slow development process. To me, it is
    a good choice for microservices that are part of the same delivery organization,
    that is, whose releases are governed by the same organization (compare this to
    a **bounded context** in **domain-driven design**, where our microservices are
    placed in a single bounded context). As already discussed in *Chapter 1*, *Introduction
    to Microservices*, microservices within the same bounded context need to have
    API definitions that are based on a common information model, so storing these
    API definitions in the same API module doesn’t add any undesired dependencies.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 是否将一组微服务的API定义存储在公共API模块中，这是一个有争议的问题。这可能会在微服务之间产生不希望的依赖关系，从而导致单体特性，例如，导致更复杂和缓慢的开发过程。对我来说，对于属于同一交付组织的微服务来说，这是一个好的选择，也就是说，它们的发布由同一组织管理（将此与**领域驱动设计**中的**边界上下文**进行比较，我们的微服务被放置在单个边界上下文中）。如*第1章*，*微服务简介*中已讨论的，同一边界上下文内的微服务需要基于公共信息模型的API定义，因此将这些API定义存储在同一个API模块中不会添加任何不希望的依赖项。
- en: Next, we will create a `util` project that can hold some helper classes that
    are shared by our microservices, for example, for handling errors in a uniform
    way.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`util`项目，该项目可以存放一些由我们的微服务共享的辅助类，例如，用于以统一方式处理错误。
- en: Again, from a DevOps perspective, it would be preferable to build all the projects
    in their own build pipeline and have version-controlled dependencies for the `api`
    and `util` projects in the microservice projects, that is, so that each microservice
    can choose what versions of the `api` and `util` projects to use. But to keep
    the build and deployment steps simple in the context of this book, we will make
    the `api` and `util` projects part of the multi-project build.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从DevOps的角度来看，最好是为每个项目构建自己的构建管道，并在微服务项目中为`api`和`util`项目设置版本控制的依赖项，也就是说，这样每个微服务都可以选择使用`api`和`util`项目的哪个版本。但为了保持本书中构建和部署步骤的简单性，我们将`api`和`util`项目作为多项目构建的一部分。
- en: The api project
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: api项目
- en: The `api` project will be packaged as a library; that is, it won’t have its
    own `main` application class. Unfortunately, Spring Initializr doesn’t support
    the creation of library projects. Instead, a library project has to be created
    manually from scratch. The source code for the API project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/api`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`api`项目将被打包成一个库；也就是说，它不会有自己的`main`应用程序类。不幸的是，Spring Initializr不支持创建库项目。相反，必须从头手动创建库项目。API项目的源代码位于`$BOOK_HOME/Chapter03/2-basic-rest-services/api`。'
- en: 'The structure of a library project is the same as for an application project,
    except that we no longer have the `main` application class, as well as some minor
    differences in the `build.gradle` file. The Gradle plugin `org.springframework.boot`
    is replaced with an `implementation platform` section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 库项目的结构与应用程序项目相同，只是我们没有`main`应用程序类，以及`build.gradle`文件中的一些细微差异。`org.springframework.boot`
    Gradle插件被替换为`implementation platform`部分：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This allows us to retain Spring Boot dependency management while we are replacing
    the construction of a fat JAR in the build step with the creation of a normal
    JAR file that only contains the project’s own classes and property files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在用创建一个只包含项目自身类和属性文件的正常JAR文件替换构建步骤中构建胖JAR文件的同时，保留Spring Boot依赖管理。
- en: 'The Java files in the `api` project for our three core microservices are as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们三个核心微服务的`api`项目中的Java文件如下：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The structure of the Java classes looks very similar for the three core microservices,
    so we will only go through the source code for the `product` service.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个核心微服务的Java类结构看起来非常相似，所以我们只将通过`product`服务的源代码进行说明。
- en: 'First, we will look at the `ProductService.java` Java interface, as shown in
    the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看`ProductService.java` Java接口，如下所示：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Java interface declaration works as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Java接口声明如下：
- en: The `product` service only exposes one API method, `getProduct()` (we will extend
    the API later in this book, in *Chapter 6,* *Adding Persistence*).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`服务仅公开一个API方法，`getProduct()`（我们将在本书的*第6章*，*添加持久性*中扩展API）。'
- en: To map the method to an HTTP `GET` request, we use the `@GetMapping` Spring
    annotation, where we specify what URL path the method will be mapped to (`/product/{productId}`)
    and what format the response will be in– in this case, JSON.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将方法映射到HTTP `GET`请求，我们使用`@GetMapping` Spring注解，其中我们指定方法将被映射到的URL路径（`/product/{productId}`）以及响应的格式——在这种情况下，是JSON。
- en: The `{productId}` part of the path maps to a path variable named `productId`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径中的`{productId}`部分映射到一个名为`productId`的路径变量。
- en: The `productId` method parameter is annotated with `@PathVariable`, which will
    map the value that’s passed in the HTTP request to the parameter. For example,
    an HTTP `GET` request to `/product/123` will result in the `getProduct()` method
    being called with the `productId` parameter set to `123`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productId`方法参数被`@PathVariable`注解，它将传入HTTP请求中的值映射到参数。例如，对`/product/123`的HTTP
    `GET`请求将导致调用`getProduct()`方法，并将`productId`参数设置为`123`。'
- en: 'The method returns a `Product` object, a plain POJO-based model class with
    the member variables corresponding to attributes for `Product`, as described at
    the start of this chapter. `Product.java` looks as follows (with constructors
    and getter methods excluded):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个`Product`对象，一个基于POJO的模型类，其成员变量对应于`Product`的属性，如本章开头所述。`Product.java`看起来如下（省略了构造函数和getter方法）：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This type of POJO class is also known as a **Data Transfer Object** (**DTO**)
    as it is used to transfer data between the API implementation and the caller of
    the API. When we get to *Chapter 6*, *Adding Persistence*, we will look at another
    type of POJO that can be used to describe how data is stored in the databases,
    also known as entity objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的POJO类也被称为**数据传输对象**（**DTO**），因为它用于在API实现和API调用者之间传输数据。当我们到达*第6章*，*添加持久性*时，我们将查看另一种类型的POJO，它可以用来描述数据在数据库中的存储方式，也称为实体对象。
- en: The API project also contains the exception classes `InvalidInputException`
    and `NotFoundException`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: API项目还包含异常类`InvalidInputException`和`NotFoundException`。
- en: The util project
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: util项目
- en: 'The `util` project will be packaged as a library in the same way as the `api`
    project. The source code for the `util` project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/util`.
    The project contains the following utility classes: `GlobalControllerExceptionHandler`,
    `HttpErrorInfo`, and `ServiceUtil`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`util`项目将以与`api`项目相同的方式打包为库。`util`项目的源代码位于`$BOOK_HOME/Chapter03/2-basic-rest-services/util`。该项目包含以下工具类：`GlobalControllerExceptionHandler`、`HttpErrorInfo`和`ServiceUtil`。'
- en: Except for the code in `ServiceUtil.java`, these classes are reusable utility
    classes that we can use to map Java exceptions to proper HTTP status codes, as
    described in the later section *Adding error handling*. The main purpose of `ServiceUtil.java`
    is to find out the hostname, IP address, and port used by the microservice. The
    class exposes a method, `getServiceAddress()`, that can be used by the microservices
    to find their hostname, IP address, and port, as described in the previous section,
    *Infrastructure-related information*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ServiceUtil.java`中的代码外，这些类是可重用的工具类，我们可以使用它们将Java异常映射到适当的HTTP状态码，如后续章节*添加错误处理*中所述。`ServiceUtil.java`的主要目的是找出微服务使用的hostname、IP地址和端口号。该类公开了一个`getServiceAddress()`方法，微服务可以使用它来查找它们的hostname、IP地址和端口号，如前述章节*基础设施相关信息*中所述。
- en: Implementing our API
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现我们的API
- en: Now we can start to implement our APIs in the core microservices!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在核心微服务中开始实现我们的API了！
- en: 'The implementation looks very similar for the three core microservices, so
    we will only go through the source code for the `product` service. You can find
    the other files in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices`.
    Let’s see how we go about this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三个核心微服务的实现看起来非常相似，所以我们只通过`product`服务的源代码来演示。其他文件可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices`中找到。让我们看看我们是如何进行这一过程的：
- en: 'We need to add the `api` and `util` projects as dependencies to our `build.gradle`
    file, in the `product-service` project:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将`api`和`util`项目作为依赖项添加到我们的`build.gradle`文件中，在`product-service`项目中：
- en: '[PRE18]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To enable Spring Boot’s autoconfiguration feature to detect Spring Beans in
    the `api` and `util` projects, we also need to add a `@ComponentScan` annotation
    to the main application class, which includes the packages of the `api` and `util`
    projects:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启用Spring Boot的自动配置功能以检测`api`和`util`项目中的Spring Beans，我们还需要在主应用程序类中添加一个`@ComponentScan`注解，该注解包括`api`和`util`项目的包：
- en: '[PRE19]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we create our service implementation file, `ProductServiceImpl.java`,
    in order to implement the Java interface, `ProductService`, from the `api` project
    and annotate the class with `@RestController` so that Spring will call the methods
    in this class according to the mappings specified in the `Interface` class:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建服务实现文件，`ProductServiceImpl.java`，以便实现来自`api`项目的Java接口`ProductService`，并使用`@RestController`注解该类，这样Spring就会根据`Interface`类中指定的映射调用该类中的方法：
- en: '[PRE20]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To be able to use the `ServiceUtil` class from the `util` project, we will
    inject it into the constructor, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用来自`util`项目的`ServiceUtil`类，我们将将其注入到构造函数中，如下所示：
- en: '[PRE21]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can implement the API by overriding the `getProduct()` method from
    the interface in the `api` project:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过覆盖`api`项目中的接口的`getProduct()`方法来实现API：
- en: '[PRE22]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since we aren’t currently using a database, we simply return a hardcoded response
    based on the input of `productId`, along with the service address supplied by
    the `ServiceUtil` class.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们目前没有使用数据库，我们只是根据`productId`的输入返回一个硬编码的响应，以及由`ServiceUtil`类提供的服务地址。
- en: For the final result, including logging and error handling, see `ProductServiceImpl.java`.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于最终结果，包括日志记录和错误处理，请参阅`ProductServiceImpl.java`。
- en: 'Finally, we also need to set up some runtime properties – what port to use
    and the desired level of logging. This is added to the property file `application.yml`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要设置一些运行时属性——使用哪个端口以及所需的日志级别。这被添加到属性文件`application.yml`中：
- en: '[PRE23]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the empty `application.properties` file generated by Spring Initializr
    has been replaced by a YAML file, `application.yml`. YAML files provide better
    support for grouping related properties compared to `.properties` files. See the
    log level setting above as an example.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由Spring Initializr生成的空`application.properties`文件已被YAML文件`application.yml`替换。与`.properties`文件相比，YAML文件提供了更好的相关属性分组支持。如上例中的日志级别设置所示。
- en: 'We can try out the `product` service on its own. Build and start the microservice
    with the following commands:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以单独尝试`product`服务。使用以下命令构建并启动微服务：
- en: '[PRE24]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Wait until the following is printed in the Terminal:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待以下内容在终端中打印出来：
- en: '![Text  Description automatically generated](img/B19825_03_04.png)Figure 3.4:
    Starting ProductServiceApplication'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![文本描述自动生成](img/B19825_03_04.png)图 3.4：启动 ProductServiceApplication'
- en: 'Make a test call to the `product` service:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `product` 服务进行测试调用：
- en: '[PRE25]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It should respond with something similar to the following:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该响应如下所示的内容：
- en: '![](img/B19825_03_05.png)Figure 3.5: Expected response to test call'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5：测试调用预期响应](img/B19825_03_05.png)'
- en: 'Finally, stop the `product` service:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，停止 `product` 服务：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have now built, run, and tested our first single microservice. In the next
    section, we will implement the composite microservice that will use the three
    core microservices we’ve created so far.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建、运行并测试了我们的第一个单一微服务。在下一节中，我们将实现将使用我们迄今为止创建的三个核心微服务的复合微服务。
- en: 'Starting with Spring Boot v2.5.0, two JAR files are created when running the
    `./gradlew build` command: the ordinary JAR file, plus a plain JAR file containing
    only the class files resulting from compiling the Java files in the Spring Boot
    application. Since we don’t need the new plain JAR file, its creation has been
    disabled to make it possible to refer to the ordinary JAR file using a wildcard
    when running the Spring Boot application, for example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Spring Boot v2.5.0 开始，在运行 `./gradlew build` 命令时将创建两个 JAR 文件：普通 JAR 文件，以及仅包含编译
    Spring Boot 应用程序中的 Java 文件生成的类文件的普通 JAR 文件。由于我们不需要新的普通 JAR 文件，因此已禁用其创建，以便在运行 Spring
    Boot 应用程序时可以使用通配符引用普通 JAR 文件，例如：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The creation of the new plain JAR file has been disabled by adding the following
    lines to the `build.gradle` file for each microservice:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将以下行添加到每个微服务的 `build.gradle` 文件中，已禁用创建新的普通 JAR 文件：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For further details, see [https://docs.spring.io/spring-boot/docs/3.0.4/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives](https://docs.spring.io/spring-boot/docs/3.0.4/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多详细信息，请参阅 [https://docs.spring.io/spring-boot/docs/3.0.4/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives](https://docs.spring.io/spring-boot/docs/3.0.4/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives)。
- en: Adding a composite microservice
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加复合微服务
- en: Now, it’s time to tie things together by adding the composite service that will
    call the three core services!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过添加将调用三个核心服务的复合服务来整合这些内容了！
- en: 'The implementation of the composite services is divided into two parts: an
    integration component that handles the outgoing HTTP requests to the core services
    and the composite service implementation itself. The main reason for this division
    of responsibility is that it simplifies automated unit and integration testing;
    we can test the service implementation in isolation by replacing the integration
    component with a mock.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 复合服务的实现分为两部分：一个处理对核心服务的出站 HTTP 请求的集成组件，以及复合服务实现本身。这种责任划分的主要原因是为了简化自动化的单元和集成测试；我们可以通过用模拟替换集成组件来独立测试服务实现。
- en: As we will see later on in this book, this division of responsibility will also
    make it easier to introduce a circuit breaker!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本书后面看到的那样，这种责任划分也将使引入断路器变得更加容易！
- en: Before we look into the source code of the two components, we need to take a
    look at the API classes that the composite microservices will use and also learn
    about how runtime properties are used to hold address information for the core
    microservices.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看两个组件的源代码之前，我们需要查看复合微服务将使用的 API 类，并了解如何使用运行时属性来保存核心微服务的地址信息。
- en: The full implementation of both the integration component and the implementation
    of the composite service can be found in the Java package `se.magnus.microservices.composite.product.services`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件和复合服务实现的完整实现可以在 Java 包 `se.magnus.microservices.composite.product.services`
    中找到。
- en: API classes
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 类
- en: 'In this section, we will take a look at the classes that describe the API of
    the composite component. They can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/api`.
    The following are the API classes:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看描述复合组件 API 的类。它们可以在 `$BOOK_HOME/Chapter03/2-basic-rest-services/api`
    中找到。以下是一些 API 类：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Java interface class `ProductCompositeService.java` follows the same pattern
    that’s used by the core services and looks as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Java 接口类 `ProductCompositeService.java` 遵循核心服务使用的相同模式，如下所示：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The model class `ProductAggregate.java` is a bit more complex than the core
    models since it contains fields for lists of recommendations and reviews:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类`ProductAggregate.java`比核心模型复杂一些，因为它包含推荐和评论列表的字段：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The remaining API classes are plain POJO-based model objects and have the same
    structure as the model objects for the core APIs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的API类是普通的POJO模型对象，结构与核心API的模型对象相同。
- en: Properties
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'To avoid hardcoding the address information for the core services into the
    source code of the composite microservice, the latter uses a property file where
    information on how to find the core services is stored. The property file, `application.yml`,
    looks as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免将核心服务的地址信息硬编码到复合微服务的源代码中，后者使用一个属性文件来存储如何找到核心服务的信息。这个属性文件，`application.yml`，看起来如下所示：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This configuration will, as already noted, be replaced by a service discovery
    mechanism later on in this book.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此配置将在本书后面的部分被服务发现机制所取代。
- en: The integration component
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成组件
- en: 'Let’s look at the first part of the implementation of the composite microservice,
    the integration component, `ProductCompositeIntegration.java`. It is declared
    as a Spring Bean using the `@Component` annotation and implements the three core
    services’ API interfaces:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看复合微服务实现的第一部分，集成组件，`ProductCompositeIntegration.java`。它使用`@Component`注解声明为Spring
    Bean，并实现了三个核心服务的API接口：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The integration component uses a helper class in the Spring Framework, `RestTemplate`,
    to perform the actual HTTP requests to the core microservices. Before we can inject
    it into the integration component, we need to configure it. We do that in the
    `main` application class, `ProductCompositeServiceApplication.java`, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件使用Spring框架中的一个辅助类`RestTemplate`来执行对核心微服务的实际HTTP请求。在我们将其注入到集成组件之前，我们需要对其进行配置。我们在`main`应用程序类`ProductCompositeServiceApplication.java`中这样做，如下所示：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A `RestTemplate` object is highly configurable, but we’ll leave it with its
    default values for now.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestTemplate`对象高度可配置，但我们现在先保留其默认值。'
- en: In the *Spring WebFlux* section in *Chapter 2,* *Introduction to Spring Boot*,
    we introduced the reactive HTTP client, `WebClient`. Using `WebClient` instead
    of `RestTemplate` in this chapter would require all source code where `WebClient`
    is used to also be reactive, including the declaration of the RESTful API in the
    API project and the source code in the composite microservice. In *Chapter 7*,
    *Developing Reactive Microservices*, we will learn how to change the implementation
    of our microservices to follow a reactive programming model. As one of the steps
    in that update, we will replace the `RestTemplate` helper class with the `WebClient`
    class. But until we have learned about reactive development in Spring, we will
    use the `RestTemplate` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*的*Spring Boot简介*部分，我们介绍了反应式HTTP客户端`WebClient`。在本章中使用`WebClient`代替`RestTemplate`将需要所有使用`WebClient`的源代码也必须是反应式的，包括API项目中RESTful
    API的声明和复合微服务的源代码。在第7章*开发反应式微服务*中，我们将学习如何更改微服务的实现以遵循反应式编程模型。在这个更新步骤之一，我们将用`WebClient`类替换`RestTemplate`辅助类。但在我们了解Spring中的反应式开发之前，我们将使用`RestTemplate`类。
- en: 'We can now inject the `RestTemplate`, along with a JSON `mapper`, which is
    used for accessing error messages in case of errors, and the configuration values
    that we have set up in the property file. Let’s see how this is done:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以注入`RestTemplate`，以及一个JSON`mapper`，后者用于在出错时访问错误消息，以及我们在属性文件中设置的配置值。让我们看看这是如何完成的：
- en: 'The objects and configuration values are injected into the constructor as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象和配置值如下注入到构造函数中：
- en: '[PRE35]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The body of the constructor stores the injected objects and builds the URLs
    based on the injected values, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数的主体存储注入的对象并基于注入的值构建URL，如下所示：
- en: '[PRE36]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, the integration component implements the API methods for the three
    core services by using `RestTemplate` to make the actual outgoing calls:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，集成组件通过使用`RestTemplate`进行实际出站调用来实现三个核心服务的API方法：
- en: '[PRE37]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Some interesting notes regarding the methods implementations:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关于方法实现的一些有趣注释：
- en: For the `getProduct()` implementation, the `getForObject()` method can be used
    in `RestTemplate`. The expected response is a `Product` object. It can be expressed
    in the call to `getForObject()` by specifying the `Product.class` class that `RestTemplate`
    will map the JSON response to.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`getProduct()`实现，可以在`RestTemplate`中使用`getForObject()`方法。期望的响应是一个`Product`对象。可以通过在`getForObject()`调用中指定`RestTemplate`将映射JSON响应到的`Product.class`类来表示。
- en: For the calls to `getRecommendations()` and `getReviews()`, a more advanced
    method, `exchange()`, has to be used. The reason for this is the automatic mapping
    from a JSON response to a model class that `RestTemplate` performs. The `getRecommendations()`
    and `getReviews()` methods expect a generic list in the responses, that is, `List<Recommendation>`
    and `List<Review>`. Since generics don’t hold any type of information at runtime,
    we can’t specify that the methods expect a generic list in their responses. Instead,
    we can use a helper class from the Spring Framework, `ParameterizedTypeReference`,
    which is designed to resolve this problem by holding the type information at runtime.
    This means that `RestTemplate` can figure out what class to map the JSON responses
    to. To utilize this helper class, we have to use the more involved `exchange()`
    method instead of the simpler `getForObject()` method on `RestTemplate`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`getRecommendations()`和`getReviews()`的调用，必须使用更高级的方法`exchange()`。这是因为`RestTemplate`会自动将JSON响应映射到模型类。`getRecommendations()`和`getReviews()`方法期望响应中包含泛型列表，即`List<Recommendation>`和`List<Review>`。由于泛型在运行时不会保留任何类型信息，因此我们无法指定这些方法期望在响应中包含泛型列表。相反，我们可以使用Spring框架中的一个辅助类`ParameterizedTypeReference`，它通过在运行时保留类型信息来设计解决此问题。这意味着`RestTemplate`可以确定将JSON响应映射到哪个类。为了使用这个辅助类，我们必须使用更复杂的`exchange()`方法，而不是`RestTemplate`上的简单`getForObject()`方法。
- en: Composite API implementation
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合API实现
- en: 'Finally, we will look at the last piece of the implementation of the composite
    microservice: the API implementation class `ProductCompositeServiceImpl.java`.
    Let’s go through it step by step:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们将查看复合微服务实现的最后一部分：API实现类`ProductCompositeServiceImpl.java`。让我们一步一步地来看它： '
- en: 'In the same way that we did for the core services, the composite service implements
    its API interface, `ProductCompositeService`, and is annotated with `@RestController`
    to mark it as a REST service:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与核心服务类似，复合服务实现了其API接口`ProductCompositeService`，并使用`@RestController`注解标记为REST服务：
- en: '[PRE38]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The implementation class requires the `ServiceUtil` bean and its own integration
    component, so they are injected into its constructor:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类需要`ServiceUtil`豆和它自己的集成组件，因此它们被注入到其构造函数中：
- en: '[PRE39]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, the API method is implemented as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，API方法实现如下：
- en: '[PRE40]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The integration component is used to call the three core services, and a helper
    method, `createProductAggregate()`, is used to create a response object of the
    `ProductAggregate` type based on the responses from the calls to the integration
    component.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件用于调用三个核心服务，并使用辅助方法`createProductAggregate()`根据集成组件的调用响应创建`ProductAggregate`类型的响应对象。
- en: The implementation of the helper method, `createProductAggregate()`, is quite
    lengthy and not very important and so has been omitted from this chapter; however,
    it can be found in this book’s source code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法`createProductAggregate()`的实现相当冗长且不是非常重要，因此已从本章中省略；然而，它可以在本书的源代码中找到。
- en: The full implementation of both the integration component and the composite
    service can be found in the Java package `se.magnus.microservices.composite.product.services`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件和复合服务的完整实现可以在Java包`se.magnus.microservices.composite.product.services`中找到。
- en: That completes the implementation of the composite microservice from a functional
    point of view. In the next section, we will see how we handle errors.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能角度来看，这完成了复合微服务的实现。在下一节中，我们将看到我们如何处理错误。
- en: Adding error handling
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加错误处理
- en: Handling errors in a structured and well-thought-out way is essential in a microservice
    landscape where a large number of microservices communicate with each other using
    synchronous APIs, for example, using HTTP and JSON. It is also important to separate
    protocol-specific handling of errors, such as HTTP status codes, from the business
    logic.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务领域中，以结构化和深思熟虑的方式处理错误至关重要，因为在微服务之间使用同步API（例如HTTP和JSON）进行大量通信。同时，将特定协议的错误处理（如HTTP状态码）与业务逻辑分离也很重要。
- en: It could be argued that a separate layer for the business logic should be added
    when implementing the microservices. This should ensure that business logic is
    separated from the protocol-specific code, making it easier both to test and reuse.
    To avoid unnecessary complexity in the examples provided in this book, we have
    left out a separate layer for business logic, so the microservices implement their
    business logic directly in the `@RestController` components.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可以争论说，在实现微服务时应该添加一个单独的业务逻辑层。这应该确保业务逻辑与特定协议的代码分离，使得测试和重用都更容易。为了避免本书中提供的示例中出现不必要的复杂性，我们省略了单独的业务逻辑层，因此微服务直接在`@RestController`组件中实现其业务逻辑。
- en: I have created a set of Java exceptions in the `util` project that are used
    by both the API implementations and the API clients, initially `InvalidInputException`
    and `NotFoundException`. Look into the Java package `se.magnus.util.exceptions`
    for details.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`util`项目中创建了一系列Java异常，这些异常既被API实现使用，也被API客户端使用，最初是`InvalidInputException`和`NotFoundException`。有关详细信息，请查看Java包`se.magnus.util.exceptions`。
- en: The global REST controller exception handler
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局REST控制器异常处理器
- en: To separate protocol-specific error handling from the business logic in the
    REST controllers, that is, the API implementations, I have created a utility class,
    `GlobalControllerExceptionHandler.java`, in the `util` project, which is annotated
    as `@RestControllerAdvice`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将特定协议的错误处理与REST控制器中的业务逻辑分开，也就是说，与API实现分开，我在`util`项目中创建了一个实用类，名为`GlobalControllerExceptionHandler.java`，并使用`@RestControllerAdvice`注解。
- en: For each Java exception that the API implementations throw, the utility class
    has an exception handler method that maps the Java exception to a proper HTTP
    response, that is, with a proper HTTP status and HTTP response body.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API实现抛出的每个Java异常，实用类都有一个异常处理方法，将Java异常映射到适当的HTTP响应，即具有适当的HTTP状态和HTTP响应体。
- en: 'For example, if an API implementation class throws `InvalidInputException`,
    the utility class will map it to an HTTP response with the status code set to
    `422` (`UNPROCESSABLE_ENTITY`). The following code shows this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个API实现类抛出`InvalidInputException`，实用类会将其映射到一个状态码设置为`422`（`UNPROCESSABLE_ENTITY`）的HTTP响应。以下代码展示了这一点：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the same way, `NotFoundException` is mapped to a `404` (`NOT_FOUND`) HTTP
    status code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`NotFoundException`被映射到`404`（`NOT_FOUND`）HTTP状态码。
- en: Whenever a REST controller throws any of these exceptions, Spring will use the
    utility class to create an HTTP response.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每当REST控制器抛出这些异常之一时，Spring都会使用实用类来创建一个HTTP响应。
- en: Note that Spring itself returns the HTTP status code `400` (`BAD_REQUEST`) when
    it detects an invalid request, for example, if the request contains a non-numeric
    product ID (`productId` is specified as an integer in the API declaration).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当Spring检测到无效请求时，例如请求包含非数字的产品ID（在API声明中，`productId`被指定为整数），它本身会返回HTTP状态码`400`（`BAD_REQUEST`）。
- en: For the full source code of the utility class, see `GlobalControllerExceptionHandler.java`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实用类的完整源代码，请参阅`GlobalControllerExceptionHandler.java`。
- en: Error handling in API implementations
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API实现中的错误处理
- en: 'API implementations use the exceptions in the `util` project to signal errors.
    They will be reported back to the REST client as HTTPS status codes indicating
    what went wrong. For example, the `Product` microservice implementation class,
    `ProductServiceImpl.java`, uses the `InvalidInputException` exception to return
    an error that indicates invalid input, as well as the `NotFoundException` exception
    to tell us that the product that was asked for does not exist. The code looks
    as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: API实现使用`util`项目中的异常来表示错误。它们将以HTTPS状态码的形式返回给REST客户端，以指示发生了什么错误。例如，`Product`微服务实现类`ProductServiceImpl.java`使用`InvalidInputException`异常来返回一个表示输入无效的错误，以及使用`NotFoundException`异常来告诉我们请求的产品不存在。代码如下：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since we currently aren’t using a database, we have to simulate when to throw
    `NotFoundException`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前没有使用数据库，我们必须模拟何时抛出`NotFoundException`。
- en: Error handling in the API client
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API客户端中的错误处理
- en: 'The API client, that is, the integration component of the `Composite` microservice,
    does the reverse; it maps the `422` (`UNPROCESSABLE_ENTITY`) HTTP status code
    to `InvalidInputException` and the `404` (`NOT_FOUND`) HTTP status code to `NotFoundException`.
    See the `getProduct()` method in `ProductCompositeIntegration.java` for the implementation
    of this error-handling logic. The source code looks as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The error handling for `getRecommendations()` and `getReviews()` in the integration
    component is a bit more relaxed – classed as best-effort, meaning that if it succeeds
    in getting product information but fails to get either recommendations or reviews,
    it is still considered to be okay. However, a warning is written to the log.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: For details, see `ProductCompositeIntegration.java`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: That completes the implementation of both the code and composite microservices.
    In the next section, we will test the microservices and the API that they expose.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs manually
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That concludes the implementation of our microservices. Let’s try them out
    by performing the following steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Build and start the microservices as background processes.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `curl` to call the composite API.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the microservices.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, build and start up each microservice as a background process, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the build completes, we can launch our microservices as background processes
    to the Terminal process with the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A lot of log messages will be written to the Terminal, but after a few seconds,
    things will calm down and we will find the following messages written to the log:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_06.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Log messages after applications start'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that they are all ready to receive requests. Try this out with the
    following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After some log output, we will get a JSON response that looks something like
    the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_07.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: JSON response after the request'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the JSON response pretty-printed, you can use the `jq` tool:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This results in the following output (some details have been replaced by `...`
    for increased readability):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_08.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Pretty-printed JSON response'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to, you can also try out the following commands to verify that
    the error handling works as expected:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, you can shut down the microservices with the following command:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you are using an IDE such as Visual Studio Code with Spring Tool Suite, you
    can use their support for the Spring Boot Dashboard to start and stop your microservices
    with one click. For instructions on how to install Spring Tool Suite, see [https://github.com/spring-projects/sts4/wiki/Installation](https://github.com/spring-projects/sts4/wiki/Installation).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the use of the Spring Boot Dashboard in Visual
    Studio Code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_03_09.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_03_09.png)'
- en: 'Figure 3.9: Spring Boot Dashboard in Visual Studio Code'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：Visual Studio Code中的Spring Boot仪表板
- en: In this section, we have learned how to manually start, test, and stop the system
    landscape of cooperating microservices. These types of tests are time-consuming,
    so they clearly need to be automated.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何手动启动、测试和停止协作微服务的系统景观。这类测试耗时较长，因此显然需要自动化。
- en: In the next two sections, we will take our first steps toward learning how to
    automate testing, testing both a single microservice in isolation and a whole
    system landscape of cooperating microservices. Throughout this book, we will improve
    how we test our microservices.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将迈出第一步学习如何自动化测试，测试单个独立微服务以及整个协作微服务系统景观。在这本书的整个过程中，我们将改进我们测试微服务的方式。
- en: Adding automated microservice tests in isolation
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立添加自动化微服务测试
- en: Before we wrap up the implementation, we also need to write some automated tests.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成实现之前，我们还需要编写一些自动化测试。
- en: We don’t have much business logic to test at this time, so we don’t need to
    write any unit tests. Instead, we will focus on testing the APIs that our microservices
    expose; that is, we will start them up in integration tests with their embedded
    web server and then use a test client to perform HTTP requests and validate the
    responses. With Spring WebFlux comes a test client, `WebTestClient`, that provides
    a fluent API for making a request and then applying assertions on its result.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们没有太多业务逻辑要测试，因此不需要编写任何单元测试。相反，我们将专注于测试我们的微服务公开的API；也就是说，我们将使用嵌入的Web服务器在集成测试中启动它们，然后使用测试客户端执行HTTP请求并验证响应。随着Spring
    WebFlux的出现，提供了一个测试客户端`WebTestClient`，它提供了一个流畅的API来发出请求并在其结果上应用断言。
- en: 'The following is an example where we test the composite product API by doing
    the following tests:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个测试复合产品API的示例，我们进行以下测试：
- en: Sending in `productId` for an existing product and asserting that we get back
    `200` as an HTTP response code and a JSON response that contains the requested
    `productId` along with one recommendation and one review
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送现有产品的`productId`并断言我们收到`200`作为HTTP响应代码，以及包含请求的`productId`以及一个推荐和一个评论的JSON响应
- en: Sending in a missing `productId` and asserting that we get back `404` as an
    HTTP response code and a JSON response that contains relevant error information
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送缺少`productId`并断言我们收到`404`作为HTTP响应代码，以及包含相关错误信息的JSON响应
- en: 'The implementation for these two tests is shown in the following code. The
    first test looks like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试的实现如下所示。第一个测试看起来如下：
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The test code works like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码的工作方式如下：
- en: The test uses the fluent `WebTestClient` API to set up the URL to call `"/product-composite/"
    + PRODUCT_ID_OK` and specify the accepted response format, JSON.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用流畅的`WebTestClient` API设置要调用的URL为`"/product-composite/" + PRODUCT_ID_OK`，并指定接受的响应格式，JSON。
- en: After executing the request using the `exchange()` method, the test verifies
    that the response status is `OK` (`200`) and that the response format actually
    is JSON (as requested).
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用`exchange()`方法执行请求之后，测试验证响应状态是`OK`（`200`），并且响应格式实际上是JSON（如请求所示）。
- en: Finally, the test inspects the response body and verifies that it contains the
    expected information in terms of `productId` and the number of recommendations
    and reviews.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，测试检查响应体，并验证它是否包含预期的信息，即`productId`以及推荐和评论的数量。
- en: 'The second test looks as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试看起来如下：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'One important note regarding this test code is:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个测试代码的一个重要注意事项是：
- en: This negative test is very similar to the preceding test in terms of its structure;
    the main difference is that it verifies that it got an error status code back,
    `Not Found` (`404`), and that the response body contains the expected error message.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个负面测试在结构上与前面的测试非常相似；主要区别在于它验证了它收到了一个错误状态码回执，`Not Found`（`404`），并且响应体包含预期的错误信息。
- en: 'To test the composite product API in isolation, we need to mock its dependencies,
    that is, the requests to the other three microservices that were performed by
    the integration component, `ProductCompositeIntegration`. We use **Mockito** to
    do this, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了独立测试复合产品API，我们需要模拟其依赖项，即由集成组件`ProductCompositeIntegration`执行的到其他三个微服务的请求。我们使用**Mockito**来完成此操作，如下所示：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The mock implementation works as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟实现的工作方式如下：
- en: 'First, we declare three constants that are used in the test class: `PRODUCT_ID_OK`,
    `PRODUCT_ID_NOT_FOUND`, and `PRODUCT_ID_INVALID`.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the annotation `@MockBean` is used to configure Mockito to set up a mock
    for the `ProductCompositeIntegration` interface.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()`, `getRecommendations()`, and `getReviews()` methods are
    called on the integration component, and `productId` is set to `PRODUCT_ID_OK`,
    the mock will return a normal response.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_NOT_FOUND`,
    the mock will throw `NotFoundException`.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_INVALID`,
    the mock will throw `InvalidInputException`.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full source code for the automated integration tests on the composite product
    API can be found in the test class `ProductCompositeServiceApplicationTests.java`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The automated integration tests on the API exposed by the three core microservices
    are similar, but simpler since they don’t need to mock anything! The source code
    for the tests can be found in each microservice’s `test` folder.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests are run automatically by Gradle when performing a build:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can, however, specify that you only want to run the tests (and not the
    rest of the build):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This was an introduction to how to write automated tests for microservices in
    isolation. In the next section, we will learn how to write tests that automatically
    test a microservice landscape. In this chapter, these tests will only be semi-automated.
    In upcoming chapters, the tests will be fully automated, a significant improvement.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Adding semi-automated tests of a microservice landscape
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to automatically run unit and integration tests for each microservice
    in isolation using plain Java, JUnit, and Gradle is very useful during development,
    but insufficient when we move over to the operation side. In operation, we also
    need a way to automatically verify that a *system landscape* of cooperating microservices
    delivers what we expect. Being able to, at any time, run a script that verifies
    that a number of cooperating microservices all work as expected in operation is
    very valuable – the more microservices there are, the higher the value of such
    a verification script.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, I have written a simple `bash` script that can verify the functionality
    of a deployed system landscape by performing calls to the RESTful APIs exposed
    by the microservices. It is based on the `curl` commands we learned about and
    used above. The script verifies return codes and parts of the JSON responses using
    `jq`. The script contains two helper functions, `assertCurl()` and `assertEqual()`,
    to make the test code compact and easy to read.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, making a normal request and expecting `200` as the status code,
    as well as asserting that we get back a JSON response that returns the requested
    `productId` along with three recommendations and three reviews, looks like the
    following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Verifying that we get `404 (Not Found)` back as an HTTP response code (when
    we try to look up a product that doesn’t exist) looks as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The test script, `test-em-all.bash`, implements the manual tests that were described
    in the section *Testing APIs manually* and can be found in the top-level folder
    `$BOOK_HOME/Chapter03/2-basic-rest-services`. We will extend the functionality
    of the test script as we add more functionality to the system landscape in later
    chapters.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 20*, *Monitoring Microservices*, we will learn about complementary
    techniques for automatically keeping an eye on a system landscape in operation.
    Here we will learn about a monitoring tool that continuously monitors the state
    of the deployed microservices and how alarms can be raised if the collected metrics
    exceed configured thresholds, such as overuse of CPU or memory.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the test script
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To try out the test script, perform the following steps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the microservices, as we did previously:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once they’ve all started up, run the test script:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Expect the output to look similar to the following:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_03_10.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Output after running the test script'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap this up by shutting down the microservices with the following command:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this section, we have taken the first steps toward automating testing for
    a system landscape of cooperating microservices, all of which will be improved
    in upcoming chapters.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now built our first few microservices using Spring Boot. After being
    introduced to the microservice landscape that we will use throughout this book,
    we learned how to use Spring Initializr to create skeleton projects for each microservice.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to add APIs using Spring WebFlux for the three core services
    and implemented a composite service that uses the three core services’ APIs to
    create an aggregated view of the information in them. The composite service uses
    the `RestTemplate` class in the Spring Framework to perform HTTP requests to APIs
    that are exposed by the core services. After adding logic for error handling to
    the services, we ran some manual tests on the microservice landscape.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped this chapter up by learning how to add tests for microservices in
    isolation and when they work together as a system landscape. To provide controlled
    isolation for the composite service, we mocked its dependencies to the core services
    using Mockito. Testing the whole system landscape is performed by a Bash script
    that uses `curl` to perform calls to the API of the composite service.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: With these skills in place, we are ready to take the next step, entering the
    world of Docker and containers in the next chapter! Among other things, we will
    learn how to use Docker to fully automate the testing of a system landscape of
    cooperating microservices.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the command that lists available dependencies when you create a new
    Spring Boot project using the `spring init` Spring Initializr CLI tool?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`spring init` Spring Initializr CLI工具创建新的Spring Boot项目时，列出可用依赖项的命令是什么？
- en: How can you set up Gradle to build multiple related projects with one command?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何设置Gradle以使用一条命令构建多个相关项目？
- en: What are the `@PathVariable` and `@RequestParam` annotations used for?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@PathVariable`和`@RequestParam`注解用于什么？'
- en: How can you separate protocol-specific error handling from the business logic
    in an API implementation class?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在API实现类中将特定协议的错误处理与业务逻辑分离？
- en: What is Mockito used for?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mockito用于什么？
