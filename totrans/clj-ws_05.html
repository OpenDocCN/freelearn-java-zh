<html><head></head><body>
		<div>
			<div id="_idContainer042" class="Content">
			</div>
		</div>
		<div id="_idContainer043" class="Content">
			<h1 id="_idParaDest-109"><a id="_idTextAnchor115"/>5. Many to One: Reducing</h1>
		</div>
		<div id="_idContainer060" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor116"/>Overview</p>
			<p class="callout">In this chapter, you will learn new techniques for dealing with sequential data. You will learn how to use the <strong class="source-inline">reduce</strong> function, as well as other reducing techniques that provide greater flexibility for transforming or extracting data from a sequence. We will use the simple form of <strong class="source-inline">reduce</strong>, use <strong class="source-inline">reduce</strong> with an initializer and an accumulator, and solve problems requiring a variable-length "window" over a sequence. We will also reduce sequences with functions other than <strong class="source-inline">reduce</strong>.</p>
			<p class="callout">By the end of this chapter, you will be able to use <strong class="source-inline">reduce</strong> with complex accumulators.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor117"/>Introduction</h1>
			<p>This chapter is about using Clojure's <strong class="source-inline">reduce</strong> function and about <em class="italic">reducing</em> in general. By that, we mean starting with a sequence and <em class="italic">boiling it down</em> to a single thing. ("Reducing" is also cooking term, after all.) <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> were about taking the sequence you have and turning it into the sequence you want: <em class="italic">sequence in, sequence out</em>. But that's not always what we want. Even simple operations on a sequence, such as calculating an average, a sum, or a maximum, cannot be directly calculated this way. That's where <strong class="source-inline">reduce</strong>, as well as a wider family of functions and patterns, comes in: <em class="italic">sequence in, something else out</em>. It's "something else" because the result might be a number, a string, a map, or even another sequence.</p>
			<p>In the previous chapter, we saw that functions such as <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> only look at one element at a time: how should we transform this item? Should we discard this item, or keep it? This is a powerful approach because it creates a clear scope for the action of the functions we write, which helps us to write simpler code, and it allows lazy evaluation. There is a limit to this approach, however, when we need to look at a sequence as a whole, or at least as more than just the current item. This is why <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> are only partial replacements for a <strong class="source-inline">for</strong> loop.</p>
			<p>In Clojure, the <strong class="source-inline">reduce</strong> function is not the only way to generate a result from an entire sequence. Even the simple <strong class="source-inline">count</strong> function is a way of reducing a sequence down to a single value. Some core functions actually use <strong class="source-inline">reduce</strong> themselves so that we don't have to. The recursion and looping techniques that we'll discuss in the next chapter can do this as well. The patterns we are going to look at here should, in general, be what you consider first, after you've decided that <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> are not enough. <strong class="source-inline">reduce</strong> and other similar functions provide a clear way of solving a certain kind of problem, which is why they are an important part of your mental Clojure toolkit.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor118"/>The Basics of reduce</h2>
			<p>To understand how <strong class="source-inline">reduce</strong> works, the best place to start is with a simple example. Let's try to find the sum of a list of integers. In an imperative language such as JavaScript, we might do something like this:</p>
			<p class="source-code">var integers = [8, 4000, 10, 300];</p>
			<p class="source-code">var sum = 0;</p>
			<p class="source-code">for (var i = 0; i &lt; integers.length; i++) {</p>
			<p class="source-code">    sum = sum + integers[i];</p>
			<p class="source-code">}</p>
			<p class="source-code">console.log(sum);</p>
			<p>The <strong class="source-inline">sum</strong> variable here accumulates information found in previous iterations of the loop. This is exactly what <strong class="source-inline">reduce</strong> does. Here's a Clojure version of the same thing:</p>
			<p class="source-code">user&gt; (reduce (fn [sum-so-far item] (+ sum-so-far item)) [8 4000 10 300])</p>
			<p class="source-code">4318</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the first iteration, <strong class="source-inline">sum-so-far</strong> refers to <strong class="source-inline">0</strong> and <strong class="source-inline">item</strong> refers to <strong class="source-inline">8</strong>. In subsequent iterations, <strong class="source-inline">sum-so-far</strong> refers to the result of evaluating the function with the previous item in the collection and <strong class="source-inline">item</strong> refers to the current item of the collection.</p>
			<p>How does this work? This expression looks a lot like some of the uses of <strong class="source-inline">map</strong> or <strong class="source-inline">filter</strong> in the previous chapter. The layout of the s-expression should be very familiar by now:</p>
			<ul>
				<li>A function</li>
				<li>An anonymous function</li>
				<li>A vector of integers</li>
			</ul>
			<p>And yet, you can probably already tell that this expression is quite different from using <strong class="source-inline">map</strong> or <strong class="source-inline">filter</strong>. First of all, there is only one sequence supplied, yet the anonymous function takes two arguments, <strong class="source-inline">sum-so-far</strong> and <strong class="source-inline">item</strong>. And, of course, the biggest surprise is the result, which is not a sequence at all, but a single integer. This isn't <strong class="source-inline">map</strong> territory anymore.</p>
			<p>Obviously, this expression simply adds up integers in the sequence provided. To do that, it iterates over the integers in the sequence, seemingly like <strong class="source-inline">map</strong> would. The key difference is that with <strong class="source-inline">reduce</strong>, the function <em class="italic">"remembers"</em> the result of evaluating the previous calculations. </p>
			<p>Let's break down the operations here.</p>
			<p>The first time <strong class="source-inline">reduce</strong> calls the function we've provided, <strong class="source-inline">(fn [sum-so-far item] (+ sum-so-far item))</strong>, the arguments are the first two items in the list:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B14502_05_01.jpg" alt="Figure 5.1: sum-so-far and item are the first two items in the list (call 1)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: sum-so-far and item are the first two items in the list (call 1)</p>
			<p>For each of the next calls, <strong class="source-inline">sum-so-far</strong> is the result of the previous calculation, and <strong class="source-inline">item</strong> is the next integer in the list:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B14502_05_02.jpg" alt="Figure 5.2: Calls 2 and 3: each call builds on the result of the previous calls&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: Calls 2 and 3: each call builds on the result of the previous calls</p>
			<p>We could simplify this expression by replacing the anonymous function with Clojure's <strong class="source-inline">+</strong> function:</p>
			<p class="source-code">user&gt; (reduce + [8 4000 10 300])</p>
			<p class="source-code">4318</p>
			<p>And we could even use <strong class="source-inline">apply</strong> and avoid using <strong class="source-inline">reduce</strong> altogether:</p>
			<p class="source-code">user&gt; (apply + [8 4000 10 300])</p>
			<p class="source-code">4318</p>
			<p>However, with <strong class="source-inline">(apply + …)</strong>, we haven't really escaped from <strong class="source-inline">reduce</strong>: internally, the <strong class="source-inline">+</strong> function, when called with more than two arguments, uses a version of <strong class="source-inline">reduce</strong> to move through the list.</p>
			<h2 id="_idParaDest-112">Ex<a id="_idTextAnchor119"/>ercise 5.01: Finding the Day with the Maximum Temperature</h2>
			<p>Clojure's <strong class="source-inline">max</strong> function is useful when dealing with a list of numbers, but what do you do when the numbers you want to compare are part of a more complex data structure? Suppose we have the following weather data:</p>
			<p class="source-code">(def weather-days</p>
			<p class="source-code">  [{:max 31</p>
			<p class="source-code">    :min 27</p>
			<p class="source-code">    :description :sunny</p>
			<p class="source-code">    :date "2019-09-24"}</p>
			<p class="source-code">   {:max 28</p>
			<p class="source-code">    :min 25</p>
			<p class="source-code">    :description :cloudy</p>
			<p class="source-code">    :date "2019-09-25"}</p>
			<p class="source-code">   {:max 22</p>
			<p class="source-code">    :min 18</p>
			<p class="source-code">    :description :rainy</p>
			<p class="source-code">    :date "2019-09-26"}</p>
			<p class="source-code">   {:max 23</p>
			<p class="source-code">    :min 16</p>
			<p class="source-code">    :description :stormy</p>
			<p class="source-code">    :date "2019-09-27"}</p>
			<p class="source-code">   {:max 35</p>
			<p class="source-code">    :min 19</p>
			<p class="source-code">    :description :sunny</p>
			<p class="source-code">    :date "2019-09-28"}])</p>
			<p>We need to be able to write functions that return the entire map for the day with the highest maximum temperature, the lowest minimum, and so on:</p>
			<ol>
				<li>Start a REPL and copy the <strong class="source-inline">weather-days</strong> variable from the book GitHub's repository and paste it into your REPL. You'll find the file here: <a href="https://packt.live/2SXw372">https://packt.live/2SXw372</a>.</li>
				<li>Use <strong class="source-inline">map</strong> and <strong class="source-inline">max</strong> to find the highest temperature:<p class="source-code">user&gt; (apply max (map :max weather-days))</p><p class="source-code">35</p><p>This could be useful, but it doesn't tell us what day had this temperature, or whether it was sunny or cloudy that day, or what the minimum temperature was that day.</p></li>
				<li>Find the maximum <strong class="source-inline">:max</strong> temperature with <strong class="source-inline">reduce</strong>:<p class="source-code">user&gt; (reduce (fn [max-day-so-far this-day]</p><p class="source-code">                     (if (&gt; (:max this-day) (:max max-day-so-far))</p><p class="source-code">                       this-day</p><p class="source-code">                       max-day-so-far))</p><p class="source-code">               weather-days)</p><p class="source-code">{:max 35, :min 19, :description :sunny, :date "2019-09-28"}</p><p>If the maximum temperature of a given day is higher than <strong class="source-inline">max-day-so-far</strong>, that day replaces <strong class="source-inline">max-day-so-far</strong> until another day with a higher temperature dethrones it.</p></li>
				<li>Find the day that had the lowest maximum temperature:<p class="source-code">user&gt; (reduce (fn [min-max-day-so-far this-day]</p><p class="source-code">                (if (&lt; (:max this-day) (:max min-max-day-so-far))</p><p class="source-code">                  this-day</p><p class="source-code">                  min-max-day-so-far))</p><p class="source-code">               we<a id="_idTextAnchor120"/>ather-days)</p><p class="source-code">{:max 22, :min 18, :description :rainy, :date "2019-09-26"}</p></li>
			</ol>
			<p>Returning the <em class="italic">item</em> with the maximum value, rather than returning the maximum itself, can be useful when working with complex data structures. You will probably never be confronted with this exact problem. The important thing is to be able to quickly write a specialized version of <strong class="source-inline">max</strong>, <strong class="source-inline">min</strong>, a comparator, or whatever other function you need that is adapted to the needs of your particular data. Because of its power and flexibility, knowing how to use <strong class="source-inline">reduce</strong> can be extremely useful in those situations. It's no accident either that, internally, many core Clojure functions use <strong class="source-inline">reduce</strong> themselves. This is true of <strong class="source-inline">take-while</strong>, <strong class="source-inline">set</strong>, <strong class="source-inline">into</strong>, and <strong class="source-inline">map</strong>, for example.</p>
			<h1 id="_idParaDest-113">In<a id="_idTextAnchor121"/>itializing reduce</h1>
			<p>Tasks such as adding integers or finding maximum values have a common thread: the input values and the accumulated values are of the same type. When two numbers are added, the result is a number; when a maximum or a minimum is chosen between two numbers, the result is still a number. When we use <strong class="source-inline">reduce</strong> to add numbers together, the running total is a number just like all the other inputs. In the examples so far, the first function call that <strong class="source-inline">reduce</strong> makes takes the first two items in the sequence. We can break a <strong class="source-inline">reduce</strong> call into its successive function calls:</p>
			<p class="source-code">(reduce + [1 2 3 5 7])</p>
			<p class="source-code">(+ 1 2)</p>
			<p class="source-code">(+ 3 3)</p>
			<p class="source-code">(+ 6 5)</p>
			<p class="source-code">(+ 11 7)</p>
			<p>We actually don't need the anonymous function that we used in the previous examples, because <strong class="source-inline">+</strong> takes numbers as arguments, and returns a number:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B14502_05_03.jpg" alt="Figure 5.3: The arguments and the return value are all of the same type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3: The arguments and the return value are all of the same type</p>
			<p>In each of our examples so far, three different things are all of the same type:</p>
			<ul>
				<li>The values in the sequence</li>
				<li>Both arguments to <strong class="source-inline">+</strong></li>
				<li>The return value of <strong class="source-inline">+</strong></li>
			</ul>
			<p>In the previous exercise, we returned a map rather than a single number. That was possible because the same kinds of maps were used in these three places: the maps we iterate over as well as the current "best" map that we are comparing the others to.</p>
			<p>If this was all we could do with <strong class="source-inline">reduce</strong>, however, it would be rather restrictive. Not all problems can be expressed by this kind of function. Often, we want to compute and accumulate some other kind of value. We might need more complex summary statistics, or to merge individual values together in a specific way, or to divide a sequence into segments based on special criteria. Just because you have a sequence of <strong class="source-inline">matches</strong>, to take up our tennis examples again, doesn't mean that the result you want can also be expressed as a tennis <strong class="source-inline">match</strong>. Maybe we want to iterate over a list of matches and accumulate some other kind of information. At the end of this chapter, in fact, we are going to do just that. At the beginning of this chapter, we said that <strong class="source-inline">reduce</strong> can turn a sequence into <em class="italic">anything</em> else, but so far, this hasn't really been true.</p>
			<p>This is why there is a second form of <strong class="source-inline">reduce</strong> that takes an additional argument. When the additional argument is present, it becomes the first argument to the reducing function. On that initial function call, the first item in the sequence is the second argument. This is a crucial improvement because the reducing function's return value no longer has to be the same kind of thing that is in the sequence. </p>
			<p>Consider the following snippet, where<a id="_idTextAnchor122"/> we supply an empty map as an initial value for our reduction. As it moves through the sequence, the reducing function updates the <strong class="source-inline">:maximum</strong> and <strong class="source-inline">:minimum</strong> fields when new values are discovered. The expression returns a function at the end:</p>
			<p class="source-code">user&gt; (reduce (fn [{:keys [minimum maximum]} new-number]</p>
			<p class="source-code">          {:minimum (if (and minimum (&gt; new-number minimum))</p>
			<p class="source-code">                      minimum</p>
			<p class="source-code">                      new-number)</p>
			<p class="source-code">           :maximum (if (and maximum (&lt; new-number maximum))</p>
			<p class="source-code">                      maximum</p>
			<p class="source-code">                      new-number)})</p>
			<p class="source-code">        {}          ;; &lt;---- The new argument!</p>
			<p class="source-code">        [5 23 5004 845 22])</p>
			<p class="source-code">{:minimum 5, :maximum 5004}</p>
			<p>The preceding expression finds both the minimum and the maximum value in a sequence. Calling <strong class="source-inline">reduce</strong> like this might be useful if, for some reason, it was difficult to loop over a list twice, if it were very, very long, or perhaps there was a stream that was not being retained. To return two values, we'll place them in a map. Without the initializing argument for <strong class="source-inline">reduce</strong>, this would already have been impossible. This is a case where "numbers in, numbers out" is not sufficient.</p>
			<p>Here, we supply an empty map as an initial value for our reduction. As it moves through the sequence, the reducing function updates the <strong class="source-inline">:maximum</strong> and <strong class="source-inline">:minimum</strong> fields when new values are discovered. The expression returns a function at the end.</p>
			<p class="callout-heading">No<a id="_idTextAnchor123"/>te</p>
			<p class="callout">Another common pattern in a case like this would be to return a two-item vector (a tuple) instead of a map: <strong class="source-inline">[minimum maximum]</strong>.</p>
			<p>On each call of the reducing function, the first argument is always a map, and the second argument is always an integer from the sequence. </p>
			<p>This difference makes <strong class="source-inline">reduce</strong> much more useful. Now, we can extract whatever data we like from each item in the sequence and insert it and carry it forward as the context for the subsequent iterations. Most of the time, we can think of this context as an <strong class="bold">accumulator</strong>, a value (often a map) in which we explicitly store whatever we need for the next iteration. We'll often use the name <strong class="source-inline">acc</strong>. Later, when we look at some of Clojure's other looping constructs, the idea of an explicit context will reappear.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor124"/>Partitioning with reduce</h2>
			<p>Partitioning a sequence into smaller sequences is a common problem and there are many ways to solve it. When the simpler solutions aren't enough, <strong class="source-inline">reduce</strong> can be a useful alternative.</p>
			<p>First, let's take a look at some of the other possibilities. If sub-sequences of a fixed length are required, then there is <strong class="source-inline">partition</strong> or <strong class="source-inline">partition-all</strong>:</p>
			<p class="source-code">user&gt; (partition 3 [1 2 3 4 5 6 7 8 9 10])</p>
			<p class="source-code">((1 2 3) (4 5 6) (7 8 9))</p>
			<p class="source-code">user&gt; (partition-all 3 [1 2 3 4 5 6 7 8 9 10])</p>
			<p class="source-code">((1 2 3) (4 5 6) (7 8 9) (10))</p>
			<p>The difference between the two is that <strong class="source-inline">partition</strong> stops when it has filled its last group, while <strong class="source-inline">partition-all</strong> continues, even if this means the final sub-sequence won't contain the same number of items.</p>
			<p>There is also <strong class="source-inline">partition-by</strong>, which offers more flexibility. In addition to the sequence to break apart, <strong class="source-inline">partition-by</strong> takes a function that will be called on each item. <strong class="source-inline">partition-by</strong> will then start a new subsequence whenever the return value changes. </p>
			<p>Here, we break a sequence into sub-sequences depending on whether the integers are greater than or less than 10:</p>
			<p class="source-code">user&gt; (partition-by #(&gt; % 10) [5 33 18 0 23 2 9 4 3 99])</p>
			<p class="source-code">((5) (33 18) (0) (23) (2 9 4 3) (99))</p>
			<p>Because <strong class="source-inline">partition-by</strong> allows you to write your own partitioning function, this can be a rather useful function when used creatively.</p>
			<p>However, just like <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> themselves, none of these functions can look at more than one item at a time. What if, for example, we wanted to partition a sequence of integers into sequences whose sum was less than 20? To solve this kind of problem, we need to be able to consider more than one item at a time.</p>
			<p>When using <strong class="source-inline">reduce</strong> for this, the key is to use a map as an initializer and accumulator, with at least two different fields: one for the accumulated sequences and one for the current sequence. The accumulator might look as follows, mid-way through a reduction, if we are trying to make sequences whose sum is less than 20:</p>
			<p class="source-code">{:current [5 10]</p>
			<p class="source-code"> :segments [[3 7 8]</p>
			<p class="source-code">            [17]</p>
			<p class="source-code">            [4 1 1 5 3 2]]}</p>
			<p>The vectors in <strong class="source-inline">segments</strong> are complete: if one more item was added, their sums would exceed 20. The <strong class="source-inline">:current</strong> vector adds up to 15 right now. If the next item in the main sequence is 4 or more, we won't be able to add it to this vector and we'll move <strong class="source-inline">[5 10]</strong> over to <strong class="source-inline">segments</strong>.</p>
			<p>Here is how this would work in practice:</p>
			<p class="source-code">user&gt; (reduce (fn [{:keys [segments current] :as accum} n]</p>
			<p class="source-code">                (let [current-with-n (conj current n)</p>
			<p class="source-code">                      total-with-n (apply + current-with-n)]</p>
			<p class="source-code">                  (if (&gt; total-with-n 20)</p>
			<p class="source-code">                    (assoc accum </p>
			<p class="source-code">                           :segments (conj segments current)</p>
			<p class="source-code">                           :current [n])</p>
			<p class="source-code">                    (assoc accum :current current-with-n))))</p>
			<p class="source-code">              {:segments [] :current []}</p>
			<p class="source-code">              [4 19 4 9 5 12 5 3 4 1 1 9 5 18])</p>
			<p class="source-code">{:segments [[4] [19] [4 9 5] [12 5 3] [4 1 1 9 5]], :current [18]}</p>
			<p>Let's take a closer look. For convenience, we start by extracting the segments and current bindings from the accumulator. Then, we set up a couple of useful bindings: <strong class="source-inline">current-with-n</strong> is the current sequence plus the current item, <strong class="source-inline">n</strong>. At this point, we don't know if this is a valid sequence. Its total might go beyond the limit of 20. To check this, we assign another binding (for clarity), <strong class="source-inline">total-with-n</strong>, and we compare that to 20.</p>
			<p>If <strong class="source-inline">current-with-n</strong> adds up to more than 20, this means that <strong class="source-inline">current</strong> is a valid sub-sequence. In that case, we add it as is (without <strong class="source-inline">n</strong>) to our list of accumulated segments, and we place <strong class="source-inline">n</strong> as the first item in a brand new <strong class="source-inline">:current</strong> vector. On the other hand, if <strong class="source-inline">current-with-n</strong> does not add up to 20 yet, we just append <strong class="source-inline">n</strong> to <strong class="source-inline">current</strong> and keep going.</p>
			<p>You'll notice that the final result is not exactly what we want: the last item, <strong class="source-inline">[18]</strong>, is still stuck in <strong class="source-inline">:current</strong>. To present a clean result, we should probably wrap our call to <strong class="source-inline">reduce</strong> in a function that will take care of this last bit of housekeeping:</p>
			<p class="source-code">user&gt; (defn segment-by-sum [limit ns]</p>
			<p class="source-code">        (let [result (reduce (fn [{:keys [segments current] :as accum} n]</p>
			<p class="source-code">                               (let [current-with-n (conj current n)</p>
			<p class="source-code">                                     total-with-n (apply + current-with-n)]</p>
			<p class="source-code">                                 (if (&gt; total-with-n limit)</p>
			<p class="source-code">                                   (assoc accum </p>
			<p class="source-code">                                          :segments (conj segments current)</p>
			<p class="source-code">                                          :current [n])</p>
			<p class="source-code">                                   (assoc accum :current current-with-n))))</p>
			<p class="source-code">                             {:segments [] :current []}</p>
			<p class="source-code">                             ns)]</p>
			<p class="source-code">          (conj (:segments result) (:current result))))</p>
			<p class="source-code">#'user/segment-by-sum</p>
			<p>Here, we've made our function a little bit more versatile by adding a <strong class="source-inline">limit</strong> parameter so that we can choose other values besides 20. We also create a binding for the result of the call to <strong class="source-inline">reduce</strong> that we then use, at the last line of the function, to append the final value of <strong class="source-inline">:current</strong> to the accumulated segments. Now we get the result we want:</p>
			<p class="source-code">user&gt; (segment-by-sum 20 [4 19 4 9 5 12 5 3 4 1 1 9 5 18])</p>
			<p class="source-code">[[4] [19] [4 9 5] [12 5 3] [4 1 1 9 5] [18]]</p>
			<p>This common pattern will allow you to do lots of interesting things with <strong class="source-inline">reduce</strong>. In the next two exercises, we will use variations of it to solve two rather different kinds of problems.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor125"/>Looking Back with reduce</h2>
			<p>As we saw in the previous chapter, Clojure's <strong class="source-inline">map</strong> function is extremely useful and versatile. The key to understanding <strong class="source-inline">map</strong> is the idea of the one-to-one <em class="italic">mapping</em> (there's that word!) between each item in the input sequence and each item in the output sequence. Sometimes, this isn't what we need. The windowing pattern we used in <em class="italic">Chapter 4</em>, <em class="italic">Mapping and Filtering</em>, is one way to work around this, but it has its own limitations. Often, we don't know how "wide" the window needs to be. It might depend on the data itself and vary as we move through the input sequence.</p>
			<p>We can solve this problem quite easily with <strong class="source-inline">reduce</strong> and an accumulator that retains a certain number of items. To start with a simple example, let's suppose we have a list of integers:</p>
			<p class="source-code">(def numbers [4 9 2 3 7 9 5 2 6 1 4 6 2 3 3 6 1])</p>
			<p>For each integer in the list, we want to return a two-item tuple containing:</p>
			<ul>
				<li>The integer itself</li>
				<li>If the integer is odd, the sum of the consecutive odd integers preceding it; if it's even, the sum of the consecutive even integers</li>
			</ul>
			<p>Following this logic, the first <strong class="source-inline">9</strong> in the list should be replaced with <strong class="source-inline">[9 0]</strong>, since it is preceded by an even integer. The second <strong class="source-inline">9</strong>, on the other hand, should be replaced with <strong class="source-inline">[9 10]</strong>, since it is preceded by a <strong class="source-inline">3</strong> and a <strong class="source-inline">7</strong>.</p>
			<p>And here is a function that solves this with <strong class="source-inline">reduce</strong>:</p>
			<p class="source-code">(defn parity-totals [ns]</p>
			<p class="source-code">  (:ret </p>
			<p class="source-code">   (reduce (fn [{:keys [current] :as acc} n]</p>
			<p class="source-code">             (if (and (seq current)</p>
			<p class="source-code">                      (or (and (odd? (last current)) (odd? n))</p>
			<p class="source-code">                          (and (even? (last current)) (even? n))))</p>
			<p class="source-code">               (-&gt; acc</p>
			<p class="source-code">                   (update :ret conj [n (apply + current)])</p>
			<p class="source-code">                   (update :current conj n))</p>
			<p class="source-code">               (-&gt; acc</p>
			<p class="source-code">                   (update :ret conj [n 0])</p>
			<p class="source-code">                   (assoc :current [n]))))</p>
			<p class="source-code">           {:current [] :ret []}</p>
			<p class="source-code">           ns)))</p>
			<p>Let's take a closer look, starting with the accumulator, a map with two keys referencing empty vectors: <strong class="source-inline">:current</strong>, for the current series of integers with the same parity; and <strong class="source-inline">:ret</strong>, for the list of values that will be returned. (The entire <strong class="source-inline">reduce</strong> expression is wrapped by a <strong class="source-inline">(:ret…)</strong> expression to extract this value.)</p>
			<p>The reducing function starts with some destructuring to give us easy access to <strong class="source-inline">:current</strong>; now, <strong class="source-inline">n</strong>, of course, is the current integer in the list. Inside the function, the structure is quite simple. The <strong class="source-inline">if</strong> expression has a somewhat elaborate set of nested logical operators. First, we use <strong class="source-inline">(seq current)</strong> to check whether <strong class="source-inline">current</strong> is empty, which would be the case on the first iteration. The <strong class="source-inline">seq</strong> function returns <strong class="source-inline">false</strong> if a vector or list is empty. Then, since we know <strong class="source-inline">(last current)</strong> will return an integer, we can test to see whether <strong class="source-inline">n</strong> and the previous value in the list are both odd or both even.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Because we are using vectors here, <strong class="source-inline">conj</strong> appends new items to the end of the vector. To get the most recent item, we use <strong class="source-inline">last</strong>. If we were using lists instead of vectors, <strong class="source-inline">conj</strong> would append to the front of the list and we would have to use <strong class="source-inline">first</strong> to get the most recent item. When using <strong class="source-inline">conj</strong>, it's important to make sure the underlying data structure is what you think it is. Otherwise, your results could easily be backward.</p>
			<p>Depending on which branch of the <strong class="source-inline">if</strong> statement we end up in, we update <strong class="source-inline">acc</strong> differently. In the first case, the current integer has the same parity as the contents of <strong class="source-inline">current</strong>. We thread <strong class="source-inline">acc</strong> through two calls to <strong class="source-inline">update</strong>. As you remember from <em class="italic">Chapter 2</em>, <em class="italic">Data types and Immutability</em>, <strong class="source-inline">update</strong> takes a function as its second argument, <strong class="source-inline">conj</strong> in this case, because we are adding to the vector, and applies it to the value associated with the key provided as the first value. We add an additional argument,<strong class="source-inline"> [n (apply + current)]</strong>. This will be the second argument to <strong class="source-inline">conj</strong>. Altogether, it's as though we were calling <strong class="source-inline">conj</strong> like this: <strong class="source-inline">(conj (:ret acc) [n (apply + current)])</strong>. The second call to <strong class="source-inline">update</strong> adds <strong class="source-inline">n</strong> to our running list of integers.</p>
			<p>In the other case, when we are at the beginning of the list or because of a change from odd to even or even to odd, we know that the current total is zero. Instead of <strong class="source-inline">update</strong>, we can use <strong class="source-inline">assoc</strong> here because we're starting over with a fresh list.</p>
			<p>Running the function on our sequence of integers gives us this:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B14502_05_04.jpg" alt="Figure 5.4: The original inputs are followed by the sum of the preceding, consecutive integers of the same parity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4: The original inputs are followed by the sum of the preceding, consecutive integers of the same parity</p>
			<p>This would be impossible with <strong class="source-inline">map</strong> because, unlike the windowing technique we used, the <strong class="source-inline">:current</strong> vector in the accumulator here can contain as many items as necessary, depending on the input. This also shows the flexibility of <strong class="source-inline">reduce</strong> when using an accumulator. Now, we can practice using it on a real problem.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor126"/>Exercise 5.02: Measuring Elevation Differences on Slopes</h2>
			<p>The organizers of a bicycle race in a mountainous region want to improve the signs they place on the side of the road. Currently, each sign simply indicates the distance from the start of the race. The race organizers would like to add two more numbers:  </p>
			<ul>
				<li>The distance to the top or bottom of the current slope, depending on whether that part of the racecourse is gaining or losing elevation</li>
				<li>The remaining elevation gain or loss until the end of the current slope</li>
			</ul>
			<p>Here is an example:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B14502_05_05.jpg" alt="Figure 5.5: Racecourse sign indicating the remaining distance and elevation until &#13;&#10;the top of the current hill&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5: Racecourse sign indicating the remaining distance and elevation until the top of the current hill</p>
			<p>The data you have is a list of tuples: the first value is the distance from the start of the race, and the second is the elevation at that point. You can copy the data from <a href="https://packt.live/38IcEvx">https://packt.live/38IcEvx</a>:</p>
			<p class="source-code">(def distance-elevation [[0 400] [12.5 457] [19 622] [21.5 592] [29 615] …)</p>
			<p>We will solve this problem using <strong class="source-inline">reduce</strong> and the "looking back" pattern. There is, however, a difficulty we need to resolve first. If we are looking <em class="italic">back</em>, how do we know how far we are from the <em class="italic">next</em> peak or the <em class="italic">next</em> valley? Simple: we'll reverse the racecourse data so that when we're looking back, we're actually looking forward!</p>
			<p>In the following figure, as we descend the slopes, we can "see" forward and compare our current position with the peaks:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B14502_05_06.jpg" alt="Figure 5.6: The descent slopes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6: The descent slopes</p>
			<p>By reversing the direction, we traverse the data; when we look "back," we are looking forward geographically.</p>
			<p>Now we can start writing some code:</p>
			<ol>
				<li value="1">Start a fresh REPL in an empty directory and open a new file, <strong class="source-inline">bike_race.clj</strong>. Add the corresponding namespace declaration: <p class="source-code">(ns bike-race)</p><p class="callout-heading">Note</p><p class="callout">Clojure namespaces use hyphens between words (sometimes referred to as "kebab case") but, because of Clojure's Java origins, the corresponding filenames use underscores instead (or "snake case"). That's why the<strong class="source-inline"> bike-race</strong> namespace is in a file named <strong class="source-inline">bike_race.clj</strong>. In <em class="italic">Chapter 8</em>, <em class="italic">Namespaces, Libraries and Leiningen </em>you will learn more about namespaces.</p></li>
				<li>Copy the <strong class="source-inline">distance-elevation</strong> var from the book's GitHub repository at <a href="https://packt.live/38IcEvx">https://packt.live/38IcEvx</a>. </li>
				<li>Set up the skeleton for this function:<p class="source-code">(defn distances-elevation-to-next-peak-or-valley</p><p class="source-code">  [data]</p><p class="source-code">  (-&gt;</p><p class="source-code">    (reduce</p><p class="source-code">      (fn [{:keys [current] :as acc} [distance elevation :as this-position]]</p><p class="source-code">        )</p><p class="source-code">      {:current []</p><p class="source-code">       :calculated []}</p><p class="source-code">      (reverse data))</p><p class="source-code">    :calculated</p><p class="source-code">    reverse))</p><p>There are only a couple of notable differences with the basic "looking back" pattern described above. First of all, there is more destructuring for easy access to the <strong class="source-inline">distance</strong> and <strong class="source-inline">elevation</strong> values inside the incoming tuple. Secondly, the entire call to <strong class="source-inline">reduce</strong> is wrapped inside a <strong class="source-inline">-&gt;</strong> threading macro. This is, of course, equivalent to <strong class="source-inline">(reverse (:calculated (reduce…)))</strong> but has the advantage of organizing the code according to how the data flows through the function. This is a fairly common idiom with accumulators when only one of the fields will ultimately be returned.</p><p>Otherwise, the general approach is the same: the <strong class="source-inline">:current</strong> field will contain all the points on the path up to the <em class="italic">previous</em> (but geographically <em class="italic">next</em>) peak or valley. The <strong class="source-inline">:calculated</strong> field will store the calculated values so they can be returned at the end.</p></li>
				<li>We will need to know whether the new position is on the same slope as the positions stored in <strong class="source-inline">current</strong>. Are we still going up, or down, or have we gone over a peak, or across the lowest part of a valley? To simplify our code, we'll write a helper function, taking <strong class="source-inline">current</strong> and the new elevation. This will return <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>:<p class="source-code">(defn same-slope-as-current? [current elevation]</p><p class="source-code">  (or (= 1 (count current))</p><p class="source-code">      (let [[[_ next-to-last] [_ the-last]] (take-last 2 current)]</p><p class="source-code">        (or (&gt;= next-to-last the-last elevation)</p><p class="source-code">            (&lt;= next-to-last the-last elevation)))))</p><p>First, we check whether there is only one value in <strong class="source-inline">current</strong>. If so, we know the answer to our question because, with only two points, we know we are on the same slope. This also protects our next tests from errors since we can now be sure that there are at least two items in <strong class="source-inline">current</strong>. (We still have to be careful not to call this function with an empty list.)</p><p>Now that we know that we have at least two items, we can do some destructuring. This destructuring is doubly nested: first, we take the last two elements in <strong class="source-inline">current</strong>, using the <strong class="source-inline">take-last</strong> function, and then we extract and name the second part of those tuples. To destructure the tuples, we use an underscore, <strong class="source-inline">_</strong>, as a placeholder to indicate that we are not interested in the first value. This use of an underscore here is simply a Clojure convention that means essentially "don't pay attention to this value."</p><p class="callout-heading">Note</p><p class="callout">We named the binding <strong class="source-inline">the-last</strong> instead of simply <strong class="source-inline">last</strong>. This is because of Clojure's <strong class="source-inline">last</strong> function. Since we don't use <strong class="source-inline">last</strong> in this scope, we <em class="italic">could</em> have named the binding <strong class="source-inline">last</strong> without a problem. However, it is a good practice to avoid using names that coincide with standard Clojure functions. The danger is that your local binding might "shadow" a core Clojure function, resulting in a confusing bug. </p><p>Now we have three values and we want to see whether they are either all increasing or all decreasing. This turns out to be quite simple with Clojure's comparison functions, which accept more than two arguments. <strong class="source-inline">(&gt;= next-to-last the-last elevation)</strong> will return <strong class="source-inline">true</strong> if <strong class="source-inline">next-to-last</strong> is greater than or equal to <strong class="source-inline">the-last</strong> , and if <strong class="source-inline">the-last</strong> is greater than or equal to <strong class="source-inline">elevation</strong>.</p></li>
				<li>At the REPL, move to the <strong class="source-inline">bike-race</strong> namespace as follows:<p class="source-code">(in-ns 'bike-race)</p></li>
				<li>Test the <strong class="source-inline">same-slope-as-current?</strong> function:<div id="_idContainer050" class="IMG---Figure"><img src="image/B14502_05_07.jpg" alt="Figure 5.7: Testing the program&#13;&#10;"/></div><p class="figure-caption">Figure 5.7: Testing the program</p><p>It seems to work as expected, including when there is only one value in <strong class="source-inline">current</strong>.</p></li>
				<li>The rest of the function will be structured around a <strong class="source-inline">cond</strong> expression with three branches to handle the three possible cases: the initial case where <strong class="source-inline">current</strong> is empty; the continuing case, when we are on the same slope as what is in <strong class="source-inline">current</strong>; and the slope change case, when we have passed a peak or a valley and we need to reset <strong class="source-inline">current</strong>.<p>Here is the reducing function:</p><p class="source-code-heading">bike_race.clj</p><p class="source-code">42 (fn [{:keys [current] :as acc} [distance elevation :as this-position]]</p><p class="source-code">43    (cond (empty? current)</p><p class="source-code">44          {:current [this-position]</p><p class="source-code">45           :calculated [{:race-position distance</p><p class="source-code">46                         :elevation elevation</p><p class="source-code">47                         :distance-to-next 0</p><p class="source-code">48                         :elevation-to-next 0}]}</p><p class="source-code">49          (same-slope-as-current? current elevation)</p><p class="source-code">50          (-&gt; acc</p><p class="source-code">51              (update :current conj this-position)</p><p class="source-code">52              (update :calculated</p><p class="source-code">53                      conj</p><p class="source-code">54                      {:race-position distance</p><p class="source-code">55                       :elevation elevation</p><p class="source-code">56                       :distance-to-next (- (first (first current)) distance)</p><p class="source-code">57                       :elevation-to-next (- (second (first current)) elevation)}))</p><p class="source-code-link">The complete code for this step can be found at <a href="https://packt.live/2sTxk4m">https://packt.live/2sTxk4m</a></p><p>In what we referred to above as the "continuing case," when we are at a position that prolongs the slope in <strong class="source-inline">current</strong>, we simply subtract the current elevation and distance from the first item in <strong class="source-inline">current</strong>. The "slope change" case is slightly more complex because we have to reset <strong class="source-inline">current</strong>, taking care to include the latest "peak-or-valley." A figure might make this clearer:</p><div id="_idContainer051" class="IMG---Figure"><img src="image/B14502_05_08.jpg" alt="Figure 5.8: The new current starts at the top of the previous peak&#13;&#10;"/></div><p class="figure-caption">Figure 5.8: The new current starts at the top of the previous peak</p><p>To "reset" <strong class="source-inline">current</strong>, therefore, we use the previous peak and our position: </p><p class="source-code">(assoc :current [peak-or-valley this-position])</p><p>Because we are starting over with a new value in <strong class="source-inline">:current</strong>, instead of <strong class="source-inline">update</strong>, we use <strong class="source-inline">assoc</strong>, which replaces the old value entirely.</p></li>
				<li>Test the function using the following command:<p class="source-code">(distances-elevation-tp-next-peak-or-valley distance-elevation)</p><p>The output is as follows:</p><div id="_idContainer052" class="IMG---Figure"><img src="image/B14502_05_09.jpg" alt="Figure 5.9: A partial view of the results&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.9: A partial view of the results</p>
			<p>In this problem, the most important part of the data is the relationship between the items. Problems like this require an approach that allows us to "see" more than one item at a time. Unlike the windowing technique we used with map in the last chapter, in this problem, we don't know beforehand how far we need to look. This is where <strong class="source-inline">reduce</strong> can really shine, because it allows us to shape the accumulator to suit the needs of the problem.</p>
			<h2 id="_idParaDest-117">Exercise <a id="_idTextAnchor127"/>5.03: Winning and Losing Streaks</h2>
			<p>In this exercise, we will start with a vector of all the matches that Serena Williams played in 2015. Each match is represented by a map:</p>
			<p class="source-code">{:loser-sets-won 0,</p>
			<p class="source-code"> :winner-sets-won 2,</p>
			<p class="source-code"> :winner-name "Williams S.",</p>
			<p class="source-code"> :loser-name "Williams V.",</p>
			<p class="source-code"> :tournament "Wimbledon",</p>
			<p class="source-code"> :location "London",</p>
			<p class="source-code"> :date "2015-07-06"}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You don't need this data to perform this exercise, but if you'd like to play around with the data, it is available here: <a href="https://packt.live/37HKOyC">https://packt.live/37HKOyC</a>.</p>
			<p>The goal is to add a <strong class="source-inline">:current_streak</strong> field to each match that would say "Lost 3," if Williams was struggling and had lost her last three matches, or "Won 5":</p>
			<ol>
				<li value="1">In a convenient directory, open a REPL and a file called <strong class="source-inline">tennis_reduce.clj</strong> with the corresponding namespace definition:<p class="source-code">(ns tennis-reduce)</p><p>In Clojure, when a namespace contains more than one word, the words are joined by hyphens. The corresponding file, however, must use underscores instead.</p><p class="callout-heading">Note</p><p class="callout">We'll use this file and namespace for the rest of the tennis-related exercises in this chapter. </p></li>
				<li>From the course's GitHub repository, in <a href="https://packt.live/2sPo4hv">https://packt.live/2sPo4hv</a>, copy the <strong class="source-inline">serena-williams-2015</strong> var into your file.</li>
				<li>Set up the skeleton of a function based on a call to <strong class="source-inline">reduce</strong>, and provide an initializer map:<p class="source-code">(defn serena-williams-win-loss-streaks [matches]</p><p class="source-code">  (reduce (fn [acc match]</p><p class="source-code">            ;; TODO: solve problem</p><p class="source-code">            )</p><p class="source-code">          {:matches []</p><p class="source-code">           :current-wins 0</p><p class="source-code">           :current-losses 0}</p><p class="source-code">          matches))</p><p>The map that we provide as an initial value here shows us the form of the data we need for each iteration. The counters for current wins and current losses are self-explanatory: we'll just need to update those values depending on what happens in each successive match. <strong class="source-inline">:matches</strong> may seem strange at first, though. It is there because we want to return the entire sequence of matches, decorated with the new <strong class="source-inline">:current-streak</strong> field. Because of Clojure's immutability, we can't just modify the matches "in place" as we go along. As we move through the items in the <strong class="source-inline">matches</strong> list, we add some data to each match and then place it in the <strong class="source-inline">:matches</strong> vector in the accumulator.</p></li>
				<li>Extract the matches from the call to <strong class="source-inline">reduce</strong>:<p class="source-code">(defn serena-williams-win-loss-streaks [matches]</p><p class="source-code">  (:matches</p><p class="source-code">    (reduce (fn [acc match]</p><p class="source-code">              ;; TODO: solve problem</p><p class="source-code">              )</p><p class="source-code">            {:matches []</p><p class="source-code">             :current-wins 0</p><p class="source-code">             :current-losses 0}</p><p class="source-code">            matches)))</p><p>The <strong class="source-inline">:current-wins</strong> and <strong class="source-inline">:current-losses</strong> fields aren't useful outside of the function, so we want to only return the newly decorated matches.</p></li>
				<li>Write a helper function that formats a string for presenting the current streak:<p class="source-code">(defn streak-string [current-wins current-losses]</p><p class="source-code">  (cond (pos? current-wins) (str "Won " current-wins)</p><p class="source-code">        (pos? current-losses) (str "Lost " current-losses)</p><p class="source-code">        :otherwise "First match of the year"))</p><p>There are three possible situations: a winning streak (at least one win, zero losses), a losing streak (at least one loss, zero wins) or no matches played yet (zero wins, zero losses). This is a good time to use <strong class="source-inline">cond</strong>, which allows us to have multiple conditions without using nested <strong class="source-inline">if</strong> statements. The test for the final catch-all condition could be anything at all, except <strong class="source-inline">false</strong> or <strong class="source-inline">nil</strong>. We use the <strong class="source-inline">:otherwise</strong> keyword because it is easy to read. And finally, <strong class="source-inline">pos?</strong> is a handy and commonly used predicate for determining whether a number is above zero, rather than writing <strong class="source-inline">(&gt; current-wins 0)</strong>.</p><p>This logic could have been part of the main reducing function. Breaking it out into its own, very simple function makes for easier-to-read code.</p></li>
				<li>Write a skeleton for the reducing function. As usual, it takes two arguments: the accumulator, <strong class="source-inline">acc</strong>, and the current match. All we do here is some destructuring so that we'll have easy access to this context inside the function. We also keep references to the original maps, <strong class="source-inline">acc</strong> and <strong class="source-inline">match</strong>, because our function will end up returning modified versions of them:<p class="source-code">(fn [{:keys [current-wins current-losses] :as acc} </p><p class="source-code">     {:keys [winner-name] :as match}]</p><p class="source-code">  ;; TODO: do something</p><p class="source-code">  )</p></li>
				<li>Introduce a <strong class="source-inline">let</strong> binding for the current match and insert it into the <strong class="source-inline">:matches</strong> vector in the accumulator:<p class="source-code">(fn [{:keys [current-wins current-losses] :as acc} </p><p class="source-code">     {:keys [winner-name] :as match}]</p><p class="source-code">             (let [this-match (assoc match :current-streak (streak-string current-wins current-losses))]</p><p class="source-code">               (update acc :matches #(conj % this-match))))</p><p>Even though our function isn't complete yet, this is the most important part of the data flow. The <strong class="source-inline">match </strong>argument is "decorated" with the current streak information formatted by the <strong class="source-inline">streak-string</strong> helper function and then inserted into the <strong class="source-inline">:matches</strong> vector that the function will return at the end. We don't have the contextual information yet, so that is the next step.</p></li>
				<li>The final step here is to produce the contextual information: we need to update <strong class="source-inline">:current-wins</strong> and <strong class="source-inline">:current-losses</strong> in the accumulator so that we're ready for the next iteration. The logic here is that if Williams won the current match, then we need to add 1 to the current streak and set the losing streak to zero. These will be used for calculating the winning and losing streaks for the next match. Conversely, if Williams lost the previous match, we set the current winning streak to zero and add 1 to the losing streak.<p>To translate this logic into code, we'll start by adding another <strong class="source-inline">let</strong> binding, <strong class="source-inline">serena-victory?</strong>, that we will refer to later:</p><p class="source-code">serena-victory? (= winner-name "Williams S.")</p><p>Now all that remains is updating <strong class="source-inline">:current-wins</strong> and <strong class="source-inline">:current-losses</strong> in <strong class="source-inline">acc</strong>. We'll use the <strong class="source-inline">-&gt;</strong> threading macro because there are several things that need to be done to our accumulator:</p><p class="source-code"> (-&gt; acc</p><p class="source-code">     (update :matches #(conj % this-match))</p><p class="source-code">     (assoc :current-wins (if serena-victory?</p><p class="source-code">                            (inc current-wins)</p><p class="source-code">                            0))</p><p class="source-code">     (assoc :current-losses (if serena-victory?</p><p class="source-code">                              0</p><p class="source-code">                              (inc current-losses))))</p><p>The calls to <strong class="source-inline">assoc</strong> just apply the conditional logic discussed above, incrementing the counters or resetting them to zero. Here is the complete function when we put all the parts back together:</p><p class="source-code">(defn serena-williams-win-loss-streaks [matches]</p><p class="source-code">  (:matches</p><p class="source-code">   (reduce (fn [{:keys [current-wins current-losses] :as acc} match]</p><p class="source-code">             (let [this-match (assoc match :current-streak (streak-string current-wins current-losses))</p><p class="source-code">                   serena-victory? (= (:winner-name match) "Williams S.")]</p><p class="source-code">               (-&gt; acc</p><p class="source-code">                   (update :matches #(conj % this-match))</p><p class="source-code">                   (assoc :current-wins (if serena-victory?</p><p class="source-code">                                          (inc current-wins)</p><p class="source-code">                                          0))</p><p class="source-code">                   (assoc :current-losses (if serena-victory?</p><p class="source-code">                                            0</p><p class="source-code">                                            (inc current-losses))))))</p><p class="source-code">           {:matches []</p><p class="source-code">            :current-wins 0</p><p class="source-code">            :current-losses 0}</p><p class="source-code">           matches)))</p><p>Try the function on the data. You should see something like this:</p></li>
			</ol>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B14502_05_10.jpg" alt="Figure 5.10: Using the function on data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10: Using the function on data</p>
			<p>This example shows us a couple of different interesting things about using <strong class="source-inline">reduce</strong>. The first point is that we are free to create whatever kind of context we would like to pass on to each successive iteration of the reducing function. To make things simple in this case, we just counted the number of wins or losses, but the context can be just as complex as you need it to be.</p>
			<p>The second point is that the ultimate return value can also be whatever we need it to be. The function in this example actually looks like something you might do with <strong class="source-inline">map</strong>: it takes a sequence and returns a sequence of the same length. Yet, by building up data from previous calls to the reducing function, it does something that <strong class="source-inline">map</strong> would be unable to do.</p>
			<h1 id="_idParaDest-118">Reducing w<a id="_idTextAnchor128"/>ithout reduce</h1>
			<p>Before we go any further, it's important to point out that sometimes there are other, better options than <strong class="source-inline">reduce</strong> for taking a sequence and turning it into something non-sequential. Often, this is because Clojure provides functions that do the hard work for us. Sometimes, clever use of Clojure's "sequence-to-sequence" functions can get you the data you need.</p>
			<p>As a general rule, it is usually preferable to do as much as possible with functions that can handle lazy sequences before turning to <strong class="source-inline">reduce</strong>. In some cases, this can be for performance reasons, and in nearly all cases, your code will be easier to write, and, more importantly, <em class="italic">to read</em>, if you can stay in the realm of sequences. That said, most solutions will require a little of both. Knowing how to combine the two is an important skill.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor129"/>zipmap</h2>
			<p>Clo<a id="_idTextAnchor130"/>jure's <strong class="source-inline">zipmap</strong> function is a tool for building a map from two sequences. The first sequence becomes the keys for the new map and the second becomes the values. This is often useful for building a lookup table. Lookup tables can be convenient when you need to repeatedly access data in a sequence based on its content rather than its position in the list. </p>
			<p>It's easy to imagine a scenario where this would be useful. Maybe at one step in a program, you have a list of maps, each one containing contact data for a person. Later, you discover that you often have a telephone number and need to find the corresponding user. If you have a lookup table where the keys are telephone numbers, you can find a user with a simple <strong class="source-inline">(get users-by-phone "+44 011 1234 5678")</strong>. Maps provide easy access, as long as you have meaningful and unique keys.</p>
			<p>The basic operation of <strong class="source-inline">zipmap</strong> is to align two sequences, one for the keys and one for the values, which <strong class="source-inline">zipmap</strong> will "zip" together:</p>
			<p class="source-code">user&gt; (zipmap [:a :b :c] [0 1 2])</p>
			<p class="source-code">{:a 0, :b 1, :c 2}</p>
			<p>Often, you will only have the second list, the values. You will derive values from the list and use them as the keys. Just be careful that the keys are unique to avoid collisions.</p>
			<h2 id="_idParaDest-120">Exercise 5<a id="_idTextAnchor131"/>.04: Creating a Lookup Table with zipmap</h2>
			<p>Maps are an extremely useful and flexible way to quickly access data. Often, however, the data you have is sequential and you find that you would like to be able to access an individual item without having to walk the entire sequence. If you know the criteria that you'll use to look up the item you need, building a lookup table from your data can be an interesting solution.</p>
			<p>In this exercise, you have a list of some of the matches that Petra Kvitova played in 2014. Let's suppose you need to be able to quickly access the matches by date, perhaps to be able to plug them into a calendar of some kind or to test which players were playing on the same day. Whatever the reason, you need to build a map where the keys are dates and the values are the individual matches. Because the same player never plays two matches on the same day, we can be sure that the date keys are unique. Here's how to build the lookup table:</p>
			<ol>
				<li value="1">Copy the following var into your REPL from the book's GitHub repository: <a href="https://packt.live/39Joc2H">https://packt.live/39Joc2H</a>:<p class="source-code-heading">kvitova_matches.clj</p><p class="source-code">1  (def matches</p><p class="source-code">2    [{:winner-name "Kvitova P.",</p><p class="source-code">3      :loser-name "Ostapenko J.",</p><p class="source-code">4      :tournament "US Open",</p><p class="source-code">5      :location "New York",</p><p class="source-code">6      :date "2016-08-29"}</p><p class="source-code">7     {:winner-name "Kvitova P.",</p><p class="source-code">8      :loser-name "Buyukakcay C.",</p><p class="source-code">9      :tournament "US Open",</p><p class="source-code">10     :location "New York",</p><p class="source-code">11     :date "2016-08-31"}</p><p class="source-code-link">The complete code for this step can be found at <a href="https://packt.live/2Ggpsgs">https://packt.live/2Ggpsgs</a></p></li>
				<li>Use <strong class="source-inline">map</strong> to create a sequence with a date from each match:<p class="source-code">user&gt; (map :date matches)</p><p class="source-code">("2016-08-29"</p><p class="source-code"> "2016-08-31"</p><p class="source-code"> "2016-09-02"</p><p class="source-code"> "2016-09-05"</p><p class="source-code"> "2016-09-20"</p><p class="source-code"> "2016-09-21")</p></li>
				<li>Combine both sequences into a single map:<p class="source-code">user&gt; (def matches-by-date (zipmap (map :date matches) matches))</p><p class="source-code">#'user/matches-by-date</p></li>
				<li>Use the map to look up a match by date:<p class="source-code">user&gt; (get matches-by-date "2016-09-20")</p><p class="source-code">{:winner-name "Kvitova P.",</p><p class="source-code"> :loser-name "Brengle M.",</p><p class="source-code"> :tournament "Toray Pan Pacific Open",</p><p class="source-code"> :location "Tokyo",</p><p class="source-code"> :date "2016-09-20"}</p></li>
			</ol>
			<p>In a single line of code, you've created a way to quickly find a match for a given day. Because it's so concise, this pattern can easily be integrated into a more complex function.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Building a lookup table like this might seem wasteful in terms of memory resources. Aren't we doubling the amount of data in memory? Actually, we aren't. Clojure's immutable data structures efficiently share data, which is possible without conflict because the data cannot be modified. This means that, in this example, the original sequence and the lookup table we've created are basically two ways of accessing the same data.</p>
			<h2 id="_idParaDest-121">Maps to Se<a id="_idTextAnchor132"/>quences, and Back Again</h2>
			<p>One of the most useful techniques is one that we mentioned briefly in the last chapter: using <strong class="source-inline">into</strong> to build a map from a list of paired items. This pattern is so versatile that it's worth taking a closer look.</p>
			<p>In its simplest form, the pattern looks like this:</p>
			<p class="source-code">user&gt; (into {} [[:a 1] [:b 2]])</p>
			<p class="source-code">{:a 1, :b 2}</p>
			<p>Maps, after all, are really just data pairs, and Clojure knows how to convert between the two. It's just as easy to make a sequence of tuples from a map:</p>
			<p class="source-code">user&gt; (seq {:a 1 :b 2})</p>
			<p class="source-code">([:a 1] [:b 2])</p>
			<p>Use a map as a map when that makes sense, but don't hesitate to use it as a sequence whenever that's easier.</p>
			<p>When you need to "modify" a map (in the Clojure sense of not actually modifying, but creating a new map with modified data), you may be tempted to use the <strong class="source-inline">keys</strong> function to iterate through the values in the map:</p>
			<p class="source-code">user&gt; (def letters-and-numbers {:a 5 :b 18 :c 35})</p>
			<p class="source-code">#'user/letters-and-numbers</p>
			<p class="source-code">user&gt; (reduce (fn [acc k]</p>
			<p class="source-code">                (assoc acc k (* 10 (get letters-and-numbers k))))</p>
			<p class="source-code">              {}</p>
			<p class="source-code">              (keys letters-and-numbers))</p>
			<p class="source-code">{:a 50, :b 180, :c 350}</p>
			<p>Here, we've used <strong class="source-inline">reduce</strong> to multiply each of the values by 10. This works, but it adds complexity and mental overhead to a problem that can be solved more easily:</p>
			<p class="source-code">user&gt; (into {} (map (fn [[k v]] [k (* v 10)]) letters-and-numbers))</p>
			<p class="source-code">{:a 50, :b 180, :c 350}</p>
			<p>We simply interpret the map, <strong class="source-inline">letters-and-numbers</strong>, as a list of key-value pairs. In the function supplied to <strong class="source-inline">map</strong>, we've used destructuring to assign <strong class="source-inline">k</strong> and <strong class="source-inline">v</strong> to the key and value inside the tuple, which we then wrap up again in a two-item vector. Thanks to <strong class="source-inline">into</strong>, we get a map back again in the end.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For convenience, there is another version of <strong class="source-inline">reduce</strong> specifically for iterating through the key-value pairs in a map, called <strong class="source-inline">reduce-kv</strong>. The main difference is that with <strong class="source-inline">reduce-kv</strong>, the reducing function that you provide takes three arguments, instead of two: the first is the same as <strong class="source-inline">reduce</strong>, but the next two are the key and the corresponding value in the map.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor133"/>group-by</h2>
			<p>S<a id="_idTextAnchor134"/>ummarizing data in Clojure doesn't always mean calling <strong class="source-inline">reduce</strong> directly. The language provides functions that are built on top of <strong class="source-inline">reduce</strong> that are sometimes more convenient. <strong class="source-inline">group-by</strong> is one of those functions.</p>
			<p>The <strong class="source-inline">group-by</strong> function takes a sequence, calls a function on each item, and uses whatever the function call returns as a key in a map. The value of the key will be a list of all the items that returned the same key.</p>
			<p>Let's say that we have a list of maps where each map represents a dish, with a <strong class="source-inline">:name</strong> key for the dish's name, and a <strong class="source-inline">:course</strong> field that tells us what part of the meal the dish is served at:</p>
			<p class="source-code">(def dishes</p>
			<p class="source-code">  [{:name "Carrot Cake"</p>
			<p class="source-code">    :course :dessert}</p>
			<p class="source-code">   {:name "French Fries"</p>
			<p class="source-code">    :course :main}</p>
			<p class="source-code">   {:name "Celery"</p>
			<p class="source-code">    :course :appetizer}</p>
			<p class="source-code">   {:name "Salmon"</p>
			<p class="source-code">    :course :main}</p>
			<p class="source-code">   {:name "Rice"</p>
			<p class="source-code">    :course :main}</p>
			<p class="source-code">   {:name "Ice Cream"</p>
			<p class="source-code">    :course :dessert}])</p>
			<p>With <strong class="source-inline">group-by</strong>, we can organize this list by category. The function we call on each item will just be the <strong class="source-inline">:course</strong> keyword, to extract the corresponding value:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For most of our examples, we use keywords as map keys. This is usually more readable and provides the convenience of using keywords as functions. However, Clojure allows us to use any value as map keys. Just like we've been using strings for the names of tennis players, you can also use any Clojure value as a map key: integers, vectors, maps, even functions!</p>
			<p class="source-code">user&gt; (group-by :course dishes)</p>
			<p class="source-code">           {:dessert</p>
			<p class="source-code">             [{:name "Carrot Cake", :course :dessert}</p>
			<p class="source-code">               {:name "Ice Cream", :course :dessert}],</p>
			<p class="source-code">            :main</p>
			<p class="source-code">            [{:name "French Fries", :course :main}</p>
			<p class="source-code">              {:name "Salmon", :course :main}</p>
			<p class="source-code">              {:name "Rice", :course :main}],</p>
			<p class="source-code">            :appetizer</p>
			<p class="source-code">           [{:name "Celery", :course :appetizer}]}</p>
			<p>With <em class="italic">very</em> little coding, we have a nicely organized map. <strong class="source-inline">group-by</strong> uses <strong class="source-inline">reduce</strong> under the hood and really just encapsulates a fairly simple pattern. We could write a simplified version of <strong class="source-inline">group-by</strong> like this:</p>
			<p class="source-code">user&gt; (defn our-group-by [f xs]</p>
			<p class="source-code">        (reduce (fn [acc x]</p>
			<p class="source-code">                  (update acc (f x) (fn [sublist] (conj (or sublist []) x))))</p>
			<p class="source-code">                {}</p>
			<p class="source-code">                xs))</p>
			<p class="source-code">#'user/our-group-by</p>
			<p>If we call <strong class="source-inline">our-group-by</strong> on the list of dishes, we get the same results:</p>
			<p class="source-code">user&gt; (our-group-by :course dishes)</p>
			<p class="source-code">{:dessert</p>
			<p class="source-code"> [{:name "Carrot Cake", :course :dessert}</p>
			<p class="source-code">  {:name "Ice Cream", :course :dessert}],</p>
			<p class="source-code"> :main</p>
			<p class="source-code"> [{:name "French Fries", :course :main}</p>
			<p class="source-code">  {:name "Salmon", :course :main}</p>
			<p class="source-code">  {:name "Rice", :course :main}],</p>
			<p class="source-code"> :appetizer [{:name "Celery", :course :appetizer}]}</p>
			<p>The official version will have better performance, but the real advantage of a function like <strong class="source-inline">group-by</strong> is that it frees us from thinking about the details. Any time you have a list and some categories, <strong class="source-inline">group-by</strong> is ready to help.</p>
			<h2 id="_idParaDest-123">Exercise 5<a id="_idTextAnchor135"/>.05: Quick Summary Statistics with group-by</h2>
			<p>In this exercise, we'll use <strong class="source-inline">group-by</strong> to quickly count the number of matches played in different tournaments in our tennis match data:</p>
			<ol>
				<li value="1">In the same directory as <em class="italic">Exercise 5.03</em>, <em class="italic">Winning and Losing Streaks</em>, create a <strong class="source-inline">deps.edn</strong> file with the following content:<p class="source-code">{:deps</p><p class="source-code"> {org.clojure/data.csv {:mvn/version "0.1.4"}</p><p class="source-code">  semantic-csv {:mvn/version "0.2.1-alpha1"}}}</p></li>
				<li>Change the namespace declaration in <strong class="source-inline">tennis_reduce.clj</strong> so that it references these two new libraries:<p class="source-code">(ns packt-clj.tennis-reduce</p><p class="source-code">  (:require</p><p class="source-code">            [clojure.java.io :as io]</p><p class="source-code">            [clojure.data.csv :as csv]</p><p class="source-code">            [semantic-csv.core :as sc]))</p></li>
				<li>Start a REPL in the same directory as the previous exercise, with the same <strong class="source-inline">deps.edn</strong>, and then open and evaluate <strong class="source-inline">tennis_reduce.clj</strong>.</li>
				<li>In your REPL, move to the <strong class="source-inline">packt-clj.tennis-reduce</strong> namespace as follows:<p class="source-code">user&gt; (in-ns 'packt-clj.tennis-reduce)</p></li>
				<li>Make sure that you have the <strong class="source-inline">match_scores_1968-1990_unindexed_csv.csv</strong> file in the same directory. This is the same data file we used in <em class="italic">Chapter 4</em>, <em class="italic">Mapping and Filtering</em>. You can find it here: <a href="https://packt.live/36k1o6X">https://packt.live/36k1o6X</a>.</li>
				<li>Set up the now familiar <strong class="source-inline">with-open</strong> macro that we've used before, and give your function an expressive name:<p class="source-code">(defn tennis-csv-&gt;tournament-match-counts [csv]</p><p class="source-code">  (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         ;;....</p><p class="source-code">         )))</p></li>
				<li>Write a call to <strong class="source-inline">group-by</strong> that builds a map where the keys are the <strong class="source-inline">:tourney_slug</strong> instances and the values are the lists of matches played there. To make the output more manageable, temporarily remove all but a few keys in the match maps by mapping over the list with <strong class="source-inline">select-keys</strong>:<p class="source-code">(defn tennis-csv-&gt;tournament-match-counts [csv]</p><p class="source-code">  (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         (map #(select-keys % [:tourney_slug :winner_name :loser_name]))</p><p class="source-code">         (group-by :tourney_slug))))</p></li>
				<li>Evaluate the source file and then try calling this function. Define a var so that your screen doesn't fill up with tennis match data:<p class="source-code">packt-clj.tennis-reduce&gt; (def tournaments (tennis-csv-&gt;tournament-match-counts "match_scores_1991-2016_unindexed_bcsv.csv"))</p><p class="source-code">#'user/tournaments</p></li>
				<li>Examine some of the data, first by using the <strong class="source-inline">keys</strong> function, to see all the tournament names:<p class="source-code">packt-clj.tennis-reduce&gt; (keys tournaments)</p><p class="source-code">("chicago"</p><p class="source-code"> "bologna"</p><p class="source-code"> "munich"</p><p class="source-code"> "marseille"</p><p class="source-code"> "dubai"</p><p class="source-code"> "milan"</p><p class="source-code"> "buzios"</p><p class="source-code"> "miami"</p><p class="source-code"> "warsaw"</p><p class="source-code"> "bucharest"</p><p class="source-code"> "wimbledon"</p><p class="source-code"> "umag"</p><p class="source-code"> "besancon"</p><p class="source-code">;; ....etc.</p><p class="source-code">)</p></li>
				<li>Look at a single tournament. Once again, limit the data returned, this time by using <strong class="source-inline">take</strong>:<p class="source-code">packt-clj.tennis-reduce&gt; (take 5 (get tournaments "chicago"))</p><p class="source-code">({:tourney_slug "chicago",</p><p class="source-code">  :winner_name "John McEnroe",</p><p class="source-code">  :loser_name "Patrick McEnroe"}</p><p class="source-code"> {:tourney_slug "chicago",</p><p class="source-code">  :winner_name "John McEnroe",</p><p class="source-code">  :loser_name "MaliVai Washington"}</p><p class="source-code"> {:tourney_slug "chicago",</p><p class="source-code">  :winner_name "Patrick McEnroe",</p><p class="source-code">  :loser_name "Grant Connell"}</p><p class="source-code"> {:tourney_slug "chicago",</p><p class="source-code">  :winner_name "John McEnroe",</p><p class="source-code">  :loser_name "Alexander Mronz"}</p><p class="source-code"> {:tourney_slug "chicago",</p><p class="source-code">  :winner_name "Patrick McEnroe",</p><p class="source-code">  :loser_name "Richey Reneberg"})</p></li>
				<li>Use <strong class="source-inline">count</strong> to obtain the number of matches played in a single tournament:<p class="source-code">packt-clj.tennis-reduce&gt; (count (get tournaments "chicago"))</p><p class="source-code">31</p></li>
				<li>Calculate the total number of matches played in each tournament using <strong class="source-inline">count</strong> in the original function:<p class="source-code">(defn tennis-csv-&gt;tournament-match-counts [csv]</p><p class="source-code">  (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         (group-by :tourney_slug)</p><p class="source-code">         (map (fn [[k ms]] [k (count ms)]))</p><p class="source-code">         (into {}))))</p><p>Notice that <strong class="source-inline">select-keys</strong> is gone. Since we are reducing the lists of matches to a single integer, there is no point in removing any fields. Here, we use a pattern that you have seen before: the call to <strong class="source-inline">map</strong> treats the Clojure map as if it were a sequence of key-value pairs. The function passed to <strong class="source-inline">map</strong> then returns a two-item vector with the keyword and the newly calculated total. And finally, <strong class="source-inline">into</strong> repackages the sequence back into a map.</p></li>
				<li>Evaluate the file again and call <strong class="source-inline">tennis-csv→tournament-match-counts</strong> again:<p class="source-code">packt-clj.tennis-reduce&gt; (def tournament-totals (tennis-csv-&gt;tournament-match-counts "match_scores_1991-2016_unindexed_csv.csv"))</p><p class="source-code">#'user/tournament-totals</p></li>
				<li>Inspect the data:<p class="source-code">packt-clj.tennis-reduce&gt; (get tournament-totals "chicago")</p><p class="source-code">31</p><p class="source-code">packt-clj.tennis-reduce&gt; (get tournament-totals "wimbledon")</p><p class="source-code">4422</p><p class="source-code">packt-clj.tennis-reduce&gt; (get tournament-totals "roland-garros")</p><p class="source-code">4422</p><p class="source-code">packt-clj.tennis-reduce&gt; (get tournament-totals "australian-open")</p><p class="source-code">4422</p><p class="source-code">packt-clj.tennis-reduce&gt; (get tournament-totals "us-open")</p><p class="source-code">4422</p><p>Here we see that the Grand Slam tournaments have the exact same number of matches over the same period, because these seven-round tournaments are structured identically.</p></li>
			</ol>
			<p>In this exercise, we were able to extract the data we wanted in a few short lines of code. Beyond illustrating the power of <strong class="source-inline">group-by</strong>, this is a good example of how mapping and reducing can work together. We used <strong class="source-inline">group-by</strong> to structure our data, and then <strong class="source-inline">map</strong> to shape it some more. It's easy to imagine using <strong class="source-inline">filter</strong> as well, if we wanted to limit the scope of our inquiry to certain players or certain tournaments, for example.</p>
			<h1 id="_idParaDest-124">Summarizin<a id="_idTextAnchor136"/>g Tennis Scores</h1>
			<p>In the previous chapter, we were able to generate some summary data from the tennis scores, using <strong class="source-inline">filter</strong>. If we wanted to know how many matches a particular player had won, we could filter out that player's victories and call <strong class="source-inline">count</strong>. While this approach works well when we are only interested in one player, it becomes cumbersome if we want more complete data. For example, if we needed to know the number of matches played or won by <em class="italic">each</em> of the players in the dataset, we would have to filter, for each query, the entire history of all the matches. The <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> functions are extremely useful in many situations, but reducing a large collection down into a more compact report is not what they are best for.</p>
			<p>Let's suppose that for each player, we need to know the number of matches played, won, and lost. We'll walk through two different ways to solve the problem in Clojure, the first using <strong class="source-inline">reduce</strong> and the second using <strong class="source-inline">group-by</strong>, one of Clojure's many convenient <strong class="source-inline">reduce</strong>-based functions.</p>
			<p>In the first exercise, we will use a common reducing pattern to build up our data, row by row, from the CSV file. Of course, we'll use the three-argument version of <strong class="source-inline">reduce</strong> with a map as the accumulator.</p>
			<h2 id="_idParaDest-125">Exercise 5<a id="_idTextAnchor137"/>.06: Complex Accumulation with reduce</h2>
			<p>For each row of CSV in the tennis dataset we've been using, the work we need to do is rather simple: count the wins and losses. In an imperative language, the most common approach would be to loop over the results, and for each line do something like this:</p>
			<p class="source-code">var matches = [{winner_slug: 'Player 1',</p>
			<p class="source-code">                loser_slug: 'Player 2'},</p>
			<p class="source-code">               {winner_slug: 'Player 2',</p>
			<p class="source-code">                loser_slug: 'Player 1'}];</p>
			<p class="source-code">var players = {}</p>
			<p class="source-code">for (var i = 0; i &lt; matches.length; i++) {</p>
			<p class="source-code">  var winnerSlug = matches[i].winner_slug;</p>
			<p class="source-code">  var loserSlug = matches[i].loser_slug;</p>
			<p class="source-code">  if (!players[winnerSlug]) {</p>
			<p class="source-code">    players[winnerSlug] = {wins: 0, losses: 0};</p>
			<p class="source-code">  }</p>
			<p class="source-code">  players[winnerSlug].wins = players[winnerSlug].wins + 1;</p>
			<p class="source-code">  if (!players[loserSlug]){</p>
			<p class="source-code">    players[loserSlug] = {wins: 0, losses: 0};</p>
			<p class="source-code">  }</p>
			<p class="source-code">  players[loserSlug].losses = players[loserSlug].losses + 1;</p>
			<p class="source-code">}</p>
			<p class="source-code">console.log(players);</p>
			<p>We will do essentially the same thing in Clojure, but within the scope of a function passed to <strong class="source-inline">reduce</strong>:</p>
			<ol>
				<li value="1">Open <strong class="source-inline">tennis_reduce.clj</strong>, start your REPL, evaluate the file, and move to the <strong class="source-inline">packt-</strong>Copy in the <strong class="source-inline">with-open</strong> pattern that we've used before and prepare the skeleton of a call to <strong class="source-inline">reduce</strong>. We'll call this function <strong class="source-inline">win-loss-by-player</strong>:<p class="source-code">(defn win-loss-by-player [csv]</p><p class="source-code">  (with-open [r (io/reader csv)]</p><p class="source-code">    (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">         sc/mappify</p><p class="source-code">         (reduce (fn [acc row]</p><p class="source-code">                   )</p><p class="source-code">                 {}                       ; an empty map as an accumulator</p><p class="source-code">                 ))))</p><p>We won't need the call to <strong class="source-inline">sc/cast-with</strong> this time, since the only values we need are strings. And we don't need to call <strong class="source-inline">doall</strong> either, because <strong class="source-inline">reduce</strong> is not lazy.</p></li>
				<li>Write the function to pass to <strong class="source-inline">reduce</strong>:<p class="source-code">(fn [acc {:keys [winner_slug loser_slug]}]</p><p class="source-code">  (-&gt; acc</p><p class="source-code">      (update-in [winner_slug :wins]</p><p class="source-code">                 (fn [wins] (inc (or wins 0))))</p><p class="source-code">      (update-in [loser_slug :losses]</p><p class="source-code">                 (fn [losses] (inc (or losses 0))))))</p><p>Here, we use <strong class="source-inline">-&gt;</strong> to thread the accumulator, <strong class="source-inline">acc</strong>, through two calls to <strong class="source-inline">update-in</strong>. This function, like <strong class="source-inline">assoc-in</strong>, allows us to access the content of a nested data structure by providing a vector as a second argument. Each call in this example would look like this:</p><p class="source-code">(update-in acc ["roger-federer" :wins] (fn [wins] (inc (or wins 0))))</p><p>By repeatedly calling this on the accumulator as <strong class="source-inline">reduce</strong> moves through the list of matches, we end up with a large map of player "slugs" mapped to small maps each containing a <strong class="source-inline">:wins</strong> key and a <strong class="source-inline">:losses</strong> key:</p><p class="source-code">{</p><p class="source-code"> ...</p><p class="source-code">  "player" {:wins 10 :losses 5}</p><p class="source-code">  "another-player" {:wins 132 :losses 28}</p><p class="source-code">  ...</p><p class="source-code"> }</p></li>
				<li>Evaluate your file and try running the function on the CSV data. Put the results in a var to avoid filling up your screen with all the data:<p class="source-code">packt-clj.tennis-reduce&gt; (def w-l (win-loss-by-player "match_scores_1991-2016_unindexed_csv.csv"))</p><p class="source-code">#'user/w-l</p></li>
				<li>Look up a player, using the "slug":<p class="source-code">packt-clj.tennis-reduce&gt; (get w-l "roger-federer")</p><p class="source-code">{:losses 240, :wins 1050}</p><p class="callout-heading">Note</p><p class="callout">We need to use <strong class="source-inline">get</strong> here because the keys in our map are strings. If we had used the <strong class="source-inline">keyword</strong> function to convert the player "slugs" when building up the map, we could access a player's data with <strong class="source-inline">(:roger-federer w-l)</strong> instead.</p></li>
			</ol>
			<h1 id="_idParaDest-126">Introducti<a id="_idTextAnchor138"/>on to Elo</h1>
			<p>In the rest of this chapter, and in some of the following chapters, we are going to be working with the Elo Rating System to develop player ratings and predict match outcomes. The algorithm itself is quite simple and it will allow us to demonstrate how Clojure can be used as a data analysis tool. Since we'll be referring to it a lot, it's worth taking a closer look at how it works. The Elo Rating System was developed by Arpad Elo to rate chess players. The United States Chess Federation began using it in 1960.</p>
			<p>Elo ratings work by establishing a score for each player. This score is used to calculate the probable outcome of a match. When the real outcome of the match is known, a player's rating is raised or lowered depending on their performance relative to the probable outcome. In other words, if a beginner with a low rating loses to a higher-rated player, the beginner's rating will not suffer by much, since that outcome was expected. If they defeat the higher-rated player, on the other hand, their rating will increase by a much greater margin, and the higher-rated player's rating will be diminished accordingly.</p>
			<p>The obvious question is, of course, how do we know a player's rating to start with? This requires looking at their previous matches, and the rating of their opponents, which, in turn, are determined by the ratings of <em class="italic">their</em> opponents, and so on. If that sounds recursive, it's because it is. Our strategy will take the form of a complex reduction: starting at the earliest match, we will accumulate player ratings, which we will then use to calculate the scores for each successive match:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B14502_05_11.jpg" alt="Figure 5.11: Reducing from match to match: each result improves the ratings for the next match&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11: Reducing from match to match: each result improves the ratings for the next match</p>
			<p>Does this look familiar? It might, because we are doing the same thing as in the previous reductions: calculating a context, moving it forward, and using it again for the next calculation. The difference with this project is that the context is much more complex. Our method for moving through the data is fundamentally the same.</p>
			<p>Before we can perform this reduction, we need to build a few key pieces of the Elo implementation. At the heart of the Elo system is a simple formula for determining the probability of a player winning a given match. It looks like this:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B14502_05_12.jpg" alt="Figure 5.12: Calculating the probability of outcomes for a given match&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12: Calculating the probability of outcomes for a given match</p>
			<p><em class="italic">P</em><span class="subscript">1</span> and <em class="italic">P</em><span class="subscript">2</span> here are the probabilities of winning for player one and player two. <em class="italic">R</em><span class="subscript">1</span> and <em class="italic">R</em><span class="subscript">2</span> are their respective ratings before the match.</p>
			<p>If we fill in the values for a match between a player, rated at 700, and a stronger player, rated at 1,000, we get the following results:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B14502_05_13.jpg" alt="Figure 5.13: Example Elo calculation for a single match&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: Example Elo calculation for a single match</p>
			<p>The <em class="italic">P</em><span class="subscript">1</span> value indicates that there is a 15% chance that the weaker player will win the match and an 85% chance that the stronger player will win. The reliability of these percentages depends, of course, on the quality of the ratings. Before we look at how the ratings are calculated, though, let's translate these equations into Clojure functions.</p>
			<h2 id="_idParaDest-127">Exercise 5.07<a id="_idTextAnchor139"/>: Calculating Probabilities for a Single Match</h2>
			<p>In this exercise, we'll set up one of the building blocks for our implementation of the Elo system, the formula for calculating the probabilities of victory for each of the two players in a match, based on their current ratings:</p>
			<ol>
				<li value="1">In the same folder as in the previous exercises, add <strong class="source-inline">math.numeric-tower</strong>, which is Clojure's standard <strong class="source-inline">math</strong> library, to your <strong class="source-inline">deps.edn</strong> file. It should look like this now:<p class="source-code">{:deps</p><p class="source-code"> {org.clojure/data.csv {:mvn/version "0.1.4"}</p><p class="source-code">  semantic-csv {:mvn/version "0.2.1-alpha1"}</p><p class="source-code">  org.clojure/math.numeric-tower {:mvn/version "0.0.4"}}}</p><p>In <strong class="source-inline">tennis_reduce.clj</strong>, update the namespace declaration:</p><p class="source-code">(ns packt-clj.tennis-reduce</p><p class="source-code">  (:require</p><p class="source-code">            [clojure.java.io :as io]</p><p class="source-code">            [clojure.data.csv :as csv]</p><p class="source-code">            [semantic-csv.core :as sc]</p><p class="source-code">            [clojure.math.numeric-tower :as math]))</p></li>
				<li>Open a REPL session, evaluate <strong class="source-inline">tennis_reduce.clj</strong>, and move to the <strong class="source-inline">packt-clj.tennis-reduce</strong> namespace.</li>
				<li>Write a function implementing the formula for calculating the probability of a player defeating another player:<p class="source-code">packt-clj.tennis-reduce&gt; (defn match-probability [player-1-rating player-2-rating]</p><p class="source-code">        (/ 1</p><p class="source-code">           (+ 1 </p><p class="source-code">           (math/expt 10 (/ (- player-2-rating player-1-rating) 400)))))</p></li>
				<li>Try your function with players of different strengths:<p class="source-code">packt-clj.tennis-reduce&gt; (match-probability 700 1000)</p><p class="source-code">0.15097955721132328</p><p class="source-code">packt-clj.tennis-reduce&gt; (match-probability 1000 700)</p><p class="source-code">0.8490204427886767</p><p class="source-code">packt-clj.tennis-reduce&gt; (match-probability 1000 1000)</p><p class="source-code">1/2</p><p class="source-code">packt-clj.tennis-reduce&gt; (match-probability 400 2000)  ;; beginner vs. master</p><p class="source-code">1/10001</p></li>
			</ol>
			<p>When the match is finally played, if the strong player wins, their rating will increase modestly (and their opponent's rating will go down slightly) because the result was not a surprise. If the weaker player wins, on the other hand, the change to the ratings will be much more significant.</p>
			<p>This equation shows how the player's score is updated after a match:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B14502_05_14.jpg" alt="Figure 5.14: Equation to calculate the player’s score&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: Equation to calculate the player's score</p>
			<p>A player's new rating (<em class="italic">R'</em>) is based on their previous rating (<em class="italic">R</em>), the match score (<em class="italic">S</em>), the expected score (<em class="italic">ES</em>), and the <em class="italic">K</em> factor.</p>
			<p>The score (<em class="italic">S</em>) of a tennis match is either 0, for a loss, or 1, for a victory. If a player is expected to win by a probability of 0.75 and they go on to win their match, then the (<em class="italic">S</em> - <em class="italic">ES</em>) part of the equation works out to 1 - 0.75 = 0.25. This result gets multiplied by what the Elo system calls the "<em class="italic">K</em> factor." The <em class="italic">K</em> factor determines the impact of a match result on a player's overall rating. A high <em class="italic">K</em> factor means ratings will move around a lot; a low <em class="italic">K</em> factor means they will be more stable. If we use a <em class="italic">K</em> factor of 32, that gives us 32 * 0.25 = 8, so the player's rating in this example would go up by eight points. If the player had lost instead, we would get 32 * (0 - 0.75) = -24. Once again, unexpected results thus have a much greater impact on ratings.</p>
			<h2 id="_idParaDest-128">Exercise 5.08:<a id="_idTextAnchor140"/> Updating Player Ratings</h2>
			<p>In this exercise, we will update the player ratings:</p>
			<ol>
				<li value="1">In the same file and REPL session as the previous exercise, define a <strong class="source-inline">k-factor</strong> var and a function that encapsulates the equation for updating a player's rating after a match:<p class="source-code">packt-clj.tennis-reduce&gt; (def k-factor 32)</p><p class="source-code">#'packt-clj.tennis-reduce/k-factor</p><p class="source-code">packt-clj.tennis-reduce&gt; (defn recalculate-rating [previous-rating expected-outcome real-outcome]</p><p class="source-code">        (+ previous-rating (* k-factor (- real-outcome expected-outcome))))</p><p class="source-code">#'packt-clj.tennis-reduce/recalculate-rating</p><p>Now, let's test the equation with some outputs from the <strong class="source-inline">match-probability</strong> function that we defined earlier.</p></li>
				<li>A player rated 1,500 loses to a slightly weaker player (1,400):<p class="source-code">packt-clj.tennis-reduce&gt; (match-probability 1500 1400)</p><p class="source-code">0.6400649998028851</p><p class="source-code">packt-clj.tennis-reduce&gt; (recalculate-rating 1500 0.64 0)</p><p class="source-code">1479.52</p><p>The player's rating has gone down by almost 21 points.</p></li>
				<li>A player with a low rating, 400, scores an upset victory against a strong player (1,000):<p class="source-code">packt-clj.tennis-reduce&gt; (match-probability 400 1000)</p><p class="source-code">0.030653430031715508</p><p class="source-code">packt-clj.tennis-reduce&gt; (recalculate-rating 400 0.03 1)</p><p class="source-code">431.04</p><p>In this example, the supposedly weaker player gains 31 points, which is close to the maximum possible gain per match when <em class="italic">K</em> is 32. This shows how <em class="italic">K</em> determines the importance of a single match.</p></li>
			</ol>
			<p>These two equations are all the math we need. That's it! The beauty of the Elo system is that the actual calculations are quite simple. Now, it's time to start using the functions we've written on some real data.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor141"/>Activity 5.01: Calculating Elo Ratings for Tennis</h2>
			<p>A sports jou<a id="_idTextAnchor142"/>rnalism website has asked you to provide improved ratings for the men's professional tennis circuit. They want to know the relative strengths of current players, as well as the strength of a given player during a given year in the past. Most of all, the journalists want high-quality predictions for future matches.</p>
			<p>Your assignment is to build the prototype for this new system. A REPL-based implementation is fine for now, but it's important to be able to demonstrate the accuracy of your results based on past match data.</p>
			<p>To do this, you'll need to write a function that parses the CSV file that we've been working with, using <strong class="source-inline">reduce</strong>. The function will not only calculate player ratings. It will also keep track of its own success rate in predicting match results. This will allow you to show the journalists how well your algorithm works, and before that, it will allow you to tweak your code to obtain the best possible predictions.</p>
			<p>Your accumulator map will need to build up the following information:</p>
			<ul>
				<li><strong class="bold">Player ratings</strong>: This is the most important part: a huge map linking each player to his rating. The map will be updated with the new ratings for the two players in the match being analyzed.</li>
				<li><strong class="bold">Success count</strong>: For each match where one of the two players has a better than 50% chance of winning, did the expected winner actually win? By counting successes, you'll be able to divide by the total number of match predictions to determine the precision of your predictions.</li>
				<li><strong class="bold">Total match count</strong>: The total number of matches that have been considered.</li>
				<li><strong class="bold">Prediction count</strong>: The number of matches where a winner could be predicted – that is, matches where the forecast was not 50-50. Since we're excluding those matches from the success count, we need to exclude them from the prediction count.<p>These steps will help you complete the activity:</p></li>
			</ul>
			<ol>
				<li value="1">Set up your project with a <strong class="source-inline">deps.edn</strong> file containing the necessary references to the Clojure libraries you will use and include the tennis data files from <a href="https://packt.live/37DCkZn">https://packt.live/37DCkZn</a>.</li>
				<li>Place your work in a new file and namespace. Include the <strong class="source-inline">recalculate-rating</strong> and <strong class="source-inline">match-probability</strong> functions from the previous exercises.</li>
				<li>Write the skeleton for a new function. It should accept two arguments: the path to the CSV file and a <em class="italic">K</em> factor.</li>
				<li>Adapt the pattern based around <strong class="source-inline">with-open</strong> used in previous activities and exercises for reading the file, mappifying each line and converting useful fields to integers.</li>
				<li>Prepare a call to <strong class="source-inline">reduce</strong> that will encompass most of the remaining logic you need to write.</li>
				<li>Design an initializer/accumulator map as the second argument to <strong class="source-inline">reduce</strong> that will adequately keep track of all the information you need to pass on from one iteration to the next.</li>
				<li>Write the code to update the accumulator after each match. Use the functions you already have to predict a winner and adjust the ratings according to the actual result of the match.</li>
				<li>Test your function on the tennis datasets.</li>
				<li>When testing, the results will be huge, so remember to assign them to a var. Check your results in the REPL by querying the result map.</li>
				<li>You should be able to query your results like this:</li>
			</ol>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B14502_05_15.jpg" alt="Figure 5.15: Expected query results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: Expected query results</p>
			<p>You should also be able to check how often the match predictions were correct:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B14502_05_16.jpg" alt="Figure 5.16: Checking the match prediction&#13; &#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16: Checking the match prediction</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 693.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor143"/>Summary</h1>
			<p>With thi<a id="_idTextAnchor144"/>s chapter, we've taken another important step forward in our exploration of Clojure's collections and how to use them to solve problems. Techniques involving collections will always be at the heart of your Clojure programming experience: they will inform how you organize your code, as well as how you choose and design your data structures.</p>
			<p>In the next chapter, we will take a look at flexible ways to work with the collections in Clojure. </p>
		</div>
	</body></html>