["```java\n$ sbt runCH05-HelloAkka-DSL\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n[info] Running org.restwithscala.chapter5.gettingstarted.HelloDSL \nPress <enter> to exit.\n\n```", "```java\n  lazy val akkaHttpVersion = \"1.0\"\n\n  val backendDeps = Seq (\n    \"com.typesafe.akka\" %% \"akka-stream-experimental\" % akkaHttpVersion,\n    \"com.typesafe.akka\" %% \"akka-http-core-experimental\" % akkaHttpVersion,\n    \"com.typesafe.akka\" %% \"akka-http-experimental\" % akkaHttpVersion,\n    \"com.typesafe.akka\" %% \"akka-http-spray-json-experimental\" % akkaHttpVersion\n  )\n```", "```java\nimport akka.actor.ActorSystem\nimport akka.stream.ActorMaterializer\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.server.Directives._\n\nobject HelloDSL extends App {\n  // used to run the actors\n  implicit val system = ActorSystem(\"my-system\")\n  // materializes underlying flow definition into a set of actors\n  implicit val materializer = ActorMaterializer()\n\n  val route =\n    path(\"hello\") {\n      get {\n        complete {\n          \"hello Akka-HTTP DSL\"\n        }\n      }\n    }\n\n  // start the server\n  val bindingFuture = Http().bindAndHandle(route, \"localhost\", 8080)\n\n  // wait for the user to stop the server\n  println(\"Press <enter> to exit.\")\n  Console.in.read.toChar\n\n  // gracefully shut down the server\n  import system.dispatcher\n  bindingFuture\n    .flatMap(_.unbind())\n    .onComplete(_ => system.shutdown())\n}\n```", "```java\n  val route =\n    path(\"hello\") {\n      get {\n        complete {\n          \"hello Akka-HTTP DSL\"\n        }\n      }\n    }\n```", "```java\n  import system.dispatcher\n  bindingFuture\n    .flatMap(_.unbind())\n    .onComplete(_ => system.shutdown())\n```", "```java\n  val route =\n    // handle the /tasks part of the request\n    path(\"tasks\") {\n      get {\n        complete { \"Return all the tasks\" }\n      } ~\n      post {\n        complete { s\"Create a new task\" }\n      } // any other request is also rejected.\n    } ~ { // we handle the \"/tasks/id separately\"\n      path(\"tasks\" / IntNumber) {\n        task => {\n          entity(as[String]) { body => {\n            put { complete { \n        s\"Update an existing task with id: $task and body: $body\" } }\n          } ~\n            get { complete { \n        s\"Get an existing task with id : $task and body: $body\" } }\n          } ~ {\n            // We can manually add this rejection.\n            reject(MethodRejection(HttpMethods.GET),\n                   MethodRejection(HttpMethods.PUT))\n          }\n        }\n      }\n    }\n```", "```java\n$ sbt runCH05-runCH05Step1\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n[info] Compiling 3 Scala sources to /Users/jos/dev/git/rest-with-scala/chapter-05/target/scala-2.11/classes...\n[info] Running org.restwithscala.chapter5.steps.AkkaHttpDSLStep1 \nPress <enter> to exit.\n\n```", "```java\npath(\"tasks\" / IntNumber) {\n        task => {\n          entity(as[String]) { body => {\n            put { complete { \n        s\"Update an existing task with id: $task and body: $body\" } }\n          } ~\n            get { complete { \n        s\"Get an existing task with id : $task and body: $body\" } }\n          } \n        }\n      }\n    }\n```", "```java\nentity(as[String]) { body => {\n            put { complete { \n        s\"Update an existing task with id: $task and body: $body\" } }\n     }\n```", "```java\nval exampleHeaderRoute = path(\"example\") {\n  (headerValueByName(\"my-custom-header\")) { header => {\n      complete(s\"Extracted header value: $header\")\n    }\n  }\n}\n```", "```java\n      get {\n        complete { \"Return all the tasks\" }\n      }\n```", "```java\n{\n// We can manually add this rejection.\nreject(MethodRejection(HttpMethods.GET),\n   MethodRejection(HttpMethods.PUT))\n}\n```", "```java\n$ sbt runCH05-runCH05Step2\n[info] Loading project definition from /Users/jos/dev/git/rest-with-scala/project\n[info] Set current project to rest-with-scala (in build file:/Users/jos/dev/git/rest-with-scala/)\n[info] Compiling 1 Scala source to /Users/jos/dev/git/rest-with-scala/chapter-05/target/scala-2.11/classes...\n[info] Running org.restwithscala.chapter5.steps.AkkaHttpDSLStep2 \nPress <enter> to exit.\n\n```", "```java\n        ((post) & \n        (parameters(\"title\", \"person\".?, \"status\" ? \"new\"))) { \n                                 (title, assignedTo, status) => {\n          (entity(as[String])) { body => {\n            complete {\n              val createdTask = TaskService.insert(\n                 Task(-1, \n                      title,\n                      body,\n                      assignedTo.map(Person(_)),\n                      List.empty, Status(status)))\n              createdTask.map(_.toString)\n            }\n           }\n          }\n        }\n      }\n```", "```java\ncomplete {\n  // our TaskService returns a Future[List[String]]. We map // this to a single Future[String] instance that can be returned // automatically by Akka HTTP\n  TaskService.all.map(_.foldLeft(\"\")((z, b) => z + b.toString + \"\\n\"))\n}\n```", "```java\nval sampleHeader: HttpHeader = \n          (HttpHeader.parse(\"helloheader\",\"hellovalue\") match {\n    case ParsingResult.Ok(header, _) => Some(header)\n    case ParsingResult.Error(_) => None\n}).get\n...\n\nimplicit val StringMarshaller: ToEntityMarshaller[Task] =\n    Marshaller.opaque { s =>\n           HttpEntity(ContentType(`text/plain`), s.toString) }\n...\n\nget {\n  ( setCookie(HttpCookie(name = \"hello\", value = \"world\")) &\n    respondWithHeader(sampleHeader)\n    ) {\n    onComplete(TaskService.select(task)) {\n      case Success(Some(value)) => complete(value)\n      case Success(None) => complete(StatusCodes.NotFound, \n                                         \"No tasks found\")\n      case Failure(ex)  => complete(StatusCodes.InternalServerError,\n                              s\"An error occurred: ${ex.getMessage}\")\n    }\n  }\n}\n```", "```java\nfinal case class HttpResponse(status: StatusCode = StatusCodes.OK,\n                 headers: immutable.Seq[HttpHeader] = Nil,\n                 entity: ResponseEntity = HttpEntity.Empty,\n                 protocol: HttpProtocol = HttpProtocols.`HTTP/1.1`)\n```", "```java\nhandleRejections(customRejectionHandler) {\n  ((post) & (parameters(\"title\", \"person\".?, \"status\" ? \"new\"))) { \n         (title, assignedTo, status) => { \n    (entity(as[String])) { body => {\n      (validate(title.length > 10, \n            \"Title must be longer than 10 characters\") &\n        validate(List(\"new\", \"done\", \"in progress\").contains(status),  \n            \"Status must be either 'new', 'done' or 'in progress'\") &\n        validate(body.length > 0, \n            \"Title must be longer than 10 characters\")\n        ) {\n        complete {\nTaskService.insert(Task(-1, title, body, \n                    assignedTo.map(Person(_)),\n                    List.empty, Status(status)))\n\n        }\n      }\n    }\n    }\n  }\n  }\n}\n```", "```java\n  val customRejectionHandler =\n    RejectionHandler.newBuilder()\n      .handle {\n      case ValidationRejection(cause, exception) =>\n        complete(HttpResponse(StatusCodes.BadRequest, entity = \n                 s\"Validation failed: $cause\"))\n    }.result()\n```", "```java\nval customExceptionHandler = ExceptionHandler {\n  case _: IllegalArgumentException =>\n    // you can easily access any request parameter here using extractors.\n    extractUri { uri =>\n      complete(HttpResponse(StatusCodes.InternalServerError, entity = s\"The function on $uri isn't implemented yet\"))\n    }\n}\n...\npath(\"search\") {\n  handleExceptions(customExceptionHandler) {\n      failWith(IllegalArgumentException(\"Search call not implemented\"))\n  }\n}\n```", "```java\nval backendDeps = Seq (\n  \"com.typesafe.akka\" %% \"akka-stream-experimental\" % akkaHttpVersion,\n  \"com.typesafe.akka\" %% \"akka-http-core-experimental\" % akkaHttpVersion,\n  \"com.typesafe.akka\" %% \"akka-http-experimental\" % akkaHttpVersion,\n  \"com.typesafe.akka\" %% \"akka-http-spray-json-experimental\" % akkaHttpVersion\n)\n```", "```java\ntrait AkkaJSONProtocol extends DefaultJsonProtocol {\n  implicit val statusFormat = jsonFormat1(Status.apply)\n  implicit val noteFormat = jsonFormat2(Note.apply)\n  implicit val personFormat = jsonFormat1(Person.apply)\n  implicit val taskFormat = jsonFormat6(Task.apply)\n}\n```", "```java\nimport akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\nimport akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport\n```", "```java\nobject AkkaHttpDSLStep4 extends App with AkkaJSONProtocol\n```", "```java\npath(\"tasks\") {\n  get {\n    complete {\n      TaskService.all\n    }\n  }\n}\n```", "```java\npost {\n   (entity(as[Task])) { task => {\n      complete {\n        TaskService.insert(task)\n      }\n    }\n  }\n}\n```"]