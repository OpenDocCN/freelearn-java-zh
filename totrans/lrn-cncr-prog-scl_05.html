<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 5. Data-Parallel Collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/><span class="koboSpan" id="kobo.1.1">Chapter 5. Data-Parallel Collections</span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"Premature optimization is the root of all evil."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Donald Knuth</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">So far, we have been composing multiple threads of computation into safe concurrent programs. </span><span class="koboSpan" id="kobo.8.2">In doing so, we focused on ensuring their correctness. </span><span class="koboSpan" id="kobo.8.3">We saw how to avoid blocking in concurrent programs, react to the completion of asynchronous computations, and how to use concurrent data structures to communicate information between threads. </span><span class="koboSpan" id="kobo.8.4">All these tools made organizing the structure of concurrent programs easier. </span><span class="koboSpan" id="kobo.8.5">In this chapter, we will focus mainly on achieving good performance. </span><span class="koboSpan" id="kobo.8.6">We require minimal or no changes in the organization of existing programs, but we will study how to reduce their running time using multiple processors. </span><span class="koboSpan" id="kobo.8.7">Futures from the previous chapter allowed doing this to a certain extent, but they are relatively heavyweight and inefficient when the asynchronous computation in each future is short.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.9.1">Data parallelism</span></strong></span><span class="koboSpan" id="kobo.10.1"> is a form of computation where the same computation proceeds in parallel on different data elements. </span><span class="koboSpan" id="kobo.10.2">Rather than having concurrent computation tasks that communicate through the use of synchronization, in data-parallel programming, independent computations produce values that are eventually merged together in some way. </span><span class="koboSpan" id="kobo.10.3">An input to a data-parallel operation is usually a dataset such as a collection, and the output can be a value or another dataset.</span></p><p><span class="koboSpan" id="kobo.11.1">In this chapter, we will study the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.12.1">Starting a data-parallel operation</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.13.1">Configuring the parallelism level of a data-parallel collection</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.14.1">Measuring performance and why it is important</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.15.1">Differences between using sequential and parallel collections</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.16.1">Using parallel collections together with concurrent collections</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.17.1">Implementing a custom parallel collection, such as a parallel string</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.18.1">Alternative data-parallel frameworks</span></li></ul></div><p><span class="koboSpan" id="kobo.19.1">In Scala, data-parallel programming was applied to the standard collection framework to accelerate bulk operations that are, by their nature, declarative and fit data parallelism well. </span><span class="koboSpan" id="kobo.19.2">Before studying data-parallel collections, we will present a brief overview of the Scala collection framework.</span></p><div class="section" title="Scala collections in a nutshell"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/><span class="koboSpan" id="kobo.20.1">Scala collections in a nutshell</span></h1></div></div></div><p><span class="koboSpan" id="kobo.21.1">The Scala collections module is a package in the Scala standard library that contains a variety of general-purpose collection types. </span><span class="koboSpan" id="kobo.21.2">Scala collections provide a general and easy-to-use way of declaratively manipulating data using functional combinators. </span><span class="koboSpan" id="kobo.21.3">For example, in the following program, we use the </span><code class="literal"><span class="koboSpan" id="kobo.22.1">filter</span></code><span class="koboSpan" id="kobo.23.1"> combinator on a range of numbers to return a sequence of palindromes between 0 and 100,000; that is, numbers that are read in the same way in both the forward and reverse direction:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.24.1">(0 until 100000).filter(x =&gt; x.toString == x.toString.reverse) 
</span></pre><p><span class="koboSpan" id="kobo.25.1">Scala collections define three basic types of collections: </span><span class="strong"><strong><span class="koboSpan" id="kobo.26.1">sequences</span></strong></span><span class="koboSpan" id="kobo.27.1">, </span><span class="strong"><strong><span class="koboSpan" id="kobo.28.1">maps</span></strong></span><span class="koboSpan" id="kobo.29.1">, and </span><span class="strong"><strong><span class="koboSpan" id="kobo.30.1">sets</span></strong></span><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">Elements stored in sequences are ordered and can be retrieved using the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">apply</span></code><span class="koboSpan" id="kobo.33.1"> method and an integer index. </span><span class="koboSpan" id="kobo.33.2">Maps store key-value pairs and can be used to retrieve a value associated with a specific key. </span><span class="koboSpan" id="kobo.33.3">Sets can be used to test the element membership with the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">apply</span></code><span class="koboSpan" id="kobo.35.1"> method.</span></p><p><span class="koboSpan" id="kobo.36.1">The Scala collection library makes a distinction between immutable collections, which cannot be modified after they are created, and mutable collections which can be updated after they are created. </span><span class="koboSpan" id="kobo.36.2">Commonly used immutable sequences are </span><code class="literal"><span class="koboSpan" id="kobo.37.1">List</span></code><span class="koboSpan" id="kobo.38.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.39.1">Vector</span></code><span class="koboSpan" id="kobo.40.1">, while </span><code class="literal"><span class="koboSpan" id="kobo.41.1">ArrayBuffer</span></code><span class="koboSpan" id="kobo.42.1"> is the mutable sequence of choice in most situations. </span><span class="koboSpan" id="kobo.42.2">Mutable </span><code class="literal"><span class="koboSpan" id="kobo.43.1">HashMap</span></code><span class="koboSpan" id="kobo.44.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.45.1">HashSet</span></code><span class="koboSpan" id="kobo.46.1"> collections are maps and sets implemented using hash tables, while immutable </span><code class="literal"><span class="koboSpan" id="kobo.47.1">HashMap</span></code><span class="koboSpan" id="kobo.48.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.49.1">HashSet</span></code><span class="koboSpan" id="kobo.50.1"> collections are based on the less widely known hash trie data structure.</span></p><p><span class="koboSpan" id="kobo.51.1">Scala collections can be transformed into their parallel counterparts by calling the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">par</span></code><span class="koboSpan" id="kobo.53.1"> method. </span><span class="koboSpan" id="kobo.53.2">The resulting collection is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.54.1">parallel collection</span></strong></span><span class="koboSpan" id="kobo.55.1">, and its operations are accelerated by using multiple processors simultaneously. </span><span class="koboSpan" id="kobo.55.2">The previous example can run in parallel, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.56.1">(0 until 100000).par.filter(x =&gt; x.toString == x.toString.reverse) 
</span></pre><p><span class="koboSpan" id="kobo.57.1">In the preceding code line, the filter combinator is a data-parallel operation. </span><span class="koboSpan" id="kobo.57.2">In this chapter, we will study parallel collections in more detail. </span><span class="koboSpan" id="kobo.57.3">We will see when and how to create parallel collections, study how they can be used together with sequential collections, and conclude by implementing a custom parallel collection class.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using parallel collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/><span class="koboSpan" id="kobo.1.1">Using parallel collections</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Most of the concurrent programming utilities we have studied so far are used in order to enable different threads of computation to exchange information. </span><span class="koboSpan" id="kobo.2.2">Atomic variables, the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">synchronized</span></code><span class="koboSpan" id="kobo.4.1"> statement, concurrent queues, futures, and promises are focused on ensuring the correctness of a concurrent program. </span><span class="koboSpan" id="kobo.4.2">On the other hand, the parallel collection programming model is designed to be largely identical to that of sequential Scala collections; parallel collections exist solely in order to improve the running time of the program. </span><span class="koboSpan" id="kobo.4.3">In this chapter, we will measure the relative speedup of programs using parallel collections. </span><span class="koboSpan" id="kobo.4.4">To make this task easier, we will introduce the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">timed</span></code><span class="koboSpan" id="kobo.6.1"> method to the package object used for the examples in this chapter. </span><span class="koboSpan" id="kobo.6.2">This method takes a block of code body, and returns the running time of the executing block of code </span><code class="literal"><span class="koboSpan" id="kobo.7.1">body</span></code><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">It starts by recording the current time with the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">nanoTime</span></code><span class="koboSpan" id="kobo.10.1"> method from the JDK </span><code class="literal"><span class="koboSpan" id="kobo.11.1">System</span></code><span class="koboSpan" id="kobo.12.1"> class. </span><span class="koboSpan" id="kobo.12.2">It then runs the body, records the time after the body executes, and computes the time difference:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">@volatile var dummy: Any = _ 
def timed[T](body: =&gt;T): Double = { 
  val start = System.nanoTime 
  dummy = body 
  val end = System.nanoTime 
  ((end - start) / 1000) / 1000.0 
} 
</span></pre><p><span class="koboSpan" id="kobo.14.1">Certain runtime optimizations in the JVM, such as dead-code elimination, can potentially remove the invocation of the </span><code class="literal"><span class="koboSpan" id="kobo.15.1">body</span></code><span class="koboSpan" id="kobo.16.1"> block, causing us to measure an incorrect running time. </span><span class="koboSpan" id="kobo.16.2">To prevent this, we assign the return value of the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">body</span></code><span class="koboSpan" id="kobo.18.1"> block to a volatile field named </span><code class="literal"><span class="koboSpan" id="kobo.19.1">dummy</span></code><span class="koboSpan" id="kobo.20.1">.</span></p><p><span class="koboSpan" id="kobo.21.1">Program performance is subject to many factors, and it is very hard to predict in practice. </span><span class="koboSpan" id="kobo.21.2">Whenever you can, you should validate your performance assumptions with measurements. </span><span class="koboSpan" id="kobo.21.3">In the following example, we use the Scala </span><code class="literal"><span class="koboSpan" id="kobo.22.1">Vector</span></code><span class="koboSpan" id="kobo.23.1"> class to create a vector with five million numbers and then shuffle that vector using the </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Random</span></code><span class="koboSpan" id="kobo.25.1"> class from the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">scala.util</span></code><span class="koboSpan" id="kobo.27.1"> package. </span><span class="koboSpan" id="kobo.27.2">We then compare the running time of the sequential and parallel </span><code class="literal"><span class="koboSpan" id="kobo.28.1">max</span></code><span class="koboSpan" id="kobo.29.1"> methods, which both find the greatest integer in the </span><code class="literal"><span class="koboSpan" id="kobo.30.1">numbers</span></code><span class="koboSpan" id="kobo.31.1"> collection:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">import scala.collection._ 
import scala.util.Random 
object ParBasic extends App { 
  val numbers = Random.shuffle(Vector.tabulate(5000000)(i =&gt; i)) 
  val seqtime = timed { numbers.max } 
  log(s"Sequential time $seqtime ms") 
  val partime = timed { numbers.par.max } 
  log(s"Parallel time $partime ms") 
} 
</span></pre><p><span class="koboSpan" id="kobo.33.1">Running this program on an Intel i7-4900MQ quad-core processor with hyper-threading and Oracle JVM Version 1.7.0_51, we find that the sequential </span><code class="literal"><span class="koboSpan" id="kobo.34.1">max</span></code><span class="koboSpan" id="kobo.35.1"> method takes 244 milliseconds, while its parallel version takes 35 milliseconds. </span><span class="koboSpan" id="kobo.35.2">This is partly because parallel collections are optimized better than their sequential counterparts, and partly because they use multiple processors. </span><span class="koboSpan" id="kobo.35.3">However, on different processors and JVM implementations, results will vary.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip51"/><span class="koboSpan" id="kobo.36.1">Tip</span></h3><p><span class="koboSpan" id="kobo.37.1">Always validate assumptions about performance by measuring the execution time.</span></p></div></div><p><span class="koboSpan" id="kobo.38.1">The </span><code class="literal"><span class="koboSpan" id="kobo.39.1">max</span></code><span class="koboSpan" id="kobo.40.1"> method is particularly well-suited for parallelization. </span><span class="koboSpan" id="kobo.40.2">Worker threads can independently scan subsets of the collection, such as </span><code class="literal"><span class="koboSpan" id="kobo.41.1">numbers</span></code><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">When a worker thread finds the greatest integer in its own subset, it notifies the other processors and they agree on the greatest result. </span><span class="koboSpan" id="kobo.42.3">This final step takes much less time than searching for the greatest integer in a collection subset. </span><span class="koboSpan" id="kobo.42.4">We say that the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">max</span></code><span class="koboSpan" id="kobo.44.1"> method is </span><span class="strong"><strong><span class="koboSpan" id="kobo.45.1">trivially parallelizable</span></strong></span><span class="koboSpan" id="kobo.46.1">.</span></p><p><span class="koboSpan" id="kobo.47.1">In general, data-parallel operations require more inter-processor communication than the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">max</span></code><span class="koboSpan" id="kobo.49.1"> method. </span><span class="koboSpan" id="kobo.49.2">Consider the </span><code class="literal"><span class="koboSpan" id="kobo.50.1">incrementAndGet</span></code><span class="koboSpan" id="kobo.51.1"> method on atomic variables from </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.52.1">Chapter 3</span></a><span class="koboSpan" id="kobo.53.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.54.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">We can use this method once again to compute unique identifiers. </span><span class="koboSpan" id="kobo.55.3">This time, we will use parallel collections to compute a large number of unique identifiers:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.56.1">import java.util.concurrent.atomic._ 
object ParUid extends App { 
  private val uid = new AtomicLong(0L) 
  val seqtime = timed { 
    for (i &lt;- 0 until 10000000) uid.incrementAndGet() 
  } 
  log(s"Sequential time $seqtime ms") 
  val partime = timed { 
    for (i &lt;- (0 until 10000000).par) uid.incrementAndGet() 
  } 
  log(s"Parallel time $partime ms") 
} 
</span></pre><p><span class="koboSpan" id="kobo.57.1">This time, we use parallel collections in a </span><code class="literal"><span class="koboSpan" id="kobo.58.1">for</span></code><span class="koboSpan" id="kobo.59.1"> loop; recall that every occurrence of a </span><code class="literal"><span class="koboSpan" id="kobo.60.1">for</span></code><span class="koboSpan" id="kobo.61.1"> loop is desugared into the </span><code class="literal"><span class="koboSpan" id="kobo.62.1">foreach</span></code><span class="koboSpan" id="kobo.63.1"> call by the compiler. </span><span class="koboSpan" id="kobo.63.2">The parallel </span><code class="literal"><span class="koboSpan" id="kobo.64.1">for</span></code><span class="koboSpan" id="kobo.65.1"> loop from the preceding code is equivalent to the following:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.66.1">(0 until 10000000).par.foreach(i =&gt; uid.incrementAndGet()) 
</span></pre><p><span class="koboSpan" id="kobo.67.1">When the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">foreach</span></code><span class="koboSpan" id="kobo.69.1"> method is called on a parallel collection, collection elements are processed concurrently. </span><span class="koboSpan" id="kobo.69.2">This means that separate worker threads simultaneously invoke the specified function, so proper synchronization must be applied. </span><span class="koboSpan" id="kobo.69.3">In our case, this synchronization is ensured by the atomic variable, as explained in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.70.1">Chapter 3</span></a><span class="koboSpan" id="kobo.71.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.72.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.73.1">.</span></p><p><span class="koboSpan" id="kobo.74.1">Running this program on our machine reveals that there is no increase in speed. </span><span class="koboSpan" id="kobo.74.2">In fact, the parallel version of the program is even slower; our program prints 320 milliseconds for the sequential </span><code class="literal"><span class="koboSpan" id="kobo.75.1">foreach</span></code><span class="koboSpan" id="kobo.76.1"> call, and 1,041 milliseconds for the parallel </span><code class="literal"><span class="koboSpan" id="kobo.77.1">foreach</span></code><span class="koboSpan" id="kobo.78.1"> call.</span></p><p><span class="koboSpan" id="kobo.79.1">You might be surprised to see this; shouldn't a program be running at least four times faster on a quad-core processor with hyper-threading? </span><span class="koboSpan" id="kobo.79.2">As shown by the preceding example, this is not always the case. </span><span class="koboSpan" id="kobo.79.3">The parallel </span><code class="literal"><span class="koboSpan" id="kobo.80.1">foreach</span></code><span class="koboSpan" id="kobo.81.1"> call is slower because the worker threads simultaneously invoke the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">incrementAndGet</span></code><span class="koboSpan" id="kobo.83.1"> method on the atomic variable, </span><code class="literal"><span class="koboSpan" id="kobo.84.1">uid</span></code><span class="koboSpan" id="kobo.85.1">, and write to the same memory location at once.</span></p><p><span class="koboSpan" id="kobo.86.1">Memory writes do not go directly to </span><span class="strong"><strong><span class="koboSpan" id="kobo.87.1">Random Access Memory</span></strong></span><span class="koboSpan" id="kobo.88.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.89.1">RAM</span></strong></span><span class="koboSpan" id="kobo.90.1">) in modern architectures, as this would be too slow. </span><span class="koboSpan" id="kobo.90.2">Instead, modern computer architectures separate the CPU from the RAM with multiple levels of caches: smaller, more expensive, and much faster memory units that hold copies of parts of the RAM that the processor is currently using. </span><span class="koboSpan" id="kobo.90.3">The cache level closest to the CPU is called the L1 cache. </span><span class="koboSpan" id="kobo.90.4">The L1 cache is divided into short contiguous parts called </span><span class="strong"><strong><span class="koboSpan" id="kobo.91.1">cache lines</span></strong></span><span class="koboSpan" id="kobo.92.1">. </span><span class="koboSpan" id="kobo.92.2">Typically, a cache-line size is 64 bytes. </span><span class="koboSpan" id="kobo.92.3">Although multiple cores can read the same cache line simultaneously, in standard multicore processors, the cache line needs to be in exclusive ownership when a core writes to it. </span><span class="koboSpan" id="kobo.92.4">When another core requests to write to the same cache line, the cache line needs to be copied to that core's L1 cache. </span><span class="koboSpan" id="kobo.92.5">The cache coherence protocol that enables this is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.93.1">Modified Exclusive Shared Invalid</span></strong></span><span class="koboSpan" id="kobo.94.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.95.1">MESI</span></strong></span><span class="koboSpan" id="kobo.96.1">), and its specifics are beyond the scope of this book. </span><span class="koboSpan" id="kobo.96.2">All you need to know is that exchanging cache-line ownership can be relatively expensive in terms of the processor's time scale.</span></p><p><span class="koboSpan" id="kobo.97.1">Since the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">uid</span></code><span class="koboSpan" id="kobo.99.1"> variable is atomic, the JVM needs to ensure a happens-before relationship between the writes and reads of the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">uid</span></code><span class="koboSpan" id="kobo.101.1"> variable, as we know from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.102.1">Chapter 2</span></a><span class="koboSpan" id="kobo.103.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.104.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.105.1">. </span><span class="koboSpan" id="kobo.105.2">To ensure the happens-before relationship, memory writes have to be visible to other processors. </span><span class="koboSpan" id="kobo.105.3">The only way to ensure this is to obtain the cache line in exclusive mode before writing to it. </span><span class="koboSpan" id="kobo.105.4">In our example, different processor cores repetitively exchange the ownership of the cache line in which the </span><code class="literal"><span class="koboSpan" id="kobo.106.1">uid</span></code><span class="koboSpan" id="kobo.107.1"> variable is allocated, and the resulting program becomes much slower than its sequential version. </span><span class="koboSpan" id="kobo.107.2">This is shown in the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.108.1"><img src="graphics/image_05_001.jpg" alt="Using parallel collections"/></span></div><p><span class="koboSpan" id="kobo.109.1">If different processors only read a shared memory location, then there is no slowdown. </span><span class="koboSpan" id="kobo.109.2">Writing to the same memory location is, on the other hand, an obstacle to scalability.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip52"/><span class="koboSpan" id="kobo.110.1">Tip</span></h3><p><span class="koboSpan" id="kobo.111.1">Writing to the same memory location with proper synchronization leads to performance bottlenecks and contention; avoid this in data-parallel operations.</span></p></div></div><p><span class="koboSpan" id="kobo.112.1">Parallel programs share other resources in addition to computing power. </span><span class="koboSpan" id="kobo.112.2">When different parallel computations request more resources than are currently available, an effect known as </span><span class="strong"><strong><span class="koboSpan" id="kobo.113.1">resource contention</span></strong></span><span class="koboSpan" id="kobo.114.1"> occurs. </span><span class="koboSpan" id="kobo.114.2">The specific kind of resource contention that occurs in our example is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.115.1">memory contention</span></strong></span><span class="koboSpan" id="kobo.116.1">, a conflict over exclusive rights to write to a specific part of memory.</span></p><p><span class="koboSpan" id="kobo.117.1">We can expect the same kind of performance degradation when using multiple threads to concurrently start the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">synchronized</span></code><span class="koboSpan" id="kobo.119.1"> statement on the same object, repetitively modifying the same key in a concurrent map or simultaneously enqueueing elements to a concurrent queue; all these actions require writes to the same memory location. </span><span class="koboSpan" id="kobo.119.2">Nonetheless, this does not mean that threads should never write to the same memory locations. </span><span class="koboSpan" id="kobo.119.3">In some applications, concurrent writes occur very infrequently; the ratio between the time spent writing to contended memory locations and the time spent doing other work determines whether parallelization is beneficial or not. </span><span class="koboSpan" id="kobo.119.4">It is difficult to predict this ratio by just looking at the program; the </span><code class="literal"><span class="koboSpan" id="kobo.120.1">ParUid</span></code><span class="koboSpan" id="kobo.121.1"> example serves to illustrate that we should always measure in order to see the impact of contention.</span></p><div class="section" title="Parallel collection class hierarchy"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"/><span class="koboSpan" id="kobo.122.1">Parallel collection class hierarchy</span></h2></div></div></div><p><span class="koboSpan" id="kobo.123.1">As we saw, parallel collection operations execute on different worker threads simultaneously. </span><span class="koboSpan" id="kobo.123.2">At any point during the execution of a parallel operation, an element in a parallel collection can be processed by at most one worker thread executing that operation. </span><span class="koboSpan" id="kobo.123.3">The block of code associated with the parallel operation is executed on each of the elements separately; in the </span><code class="literal"><span class="koboSpan" id="kobo.124.1">ParUid</span></code><span class="koboSpan" id="kobo.125.1"> example, the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">incrementAndGet</span></code><span class="koboSpan" id="kobo.127.1"> method is called concurrently many times. </span><span class="koboSpan" id="kobo.127.2">Whenever a parallel operation executes any side-effects, it must take care to use proper synchronization; the naive approach of using </span><code class="literal"><span class="koboSpan" id="kobo.128.1">var</span></code><span class="koboSpan" id="kobo.129.1"> to store </span><code class="literal"><span class="koboSpan" id="kobo.130.1">uid</span></code><span class="koboSpan" id="kobo.131.1"> causes data races as it did in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.132.1">Chapter 2</span></a><span class="koboSpan" id="kobo.133.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.134.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.135.1">. </span><span class="koboSpan" id="kobo.135.2">This is not the case with sequential Scala collections.</span></p><p><span class="koboSpan" id="kobo.136.1">The consequence is that a parallel collection cannot be a subtype of a sequential collection. </span><span class="koboSpan" id="kobo.136.2">If it were, then the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.137.1">Liskov substitution principle</span></em></span><span class="koboSpan" id="kobo.138.1"> would be violated. </span><span class="koboSpan" id="kobo.138.2">The Liskov substitution principle states that if type </span><code class="literal"><span class="koboSpan" id="kobo.139.1">S</span></code><span class="koboSpan" id="kobo.140.1"> is a subtype of </span><code class="literal"><span class="koboSpan" id="kobo.141.1">T</span></code><span class="koboSpan" id="kobo.142.1">, then the object of type </span><code class="literal"><span class="koboSpan" id="kobo.143.1">T</span></code><span class="koboSpan" id="kobo.144.1"> can be replaced with objects of type </span><code class="literal"><span class="koboSpan" id="kobo.145.1">S</span></code><span class="koboSpan" id="kobo.146.1"> without affecting the correctness of the program.</span></p><p><span class="koboSpan" id="kobo.147.1">In our case, if parallel collections are subtypes of sequential collections, then some methods can return a sequential sequence collection with the static type </span><code class="literal"><span class="koboSpan" id="kobo.148.1">Seq[Int]</span></code><span class="koboSpan" id="kobo.149.1">, where the sequence object is a parallel sequence collection at runtime. </span><span class="koboSpan" id="kobo.149.2">Clients can call methods such as </span><code class="literal"><span class="koboSpan" id="kobo.150.1">foreach</span></code><span class="koboSpan" id="kobo.151.1"> on the collection without knowing that the body of the </span><code class="literal"><span class="koboSpan" id="kobo.152.1">foreach</span></code><span class="koboSpan" id="kobo.153.1"> method needs synchronization, and their programs would not work correctly. </span><span class="koboSpan" id="kobo.153.2">For these reasons, parallel collections form a hierarchy that is separate from the sequential collections, as shown in the following diagram:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.154.1"><img src="graphics/image_05_002.jpg" alt="Parallel collection class hierarchy"/></span><div class="caption"><p><span class="koboSpan" id="kobo.155.1">Scala collection hierarchy</span></p></div></div><p><span class="koboSpan" id="kobo.156.1">The preceding diagram shows the simplified Scala collection hierarchy with sequential collections on the left. </span><span class="koboSpan" id="kobo.156.2">The most general collection type is called </span><code class="literal"><span class="koboSpan" id="kobo.157.1">Traversable</span></code><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">Different collection operations such as </span><code class="literal"><span class="koboSpan" id="kobo.159.1">find</span></code><span class="koboSpan" id="kobo.160.1">, </span><code class="literal"><span class="koboSpan" id="kobo.161.1">map</span></code><span class="koboSpan" id="kobo.162.1">, </span><code class="literal"><span class="koboSpan" id="kobo.163.1">filter</span></code><span class="koboSpan" id="kobo.164.1">, or </span><code class="literal"><span class="koboSpan" id="kobo.165.1">reduceLeft</span></code><span class="koboSpan" id="kobo.166.1"> are implemented in terms of its abstract </span><code class="literal"><span class="koboSpan" id="kobo.167.1">foreach</span></code><span class="koboSpan" id="kobo.168.1"> method. </span><span class="koboSpan" id="kobo.168.2">Its </span><code class="literal"><span class="koboSpan" id="kobo.169.1">Iterable[T]</span></code><span class="koboSpan" id="kobo.170.1"> subtype offers additional operations such as </span><code class="literal"><span class="koboSpan" id="kobo.171.1">zip</span></code><span class="koboSpan" id="kobo.172.1">, </span><code class="literal"><span class="koboSpan" id="kobo.173.1">grouped</span></code><span class="koboSpan" id="kobo.174.1">, </span><code class="literal"><span class="koboSpan" id="kobo.175.1">sliding</span></code><span class="koboSpan" id="kobo.176.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.177.1">sameElements</span></code><span class="koboSpan" id="kobo.178.1">, implemented using its </span><code class="literal"><span class="koboSpan" id="kobo.179.1">iterator</span></code><span class="koboSpan" id="kobo.180.1"> method. </span><span class="koboSpan" id="kobo.180.2">The </span><code class="literal"><span class="koboSpan" id="kobo.181.1">Seq</span></code><span class="koboSpan" id="kobo.182.1">, </span><code class="literal"><span class="koboSpan" id="kobo.183.1">Map</span></code><span class="koboSpan" id="kobo.184.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.185.1">Set</span></code><span class="koboSpan" id="kobo.186.1"> traits are iterable collections that represent Scala sequences, maps, and sets, respectively. </span><span class="koboSpan" id="kobo.186.2">These traits are used to write code that is generic in the type of the concrete Scala collection. </span><span class="koboSpan" id="kobo.186.3">The following </span><code class="literal"><span class="koboSpan" id="kobo.187.1">nonNull</span></code><span class="koboSpan" id="kobo.188.1"> method copies elements from an </span><code class="literal"><span class="koboSpan" id="kobo.189.1">xs</span></code><span class="koboSpan" id="kobo.190.1"> collection that are different from </span><code class="literal"><span class="koboSpan" id="kobo.191.1">null</span></code><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">Here, the </span><code class="literal"><span class="koboSpan" id="kobo.193.1">xs</span></code><span class="koboSpan" id="kobo.194.1"> collection can be a </span><code class="literal"><span class="koboSpan" id="kobo.195.1">Vector[T]</span></code><span class="koboSpan" id="kobo.196.1">, </span><code class="literal"><span class="koboSpan" id="kobo.197.1">List[T]</span></code><span class="koboSpan" id="kobo.198.1">, or some other sequence:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.199.1">def nonNull(xs: Seq[T]): Seq[T] = xs.filter(_ != null) 
</span></pre><p><span class="koboSpan" id="kobo.200.1">Parallel collections form a separate hierarchy. </span><span class="koboSpan" id="kobo.200.2">The most general parallel collection type is called </span><code class="literal"><span class="koboSpan" id="kobo.201.1">ParIterable</span></code><span class="koboSpan" id="kobo.202.1">. </span><span class="koboSpan" id="kobo.202.2">Methods such as </span><code class="literal"><span class="koboSpan" id="kobo.203.1">foreach</span></code><span class="koboSpan" id="kobo.204.1">, </span><code class="literal"><span class="koboSpan" id="kobo.205.1">map</span></code><span class="koboSpan" id="kobo.206.1">, or </span><code class="literal"><span class="koboSpan" id="kobo.207.1">reduce</span></code><span class="koboSpan" id="kobo.208.1"> on a </span><code class="literal"><span class="koboSpan" id="kobo.209.1">ParIterable</span></code><span class="koboSpan" id="kobo.210.1"> object execute in parallel. </span><span class="koboSpan" id="kobo.210.2">The </span><code class="literal"><span class="koboSpan" id="kobo.211.1">ParSeq</span></code><span class="koboSpan" id="kobo.212.1">, </span><code class="literal"><span class="koboSpan" id="kobo.213.1">ParMap</span></code><span class="koboSpan" id="kobo.214.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.215.1">ParSet</span></code><span class="koboSpan" id="kobo.216.1"> collections are parallel collections that correspond to </span><code class="literal"><span class="koboSpan" id="kobo.217.1">Seq</span></code><span class="koboSpan" id="kobo.218.1">, </span><code class="literal"><span class="koboSpan" id="kobo.219.1">Map</span></code><span class="koboSpan" id="kobo.220.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.221.1">Set</span></code><span class="koboSpan" id="kobo.222.1">, but are not their subtypes. </span><span class="koboSpan" id="kobo.222.2">We can rewrite the </span><code class="literal"><span class="koboSpan" id="kobo.223.1">nonNull</span></code><span class="koboSpan" id="kobo.224.1"> method to use parallel collections:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.225.1">def nonNull(xs: ParSeq[T]): ParSeq[T] = xs.filter(_ != null) 
</span></pre><p><span class="koboSpan" id="kobo.226.1">Although the implementation is identical, we can no longer pass a sequential collection to the </span><code class="literal"><span class="koboSpan" id="kobo.227.1">nonNull</span></code><span class="koboSpan" id="kobo.228.1"> method. </span><span class="koboSpan" id="kobo.228.2">We can call </span><code class="literal"><span class="koboSpan" id="kobo.229.1">.par</span></code><span class="koboSpan" id="kobo.230.1"> on the sequential </span><code class="literal"><span class="koboSpan" id="kobo.231.1">xs</span></code><span class="koboSpan" id="kobo.232.1"> collection before passing it to the </span><code class="literal"><span class="koboSpan" id="kobo.233.1">nonNull</span></code><span class="koboSpan" id="kobo.234.1"> method, but then the </span><code class="literal"><span class="koboSpan" id="kobo.235.1">filter</span></code><span class="koboSpan" id="kobo.236.1"> method will execute in parallel. </span><span class="koboSpan" id="kobo.236.2">Can we instead write code that is agnostic in the type of the collection? </span><span class="koboSpan" id="kobo.236.3">The generic collection types: </span><code class="literal"><span class="koboSpan" id="kobo.237.1">GenTraversable</span></code><span class="koboSpan" id="kobo.238.1">, </span><code class="literal"><span class="koboSpan" id="kobo.239.1">GenIterable</span></code><span class="koboSpan" id="kobo.240.1">, </span><code class="literal"><span class="koboSpan" id="kobo.241.1">GenSeq</span></code><span class="koboSpan" id="kobo.242.1">, </span><code class="literal"><span class="koboSpan" id="kobo.243.1">GenMap</span></code><span class="koboSpan" id="kobo.244.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.245.1">GenSet</span></code><span class="koboSpan" id="kobo.246.1"> exist for this purpose. </span><span class="koboSpan" id="kobo.246.2">Each of them represents a supertype of the corresponding sequential or parallel collection type. </span><span class="koboSpan" id="kobo.246.3">For example, the </span><code class="literal"><span class="koboSpan" id="kobo.247.1">GenSeq</span></code><span class="koboSpan" id="kobo.248.1"> generic sequence type allows us to rewrite the </span><code class="literal"><span class="koboSpan" id="kobo.249.1">nonNull</span></code><span class="koboSpan" id="kobo.250.1"> method as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.251.1">def nonNull(xs: GenSeq[T]): GenSeq[T] = xs.filter(_ != null) 
</span></pre><p><span class="koboSpan" id="kobo.252.1">When using generic collection types, we need to remember that they might be implemented either as a sequential collection or as a parallel collection. </span><span class="koboSpan" id="kobo.252.2">Thus, as a precaution, if operations invoked on a generic collection execute any side effects, you should use synchronization.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip53"/><span class="koboSpan" id="kobo.253.1">Tip</span></h3><p><span class="koboSpan" id="kobo.254.1">Treat operations invoked on a generic collection type as if they are parallel.</span></p></div></div></div><div class="section" title="Configuring the parallelism level"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec43"/><span class="koboSpan" id="kobo.255.1">Configuring the parallelism level</span></h2></div></div></div><p><span class="koboSpan" id="kobo.256.1">Parallel collections use all the processors by default; their underlying executor has as many workers as there are processors. </span><span class="koboSpan" id="kobo.256.2">We can change this default behavior by changing the </span><code class="literal"><span class="koboSpan" id="kobo.257.1">TaskSupport</span></code><span class="koboSpan" id="kobo.258.1"> object of the parallel collection. </span><span class="koboSpan" id="kobo.258.2">The basic </span><code class="literal"><span class="koboSpan" id="kobo.259.1">TaskSupport</span></code><span class="koboSpan" id="kobo.260.1"> implementation is the </span><code class="literal"><span class="koboSpan" id="kobo.261.1">ForkJoinTaskSupport</span></code><span class="koboSpan" id="kobo.262.1"> class. </span><span class="koboSpan" id="kobo.262.2">It takes a </span><code class="literal"><span class="koboSpan" id="kobo.263.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.264.1"> collection and uses it to schedule parallel operations.</span></p><p><span class="koboSpan" id="kobo.265.1">Therefore, to change the parallelism level of a parallel collection, we instantiate a </span><code class="literal"><span class="koboSpan" id="kobo.266.1">ForkJoinPool</span></code><span class="koboSpan" id="kobo.267.1"> collection with the desired parallelism level:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.268.1">import scala.concurrent.forkjoin.ForkJoinPool 
object ParConfig extends App { 
  val fjpool = new ForkJoinPool(2) 
  val customTaskSupport = new parallel.ForkJoinTaskSupport(fjpool) 
  val numbers = Random.shuffle(Vector.tabulate(5000000)(i =&gt; i)) 
  val partime = timed { 
    val parnumbers = numbers.par 
    parnumbers.tasksupport = customTaskSupport 
    val n = parnumbers.max 
    println(s"largest number $n") 
  } 
  log(s"Parallel time $partime ms") 
} 
</span></pre><p><span class="koboSpan" id="kobo.269.1">Once a </span><code class="literal"><span class="koboSpan" id="kobo.270.1">TaskSupport</span></code><span class="koboSpan" id="kobo.271.1"> object is created, we can use it with different parallel collections. </span><span class="koboSpan" id="kobo.271.2">Every parallel collection has a </span><code class="literal"><span class="koboSpan" id="kobo.272.1">tasksupport</span></code><span class="koboSpan" id="kobo.273.1"> field that we use to assign the </span><code class="literal"><span class="koboSpan" id="kobo.274.1">TaskSupport</span></code><span class="koboSpan" id="kobo.275.1"> object to it.</span></p></div><div class="section" title="Measuring the performance on the JVM"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec44"/><span class="koboSpan" id="kobo.276.1">Measuring the performance on the JVM</span></h2></div></div></div><p><span class="koboSpan" id="kobo.277.1">To correctly measure the running time on the JVM is not an easy task. </span><span class="koboSpan" id="kobo.277.2">Under the hood, the JVM does a lot more than meets the eye. </span><span class="koboSpan" id="kobo.277.3">The Scala compiler does not produce machine code directly runnable on the CPU. </span><span class="koboSpan" id="kobo.277.4">Instead, the Scala compiler produces a special intermediate instruction code called </span><span class="strong"><strong><span class="koboSpan" id="kobo.278.1">Java bytecode</span></strong></span><span class="koboSpan" id="kobo.279.1">. </span><span class="koboSpan" id="kobo.279.2">When bytecode from the Scala compiler gets run inside the JVM, at first it executes in so-called </span><span class="strong"><strong><span class="koboSpan" id="kobo.280.1">interpreted mode</span></strong></span><span class="koboSpan" id="kobo.281.1">; the JVM interprets each bytecode instruction and simulates the execution of the program. </span><span class="koboSpan" id="kobo.281.2">Only when the JVM decides that the bytecode in a certain method was run often enough does it compile the bytecode to machine code, which can be executed directly on the processor. </span><span class="koboSpan" id="kobo.281.3">This process is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.282.1">just-in-time compilation</span></strong></span><span class="koboSpan" id="kobo.283.1">.</span></p><p><span class="koboSpan" id="kobo.284.1">The JVM needs standardized bytecode to be cross-platform; the same bytecode can be run on any processor or operating system that supports the JVM. </span><span class="koboSpan" id="kobo.284.2">However, the entire bytecode of a program cannot be translated to the machine code as soon as the program runs; this would be too slow. </span><span class="koboSpan" id="kobo.284.3">Instead, the JVM translates parts of the programs, such as specific methods, incrementally, in short compiler runs. </span><span class="koboSpan" id="kobo.284.4">In addition, the JVM can decide to additionally optimize certain parts of the program that execute very frequently. </span><span class="koboSpan" id="kobo.284.5">As a result, programs running on the JVM are usually slow immediately after they start, and eventually reach their optimal performance. </span><span class="koboSpan" id="kobo.284.6">Once this happens, we say that the JVM reached its steady state. </span><span class="koboSpan" id="kobo.284.7">When evaluating the performance on the JVM, we are usually interested in the </span><span class="strong"><strong><span class="koboSpan" id="kobo.285.1">steady state</span></strong></span><span class="koboSpan" id="kobo.286.1">; most programs run long enough to achieve it.</span></p><p><span class="koboSpan" id="kobo.287.1">To witness this effect, assume that you want to find out what the </span><code class="literal"><span class="koboSpan" id="kobo.288.1">TEXTAREA</span></code><span class="koboSpan" id="kobo.289.1"> tag means in HTML. </span><span class="koboSpan" id="kobo.289.2">You write the program that downloads the HTML specification and searches for the first occurrence of the </span><code class="literal"><span class="koboSpan" id="kobo.290.1">TEXTAREA</span></code><span class="koboSpan" id="kobo.291.1"> string. </span><span class="koboSpan" id="kobo.291.2">Having mastered asynchronous programming in </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.292.1">Chapter 4</span></a><span class="koboSpan" id="kobo.293.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.294.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.295.1">, you can implement the </span><code class="literal"><span class="koboSpan" id="kobo.296.1">getHtmlSpec</span></code><span class="koboSpan" id="kobo.297.1"> method, which starts an asynchronous computation to download the HTML specification and returns a future value with the lines of the HTML specification. </span><span class="koboSpan" id="kobo.297.2">You then install a callback; once the HTML specification is available, you can call the </span><code class="literal"><span class="koboSpan" id="kobo.298.1">indexWhere</span></code><span class="koboSpan" id="kobo.299.1"> method on the lines to find the line that matches the regular expression </span><code class="literal"><span class="koboSpan" id="kobo.300.1">.*TEXTAREA.*</span></code><span class="koboSpan" id="kobo.301.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.302.1">object ParHtmlSearch extends App { 
  def getHtmlSpec() = Future { 
    val url = "http://www.w3.org/MarkUp/html-spec/html-spec.txt" 
    val specSrc = Source.fromURL(url) 
    try specSrc.getLines.toArray finally specSrc.close() 
  } 
  getHtmlSpec() foreach { case specDoc =&gt; 
    def search(d: GenSeq[String]): Double = 
      timed { d.indexWhere(line =&gt; line.matches(".*TEXTAREA.*")) } 
    val seqtime = search(specDoc) 
    log(s"Sequential time $seqtime ms") 
    val partime = search(specDoc.par) 
    log(s"Parallel time $partime ms") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.303.1">Running this example several times from SBT shows that the times vary. </span><span class="koboSpan" id="kobo.303.2">At first, the sequential and parallel versions execute for 45 and 16 milliseconds, respectively. </span><span class="koboSpan" id="kobo.303.3">Next time, they take 36 and 10 milliseconds, and subsequently 10 and 4 milliseconds. </span><span class="koboSpan" id="kobo.303.4">Note that we only observe this effect when running the examples inside the same JVM process as SBT itself.</span></p><p><span class="koboSpan" id="kobo.304.1">We can draw a false conclusion that the steady state was reached at this point. </span><span class="koboSpan" id="kobo.304.2">In truth, we should run this program many more times before the JVM properly optimizes it. </span><span class="koboSpan" id="kobo.304.3">Therefore, we add the </span><code class="literal"><span class="koboSpan" id="kobo.305.1">warmedTimed</span></code><span class="koboSpan" id="kobo.306.1"> method to our package object. </span><span class="koboSpan" id="kobo.306.2">This method runs the block of code </span><code class="literal"><span class="koboSpan" id="kobo.307.1">n</span></code><span class="koboSpan" id="kobo.308.1"> times before measuring its running time. </span><span class="koboSpan" id="kobo.308.2">We set the default value for the </span><code class="literal"><span class="koboSpan" id="kobo.309.1">n</span></code><span class="koboSpan" id="kobo.310.1"> variable to </span><code class="literal"><span class="koboSpan" id="kobo.311.1">200</span></code><span class="koboSpan" id="kobo.312.1">; although there is no way to be sure that the JVM will reach a steady state after executing the block of code 200 times, this is a reasonable default:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.313.1">def warmedTimed[T](n: Int = 200)(body: =&gt;T): Double = { 
  for (_ &lt;- 0 until n) body 
  timed(body) 
} 
</span></pre><p><span class="koboSpan" id="kobo.314.1">We can now call the </span><code class="literal"><span class="koboSpan" id="kobo.315.1">warmedTimed</span></code><span class="koboSpan" id="kobo.316.1"> method instead of the </span><code class="literal"><span class="koboSpan" id="kobo.317.1">timed</span></code><span class="koboSpan" id="kobo.318.1"> method in the </span><code class="literal"><span class="koboSpan" id="kobo.319.1">ParHtmlSearch</span></code><span class="koboSpan" id="kobo.320.1"> example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.321.1">def search(d: GenSeq[String]) = warmedTimed() { 
  d.indexWhere(line =&gt; line.matches(".*TEXTAREA.*")) 
} 
</span></pre><p><span class="koboSpan" id="kobo.322.1">Doing so changes the running times on our machine to 1.5 and 0.5 milliseconds for the sequential and parallel versions of the program, respectively.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip54"/><span class="koboSpan" id="kobo.323.1">Tip</span></h3><p><span class="koboSpan" id="kobo.324.1">Make sure that the JVM is in the steady state before drawing any premature conclusions about the running time of a program.</span></p></div></div><p><span class="koboSpan" id="kobo.325.1">There are other reasons why measuring performance on the JVM is hard. </span><span class="koboSpan" id="kobo.325.2">Even if the JVM reached a steady state for the part of the program we measure, the </span><span class="strong"><strong><span class="koboSpan" id="kobo.326.1">Just-In-Time</span></strong></span><span class="koboSpan" id="kobo.327.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.328.1">JIT</span></strong></span><span class="koboSpan" id="kobo.329.1">) compiler can at any point pause the execution and translate some other part of the program, effectively slowing down our measurement. </span><span class="koboSpan" id="kobo.329.2">Then, the JVM provides automatic memory management. </span><span class="koboSpan" id="kobo.329.3">In languages such as C++, an invocation of the </span><code class="literal"><span class="koboSpan" id="kobo.330.1">new</span></code><span class="koboSpan" id="kobo.331.1"> keyword, which is used to allocate an object, must be accompanied by the corresponding </span><code class="literal"><span class="koboSpan" id="kobo.332.1">delete</span></code><span class="koboSpan" id="kobo.333.1"> call that frees the memory occupied by the object so that it can be reused later. </span><span class="koboSpan" id="kobo.333.2">In languages such as Scala and Java, however, there is no </span><code class="literal"><span class="koboSpan" id="kobo.334.1">delete</span></code><span class="koboSpan" id="kobo.335.1"> statement; objects are eventually freed automatically during the process called </span><span class="strong"><strong><span class="koboSpan" id="kobo.336.1">Garbage Collection</span></strong></span><span class="koboSpan" id="kobo.337.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.338.1">GC</span></strong></span><span class="koboSpan" id="kobo.339.1">). </span><span class="koboSpan" id="kobo.339.2">Periodically, the JVM stops the execution, scans the heap for all objects no longer used in the program, and frees the memory they occupy. </span><span class="koboSpan" id="kobo.339.3">If we measure the running time of code that frequently causes GC cycles, the chances are that GC will skew the measurements. </span><span class="koboSpan" id="kobo.339.4">In some cases, the performance of the same program can vary from one JVM process to the other because the objects get allocated in a way that causes a particular memory access pattern, impacting the program's performance.</span></p><p><span class="koboSpan" id="kobo.340.1">To get really reliable running time values, we need to run the code many times by starting separate JVM processes, making sure that the JVM reached a steady state, and taking the average of all the measurements. </span><span class="koboSpan" id="kobo.340.2">Frameworks such as </span><span class="strong"><strong><span class="koboSpan" id="kobo.341.1">ScalaMeter</span></strong></span><span class="koboSpan" id="kobo.342.1">, introduced in </span><a class="link" href="ch09.html" title="Chapter 9. Concurrency in Practice"><span class="koboSpan" id="kobo.343.1">Chapter 9</span></a><span class="koboSpan" id="kobo.344.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.345.1">Concurrency in Practice</span></em></span><span class="koboSpan" id="kobo.346.1">, go a long way toward automating this process.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Caveats with parallel collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/><span class="koboSpan" id="kobo.1.1">Caveats with parallel collections</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Parallel collections were designed to provide a programming API similar to sequential Scala collections. </span><span class="koboSpan" id="kobo.2.2">Every sequential collection has a parallel counterpart and most operations have the same signature in both sequential and parallel collections. </span><span class="koboSpan" id="kobo.2.3">Still, there are some caveats when using parallel collections, and we will study them in this section.</span></p><div class="section" title="Non-parallelizable collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec45"/><span class="koboSpan" id="kobo.3.1">Non-parallelizable collections</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Parallel collections use </span><span class="strong"><strong><span class="koboSpan" id="kobo.5.1">splitters</span></strong></span><span class="koboSpan" id="kobo.6.1">, represented with the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">Splitter[T]</span></code><span class="koboSpan" id="kobo.8.1"> type, in order to provide parallel operations. </span><span class="koboSpan" id="kobo.8.2">A splitter is a more advanced form of an iterator; in addition to the iterator's </span><code class="literal"><span class="koboSpan" id="kobo.9.1">next</span></code><span class="koboSpan" id="kobo.10.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.11.1">hasNext</span></code><span class="koboSpan" id="kobo.12.1"> methods, splitters define the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">split</span></code><span class="koboSpan" id="kobo.14.1"> method, which divides the splitter </span><code class="literal"><span class="koboSpan" id="kobo.15.1">S</span></code><span class="koboSpan" id="kobo.16.1"> into a sequence of splitters that traverse parts of the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">S</span></code><span class="koboSpan" id="kobo.18.1"> splitter:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.19.1">def split: Seq[Splitter[T]] 
</span></pre><p><span class="koboSpan" id="kobo.20.1">This method allows separate processors to traverse separate parts of the input collection. </span><span class="koboSpan" id="kobo.20.2">The </span><code class="literal"><span class="koboSpan" id="kobo.21.1">split</span></code><span class="koboSpan" id="kobo.22.1"> method must be implemented efficiently, as this method is invoked many times during the execution of a parallel operation. </span><span class="koboSpan" id="kobo.22.2">In the vocabulary of computational complexity theory, the allowed asymptotic running time of the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">split</span></code><span class="koboSpan" id="kobo.24.1"> method is </span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">O</span></strong></span><span class="koboSpan" id="kobo.26.1">(log (</span><span class="emphasis"><em><span class="koboSpan" id="kobo.27.1">N</span></em></span><span class="koboSpan" id="kobo.28.1">)), where </span><span class="emphasis"><em><span class="koboSpan" id="kobo.29.1">N</span></em></span><span class="koboSpan" id="kobo.30.1"> is the number of elements in the splitter. </span><span class="koboSpan" id="kobo.30.2">Splitters can be implemented for flat data structures such as arrays and hash tables, and tree-like data structures such as immutable hash maps and vectors. </span><span class="koboSpan" id="kobo.30.3">Linear data structures such as the Scala </span><code class="literal"><span class="koboSpan" id="kobo.31.1">List</span></code><span class="koboSpan" id="kobo.32.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.33.1">Stream</span></code><span class="koboSpan" id="kobo.34.1"> collections cannot efficiently implement the </span><code class="literal"><span class="koboSpan" id="kobo.35.1">split</span></code><span class="koboSpan" id="kobo.36.1"> method. </span><span class="koboSpan" id="kobo.36.2">Dividing a long linked list of nodes into two parts requires traversing these nodes, which takes a time that is proportionate to the size of the collection.</span></p><p><span class="koboSpan" id="kobo.37.1">Operations on Scala collections such as </span><code class="literal"><span class="koboSpan" id="kobo.38.1">Array</span></code><span class="koboSpan" id="kobo.39.1">, </span><code class="literal"><span class="koboSpan" id="kobo.40.1">ArrayBuffer</span></code><span class="koboSpan" id="kobo.41.1">, mutable </span><code class="literal"><span class="koboSpan" id="kobo.42.1">HashMap</span></code><span class="koboSpan" id="kobo.43.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.44.1">HashSet</span></code><span class="koboSpan" id="kobo.45.1">, </span><code class="literal"><span class="koboSpan" id="kobo.46.1">Range</span></code><span class="koboSpan" id="kobo.47.1">, </span><code class="literal"><span class="koboSpan" id="kobo.48.1">Vector</span></code><span class="koboSpan" id="kobo.49.1">, immutable </span><code class="literal"><span class="koboSpan" id="kobo.50.1">HashMap</span></code><span class="koboSpan" id="kobo.51.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.52.1">HashSet</span></code><span class="koboSpan" id="kobo.53.1">, and concurrent </span><code class="literal"><span class="koboSpan" id="kobo.54.1">TrieMap</span></code><span class="koboSpan" id="kobo.55.1"> can be parallelized. </span><span class="koboSpan" id="kobo.55.2">We call these collections </span><span class="emphasis"><em><span class="koboSpan" id="kobo.56.1">parallelizable</span></em></span><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">par</span></code><span class="koboSpan" id="kobo.59.1"> method on these collections creates a parallel collection that shares the same underlying dataset as the original collection. </span><span class="koboSpan" id="kobo.59.2">No elements are copied and the conversion is fast.</span></p><p><span class="koboSpan" id="kobo.60.1">Other Scala collections need to be converted to their parallel counterparts upon calling </span><code class="literal"><span class="koboSpan" id="kobo.61.1">par</span></code><span class="koboSpan" id="kobo.62.1">. </span><span class="koboSpan" id="kobo.62.2">We can refer to them as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.63.1">non-parallelizable collections</span></em></span><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">Calling the </span><code class="literal"><span class="koboSpan" id="kobo.65.1">par</span></code><span class="koboSpan" id="kobo.66.1"> method on non-parallelizable collections entails copying their elements into a new collection. </span><span class="koboSpan" id="kobo.66.2">For example, the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">List</span></code><span class="koboSpan" id="kobo.68.1"> collection needs to be copied to a </span><code class="literal"><span class="koboSpan" id="kobo.69.1">Vector</span></code><span class="koboSpan" id="kobo.70.1"> collection when the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">par</span></code><span class="koboSpan" id="kobo.72.1"> method is called, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">object ParNonParallelizableCollections extends App { 
  val list = List.fill(1000000)("") 
  val vector = Vector.fill(1000000)("") 
  log(s"list conversion time: ${timed(list.par)} ms") 
  log(s"vector conversion time: ${timed(vector.par)} ms") 
} 
</span></pre><p><span class="koboSpan" id="kobo.74.1">Calling </span><code class="literal"><span class="koboSpan" id="kobo.75.1">par</span></code><span class="koboSpan" id="kobo.76.1"> on </span><code class="literal"><span class="koboSpan" id="kobo.77.1">List</span></code><span class="koboSpan" id="kobo.78.1"> takes 55 milliseconds on our machine, whereas calling </span><code class="literal"><span class="koboSpan" id="kobo.79.1">par</span></code><span class="koboSpan" id="kobo.80.1"> on </span><code class="literal"><span class="koboSpan" id="kobo.81.1">Vector</span></code><span class="koboSpan" id="kobo.82.1"> takes 0.025 milliseconds. </span><span class="koboSpan" id="kobo.82.2">Importantly, the conversion from a sequential collection to a parallel one is not itself parallelized, and is a possible sequential bottleneck.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip55"/><span class="koboSpan" id="kobo.83.1">Tip</span></h3><p><span class="koboSpan" id="kobo.84.1">Converting a non-parallelizable sequential collection to a parallel collection is not a parallel operation; it executes on the caller thread.</span></p></div></div><p><span class="koboSpan" id="kobo.85.1">Sometimes, the cost of converting a non-parallelizable collection to a parallel one is acceptable. </span><span class="koboSpan" id="kobo.85.2">If the amount of work in the parallel operation far exceeds the cost of converting the collection, then we can bite the bullet and pay the cost of the conversion. </span><span class="koboSpan" id="kobo.85.3">Otherwise, it is more prudent to keep the program data in parallelizable collections and benefit from fast conversions. </span><span class="koboSpan" id="kobo.85.4">When in doubt, measure!</span></p></div><div class="section" title="Non-parallelizable operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/><span class="koboSpan" id="kobo.86.1">Non-parallelizable operations</span></h2></div></div></div><p><span class="koboSpan" id="kobo.87.1">While most parallel collection operations achieve superior performance by executing on several processors, some operations are inherently sequential, and their semantics do not allow them to execute in parallel. </span><span class="koboSpan" id="kobo.87.2">Consider the </span><code class="literal"><span class="koboSpan" id="kobo.88.1">foldLeft</span></code><span class="koboSpan" id="kobo.89.1"> method from the Scala collections API:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.90.1">def foldLeft[S](z: S)(f: (S, T) =&gt; S): S 
</span></pre><p><span class="koboSpan" id="kobo.91.1">This method visits elements of the collection going from left to right and adds them to the accumulator of type </span><code class="literal"><span class="koboSpan" id="kobo.92.1">S</span></code><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">The accumulator is initially equal to the zero value </span><code class="literal"><span class="koboSpan" id="kobo.94.1">z</span></code><span class="koboSpan" id="kobo.95.1">, and is updated with the function </span><code class="literal"><span class="koboSpan" id="kobo.96.1">f</span></code><span class="koboSpan" id="kobo.97.1"> that uses the accumulator and a collection element of type </span><code class="literal"><span class="koboSpan" id="kobo.98.1">T</span></code><span class="koboSpan" id="kobo.99.1"> to produce a new accumulator. </span><span class="koboSpan" id="kobo.99.2">For example, given a list of integers </span><code class="literal"><span class="koboSpan" id="kobo.100.1">List(1, 2, 3)</span></code><span class="koboSpan" id="kobo.101.1">, we can compute the sum of its integers with the following expression:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.102.1">List(1, 2, 3).foldLeft(0)((acc, x) =&gt; acc + x) 
</span></pre><p><span class="koboSpan" id="kobo.103.1">This </span><code class="literal"><span class="koboSpan" id="kobo.104.1">foldLeft</span></code><span class="koboSpan" id="kobo.105.1"> method starts by assigning </span><code class="literal"><span class="koboSpan" id="kobo.106.1">0</span></code><span class="koboSpan" id="kobo.107.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.108.1">acc</span></code><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">It then takes the first element in the list </span><code class="literal"><span class="koboSpan" id="kobo.110.1">1</span></code><span class="koboSpan" id="kobo.111.1"> and calls the function </span><code class="literal"><span class="koboSpan" id="kobo.112.1">f</span></code><span class="koboSpan" id="kobo.113.1"> to evaluate </span><code class="literal"><span class="koboSpan" id="kobo.114.1">0 + 1</span></code><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">The </span><code class="literal"><span class="koboSpan" id="kobo.116.1">acc</span></code><span class="koboSpan" id="kobo.117.1"> accumulator then becomes </span><code class="literal"><span class="koboSpan" id="kobo.118.1">1</span></code><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">This process continues until the entire list of elements is visited, and the </span><code class="literal"><span class="koboSpan" id="kobo.120.1">foldLeft</span></code><span class="koboSpan" id="kobo.121.1"> method eventually returns the result </span><code class="literal"><span class="koboSpan" id="kobo.122.1">6</span></code><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">In this example, the </span><code class="literal"><span class="koboSpan" id="kobo.124.1">S</span></code><span class="koboSpan" id="kobo.125.1"> type of the accumulator is set to the </span><code class="literal"><span class="koboSpan" id="kobo.126.1">Int</span></code><span class="koboSpan" id="kobo.127.1"> type. </span><span class="koboSpan" id="kobo.127.2">In general, the accumulator can have any type. </span><span class="koboSpan" id="kobo.127.3">When converting a list of elements to a string, the zero value is an empty string and the function </span><code class="literal"><span class="koboSpan" id="kobo.128.1">f</span></code><span class="koboSpan" id="kobo.129.1"> concatenates a string and a number.</span></p><p><span class="koboSpan" id="kobo.130.1">The crucial property of the </span><code class="literal"><span class="koboSpan" id="kobo.131.1">foldLeft</span></code><span class="koboSpan" id="kobo.132.1"> operation is that it traverses the elements of the list by going from left to right. </span><span class="koboSpan" id="kobo.132.2">This is reflected in the type of the function </span><code class="literal"><span class="koboSpan" id="kobo.133.1">f</span></code><span class="koboSpan" id="kobo.134.1">; it accepts an accumulator of type </span><code class="literal"><span class="koboSpan" id="kobo.135.1">S</span></code><span class="koboSpan" id="kobo.136.1"> and a list value of type </span><code class="literal"><span class="koboSpan" id="kobo.137.1">T</span></code><span class="koboSpan" id="kobo.138.1">. </span><span class="koboSpan" id="kobo.138.2">The function </span><code class="literal"><span class="koboSpan" id="kobo.139.1">f</span></code><span class="koboSpan" id="kobo.140.1"> cannot take two values of the accumulator type </span><code class="literal"><span class="koboSpan" id="kobo.141.1">S</span></code><span class="koboSpan" id="kobo.142.1"> and merge them into a new accumulator of type </span><code class="literal"><span class="koboSpan" id="kobo.143.1">S</span></code><span class="koboSpan" id="kobo.144.1">. </span><span class="koboSpan" id="kobo.144.2">As a consequence, computing the accumulator cannot be implemented in parallel; the </span><code class="literal"><span class="koboSpan" id="kobo.145.1">foldLeft</span></code><span class="koboSpan" id="kobo.146.1"> method cannot merge two accumulators from two different processors. </span><span class="koboSpan" id="kobo.146.2">We can confirm this by running the following program:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.147.1">object ParNonParallelizableOperations extends App { 
  ParHtmlSearch.getHtmlSpec() foreach { case specDoc =&gt; 
    def allMatches(d: GenSeq[String]) = warmedTimed() { 
      val results = d.foldLeft("") { (acc, line) =&gt; 
        if (line.matches(".*TEXTAREA.*")) s"$acc\n$line" else acc 
      } 
    } 
    val seqtime = allMatches(specDoc) 
    log(s"Sequential time - $seqtime ms") 
    val partime = allMatches(specDoc.par) 
    log(s"Parallel time   - $partime ms") 
  } 
  Thread.sleep(2000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.148.1">In the preceding program, we use the </span><code class="literal"><span class="koboSpan" id="kobo.149.1">getHtmlSpec</span></code><span class="koboSpan" id="kobo.150.1"> method introduced earlier to obtain the lines of the HTML specification. </span><span class="koboSpan" id="kobo.150.2">We install a callback using the </span><code class="literal"><span class="koboSpan" id="kobo.151.1">foreach</span></code><span class="koboSpan" id="kobo.152.1"> call to process the HTML specification once it arrives; the </span><code class="literal"><span class="koboSpan" id="kobo.153.1">allMatches</span></code><span class="koboSpan" id="kobo.154.1"> method calls the </span><code class="literal"><span class="koboSpan" id="kobo.155.1">foldLeft</span></code><span class="koboSpan" id="kobo.156.1"> operation to accumulate the lines of the specification that contain the </span><code class="literal"><span class="koboSpan" id="kobo.157.1">TEXTAREA</span></code><span class="koboSpan" id="kobo.158.1"> string. </span><span class="koboSpan" id="kobo.158.2">Running the program reveals that both the sequential and parallel </span><code class="literal"><span class="koboSpan" id="kobo.159.1">foldLeft</span></code><span class="koboSpan" id="kobo.160.1"> operations take 5.6 milliseconds.</span></p><p><span class="koboSpan" id="kobo.161.1">To specify how the accumulators produced by different processors should be merged together, we need to use the </span><code class="literal"><span class="koboSpan" id="kobo.162.1">aggregate</span></code><span class="koboSpan" id="kobo.163.1"> method. </span><span class="koboSpan" id="kobo.163.2">The </span><code class="literal"><span class="koboSpan" id="kobo.164.1">aggregate</span></code><span class="koboSpan" id="kobo.165.1"> method is similar to the </span><code class="literal"><span class="koboSpan" id="kobo.166.1">foldLeft</span></code><span class="koboSpan" id="kobo.167.1"> operation, but it does not specify that the elements are traversed from left to right. </span><span class="koboSpan" id="kobo.167.2">Instead, it only specifies that subsets of elements are visited going from left to right; each of these subsets can produce a separate accumulator. </span><span class="koboSpan" id="kobo.167.3">The </span><code class="literal"><span class="koboSpan" id="kobo.168.1">aggregate</span></code><span class="koboSpan" id="kobo.169.1"> method takes an additional function of type </span><code class="literal"><span class="koboSpan" id="kobo.170.1">(S, S) =&gt; S</span></code><span class="koboSpan" id="kobo.171.1">, which is used to merge multiple accumulators:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.172.1">d.aggregate("")( 
  (acc, line) =&gt; 
  if (line.matches(".*TEXTAREA.*")) s"$acc\n$line" else acc, 
  (acc1, acc2) =&gt; acc1 + acc2 
) 
</span></pre><p><span class="koboSpan" id="kobo.173.1">Running the example again shows the difference between the sequential and parallel versions of the program; the parallel </span><code class="literal"><span class="koboSpan" id="kobo.174.1">aggregate</span></code><span class="koboSpan" id="kobo.175.1"> method takes 1.4 milliseconds to complete on our machine.</span></p><p><span class="koboSpan" id="kobo.176.1">When doing these kinds of reduction operation in parallel, we can alternatively use the </span><code class="literal"><span class="koboSpan" id="kobo.177.1">reduce</span></code><span class="koboSpan" id="kobo.178.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.179.1">fold</span></code><span class="koboSpan" id="kobo.180.1"> methods, which do not guarantee going from left to right. </span><span class="koboSpan" id="kobo.180.2">The </span><code class="literal"><span class="koboSpan" id="kobo.181.1">aggregate</span></code><span class="koboSpan" id="kobo.182.1"> method is more expressive, as it allows the accumulator type to be different from the type of the elements in the collection.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip56"/><span class="koboSpan" id="kobo.183.1">Tip</span></h3><p><span class="koboSpan" id="kobo.184.1">Use the </span><code class="literal"><span class="koboSpan" id="kobo.185.1">aggregate</span></code><span class="koboSpan" id="kobo.186.1"> method to execute parallel reduction operations.</span></p></div></div><p><span class="koboSpan" id="kobo.187.1">Other inherently sequential operations include </span><code class="literal"><span class="koboSpan" id="kobo.188.1">foldRight</span></code><span class="koboSpan" id="kobo.189.1">, </span><code class="literal"><span class="koboSpan" id="kobo.190.1">reduceLeft</span></code><span class="koboSpan" id="kobo.191.1">, </span><code class="literal"><span class="koboSpan" id="kobo.192.1">reduceRight</span></code><span class="koboSpan" id="kobo.193.1">, </span><code class="literal"><span class="koboSpan" id="kobo.194.1">reduceLeftOption</span></code><span class="koboSpan" id="kobo.195.1">, </span><code class="literal"><span class="koboSpan" id="kobo.196.1">reduceRightOption</span></code><span class="koboSpan" id="kobo.197.1">, </span><code class="literal"><span class="koboSpan" id="kobo.198.1">scanLeft</span></code><span class="koboSpan" id="kobo.199.1">, </span><code class="literal"><span class="koboSpan" id="kobo.200.1">scanRight</span></code><span class="koboSpan" id="kobo.201.1">, and methods that produce non-parallelizable collections such as the </span><code class="literal"><span class="koboSpan" id="kobo.202.1">toList</span></code><span class="koboSpan" id="kobo.203.1"> method.</span></p></div><div class="section" title="Side effects in parallel operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/><span class="koboSpan" id="kobo.204.1">Side effects in parallel operations</span></h2></div></div></div><p><span class="koboSpan" id="kobo.205.1">As their name implies, parallel collections execute on multiple threads concurrently. </span><span class="koboSpan" id="kobo.205.2">We have already learned in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.206.1">Chapter 2</span></a><span class="koboSpan" id="kobo.207.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.208.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.209.1">, that multiple threads cannot correctly modify shared memory locations without the use of synchronization. </span><span class="koboSpan" id="kobo.209.2">Assigning to a mutable variable from a parallel collection operation may be tempting, but it is almost certainly incorrect. </span><span class="koboSpan" id="kobo.209.3">This is best illustrated by the following example, in which we construct two sets, </span><code class="literal"><span class="koboSpan" id="kobo.210.1">a</span></code><span class="koboSpan" id="kobo.211.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.212.1">b</span></code><span class="koboSpan" id="kobo.213.1">, where </span><code class="literal"><span class="koboSpan" id="kobo.214.1">b</span></code><span class="koboSpan" id="kobo.215.1"> is the subset of the elements in </span><code class="literal"><span class="koboSpan" id="kobo.216.1">a</span></code><span class="koboSpan" id="kobo.217.1">, and then uses the </span><code class="literal"><span class="koboSpan" id="kobo.218.1">total</span></code><span class="koboSpan" id="kobo.219.1"> mutable variable to count the size of the intersection:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.220.1">object ParSideEffectsIncorrect extends App { 
  def intersectionSize(a: GenSet[Int], b: GenSet[Int]): Int = { 
    var total = 0 
    for (x &lt;- a) if (b contains x) total += 1 
    total 
  } 
  val a = (0 until 1000).toSet 
  val b = (0 until 1000 by 4).toSet 
  val seqres = intersectionSize(a, b) 
  val parres = intersectionSize(a.par, b.par) 
  log(s"Sequential result - $seqres") 
  log(s"Parallel result   - $parres") 
} 
</span></pre><p><span class="koboSpan" id="kobo.221.1">Instead of returning </span><code class="literal"><span class="koboSpan" id="kobo.222.1">250</span></code><span class="koboSpan" id="kobo.223.1">, the parallel version nondeterministically returns various wrong results. </span><span class="koboSpan" id="kobo.223.2">Note that you might have to change the sizes of the sets </span><code class="literal"><span class="koboSpan" id="kobo.224.1">a</span></code><span class="koboSpan" id="kobo.225.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.226.1">b</span></code><span class="koboSpan" id="kobo.227.1"> to witness this:</span></p><pre class="programlisting">
<span class="strong"><strong><span class="koboSpan" id="kobo.228.1">run-main-32: Sequential result - 250</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.229.1">run-main-32: Parallel result   - 244</span></strong></span>
</pre><p><span class="koboSpan" id="kobo.230.1">To ensure that the parallel version returns the correct results, we can use an atomic variable and its </span><code class="literal"><span class="koboSpan" id="kobo.231.1">incrementAndGet</span></code><span class="koboSpan" id="kobo.232.1"> method. </span><span class="koboSpan" id="kobo.232.2">However, this leads to the same scalability problems we had before. </span><span class="koboSpan" id="kobo.232.3">A better alternative is to use the parallel </span><code class="literal"><span class="koboSpan" id="kobo.233.1">count</span></code><span class="koboSpan" id="kobo.234.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.235.1">a.count(x =&gt; b contains x) 
</span></pre><p><span class="koboSpan" id="kobo.236.1">If the amount of work executed per element is low and the matches are frequent, the parallel </span><code class="literal"><span class="koboSpan" id="kobo.237.1">count</span></code><span class="koboSpan" id="kobo.238.1"> method will result in better performance than the </span><code class="literal"><span class="koboSpan" id="kobo.239.1">foreach</span></code><span class="koboSpan" id="kobo.240.1"> method with an atomic variable.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip57"/><span class="koboSpan" id="kobo.241.1">Tip</span></h3><p><span class="koboSpan" id="kobo.242.1">To avoid the need for synchronization and ensure better scalability, favor declarative-style parallel operations instead of the side effects in parallel </span><code class="literal"><span class="koboSpan" id="kobo.243.1">for</span></code><span class="koboSpan" id="kobo.244.1"> loops.</span></p></div></div><p><span class="koboSpan" id="kobo.245.1">Similarly, we must ensure that the memory locations read by a parallel operation are protected from concurrent writes. </span><span class="koboSpan" id="kobo.245.2">In the last example, the </span><code class="literal"><span class="koboSpan" id="kobo.246.1">b</span></code><span class="koboSpan" id="kobo.247.1"> set should not be concurrently mutated by some thread while the parallel operation is executing; this leads to the same incorrect results as using mutable variables from within the parallel operation.</span></p></div><div class="section" title="Nondeterministic parallel operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/><span class="koboSpan" id="kobo.248.1">Nondeterministic parallel operations</span></h2></div></div></div><p><span class="koboSpan" id="kobo.249.1">In </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.250.1">Chapter 2</span></a><span class="koboSpan" id="kobo.251.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.252.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.253.1">, we saw that multithreaded programs can be nondeterministic; given the same inputs, they can produce different outputs depending on the execution schedule. </span><span class="koboSpan" id="kobo.253.2">The </span><code class="literal"><span class="koboSpan" id="kobo.254.1">find</span></code><span class="koboSpan" id="kobo.255.1"> collection operation returns an element matching a given predicate. </span><span class="koboSpan" id="kobo.255.2">The parallel </span><code class="literal"><span class="koboSpan" id="kobo.256.1">find</span></code><span class="koboSpan" id="kobo.257.1"> operation returns whichever element was found first by some processor. </span><span class="koboSpan" id="kobo.257.2">In the following example, we use </span><code class="literal"><span class="koboSpan" id="kobo.258.1">find</span></code><span class="koboSpan" id="kobo.259.1"> to search the HTML specification for occurrences of the </span><code class="literal"><span class="koboSpan" id="kobo.260.1">TEXTAREA</span></code><span class="koboSpan" id="kobo.261.1"> string; running the example several times gives different results, because the </span><code class="literal"><span class="koboSpan" id="kobo.262.1">TEXTAREA</span></code><span class="koboSpan" id="kobo.263.1"> string occurs in many different places in the HTML specification:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.264.1">object ParNonDeterministicOperation extends App { 
  ParHtmlSearch.getHtmlSpec() foreach { case specDoc =&gt; 
    val patt = ".*TEXTAREA.*" 
    val seqresult = specDoc.find(_.matches(patt)) 
    val parresult = specDoc.par.find(_.matches(patt)) 
    log(s"Sequential result - $seqresult") 
    log(s"Parallel result   - $parresult") 
  } 
  Thread.sleep(3000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.265.1">If we want to retrieve the first occurrence of the </span><code class="literal"><span class="koboSpan" id="kobo.266.1">TEXTAREA</span></code><span class="koboSpan" id="kobo.267.1"> string, we need to use </span><code class="literal"><span class="koboSpan" id="kobo.268.1">indexWhere</span></code><span class="koboSpan" id="kobo.269.1"> instead:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.270.1">val index = specDoc.par.indexWhere(_.matches(patt)) 
val parresult = if (index != -1) Some(specDoc(index)) else None 
</span></pre><p><span class="koboSpan" id="kobo.271.1">Parallel collection operations other than </span><code class="literal"><span class="koboSpan" id="kobo.272.1">find</span></code><span class="koboSpan" id="kobo.273.1"> are deterministic as long as their operators are </span><span class="strong"><strong><span class="koboSpan" id="kobo.274.1">pure functions</span></strong></span><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">A pure function is always evaluated to the same value, given the same inputs, and does not have any side effects. </span><span class="koboSpan" id="kobo.275.3">For example, the function </span><code class="literal"><span class="koboSpan" id="kobo.276.1">(x: Int) =&gt; x + 1</span></code><span class="koboSpan" id="kobo.277.1"> is a pure function. </span><span class="koboSpan" id="kobo.277.2">By contrast, the following function </span><code class="literal"><span class="koboSpan" id="kobo.278.1">f</span></code><span class="koboSpan" id="kobo.279.1"> is not pure, because it changes the state of the </span><code class="literal"><span class="koboSpan" id="kobo.280.1">uid</span></code><span class="koboSpan" id="kobo.281.1"> value:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.282.1">val uid = new AtomicInteger(0) 
val f = (x: Int) =&gt; (x, uid.incrementAndGet()) 
</span></pre><p><span class="koboSpan" id="kobo.283.1">Even if a function does not modify any memory locations, it is not pure if it reads memory locations that might change. </span><span class="koboSpan" id="kobo.283.2">For example, the following </span><code class="literal"><span class="koboSpan" id="kobo.284.1">g</span></code><span class="koboSpan" id="kobo.285.1"> function is not pure:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.286.1">val g = (x: Int) =&gt; (x, uid.get) 
</span></pre><p><span class="koboSpan" id="kobo.287.1">When used with a non-pure function, any parallel operation can become nondeterministic. </span><span class="koboSpan" id="kobo.287.2">Mapping the range of values to unique identifiers in parallel gives a nondeterministic result, as illustrated by the following call:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.288.1">val uids: GenSeq[(Int, Int)] = (0 until 10000).par.map(f) 
</span></pre><p><span class="koboSpan" id="kobo.289.1">The resulting sequence, </span><code class="literal"><span class="koboSpan" id="kobo.290.1">uids</span></code><span class="koboSpan" id="kobo.291.1">, is different in separate executions. </span><span class="koboSpan" id="kobo.291.2">The parallel </span><code class="literal"><span class="koboSpan" id="kobo.292.1">map</span></code><span class="koboSpan" id="kobo.293.1"> operation retains the relative order of elements from the range </span><code class="literal"><span class="koboSpan" id="kobo.294.1">0 until 10000</span></code><span class="koboSpan" id="kobo.295.1">, so the tuples in </span><code class="literal"><span class="koboSpan" id="kobo.296.1">uids</span></code><span class="koboSpan" id="kobo.297.1"> are ordered by their first elements from 0 until 10,000. </span><span class="koboSpan" id="kobo.297.2">On the other hand, the second element in each tuple is assigned nondeterministically; in one execution, the </span><code class="literal"><span class="koboSpan" id="kobo.298.1">uids</span></code><span class="koboSpan" id="kobo.299.1"> sequence can start with the </span><code class="literal"><span class="koboSpan" id="kobo.300.1">(0, 0), (1, 2), (2, 3), ...</span></code><span class="koboSpan" id="kobo.301.1"> and in another, with </span><code class="literal"><span class="koboSpan" id="kobo.302.1">(0, 0), (1, 4), (2, 9), ...</span></code><span class="koboSpan" id="kobo.303.1">.</span></p></div><div class="section" title="Commutative and associative operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/><span class="koboSpan" id="kobo.304.1">Commutative and associative operators</span></h2></div></div></div><p><span class="koboSpan" id="kobo.305.1">Parallel collection operations such as </span><code class="literal"><span class="koboSpan" id="kobo.306.1">reduce</span></code><span class="koboSpan" id="kobo.307.1">, </span><code class="literal"><span class="koboSpan" id="kobo.308.1">fold</span></code><span class="koboSpan" id="kobo.309.1">, </span><code class="literal"><span class="koboSpan" id="kobo.310.1">aggregate</span></code><span class="koboSpan" id="kobo.311.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.312.1">scan</span></code><span class="koboSpan" id="kobo.313.1"> take binary operators as part of their input. </span><span class="koboSpan" id="kobo.313.2">A binary operator is a function  </span><code class="literal"><span class="koboSpan" id="kobo.314.1">op</span></code><span class="koboSpan" id="kobo.315.1"> that takes two arguments, </span><code class="literal"><span class="koboSpan" id="kobo.316.1">a</span></code><span class="koboSpan" id="kobo.317.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.318.1">b</span></code><span class="koboSpan" id="kobo.319.1">. </span><span class="koboSpan" id="kobo.319.2">We can say that the binary operator </span><code class="literal"><span class="koboSpan" id="kobo.320.1">op</span></code><span class="koboSpan" id="kobo.321.1"> is </span><span class="strong"><strong><span class="koboSpan" id="kobo.322.1">commutative</span></strong></span><span class="koboSpan" id="kobo.323.1"> if changing the order of its arguments returns the same result, that is, </span><code class="literal"><span class="koboSpan" id="kobo.324.1">op(a, b) == op(b, a)</span></code><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">For example, adding two numbers together is a commutative operation. </span><span class="koboSpan" id="kobo.325.3">Concatenating two strings is not a commutative operation; we get different strings depending on the concatenation order.</span></p><p><span class="koboSpan" id="kobo.326.1">Binary operators for the parallel </span><code class="literal"><span class="koboSpan" id="kobo.327.1">reduce</span></code><span class="koboSpan" id="kobo.328.1">, </span><code class="literal"><span class="koboSpan" id="kobo.329.1">fold</span></code><span class="koboSpan" id="kobo.330.1">, </span><code class="literal"><span class="koboSpan" id="kobo.331.1">aggregate</span></code><span class="koboSpan" id="kobo.332.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.333.1">scan</span></code><span class="koboSpan" id="kobo.334.1"> operations never need to be commutative. </span><span class="koboSpan" id="kobo.334.2">Parallel collection operations always respect the relative order of the elements when applying binary operators, provided that the underlying collections have any ordering. </span><span class="koboSpan" id="kobo.334.3">Elements in sequence collections, such as </span><code class="literal"><span class="koboSpan" id="kobo.335.1">ArrayBuffer</span></code><span class="koboSpan" id="kobo.336.1"> collections, are always ordered. </span><span class="koboSpan" id="kobo.336.2">Other collection types can order their elements but are not required to do so.</span></p><p><span class="koboSpan" id="kobo.337.1">In the following example, we can concatenate the strings inside an </span><code class="literal"><span class="koboSpan" id="kobo.338.1">ArrayBuffer</span></code><span class="koboSpan" id="kobo.339.1"> collection into one long string by using the sequential </span><code class="literal"><span class="koboSpan" id="kobo.340.1">reduceLeft</span></code><span class="koboSpan" id="kobo.341.1"> operation and the parallel </span><code class="literal"><span class="koboSpan" id="kobo.342.1">reduce</span></code><span class="koboSpan" id="kobo.343.1"> operation. </span><span class="koboSpan" id="kobo.343.2">We then convert the </span><code class="literal"><span class="koboSpan" id="kobo.344.1">ArrayBuffer</span></code><span class="koboSpan" id="kobo.345.1"> collection into a set, which does not have an ordering:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.346.1">object ParNonCommutativeOperator extends App { 
  val doc = mutable.ArrayBuffer.tabulate(20)(i =&gt; s"Page $i, ") 
  def test(doc: GenIterable[String]) { 
    val seqtext = doc.seq.reduceLeft(_ + _) 
    val partext = doc.par.reduce(_ + _) 
    log(s"Sequential result - $seqtext\n") 
    log(s"Parallel result   - $partext\n") 
  } 
  test(doc) 
  test(doc.toSet) 
} 
</span></pre><p><span class="koboSpan" id="kobo.347.1">We can see that the string is concatenated correctly when the parallel </span><code class="literal"><span class="koboSpan" id="kobo.348.1">reduce</span></code><span class="koboSpan" id="kobo.349.1"> operation is invoked on a parallel array, but the order of the pages is mangled both for the </span><code class="literal"><span class="koboSpan" id="kobo.350.1">reduceLeft</span></code><span class="koboSpan" id="kobo.351.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.352.1">reduce</span></code><span class="koboSpan" id="kobo.353.1"> operations when invoked on a set; the default Scala set implementation does not order the elements.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note58"/><span class="koboSpan" id="kobo.354.1">Note</span></h3><p><span class="koboSpan" id="kobo.355.1">Binary operators used in parallel operations do not need to be commutative.</span></p></div></div><p><span class="koboSpan" id="kobo.356.1">An </span><code class="literal"><span class="koboSpan" id="kobo.357.1">op</span></code><span class="koboSpan" id="kobo.358.1"> binary operator is </span><span class="strong"><strong><span class="koboSpan" id="kobo.359.1">associative</span></strong></span><span class="koboSpan" id="kobo.360.1"> if applying </span><code class="literal"><span class="koboSpan" id="kobo.361.1">op</span></code><span class="koboSpan" id="kobo.362.1"> consecutively to a sequence of values </span><code class="literal"><span class="koboSpan" id="kobo.363.1">a</span></code><span class="koboSpan" id="kobo.364.1">, </span><code class="literal"><span class="koboSpan" id="kobo.365.1">b</span></code><span class="koboSpan" id="kobo.366.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.367.1">c</span></code><span class="koboSpan" id="kobo.368.1"> gives the same result regardless of the order in which the operator is applied, that is, </span><code class="literal"><span class="koboSpan" id="kobo.369.1">op(a, op(b, c)) == op(op(a, b), c)</span></code><span class="koboSpan" id="kobo.370.1">. </span><span class="koboSpan" id="kobo.370.2">Adding two numbers together or computing the larger of the two numbers is an associative operation. </span><span class="koboSpan" id="kobo.370.3">Subtraction is not associative, as </span><code class="literal"><span class="koboSpan" id="kobo.371.1">1 - (2 - 3)</span></code><span class="koboSpan" id="kobo.372.1"> is different from </span><code class="literal"><span class="koboSpan" id="kobo.373.1">(1 - 2) - 3</span></code><span class="koboSpan" id="kobo.374.1">.</span></p><p><span class="koboSpan" id="kobo.375.1">Parallel collection operations usually require associative binary operators. </span><span class="koboSpan" id="kobo.375.2">While using subtraction with the </span><code class="literal"><span class="koboSpan" id="kobo.376.1">reduceLeft</span></code><span class="koboSpan" id="kobo.377.1"> operation means that all the numbers in the collection should be subtracted from the first number, using subtraction in the </span><code class="literal"><span class="koboSpan" id="kobo.378.1">reduce</span></code><span class="koboSpan" id="kobo.379.1">, </span><code class="literal"><span class="koboSpan" id="kobo.380.1">fold</span></code><span class="koboSpan" id="kobo.381.1">, or </span><code class="literal"><span class="koboSpan" id="kobo.382.1">scan</span></code><span class="koboSpan" id="kobo.383.1"> methods gives nondeterministic and incorrect results, as illustrated by the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.384.1">object ParNonAssociativeOperator extends App { 
  def test(doc: GenIterable[Int]) { 
    val seqtext = doc.seq.reduceLeft(_ - _) 
    val partext = doc.par.reduce(_ - _) 
    log(s"Sequential result - $seqtext\n") 
    log(s"Parallel result   - $partext\n") 
  } 
  test(0 until 30) 
} 
</span></pre><p><span class="koboSpan" id="kobo.385.1">While the </span><code class="literal"><span class="koboSpan" id="kobo.386.1">reduceLeft</span></code><span class="koboSpan" id="kobo.387.1"> operation consistently returns </span><code class="literal"><span class="koboSpan" id="kobo.388.1">-435</span></code><span class="koboSpan" id="kobo.389.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.390.1">reduce</span></code><span class="koboSpan" id="kobo.391.1"> operation returns meaningless results at random.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip59"/><span class="koboSpan" id="kobo.392.1">Tip</span></h3><p><span class="koboSpan" id="kobo.393.1">Make sure that binary operators used in parallel operations are associative.</span></p></div></div><p><span class="koboSpan" id="kobo.394.1">Parallel operations such as </span><code class="literal"><span class="koboSpan" id="kobo.395.1">aggregate</span></code><span class="koboSpan" id="kobo.396.1"> require the multiple binary operators, </span><code class="literal"><span class="koboSpan" id="kobo.397.1">sop</span></code><span class="koboSpan" id="kobo.398.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.399.1">cop</span></code><span class="koboSpan" id="kobo.400.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.401.1">def aggregate[S](z: S)(sop: (S, T) =&gt; S, cop: (S, S) =&gt; S): S 
</span></pre><p><span class="koboSpan" id="kobo.402.1">The </span><code class="literal"><span class="koboSpan" id="kobo.403.1">sop</span></code><span class="koboSpan" id="kobo.404.1"> operator is of the same type as the operator required by the </span><code class="literal"><span class="koboSpan" id="kobo.405.1">reduceLeft</span></code><span class="koboSpan" id="kobo.406.1"> operation. </span><span class="koboSpan" id="kobo.406.2">It takes an accumulator and the collection element. </span><span class="koboSpan" id="kobo.406.3">The </span><code class="literal"><span class="koboSpan" id="kobo.407.1">sop</span></code><span class="koboSpan" id="kobo.408.1"> operator is used to fold elements within a subset assigned to a specific processor. </span><span class="koboSpan" id="kobo.408.2">The </span><code class="literal"><span class="koboSpan" id="kobo.409.1">cop</span></code><span class="koboSpan" id="kobo.410.1"> operator is used to merge the subsets together and is of the same type as the operators for </span><code class="literal"><span class="koboSpan" id="kobo.411.1">reduce</span></code><span class="koboSpan" id="kobo.412.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.413.1">fold</span></code><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">The </span><code class="literal"><span class="koboSpan" id="kobo.415.1">aggregate</span></code><span class="koboSpan" id="kobo.416.1"> operation requires that </span><code class="literal"><span class="koboSpan" id="kobo.417.1">cop</span></code><span class="koboSpan" id="kobo.418.1"> is associative and that </span><code class="literal"><span class="koboSpan" id="kobo.419.1">z</span></code><span class="koboSpan" id="kobo.420.1"> is the </span><span class="strong"><strong><span class="koboSpan" id="kobo.421.1">zero element</span></strong></span><span class="koboSpan" id="kobo.422.1"> for the accumulator, that is, </span><code class="literal"><span class="koboSpan" id="kobo.423.1">cop(z, a) == a</span></code><span class="koboSpan" id="kobo.424.1">. </span><span class="koboSpan" id="kobo.424.2">Additionally, the </span><code class="literal"><span class="koboSpan" id="kobo.425.1">sop</span></code><span class="koboSpan" id="kobo.426.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.427.1">cop</span></code><span class="koboSpan" id="kobo.428.1"> operators must give the same result irrespective of the order in which element subsets are assigned to processors, that is, </span><code class="literal"><span class="koboSpan" id="kobo.429.1">cop(sop(z, a), sop(z, b)) == cop(z, sop(sop(z, a), b))</span></code><span class="koboSpan" id="kobo.430.1">.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using parallel and concurrent collections together"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/><span class="koboSpan" id="kobo.1.1">Using parallel and concurrent collections together</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">We have already seen that parallel collection operations are not allowed to access mutable states without the use of synchronization. </span><span class="koboSpan" id="kobo.2.2">This includes modifying sequential Scala collections from within a parallel operation. </span><span class="koboSpan" id="kobo.2.3">Recall that we used a mutable variable in the section on side effects to count the size of the intersection. </span><span class="koboSpan" id="kobo.2.4">In the following example, we will download the URL and HTML specifications, convert them to sets of words, and try to find an intersection of their words. </span><span class="koboSpan" id="kobo.2.5">In the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">intersection</span></code><span class="koboSpan" id="kobo.4.1"> method, we use a </span><code class="literal"><span class="koboSpan" id="kobo.5.1">HashSet</span></code><span class="koboSpan" id="kobo.6.1"> collection and update it in parallel. </span><span class="koboSpan" id="kobo.6.2">Collections in the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">scala.collection.mutable</span></code><span class="koboSpan" id="kobo.8.1"> package are not thread-safe. </span><span class="koboSpan" id="kobo.8.2">The following example nondeterministically drops elements, corrupts the buffer state, or throws exceptions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">object ConcurrentWrong extends App { 
  import ParHtmlSearch.getHtmlSpec 
  import ch4.FuturesCallbacks.getUrlSpec 
  def intersection(a: GenSet[String], b: GenSet[String]) = { 
    val result = new mutable.HashSet[String] 
    for (x &lt;- a.par) if (b contains x) result.add(x) 
    result 
  } 
  val ifut = for { 
    htmlSpec &lt;- getHtmlSpec() 
    urlSpec &lt;- getUrlSpec() 
  } yield { 
    val htmlWords = htmlSpec.mkString.split("\\s+").toSet 
    val urlWords = urlSpec.mkString.split("\\s+").toSet 
    intersection(htmlWords, urlWords) 
  } 
  ifut onComplete { case t =&gt; log(s"Result: $t") } 
  Thread.sleep(3000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.10.1">We learned in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.11.1">Chapter 3</span></a><span class="koboSpan" id="kobo.12.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.13.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.14.1">, that concurrent collections can be safely modified by multiple threads without the risk of data corruption. </span><span class="koboSpan" id="kobo.14.2">We use the concurrent skip list collection from the JDK to accumulate words that appear in both specifications. </span><span class="koboSpan" id="kobo.14.3">The </span><code class="literal"><span class="koboSpan" id="kobo.15.1">decorateAsScala</span></code><span class="koboSpan" id="kobo.16.1"> object is used to add the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">asScala</span></code><span class="koboSpan" id="kobo.18.1"> method to Java collections:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.19.1">import java.util.concurrent.ConcurrentSkipListSet 
import scala.collection.convert.decorateAsScala._ 
def intersection(a: GenSet[String], b: GenSet[String]) = { 
  val skiplist = new ConcurrentSkipListSet[String] 
  for (x &lt;- a.par) if (b contains x) skiplist.add(x) 
  val result: Set[String] = skiplist.asScala 
  result 
} 
</span></pre><div class="section" title="Weakly consistent iterators"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/><span class="koboSpan" id="kobo.20.1">Weakly consistent iterators</span></h2></div></div></div><p><span class="koboSpan" id="kobo.21.1">As we saw in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.22.1">Chapter 3</span></a><span class="koboSpan" id="kobo.23.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.24.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.25.1">, iterators on most concurrent collections are weakly consistent. </span><span class="koboSpan" id="kobo.25.2">This means that they are not guaranteed to correctly traverse the data structure if some thread concurrently updates the collection during traversal.</span></p><p><span class="koboSpan" id="kobo.26.1">When executing a parallel operation on a concurrent collection, the same limitation applies; the traversal is weakly consistent and might not reflect the state of the data structure at the point when the operation started. </span><span class="koboSpan" id="kobo.26.2">The Scala </span><code class="literal"><span class="koboSpan" id="kobo.27.1">TrieMap</span></code><span class="koboSpan" id="kobo.28.1"> collection is an exception to this rule. </span><span class="koboSpan" id="kobo.28.2">In the following example, we will create a </span><code class="literal"><span class="koboSpan" id="kobo.29.1">TrieMap</span></code><span class="koboSpan" id="kobo.30.1"> collection called </span><code class="literal"><span class="koboSpan" id="kobo.31.1">cache</span></code><span class="koboSpan" id="kobo.32.1"> containing numbers between 0 and 100, mapped to their string representation. </span><span class="koboSpan" id="kobo.32.2">We will then start a parallel operation that traverses these numbers and adds the mappings for their negative values to the map:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.33.1">object ConcurrentTrieMap extends App { 
  val cache = new concurrent.TrieMap[Int, String]() 
  for (i &lt;- 0 until 100) cache(i) = i.toString 
  for ((number, string) &lt;- cache.par) cache(-number) = s"-$string" 
  log(s"cache - ${cache.keys.toList.sorted}") 
} 
</span></pre><p><span class="koboSpan" id="kobo.34.1">The parallel </span><code class="literal"><span class="koboSpan" id="kobo.35.1">foreach</span></code><span class="koboSpan" id="kobo.36.1"> operation does not traverse entries added after the parallel operation started; only positive numbers are reflected in the traversal. </span><span class="koboSpan" id="kobo.36.2">The </span><code class="literal"><span class="koboSpan" id="kobo.37.1">TrieMap</span></code><span class="koboSpan" id="kobo.38.1"> collection is implemented using the Ctrie concurrent data structure, which atomically creates a snapshot of the collection when the parallel operation starts. </span><span class="koboSpan" id="kobo.38.2">Snapshot creation is efficient and does not require you to copy the elements; subsequent update operations incrementally rebuild parts of the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">TrieMap</span></code><span class="koboSpan" id="kobo.40.1"> collection.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip60"/><span class="koboSpan" id="kobo.41.1">Tip</span></h3><p><span class="koboSpan" id="kobo.42.1">Whenever program data needs to be simultaneously modified and traversed in parallel, use the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">TrieMap</span></code><span class="koboSpan" id="kobo.44.1"> collection.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Implementing custom parallel collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/><span class="koboSpan" id="kobo.1.1">Implementing custom parallel collections</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Parallel collections in the Scala standard library are sufficient for most tasks, but in some cases we want to add parallel operations to our own collections. </span><span class="koboSpan" id="kobo.2.2">The Java </span><code class="literal"><span class="koboSpan" id="kobo.3.1">String</span></code><span class="koboSpan" id="kobo.4.1"> class does not have a direct parallel counterpart in the parallel collections framework. </span><span class="koboSpan" id="kobo.4.2">In this section, we will study how to implement a custom </span><code class="literal"><span class="koboSpan" id="kobo.5.1">ParString</span></code><span class="koboSpan" id="kobo.6.1"> class that supports parallel operations. </span><span class="koboSpan" id="kobo.6.2">We will then use our custom parallel collection class in several example programs.</span></p><p><span class="koboSpan" id="kobo.7.1">The first step in implementing a custom parallel collection is to extend the correct parallel collection trait. </span><span class="koboSpan" id="kobo.7.2">A parallel string is a sequence of characters, so we need to extend the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">ParSeq</span></code><span class="koboSpan" id="kobo.9.1"> trait with the </span><code class="literal"><span class="koboSpan" id="kobo.10.1">Char</span></code><span class="koboSpan" id="kobo.11.1"> type argument. </span><span class="koboSpan" id="kobo.11.2">Once a string is created, it can no longer be modified; we say that the string is an immutable collection. </span><span class="koboSpan" id="kobo.11.3">For this reason, we extend a subtype of the </span><code class="literal"><span class="koboSpan" id="kobo.12.1">scala.collection.parallel.ParSeq</span></code><span class="koboSpan" id="kobo.13.1"> trait, the </span><code class="literal"><span class="koboSpan" id="kobo.14.1">ParSeq</span></code><span class="koboSpan" id="kobo.15.1"> trait from the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">scala.collection.parallel.immutable</span></code><span class="koboSpan" id="kobo.17.1"> package:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.18.1">class ParString(val str: String) extends immutable.ParSeq[Char] { 
  def apply(i: Int) = str.charAt(i) 
  def length = str.length 
  def splitter = new ParStringSplitter(str, 0, str.length) 
  def seq = new collection.immutable.WrappedString(str) 
} 
</span></pre><p><span class="koboSpan" id="kobo.19.1">When we extend a parallel collection, we need to implement its </span><code class="literal"><span class="koboSpan" id="kobo.20.1">apply</span></code><span class="koboSpan" id="kobo.21.1">, </span><code class="literal"><span class="koboSpan" id="kobo.22.1">length</span></code><span class="koboSpan" id="kobo.23.1">, </span><code class="literal"><span class="koboSpan" id="kobo.24.1">splitter</span></code><span class="koboSpan" id="kobo.25.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.26.1">seq</span></code><span class="koboSpan" id="kobo.27.1"> methods. </span><span class="koboSpan" id="kobo.27.2">The </span><code class="literal"><span class="koboSpan" id="kobo.28.1">apply</span></code><span class="koboSpan" id="kobo.29.1"> method returns an element at position </span><code class="literal"><span class="koboSpan" id="kobo.30.1">i</span></code><span class="koboSpan" id="kobo.31.1"> in the sequence, and the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">length</span></code><span class="koboSpan" id="kobo.33.1"> method returns the total number of elements in the sequence. </span><span class="koboSpan" id="kobo.33.2">These methods are equivalent to the methods on sequential collections, so we use the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">String</span></code><span class="koboSpan" id="kobo.35.1"> class's </span><code class="literal"><span class="koboSpan" id="kobo.36.1">charAt</span></code><span class="koboSpan" id="kobo.37.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.38.1">length</span></code><span class="koboSpan" id="kobo.39.1"> methods to implement them. </span><span class="koboSpan" id="kobo.39.2">Where defining a custom regular sequence requires implementing its </span><code class="literal"><span class="koboSpan" id="kobo.40.1">iterator</span></code><span class="koboSpan" id="kobo.41.1"> method, custom parallel collections need a </span><code class="literal"><span class="koboSpan" id="kobo.42.1">splitter</span></code><span class="koboSpan" id="kobo.43.1"> method. </span><span class="koboSpan" id="kobo.43.2">Calling </span><code class="literal"><span class="koboSpan" id="kobo.44.1">splitter</span></code><span class="koboSpan" id="kobo.45.1"> returns an object of the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">Splitter[T]</span></code><span class="koboSpan" id="kobo.47.1"> type, a special iterator that can be split into subsets. </span><span class="koboSpan" id="kobo.47.2">We implement the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">splitter</span></code><span class="koboSpan" id="kobo.49.1"> method to return a </span><code class="literal"><span class="koboSpan" id="kobo.50.1">ParStringSplitter</span></code><span class="koboSpan" id="kobo.51.1"> object, which we will show you shortly. </span><span class="koboSpan" id="kobo.51.2">Finally, parallel collections need a </span><code class="literal"><span class="koboSpan" id="kobo.52.1">seq</span></code><span class="koboSpan" id="kobo.53.1"> method, which returns a sequential Scala collection. </span><span class="koboSpan" id="kobo.53.2">Since </span><code class="literal"><span class="koboSpan" id="kobo.54.1">String</span></code><span class="koboSpan" id="kobo.55.1"> itself comes from Java and is not a Scala collection, we will use its </span><code class="literal"><span class="koboSpan" id="kobo.56.1">WrappedString</span></code><span class="koboSpan" id="kobo.57.1"> wrapper class from the Scala collections library.</span></p><p><span class="koboSpan" id="kobo.58.1">Our custom parallel collection class is almost complete; we only need to provide the implementation for the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">ParStringSplitter</span></code><span class="koboSpan" id="kobo.60.1"> object. </span><span class="koboSpan" id="kobo.60.2">We will study how to do this next.</span></p><div class="section" title="Splitters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/><span class="koboSpan" id="kobo.61.1">Splitters</span></h2></div></div></div><p><span class="koboSpan" id="kobo.62.1">A splitter is an iterator that can be efficiently split into disjoint subsets. </span><span class="koboSpan" id="kobo.62.2">Here, efficient means that the splitter's </span><code class="literal"><span class="koboSpan" id="kobo.63.1">split</span></code><span class="koboSpan" id="kobo.64.1"> method must have </span><span class="strong"><strong><span class="koboSpan" id="kobo.65.1">O</span></strong></span><span class="koboSpan" id="kobo.66.1">(</span><span class="emphasis"><em><span class="koboSpan" id="kobo.67.1">log</span></em></span><span class="koboSpan" id="kobo.68.1">(</span><span class="emphasis"><em><span class="koboSpan" id="kobo.69.1">N</span></em></span><span class="koboSpan" id="kobo.70.1">)) running time, where </span><span class="emphasis"><em><span class="koboSpan" id="kobo.71.1">N</span></em></span><span class="koboSpan" id="kobo.72.1"> is the number of elements in the splitter. </span><span class="koboSpan" id="kobo.72.2">Stated informally, a splitter is not allowed to copy large parts of the collection when split; if it did, the computational overhead from splitting would overcome any benefits from parallelization and become a serial bottleneck.</span></p><p><span class="koboSpan" id="kobo.73.1">The easiest way to define a new </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Splitter</span></code><span class="koboSpan" id="kobo.75.1"> class for the Scala parallel collection framework is to extend the </span><code class="literal"><span class="koboSpan" id="kobo.76.1">IterableSplitter[T]</span></code><span class="koboSpan" id="kobo.77.1"> trait, which has the following simplified interface:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.78.1">trait IterableSplitter[T] extends Iterator[T] { 
  def dup: IterableSplitter[T] 
  def remaining: Int 
  def split: Seq[IterableSplitter[T]] 
} 
</span></pre><p><span class="koboSpan" id="kobo.79.1">The splitter interface declares the </span><code class="literal"><span class="koboSpan" id="kobo.80.1">dup</span></code><span class="koboSpan" id="kobo.81.1"> method which duplicates the current splitter. </span><span class="koboSpan" id="kobo.81.2">This method simply returns a new splitter pointing to the same subset of the collection. </span><span class="koboSpan" id="kobo.81.3">Splitters also define the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">remaining</span></code><span class="koboSpan" id="kobo.83.1"> method, which returns the number of elements that the splitter can traverse by calling </span><code class="literal"><span class="koboSpan" id="kobo.84.1">next</span></code><span class="koboSpan" id="kobo.85.1"> before the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">hasNext</span></code><span class="koboSpan" id="kobo.87.1"> method returns </span><code class="literal"><span class="koboSpan" id="kobo.88.1">false</span></code><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">The </span><code class="literal"><span class="koboSpan" id="kobo.90.1">remaining</span></code><span class="koboSpan" id="kobo.91.1"> method does not change the state of the splitter and can be called as many times as necessary.</span></p><p><span class="koboSpan" id="kobo.92.1">However, the </span><code class="literal"><span class="koboSpan" id="kobo.93.1">split</span></code><span class="koboSpan" id="kobo.94.1"> method can be called only once and it invalidates the splitter; none of the splitter's methods should be called after calling the </span><code class="literal"><span class="koboSpan" id="kobo.95.1">split</span></code><span class="koboSpan" id="kobo.96.1"> method. </span><span class="koboSpan" id="kobo.96.2">The </span><code class="literal"><span class="koboSpan" id="kobo.97.1">split</span></code><span class="koboSpan" id="kobo.98.1"> method returns a sequence of splitters that iterate over the disjoint subsets of the original splitter. </span><span class="koboSpan" id="kobo.98.2">If the original splitter has two or more elements remaining, then none of the resulting splitters should be empty, and the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">split</span></code><span class="koboSpan" id="kobo.100.1"> method should return at least two splitters. </span><span class="koboSpan" id="kobo.100.2">If the original splitter has a single element or no elements remaining, then </span><code class="literal"><span class="koboSpan" id="kobo.101.1">split</span></code><span class="koboSpan" id="kobo.102.1"> is allowed to return empty splitters. </span><span class="koboSpan" id="kobo.102.2">Importantly, the splitters returned by </span><code class="literal"><span class="koboSpan" id="kobo.103.1">split</span></code><span class="koboSpan" id="kobo.104.1"> should be approximately equal in size; this helps the parallel collection scheduler achieve good performance.</span></p><p><span class="koboSpan" id="kobo.105.1">To allow sequence-specific operations such as </span><code class="literal"><span class="koboSpan" id="kobo.106.1">zip</span></code><span class="koboSpan" id="kobo.107.1">, </span><code class="literal"><span class="koboSpan" id="kobo.108.1">sameElements</span></code><span class="koboSpan" id="kobo.109.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.110.1">corresponds</span></code><span class="koboSpan" id="kobo.111.1">, parallel sequence collections use a more refined subtype of the </span><code class="literal"><span class="koboSpan" id="kobo.112.1">IterableSplitter</span></code><span class="koboSpan" id="kobo.113.1"> trait, called the </span><code class="literal"><span class="koboSpan" id="kobo.114.1">SeqSplitter</span></code><span class="koboSpan" id="kobo.115.1"> trait:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.116.1">trait SeqSplitter[T] extends IterableSplitter[T] { 
  def psplit(sizes: Int*): Seq[SeqSplitter[T]] 
} 
</span></pre><p><span class="koboSpan" id="kobo.117.1">Sequence splitters declare an additional method, </span><code class="literal"><span class="koboSpan" id="kobo.118.1">psplit</span></code><span class="koboSpan" id="kobo.119.1">, which takes the list of sizes for the splitter partitions and returns as many splitters and elements as specified by the </span><code class="literal"><span class="koboSpan" id="kobo.120.1">sizes</span></code><span class="koboSpan" id="kobo.121.1"> parameter. </span><span class="koboSpan" id="kobo.121.2">If </span><code class="literal"><span class="koboSpan" id="kobo.122.1">sizes</span></code><span class="koboSpan" id="kobo.123.1"> specifies more elements than there are available in the splitter, additional empty splitters are returned at the end of the resulting sequence. </span><span class="koboSpan" id="kobo.123.2">For example, calling </span><code class="literal"><span class="koboSpan" id="kobo.124.1">s.psplit(10, 20, 15)</span></code><span class="koboSpan" id="kobo.125.1"> on a splitter with only 15 elements yields three splitters with sizes 10, five, and zero.</span></p><p><span class="koboSpan" id="kobo.126.1">Similarly, if the </span><code class="literal"><span class="koboSpan" id="kobo.127.1">sizes</span></code><span class="koboSpan" id="kobo.128.1"> parameter specifies fewer elements than there are in the splitter, an additional splitter with the remaining elements is appended at the end.</span></p><p><span class="koboSpan" id="kobo.129.1">Our parallel string class is a parallel sequence, so we need to implement a sequence splitter. </span><span class="koboSpan" id="kobo.129.2">We can start by extending the </span><code class="literal"><span class="koboSpan" id="kobo.130.1">SeqSplitter</span></code><span class="koboSpan" id="kobo.131.1"> class with the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">Char</span></code><span class="koboSpan" id="kobo.133.1"> type parameter:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.134.1">class ParStringSplitter 
  (val s: String, var i: Int, val limit: Int) 
extends SeqSplitter[Char] { 
</span></pre><p><span class="koboSpan" id="kobo.135.1">We add the </span><code class="literal"><span class="koboSpan" id="kobo.136.1">s</span></code><span class="koboSpan" id="kobo.137.1"> field pointing to the underlying </span><code class="literal"><span class="koboSpan" id="kobo.138.1">String</span></code><span class="koboSpan" id="kobo.139.1"> object in the </span><code class="literal"><span class="koboSpan" id="kobo.140.1">ParStringSplitter</span></code><span class="koboSpan" id="kobo.141.1"> constructor. </span><span class="koboSpan" id="kobo.141.2">A parallel string splitter must represent a subset of the elements in the string, so we add an </span><code class="literal"><span class="koboSpan" id="kobo.142.1">i</span></code><span class="koboSpan" id="kobo.143.1"> field to represent the position of the next character that will be traversed by the splitter. </span><span class="koboSpan" id="kobo.143.2">Note that </span><code class="literal"><span class="koboSpan" id="kobo.144.1">i</span></code><span class="koboSpan" id="kobo.145.1"> does not need to be synchronized; the splitter is only used by one processor at a time. </span><span class="koboSpan" id="kobo.145.2">The </span><code class="literal"><span class="koboSpan" id="kobo.146.1">limit</span></code><span class="koboSpan" id="kobo.147.1"> field contains the position after the last character in the splitter. </span><span class="koboSpan" id="kobo.147.2">This way, our splitter class represents substrings of the original string.</span></p><p><span class="koboSpan" id="kobo.148.1">Implementing methods inherited from the </span><code class="literal"><span class="koboSpan" id="kobo.149.1">Iterator</span></code><span class="koboSpan" id="kobo.150.1"> trait is easy. </span><span class="koboSpan" id="kobo.150.2">As long as </span><code class="literal"><span class="koboSpan" id="kobo.151.1">i</span></code><span class="koboSpan" id="kobo.152.1"> is less than </span><code class="literal"><span class="koboSpan" id="kobo.153.1">limit</span></code><span class="koboSpan" id="kobo.154.1">, </span><code class="literal"><span class="koboSpan" id="kobo.155.1">hasNext</span></code><span class="koboSpan" id="kobo.156.1"> must return </span><code class="literal"><span class="koboSpan" id="kobo.157.1">true</span></code><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">The </span><code class="literal"><span class="koboSpan" id="kobo.159.1">next</span></code><span class="koboSpan" id="kobo.160.1"> method uses </span><code class="literal"><span class="koboSpan" id="kobo.161.1">i</span></code><span class="koboSpan" id="kobo.162.1"> to read the character at that position, increment </span><code class="literal"><span class="koboSpan" id="kobo.163.1">i</span></code><span class="koboSpan" id="kobo.164.1">, and return the character:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.165.1">  final def hasNext = i &lt; limit 
  final def next = { 
    val r = s.charAt(i) 
    i += 1 
    r 
  } 
</span></pre><p><span class="koboSpan" id="kobo.166.1">The </span><code class="literal"><span class="koboSpan" id="kobo.167.1">dup</span></code><span class="koboSpan" id="kobo.168.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.169.1">remaining</span></code><span class="koboSpan" id="kobo.170.1"> methods are straightforward; the </span><code class="literal"><span class="koboSpan" id="kobo.171.1">dup</span></code><span class="koboSpan" id="kobo.172.1"> method creates a new parallel string splitter using the state of the current splitter, and the </span><code class="literal"><span class="koboSpan" id="kobo.173.1">remaining</span></code><span class="koboSpan" id="kobo.174.1"> method uses </span><code class="literal"><span class="koboSpan" id="kobo.175.1">limit</span></code><span class="koboSpan" id="kobo.176.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.177.1">i</span></code><span class="koboSpan" id="kobo.178.1"> to compute the number of remaining elements:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.179.1">  def dup = new ParStringSplitter(s, i, limit) 
  def remaining = limit - i 
</span></pre><p><span class="koboSpan" id="kobo.180.1">The main parts of a splitter are its </span><code class="literal"><span class="koboSpan" id="kobo.181.1">split</span></code><span class="koboSpan" id="kobo.182.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.183.1">psplit</span></code><span class="koboSpan" id="kobo.184.1"> methods. </span><span class="koboSpan" id="kobo.184.2">Luckily, </span><code class="literal"><span class="koboSpan" id="kobo.185.1">split</span></code><span class="koboSpan" id="kobo.186.1"> can be implemented in terms of </span><code class="literal"><span class="koboSpan" id="kobo.187.1">psplit</span></code><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">If there is more than one element remaining, we call the </span><code class="literal"><span class="koboSpan" id="kobo.189.1">psplit</span></code><span class="koboSpan" id="kobo.190.1"> method. </span><span class="koboSpan" id="kobo.190.2">Otherwise, if there are no elements to split, we return the </span><code class="literal"><span class="koboSpan" id="kobo.191.1">this</span></code><span class="koboSpan" id="kobo.192.1"> splitter:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.193.1">  def split = { 
    val rem = remaining 
    if (rem &gt;= 2) psplit(rem / 2, rem - rem / 2) 
    else Seq(this) 
  } 
</span></pre><p><span class="koboSpan" id="kobo.194.1">The </span><code class="literal"><span class="koboSpan" id="kobo.195.1">psplit</span></code><span class="koboSpan" id="kobo.196.1"> method uses </span><code class="literal"><span class="koboSpan" id="kobo.197.1">sizes</span></code><span class="koboSpan" id="kobo.198.1"> to peel off parts of the original splitter. </span><span class="koboSpan" id="kobo.198.2">It does so by incrementing the </span><code class="literal"><span class="koboSpan" id="kobo.199.1">i</span></code><span class="koboSpan" id="kobo.200.1"> variable and creating a new splitter for each size </span><code class="literal"><span class="koboSpan" id="kobo.201.1">sz</span></code><span class="koboSpan" id="kobo.202.1"> in the </span><code class="literal"><span class="koboSpan" id="kobo.203.1">sizes</span></code><span class="koboSpan" id="kobo.204.1"> parameter. </span><span class="koboSpan" id="kobo.204.2">Recall that the current splitter is considered invalidated after calling the </span><code class="literal"><span class="koboSpan" id="kobo.205.1">split</span></code><span class="koboSpan" id="kobo.206.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.207.1">psplit</span></code><span class="koboSpan" id="kobo.208.1"> method, so we are allowed to mutate its </span><code class="literal"><span class="koboSpan" id="kobo.209.1">i</span></code><span class="koboSpan" id="kobo.210.1"> field:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.211.1">  def psplit(sizes: Int*): Seq[ParStringSplitter] = { 
    val ss = for (sz &lt;- sizes) yield { 
      val nlimit = (i + sz) min limit 
      val ps = new ParStringSplitter(s, i, nlimit) 
      i = nlimit 
      ps 
    } 
    if (i == limit) ss 
    else ss :+ new ParStringSplitter(s, i, limit) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.212.1">Note that we never copy the string underlying the splitter; instead, we update the indices that mark the beginning and the end of the splitter.</span></p><p><span class="koboSpan" id="kobo.213.1">We have now completed our </span><code class="literal"><span class="koboSpan" id="kobo.214.1">ParString</span></code><span class="koboSpan" id="kobo.215.1"> class; we can use it to execute parallel operations on strings. </span><span class="koboSpan" id="kobo.215.2">We can also use it to count the number of uppercase characters in the string as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.216.1">object CustomCharCount extends App { 
  val txt = "A custom text " * 250000 
  val partxt = new ParString(txt) 
  val seqtime = warmedTimed(50) { 
    txt.foldLeft(0) { (n, c) =&gt; 
      if (Character.isUpperCase(c)) n + 1 else n 
    } 
  } 
  log(s"Sequential time - $seqtime ms") 
  val partime = warmedTimed(50) { 
    partxt.aggregate(0)( 
      (n, c) =&gt; if (Character.isUpperCase(c)) n + 1 else n, 
      _ + _) 
  } 
  log(s"Parallel time   - $partime ms") 
} 
</span></pre><p><span class="koboSpan" id="kobo.217.1">On our machine, the sequential </span><code class="literal"><span class="koboSpan" id="kobo.218.1">foldLeft</span></code><span class="koboSpan" id="kobo.219.1"> call takes 57 milliseconds, and the parallel </span><code class="literal"><span class="koboSpan" id="kobo.220.1">aggregate</span></code><span class="koboSpan" id="kobo.221.1"> call takes 19 milliseconds. </span><span class="koboSpan" id="kobo.221.2">This is a good indication that we have implemented parallel strings efficiently.</span></p></div><div class="section" title="Combiners"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/><span class="koboSpan" id="kobo.222.1">Combiners</span></h2></div></div></div><p><span class="koboSpan" id="kobo.223.1">Collection methods in the Scala standard library are divided into two major groups: </span><span class="strong"><strong><span class="koboSpan" id="kobo.224.1">accessor</span></strong></span><span class="koboSpan" id="kobo.225.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.226.1">transformer</span></strong></span><span class="koboSpan" id="kobo.227.1"> methods. </span><span class="koboSpan" id="kobo.227.2">Accessor methods, such as </span><code class="literal"><span class="koboSpan" id="kobo.228.1">foldLeft</span></code><span class="koboSpan" id="kobo.229.1">, </span><code class="literal"><span class="koboSpan" id="kobo.230.1">find</span></code><span class="koboSpan" id="kobo.231.1">, or </span><code class="literal"><span class="koboSpan" id="kobo.232.1">exists</span></code><span class="koboSpan" id="kobo.233.1">, return a single value from the collection. </span><span class="koboSpan" id="kobo.233.2">By contrast, transformer methods, such as </span><code class="literal"><span class="koboSpan" id="kobo.234.1">map</span></code><span class="koboSpan" id="kobo.235.1">, </span><code class="literal"><span class="koboSpan" id="kobo.236.1">filter</span></code><span class="koboSpan" id="kobo.237.1">, or </span><code class="literal"><span class="koboSpan" id="kobo.238.1">groupBy</span></code><span class="koboSpan" id="kobo.239.1">, create new collections and return them as results.</span></p><p><span class="koboSpan" id="kobo.240.1">To generically implement transformer operations, the Scala collection framework uses an abstraction called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.241.1">builder</span></strong></span><span class="koboSpan" id="kobo.242.1">, which has roughly the following interface:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.243.1">trait Builder[T, Repr] { // simplified interface 
  def +=(x: T): Builder[T, Repr] 
  def result: Repr 
  def clear(): Unit 
} 
</span></pre><p><span class="koboSpan" id="kobo.244.1">Here, the </span><code class="literal"><span class="koboSpan" id="kobo.245.1">Repr</span></code><span class="koboSpan" id="kobo.246.1"> type is of a collection that a specific builder can produce, and </span><code class="literal"><span class="koboSpan" id="kobo.247.1">T</span></code><span class="koboSpan" id="kobo.248.1"> is the type of its elements. </span><span class="koboSpan" id="kobo.248.2">A builder is used by repetitively calling its </span><code class="literal"><span class="koboSpan" id="kobo.249.1">+=</span></code><span class="koboSpan" id="kobo.250.1"> method to add more elements, and eventually calling the </span><code class="literal"><span class="koboSpan" id="kobo.251.1">result</span></code><span class="koboSpan" id="kobo.252.1"> method to obtain the collection. </span><span class="koboSpan" id="kobo.252.2">After the </span><code class="literal"><span class="koboSpan" id="kobo.253.1">result</span></code><span class="koboSpan" id="kobo.254.1"> method is called, the contents of the builder are undefined. </span><span class="koboSpan" id="kobo.254.2">The </span><code class="literal"><span class="koboSpan" id="kobo.255.1">clear</span></code><span class="koboSpan" id="kobo.256.1"> method can be used to reset the state of the builder.</span></p><p><span class="koboSpan" id="kobo.257.1">Every collection defines a custom builder used in various transformer operations. </span><span class="koboSpan" id="kobo.257.2">For example, the </span><code class="literal"><span class="koboSpan" id="kobo.258.1">filter</span></code><span class="koboSpan" id="kobo.259.1"> operation is defined in the </span><code class="literal"><span class="koboSpan" id="kobo.260.1">Traversable</span></code><span class="koboSpan" id="kobo.261.1"> trait, roughly as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.262.1">def newBuilder: Builder[T, Traversable[T]] 
def filter(p: T =&gt; Boolean): Traversable[T] = { 
  val b = newBuilder 
  for (x &lt;- this) if (p(x)) b += x 
  b.result 
} 
</span></pre><p><span class="koboSpan" id="kobo.263.1">In the preceding example, the </span><code class="literal"><span class="koboSpan" id="kobo.264.1">filter</span></code><span class="koboSpan" id="kobo.265.1"> implementation relies on the abstract </span><code class="literal"><span class="koboSpan" id="kobo.266.1">newBuilder</span></code><span class="koboSpan" id="kobo.267.1"> method, which is implemented in subclasses of the </span><code class="literal"><span class="koboSpan" id="kobo.268.1">Traversable</span></code><span class="koboSpan" id="kobo.269.1"> trait. </span><span class="koboSpan" id="kobo.269.2">This design allows defining all collection methods once, and only provide the </span><code class="literal"><span class="koboSpan" id="kobo.270.1">foreach</span></code><span class="koboSpan" id="kobo.271.1"> method (or the iterator) and the </span><code class="literal"><span class="koboSpan" id="kobo.272.1">newBuilder</span></code><span class="koboSpan" id="kobo.273.1"> method when declaring a new collection type.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.274.1">Combiners</span></strong></span><span class="koboSpan" id="kobo.275.1"> are a parallel counterpart of standard builders, and are represented with the </span><code class="literal"><span class="koboSpan" id="kobo.276.1">Combiner[T, Repr]</span></code><span class="koboSpan" id="kobo.277.1"> type, which subtypes the </span><code class="literal"><span class="koboSpan" id="kobo.278.1">Builder[T, Repr]</span></code><span class="koboSpan" id="kobo.279.1"> type:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.280.1">trait Combiner[T, Repr] extends Builder[T, Repr] { 
  def size: Int 
  def combine[N &lt;: T, NewRepr &gt;: Repr] 
    (that: Combiner[N, NewRepr]): Combiner[N, NewRepr] 
} 
</span></pre><p><span class="koboSpan" id="kobo.281.1">The </span><code class="literal"><span class="koboSpan" id="kobo.282.1">size</span></code><span class="koboSpan" id="kobo.283.1"> method is self-explanatory. </span><span class="koboSpan" id="kobo.283.2">The </span><code class="literal"><span class="koboSpan" id="kobo.284.1">combine</span></code><span class="koboSpan" id="kobo.285.1"> method takes another combiner called </span><code class="literal"><span class="koboSpan" id="kobo.286.1">that</span></code><span class="koboSpan" id="kobo.287.1">, and produces a third combiner that contains the elements of the </span><code class="literal"><span class="koboSpan" id="kobo.288.1">this</span></code><span class="koboSpan" id="kobo.289.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.290.1">that</span></code><span class="koboSpan" id="kobo.291.1"> combiners. </span><span class="koboSpan" id="kobo.291.2">After the </span><code class="literal"><span class="koboSpan" id="kobo.292.1">combine</span></code><span class="koboSpan" id="kobo.293.1"> method returns, the contents of both the </span><code class="literal"><span class="koboSpan" id="kobo.294.1">this</span></code><span class="koboSpan" id="kobo.295.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.296.1">that</span></code><span class="koboSpan" id="kobo.297.1"> combiners are undefined, and should not be used again. </span><span class="koboSpan" id="kobo.297.2">This constraint allows reusing the </span><code class="literal"><span class="koboSpan" id="kobo.298.1">this</span></code><span class="koboSpan" id="kobo.299.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.300.1">that</span></code><span class="koboSpan" id="kobo.301.1"> combiner object as the resulting combiner. </span><span class="koboSpan" id="kobo.301.2">Importantly, if that combiner is the same runtime object as the </span><code class="literal"><span class="koboSpan" id="kobo.302.1">this</span></code><span class="koboSpan" id="kobo.303.1"> combiner, the </span><code class="literal"><span class="koboSpan" id="kobo.304.1">combine</span></code><span class="koboSpan" id="kobo.305.1"> method should just return the </span><code class="literal"><span class="koboSpan" id="kobo.306.1">this</span></code><span class="koboSpan" id="kobo.307.1"> combiner.</span></p><p><span class="koboSpan" id="kobo.308.1">There are three ways to implement a custom combiner, as follows:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.309.1">Merging</span></strong></span><span class="koboSpan" id="kobo.310.1">: Some data structures have an efficient merge operation that can be used to implement the </span><code class="literal"><span class="koboSpan" id="kobo.311.1">combine</span></code><span class="koboSpan" id="kobo.312.1"> method.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.313.1">Two-phase evaluation</span></strong></span><span class="koboSpan" id="kobo.314.1">: Here, elements are first partially sorted into buckets that can be efficiently concatenated, and placed into the final data structure once it is allocated.</span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong><span class="koboSpan" id="kobo.315.1">Concurrent data structure</span></strong></span><span class="koboSpan" id="kobo.316.1">: The </span><code class="literal"><span class="koboSpan" id="kobo.317.1">+=</span></code><span class="koboSpan" id="kobo.318.1"> method is implemented by modifying a concurrent data structure shared between different combiners, and the </span><code class="literal"><span class="koboSpan" id="kobo.319.1">combine</span></code><span class="koboSpan" id="kobo.320.1"> method does not do anything.</span></li></ul></div><p><span class="koboSpan" id="kobo.321.1">Most data structures do not have an efficient merge operation, so we usually have to use two-phase evaluation in the combiner implementation. </span><span class="koboSpan" id="kobo.321.2">In the following example, we implement the combiners for parallel strings using two-phase evaluation. </span><span class="koboSpan" id="kobo.321.3">The </span><code class="literal"><span class="koboSpan" id="kobo.322.1">ParStringCombiner</span></code><span class="koboSpan" id="kobo.323.1"> class contains a resizable array, called </span><code class="literal"><span class="koboSpan" id="kobo.324.1">chunks</span></code><span class="koboSpan" id="kobo.325.1">, containing </span><code class="literal"><span class="koboSpan" id="kobo.326.1">StringBuilder</span></code><span class="koboSpan" id="kobo.327.1"> objects. </span><span class="koboSpan" id="kobo.327.2">Invoking the </span><code class="literal"><span class="koboSpan" id="kobo.328.1">+=</span></code><span class="koboSpan" id="kobo.329.1"> method adds a character to the rightmost </span><code class="literal"><span class="koboSpan" id="kobo.330.1">StringBuilder</span></code><span class="koboSpan" id="kobo.331.1"> object in this array:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.332.1">class ParStringCombiner extends Combiner[Char, ParString] { 
  private val chunks = new ArrayBuffer += new StringBuilder 
  private var lastc = chunks.last 
  var size = 0 
  def +=(elem: Char) = { 
    lastc += elem 
    size += 1 
    this 
  } 
</span></pre><p><span class="koboSpan" id="kobo.333.1">The </span><code class="literal"><span class="koboSpan" id="kobo.334.1">combine</span></code><span class="koboSpan" id="kobo.335.1"> method takes the </span><code class="literal"><span class="koboSpan" id="kobo.336.1">StringBuilder</span></code><span class="koboSpan" id="kobo.337.1"> objects of the </span><code class="literal"><span class="koboSpan" id="kobo.338.1">that</span></code><span class="koboSpan" id="kobo.339.1"> combiner, and adds them to the </span><code class="literal"><span class="koboSpan" id="kobo.340.1">chunks</span></code><span class="koboSpan" id="kobo.341.1"> array of the </span><code class="literal"><span class="koboSpan" id="kobo.342.1">this</span></code><span class="koboSpan" id="kobo.343.1"> combiner. </span><span class="koboSpan" id="kobo.343.2">It then returns a reference to the </span><code class="literal"><span class="koboSpan" id="kobo.344.1">this</span></code><span class="koboSpan" id="kobo.345.1"> combiner:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.346.1">  def combine[N &lt;: Char, NewRepr &gt;: ParString] 
    (that: Combiner[U, NewTo]) = { 
    if (this eq that) this else that match { 
      case that: ParStringCombiner =&gt; 
        size += that.size 
        chunks ++= that.chunks 
        lastc = chunks.last 
        this 
  } 
</span></pre><p><span class="koboSpan" id="kobo.347.1">Finally, the </span><code class="literal"><span class="koboSpan" id="kobo.348.1">result</span></code><span class="koboSpan" id="kobo.349.1"> method allocates a new </span><code class="literal"><span class="koboSpan" id="kobo.350.1">StringBuilder</span></code><span class="koboSpan" id="kobo.351.1"> object and adds the characters from all the chunks into the resulting string:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.352.1">  def result: ParString = { 
    val rsb = new StringBuilder 
    for (sb &lt;- chunks) rsb.append(sb) 
    new ParString(rsb.toString) 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.353.1">We test the performance of the parallel </span><code class="literal"><span class="koboSpan" id="kobo.354.1">filter</span></code><span class="koboSpan" id="kobo.355.1"> method with the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.356.1">val txt = "A custom txt" * 25000 
val partxt = new ParString(txt) 
val seqtime = warmedTimed(250) { txt.filter(_ != ' ') } 
val partime = warmedTimed(250) { partxt.filter(_ != ' ') } 
</span></pre><p><span class="koboSpan" id="kobo.357.1">Running this snippet on our machine takes 11 milliseconds for the sequential version, and 6 milliseconds for the parallel one.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we learned how to use parallel collections to improve program performance. </span><span class="koboSpan" id="kobo.2.2">We have seen that sequential operations on large collections can be easily parallelized and learned the difference between parallelizable and non-parallelizable collections. </span><span class="koboSpan" id="kobo.2.3">We investigated how mutability and side effects impact correctness and determinism of parallel operations and saw the importance of using associative operators for parallel operations. </span><span class="koboSpan" id="kobo.2.4">Finally, we studied how to implement our custom parallel collection class.</span></p><p><span class="koboSpan" id="kobo.3.1">We also found, however, that tuning program performance is tricky. </span><span class="koboSpan" id="kobo.3.2">Effects such as memory contention, garbage collection, and dynamic compilation may impact the performance of the program in ways that are hard to predict by looking at the source code. </span><span class="koboSpan" id="kobo.3.3">Throughout this section, we urged you to confirm suspicions and claims about program performance by experimentally validating them. </span><span class="koboSpan" id="kobo.3.4">Understanding the performance characteristics of your program is the first step toward optimizing it.</span></p><p><span class="koboSpan" id="kobo.4.1">Even when you are sure that parallel collections improve program performance, you should think twice before using them. </span><span class="koboSpan" id="kobo.4.2">Donald Knuth once coined the phrase </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">Premature optimization is the root of all evil</span></em></span><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">It is neither desirable nor necessary to use parallel collections wherever possible. </span><span class="koboSpan" id="kobo.6.3">In some cases, parallel collections give negligible or no increase in speed. </span><span class="koboSpan" id="kobo.6.4">In other situations, they could be speeding up a part of the program that is not the real bottleneck. </span><span class="koboSpan" id="kobo.6.5">Before using parallel collections, make sure to investigate which part of the program takes the most time, and whether it is worth parallelizing. </span><span class="koboSpan" id="kobo.6.6">The only practical way of doing so is by correctly measuring the running time of the parts of your application. </span><span class="koboSpan" id="kobo.6.7">In </span><a class="link" href="ch09.html" title="Chapter 9. Concurrency in Practice"><span class="koboSpan" id="kobo.7.1">Chapter 9</span></a><span class="koboSpan" id="kobo.8.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.9.1">Concurrency in Practice</span></em></span><span class="koboSpan" id="kobo.10.1">, we will introduce a framework called ScalaMeter, which offers a more robust way to measure program performance than what we saw in this chapter.</span></p><p><span class="koboSpan" id="kobo.11.1">This chapter briefly introduced concepts such as Random Access Memory, cache lines, and the MESI protocol. </span><span class="koboSpan" id="kobo.11.2">If you would like to learn more about this, you should read the article, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.12.1">What Every Programmer Should Know About Memory</span></em></span><span class="koboSpan" id="kobo.13.1">, by Ulrich Drepper. </span><span class="koboSpan" id="kobo.13.2">To gain a more in-depth knowledge about the Scala collections hierarchy, we recommend you to search for the document entitled </span><span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">The Architecture of Scala Collections</span></em></span><span class="koboSpan" id="kobo.15.1">, by Martin Odersky and Lex Spoon, or the paper </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">Fighting Bit Rot with Types</span></em></span><span class="koboSpan" id="kobo.17.1">, by Martin Odersky and Adriaan Moors. </span><span class="koboSpan" id="kobo.17.2">To understand how data-parallel frameworks work under the hood, consider reading the doctoral thesis entitled </span><span class="emphasis"><em><span class="koboSpan" id="kobo.18.1">Data Structures and Algorithms for Data-Parallel Computing in a Managed Runtime</span></em></span><span class="koboSpan" id="kobo.19.1">, by Aleksandar Prokopec.</span></p><p><span class="koboSpan" id="kobo.20.1">So far, we've assumed that all the collection elements are available when the data-parallel operation starts. </span><span class="koboSpan" id="kobo.20.2">A collection does not change its contents during the data-parallel operation. </span><span class="koboSpan" id="kobo.20.3">This makes parallel collections ideal in situations where we already have the dataset, and we want to process it in bulk. </span><span class="koboSpan" id="kobo.20.4">In other applications, data elements are not immediately available, but arrive asynchronously. </span><span class="koboSpan" id="kobo.20.5">In the next chapter, we will learn about an abstraction called an event stream, which is used when asynchronous computations produce multiple intermediate results.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the following exercises, you will use data-parallel collections in several concrete parallel collection use cases, and implement custom parallel collections. </span><span class="koboSpan" id="kobo.2.2">In all examples, a special emphasis is put on measuring the performance gains from parallelization. </span><span class="koboSpan" id="kobo.2.3">Even when it is not asked for explicitly, you should ensure that your program is not only correct but also faster than a corresponding sequential program:</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.3.1">Measure the average running time for allocating a simple object on the JVM.</span></li><li class="listitem"><span class="koboSpan" id="kobo.4.1">Count the occurrences of the whitespace character in a randomly generated string, where the probability of a whitespace at each position is determined by a </span><code class="literal"><span class="koboSpan" id="kobo.5.1">p</span></code><span class="koboSpan" id="kobo.6.1"> parameter. </span><span class="koboSpan" id="kobo.6.2">Use the parallel </span><code class="literal"><span class="koboSpan" id="kobo.7.1">foreach</span></code><span class="koboSpan" id="kobo.8.1"> method. </span><span class="koboSpan" id="kobo.8.2">Plot a graph that correlates the running time of this operation with the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">p</span></code><span class="koboSpan" id="kobo.10.1"> parameter.</span></li><li class="listitem"><span class="koboSpan" id="kobo.11.1">Implement a program that renders the Mandelbrot set in parallel.</span></li><li class="listitem"><span class="koboSpan" id="kobo.12.1">Implement a program that simulates a cellular automaton in parallel.</span></li><li class="listitem"><span class="koboSpan" id="kobo.13.1">Implement a parallel </span><span class="emphasis"><em><span class="koboSpan" id="kobo.14.1">Barnes-Hut N-body</span></em></span><span class="koboSpan" id="kobo.15.1"> simulation algorithm.</span></li><li class="listitem"><span class="koboSpan" id="kobo.16.1">Explain how you can improve the performance of the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">result</span></code><span class="koboSpan" id="kobo.18.1"> method in the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">ParStringCombiner</span></code><span class="koboSpan" id="kobo.20.1"> class, as shown in this chapter. </span><span class="koboSpan" id="kobo.20.2">Can you parallelize this method?</span></li><li class="listitem"><span class="koboSpan" id="kobo.21.1">Implement a custom splitter for the binary heap data structure.</span></li><li class="listitem"><span class="koboSpan" id="kobo.22.1">The binomial heap, described in the doctoral thesis of Chris Okasaki entitled </span><span class="emphasis"><em><span class="koboSpan" id="kobo.23.1">Purely Functional Data Structures</span></em></span><span class="koboSpan" id="kobo.24.1">, is an immutable data structure that efficiently implements a priority queue with four basic operations: insert the element, find the smallest element, remove the smallest element, and merge two binomial heaps:</span><pre class="programlisting"><span class="koboSpan" id="kobo.25.1">            class BinomialHeap[T] extends Iterable[T] { 
              def insert(x: T): BinomialHeap[T] 
              def remove: (T, BinomialHeap[T]) 
              def smallest: T 
              def merge(that: BinomialHeap[T]): BinomialHeap[T] 
            } 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.26.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">BinomialHeap</span></code><span class="koboSpan" id="kobo.28.1"> class. </span><span class="koboSpan" id="kobo.28.2">Then, implement splitters and combiners for the binomial heap, and override the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">par</span></code><span class="koboSpan" id="kobo.30.1"> operation.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.31.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">Combiner</span></code><span class="koboSpan" id="kobo.33.1"> trait for the Red-Black tree from the Scala standard library. </span><span class="koboSpan" id="kobo.33.2">Use it to provide a parallel version of the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">SortedSet</span></code><span class="koboSpan" id="kobo.35.1"> trait.</span></li><li class="listitem"><span class="koboSpan" id="kobo.36.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.37.1">parallelBalanceParentheses</span></code><span class="koboSpan" id="kobo.38.1"> method, which returns </span><code class="literal"><span class="koboSpan" id="kobo.39.1">true</span></code><span class="koboSpan" id="kobo.40.1"> if the parentheses in a string are properly balanced, or </span><code class="literal"><span class="koboSpan" id="kobo.41.1">false</span></code><span class="koboSpan" id="kobo.42.1"> otherwise. </span><span class="koboSpan" id="kobo.42.2">Parentheses are balanced if, going from left to right, the count of left parenthesis occurrences is always larger than, or equal to, the count of right parenthesis occurrences, and the total count of the left parentheses is equal to the total count of the right parentheses. </span><span class="koboSpan" id="kobo.42.3">For example, string </span><code class="literal"><span class="koboSpan" id="kobo.43.1">0(1)(2(3))4</span></code><span class="koboSpan" id="kobo.44.1"> is balanced, but strings </span><code class="literal"><span class="koboSpan" id="kobo.45.1">0)2(1(3)</span></code><span class="koboSpan" id="kobo.46.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.47.1">0((1)2</span></code><span class="koboSpan" id="kobo.48.1"> are not. </span><span class="koboSpan" id="kobo.48.2">You should use the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">aggregate</span></code><span class="koboSpan" id="kobo.50.1"> method.</span></li></ol></div></div></div></div></body></html>