<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Database Programming</h1>
                </header>
            
            <article>
                
<p>This chapter covers both basic and commonly used interactions between a Java application and a <strong>database</strong> (<strong>DB</strong>), right from connecting to the DB and performing CRUD operations to creating transactions, storing procedures, and working with <strong>large objects</strong> (<strong>LOBs</strong>). We will cover the following recipes:</p>
<ul>
<li>Connecting to a database using JDBC</li>
<li>Setting up the tables required for DB interactions</li>
<li>Performing CRUD operations</li>
<li>Using prepared statements</li>
<li>Using transactions</li>
<li>Working with large objects</li>
<li>Executing stored procedures</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>It is difficult to imagine a complex software application that does not use some kind of data storage. A structured and accessible data storage is called a database. This is why any modern language implementation includes a framework that allows you to access the DB and <strong>create, read, update, and delete</strong> (<strong>CRUD</strong>) data in it. In Java, it is the <strong>Java Database Connectivity</strong> (<strong>JDBC</strong>) API that provides access to <em>virtually any data source, from relational databases to spreadsheets and flat files</em>, according to the Javadoc. </p>
<p>The <kbd>java.sql</kbd> and <kbd>javax.sql</kbd> packages that compose the JDBC API are included in the <strong>Java Platform Standard Edition</strong> (<strong>Java SE</strong>). The <kbd>java.sql</kbd> package provides <em>the API for accessing and processing data stored in a data source (usually a relational database).</em> The <kbd>javax.sql</kbd> package provides the API for server-side data source access and processing. Specifically, it provides the <kbd>DataSource</kbd> interface for establishing a connection with a database, connection and statement pooling, distributed transactions, and rowsets. We will discuss each of these features in greater detail in the recipes of this chapter.</p>
<p>However, to actually connect <kbd>DataSource</kbd> to a physical database, one also needs a database-specific driver (provided by a database vendor, such as MySQL, Oracle, PostgreSQL, or SQL server database, to name a few). These might be written in Java or in a mixture of Java and <strong>Java Native Interface</strong> (<strong>JNI</strong>) native methods. This driver implements the JDBC API.</p>
<p>Working with a database involves eight steps:</p>
<ol>
<li>Installing the database by following the vendor instructions.</li>
<li>Adding the dependency on a <kbd>.jar</kbd> to the application with the database-specific driver.</li>
<li>Creating a user, database, and database schema: tables, views, stored procedures, and so on.</li>
<li>Connecting to the database from the application.</li>
<li>Constructing an SQL statement.</li>
<li>Executing the SQL statement.</li>
<li>Using the result of the execution.</li>
<li>Closing the database connection and other resources.</li>
</ol>
<p>Steps 1-3 are done only once at the database setup stage before the application is run.</p>
<p>Steps 4-8 are performed by the application repeatedly as needed.</p>
<p>Steps 5-7 can be repeated multiple times with the same database connection. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connecting to a database using JDBC</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, you will learn how to connect to a database.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Select the database you would like to work with. There are good commercial databases and good open source databases. The only thing we are going to assume is that the database of your choice supports <strong>Structured Query Language</strong> (<strong>SQL</strong>), which is a standardized language that allows you to perform CRUD operations on a database. In our recipes, we will use the standard SQL and avoid constructs and procedures specific to a particular database type.</li>
<li>If the database is not installed yet, follow the vendor instructions and install it. Then, download the database driver. The most popular ones are types 4 and 5, written in Java. They are very efficient and talk to the database server through a socket connection. If a <kbd>.jar</kbd> file with such a driver is placed on the classpath, it is loaded automatically. Type 4 and 5 drivers are database specific because they use database native protocol for accessing the database. We are going to assume that you are using a driver of such a type.</li>
</ol>
<p style="padding-left: 60px">If your application has to access several types of databases, then you need a driver of type 3. Such a driver can talk to different databases via a middleware application server. </p>
<p style="padding-left: 60px">Drivers of type 1 and 2 are used only when there are no other driver types available for your database.  </p>
<ol start="3">
<li><span>Set the downloaded <kbd>.jar</kbd> file with the driver on your application's classpath. </span>Now you can create a database and access it from your application.</li>
<li>Your database might have a console, a GUI, or some other way to interact with it. Read the instructions and create first a user, that is, <kbd>cook</kbd>, and then a database, namely <kbd>cookbook</kbd>.</li>
</ol>
<p style="padding-left: 60px">For example, here are the commands that do this for PostgreSQL:</p>
<pre>        CREATE USER cook SUPERUSER;<br/>        CREATE DATABASE cookbook OWNER cook;</pre>
<p style="padding-left: 60px">We selected the <kbd>SUPERUSER</kbd> role for our user; however, a good security practice is to assign such a powerful role to an administrator and create another application-specific user who can manage data but cannot change the database structure. It is good practice to create another logical layer, called schema, that can have its own set of users and permissions. This way, several schemas in the same database could be isolated, and each user (one of them is your application) will only have access to certain schemas.</p>
<ol start="5">
<li>Also, at the enterprise level, the common practice is to create synonyms for the database schema so that no application can access the original structure directly. You can also create a password for each user, but, again, for the purpose of this book, this is not needed. So we leave it to the database administrators to establish the rules and guidelines suitable to the particular working conditions of each enterprise. </li>
</ol>
<p style="padding-left: 60px">Now we connect our application to the database. In our demonstration, we will use, as you may have probably guessed by now, the open source (free) PostgreSQL database. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>Here is the code fragment that creates connection to our local PostgreSQL database:</span></p>
<pre>String URL = <span>"jdbc:postgresql://localhost/cookbook"</span><span>;<br/></span>Properties prop = <span>new </span>Properties( )<span>;<br/></span><span>//prop.put( "user", "cook" );<br/></span><span>//prop.put( "password", "secretPass123" );<br/></span><span>Connection conn = </span>DriverManager.<span>getConnection</span>(URL<span>, </span>prop)<span>;</span></pre>
<p>The commented lines show how you can set a user and password for your connection. Since, for this demo, we keep the database open and accessible to anyone, we could use an overloaded <kbd>DriverManager.getConnection(String url)</kbd> method. However, we will show the most general implementation that would allow anyone to read from a property file and pass other useful values (<kbd>ssl</kbd> as true/false, <kbd>autoReconnect</kbd> as true/false, <kbd>connectTimeout</kbd> in seconds, and so on) to the connection-creating method. Many keys for the passed-in properties are the same for all major database types, but some of them are database-specific. </p>
<p>Alternatively, for passing only a user and password, we could use the third overloaded version, namely <kbd><span>DriverManager.getConnection(String url, String user, String password)</span></kbd><span>.</span> It's worth mentioning that it is good practice to keep the password encrypted. We are not going to show how to do this, but there are plenty of guides available online.</p>
<p>Also, the <kbd>getConnection()</kbd> method throws <kbd>SQLException</kbd>, so we need to wrap it in a <kbd>try...catch</kbd> block.</p>
<p>To hide all of this and other plumbing, it is a good idea to keep the connection-establishing code inside a method:</p>
<pre><span>private static </span>Connection <span>getDbConnection</span>(){<br/>  String url = <span>"jdbc:postgresql://localhost/cookbook"</span><span>;<br/></span><span>  </span><span>try </span>{<br/>    <span>return </span>DriverManager.<span>getConnection</span>(url)<span>;<br/></span><span>  </span>}<br/>  <span>catch</span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>    return null;<br/></span><span>  </span>}<br/>}</pre>
<p class="mce-root">Another way of connecting to a database is to use the <kbd>DataSource</kbd> interface. Its implementation is typically included in the same <kbd>.jar</kbd> file as the database driver. In the case of PostgreSQL, there are two classes that implement the <kbd>DataSource</kbd> interface: <kbd>org.postgresql.ds.PGSimpleDataSource</kbd> and <kbd>org.postgresql.ds.PGPoolingDataSource</kbd>. We can use them instead of <kbd>DriverManager</kbd>. Here is an example of the usage of <kbd>PGSimpleDataSource</kbd>:   </p>
<pre><span>private static </span>Connection <span>getDbConnection</span>(){<br/>  PGSimpleDataSource source = <span>new </span>PGSimpleDataSource()<span>;<br/></span><span>  </span>source.setServerName(<span>"localhost"</span>)<span>;<br/></span><span>  </span>source.setDatabaseName(<span>"cookbook"</span>)<span>;<br/></span><span>  </span>source.setLoginTimeout(<span>10</span>)<span>;<br/></span><span>  try </span>{<br/>    <span>return </span>source.getConnection()<span>;<br/></span><span>  </span>}<br/>  <span>catch</span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>    return null;<br/></span><span>  </span>}<br/>}<br/><br/></pre>
<p>And the following is an example of the usage of <kbd>PGPoolingDataSource</kbd>:  </p>
<pre><span>private static </span>Connection <span>getDbConnection</span>(){<br/>  PGPoolingDataSource source = <span>new </span>PGPoolingDataSource()<span>;<br/></span><span>  </span>source.setServerName(<span>"localhost"</span>)<span>;<br/></span><span>  </span>source.setDatabaseName(<span>"cookbook"</span>)<span>;<br/></span><span>  </span>source.setInitialConnections(<span>3</span>)<span>;<br/></span><span>  </span>source.setMaxConnections(<span>10</span>)<span>;<br/></span><span>  </span>source.setLoginTimeout(<span>10</span>)<span>;<br/></span><span>  try </span>{<br/>    <span>return </span>source.getConnection()<span>;<br/></span><span>  </span>}<br/>  <span>catch</span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>    return null;<br/></span><span>  </span>}<br/>}</pre>
<p>The last version of the <kbd>getDbConnection()</kbd> method is usually the preferred way of connecting because it allows you to use connection pooling and some other features, in addition to those available when connecting via <kbd>DriverManager</kbd>.</p>
<p><span>Whatever version of the <kbd>getDbConnection()</kbd> implementation you choose, you'll need to use it in all the code examples the same way.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><span>It is good practice to think about closing the connection as soon as you create it. The way to do this is using the <kbd>try-with-resources</kbd> construct, which ensures that the resource is closed at the end of the <kbd>try...catch</kbd> block:</span></p>
<pre>try (Connection conn = getDbConnection()) {<br/><span>  // code that uses the connection to access the DB<br/></span>} <br/><span>catch</span>(Exception ex) { <br/>  ex.printStackTrace()<span>;<br/></span>}</pre>
<p>Such a construct can be used with any object that implements the <kbd>java.lang.AutoCloseable</kbd> or <kbd>java.io.Closeable</kbd> interface. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p><span>Refer to the following recipe in this chapter:</span></p>
<ul>
<li>Setting up the tables required for DB interactions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the tables required for DB interactions</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, you will learn how to create, change, and delete tables and other logical database constructs that compose a database schema.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>The standard SQL statement for table creation looks like this:</span></p>
<pre><span>CREATE TABLE table_name (<br/>  column1_name data_type(size),<br/>  column2_name data_type(size),<br/>  column3_name data_type(size),<br/>  ....<br/>);</span></pre>
<p><span>Here, <kbd>table_name</kbd> and <kbd>column_name</kbd> have to be alphanumeric and unique (inside the schema) identifiers. The limitations for the names and possible data types are database-specific. For example, Oracle allows the table name to have 128 characters, while in PostgreSQL, the max length of the table name and column name is 63 characters. There are differences in the data types too, so read the database documentation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>Here is an example of a command that creates the <kbd>traffic_unit</kbd> table in PostgreSQL:</span></p>
<pre>CREATE TABLE traffic_unit (<br/>  id SERIAL PRIMARY KEY,<br/>  vehicle_type VARCHAR NOT NULL,<br/>  horse_power integer NOT NULL,<br/>  weight_pounds integer NOT NULL,<br/>  payload_pounds integer NOT NULL,<br/>  passengers_count integer NOT NULL,<br/>  speed_limit_mph double precision NOT NULL,<br/>  traction double precision NOT NULL,<br/>  road_condition VARCHAR NOT NULL,<br/>  tire_condition VARCHAR NOT NULL,<br/>  temperature integer NOT NULL<br/>);</pre>
<p><span>Here, we did not set the size of the columns of the type <kbd>VARCHAR</kbd>, thus allowing those columns to store values of any length. The <kbd>integer</kbd> type, in this case, allows you to store numbers from -2147483648 to +2147483647. The <kbd>NOT NULL</kbd> type was added because, by default, the column would be nullable and we wanted to make sure that all the columns would be populated for each record.</span></p>
<p><span>We also identified the <kbd>id</kbd> column as <kbd>PRIMARY KEY</kbd>, which indicates that the column (or the combination of columns) uniquely identifies the record. For example, if there is a table that contains information about all the people of all the countries, the unique combination would <em>probably</em> be their full name, address, and date of birth. Well, it is plausible to imagine that in some household, twins are born and given the same name, so we said probably. If the chance of such an occasion is high, we would need to add another column to the primary key combination, which is the order of birth, with the default value of 1. Here is how we can do this in PostgreSQL:</span></p>
<pre>CREATE TABLE person (<br/>  name VARCHAR NOT NULL,<br/>  address VARCHAR NOT NULL,<br/>  dob date NOT NULL,<br/>  order integer DEFAULT 1 NOT NULL,<br/>  PRIMARY KEY (name,address,dob,order)<br/>);</pre>
<p><span>In the case of the <kbd>traffic_unit</kbd> table, there is no combination of columns that can serve as a primary key. Many cars have the same values. But we need to refer to a <kbd>traffic_unit</kbd> record so we could know which units have been selected and processed and which were not, for example. This is why, we added an <kbd>id</kbd> column to populate it with a unique generated number, and we would like the database to generate this primary key automatically.</span>  </p>
<p><span>If you look at the generated table description (<kbd>\d traffic_unit</kbd>), you will see</span> the <kbd><span class="s1">nextval('traffic_unit_id_seq'::regclass)</span></kbd><span> function assigned to the <kbd>id</kbd> column. This function generates numbers sequentially, starting with 1. If you need some different behavior, create the sequence number generator manually. Here's an example of how to do this:</span></p>
<pre><span>CREATE SEQUENCE traffic_unit</span>_id_seq <br/><span>START WITH </span><span>1000 </span><span>INCREMENT BY </span><span>1 <br/></span><span>NO MINVALUE </span><span>NO MAXVALUE </span><span>CACHE </span><span>10</span>; <br/><span>ALTER TABLE ONLY traffic_unit</span> <span>ALTER COLUMN id SET DEFAULT nextval</span>(<span>'traffic_unit_id_seq'</span>:<span>:regclass</span>);</pre>
<p>This sequence starts from 1,000 and caches 10 numbers for better performance in case there is a need to generate numbers in quick succession.</p>
<p>According to the code examples shared in the previous chapters, the values of <kbd>vehicle_type</kbd>, <kbd>road_condition</kbd>, and <kbd>tire_condition</kbd> are limited by the <kbd>enum</kbd> type in the code. That's why when the <kbd>traffic_unit</kbd> table is populated, we would like to make sure that only the values present in the code in <kbd>enum</kbd> types are set in the columns. To accomplish this, we'll create a lookup table called <kbd>enums</kbd> and populate it with the values from our <kbd>enum</kbd> types:</p>
<pre>CREATE TABLE enums (<br/>  id integer PRIMARY KEY,<br/>  type VARCHAR NOT NULL,<br/>  value VARCHAR NOT NULL<br/>);<br/><br/>insert into enums (id, type, value) values <br/>(1, 'vehicle', 'car'),<br/>(2, 'vehicle', 'truck'),<br/>(3, 'vehicle', 'crewcab'),<br/>(4, 'road_condition', 'dry'),<br/>(5, 'road_condition', 'wet'),<br/>(6, 'road_condition', 'snow'),<br/>(7, 'tire_condition', 'new'),<br/>(8, 'tire_condition', 'worn');</pre>
<p>PostgreSQL has an <kbd>enum</kbd> data type, but it incurs an overhead if the list of possible values is not fixed and has to be changed over time. We think it is quite possible that the list of values in our application will expand. So, we decided not to use a database <kbd>enum</kbd> type but create the lookup table ourselves.</p>
<p>Now we can refer to the values of the <kbd>enums</kbd> table from the <kbd>traffic_unit</kbd> table using their ID as a foreign key. First, we delete the table:</p>
<pre>drop table traffic_unit;</pre>
<p>Then we recreate it with a slightly different SQL command:</p>
<pre>CREATE TABLE traffic_unit (<br/>  id SERIAL PRIMARY KEY,<br/>  vehicle_type <strong>integer REFERENCES enums (id)</strong>,<br/>  horse_power integer NOT NULL,<br/>  weight_pounds integer NOT NULL,<br/>  payload_pounds integer NOT NULL,<br/>  passengers_count integer NOT NULL,<br/>  speed_limit_mph double precision NOT NULL,<br/>  traction double precision NOT NULL,<br/>  road_condition <strong>integer REFERENCES enums (id)</strong>,<br/>  tire_condition <strong>integer REFERENCES enums (id)</strong>,<br/>  temperature integer NOT NULL<br/>);</pre>
<p>The columns <kbd>vehicle_type</kbd>, <kbd>road_condition</kbd>, and <kbd>tire_condition</kbd> must now be populated by the primary key of the corresponding record of the <kbd>enums</kbd> table. This way, we can make sure that our traffic-analyzing code will be able to match the values in these columns to the values of the <kbd>enum</kbd> types in the code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The <kbd>enums</kbd> table should not have a duplicate combination of type-value because this might lead to confusion, especially when the code that populates the <kbd>traffic_unit</kbd> table looks up the necessary <kbd>id</kbd> in the <kbd>enums</kbd> table. Instead of the one value that is expected, the query will return two. Which one to pick, then? To avoid duplication, we can add a unique constraint to the <kbd>enums</kbd> table: </p>
<pre>ALTER TABLE enums ADD CONSTRAINT enums_unique_type_value <br/>UNIQUE (type, value);</pre>
<p>Now if we try to add a duplicate, the database will not allow it.</p>
<p>Another important consideration of database table creation is whether an index has to be added. An index is a data structure that helps to accelerate data searches in the table without having to check every table record. It can include one or more columns of a table. For example, an index for a primary key is created automatically. If you bring up the description of the table we have created already, you will see the following:</p>
<pre> Indexes: "traffic_unit_pkey" PRIMARY KEY, btree (id)</pre>
<p>We can also add an index ourselves if we think (and have proven by experimentation) it will help the application performance. In the case of <kbd>traffic_unit</kbd>, we discovered that our code often searches this table by <kbd>vehicle_type</kbd> and <kbd>passengers_count</kbd>. So we measured the performance of our code during the search and added these two columns to the index:</p>
<pre>CREATE INDEX idx_traffic_unit_vehicle_type_passengers_count <br/>ON traffic_unit USING btree (vehicle_type,passengers_count);</pre>
<p>Then we measured the performance again. If it had improved, we would have left the index in place, but in our case, we removed it:</p>
<pre>drop index idx_traffic_unit_vehicle_type_passengers_count;</pre>
<p>We did this because an index has an overhead of additional writes and storage space.</p>
<p><span>In our examples of primary key, constraints, and indexes, we followed the naming convention of PostgreSQL. If you use a different database, we suggest you look up its naming convention and follow it, so that your naming aligns with the names created automatically.  </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p><span>Refer to the following recipes in this chapter:</span></p>
<ul>
<li>Performing CRUD operations</li>
<li>Working with large objects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing CRUD operations</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, you will learn how to populate, read, change, and delete data in the database. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We have already seen examples of <span>SQL statements that create (populate) data in the database:</span></p>
<pre>INSERT INTO table_name (column1,column2,column3,...)<br/>VALUES (value1,value2,value3,...);</pre>
<p>We've also seen examples of instances where several table records have to be added:</p>
<pre>INSERT INTO table_name (column1,column2,column3,...)<br/>VALUES (value1,value2,value3, ... ), <br/>       (value21,value22,value23, ...), <br/>       ( ...                       );</pre>
<p>If a column has a default value specified, there is no need to list it in the <kbd>INSERT INTO</kbd> statement, unless a different value has to be inserted.</p>
<p>The reading of the data is done by a <kbd>SELECT</kbd> statement:</p>
<pre>SELECT column_name,column_name<br/>FROM table_name WHERE some_column=some_value;</pre>
<p>This is also done when all the columns have to be selected in an order:</p>
<pre>SELECT * FROM table_name WHERE some_column=some_value;</pre>
<p><span>Here's a general definition of the <kbd>WHERE</kbd> clause:</span></p>
<pre>WHERE column_name operator value<br/>Operator:<br/>  = Equal<br/>  &lt;&gt; Not equal. In some versions of SQL, !=<br/>  &gt; Greater than<br/>  &lt; Less than<br/>  &gt;= Greater than or equal<br/>  &lt;= Less than or equal<br/>  BETWEEN Between an inclusive range<br/>  LIKE Search for a pattern<br/>  IN To specify multiple possible values for a column</pre>
<p>The <kbd>column_name operator value</kbd> construct can be combined the with logical operators <kbd>AND</kbd> and <kbd>OR</kbd> and grouped with the brackets <kbd>(</kbd> and <kbd>)</kbd>.</p>
<p>The data can be changed with the <kbd>UPDATE</kbd> statement:</p>
<pre>UPDATE table_name SET column1=value1,column2=value2,... <br/>WHERE-clause;</pre>
<p>Alternatively, it can be deleted with the <kbd>DELETE</kbd> statement:</p>
<pre>DELETE FROM table_name WHERE-clause;</pre>
<p><span>Without the <kbd>WHERE</kbd> clause, all the records of the table are going to be affected by the <kbd>UPDATE</kbd> or <kbd>DELETE</kbd> statement.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We have already seen an <kbd>INSERT</kbd> statement. Here is an example of other types of statements:</p>
<div class="CDPAlignCenter CDPAlign"><img height="130" width="246" class="image-border" src="assets/1cb03683-da6c-4cf4-a5ae-16b25d85f6ab.png"/></div>
<p>The preceding <kbd>SELECT</kbd> statement requires bringing up all the columns of all the rows of the table. If the number of rows was bigger than the number of lines on the screen, the database console would show only the first screen and you would need to type a command (database-specific) to show the next screen:  </p>
<div class="CDPAlignCenter CDPAlign"><img height="80" width="510" class="image-border" src="assets/a54b682d-5a42-47ee-96a2-a8c33cce32b0.png"/></div>
<p>This <kbd>SELECT</kbd> statement has a <kbd>WHERE</kbd> clause that requires you to show only those rows where the value in the <kbd>type</kbd> column is <kbd>vehicle</kbd> and the value in the <kbd>value</kbd> column is not <kbd>crewcab</kbd>. It also requires you to show the rows where the <span>value in the</span> <kbd>value</kbd> <span>column</span> <span>is <kbd>new</kbd>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="105" width="390" class="image-border" src="assets/7bd17df9-3af0-4055-a889-889a4533fcb2.png"/></div>
<p>The preceding screenshot captures three statements. The first one is an <kbd>UPDATE</kbd> statement that requires you to change the value in the <kbd>value</kbd> column to <kbd>NEW</kbd>, but only in the rows where the value in the <kbd>value</kbd> column is <kbd>new</kbd> (apparently, the value is case-sensitive). The second statement <span>requires</span> you to delete all the rows that do not have the value <kbd>NEW</kbd> in the <kbd>value</kbd> column. The third statement is <kbd>SELECT</kbd>, which we just discussed.</p>
<p>It worth noting that we would not be able to delete the records of the <kbd>enums</kbd> table if these records were referred to as foreign keys in the <kbd>traffic_unit</kbd> table. Only after deleting the corresponding records of the <kbd>traffic_unit</kbd> table would we be able to do this. But, for now, that is, for demonstration purposes, we keep the <kbd>traffic_unit</kbd> table empty. </p>
<p>To execute any of the CRUD operations in the code, one has to acquire a JDBC connection first, then create and execute a statement:</p>
<pre><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  <span>try </span>(Statement st = conn.createStatement()) {<br/>    <span>boolean </span>res = st.execute(<span>"select id, type, value from enums"</span>)<span>;<br/></span><span>    if </span>(res) {<br/>      ResultSet rs = st.getResultSet()<span>;<br/></span><span>      while </span>(rs.next()) {<br/>        i<span>nt </span>id = rs.getInt(<span>1</span>)<span>; </span><span><br/></span><span>        </span>String type = rs.getString(<span>2</span>)<span>;<br/></span><span>        </span>String value = rs.getString(<span>3</span>)<span>;<br/></span><span>        </span>System.<span>out</span>.println(<span>"id = " </span>+ id + <span>", type = " <br/></span>                           + type + <span>", value = " </span>+ value)<span>;<br/></span><span>      </span>}<br/>    } <span>else </span>{<br/>      <span>int </span>count = st.getUpdateCount()<span>;<br/></span><span>      </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>    </span>}<br/>  }<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}</pre>
<p><span>It is good practice to use the </span><kbd>try-with-resources</kbd><span> construct for the <kbd>Statement</kbd> object too. The c</span>losing of the <kbd>Connection</kbd> object would close the <kbd>Statement</kbd> object automatically. However, when you close the <kbd>Statement</kbd> object explicitly, the cleanup happens immediately instead of waiting for the necessary checks and actions to propagate through the layers of the framework.</p>
<p>The <kbd>execute()</kbd> method is the most generic one among the three methods that can execute a statement. The other two include <kbd>executeQuery()</kbd> (for <kbd>SELECT</kbd> statements only) and <kbd>executeUpdate()</kbd> (for <kbd>UPDATE</kbd>, <kbd>DELETE</kbd>, <kbd>CREATE</kbd>, or <kbd>ALTER</kbd> statements). As you can see in our example, the <kbd>execute()</kbd> method returns <kbd>boolean</kbd>, which indicates whether the result is a <kbd>ResultSet</kbd> object or just a count. This means that <kbd>execute()</kbd> acts as <kbd>executeQuery()</kbd> for the <kbd>SELECT</kbd> statement and <kbd>executeUpdate()</kbd> for the other statements that we just listed.</p>
<p>We can demonstrate this by running the preceding code with the following sequence of statements:</p>
<pre><span>"select id, type, value from enums"<br/>"insert into enums (id, type, value)" + " values(1,'vehicle','car')"<br/>"select id, type, value from enums"<br/>"update enums set value = 'bus' where value = 'car'"<br/>"select id, type, value from enums"<br/>"delete from enums where value = 'bus'"<br/>"select id, type, value from enums"</span></pre>
<p><span>The result will be as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="158" width="291" class="image-border" src="assets/896e111f-c133-4b13-8c4d-db39aa2d0ca5.png"/></div>
<p><span>We carried out the positional extraction of the values from <kbd>ResultSet</kbd> because this is more efficient than using the column name (as in <kbd>rs.getInt("id")</kbd> or <kbd>rs.getInt("type")</kbd></span>). The difference in performance is very small, though, and becomes important only when the operation happens many times. Only the actual measuring and testing can tell you whether the difference in the case of your application is significant or not. Bear in mind that getting values by name provides better code readability, which pays well in the long term during application maintenance.</p>
<p><span>We used the <kbd>execute()</kbd> method for demonstration purposes. In practice, the <kbd>executeQuery()</kbd> method is used for <kbd>SELECT</kbd> statements because the programmer usually has to extract the data in a way specific to the executed SQL statement. By contrast, the call to <kbd>executeUpdate()</kbd> can be wrapped in a generic method:</span></p>
<pre><span>private static void </span><span>executeUpdate</span>(String sql){<span><br/></span><span>  try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>    <span>try </span>(Statement st = conn.createStatement()) {<br/>      <span>int </span>count = st.executeUpdate(sql)<span>;<br/></span><span>      </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>    </span>}<br/>  } <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>SQL is a rich language, and we do not have enough space to cover all its features. We would just like to enumerate a few of its most popular ones so you are aware of their existence and could look them up when needed: </p>
<ul>
<li>The <kbd>SELECT</kbd> statement allows the use of the <kbd>DISTINCT</kbd> keyword to get rid off all the duplicate values</li>
<li>Adding the <kbd>ORDER BY</kbd> keyword presents the result in the specified order</li>
<li>The keyword <kbd>LIKE</kbd> allows you to set the search pattern to the <kbd>WHERE</kbd> clause</li>
<li>The search pattern can use several wildcard: <kbd>%, _</kbd>, <kbd>[charlist]</kbd>, <kbd>[^charlist]</kbd>, or <kbd>[!charlist]</kbd> </li>
<li>Matching values can be enumerated with the <kbd>IN</kbd> keyword</li>
<li>The <kbd>SELECT</kbd> statement can include several tables using the <kbd>JOIN</kbd> clause</li>
<li><kbd>SELECT * INTO table_2 from table_1 creates table_2</kbd> and copies data from <kbd>table_1</kbd></li>
<li><kbd>TRUNCATE</kbd> is faster and uses fewer resources when removing all the rows of a table</li>
</ul>
<p>There are many other useful methods in the <kbd>ResultSet</kbd> interface as well. Here is an example of how some of its methods can be used to write generic code that would traverse the returned result and use metadata to print out the column name and the returned value:</p>
<pre><span>private static void </span><span>traverseRS</span>(String sql){<br/>  System.<span>out</span>.println(<span>"traverseRS(" </span>+ sql + <span>"):"</span>)<span>;<br/></span><span>  try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>    <span>try </span>(Statement st = conn.createStatement()) {<br/>      <span>try</span>(ResultSet rs = st.executeQuery(sql)){<br/>        <span>int </span>cCount = <span>0</span><span>;<br/></span><span>        </span>Map&lt;Integer<span>, </span>String&gt; cName = <span>new </span>HashMap&lt;&gt;()<span>;<br/></span><span>        while </span>(rs.next()) {<br/>          <span>if </span>(cCount == <span>0</span>) {<br/>            ResultSetMetaData rsmd = rs.getMetaData()<span>;<br/></span><span>            </span>cCount = rsmd.getColumnCount()<span>;<br/></span><span>            for </span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= cCount<span>; </span>i++) {<br/>              cName.put(i<span>, </span>rsmd.getColumnLabel(i))<span>;<br/></span><span>            </span>}<br/>          }<br/>          List&lt;String&gt; l = <span>new </span>ArrayList&lt;&gt;()<span>;<br/></span><span>          for </span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= cCount<span>; </span>i++) {<br/>            l.add(cName.get(i) + <span>" = " </span>+ rs.getString(i))<span>;<br/></span><span>          </span>}<br/>          System.<span>out</span>.println(l.stream()<br/>                              .collect(Collectors.<span>joining</span>(<span>", "</span>)))<span>;<br/></span><span>        </span>}<br/>      }<br/>    }<br/>  } <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>}</pre>
<p>We used <kbd>ResultSetMetaData</kbd> only once to collect the returned column names and the length (number of columns) of one row. Then, we extracted the values from each row by position and created <kbd>List&lt;String&gt;</kbd> elements with the corresponding column names. To print, we used something we are already familiar with--a programmer's delight--the joining collector (we discussed this in a previous chapter). If we call the <kbd>traverseRS("select * from enums")</kbd> method, the result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="24" width="313" class="image-border" src="assets/fe5810e8-6253-430d-afc4-1d8bb975532c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Using prepared statements</li>
<li>Using transactions</li>
<li>Working with large objects</li>
<li>Executing stored procedures</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using prepared statements</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, you will learn how to use a prepared statement: a statement template that can be stored in the database and executed efficiently with different input values.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>An object of <kbd>PreparedStatement</kbd>--a subinterface of <kbd>Statement</kbd>--can be precompiled and stored in the database and then used to efficiently execute the SQL statement multiple times for different input values. Similar to an object of <kbd>Statement</kbd></span> <span>(created by the <kbd>createStatement()</kbd></span> method<span>), it can be created by the <kbd>prepareStatement()</kbd> method of the same <kbd>Connection</kbd> object. </span></p>
<p><span> </span>There is also a third version of a statement that creates a method called <kbd>prepareCall()</kbd> that, in turn, creates the <kbd>CallableStatement</kbd> object used to execute a database-stored procedure, but we will discuss this in a separate recipe later.</p>
<p>The same SQL statement that was used to generate <kbd>Statement</kbd> can be used to generate <kbd>PreparedStatement</kbd> too. In fact, it is a good idea to consider using <kbd>PrepdaredStatement</kbd> for any SQL statement that is called multiple times because it performs better than <kbd>Statement</kbd>. To do this, all we need to change are these two lines in the sample code of the previous section:</p>
<pre><span>try </span>(Statement st = conn.createStatement()) {<br/>  <span>boolean </span>res = st.execute(<span>"select * from enums"</span>)<span>;<br/></span></pre>
<p>We change these lines to the following:</p>
<pre><span>try </span>(PreparedStatement st = <br/>           conn.prepareStatement(<span>"select * from enums"</span>)) {<br/>  <span>boolean </span>res = st.execute()<span>;<br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>The true usefulness of <kbd>PreparedStatement</kbd> shines because of its ability to accept parameters--the input values that substitute (in the order of appearance) the <kbd>?</kbd></span><span> symbol. Here's an example of this:</span></p>
<pre><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  String[][] values = {{<span>"1"</span><span>, </span><span>"vehicle"</span><span>, </span><span>"car"</span>}<span>,<br/></span>                       {<span>"2"</span><span>, </span><span>"vehicle"</span><span>, </span><span>"truck"</span>}}<span>;<br/>  String sql = "insert into enums (id, type, value) values(?, ?, ?)");<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql) {<br/>    <span>for</span>(String[] v: values){<br/>      st.setInt(<span>1</span><span>, </span>Integer.<span>parseInt</span>(v[<span>0</span>]))<span>;<br/></span><span>      </span>st.setString(<span>2</span><span>, </span>v[<span>1</span>])<span>;<br/></span><span>      </span>st.setString(<span>3</span><span>, </span>v[<span>2</span>])<span>;<br/></span><span>      int </span>count = st.executeUpdate()<span>;<br/></span><span>      </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>    }<br/></span>  }<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;<br/></span></pre>
<p><span>The result of this is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="102" width="337" class="image-border" src="assets/4d00bc67-c4b4-4efb-95f6-f562df470f9d.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It is not a bad idea to always use prepared statements for CRUD operations. They might be slower if executed only once, but you can test and see whether this is the price you are willing to pay. What you get with prepared statements is consistent (better readable) code, more security (prepared statements are not vulnerable to SQL injection), and one fewer decision to make (just reuse the same code everywhere).  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p><span>Refer to the following recipes in this chapter:</span></p>
<ul>
<li>Using transactions</li>
<li>Working with large objects</li>
<li>Executing stored procedures</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using transactions</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, you will learn what a database transaction is and how it can be used in Java code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>A transaction is a unit of work that includes one or many operations that change data. If successful, all the data changes are <em>committed</em> (applied to the database). If one of the operations errors out or the transaction is <em>rolled back</em>, then none of the changes included in the transaction will be applied to the database.</p>
<p>Transaction properties are set up on the <kbd>Connection</kbd> object. They can be changed without closing the connection, so different transactions can reuse the same <kbd>Connection</kbd> object.</p>
<p>JDBC allows transaction control only for CRUD operations. Table modification (<kbd>CREATE TABLE</kbd>, <kbd>ALTER TABLE</kbd>, and so on) is committed automatically and cannot be controlled from the Java code.</p>
<p>By default, a CRUD operation transaction is set to be autocommitted too. This means that every data change that was introduced by an SQL statement is applied to the database as soon as the execution of the SQL statement is completed. All the preceding examples use this default behavior.</p>
<p>To change this, one has to use the <kbd>setAutoCommit()</kbd> method of the <kbd>Connection</kbd> object. If set to false, that is, <kbd>setAutoCommit(false)</kbd>, the data changes will not be applied to the database until the <kbd>commit()</kbd> method on the <kbd>Connection</kbd> object is invoked. If the <kbd>rollback()</kbd> method is called, all the data changes since the beginning of the transaction or since the last call to <kbd>commit()</kbd> would be discarded.</p>
<p>Explicit programmatic transaction management improves performance, but it is insignificant in the case of short atomic operations that are called once and not very often. Taking over transaction control becomes crucial when several operations introduce changes that have to be applied, either all together or none of them. It allows you to group database changes into atomic units and thus avoid accidental violation of data integrity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>First, let's add an output to the <kbd>traverseRS()</kbd> method: </p>
<pre><span>private static void </span><span>traverseRS</span>(String sql){<br/>  System.<span>out</span>.println(<span>"traverseRS(" </span>+ sql + <span>"):"</span>)<span>;<br/></span><span>  try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>    ...<br/>  }<br/>}</pre>
<p>This will help you analyze the output when many different SQL statements are executed in the same demo example. </p>
<p>Now let's run the following code that reads data from the <kbd>enums</kbd> table, then inserts a row, and then reads all the data from the table again:</p>
<pre><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  conn.setAutoCommit(<span>false</span>)<span>;<br/></span><span>  </span>String sql = <span>"insert into enums (id, type, value) "<br/>                       + " values(1,'vehicle','car')"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    System.<span>out</span>.println(sql)<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = " </span>+ st.executeUpdate())<span>;<br/></span><span>  </span>}<br/>  //conn.commit();<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;<br/></span></pre>
<p>Note that we took over transaction control by calling <kbd>conn.setAutoCommit(false)</kbd>. The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="103" width="404" class="image-border" src="assets/4ba8a330-8187-4e84-abff-45aadcb2e6c0.png"/></div>
<p>As you can see, the changes were not applied because the call to <kbd>commit()</kbd> was commented out. When we uncomment it, the result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="121" width="412" class="image-border" src="assets/a4c1bbe0-12aa-4ef8-a906-6330ea3d26cf.png"/></div>
<p>Now let's execute two inserts, but introduce a spelling error in the second insert:</p>
<pre><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  conn.setAutoCommit(<span>false</span>)<span>;<br/></span><span>  </span>String sql = <span>"insert into enums (id, type, value) "<br/>                       + " values(1,'vehicle','car')"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    System.<span>out</span>.println(sql)<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = "</span> + st.executeUpdate())<span>;<br/></span><span>  </span>}<br/>  conn.commit()<span>;<br/></span><span>  </span>sql = <span>"insert into enums (id, type, value) " <br/>                     + " values(2,'vehicle','truck')"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    System.<span>out</span>.println(sql)<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = " </span>+ st.executeUpdate())<span>;<br/></span><span>  </span>}<br/>  conn.commit()<span>;<br/></span>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;</span></pre>
<p>We get a stack trace (we do not show it to save space) of the error: </p>
<pre>org.postgresql.util.PSQLException: ERROR: syntax error at or near "inst"</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="51" width="416" class="image-border" src="assets/e643bfd1-e947-42f2-9e4e-55a555146ae9.png"/></div>
<p>The second row was not inserted. If there was no <kbd>conn.commit()</kbd> after the first <kbd>INSERT INTO</kbd> statement, the first insert would not be applied either. This is the advantage of the programmatic transaction control in the case of many independent data changes: if one fails, we can skip it and continue applying other changes.</p>
<p><span>Now let's try to insert three rows with an error (by not setting a number as the <kbd>id</kbd> value) in the second row:</span></p>
<pre><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  conn.setAutoCommit(<span>false</span>)<span>;<br/></span><span>  </span>String[][] values = { {<span>"1"</span><span>, </span><span>"vehicle"</span><span>, </span><span>"car"</span>}<span>,<br/></span>                        {<span>"b"</span><span>, </span><span>"vehicle"</span><span>, </span><span>"truck"</span>}<span>,<br/></span>                        {<span>"3"</span><span>, </span><span>"vehicle"</span><span>, </span><span>"crewcab"</span>} }<span>;<br/></span><span>  </span>String sql = <span>"insert into enums (id, type, value) " <br/>                            + " values(?, ?, ?)"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    <span>for </span>(String[] v: values){<br/>      <span>try </span>{<br/>        System.<span>out</span>.print(<span>"id=" </span>+ v[<span>0</span>] + <span>": "</span>)<span>;<br/></span><span>        </span>st.setInt(<span>1</span><span>, </span>Integer.<span>parseInt</span>(v[<span>0</span>]))<span>;<br/></span><span>        </span>st.setString(<span>2</span><span>, </span>v[<span>1</span>])<span>;<br/></span><span>        </span>st.setString(<span>3</span><span>, </span>v[<span>2</span>])<span>;<br/></span><span>        int </span>count = st.executeUpdate()<span>;<br/></span><span>        </span>conn.commit()<span>;<br/></span><span>        </span>System.<span>out</span>.println(<span>"Update count = "</span>+count)<span>;<br/></span><span>      </span>} <span>catch</span>(Exception ex){<br/>        //conn.rollback();<br/>        System.<span>out</span>.println(ex.getMessage())<span>;<br/></span><span>      </span>}<br/>    }<br/>  }<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;<br/></span></pre>
<p><span>We put each insert execution in the <kbd>try...catch</kbd> block and commit the changes before printing out the result (update count or error message). The result will be as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="146" width="382" class="image-border" src="assets/e676ed35-c821-42a9-897d-555d2ce8bc79.png"/></div>
<p><span>You can see that the second row was not inserted, although <kbd>conn.rollback()</kbd> was commented out. Why? This is because the only SQL statement included in this transaction failed, so there was nothing to roll back.</span></p>
<p>Now let's create a <kbd>test</kbd> table using the database console:</p>
<div class="CDPAlignCenter CDPAlign"><img height="81" width="409" class="image-border" src="assets/1994a329-9e4c-4b24-9caf-20a81cc2a977.png"/></div>
<p><span>We will use this table to record the vehicle types of the records inserted in the <kbd>enums</kbd> table:</span></p>
<pre><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  conn.setAutoCommit(<span>false</span>)<span>;<br/></span><span>  </span>String[][] values = { {<span>"1"</span><span>, </span><span>"vehicle"</span><span>, </span><span>"car"</span>}<span>,<br/></span>                        {<span>"b"</span><span>, </span><span>"vehicle"</span><span>, </span><span>"truck"</span>}<span>,<br/></span>                        {<span>"3"</span><span>, </span><span>"vehicle"</span><span>, </span><span>"crewcab"</span>} }<span>;<br/></span><span>  </span>String sql = <span>"insert into enums (id, type, value) " +<br/>                                        " values(?, ?, ?)"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    <span>for </span>(String[] v: values){<br/>      <span>try</span>(Statement stm = conn.createStatement()) {<br/>        System.<span>out</span>.print(<span>"id=" </span>+ v[<span>0</span>] + <span>": "</span>)<span>;<br/></span><span>        </span>stm.execute(<span>"insert into test values('"</span>+ v[<span>2</span>] + <span>"')"</span>)<span>;<br/></span><span>        </span>st.setInt(<span>1</span><span>, </span>Integer.<span>parseInt</span>(v[<span>0</span>]))<span>;<br/></span><span>        </span>st.setString(<span>2</span><span>, </span>v[<span>1</span>])<span>;<br/></span><span>        </span>st.setString(<span>3</span><span>, </span>v[<span>2</span>])<span>;<br/></span><span>        int </span>count = st.executeUpdate()<span>;<br/></span><span>        </span>conn.commit()<span>;<br/></span><span>        </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>      </span>} <span>catch</span>(Exception ex){<br/>         <span>//conn.rollback();<br/></span><span>         </span>System.<span>out</span>.println(ex.getMessage())<span>;<br/></span><span>      </span>}<br/>    }<br/>  }<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from enums"</span>)<span>;</span><span><br/></span>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from test"</span>)<span>;<br/></span></pre>
<p>With <kbd>conn.rollback()</kbd> commented out, the result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="195" width="359" class="image-border" src="assets/9371aa64-1517-404f-97a7-1451f1b463e4.png"/></div>
<p>The row with <kbd>truck</kbd> was not inserted in the <kbd>enums</kbd> table but added to the <kbd>test</kbd> table, although our intent was to record all the vehicles inserted in <kbd>enums</kbd>, and only them, in the <kbd>test</kbd> table. This is when the usefulness of a rollback can be demonstrated. If we uncomment <kbd>conn.rollback()</kbd>, the result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="189" width="369" class="image-border" src="assets/1bdc5cde-04b9-4eb2-9bbe-605b8c28f165.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Another important property of a transaction is the <em>transaction isolation level</em>. It defines the boundaries between database users. For example, can other users see your database changes before they are committed? The higher the isolation (the highest is <em>serializable</em>), the more the time it takes a transaction to complete in the case of concurrent access to the same records. The less restrictive the isolation (the least restrictive is <em>read uncommitted</em>), the dirtier the data; this is because other users can get the values you are not going to commit eventually.</p>
<p>Usually, it is enough to use the default level, which (although it may be different for different databases) is typically <kbd>TRANSACTION_READ_COMMITTED</kbd>. JDBC allows you to get the current transaction isolation level using the <kbd>Connection</kbd> method called <kbd>getTransactionIsolation()</kbd>, while the <kbd>setTransactionIsolation()</kbd> method allows you to set any other level as needed.</p>
<p><span>In the case of complex decision-making logic about which changes need to be committed and which need to be rolled back, one can use</span> two <kbd>Connection</kbd> methods to create and delete <em>savepoints</em>. The <kbd>setSavepoint(String savepointName)</kbd> method creates a new savepoint and returns a <kbd>Savepoint</kbd> object, which can later be used to roll back all the changes up to this point using the <kbd><span>rollback (Savepoint savepoint)</span></kbd> method. A savepoint can be deleted by calling <kbd>releaseSavepoint(Savepoint savepoint)</kbd>.</p>
<p>The most complex type of database transactions is <em>distributed transactions</em>. They are sometimes called <em>global transactions</em>, <em>XA transactions</em>, or <em>JTA transactions</em> (the latter is a Java API that consists of two Java packages, namely <kbd>javax.transaction</kbd> and <kbd>javax.transaction.xa</kbd>). They allow you to create and execute a transaction that spans operations across two different databases. Providing a detailed overview of distributed transactions is outside the scope of this book. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with large objects</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, you will learn how to store and retrieve a LOB that can be one of the three types: <strong>Binary Large Object</strong> (<strong>BLOB</strong>), <strong>Character Large Object</strong> (<strong>CLOB</strong>), and <strong>National Character Large Object</strong> (<strong>NCLOB</strong>). </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The actual processing of LOB objects inside a database is vendor-specific, but JDBC APIs hide these implementation details from the application by representing the three LOB types as interfaces: <kbd>java.sql.Blob</kbd>, <kbd>java.sql.Clob</kbd>, and <kbd>java.sql.NClob</kbd>.</p>
<p><kbd>Blob</kbd> is usually used to store images or other non-alphanumeric data. On the way to the database, an image can be converted into a stream of bytes and stored using the <kbd>INSERT INTO</kbd> statement. The <kbd>Blob</kbd> interface allows you to find the length of the object and convert it into an array of bytes that can be processed by Java for the purpose of displaying the image, for example.  </p>
<p><kbd>Clob</kbd> allows you to store character data. <span><kbd>NClob</kbd> </span>stores Unicode character data as a way to support internationalization. It extends the <kbd>Clob</kbd> interface and provides the same methods. Both interfaces allow you to find the length of LOB and a substring inside the value. </p>
<p><span>The methods in the</span> <kbd>ResultSet</kbd><span>,</span> <kbd>CallableStatement</kbd> <span>(we will discuss this in the next recipe) and</span> <kbd>PreparedStatement</kbd> <span>interfaces</span> <span>allow an application to store and access the stored value in a variety of ways: some of them via setters and getters of the corresponding objects, while others as <kbd>bytes[]</kbd>, or as a binary, character, or ASCII stream.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Each database has its specific way of storing a LOB. In the case of PostgreSQL, <kbd>Blob</kbd> is usually mapped to the <kbd>OID</kbd> or <kbd>BYTEA</kbd> data type, while <kbd>Clob</kbd> and <kbd>NClob</kbd> are mapped to the <kbd>TEXT</kbd> type. So let's write a new method that will allow us to create tables programmatically:</p>
<pre><span>private static void </span><span>execute</span>(String sql){<br/>  <span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>    <span>try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>      st.execute()<span>;<br/></span><span>    </span>}<br/>  } <span>catch </span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>This differs from <kbd>executeUpdate()</kbd>, as it calls the <kbd>execute()</kbd> method of <kbd>PreparedStatement</kbd> instead of <kbd>executeUpdate()</kbd>. In principle, we can use <kbd>execute()</kbd> instead of <kbd>executeUpdate()</kbd> everywhere, but in our implementation of <kbd>executeUpdate()</kbd>, we expect a return value (<kbd>count</kbd>), which is not returned in the case of creating a table; therefore, we wrote this new method. Now we can create three tables:</p>
<pre><span>execute</span>(<span>"create table images (id integer, image bytea)"</span>)<span>;<br/></span><span>execute</span>(<span>"create table lobs (id integer, lob oid)"</span>)<span>;<br/></span><span>execute</span>(<span>"create table texts (id integer, text text)"</span>)<span>;</span></pre>
<p>Look at the JDBC interfaces <kbd>PreparedStatement</kbd> and <kbd>ResultSet</kbd> and you'll notice the setters and getters for the objects--<kbd>get/setBlob()</kbd>, <kbd>get/setClob()</kbd>, <kbd>get/setNClob()</kbd>, <kbd>get/setBytes()</kbd>-- in memory and<span> the methods that</span><span> use <kbd>InputStream</kbd> and <kbd>Reader</kbd> (</span><kbd>get/setBinaryStream()</kbd><span>,</span> <kbd>get/setAsciiStream()</kbd><span>, or </span><kbd>get/setCharacterStream()</kbd><span>). The big advantage of streaming methods is that they move data between the database and source without storing the whole LOB in memory.</span></p>
<p>However, the object's setters and getters are closer to our heart as they are used to object-oriented coding. So we will start with them, using not too big objects, for demo purposes. We expect the code to work just fine:</p>
<pre><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  String sql =<span> "insert into images (id, image) values(?, ?)"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    </span>File file = <span>new </span>File(<span>"src/com/packt/cookbook/ch06_db/image1.png"</span>)<span>;<br/></span><span>    </span>FileInputStream fis = <span>new </span>FileInputStream(file)<span>;<br/></span><span>    </span>Blob blob = conn.createBlob()<span>;   </span><span><br/></span><span>    </span>OutputStream out = blob.setBinaryStream(<span>1</span>)<span>;<br/></span><span>    int </span>i = -<span>1</span><span>;<br/></span><span>    while </span>((i = fis.read()) != -<span>1</span>) {<br/>      out.write(i)<span>;<br/></span><span>    </span>}<br/>    st.setBlob(<span>2</span><span>, </span>blob)<span>;<br/></span><span>    int </span>count = st.executeUpdate()<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>  </span>}<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}</pre>
<p>Alternatively, in the case of <kbd>Clob</kbd>, we write this code:</p>
<pre><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  String sql = <span>"insert into texts (id, text) values(?, ?)"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    </span>File file = <span>new </span>File(<span>"src/com/packt/cookbook/ch06_db/"<br/>                         + "Chapter06Database.java"</span>)<span>;</span><span><br/></span><span>    </span>Reader reader = <span>new </span>FileReader(file)<span>;<br/></span><span>    </span><span>st.setClob(2, reader);  <br/></span><span>    </span><span>int </span>count = st.executeUpdate()<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>  </span>}<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}</pre>
<p>It turns out not all methods available in the JDBC API are actually implemented by the drivers of all the databases. For example, <kbd>createBlob()</kbd> seems to work just fine for Oracle and MySQL, but in the case of PostgreSQL, we get this: </p>
<div class="CDPAlignCenter CDPAlign"><img height="47" width="658" class="image-border" src="assets/4a788ba8-abc4-4087-9122-96078f015058.png"/></div>
<p><span>For the <kbd>Clob</kbd> example, we get this:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="57" width="727" class="image-border" src="assets/746fbbc3-9a6c-4143-9725-2432107c32c1.png"/></div>
<p>We can try to retrieve an object from <kbd>ResultSet</kbd> via the getter as well:</p>
<pre><span>String sql = "select image from images";<br/>try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>  st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>  try</span>(ResultSet rs = st.executeQuery()){<br/>    <span>while </span>(rs.next()){<br/>      <span>Blob blob = rs.getBlob(1); </span><span><br/></span><span>      </span>System.<span>out</span>.println(<span>"blob length = " </span>+ blob.length())<span>;<br/></span><span>    </span>}<br/>  }<br/>}</pre>
<p>The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="50" width="497" class="image-border" src="assets/290d67e0-091a-426e-bc12-9a15b1a9aafe.png"/></div>
<p>Apparently, knowing the JDBC API is not enough; one has to read the documentation for the database too. Here is what the documentation for PostgreSQL (<a href="https://jdbc.postgresql.org/documentation/80/binary-data.html">https://jdbc.postgresql.org/documentation/80/binary-data.html</a>) has to say about LOB handling:</p>
<div class="packt_quote">To use the BYTEA data type you should simply use the getBytes(), setBytes(), getBinaryStream(), or setBinaryStream() methods.<br/>
To use the Large Object functionality you can use either the LargeObject class provided by the PostgreSQL JDBC driver, or by using the getBLOB() and setBLOB() methods.</div>
<p><br/>
Also, <em>you must access Large Objects within an SQL transaction block. You can start a transaction block by calling setAutoCommit(false)</em>.</p>
<p>Without knowing such specifics, figuring out a way to handle LOBs would require a lot of time and cause much frustration.     </p>
<p>When dealing with LOBs, we will use the streaming methods first <span>because streaming directly from the source into the database or the other way around does not consume memory as much as the setters and getters do (which have to load LOB in memory first). Here is the code that streams <kbd>Blob</kbd> in/from PostgreSQL: </span></p>
<pre><span>traverseRS</span>(<span>"select * from images"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  String sql = <span>"insert into images (id, image) values(?, ?)"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    </span>File file = <span>new </span>File(<span>"src/com/packt/cookbook/ch06_db/image1.png"</span>)<span>;<br/></span><span>    </span>FileInputStream fis = <span>new </span>FileInputStream(file)<span>;<br/></span><span>    </span>st.setBinaryStream(<span>2</span><span>, </span>fis)<span>;<br/></span><span>    int </span>count = st.executeUpdate()<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>  </span>}<br/>  sql = <span>"select image from images where id = ?"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    try</span>(ResultSet rs = st.executeQuery()){<br/>      <span>while </span>(rs.next()){<br/>        <span>try</span>(InputStream is = rs.getBinaryStream(<span>1</span>)){<br/><span>          int i;<br/>          System.out.print("ints = ");<br/>          while ((i = is.read()) != -1) {<br/>            System.out.print(i);<br/>          }<br/>        </span>}<br/>      }<br/>    }<br/>  }<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from images"</span>)<span>;<br/></span></pre>
<p>This will be your result. We have cut the screenshot arbitrarily on the right-hand side; otherwise, it is very long horizontally:</p>
<div class="CDPAlignCenter CDPAlign"><img height="105" width="559" class="image-border" src="assets/7340788e-cfe4-47d5-addf-012aebd12d91.png"/></div>
<p>Another way to process the retrieved image is to use <kbd>byte[]</kbd>:</p>
<pre><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  String sql = <span> "insert into images (id, image) values(?, ?)"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    </span>File file = <span>new </span>File(<span>"src/com/packt/cookbook/ch06_db/image1.png"</span>)<span>;<br/></span><span>    </span>FileInputStream fis = <span>new </span>FileInputStream(file)<span>;<br/></span><span>    byte</span>[] bytes = fis.readAllBytes()<span>;<br/></span><span>    </span>st.setBytes(<span>2</span><span>, </span>bytes)<span>;<br/></span><span>    int </span>count = st.executeUpdate()<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>  </span>}<br/>  sql = <span>"select image from images where id = ?"</span><span>;<br/></span><span>  </span>System.<span>out</span>.println()<span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    try</span>(ResultSet rs = st.executeQuery()){<br/>      <span>while </span>(rs.next()){<br/>        <span>byte</span>[] bytes = rs.getBytes(<span>1</span>)<span>;<br/></span><span>        </span>System.<span>out</span>.println(<span>"bytes = " </span>+ bytes)<span>;<br/></span><span>      </span>}<br/>    }<br/>  }<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<span><br/></span></pre>
<p>PostgreSQL limits the BYTEA size to 1 GB. Larger binary objects can be stored as the <strong>object identifier</strong> (<strong>OID</strong>) data type:</p>
<pre><span>traverseRS</span>(<span>"select * from lobs"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  conn.setAutoCommit(<span>false</span>)<span>;<br/></span><span>  </span>LargeObjectManager lobm = <br/>        conn.unwrap(org.postgresql.PGConnection.<span>class</span>)<br/>            .getLargeObjectAPI()<span>;<br/></span><span>  long </span>lob = lobm.createLO(LargeObjectManager.<span>READ <br/></span>                           | LargeObjectManager.<span>WRITE</span>)<span>;<br/></span><span>  </span>LargeObject obj = lobm.open(lob<span>, </span>LargeObjectManager.<span>WRITE</span>)<span>;<br/></span><span>  </span>File file = <span>new </span>File(<span>"src/com/packt/cookbook/ch06_db/image1.png"</span>)<span>;<br/></span><span>  try </span>(FileInputStream fis = <span>new </span>FileInputStream(file)){<br/>    <span>int </span>size = <span>2048</span><span>;<br/></span><span>    byte</span>[] bytes = <span>new byte</span>[size]<span>;<br/></span><span>    int </span>len = <span>0</span><span>;<br/></span><span>    while </span>((len = fis.read(bytes<span>, </span><span>0</span><span>, </span>size)) &gt; <span>0</span>) {<br/>      obj.write(bytes<span>, </span><span>0</span><span>, </span>len)<span>;<br/></span><span>    </span>}<br/>    obj.close()<span>;<br/></span><span>    </span>String sql = <span>"insert into lobs (id, lob) values(?, ?)"</span><span>;<br/></span><span>    try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>      st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>      </span>st.setLong(<span>2</span><span>, </span>lob)<span>;<br/></span><span>      </span>st.executeUpdate()<span>;<br/></span><span>    </span>}<br/>  }<br/>    conn.commit()<span>;<br/></span>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from lobs"</span>)<span>;<br/></span></pre>
<p>The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="72" width="357" class="image-border" src="assets/31ad56e0-7cf0-4fe1-9754-b26c947d6084.png"/></div>
<p>Note that the <kbd>select</kbd> statement returns a long value from the <kbd>lob</kbd> column. This is because the <kbd>OID</kbd> column does not store the value itself like BYTEA does. Instead, it stores the reference to the object that is stored somewhere else in the database. Such an arrangement makes deleting the row with the OID type not as straightforward as this: </p>
<pre><span>execute</span>(<span>"delete from lobs where id = 100"</span>)<span>; </span><span><br/></span></pre>
<p>If one does just that, it leaves the actual object an orphan that continues to consume disk space, but, that is not referred to by any of the application tables. To avoid this problem, one has to <kbd>unlink</kbd> the LOB first by executing the following command:</p>
<pre><span>execute</span>(<span>"select lo_unlink((select lob from lobs " + " where id=100))"</span>)<span>;<br/></span></pre>
<p>Only after this can you safely execute the <kbd>delete from lobs where id = 100</kbd> command.</p>
<p>If you forget to <kbd>unlink</kbd> first, or if you create an orphan LOB accidentally (because of an error in the code or something), there is a way to find orphans in system tables. Again, database documentation should provide you with instructions on how to do this. In the case of PostgreSQL v.9.3 or later, you can check whether you have an orphan LOB by executing the <kbd>select count(*) from pg_largeobject</kbd> command. If it returns a count that is bigger than 0, then you can delete all the orphans with the following join (assuming that the <kbd>lobs</kbd> table is the only one that can refer to a LOB):</p>
<pre>SELECT lo_unlink(pgl.oid) FROM pg_largeobject_metadata pgl<br/>WHERE (NOT EXISTS (SELECT 1 FROM lobs ls" + "WHERE ls.lob = pgl.oid));</pre>
<p>This is an overhead, though--the price one has to pay for storing a LOB in a database. It's worth noticing that although BYTEA does not require such complexity during the delete operation, it has a different kind of overhead. According to the PostgreSQL documentation, when close to 1 GB, <em>it would require a huge amount of memory to process such a large value.</em>   </p>
<p>To read LOB data, one can use the following code:</p>
<pre><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  conn.setAutoCommit(<span>false</span>)<span>;<br/></span><span>  </span>LargeObjectManager lobm =      <br/>          conn.unwrap(org.postgresql.PGConnection.<span>class</span>)<br/>              .getLargeObjectAPI()<span>;<br/></span><span>  </span>String sql = <span>"select lob from lobs where id = ?"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    try</span>(ResultSet rs = st.executeQuery()){<br/>      <span>while </span>(rs.next()){<br/>        long lob = rs.getLong(<span>1</span>)<span>;<br/></span><span>        LargeObject </span>obj = lobm.open(lob<span>, </span>LargeObjectManager.<span>READ</span>)<span>;<br/></span><span>        byte</span>[] bytes = <span>new byte</span>[obj.size()]<span>;<br/></span><span>        </span>obj.read(bytes<span>, </span><span>0</span><span>, </span>obj.size())<span>;<br/></span><span>        </span>System.<span>out</span>.println(<span>"bytes = " </span>+ bytes)<span>;<br/></span><span>        </span>obj.close()<span>;<br/></span><span>      </span>}<br/>    }<br/>  }<br/>  conn.commit()<span>;<br/></span>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<span><br/></span></pre>
<p>Alternatively, one can also use an even simpler version by getting <kbd>Blob</kbd> directly from the <kbd>ResultSet</kbd> object if the LOB is not too big:</p>
<pre><span>while </span>(rs.next()){<br/>  Blob blob = rs.getBlob(<span>1</span>)<span>;<br/></span><span>  byte</span>[] bytes = blob.getBytes(<span>1</span><span>, </span>(<span>int</span>)blob.length())<span>;<br/></span><span>  </span>System.<span>out</span>.println(<span>"bytes = " </span>+ bytes)<span>;<br/>}</span></pre>
<p>To store <kbd>Clob</kbd> in PostgreSQL, one can use the same code as the preceding one. While reading from the database, one can convert bytes into a <kbd>String</kbd> data type or something similar (again, if the LOB is not too big):</p>
<pre>String str = <span>new </span>String(bytes<span>, </span>Charset.<span>forName</span>(<span>"UTF-8"</span>))<span>;<br/></span>System.<span>out</span>.println(<span>"bytes = " </span>+ str)<span>;<br/></span></pre>
<p>However, <kbd>Clob</kbd> in PostgreSQL can be stored directly as data type <kbd>TEXT</kbd> that is unlimited in size. This code<span> reads the file where this code is written and stores/retrieves it in/from the database</span>:</p>
<pre><span>traverseRS</span>(<span>"select * from texts"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  String sql = <span>"insert into texts (id, text) values(?, ?)"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    </span>File file = <span>new </span>File(<span>"src/com/packt/cookbook/ch06_db/"<br/>                         + "Chapter06Database.java"</span>)<span>;<br/></span><span>    try </span>(FileInputStream fis = <span>new </span>FileInputStream(file)) {<br/>      <span>byte</span>[] bytes = fis.readAllBytes()<span>;<br/></span>      st.setString(<span>2</span><span>, new </span>String(bytes<span>, </span>Charset.<span>forName</span>(<span>"UTF-8"</span>)))<span>;<br/></span><span>    </span>}<br/><span>    </span><span>int </span>count = st.executeUpdate()<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>  </span>}<br/>  sql = <span>"select text from texts where id = ?"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    try</span>(ResultSet rs = st.executeQuery()){<br/>      <span>while </span>(rs.next()) {<br/>        String str = rs.getString(<span>1</span>)<span>;<br/></span><span>        </span>System.<span>out</span>.println(str)<span>;<br/></span><span>      </span>}<br/>    }<br/>  }<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}</pre>
<p>The result will be as follows (<span>we have shown only the first few lines of the output)</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="108" width="430" class="image-border" src="assets/18e521c3-38de-4b3b-8724-816367d8e052.png"/></div>
<p>For bigger objects, streaming methods would be a better (if not the only) choice:</p>
<pre><span>traverseRS</span>(<span>"select * from texts"</span>)<span>;<br/></span>System.<span>out</span>.println()<span>;<br/></span><span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>  String sql = <span>"insert into texts (id, text) values(?, ?)"</span><span>;<br/></span><span>  try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>    st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>    </span>File file = <span>new </span>File(<span>"src/com/packt/cookbook/ch06_db/"<br/>                         + "Chapter06Database.java"</span>)<span>;<br/></span><span>    //This is not implemented:<br/>    //st.setCharacterStream(2, reader, file.length()); <br/></span><span>    </span>st.setCharacterStream(<span>2</span><span>, </span>reader<span>, </span>(<span>int</span>)file.length())<span>;<br/></span><span><br/></span><span>    int </span>count = st.executeUpdate()<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"Update count = " </span>+ count)<span>;<br/></span><span>  </span>}<br/>} <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>System.<span>out</span>.println()<span>;<br/></span><span>traverseRS</span>(<span>"select * from texts"</span>)<span>;</span></pre>
<p>Note that <kbd>setCharacterStream(int, Reader, long)</kbd> is not implemented, while <span><kbd>setCharacterStream(int, Reader, int)</kbd> works just fine. </span></p>
<p><span>We can also read the file from the <kbd>texts</kbd> table as a character stream and limit it to the first 160 characters:</span></p>
<pre>String sql = <span>"select text from texts where id = ?"</span><span>;<br/></span><span>try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>  st.setInt(<span>1</span><span>, </span><span>100</span>)<span>;<br/></span><span>  try</span>(ResultSet rs = st.executeQuery()){<br/>    <span>while </span>(rs.next()) {<br/>      <span>try</span>(Reader reader = rs.getCharacterStream(<span>1</span>)) {<br/>        <span>char</span>[] chars = <span>new char</span>[<span>160</span>]<span>;<br/></span><span>        </span>reader.read(chars)<span>;<br/></span><span>        </span>System.<span>out</span>.println(chars)<span>;<br/></span><span>      </span>}<br/>    }<br/>  }<br/>}</pre>
<p>The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="92" width="352" class="image-border" src="assets/4d8e1598-e94c-4dbf-b7b7-c347448de32c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Here is another recommendation from the PostgreSQL documentation (you can access it at <a href="https://jdbc.postgresql.org/documentation/80/binary-data.html">https://jdbc.postgresql.org/documentation/80/binary-data.html</a>):</p>
<div class="packt_quote">The BYTEA data type is not well suited for storing very large amounts of binary data. While a column of type BYTEA can hold up to 1 GB of binary data, it would require a huge amount of memory to process such a large value.<br/>
The Large Object method for storing binary data is better suited to storing very large values, but it has its own limitations. Specifically deleting a row that contains a Large Object reference does not delete the Large Object. Deleting the Large Object is a separate operation that needs to be performed. Large Objects also have some security issues since anyone connected to the database can view and/or modify any Large Object, even if they don't have permissions to view/update the row containing the Large Object reference.</div>
<p>While deciding to store LOBs in a database, one has to remember that the bigger the database, the more difficult it is to maintain it. The speed of access--the main advantage of choosing a database as a storage facility--also slows down, and it is not possible to create indices for LOB types to improve the search. Also, one cannot use LOB columns in a <kbd>WHERE</kbd> clause, except for a few CLOB cases, or use LOB columns in <span>multiple rows of <kbd>INSERT</kbd> or <kbd>UPDATE</kbd> statements.</span></p>
<p>So, before thinking about a database for a LOB, one should always consider whether storing the name of a file, keywords, and some other content properties in the database would be enough for the solution.    </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing stored procedures</h1>
                </header>
            
            <article>
                
<p><span>In this recipe, you will learn how to execute a database-stored procedure from a Java program.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p><span>Once in a while, a real-life Java programmer encounters the need to manipulate and/or select data in/from several tables and comes up with a set of complex SQL statements. In one scenario, a database administrator looks at the suggested procedure and improves and optimizes it so much that it becomes impossible or at least impractical to implement it in Java. This is when the developed set of SQL statements can be wrapped into a stored procedure that is compiled and stored in the database and then invoked via the JDBC interface. Or, in another twist of fate, a Java programmer might encounter the need for incorporating a call to an existing stored procedure into the program. To accomplish this, the interface <kbd>CallableStatement</kbd> (which extends interface <kbd>PreparedStatement</kbd>) can be used, although some databases allow you to call a stored procedure using either interface <kbd>Statement</kbd> or <kbd>PreparedStatement</kbd>.  </span></p>
<p><span><kbd>CallableStatement</kbd> can have parameters of three types</span>: <span><kbd>IN</kbd> for an input value</span><span>, <kbd>OUT</kbd> for the result, and <kbd>IN OUT</kbd> for either an input or an output value. <kbd>OUT</kbd> parameters must be registered by the <kbd>registerOutParameter()</kbd> method of <kbd>CallableStatement</kbd>. IN parameters are set the same way as the parameters of <kbd>PreparedStatement</kbd>.   </span></p>
<p>Bear in mind that executing a stored procedure from Java programmatically is one of the least standardized areas. PostgreSQL, for example, does not support stored procedures directly, but they can be invoked as functions, which have been modified for this purpose by interpreting <kbd>OUT</kbd> parameters as return values. Oracle, on the other hand, allows <kbd>OUT</kbd> parameters for functions too. </p>
<p><span>This is why the following difference between database functions and stored procedures can serve only as a general guideline, not as a formal definition:</span></p>
<ul>
<li>A function has a return value, but it does not allow <kbd>OUT</kbd> parameters (except for some databases) and can be used in an SQL statement.</li>
<li>A stored procedure does not have a return value (except for some databases); it allows <kbd>OUT</kbd> parameters (for most databases) and can be executed using the JDBC interface <kbd>CallableStatement</kbd><span>.</span></li>
</ul>
<p>This is why reading the database documentation in order to learn how to execute a stored procedure is as important as, say, handling LOBs, discussed in the previous recipe.</p>
<p>Because<span> stored procedures are compiled and stored in the database server, the <kbd>execute()</kbd> method of <kbd>CallableStatement</kbd> performs better for the same SQL statement than the corresponding method of <kbd>Statement</kbd> or <kbd>PreparedStatement</kbd>. This is one of the reasons a lot of Java code is sometimes replaced by one or several stored procedures that include even the business logic. Another reason for such a decision is that one can implement the solution the way one is most familiar with. So, there is no right answer for all cases and situations, and we will refrain from making specific recommendations, except to repeat the familiar mantra about the value of testing and the clarity of the code you are writing.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>As in the previous recipe, we will continue using the PostgreSQL database for demonstration purposes. Before writing custom SQL statements, functions, and stored procedures, one should look at the list of already existing functions first. Usually, they provide a wealth of functionality.</p>
<p>Here is an example of calling the <kbd>replace(string text, from text, to text)</kbd> function that finds all the <kbd>from text </kbd> substrings in <kbd>string text</kbd> and replaces them with <kbd>to text</kbd>:</p>
<pre>String sql = <span>"{ ? = call replace(?, ?, ? ) }"</span><span>;<br/></span><span>try </span>(CallableStatement st = conn.prepareCall(sql)) {<br/>  st.registerOutParameter(<span>1</span><span>, </span>Types.<span>VARCHAR</span>)<span>;<br/></span><span>  </span>st.setString(<span>2</span><span>, </span><span>"Hello, World! Hello!"</span>)<span>;<br/></span><span>  </span>st.setString(<span>3</span><span>, </span><span>"llo"</span>)<span>;<br/></span><span>  </span>st.setString(<span>4</span><span>, </span><span>"y"</span>)<span>;<br/></span><span>  </span>st.execute()<span>;<br/></span><span>  </span>String res = st.getString(<span>1</span>)<span>;<br/></span><span>  </span>System.<span>out</span>.println(res)<span>;<br/></span>}</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="30" width="317" class="image-border" src="assets/8e199295-8014-439c-a39b-e4bf4849f5e0.png"/></div>
<p>We will incorporate this function into our custom functions and stored procedures in order to show how it can be done.</p>
<p>A stored procedure can be without any parameters at all, with <kbd>IN</kbd> parameters only, with <kbd>OUT</kbd> parameters only, or with both. The result may be one or multiple values, or a <kbd>ResultSet</kbd> object. Here is an example of creating a stored procedure without any parameters in PostgreSQL:</p>
<pre><span>execute</span>(<span>"create or replace function createTableTexts() " <br/>        + " returns void as " <br/>        + "$$ </span><span>drop table if exists texts; "</span><br/>        + "  <span>create table texts (id integer, text text); "</span><br/>        + <span>"$$ language sql"</span>)<span>;<br/></span></pre>
<p>We use a method we are already familiar with:</p>
<pre><span>private static void </span><span>execute</span>(String sql){<br/>  <span>try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>    <span>try </span>(PreparedStatement st = conn.prepareStatement(sql)) {<br/>      st.execute()<span>;<br/></span><span>    </span>}<br/>  } <span>catch </span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>This stored procedure (it is always a function in PostgreSQL) creates a <kbd>texts</kbd> table (drops this if the table exists already). You can find the syntax of the SQL for function creation in the database documentation. The only thing we would like to comment here is that instead of the symbol <kbd>$$</kbd> that denotes the function body, you can use single quotes. We prefer <kbd>$$</kbd> because it helps avoid the escaping of single quotes in case we need to include them in the function body. </p>
<p>This procedure can be invoked by <kbd>CallableStatement</kbd>:</p>
<pre>String sql = <span>"{ call createTableTexts() }"</span><span>;<br/></span><span>try </span>(CallableStatement st = conn.prepareCall(sql)) {<br/>  st.execute()<span>;<br/></span>}</pre>
<p>Alternatively, it can be invoked with the SQL statement <kbd>select createTableTexts()</kbd> or <kbd>select * from createTableTexts()</kbd>. Both statements return a <kbd>ResultSet</kbd> object (which is <kbd>null</kbd> in the case of the <kbd>createTableTexts()</kbd> function), so we can traverse it by our method:</p>
<pre><span>private static void </span><span>traverseRS</span>(String sql){<br/>  System.<span>out</span>.println(<span>"traverseRS(" </span>+ sql + <span>"):"</span>)<span>;<br/></span><span>  try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>    <span>try </span>(Statement st = conn.createStatement()) {<br/>      <span>try</span>(ResultSet rs = st.executeQuery(sql)){<br/>        <span>int </span>cCount = <span>0</span><span>;<br/></span><span>        </span>Map&lt;Integer<span>, </span>String&gt; cName = <span>new </span>HashMap&lt;&gt;()<span>;<br/></span><span>        while </span>(rs.next()) {<br/>          <span>if </span>(cCount == <span>0</span>) {<br/>            ResultSetMetaData rsmd = rs.getMetaData()<span>;<br/></span><span>            </span>cCount = rsmd.getColumnCount()<span>;<br/></span><span>            for </span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= cCount<span>; </span>i++) {<br/>              cName.put(i<span>, </span>rsmd.getColumnLabel(i))<span>;<br/></span><span>            </span>}<br/>          }<br/>          List&lt;String&gt; l = <span>new </span>ArrayList&lt;&gt;()<span>;<br/></span><span>          for </span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= cCount<span>; </span>i++) {<br/>            l.add(cName.get(i) + <span>" = " </span>+ rs.getString(i))<span>;<br/></span><span>          </span>}<br/>          System.<span>out</span>.println(l.stream()<br/>                      .collect(Collectors.<span>joining</span>(<span>", "</span>)))<span>;<br/></span><span>        </span>}<br/>      }<br/>    }<br/>  } <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>}</pre>
<p>We have already used this method in the previous recipes.</p>
<p>The function can be deleted by the <kbd>drop function if exists createTableTexts()</kbd> statement.  </p>
<p>Now let's put all of this together in Java code, create a function, and invoke it in three different styles:</p>
<pre><span>execute</span>(<span>"create or replace function createTableTexts() " <br/>        + "returns void as "<br/>        + "$$ </span><span>drop table if exists texts; "</span><br/>        + "  <span>create table texts (id integer, text text); "</span><br/>        + <span>"$$ language sql"</span>)<span>;<br/>String sql = "{ call createTableTexts() }";<br/>try (Connection conn = getDbConnection()) {<br/>  try (CallableStatement st = conn.prepareCall(sql)) {<br/>    st.execute();<br/>  }<br/>}<br/>traverseRS("select createTableTexts()");<br/>traverseRS("select * from createTableTexts()");<br/>execute("drop function if exists createTableTexts()");<br/></span></pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="57" width="402" class="image-border" src="assets/cc42e573-2b09-4dda-a2b5-c0f62aeea46b.png"/></div>
<p>Note that the name of the function is case-insensitive. We keep it camel case for human readability only.</p>
<p>Now let's create and call a stored procedure (function) with two input parameters:</p>
<pre><span>execute("create or replace function insertText(int,varchar)" <br/>        + " returns void "<br/>        + " as $$ insert into texts (id, text) "<br/>        + "   values($1, replace($2,'XX','ext'));" <br/>        + " $$ language sql");<br/>String sql = "{ call insertText(?, ?) }";<br/>try (Connection conn = getDbConnection()) {<br/>  try (CallableStatement st = conn.prepareCall(sql)) {<br/>    st.setInt(1, 1);<br/>    st.setString(2, "TXX 1");<br/>    st.execute();<br/>  }<br/>}<br/>execute("select insertText(2, 'TXX 2')");<br/>traverseRS("select * from texts");<br/>execute("drop function if exists insertText()");<br/></span></pre>
<p><span>In the function body, the input parameters were referred to by their <kbd>$1</kbd> and <kbd>$2</kbd> positions. As mentioned before, we also used the built-in <kbd>replace()</kbd> function to manipulate the values of the second input parameter before inserting it in the table. We called the newly created stored procedure twice: first via <kbd>CallableStatment</kbd> and then via the <kbd>execute()</kbd> method, with different input values. Then we looked inside the table using <kbd>traverseRS("select * from texts")</kbd> and dropped the newly created function to perform a cleanup (in real code, the function, once created, stays and takes advantage of being there, compiled and ready to run). If we run this code, we'll get the following result:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="49" width="442" class="image-border" src="assets/fa933ce1-3f33-4adc-8036-e089af2e167c.png"/></div>
<p><span>The following code adds two rows to the <kbd>texts</kbd> table, then looks into it and creates a stored procedure (function) that counts the number of rows in the table and returns the result (note the <kbd>bigint</kbd> value of the returned value and the matching type for the <kbd>OUT</kbd> parameter <kbd>Types.BIGINT</kbd>):</span></p>
<pre><span>execute("insert into texts (id, text) " <br/>         + "values(3,'Text 3'),(4,'Text 4')");<br/>traverseRS("select * from texts");<br/>execute("create or replace function countTexts() " <br/>        + "returns bigint as " <br/>        + "$$ select count(*) from texts; " <br/>        + "$$ language sql");<br/>String sql = "{ ? = call countTexts() }";<br/>try (Connection conn = getDbConnection()) {<br/>  try (CallableStatement st = conn.prepareCall(sql)) {<br/>    st.registerOutParameter(1, Types.BIGINT);<br/>    st.execute();<br/>    System.out.println("Result of countTexts() = " + st.getLong(1));<br/>  }<br/>}<br/>traverseRS("select countTexts()");<br/>traverseRS("select * from countTexts()");<br/>execute("drop function if exists countTexts()");<br/></span></pre>
<p><span>The newly created stored procedure is executed three times and then deleted. The result is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="134" width="424" class="image-border" src="assets/faa8f054-3e42-4fb9-b6bf-81bc02e669dc.png"/></div>
<p><span>An example of a stored procedure with one input parameter (of the type <kbd>int</kbd>) that returns <kbd>ResultSet</kbd> will look like this (note the return type defined as <kbd>setof texts</kbd>, where <kbd>texts</kbd> is the name of the table):</span></p>
<pre><span>execute</span>(<span>"create or replace function selectText(int) " <br/>        + "returns setof texts as <br/>        + "$$ </span><span>select * from texts where id=$1; " </span><br/>        + <span>"$$ language sql"</span>)<span>;<br/></span><span>traverseRS</span>(<span>"select selectText(1)"</span>)<span>;<br/></span><span>traverseRS</span>(<span>"select * from selectText(1)"</span>)<span>;<br/></span><span>execute</span>(<span>"drop function if exists selectText(int)"</span>)<span>;</span></pre>
<p><span>The result will be as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="59" width="439" class="image-border" src="assets/ad9e4a06-e481-491c-8cf3-4ea71834543f.png"/></div>
<p>It's worth analyzing the difference in the <kbd>ResultSet</kbd> content of two different calls to the stored procedure. Without <kbd>select *</kbd>, it contains the name of the procedure and the returned object (of the <kbd>ResultSet</kbd> type). But with <span><kbd>select *</kbd>, it returns the actual <kbd>ResultSet</kbd> content from the last SQL statement in the procedure.</span> </p>
<p>Naturally, the question arises why we could not call this stored procedure via <kbd>CallableStatement</kbd>, like this:</p>
<pre><span>String sql = "{ ? = call selectText(?) }";<br/></span><span>try (CallableStatement st = conn.prepareCall(sql)) {<br/></span><span>  st.registerOutParameter(1, Types.OTHER);<br/></span><span>  st.setInt(2, 1);<br/></span><span>  st.execute();<br/></span><span>  traverseRS((ResultSet)st.getObject(1));<br/></span><span>}<br/></span></pre>
<p>We tried, but it did not work. Here is what the PostgreSQL documentation has to say about it:</p>
<div class="packt_quote">Functions that return data as a set should not be called via the CallableStatement interface, but instead should use the normal Statement or PreparedStatement interfaces.</div>
<p><span>There is a way around this limitation, though. The same database documentation describes how to retrieve a <kbd>refcursor</kbd> (a PostgreSQL-specific feature) value that can then be cast to <kbd>ResultSet</kbd>:</span></p>
<pre><span>execute</span>(<span>"create or replace function selectText(int) " <br/>        + "returns refcursor " +<br/>        + "as </span><span>$$ declare curs refcursor; " <br/></span><span>        + </span><span>" begin " <br/>        + </span><span>"   open curs for select * from texts where id=$1;" <br/>        + </span><span>"     return curs; " <br/>        + </span><span>" end; " <br/>        + </span><span>"$$ language plpgsql"</span>)<span>;</span><span><br/></span>String sql = <span>"{ ? = call selectText(?) }"</span><span>;<br/>try (Connection conn = getDbConnection()) {<br/>  conn.setAutoCommit(false);<br/></span><span>  try</span>(CallableStatement st = conn.prepareCall(sql)){<br/>    st.registerOutParameter(<span>1</span><span>, </span>Types.<span>OTHER</span>)<span>;<br/></span><span>    </span>st.setInt(<span>2</span><span>, </span><span>2</span>)<span>;<br/></span><span>    </span>st.execute()<span>;<br/></span><span>    try</span>(ResultSet rs = (ResultSet) st.getObject(<span>1</span>)){<br/>      System.<span>out</span>.println(<span>"traverseRS(refcursor()=&gt;rs):"</span>)<span>;<br/></span><span>      </span><span>traverseRS</span>(rs)<span>;<br/></span><span>    </span>}<br/>  }<br/>}<br/><span>traverseRS</span>(<span>"select selectText(2)"</span>)<span>;<br/></span><span>traverseRS</span>(<span>"select * from selectText(2)"</span>)<span>;<br/></span><span>execute</span>(<span>"drop function if exists selectText(int)"</span>)<span>;<br/></span></pre>
<p><span>A few comments about the preceding code would probably help you understand how it was done:</span></p>
<ul>
<li>Autocommit has to be turned off</li>
<li>Inside the function, <kbd>$1</kbd> refers to the first <kbd>IN</kbd> parameter (not counting the <kbd>OUT</kbd> parameter)</li>
<li>The language is set to <kbd>plpgsql</kbd> in order to access the <kbd>refcursor</kbd> functionality (PL/pgSQL is a loadable procedural language of the PostgreSQL database)</li>
<li>To traverse <kbd>ResultSet</kbd>, we wrote a new method, as follows:</li>
</ul>
<pre><span>        private void </span><span>traverseRS</span>(ResultSet rs) <span>throws </span>Exception {<br/>          <span>int </span>cCount = <span>0</span><span>;<br/></span><span>          </span>Map&lt;Integer<span>, </span>String&gt; cName = <span>new </span>HashMap&lt;&gt;()<span>;<br/></span><span>          while </span>(rs.next()) {<br/>            <span>if </span>(cCount == <span>0</span>) {<br/>              ResultSetMetaData rsmd = rs.getMetaData()<span>;<br/></span><span>              </span>cCount = rsmd.getColumnCount()<span>;<br/></span><span>              for </span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= cCount<span>; </span>i++) {<br/>                cName.put(i<span>, </span>rsmd.getColumnLabel(i))<span>;<br/></span><span>              </span>}<br/>            }<br/>            List&lt;String&gt; l = <span>new </span>ArrayList&lt;&gt;()<span>;<br/></span><span>            for </span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= cCount<span>; </span>i++) {<br/>              l.add(cName.get(i) + <span>" = " </span>+ rs.getString(i))<span>;<br/></span><span>            </span>}<br/>            System.<span>out</span>.println(l.stream()<br/>                      .collect(Collectors.<span>joining</span>(<span>", "</span>)))<span>;<br/></span><span>          </span>}<br/>        }</pre>
<p><span>So, our old friend can now be refactored into this:</span></p>
<pre><span>private static void </span><span>traverseRS</span>(String sql){<br/>  System.<span>out</span>.println(<span>"traverseRS(" </span>+ sql + <span>"):"</span>)<span>;<br/></span><span>  try </span>(Connection conn = <span>getDbConnection</span>()) {<br/>    <span>try </span>(Statement st = conn.createStatement()) {<br/>      <span>try</span>(ResultSet rs = st.executeQuery(sql)){<br/>        <span>traverseRS</span>(rs)<span>;<br/></span><span>      </span>}<br/>    }<br/>  } <span>catch </span>(Exception ex) { ex.printStackTrace()<span>; </span>}<br/>}</pre>
<p><span>The result will be as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="79" width="418" class="image-border" src="assets/23c60d40-e621-4b5c-ab32-5bb63acbead8.png"/></div>
<p>You can see that the result-traversing methods that do not extract an object and cast it to <kbd>ResultSet</kbd> don't show the correct data in this case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We covered the most popular cases of calling stored procedures from Java code. The scope of this book did not allow us to present more complex and potentially useful forms of stored procedures in PostgreSQL and other databases. However, we would like to mention them here, so you can have an idea of other possibilities: </p>
<ul>
<li>Functions on composite types</li>
<li>Functions with parameter names</li>
<li>Functions with variable numbers of arguments</li>
<li>Functions with default values for arguments</li>
<li>Functions as table sources</li>
<li>Functions returning tables</li>
<li>Polymorphic SQL functions</li>
<li>Functions with collations</li>
</ul>
<p> </p>
<p><span> </span></p>


            </article>

            
        </section>
    </body></html>