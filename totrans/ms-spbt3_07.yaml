- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot 3.0 Features for Containerization and Orchestration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are delving into the realm of **containerization** and **orchestration**
    using **Spring Boot 3.0**, which is a crucial skill set for contemporary developers.
    As you navigate through these pages, you will not acquire knowledge but also practical
    expertise that can be immediately implemented in your projects. This journey holds
    significance for anyone seeking to maximize the capabilities of Spring Boot, in
    developing applications that are not just efficient and scalable but resilient
    and robust in today’s ever-evolving digital world.
  prefs: []
  type: TYPE_NORMAL
- en: Upon completing this chapter, you will possess the know-how to seamlessly containerize
    your Spring Boot applications, comprehend Docker intricacies as a container platform,
    and grasp the concepts of Kubernetes for orchestrating your containerized applications.
    These skills are pivotal in today’s software development landscape where the swiftness
    and reliability of application development, deployment, and management can greatly
    influence project success.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world scenarios, adaptability to environments, resource efficiency,
    and scalability according to demand are aspects of software development. This
    chapter addresses these requirements by highlighting the advantages of containerization
    and orchestration to enhance the portability, efficiency, and manageability of
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Containerization and orchestration in Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot and Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing Spring Boot apps for Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot Actuator with Prometheus and Grafana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin this journey to containerize your Spring Boot applications and make
    them easier to manage!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we are going to need some settings in our local machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java 17 Development Kit** (**JDK 17**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern **integrated development environment** (**IDE**) – I recommend IntelliJ
    IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub repository: You can clone all repositories related to [*Chapter 7*](B18400_07.xhtml#_idTextAnchor213)
    from here: [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerization and orchestration in Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the realm of containerization, where we prepare Spring Boot applications
    for deployment across any platform. If you’re curious about how container technology
    is revolutionizing application development and deployment processes, you’ve come
    to the right spot. This section will equip you with the insights to bundle your
    Spring Boot application into a container, ensuring flexibility, uniformity, and
    adaptability in environments. You’ll delve into the reasons behind it and learn
    the techniques that will reshape your approach to delivering applications. Together,
    we’ll embark on this journey to simplify your application deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding containerization – your app in a box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of containerization as a way to pack up your application. Picture getting
    ready for a trip and ensuring all your essentials fit into one suitcase. In the
    context of your application, think of the “suitcase” as a container that houses
    not your app but the necessary code, libraries, and configuration settings. This
    container is versatile – it functions seamlessly whether it’s on your computer,
    a friend’s device, or in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this beneficial for you? Imagine creating an app that you want to work
    for everyone. Without containers, it might run perfectly on your system, but can
    encounter issues elsewhere – that can be frustrating. With containerization, if
    it works well for you, it will work well for anyone else. It provides reliability
    and eliminates those irritating moments when someone says, “It doesn’t work for
    me.”
  prefs: []
  type: TYPE_NORMAL
- en: Containers act like boxes that empower your app to travel effortlessly without
    any hassle. It’s like a trick that saves you time and headaches. By embracing
    this concept, you’re ensuring that your app is equipped to thrive regardless of
    where it needs to go or how much it needs to expand.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the reason why knowing about containerization is crucial; it simplifies
    the developer’s life and enhances the flexibility of your app. Let’s now explore
    how to prepare your Spring Boot application for this container journey.
  prefs: []
  type: TYPE_NORMAL
- en: Reaping the benefits – lighter loads, quicker starts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers do more than just help your app move around easily. They are like
    the tech world’s backpacks. Instead of each app carrying its suitcase filled with
    everything it needs to run, containers share resources. This speeds up your apps’
    launch time and saves space and memory on your computer. The concept is similar
    to carpooling to work. When everyone drives together, you all reach the same destination
    faster and in a more eco-friendly manner.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s why using containers is beneficial for you – when your app is in a container,
    it can start up instantly with a snap of your fingers. You won’t have to wait
    for it to get going. Additionally, since containers are lightweight, you can run
    apps on one machine without resource conflicts. Moreover, if your app becomes
    popular, creating containers to handle the traffic is simple – when activity slows
    down, stopping some containers is effortless.
  prefs: []
  type: TYPE_NORMAL
- en: Using containers offers flexibility to the ability to attach cars to a train
    when there is high demand for rides and detach them when demand decreases. Opting
    for containers represents an efficient approach to managing your applications.
    It revolutionizes the way you create, test, and launch your apps, enhancing reliability
    and responsiveness. In the next section, we will explore how your Spring Boot
    application can take advantage of these perks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Spring Boot in the game – container-friendly from the start
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s prepare your Spring Boot application for the container environment. Spring
    Boot acts as a guide for your app, ensuring operation within containers. Right
    from the start, Spring Boot is tailored to work with containers. Why is this important?
    It’s akin to having a car all set and prepared for a road trip whenever you need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot takes care of much of the lifting for you. It automatically adapts
    to your application requirements based on its deployment location, making it ideal
    for highly portable environments. With Spring Boot, you don’t need to micromanage
    every aspect – it intuitively grasps the container setup and adapts accordingly.
    It’s akin to having a companion who effortlessly knows what essentials to pack
    for each journey.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot also ensures that your application is ready to go – whether you’re
    running your application on your computer, a friend’s device, or in the cloud.
    This allows you to focus more on enhancing your application and less on dealing
    with the setup process.
  prefs: []
  type: TYPE_NORMAL
- en: By ensuring that your Spring Boot application is container friendly, you’re
    not just following a trend; you’re opting for a path that reduces stress and enhances
    success. It’s all about simplifying your life as a developer and strengthening
    the resilience of your application. Now, let’s move on to transforming your Spring
    Boot application into a container.
  prefs: []
  type: TYPE_NORMAL
- en: Unleashing Spring Boot superpowers – portability, efficiency, and control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s tap into the capabilities that Spring Boot offers your application when
    it’s inside a container. These capabilities include portability, efficiency, and
    control. They are set to simplify your life as a developer. These capabilities
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Portability**: This is akin to having an adapter for your application. Wherever
    you plug it in, it just functions seamlessly. Whether you transfer your application
    from your computer to a testing environment or the cloud, it will operate consistently
    each time. This eliminates the issues that arise when an application works on
    one person’s device but not another’s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: This entails achieving with less. Containers utilize resources
    by sharing them where possible and minimizing wastage. Your application boots
    up quickly and operates smoothly, akin to a tuned machine. Consequently, your
    application can cater to many users simultaneously without requiring power or
    numerous machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control**: This empowers you to effortlessly oversee all aspects of your
    application. You can initiate it, halt it, scale it up during usage periods, or
    scale it down during quieter times. It’s similar to having a remote for your app,
    where you have buttons for every action you may need. Spring Boot makes it easy
    to access all these controls as it is designed in a user-intuitive manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you package your Spring Boot app in a container, you’re not just putting
    it in a box; you’re equipping it with tools that enhance its flexibility, strength,
    and intelligence. This prepares our application to meet the needs of users today
    and in the future. The best part? You’re setting it up in a way that allows you
    to focus on improving the app itself rather than worrying about how and where
    it operates. That’s the beauty of using containers, with Spring Boot – it empowers
    you to enhance your app’s capabilities while minimizing complexities. Let’s now
    move forward and implement these features as we containerize your Spring Boot
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot and Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After laying the foundation by understanding containerization and orchestration,
    as their overall advantages, it’s time to dive in and get hands on. This section
    will walk you through the process of incorporating Docker into a sample Spring
    Boot application and making use of the features of Spring Boot 3.0\. We’ll demonstrate
    how to convert your Spring Boot application into a set of containers that can
    be efficiently orchestrated for scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start this journey where we will put the concepts of containerization
    and orchestration into action with Spring Boot. Together, we’ll learn how to create
    Docker images that are not only functional but also tailored to enhance your workflow,
    paving the way for seamless integration with container orchestration platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting efficient Docker images with layered jars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker aims to simplify developers’ lives by emphasizing the importance of creating
    Docker images for results. The concept of jars, a feature of Spring Boot, has
    caught the attention of developers. Picture baking a cake – instead of baking
    it as one unit, you bake individual layers separately. This method allows for
    the modification of layers without the need to reconstruct the entire cake. Similarly,
    layered jars in Docker enable you to segregate your application into layers that
    can be managed and updated independently by Docker.
  prefs: []
  type: TYPE_NORMAL
- en: This approach revolutionizes the development process by reducing build times
    and producing Docker images. By caching these layers, Docker only rebuilds the
    modified layers when changes are made to your application. For example, modifications
    to your application’s code do not necessitate rebuilding the components, such
    as the JVM layer that remains largely unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ready to get started? Here’s a step-by-step guide on setting up your Spring
    Boot project to take advantage of layered jars:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a new project**: Use Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    to create a new Spring Boot project. Select **Spring Boot version 3.2.1**. For
    dependencies, add **Spring Web** to create a simple web application. Please choose
    **Gradle** as the build tool.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generate and download**: Once configured, click on **Generate** to download
    your project skeleton.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`` `src/main/java/` `` in the appropriate package, create a new Java class
    named `` `HelloController` ``.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Add a REST endpoint**: Implement a simple GET endpoint that returns a greeting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Enable layering**: Begin by configuring your Spring Boot build plugin to
    recognize the layering feature. It’s a simple matter of including the right dependencies
    and configuration settings in your build file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`` `./gradlew build` [PRE1]` build/libs` `` directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we have a layered jar in our hands. Let’s see how we can check the layers
    inside of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `layers.idx` file organizes the application into logical layers. Typical
    layers include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dependencies`: The external libraries your application needs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-boot-loader`: The parts of Spring Boot that are responsible for launching
    your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`snapshot-dependencies`: Any snapshot versions of dependencies, which are more
    likely to change than regular dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application`: Your application’s compiled classes and resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each layer is designed to optimize the build process for Docker. Layers less
    likely to change (such as `dependencies`) are separated from more volatile layers
    (such as `application`), allowing Docker to cache these layers independently.
    This reduces the time and bandwidth needed to rebuild and redeploy your application
    when only small changes are made.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored the efficiency of layered jars, next, we will look at how Spring
    Boot simplifies Docker image creation with Cloud Native Buildpacks. Prepare to
    see how even without deep Docker expertise, you can create and manage Docker images
    that are both robust and ready for the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Dockerization with Cloud Native Buildpacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cloud Native Buildpacks** mark an advancement in how we prepare applications
    for Docker – consider them as your assistant for Dockerizing. For creating a Dockerfile,
    where you list out all the commands to build your Docker image, Buildpacks automate
    this process. They analyze your code figure out its requirements and package it
    into a container image without you needing to write even a line of code in a Dockerfile.'
  prefs: []
  type: TYPE_NORMAL
- en: This automation is particularly beneficial for teams lacking expertise in Docker
    or the time to maintain Dockerfiles. It also promotes consistency and adherence
    to practices, ensuring that the images generated by Buildpacks meet standards,
    for security, efficiency, and compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can harness the power of Cloud Native Buildpacks with Spring
    Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, navigate to the root folder of our Spring Boot application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Spring Boot Gradle plugin, which comes with built-in support for Buildpacks.
    With a simple command, `./gradlew bootBuildImage --imageName=demoapp`, you trigger
    the Buildpack to spring into action. We also gave a name to our image – `demoapp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Buildpack examines your application, recognizing it as a Spring Boot app.
    It then automatically selects a base image and layers your application code on
    top, along with any dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the Buildpack optimizes your image for the cloud. This means trimming
    any fat to ensure your image is as lightweight and secure as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our Spring Boot application is now containerized and ready for deployment to
    any Docker environment, cloud or otherwise. You’ve got a robust, standardized
    Docker image with zero Dockerfile drama.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can test whether it is working as expected with Docker. Please be sure Docker
    Desktop is up and running on your local machine. Later, we just need to run this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: server.shutdown=graceful
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: spring.lifecycle.timeout-per-shutdown-phase=20s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ./gradlew bootBuildImage --imageName=demoapp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: docker run –-name demoapp-container -p 8080:8080 demoapp:latest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: docker stop demoapp-container
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Commencing graceful shutdown. Waiting for active requests to complete
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Graceful shutdown complete
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: implementation 'org.springframework.boot:spring-boot-starter-actuator'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: management.endpoint.health.group.liveness.include=livenessState
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: management.endpoint.health.group.readiness.include=readinessState
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'apiVersion: apps/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Deployment'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: spring-boot-demo-app'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'replicas: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'selector:'
  prefs: []
  type: TYPE_NORMAL
- en: 'matchLabels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'app: spring-boot-demo-app'
  prefs: []
  type: TYPE_NORMAL
- en: 'template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'labels:'
  prefs: []
  type: TYPE_NORMAL
- en: 'app: spring-boot-demo-app'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: spring-boot-demo-app'
  prefs: []
  type: TYPE_NORMAL
- en: 'image: demoapp:latest'
  prefs: []
  type: TYPE_NORMAL
- en: 'imagePullPolicy: IfNotPresent'
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '- containerPort: 8080'
  prefs: []
  type: TYPE_NORMAL
- en: 'livenessProbe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'httpGet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /actuator/health/liveness'
  prefs: []
  type: TYPE_NORMAL
- en: 'port: 8080'
  prefs: []
  type: TYPE_NORMAL
- en: 'initialDelaySeconds: 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'periodSeconds: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'readinessProbe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'httpGet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /actuator/health/readiness'
  prefs: []
  type: TYPE_NORMAL
- en: 'port: 8080'
  prefs: []
  type: TYPE_NORMAL
- en: 'initialDelaySeconds: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'periodSeconds: 5'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '---'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Service'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: spring-boot-demo-app-service'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'type: LoadBalancer'
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '- port: 8080'
  prefs: []
  type: TYPE_NORMAL
- en: 'targetPort: 8080'
  prefs: []
  type: TYPE_NORMAL
- en: 'selector:'
  prefs: []
  type: TYPE_NORMAL
- en: 'app: spring-boot-demo-app'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'kubectl commands to observe the probes in action. This ensures they’re correctly
    configured and responding as expected. Also, you can make a GET request to HelloController
    by the following curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the response we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means our app is up and running and successfully communicated with readiness
    and liveness probs with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: With your app’s health checks firmly in place, ensuring that Kubernetes knows
    exactly when your services are ready and able to perform, it’s time to shift our
    focus. Next, we’ll dive into the realm of Kubernetes **ConfigMaps** and **Secrets**.
    This move will show you how to adeptly handle application configuration and manage
    sensitive data, leveraging Kubernetes-native mechanisms to further enhance the
    operational efficiency and security of your Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Managing configurations and Secrets with Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of Kubernetes, effective management of application configurations
    and sensitive information is not just a best practice; it’s a necessity for secure
    and scalable deployments. Kubernetes offers two powerful tools for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps enable the separation of configuration artifacts from images for
    portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets securely store sensitive information such as passwords, OAuth tokens,
    and SSH keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ConfigMaps and Secrets can revolutionize how you manage your application’s environment-specific
    configurations and sensitive data. Here’s how to leverage these Kubernetes-native
    tools in your Spring Boot application, using a new controller as an illustrative
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a simple Spring Boot controller that returns a message and an API key
    when specific endpoints are accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `@Value` annotations pull configuration values from the application’s environment,
    with default values provided for both the message and the API key.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll externalize the configuration using a ConfigMap and a Secret. The
    ConfigMap stores the custom message, and the Secret securely stores the API key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new YAML file called `app-configmap.yaml` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can easily understand, this configuration will set a message for our
    `app.message` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a secure key with Kubernetes capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to modify our application’s deployment YAML file to inject the
    values from the ConfigMap and Secret into your Spring Boot application’s environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This configuration injects the `app.message` from the `ConfigMap` and the `api.key`
    from the Secret into the `APP_MESSAGE` and `API_KEY` environment variables, respectively,
    which Spring Boot consumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to regenerate our image and restart the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After applying the updated deployment, your application will now return the
    `/message` endpoint, and the secure API key when accessing the `/apikey` endpoint,
    demonstrating the successful externalization of configuration and sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have configured your application to keep its secrets safe and configurations
    dynamic, let’s explore the streamlined approach Spring Boot offers for profile-specific
    configurations in various Kubernetes environments. This next step will enhance
    your ability to manage application behavior dynamically based on the deployment
    environment, further tailoring your app’s functionality to meet different operational
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing profile-specific configurations in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of application deployment, customizing your app to behave differently
    in settings, such as development, testing, and production, is not just helpful;
    it’s essential. Spring Boot simplifies this process by offering profile configurations
    that let you set up configurations based on the profile. When used alongside Kubernetes,
    this functionality opens up a level of adaptability and versatility for your deployments.
  prefs: []
  type: TYPE_NORMAL
- en: With profile configurations in Spring Boot, you can organize your app properties
    into files specific to each environment. For example, you could have `application-prod.properties`
    for production settings and `application-test.properties` for test environment
    settings. This segregation allows you to manage environment configurations such
    as database URLs, external service endpoints, and feature toggles separately reducing
    the risk of configuration mix-ups between environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example where your Spring Boot application needs to return
    a different message from the `/message` endpoint based on whether it’s running
    in a test or production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, let’s define our configurations for test and prod environments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`application-test.properties`: This is intended for the test environment:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`application-prod.properties`: This is intended for the production environment:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '2.  To leverage these profiles within Kubernetes, you can set an environment
    variable in your deployment configuration that Spring Boot automatically recognizes
    to activate a specific profile:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By setting the `SPRING_PROFILES_ACTIVE` environment variable to either prod
    or test, you instruct Spring Boot to activate the corresponding profile and load
    its associated properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '3.  Now, we need to regenerate our image and restart the Kubernetes cluster:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deploy your application to Kubernetes with the prod profile activated. Accessing
    the `/message` endpoint should return `SPRING_PROFILES_ACTIVE` value to test and
    redeploy, and the same endpoint should now return **Hello from the Test Environment!**,
    demonstrating the profile-specific behavior in action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After exploring the profile-based configurations, let’s take a moment to reflect
    on the journey we’ve been on and how these features aligned with Kubernetes can
    benefit you and your Spring Boot applications. This method not only simplifies
    the handling of environment settings but also boosts your application’s adaptability
    and reliability across different deployment scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve discussed how the innovative features of Spring Boot
    3.0 can seamlessly merge with Kubernetes to improve the deployment, configuration,
    and management of applications. We looked into utilizing Kubernetes probes for
    application health monitoring, managing configurations and secrets to protect
    data, and adapting to various environments effortlessly with profile-specific
    settings. These capabilities not only streamline deployment but also strengthen
    the resilience and flexibility of applications in the Kubernetes environment.
    With its native support for Kubernetes, Spring Boot 3.0 empowers developers to
    make use of container orchestration to ensure that applications can be deployed
    at scale while remaining maintainable and secure.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your Spring Boot applications are primed for performance in Kubernetes,
    our upcoming section will focus on monitoring these applications. The integration
    is designed to be user friendly, offering assistance for keeping track of and
    analyzing data in Kubernetes settings. This ensures that you have the information
    to enhance performance and dependability.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot Actuator with Prometheus and Grafana
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of Kubernetes, where applications are dynamically handled across
    a group of containers, the significance of monitoring and metrics cannot be emphasized
    enough. These insights act as the heartbeat for your applications, signaling their
    health, performance, and efficiency. Without them, you’re navigating blindly through
    a maze of complexity, unable to detect or resolve issues that could impact your
    application’s reliability or user experience. Monitoring and metrics empower developers
    and operations teams with the visibility to ensure that applications are not just
    surviving but thriving in their Kubernetes environment.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing **Spring Boot Actuator**, a tool in every developer’s arsenal for
    revealing a wealth of details about your application. Actuator endpoints provide
    a peek into the workings of your application by offering real-time metrics, health
    checks, and more. These insights are priceless for maintaining an application
    state, identifying problems before they escalate, and optimizing performance to
    meet requirements. With Spring Boot Actuator at your disposal, you acquire an
    understanding of how your application behaves and its current status – for effective
    monitoring within Kubernetes setups.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how Spring Boot Actuator furnishes the required endpoints for
    Prometheus to gather data, paving the way for monitoring capabilities. This groundwork
    will help us unlock the capabilities of Prometheus and Grafana and develop a monitoring
    system that brings clarity to managing applications on a scale.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Prometheus for metrics collection
  prefs: []
  type: TYPE_NORMAL
- en: '**Prometheus** plays a role in monitoring within the Kubernetes ecosystem,
    serving as a tool for keeping tabs on the well-being and efficiency of applications
    and infrastructure. Its capacity to gather and consolidate metrics is invaluable,
    particularly when combined with the Actuator endpoints of Spring Boot. These endpoints
    reveal information that Prometheus can gather to present a thorough overview of
    an application’s operational condition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate Prometheus with a Spring Boot application, you need to configure
    Prometheus to recognize and scrape the Actuator metrics endpoints. Here’s a practical
    guide to setting this up, utilizing Kubernetes ConfigMaps and deployments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to update our Spring Boot application. We will add a new library
    to our `gradle.build` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Then, we need to add `prometheus` in the `web.exposure` list to enable
    the Prometheus Actuator endpoint in the `application.properties` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.  Start by defining a `ConfigMap` resource that contains your Prometheus
    configuration. This includes specifying the scrape interval and the targets from
    which Prometheus should collect metrics. Here’s how `prometheus-config.yaml` looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This configuration instructs Prometheus to scrape metrics from your Spring Boot
    application’s Actuator Prometheus endpoint every 15 seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.  With the `ConfigMap` in place, deploy the Prometheus server using `prometheus-deployment.yaml`.
    This deployment specifies the Prometheus server image, ports, and volume mounts,
    to use the previously created `ConfigMap` for configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we need to define the deployment part of this Kubernetes pod as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can continue with the load balancer part of this pod as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this YAML file, we have defined a Kubernetes pod that can run Prometheus
    image in it, and serve it in port `9090`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '5.  Apply the configuration to your Kubernetes cluster with the following commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These commands create the necessary ConfigMap and deploy Prometheus within your
    cluster, setting it up to automatically scrape metrics from your Spring Boot application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Having Prometheus collect metrics is just the first step toward gaining actionable
    insights into your application’s performance. The real magic happens when we visualize
    this data, making it accessible and understandable. Next, we’ll explore how Grafana
    can be used to create compelling visualizations of the metrics collected by Prometheus,
    transforming raw data into valuable insights that drive decision making and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing metrics with Grafana
  prefs: []
  type: TYPE_NORMAL
- en: '**Grafana** acts like a beacon guiding us through the ocean of metrics generated
    by today’s applications. It’s more than a tool. It’s a platform that turns metrics
    data into valuable insights with its versatile dashboards. Grafana supports data
    sources, including Prometheus, and excels in creating queries, setting up alerts,
    and presenting data in diverse formats. Whether you’re tracking system health,
    user behavior, or app performance, Grafana offers the clarity and instant information
    needed for making decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To leverage Grafana for monitoring your Spring Boot application metrics, you’ll
    start by deploying Grafana in your Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `grafana-deployment.yaml` file that defines the Grafana deployment
    and service in Kubernetes. This deployment will run Grafana and expose it through
    `LoadBalancer`, making the Grafana UI accessible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This configuration will help us to create a `grafana` instance and make it accessible
    over port `3000`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Apply this configuration with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to `http://prometheus-service:9090` Prometheus service since Prometheus
    is deployed within the same Kubernetes cluster. Save and test the connection to
    ensure Grafana can communicate with Prometheus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Prometheus configured as a data source, you can now create dashboards in
    Grafana to visualize your Spring Boot application metrics. Start by clicking `12900`
    ID for **SpringBoot APM Dashboard** and select the data source you created for
    Prometheus. That’s it! You have a wide range dashboard to monitor your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1: Sample visualization that demonstrates how the dashboard will
    appear](img/B18400_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Sample visualization that demonstrates how the dashboard will appear'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.1*, the Grafana dashboard showcases the performance metrics of
    a Spring Boot application visually. **SpringBoot APM Dashboard** is designed with
    panels that are easy to understand, displaying information at a glance. At the
    top, you can view statistics, such as uptime and memory usage gauges, which offer
    a snapshot of system health. Below are graphs and charts that illustrate CPU usage
    and JVM memory statistics, providing insights into the application’s performance.
    The dashboard utilizes gauges, bar charts, and line graphs to present data in
    a user-friendly manner, enabling users to monitor and analyze the application’s
    behavior over time without complexity overload.
  prefs: []
  type: TYPE_NORMAL
- en: Having discussed collection and visualization techniques, let’s explore scenarios
    where these insights can enhance your application’s performance and reliability.
    By leveraging Grafana dashboards, we can shift from a reactive approach to a proactive
    approach in managing our Spring Boot apps to ensure optimal performance within
    Kubernetes environments.
  prefs: []
  type: TYPE_NORMAL
- en: During our exploration of application monitoring, we have emphasized the need
    to closely monitor our applications, especially when they are operating within
    the environment of Kubernetes. The Spring Boot Actuator has emerged as a tool
    that provides us with a way to examine the signs of our applications. When combined
    with Prometheus, this duo acts as an observer collecting metrics that offer a
    view of how our applications are functioning.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Grafana completes our monitoring trio by transforming the data gathered
    by Prometheus into stories that illustrate the performance and health of our applications.
    Through user dashboards, we not only have the ability to observe but also to interact
    with our metrics in depth, delving into patterns that inform our proactive actions.
  prefs: []
  type: TYPE_NORMAL
- en: As we consider the tools available to us, we realize that we are not just equipped
    for monitoring; we are empowered to predict, adjust, and ensure that our Kubernetes
    deployments operate optimally. The concrete advantages of this integrated monitoring
    strategy – such as improved visibility, quicker response times, and a deeper insight
    into application behavior – are assets in our efforts to deliver resilient and
    reliable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: As we wrap up this chapter, on the Spring Boot 3.0 features for containerization
    and orchestration, we can say that it has been quite a journey of learning and
    honing skills. This chapter not only highlighted the role of containerization
    and orchestration in software development but also equipped you with the necessary
    tools and knowledge to effectively utilize these technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s recap the valuable insights and skills you’ve acquired:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the essentials of containerization**: We began by delving into
    the concept of containerization and learned how to bundle our Spring Boot applications
    into containers for portability and efficiency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mastering Docker with Spring Boot**: We have discussed how to create and
    manage Docker images for our Spring Boot applications, making them ready for any
    environment while emphasizing the ease of deployment and lightweight nature of
    containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestrating containers with Kubernetes**: We have learned how to deploy
    and manage our Dockerized Spring Boot applications using Kubernetes, highlighting
    the platform’s ability to scale and maintain application health'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring with Prometheus and Grafana**: Finally, we explored how to set
    up Prometheus for metrics collection and Grafana for visualization, ensuring you
    can monitor your applications’ performance and swiftly respond to any issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These abilities and expertise are extremely valuable in today’s tech landscape,
    allowing you to create applications that are not only robust and adaptable but
    also easy to maintain and efficient across different platforms. Having a grasp
    of containerization and orchestration principles lays the groundwork for developing
    cutting-edge cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: As we look forward to the next chapter, we’ll delve into the integration of
    Kafka with Spring Boot to build responsive, scalable event-driven systems.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from the realm of containerization and orchestration to event-driven
    design opens up opportunities for you to enhance your skill set, further tackling
    the challenges and advantages of software development. The next chapter is anticipated
    to be another stride in your journey toward mastering Spring Boot and its ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
