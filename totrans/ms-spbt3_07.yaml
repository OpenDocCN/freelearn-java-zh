- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Spring Boot 3.0 Features for Containerization and Orchestration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 3.0 的容器化和编排功能
- en: In this chapter, we are delving into the realm of **containerization** and **orchestration**
    using **Spring Boot 3.0**, which is a crucial skill set for contemporary developers.
    As you navigate through these pages, you will not acquire knowledge but also practical
    expertise that can be immediately implemented in your projects. This journey holds
    significance for anyone seeking to maximize the capabilities of Spring Boot, in
    developing applications that are not just efficient and scalable but resilient
    and robust in today’s ever-evolving digital world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨使用 **Spring Boot 3.0** 的 **容器化** 和 **编排** 领域，这对于当代开发者来说是一个关键技能集。随着您翻阅这些页面，您不仅将获得知识，还将获得可以立即应用于您项目的实践经验。对于任何寻求最大化
    Spring Boot 能力的开发者来说，这段旅程具有重要意义，他们开发的应用程序不仅高效和可扩展，而且在当今不断发展的数字世界中具有弹性和健壮性。
- en: Upon completing this chapter, you will possess the know-how to seamlessly containerize
    your Spring Boot applications, comprehend Docker intricacies as a container platform,
    and grasp the concepts of Kubernetes for orchestrating your containerized applications.
    These skills are pivotal in today’s software development landscape where the swiftness
    and reliability of application development, deployment, and management can greatly
    influence project success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将掌握无缝容器化 Spring Boot 应用程序的知识，理解作为容器平台的 Docker 的复杂性，并掌握 Kubernetes 编排您容器化应用程序的概念。这些技能在当今的软件开发领域中至关重要，因为应用程序开发、部署和管理速度和可靠性可以极大地影响项目成功。
- en: In real-world scenarios, adaptability to environments, resource efficiency,
    and scalability according to demand are aspects of software development. This
    chapter addresses these requirements by highlighting the advantages of containerization
    and orchestration to enhance the portability, efficiency, and manageability of
    your applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，根据需求对环境的适应性、资源效率和可扩展性是软件开发的一些方面。本章通过强调容器化和编排的优势来满足这些要求，以增强您应用程序的可移植性、效率和可管理性。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Containerization and orchestration in Spring Boot
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 中的容器化和编排
- en: Spring Boot and Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 和 Docker
- en: Optimizing Spring Boot apps for Kubernetes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化 Spring Boot 应用程序以适应 Kubernetes
- en: Spring Boot Actuator with Prometheus and Grafana
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 与 Prometheus 和 Grafana
- en: Let’s begin this journey to containerize your Spring Boot applications and make
    them easier to manage!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这段旅程，将您的 Spring Boot 应用程序容器化，并使它们更容易管理！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we are going to need some settings in our local machines:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要在我们的本地机器上做一些设置：
- en: '**Java 17 Development Kit** (**JDK 17**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 17 开发工具包**（**JDK 17**）'
- en: A modern **integrated development environment** (**IDE**) – I recommend IntelliJ
    IDEA
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代的**集成开发环境**（**IDE**）——我推荐 IntelliJ IDEA
- en: 'GitHub repository: You can clone all repositories related to [*Chapter 7*](B18400_07.xhtml#_idTextAnchor213)
    from here: [https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 仓库：您可以从这里克隆与[*第7章*](B18400_07.xhtml#_idTextAnchor213)相关的所有仓库：[https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/](https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/)
- en: Docker Desktop
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: Containerization and orchestration in Spring Boot
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 中的容器化和编排
- en: Welcome to the realm of containerization, where we prepare Spring Boot applications
    for deployment across any platform. If you’re curious about how container technology
    is revolutionizing application development and deployment processes, you’ve come
    to the right spot. This section will equip you with the insights to bundle your
    Spring Boot application into a container, ensuring flexibility, uniformity, and
    adaptability in environments. You’ll delve into the reasons behind it and learn
    the techniques that will reshape your approach to delivering applications. Together,
    we’ll embark on this journey to simplify your application deployment process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到容器化的领域，我们将为 Spring Boot 应用程序在任意平台上的部署做好准备。如果您对容器技术如何革命性地改变应用程序的开发和部署流程感兴趣，您就来到了正确的位置。本节将为您提供将
    Spring Boot 应用程序打包成容器的见解，确保在环境中的灵活性、一致性和适应性。您将深入了解背后的原因，并学习将重塑您交付应用程序方法的技巧。我们将一起踏上这段旅程，简化您的应用程序部署过程。
- en: Understanding containerization – your app in a box
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解容器化——您的应用程序在一个盒子里
- en: Think of containerization as a way to pack up your application. Picture getting
    ready for a trip and ensuring all your essentials fit into one suitcase. In the
    context of your application, think of the “suitcase” as a container that houses
    not your app but the necessary code, libraries, and configuration settings. This
    container is versatile – it functions seamlessly whether it’s on your computer,
    a friend’s device, or in the cloud.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器化视为打包应用程序的一种方式。想象一下准备旅行，确保所有必需品都装进一个行李箱。在你的应用程序的上下文中，将“行李箱”想象成一个容器，它容纳的不是你的应用程序，而是必要的代码、库和配置设置。这个容器是通用的——无论它是在你的电脑上、朋友的设备上还是在云端，它都能无缝运行。
- en: Why is this beneficial for you? Imagine creating an app that you want to work
    for everyone. Without containers, it might run perfectly on your system, but can
    encounter issues elsewhere – that can be frustrating. With containerization, if
    it works well for you, it will work well for anyone else. It provides reliability
    and eliminates those irritating moments when someone says, “It doesn’t work for
    me.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你有什么好处？想象一下创建一个你想让每个人都能使用的应用程序。没有容器，它可能在你的系统上运行得很好，但可能在其他地方遇到问题——这可能会令人沮丧。有了容器化，如果它对你工作得很好，那么对其他人也是如此。它提供了可靠性，消除了那些令人烦恼的时刻，当有人说，“它对我不起作用。”
- en: Containers act like boxes that empower your app to travel effortlessly without
    any hassle. It’s like a trick that saves you time and headaches. By embracing
    this concept, you’re ensuring that your app is equipped to thrive regardless of
    where it needs to go or how much it needs to expand.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 容器就像盒子，让你的应用程序能够轻松旅行，没有任何麻烦。这就像一个节省你时间和头痛的技巧。通过接受这个概念，你确保了无论应用程序需要去哪里或需要扩展多少，它都能茁壮成长。
- en: That’s the reason why knowing about containerization is crucial; it simplifies
    the developer’s life and enhances the flexibility of your app. Let’s now explore
    how to prepare your Spring Boot application for this container journey.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，了解容器化至关重要；它简化了开发者的生活，并增强了应用程序的灵活性。现在让我们探索如何为Spring Boot应用程序准备这次容器之旅。
- en: Reaping the benefits – lighter loads, quicker starts
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 享受收益——负载更轻，启动更快
- en: Containers do more than just help your app move around easily. They are like
    the tech world’s backpacks. Instead of each app carrying its suitcase filled with
    everything it needs to run, containers share resources. This speeds up your apps’
    launch time and saves space and memory on your computer. The concept is similar
    to carpooling to work. When everyone drives together, you all reach the same destination
    faster and in a more eco-friendly manner.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器不仅帮助应用程序轻松移动。它们就像是科技世界的背包。不是每个应用程序都携带一个装满运行所需一切物品的行李箱，容器共享资源。这加快了应用程序的启动时间，并在你的电脑上节省空间和内存。这个概念类似于拼车上班。当每个人都一起开车时，你们所有人都能更快地到达目的地，并且更加环保。
- en: Here’s why using containers is beneficial for you – when your app is in a container,
    it can start up instantly with a snap of your fingers. You won’t have to wait
    for it to get going. Additionally, since containers are lightweight, you can run
    apps on one machine without resource conflicts. Moreover, if your app becomes
    popular, creating containers to handle the traffic is simple – when activity slows
    down, stopping some containers is effortless.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用容器对你有益的原因——当你的应用程序在容器中时，它可以瞬间启动，只需一挥手。你不必等待它开始。此外，由于容器轻量级，你可以在一台机器上运行应用程序而不会发生资源冲突。此外，如果你的应用程序变得流行，创建容器来处理流量很简单——当活动减慢时，停止一些容器是轻而易举的。
- en: Using containers offers flexibility to the ability to attach cars to a train
    when there is high demand for rides and detach them when demand decreases. Opting
    for containers represents an efficient approach to managing your applications.
    It revolutionizes the way you create, test, and launch your apps, enhancing reliability
    and responsiveness. In the next section, we will explore how your Spring Boot
    application can take advantage of these perks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器提供了在需求高时将汽车连接到火车上，在需求减少时将其拆卸下来的灵活性。选择容器代表了一种高效管理应用程序的方法。它彻底改变了你创建、测试和发布应用程序的方式，提高了可靠性和响应速度。在下一节中，我们将探讨你的Spring
    Boot应用程序如何利用这些好处。
- en: Getting Spring Boot in the game – container-friendly from the start
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Spring Boot带入比赛——从一开始就支持容器
- en: Let’s prepare your Spring Boot application for the container environment. Spring
    Boot acts as a guide for your app, ensuring operation within containers. Right
    from the start, Spring Boot is tailored to work with containers. Why is this important?
    It’s akin to having a car all set and prepared for a road trip whenever you need
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为您的Spring Boot应用程序准备容器环境。Spring Boot作为您的应用程序的向导，确保在容器内运行。从一开始，Spring Boot就旨在与容器一起工作。为什么这很重要？这就像拥有一辆随时准备好的汽车，以便您需要时进行长途旅行。
- en: Spring Boot takes care of much of the lifting for you. It automatically adapts
    to your application requirements based on its deployment location, making it ideal
    for highly portable environments. With Spring Boot, you don’t need to micromanage
    every aspect – it intuitively grasps the container setup and adapts accordingly.
    It’s akin to having a companion who effortlessly knows what essentials to pack
    for each journey.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为您承担了许多重任。它根据其部署位置自动适应您的应用程序需求，使其非常适合高度可移植的环境。使用Spring Boot，您不需要对每个方面进行微观管理——它本能地理解容器设置并相应地适应。这就像有一个伴侣，每次旅行都能轻松地知道需要携带哪些必需品。
- en: Spring Boot also ensures that your application is ready to go – whether you’re
    running your application on your computer, a friend’s device, or in the cloud.
    This allows you to focus more on enhancing your application and less on dealing
    with the setup process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot还确保您的应用程序随时可用——无论您是在自己的电脑上、朋友的设备上还是在云中运行您的应用程序。这使您能够更多地关注增强您的应用程序，而不是处理设置过程。
- en: By ensuring that your Spring Boot application is container friendly, you’re
    not just following a trend; you’re opting for a path that reduces stress and enhances
    success. It’s all about simplifying your life as a developer and strengthening
    the resilience of your application. Now, let’s move on to transforming your Spring
    Boot application into a container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保您的Spring Boot应用程序具有容器友好性，您不仅是在追随潮流；您是在选择一条减少压力并提高成功率的道路。这一切都是为了简化您作为开发者的生活并增强您应用程序的弹性。现在，让我们继续将您的Spring
    Boot应用程序转换为容器。
- en: Unleashing Spring Boot superpowers – portability, efficiency, and control
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 激发Spring Boot的超级力量——可移植性、效率和控制
- en: 'Let’s tap into the capabilities that Spring Boot offers your application when
    it’s inside a container. These capabilities include portability, efficiency, and
    control. They are set to simplify your life as a developer. These capabilities
    are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索Spring Boot在容器内部为您的应用程序提供的功能。这些功能包括可移植性、效率和控制。它们旨在简化您作为开发者的生活。这些功能如下：
- en: '**Portability**: This is akin to having an adapter for your application. Wherever
    you plug it in, it just functions seamlessly. Whether you transfer your application
    from your computer to a testing environment or the cloud, it will operate consistently
    each time. This eliminates the issues that arise when an application works on
    one person’s device but not another’s.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：这就像为您的应用程序配备了一个适配器。无论您将其插入何处，它都能无缝地运行。无论您将应用程序从您的电脑转移到测试环境或云中，它每次都会一致地运行。这消除了当应用程序在一台设备上运行但在另一台设备上不运行时出现的问题。'
- en: '**Efficiency**: This entails achieving with less. Containers utilize resources
    by sharing them where possible and minimizing wastage. Your application boots
    up quickly and operates smoothly, akin to a tuned machine. Consequently, your
    application can cater to many users simultaneously without requiring power or
    numerous machines.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：这意味着用更少的资源实现。容器通过尽可能共享资源并最小化浪费来利用资源。您的应用程序启动快速且运行顺畅，就像一台调校过的机器。因此，您的应用程序可以同时为许多用户提供服务，而无需大量电力或机器。'
- en: '**Control**: This empowers you to effortlessly oversee all aspects of your
    application. You can initiate it, halt it, scale it up during usage periods, or
    scale it down during quieter times. It’s similar to having a remote for your app,
    where you have buttons for every action you may need. Spring Boot makes it easy
    to access all these controls as it is designed in a user-intuitive manner.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**：这使您能够轻松地监督您应用程序的所有方面。您可以启动它、停止它、在使用期间扩展它，或在较安静的时间缩小它。这就像拥有您应用程序的遥控器，其中每个按钮都对应您可能需要的每个操作。Spring
    Boot通过用户直观的设计方式，使访问所有这些控制变得容易。'
- en: When you package your Spring Boot app in a container, you’re not just putting
    it in a box; you’re equipping it with tools that enhance its flexibility, strength,
    and intelligence. This prepares our application to meet the needs of users today
    and in the future. The best part? You’re setting it up in a way that allows you
    to focus on improving the app itself rather than worrying about how and where
    it operates. That’s the beauty of using containers, with Spring Boot – it empowers
    you to enhance your app’s capabilities while minimizing complexities. Let’s now
    move forward and implement these features as we containerize your Spring Boot
    application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 Spring Boot 应用程序打包到容器中时，你不仅仅是把它放入一个盒子；你还在其中配备了增强其灵活性、强度和智能的工具。这使我们的应用程序能够满足当前和未来的用户需求。最好的部分？你正在以允许你专注于改进应用程序本身而不是担心它如何以及在哪里运行的方式设置它。这就是使用容器，特别是
    Spring Boot 的美妙之处——它赋予你增强应用程序功能的同时最小化复杂性的能力。现在，让我们继续前进，在我们容器化 Spring Boot 应用程序的过程中实现这些功能。
- en: Spring Boot and Docker
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 和 Docker
- en: After laying the foundation by understanding containerization and orchestration,
    as their overall advantages, it’s time to dive in and get hands on. This section
    will walk you through the process of incorporating Docker into a sample Spring
    Boot application and making use of the features of Spring Boot 3.0\. We’ll demonstrate
    how to convert your Spring Boot application into a set of containers that can
    be efficiently orchestrated for scalability.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过理解容器化和编排及其整体优势打下基础之后，现在是时候深入实践了。本节将指导你将 Docker 集成到示例 Spring Boot 应用程序中，并利用
    Spring Boot 3.0 的功能。我们将演示如何将你的 Spring Boot 应用程序转换为一系列容器，这些容器可以高效地编排以实现可伸缩性。
- en: Let’s start this journey where we will put the concepts of containerization
    and orchestration into action with Spring Boot. Together, we’ll learn how to create
    Docker images that are not only functional but also tailored to enhance your workflow,
    paving the way for seamless integration with container orchestration platforms.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这段旅程，我们将在这里将容器化和编排的概念与 Spring Boot 结合起来付诸实践。我们将一起学习如何创建不仅功能强大而且定制以增强你的工作流程的
    Docker 镜像，为与容器编排平台的无缝集成铺平道路。
- en: Crafting efficient Docker images with layered jars
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分层 jar 构建高效的 Docker 镜像
- en: Docker aims to simplify developers’ lives by emphasizing the importance of creating
    Docker images for results. The concept of jars, a feature of Spring Boot, has
    caught the attention of developers. Picture baking a cake – instead of baking
    it as one unit, you bake individual layers separately. This method allows for
    the modification of layers without the need to reconstruct the entire cake. Similarly,
    layered jars in Docker enable you to segregate your application into layers that
    can be managed and updated independently by Docker.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 通过强调创建 Docker 镜像的重要性来简化开发者的生活。Spring Boot 的 jars 概念引起了开发者的注意。想象一下烘焙蛋糕——不是作为一个整体烘焙，而是分别烘焙单独的层次。这种方法允许在不重建整个蛋糕的情况下修改层次。同样，Docker
    中的分层 jars 允许你将应用程序分割成可以由 Docker 独立管理和更新的层次。
- en: This approach revolutionizes the development process by reducing build times
    and producing Docker images. By caching these layers, Docker only rebuilds the
    modified layers when changes are made to your application. For example, modifications
    to your application’s code do not necessitate rebuilding the components, such
    as the JVM layer that remains largely unchanged.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过减少构建时间和生成 Docker 镜像来革新开发过程。通过缓存这些层次，Docker 只在应用程序发生更改时重建修改过的层次。例如，对应用程序代码的修改不需要重建那些保持基本不变的组件，如
    JVM 层。
- en: 'Ready to get started? Here’s a step-by-step guide on setting up your Spring
    Boot project to take advantage of layered jars:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 准备开始了吗？以下是一个逐步指南，介绍如何设置你的 Spring Boot 项目以利用分层 jar：
- en: '**Create a new project**: Use Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    to create a new Spring Boot project. Select **Spring Boot version 3.2.1**. For
    dependencies, add **Spring Web** to create a simple web application. Please choose
    **Gradle** as the build tool.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新项目**：使用 Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    创建一个新的 Spring Boot 项目。选择 **Spring Boot 版本 3.2.1**。对于依赖项，添加 **Spring Web** 以创建一个简单的
    Web 应用程序。请选择 **Gradle** 作为构建工具。'
- en: '**Generate and download**: Once configured, click on **Generate** to download
    your project skeleton.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成和下载**：配置完成后，点击 **生成** 下载你的项目骨架。'
- en: '`` `src/main/java/` `` in the appropriate package, create a new Java class
    named `` `HelloController` ``.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适当的包中，在`src/main/java/`目录下创建一个名为`HelloController`的新Java类。
- en: '**Add a REST endpoint**: Implement a simple GET endpoint that returns a greeting:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加REST端点**：实现一个简单的GET端点，返回一个问候语：'
- en: '[PRE0]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Enable layering**: Begin by configuring your Spring Boot build plugin to
    recognize the layering feature. It’s a simple matter of including the right dependencies
    and configuration settings in your build file.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用分层**：首先，配置您的Spring Boot构建插件以识别分层功能。这只是一个简单的问题，即在您的构建文件中包含正确的依赖项和配置设置。'
- en: '`` `./gradlew build` [PRE1]` build/libs` `` directory.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`./gradlew build` [PRE1]` build/libs` 目录。'
- en: 'Now, we have a layered jar in our hands. Let’s see how we can check the layers
    inside of it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们手中有一个分层jar。让我们看看我们如何检查其中的层：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `layers.idx` file organizes the application into logical layers. Typical
    layers include the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`layers.idx`文件将应用程序组织成逻辑层。典型的层包括以下内容：'
- en: '`dependencies`: The external libraries your application needs'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`：应用程序需要的外部库'
- en: '`spring-boot-loader`: The parts of Spring Boot that are responsible for launching
    your application'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-loader`：负责启动您的应用程序的Spring Boot部分'
- en: '`snapshot-dependencies`: Any snapshot versions of dependencies, which are more
    likely to change than regular dependencies'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-dependencies`：任何快照版本的依赖项，它们比常规依赖项更可能更改'
- en: '`application`: Your application’s compiled classes and resources'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application`：您的应用程序的编译类和资源'
- en: Each layer is designed to optimize the build process for Docker. Layers less
    likely to change (such as `dependencies`) are separated from more volatile layers
    (such as `application`), allowing Docker to cache these layers independently.
    This reduces the time and bandwidth needed to rebuild and redeploy your application
    when only small changes are made.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层都旨在优化Docker的构建过程。不太可能改变的层（如`dependencies`）与更易变的层（如`application`）分离，允许Docker独立缓存这些层。这减少了在只有小改动时重建和重新部署应用程序所需的时间和带宽。
- en: Having explored the efficiency of layered jars, next, we will look at how Spring
    Boot simplifies Docker image creation with Cloud Native Buildpacks. Prepare to
    see how even without deep Docker expertise, you can create and manage Docker images
    that are both robust and ready for the cloud.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨了分层jar的效率之后，接下来我们将看看Spring Boot如何使用云原生构建包简化Docker镜像的创建。准备好看到即使没有深入的Docker专业知识，您也可以创建和管理既健壮又适合云的Docker镜像。
- en: Simplifying Dockerization with Cloud Native Buildpacks
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用云原生构建包简化Docker化
- en: '**Cloud Native Buildpacks** mark an advancement in how we prepare applications
    for Docker – consider them as your assistant for Dockerizing. For creating a Dockerfile,
    where you list out all the commands to build your Docker image, Buildpacks automate
    this process. They analyze your code figure out its requirements and package it
    into a container image without you needing to write even a line of code in a Dockerfile.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**云原生构建包**标志着我们在为Docker准备应用程序方面的进步——把它们视为您的Docker化助手。在创建Dockerfile时，您需要列出所有构建Docker镜像的命令，构建包会自动化这个过程。它们分析您的代码，确定其需求，并将其打包成容器镜像，而无需在Dockerfile中编写任何一行代码。'
- en: This automation is particularly beneficial for teams lacking expertise in Docker
    or the time to maintain Dockerfiles. It also promotes consistency and adherence
    to practices, ensuring that the images generated by Buildpacks meet standards,
    for security, efficiency, and compatibility.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动化对于缺乏Docker专业知识或没有时间维护Dockerfile的团队特别有益。它还促进了一致性和对实践的遵守，确保构建包生成的镜像符合安全、效率和兼容性的标准。
- en: 'Here’s how you can harness the power of Cloud Native Buildpacks with Spring
    Boot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您如何利用云原生构建包的力量与Spring Boot结合使用：
- en: In the terminal, navigate to the root folder of our Spring Boot application.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，导航到我们的Spring Boot应用程序的根目录。
- en: Use the Spring Boot Gradle plugin, which comes with built-in support for Buildpacks.
    With a simple command, `./gradlew bootBuildImage --imageName=demoapp`, you trigger
    the Buildpack to spring into action. We also gave a name to our image – `demoapp`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置对构建包支持的Spring Boot Gradle插件。通过一个简单的命令，`./gradlew bootBuildImage --imageName=demoapp`，您就可以触发构建包开始工作。我们还为我们的镜像起了一个名字——`demoapp`。
- en: The Buildpack examines your application, recognizing it as a Spring Boot app.
    It then automatically selects a base image and layers your application code on
    top, along with any dependencies.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the Buildpack optimizes your image for the cloud. This means trimming
    any fat to ensure your image is as lightweight and secure as possible.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our Spring Boot application is now containerized and ready for deployment to
    any Docker environment, cloud or otherwise. You’ve got a robust, standardized
    Docker image with zero Dockerfile drama.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can test whether it is working as expected with Docker. Please be sure Docker
    Desktop is up and running on your local machine. Later, we just need to run this
    command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: server.shutdown=graceful
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: spring.lifecycle.timeout-per-shutdown-phase=20s
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ./gradlew bootBuildImage --imageName=demoapp
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: docker run –-name demoapp-container -p 8080:8080 demoapp:latest
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: docker stop demoapp-container
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Commencing graceful shutdown. Waiting for active requests to complete
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Graceful shutdown complete
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: implementation 'org.springframework.boot:spring-boot-starter-actuator'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: management.endpoint.health.group.liveness.include=livenessState
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: management.endpoint.health.group.readiness.include=readinessState
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'apiVersion: apps/v1'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Deployment'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'name: spring-boot-demo-app'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'replicas: 1'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'selector:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'matchLabels:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'app: spring-boot-demo-app'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'template:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'labels:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'app: spring-boot-demo-app'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'containers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '- name: spring-boot-demo-app'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'image: demoapp:latest'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'imagePullPolicy: IfNotPresent'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '- containerPort: 8080'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'livenessProbe:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'httpGet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /actuator/health/liveness'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'port: 8080'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'initialDelaySeconds: 10'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'periodSeconds: 5'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'readinessProbe:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'httpGet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /actuator/health/readiness'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'port: 8080'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'initialDelaySeconds: 5'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'periodSeconds: 5'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '---'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: v1'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: Service'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'name: spring-boot-demo-app-service'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'type: LoadBalancer'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'ports:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '- port: 8080'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'targetPort: 8080'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'selector:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'app: spring-boot-demo-app'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'kubectl commands to observe the probes in action. This ensures they’re correctly
    configured and responding as expected. Also, you can make a GET request to HelloController
    by the following curl command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the response we will get:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means our app is up and running and successfully communicated with readiness
    and liveness probs with Kubernetes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: With your app’s health checks firmly in place, ensuring that Kubernetes knows
    exactly when your services are ready and able to perform, it’s time to shift our
    focus. Next, we’ll dive into the realm of Kubernetes **ConfigMaps** and **Secrets**.
    This move will show you how to adeptly handle application configuration and manage
    sensitive data, leveraging Kubernetes-native mechanisms to further enhance the
    operational efficiency and security of your Spring Boot applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Managing configurations and Secrets with Kubernetes
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of Kubernetes, effective management of application configurations
    and sensitive information is not just a best practice; it’s a necessity for secure
    and scalable deployments. Kubernetes offers two powerful tools for this purpose:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 的世界中，有效管理应用程序配置和敏感信息不仅是一种最佳实践；对于安全且可扩展的部署来说，它是一种必要性。Kubernetes
    提供了两个强大的工具来完成这个目的：
- en: ConfigMaps enable the separation of configuration artifacts from images for
    portability
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ConfigMaps 允许将配置工件与镜像分离，以实现可移植性
- en: Secrets securely store sensitive information such as passwords, OAuth tokens,
    and SSH keys
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secrets 安全地存储敏感信息，如密码、OAuth 令牌和 SSH 密钥
- en: ConfigMaps and Secrets can revolutionize how you manage your application’s environment-specific
    configurations and sensitive data. Here’s how to leverage these Kubernetes-native
    tools in your Spring Boot application, using a new controller as an illustrative
    example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMaps 和 Secrets 可以彻底改变你管理应用程序环境特定配置和敏感数据的方式。以下是如何在 Spring Boot 应用程序中利用这些
    Kubernetes 原生工具，使用一个新的控制器作为说明性示例。
- en: 'Imagine a simple Spring Boot controller that returns a message and an API key
    when specific endpoints are accessed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简单的 Spring Boot 控制器，当访问特定端点时会返回一条消息和一个 API 密钥：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `@Value` annotations pull configuration values from the application’s environment,
    with default values provided for both the message and the API key.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Value` 注解从应用程序的环境中提取配置值，为消息和 API 密钥都提供了默认值。'
- en: Next, we’ll externalize the configuration using a ConfigMap and a Secret. The
    ConfigMap stores the custom message, and the Secret securely stores the API key.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 ConfigMap 和 Secret 外部化配置。ConfigMap 存储自定义消息，Secret 安全地存储 API 密钥。
- en: 'We will create a new YAML file called `app-configmap.yaml` with the following
    content:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `app-configmap.yaml` 的新 YAML 文件，内容如下：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can easily understand, this configuration will set a message for our
    `app.message` parameter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所容易理解的，此配置将为我们的 `app.message` 参数设置一条消息。
- en: 'Now, let’s create a secure key with Kubernetes capability:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个具有 Kubernetes 功能的安全密钥：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need to modify our application’s deployment YAML file to inject the
    values from the ConfigMap and Secret into your Spring Boot application’s environment:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改应用程序的部署 YAML 文件，将 ConfigMap 和 Secret 中的值注入到 Spring Boot 应用程序的环境：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This configuration injects the `app.message` from the `ConfigMap` and the `api.key`
    from the Secret into the `APP_MESSAGE` and `API_KEY` environment variables, respectively,
    which Spring Boot consumes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将 `ConfigMap` 中的 `app.message` 和 `Secret` 中的 `api.key` 分别注入到 `APP_MESSAGE`
    和 `API_KEY` 环境变量中，Spring Boot 将使用这些变量。
- en: 'Now, we need to regenerate our image and restart the Kubernetes cluster:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要重新生成我们的镜像并重启 Kubernetes 集群：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After applying the updated deployment, your application will now return the
    `/message` endpoint, and the secure API key when accessing the `/apikey` endpoint,
    demonstrating the successful externalization of configuration and sensitive data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更新后的部署后，您的应用程序现在将返回 `/message` 端点，当访问 `/apikey` 端点时会返回安全的 API 密钥，这证明了配置和敏感数据外部化的成功。
- en: Now that you have configured your application to keep its secrets safe and configurations
    dynamic, let’s explore the streamlined approach Spring Boot offers for profile-specific
    configurations in various Kubernetes environments. This next step will enhance
    your ability to manage application behavior dynamically based on the deployment
    environment, further tailoring your app’s functionality to meet different operational
    requirements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经配置了应用程序以保持其秘密安全且配置动态，让我们探索 Spring Boot 为各种 Kubernetes 环境提供的针对特定配置文件的简化方法。此下一步将增强您根据部署环境动态管理应用程序行为的能力，进一步定制应用程序的功能以满足不同的运营需求。
- en: Utilizing profile-specific configurations in Kubernetes
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中利用特定配置文件配置
- en: In the realm of application deployment, customizing your app to behave differently
    in settings, such as development, testing, and production, is not just helpful;
    it’s essential. Spring Boot simplifies this process by offering profile configurations
    that let you set up configurations based on the profile. When used alongside Kubernetes,
    this functionality opens up a level of adaptability and versatility for your deployments.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序部署的领域，根据设置（如开发、测试和生产）定制应用程序以表现出不同的行为不仅是有帮助的；这是至关重要的。Spring Boot 通过提供基于配置文件的配置来简化此过程，允许您根据配置文件设置配置。当与
    Kubernetes 一起使用时，此功能为您的部署提供了适应性和多功能性。
- en: With profile configurations in Spring Boot, you can organize your app properties
    into files specific to each environment. For example, you could have `application-prod.properties`
    for production settings and `application-test.properties` for test environment
    settings. This segregation allows you to manage environment configurations such
    as database URLs, external service endpoints, and feature toggles separately reducing
    the risk of configuration mix-ups between environments.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 中，通过配置文件，你可以将你的应用程序属性组织成针对每个环境的特定文件。例如，你可以有 `application-prod.properties`
    用于生产设置和 `application-test.properties` 用于测试环境设置。这种分离允许你分别管理环境配置，如数据库 URL、外部服务端点和功能开关，从而降低环境配置混淆的风险。
- en: 'Let’s consider an example where your Spring Boot application needs to return
    a different message from the `/message` endpoint based on whether it’s running
    in a test or production environment:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，其中你的 Spring Boot 应用程序需要根据它是在测试或生产环境中运行来从 `/message` 端点返回不同的消息：
- en: 'First off, let’s define our configurations for test and prod environments:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义测试和生产环境的配置：
- en: '`application-test.properties`: This is intended for the test environment:'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application-test.properties`：这是为测试环境设计的：'
- en: '[PRE19]'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`application-prod.properties`: This is intended for the production environment:'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application-prod.properties`：这是为生产环境设计的：'
- en: '[PRE20]'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '2.  To leverage these profiles within Kubernetes, you can set an environment
    variable in your deployment configuration that Spring Boot automatically recognizes
    to activate a specific profile:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  要在 Kubernetes 中利用这些配置文件，你可以在部署配置中设置一个环境变量，Spring Boot 会自动识别以激活特定的配置文件：
- en: '[PRE21]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By setting the `SPRING_PROFILES_ACTIVE` environment variable to either prod
    or test, you instruct Spring Boot to activate the corresponding profile and load
    its associated properties.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过设置 `SPRING_PROFILES_ACTIVE` 环境变量为 prod 或 test，你指示 Spring Boot 激活相应的配置文件并加载其关联的属性。
- en: '3.  Now, we need to regenerate our image and restart the Kubernetes cluster:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.  现在，我们需要重新生成我们的镜像并重启 Kubernetes 集群：
- en: '[PRE22]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Deploy your application to Kubernetes with the prod profile activated. Accessing
    the `/message` endpoint should return `SPRING_PROFILES_ACTIVE` value to test and
    redeploy, and the same endpoint should now return **Hello from the Test Environment!**,
    demonstrating the profile-specific behavior in action.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用激活生产配置文件的方式部署你的应用程序到 Kubernetes。访问 `/message` 端点应返回 `SPRING_PROFILES_ACTIVE`
    值以进行测试和重新部署，而相同的端点现在应返回 **来自测试环境的问候！**，展示了配置特定行为的实际应用。
- en: After exploring the profile-based configurations, let’s take a moment to reflect
    on the journey we’ve been on and how these features aligned with Kubernetes can
    benefit you and your Spring Boot applications. This method not only simplifies
    the handling of environment settings but also boosts your application’s adaptability
    and reliability across different deployment scenarios.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索基于配置文件配置之后，让我们花点时间反思我们所走过的旅程以及这些功能如何与 Kubernetes 结合，从而为你和你的 Spring Boot 应用程序带来好处。这种方法不仅简化了环境设置的处理，还提高了应用程序在不同部署场景下的适应性和可靠性。
- en: In this section, we’ve discussed how the innovative features of Spring Boot
    3.0 can seamlessly merge with Kubernetes to improve the deployment, configuration,
    and management of applications. We looked into utilizing Kubernetes probes for
    application health monitoring, managing configurations and secrets to protect
    data, and adapting to various environments effortlessly with profile-specific
    settings. These capabilities not only streamline deployment but also strengthen
    the resilience and flexibility of applications in the Kubernetes environment.
    With its native support for Kubernetes, Spring Boot 3.0 empowers developers to
    make use of container orchestration to ensure that applications can be deployed
    at scale while remaining maintainable and secure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了 Spring Boot 3.0 的创新功能如何无缝地与 Kubernetes 结合，以改进应用程序的部署、配置和管理。我们探讨了利用
    Kubernetes 探针进行应用程序健康监控、管理配置和机密以保护数据，以及通过配置特定设置轻松适应各种环境。这些功能不仅简化了部署，还增强了应用程序在
    Kubernetes 环境中的弹性和灵活性。凭借其对 Kubernetes 的原生支持，Spring Boot 3.0 使开发者能够利用容器编排来确保应用程序可以大规模部署，同时保持可维护性和安全性。
- en: Now that your Spring Boot applications are primed for performance in Kubernetes,
    our upcoming section will focus on monitoring these applications. The integration
    is designed to be user friendly, offering assistance for keeping track of and
    analyzing data in Kubernetes settings. This ensures that you have the information
    to enhance performance and dependability.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的 Spring Boot 应用程序已经为在 Kubernetes 中的性能做好了准备，我们接下来的部分将专注于监控这些应用程序。该集成旨在易于使用，提供在
    Kubernetes 设置中跟踪和分析数据的帮助。这确保了你拥有提高性能和可靠性的信息。
- en: Spring Boot Actuator with Prometheus and Grafana
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator 与 Prometheus 和 Grafana
- en: In the realm of Kubernetes, where applications are dynamically handled across
    a group of containers, the significance of monitoring and metrics cannot be emphasized
    enough. These insights act as the heartbeat for your applications, signaling their
    health, performance, and efficiency. Without them, you’re navigating blindly through
    a maze of complexity, unable to detect or resolve issues that could impact your
    application’s reliability or user experience. Monitoring and metrics empower developers
    and operations teams with the visibility to ensure that applications are not just
    surviving but thriving in their Kubernetes environment.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 的领域，应用程序在容器组中动态处理，监控和指标的重要性不容忽视。这些洞察是应用程序的心跳，标志着其健康、性能和效率。没有它们，你就像在复杂的迷宫中盲目导航，无法检测或解决可能影响应用程序可靠性和用户体验的问题。监控和指标赋予开发者和运维团队可见性，确保应用程序不仅在
    Kubernetes 环境中生存，而且蓬勃发展。
- en: Introducing **Spring Boot Actuator**, a tool in every developer’s arsenal for
    revealing a wealth of details about your application. Actuator endpoints provide
    a peek into the workings of your application by offering real-time metrics, health
    checks, and more. These insights are priceless for maintaining an application
    state, identifying problems before they escalate, and optimizing performance to
    meet requirements. With Spring Boot Actuator at your disposal, you acquire an
    understanding of how your application behaves and its current status – for effective
    monitoring within Kubernetes setups.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍 **Spring Boot Actuator**，这是每个开发者工具箱中用于揭示应用程序丰富细节的工具。Actuator 端点通过提供实时指标、健康检查等功能，让你窥视应用程序的工作原理。这些洞察对于维护应用程序状态、在问题升级之前识别问题以及优化性能以满足要求是无价的。有了
    Spring Boot Actuator，你就能了解应用程序的行为及其当前状态，这对于在 Kubernetes 设置中进行有效监控至关重要。
- en: Let’s explore how Spring Boot Actuator furnishes the required endpoints for
    Prometheus to gather data, paving the way for monitoring capabilities. This groundwork
    will help us unlock the capabilities of Prometheus and Grafana and develop a monitoring
    system that brings clarity to managing applications on a scale.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 Spring Boot Actuator 如何为 Prometheus 提供所需端点以收集数据，为监控能力铺平道路。这些基础工作将帮助我们解锁
    Prometheus 和 Grafana 的功能，并开发一个能够清晰管理大规模应用程序的监控系统。
- en: Integrating Prometheus for metrics collection
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 集成 Prometheus 进行指标收集
- en: '**Prometheus** plays a role in monitoring within the Kubernetes ecosystem,
    serving as a tool for keeping tabs on the well-being and efficiency of applications
    and infrastructure. Its capacity to gather and consolidate metrics is invaluable,
    particularly when combined with the Actuator endpoints of Spring Boot. These endpoints
    reveal information that Prometheus can gather to present a thorough overview of
    an application’s operational condition.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prometheus** 在 Kubernetes 生态系统中的监控中扮演着角色，作为监控应用程序和基础设施健康和效率的工具。它收集和整合指标的能力非常宝贵，尤其是与
    Spring Boot 的 Actuator 端点结合使用时。这些端点揭示了 Prometheus 可以收集的信息，以提供一个关于应用程序操作状况的全面概述。'
- en: 'To integrate Prometheus with a Spring Boot application, you need to configure
    Prometheus to recognize and scrape the Actuator metrics endpoints. Here’s a practical
    guide to setting this up, utilizing Kubernetes ConfigMaps and deployments:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Prometheus 集成到 Spring Boot 应用程序中，你需要配置 Prometheus 以识别和抓取 Actuator 指标端点。以下是一个使用
    Kubernetes ConfigMaps 和部署设置此环境的实用指南：
- en: 'Firstly, we need to update our Spring Boot application. We will add a new library
    to our `gradle.build` file:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要更新我们的 Spring Boot 应用程序。我们将在 `gradle.build` 文件中添加一个新的库：
- en: '[PRE23]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '2.  Then, we need to add `prometheus` in the `web.exposure` list to enable
    the Prometheus Actuator endpoint in the `application.properties` file:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 然后，我们需要在 `application.properties` 文件中将 `prometheus` 添加到 `web.exposure` 列表中，以启用
    Prometheus Actuator 端点：
- en: '[PRE24]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '3.  Start by defining a `ConfigMap` resource that contains your Prometheus
    configuration. This includes specifying the scrape interval and the targets from
    which Prometheus should collect metrics. Here’s how `prometheus-config.yaml` looks:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3. 首先定义一个包含你的 Prometheus 配置的 `ConfigMap` 资源。这包括指定抓取间隔和 Prometheus 应从哪些目标收集指标。以下是
    `prometheus-config.yaml` 的样子：
- en: '[PRE25]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This configuration instructs Prometheus to scrape metrics from your Spring Boot
    application’s Actuator Prometheus endpoint every 15 seconds.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此配置指示 Prometheus 每 15 秒从你的 Spring Boot 应用程序的 Actuator Prometheus 端点抓取指标。
- en: 4.  With the `ConfigMap` in place, deploy the Prometheus server using `prometheus-deployment.yaml`.
    This deployment specifies the Prometheus server image, ports, and volume mounts,
    to use the previously created `ConfigMap` for configuration.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4. 在 `ConfigMap` 就位后，使用 `prometheus-deployment.yaml` 部署 Prometheus 服务器。此部署指定了
    Prometheus 服务器镜像、端口和卷挂载，以使用之前创建的 `ConfigMap` 进行配置。
- en: 'First, we need to define the deployment part of this Kubernetes pod as follows:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们需要定义这个 Kubernetes 容器部署的部分如下：
- en: '[PRE26]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can continue with the load balancer part of this pod as follows:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以继续定义这个容器的负载均衡部分如下：
- en: '[PRE27]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this YAML file, we have defined a Kubernetes pod that can run Prometheus
    image in it, and serve it in port `9090`.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过此 YAML 文件，我们定义了一个 Kubernetes 容器，可以在其中运行 Prometheus 镜像，并通过端口 `9090` 提供服务。
- en: '5.  Apply the configuration to your Kubernetes cluster with the following commands:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 5. 使用以下命令将配置应用到你的 Kubernetes 集群中：
- en: '[PRE28]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These commands create the necessary ConfigMap and deploy Prometheus within your
    cluster, setting it up to automatically scrape metrics from your Spring Boot application.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些命令创建了必要的 ConfigMap 并在集群内部署 Prometheus，设置它自动从你的 Spring Boot 应用程序中抓取指标。
- en: Having Prometheus collect metrics is just the first step toward gaining actionable
    insights into your application’s performance. The real magic happens when we visualize
    this data, making it accessible and understandable. Next, we’ll explore how Grafana
    can be used to create compelling visualizations of the metrics collected by Prometheus,
    transforming raw data into valuable insights that drive decision making and optimization.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 收集指标只是获取关于应用程序性能的可操作见解的第一步。真正的魔法发生在我们将这些数据可视化时，使其易于访问和理解。接下来，我们将探讨如何使用
    Grafana 创建 Prometheus 收集的指标的引人入胜的可视化，将原始数据转化为推动决策和优化的有价值的见解。
- en: Visualizing metrics with Grafana
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Grafana 可视化指标
- en: '**Grafana** acts like a beacon guiding us through the ocean of metrics generated
    by today’s applications. It’s more than a tool. It’s a platform that turns metrics
    data into valuable insights with its versatile dashboards. Grafana supports data
    sources, including Prometheus, and excels in creating queries, setting up alerts,
    and presenting data in diverse formats. Whether you’re tracking system health,
    user behavior, or app performance, Grafana offers the clarity and instant information
    needed for making decisions.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grafana** 像一座灯塔，引导我们穿越今天应用程序产生的指标海洋。它不仅仅是一个工具。它是一个平台，通过其多功能的仪表板将指标数据转化为有价值的见解。Grafana
    支持包括 Prometheus 在内的数据源，并在创建查询、设置警报以及以多种格式展示数据方面表现出色。无论你是跟踪系统健康、用户行为还是应用程序性能，Grafana
    都提供了做出决策所需的清晰度和即时信息。'
- en: 'To leverage Grafana for monitoring your Spring Boot application metrics, you’ll
    start by deploying Grafana in your Kubernetes cluster:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用 Grafana 监控你的 Spring Boot 应用程序指标，你将首先在 Kubernetes 集群中部署 Grafana：
- en: 'Create a `grafana-deployment.yaml` file that defines the Grafana deployment
    and service in Kubernetes. This deployment will run Grafana and expose it through
    `LoadBalancer`, making the Grafana UI accessible:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `grafana-deployment.yaml` 文件，该文件定义了 Kubernetes 中的 Grafana 部署和服务。此部署将运行
    Grafana，并通过 `LoadBalancer` 暴露它，使 Grafana UI 可访问：
- en: '[PRE29]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This configuration will help us to create a `grafana` instance and make it accessible
    over port `3000`.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此配置将帮助我们创建一个 `grafana` 实例，并通过端口 `3000` 使其可访问。
- en: '2.  Apply this configuration with the following command:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 使用以下命令应用此配置：
- en: '[PRE30]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Navigate to `http://prometheus-service:9090` Prometheus service since Prometheus
    is deployed within the same Kubernetes cluster. Save and test the connection to
    ensure Grafana can communicate with Prometheus.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `http://prometheus-service:9090` Prometheus 服务，因为 Prometheus 部署在同一 Kubernetes
    集群中。保存并测试连接，以确保 Grafana 可以与 Prometheus 通信。
- en: With Prometheus configured as a data source, you can now create dashboards in
    Grafana to visualize your Spring Boot application metrics. Start by clicking `12900`
    ID for **SpringBoot APM Dashboard** and select the data source you created for
    Prometheus. That’s it! You have a wide range dashboard to monitor your application.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Prometheus作为数据源后，您现在可以在Grafana中创建仪表板来可视化您的Spring Boot应用程序指标。首先点击`12900` ID的**SpringBoot
    APM仪表板**，然后选择您为Prometheus创建的数据源。就这样！您拥有一个广泛的仪表板来监控您的应用程序。
- en: '![Figure 7.1: Sample visualization that demonstrates how the dashboard will
    appear](img/B18400_07_01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：展示仪表板外观的示例可视化](img/B18400_07_01.jpg)'
- en: 'Figure 7.1: Sample visualization that demonstrates how the dashboard will appear'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：展示仪表板外观的示例可视化
- en: In *Figure 7**.1*, the Grafana dashboard showcases the performance metrics of
    a Spring Boot application visually. **SpringBoot APM Dashboard** is designed with
    panels that are easy to understand, displaying information at a glance. At the
    top, you can view statistics, such as uptime and memory usage gauges, which offer
    a snapshot of system health. Below are graphs and charts that illustrate CPU usage
    and JVM memory statistics, providing insights into the application’s performance.
    The dashboard utilizes gauges, bar charts, and line graphs to present data in
    a user-friendly manner, enabling users to monitor and analyze the application’s
    behavior over time without complexity overload.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图7.1**中，Grafana仪表板以可视化的方式展示了Spring Boot应用程序的性能指标。**SpringBoot APM仪表板**设计有易于理解的面板，可以一目了然地显示信息。在顶部，您可以查看统计信息，如正常运行时间和内存使用仪表，它们提供了系统健康状况的快照。下面是展示CPU使用和JVM内存统计信息的图表和图形，提供了对应用程序性能的洞察。仪表板利用仪表、柱状图和折线图以用户友好的方式呈现数据，使用户能够监控和分析应用程序随时间的行为，而不会感到复杂过载。
- en: Having discussed collection and visualization techniques, let’s explore scenarios
    where these insights can enhance your application’s performance and reliability.
    By leveraging Grafana dashboards, we can shift from a reactive approach to a proactive
    approach in managing our Spring Boot apps to ensure optimal performance within
    Kubernetes environments.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了收集和可视化技术之后，让我们探索这些洞察如何增强您应用程序的性能和可靠性。通过利用Grafana仪表板，我们可以从反应式方法转变为主动式方法来管理我们的Spring
    Boot应用程序，以确保在Kubernetes环境中达到最佳性能。
- en: During our exploration of application monitoring, we have emphasized the need
    to closely monitor our applications, especially when they are operating within
    the environment of Kubernetes. The Spring Boot Actuator has emerged as a tool
    that provides us with a way to examine the signs of our applications. When combined
    with Prometheus, this duo acts as an observer collecting metrics that offer a
    view of how our applications are functioning.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索应用程序监控的过程中，我们强调了密切监控我们应用程序的必要性，尤其是在它们在Kubernetes环境中运行时。Spring Boot Actuator已成为一个提供我们检查应用程序迹象的工具。当与Prometheus结合使用时，这对组合充当观察者，收集提供应用程序运行视图的指标。
- en: Integrating Grafana completes our monitoring trio by transforming the data gathered
    by Prometheus into stories that illustrate the performance and health of our applications.
    Through user dashboards, we not only have the ability to observe but also to interact
    with our metrics in depth, delving into patterns that inform our proactive actions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成Grafana，我们将Prometheus收集的数据转化为展示应用程序性能和健康状况的故事，从而完成了我们的监控三重奏。通过用户仪表板，我们不仅能够观察，而且能够深入交互我们的指标，深入挖掘指导我们主动行动的模式。
- en: As we consider the tools available to us, we realize that we are not just equipped
    for monitoring; we are empowered to predict, adjust, and ensure that our Kubernetes
    deployments operate optimally. The concrete advantages of this integrated monitoring
    strategy – such as improved visibility, quicker response times, and a deeper insight
    into application behavior – are assets in our efforts to deliver resilient and
    reliable applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑可用的工具时，我们意识到我们不仅配备了监控工具；我们还获得了预测、调整并确保我们的Kubernetes部署以最佳状态运行的能力。这种集成监控策略的具体优势——如提高可见性、更快的响应时间以及对应用程序行为的更深入洞察——是我们努力提供弹性可靠应用程序的资产。
- en: Summary
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: As we wrap up this chapter, on the Spring Boot 3.0 features for containerization
    and orchestration, we can say that it has been quite a journey of learning and
    honing skills. This chapter not only highlighted the role of containerization
    and orchestration in software development but also equipped you with the necessary
    tools and knowledge to effectively utilize these technologies.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章关于Spring Boot 3.0容器化和编排特性的讨论时，可以说这是一段学习与技能提升的旅程。本章不仅强调了容器化和编排在软件开发中的作用，而且还为您提供了有效利用这些技术的必要工具和知识。
- en: 'Let’s recap the valuable insights and skills you’ve acquired:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下您所获得的有价值见解和技能：
- en: '**Understanding the essentials of containerization**: We began by delving into
    the concept of containerization and learned how to bundle our Spring Boot applications
    into containers for portability and efficiency'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解容器化的基本知识**: 我们从深入了解容器化概念开始，学习了如何将我们的Spring Boot应用程序打包到容器中，以实现可移植性和效率'
- en: '**Mastering Docker with Spring Boot**: We have discussed how to create and
    manage Docker images for our Spring Boot applications, making them ready for any
    environment while emphasizing the ease of deployment and lightweight nature of
    containers'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**掌握Docker与Spring Boot**: 我们已经讨论了如何为我们的Spring Boot应用程序创建和管理Docker镜像，使它们在任何环境中都准备就绪，同时强调部署的简便性和容器轻量级的特性'
- en: '**Orchestrating containers with Kubernetes**: We have learned how to deploy
    and manage our Dockerized Spring Boot applications using Kubernetes, highlighting
    the platform’s ability to scale and maintain application health'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Kubernetes编排容器**: 我们已经学习了如何使用Kubernetes部署和管理我们的Docker化Spring Boot应用程序，突出了该平台的可扩展性和维护应用程序健康的能力'
- en: '**Monitoring with Prometheus and Grafana**: Finally, we explored how to set
    up Prometheus for metrics collection and Grafana for visualization, ensuring you
    can monitor your applications’ performance and swiftly respond to any issues'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Prometheus和Grafana进行监控**: 最后，我们探讨了如何设置Prometheus进行指标收集和Grafana进行可视化，确保您能够监控应用程序的性能并迅速响应任何问题'
- en: These abilities and expertise are extremely valuable in today’s tech landscape,
    allowing you to create applications that are not only robust and adaptable but
    also easy to maintain and efficient across different platforms. Having a grasp
    of containerization and orchestration principles lays the groundwork for developing
    cutting-edge cloud-native applications.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些能力和专业知识在当今的技术领域中极为宝贵，使您能够创建不仅强大且适应性强的应用程序，而且易于维护和在不同平台上高效运行。掌握容器化和编排原则为开发前沿的云原生应用程序奠定了基础。
- en: As we look forward to the next chapter, we’ll delve into the integration of
    Kafka with Spring Boot to build responsive, scalable event-driven systems.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们期待下一章，我们将深入研究Kafka与Spring Boot的集成，以构建响应式、可扩展的事件驱动系统。
- en: Transitioning from the realm of containerization and orchestration to event-driven
    design opens up opportunities for you to enhance your skill set, further tackling
    the challenges and advantages of software development. The next chapter is anticipated
    to be another stride in your journey toward mastering Spring Boot and its ecosystem.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器化和编排领域过渡到事件驱动设计，为您提供了提升技能集、进一步应对软件开发挑战和优势的机会。下一章预计将是您在掌握Spring Boot及其生态系统旅程中的又一重要步骤。
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
