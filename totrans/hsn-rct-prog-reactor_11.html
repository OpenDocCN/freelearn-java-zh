<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 1: Getting Started with Reactive Streams</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the principles of the Reactive Manifesto?</li>
</ol>
<p style="padding-left: 60px">The Reactive Manifesto defines the following principles:</p>
<ul>
<li><strong>Message-Driven</strong>: All application components should be loosely coupled and communicate using messages</li>
<li><strong>Responsive</strong>: An application must respond to user input in a timely manner</li>
<li><strong>Resilient</strong>: An application must isolate failures to individual components</li>
<li><strong>Scalable</strong>: An application must react to changes in workload</li>
</ul>
<ol start="2">
<li>What are Reactive Extensions?</li>
</ol>
<p style="padding-left: 60px">Reactive Extensions are libraries in imperative languages that enables us to write asynchronous, event-driven reactive applications. The libraries enable us to express asynchronous events as a set of observables. This enables us to build application components that can receive and process these async events. On the other hand, there are also event producers, which push these events.</p>
<ol start="3">
<li>What does the Reactive Streams specification cater to?</li>
</ol>
<p style="padding-left: 60px"><span>Reactive Streams is a specification</span> that determines the minimum set of interfaces required to build the asynchronous processing of a large volume of unbounded data. It is a specification aimed at JVM and JavaScript runtime. The main goal of the Reactive Streams specification is to standardize the exchange of stream data across an asynchronous boundary of applications.</p>
<p class="mce-root"/>
<ol start="4">
<li>What are the principles upon which Reactive Streams are based?</li>
</ol>
<p style="padding-left: 60px">Reactive Streams are based on the following two principles:</p>
<ul>
<li><strong>Asynchronous execution</strong>: This is the ability to execute tasks without having to wait for previously executed tasks to finish first. The execution model decouples tasks so that each of them can be performed simultaneously, utilizing the available hardware.</li>
<li><strong>Backpressure</strong>: A subscriber can control events in its queue to avoid any overruns. It can also request more events if there is additional capacity.</li>
</ul>
<ol start="5">
<li>What are the salient features of the Reactor Framework?</li>
</ol>
<ul>
<li><strong>Infinite data streams</strong>: This refers to Reactor's capability of generating infinite sequences of data.</li>
<li><strong>Push-pull model</strong>: In Reactor, a producer can push events. On the other hand, if the consumer is slow in processing, it can pull events at its own rate.</li>
<li><strong>Concurrency agnostic</strong>: Reactor does not enforce any concurrency model. It allows a developer to select what fits best.</li>
<li><strong>Operator vocabulary</strong>: Reactor provides a wide range of operators. These operators allow us to select, filter, transform, and combine streams. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 2: The Publisher and Subscriber APIs in a Reactor</h1>
                </header>
            
            <article>
                
<ol>
<li>How can we validate Reactive Streams publisher and subscriber implementations?</li>
</ol>
<p style="padding-left: 60px"><span>In order to validate a publisher, the Reactive Streams API has published a test compatibility kit called</span> <kbd>reactive-streams-tck</kbd>. Reactive publisher can be verified using the <kbd>PublisherVerifier</kbd> interface. Similarly, a subscriber can be verified by using the <kbd>SubscriberBlackboxVerification&lt;T&gt;</kbd> abstract class.</p>
<ol start="2">
<li>How is the Reactive Streams publisher-subscriber model different from the JMS API?</li>
</ol>
<p style="padding-left: 60px">In JMS, the producer is responsible for generating unbounded events on the queue or topics, while the consumer actively consumes the events. The producer and consumer are working in isolation, at their own rates. The task of managing the subscription is taken care of by the JMS broker. There is no concept of backpressure in JMS. Also, it lacks event modeling, such as subscription, error, or completion.</p>
<ol start="3">
<li>How is the Reactive Streams publisher-subscriber model different from the Observer API?</li>
</ol>
<p style="padding-left: 60px">The Observable API has the responsibility of determining a change and publishing it to all interested parties. The API is about entity state changes. This is not what we are modeling with the <kbd>Publisher</kbd> and <kbd>Subscriber</kbd> interface. The <kbd>Publisher</kbd> interface is responsible for generating unbounded events. The <kbd>Subscriber</kbd>, on the other hand, lists all kinds of events, such as data, error, and completion.</p>
<ol start="4">
<li>What is the difference between Flux and Mono?</li>
</ol>
<p style="padding-left: 60px"><kbd>Flux</kbd> is a general-purpose reactive publisher. It represents a stream of asynchronous events with zero or more values. On the other hand, Mono can only generate a maximum of one event. </p>
<ol start="5">
<li>What is the difference between <kbd>SynchronousSink</kbd> and <kbd>FluxSink</kbd>?</li>
</ol>
<p style="padding-left: 60px"><kbd>SynchronousSink</kbd> can generate only one event at a time. It is synchronous in nature. A subscriber must consume the event before generating the next event. On the other hand, <kbd>FluxSink</kbd> can generate many events asynchronously. Moreover, it does not take subscription cancelation or backpressure into account. This means that even if the subscriber has canceled its subscription, the <kbd>create</kbd> API will continue to generate events.</p>
<ol start="6">
<li>What are the different lifecycle hooks available in Reactor?</li>
</ol>
<ul>
<li><kbd>doOnSubscribe</kbd>: For the subscribe event</li>
<li><kbd>doOnRequest</kbd>: For the request event</li>
<li><kbd>doOnNext</kbd>: For the next event</li>
<li><kbd>doOnCancel</kbd>: For the subscription cancel event</li>
<li><kbd>doOnError</kbd>: For an error event</li>
<li><kbd>doOnCompletion</kbd>: For completion event</li>
<li><kbd>doOnTerminate</kbd>: For termination due to error, completion, or cancelation</li>
<li><kbd>doFinally</kbd>: For clean-up post termination of a stream</li>
<li><kbd>doOnEach</kbd>: For all events</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 3: Data and Stream Processing</h1>
                </header>
            
            <article>
                
<ol>
<li>Which operator is used to select data elements from a stream?</li>
</ol>
<ul>
<li><kbd>filter</kbd></li>
<li><kbd>filterWhen</kbd></li>
<li><kbd>take</kbd></li>
<li><kbd>takeLast</kbd></li>
<li><kbd>last</kbd></li>
<li><kbd>distinct</kbd></li>
<li><kbd>single</kbd></li>
<li><kbd>elementAT</kbd></li>
</ul>
<ol start="2">
<li>Which operator is used to reject data elements from a stream?</li>
</ol>
<ul>
<li><kbd>filter</kbd></li>
<li><kbd>filterWhen</kbd></li>
<li><kbd>skip</kbd></li>
<li><kbd>skipLast</kbd></li>
<li><kbd>SkipUntil</kbd></li>
<li><kbd>ignoreElements</kbd></li>
</ul>
<ol start="3">
<li>Which operators does Reactor offer for data conversion? How are these operators different from each other?</li>
</ol>
<ul>
<li><kbd>map</kbd>: This is used for one-to-one transformation</li>
<li><kbd>flatMap</kbd>: This is used for one-to-n transformation</li>
</ul>
<ol start="4">
<li>How can we perform data aggregation by using Reactor operators?</li>
</ol>
<ul>
<li><kbd>collectList</kbd></li>
<li><kbd>collectMap</kbd></li>
<li><kbd><kbd>collectMultiMap</kbd></kbd></li>
</ul>
<ol start="5">
<li>Which conditional operators are offered by Reactor? </li>
</ol>
<ul>
<li><kbd>all</kbd>: Represents the <kbd>AND</kbd> operator</li>
<li><kbd>any</kbd>: Represents the <kbd>OR</kbd> operator</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 4: Processors</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the limitations of <kbd>DirectProcessor</kbd>?</li>
</ol>
<p style="padding-left: 60px"><kbd>DirectProcessor</kbd> does not offer any backpressure handling.</p>
<ol start="2">
<li>What are the limitations of <kbd>UnicastProcessor</kbd>?</li>
</ol>
<p style="padding-left: 60px"><span><kbd>UnicastProcessor</kbd> can work with only a single subscriber.</span></p>
<ol start="3">
<li>What are the capabilities of <kbd>EmitterProcessor</kbd>?</li>
</ol>
<p style="padding-left: 60px"><kbd>EmitterProcessor</kbd> is a processor that can be used with several subscribers. Multiple subscribers can ask the processor for the next value event, based on their individual rates of consumption</p>
<ol start="4">
<li>What are the <span>capabilities </span>of <kbd>ReplayProcessor</kbd>?</li>
</ol>
<p style="padding-left: 60px"><kbd>ReplayProcessor</kbd> is a special-purpose processor, capable of caching and replaying events to its subscribers.</p>
<ol start="5">
<li>What are the <span>capabilities</span><span> </span>of <kbd>TopicProcessor</kbd>?</li>
</ol>
<p style="padding-left: 60px"><kbd>TopicProcessor</kbd> is a processor capable of working with multiple subscribers, using an event-loop architecture. The processor delivers events from a publisher to the attached subscribers in an asynchronous manner and honors backpressure for each subscriber by using the RingBuffer data structure.</p>
<ol start="6">
<li>What are the <span>capabilities</span><span> </span>of <kbd>WorkQueueProcessor</kbd>?</li>
</ol>
<p style="padding-left: 60px"><kbd>WorkQueueProcessor</kbd> can connect to multiple subscribers. It does not deliver all events to each subscriber. The demand from every subscriber is added to a queue and events from a publisher are sent to any of the subscribers.</p>
<ol start="7">
<li>What is the difference between a hot publisher and a cold publisher?</li>
</ol>
<p style="padding-left: 60px">Cold publishers have an individual subscription state for each subscriber. They publish all data to each of the subscribers irrespective of the subscription time. On the other hand, a hot publisher publishes common data to all its subscribers. Thus, new subscribers get only the current events and no older events are delivered to them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 5: SpringWebFlux for Microservices</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">How can we configure the <kbd>SpringWebFlux</kbd> project?</li>
</ol>
<p class="mce-root" style="padding-left: 60px"><span><kbd>SpringWebFlux</kbd> </span>can be configured in two ways :</p>
<ul>
<li><strong>Using annotations</strong>: <kbd>SpringWebFlux</kbd> supports <kbd>SpringWebMVC</kbd> annotations. This is the easiest way of configuring <kbd>SpringWebFlux</kbd>.</li>
<li><strong>Using functional endpoints</strong>: This model allows us to build Java 8 functions as web endpoints. The application can be configured as a set of routes, handlers, and filters.</li>
</ul>
<ol start="2">
<li class="mce-root">Which <kbd>MethodParameter</kbd> annotations are supported by <kbd>SpringWebFlux</kbd>?</li>
</ol>
<ul>
<li class="mce-root"><kbd>@PathVariable</kbd>: This annotation is used to access values for URI template variables</li>
<li class="mce-root"><kbd>@RequestParam</kbd>: This annotation is used to determine values passed as query parameters</li>
<li class="mce-root"><kbd>@RequestHeader</kbd>: This annotation is used to determine values passed in request headers</li>
<li class="mce-root"><kbd>@RequestBody</kbd>: This annotation is used to determine values passed in the request body</li>
<li class="mce-root"><kbd>@CookieValue</kbd>: This annotation is used to determine HTTP cookie values as part of request</li>
<li class="mce-root"><kbd>@ModelAttribute</kbd>: This annotation is used to determine an attribute from the request model or instantiate one if not present</li>
<li class="mce-root"><kbd>@SessionAttribute</kbd>: This annotation is used to determine preexisting session attributes</li>
<li class="mce-root"><kbd>@RequestAttribute</kbd>: This annotation is used to determine preexisting request attributes created by a previous filter execution</li>
</ul>
<ol start="3">
<li class="mce-root">What is the use of <kbd>ExceptionHandler</kbd>?</li>
</ol>
<p class="mce-root" style="padding-left: 60px"><kbd>SpringWebFlux</kbd> supports exception handling by creating methods that are annotated with <kbd>@ExceptionHandler</kbd>.</p>
<ol start="4">
<li class="mce-root">What is the use of <kbd>HandlerFunction</kbd> ?</li>
</ol>
<p style="padding-left: 60px"><span><kbd>SpringWebFlux</kbd> </span>handler function is responsible for serving a given request. It takes the request in the form of a <kbd>ServerRequest</kbd> class and generates the response as <kbd>ServerResponse</kbd>.</p>
<ol start="5">
<li class="mce-root">What is the use of <kbd>RouterFunction</kbd> ?</li>
</ol>
<p class="mce-root" style="padding-left: 60px"><kbd>SpringWebFlux</kbd> router function is responsible for routing incoming requests to the correct handler function.</p>
<ol start="6">
<li class="mce-root">What is the use of <kbd>HandlerFilter</kbd> ?</li>
</ol>
<p style="padding-left: 60px"><kbd>HandlerFilter</kbd> is analogous to the Servlet filter. This executes before the request gets processed by <kbd>HandlerFunction</kbd>. There could be chain filters, which get executed before the request gets served.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 6: Dynamic Rendering</h1>
                </header>
            
            <article>
                
<ol>
<li>How does the <kbd>SpringWebFlux</kbd> framework resolve a View?</li>
</ol>
<p style="padding-left: 60px">The framework invokes <kbd>ViewResolutionResultHandler</kbd> using the <kbd>HandlerResult</kbd> returned for the endpoint invocation. <kbd>ViewResolutionResultHandler</kbd> then determines the correct view by validating the returned value for the following:</p>
<ul>
<li><strong>String</strong>: If the returned value is a string, then the framework builds a view using the configured <kbd>ViewResolvers</kbd></li>
<li><strong>Void</strong>: If nothing is returned, it then tries to build the default view</li>
<li><strong>Map</strong>: The framework looks for the default view but it also adds the key values returned into the request model</li>
</ul>
<p style="padding-left: 60px"><kbd>ViewResolutionResultHandler</kbd> looks up the content type passed in the request. In order to determine which view should be used, it compares the content type passed to the content type supported by <kbd>ViewResolver</kbd>. It then selects the first <kbd>ViewResolver</kbd>, which supports the request content type.</p>
<p class="mce-root"/>
<ol start="2">
<li>Which components need to be configured so you can use the Thymeleaf template engine?</li>
</ol>
<ul>
<li> Add <kbd>spring-boot-starter-thymeleaf</kbd> to the project</li>
<li>Create an instance of <kbd>ThymeleafReactiveViewResolver</kbd></li>
<li>Add the resolver to <kbd>ViewResolverRegistry</kbd>, available in the <kbd>configureViewResolvers</kbd> method</li>
</ul>
<ol start="3">
<li>Which API is used to configure static resources in SpringWebFlux?</li>
</ol>
<ul>
<li>The <kbd>addResourceHandler</kbd> method takes a URL pattern and configures it to be a static location</li>
<li>The <kbd>addResourceLocations</kbd> method configures a location from where the static content needs to be served</li>
</ul>
<ol start="4">
<li>What are the benefits of <kbd>WebClient</kbd>?</li>
</ol>
<p style="padding-left: 60px"> <kbd>WebClient</kbd> is a non-blocking, asynchronous HTTP client for making requests. It can be configured with Java 8 lambdas for processing data.</p>
<ol start="5">
<li>What is the difference between the retrieve and exchange APIs of WebClient?</li>
</ol>
<ul>
<li><kbd>Retrieve</kbd>: This can decode a request body into a Flux or Mono</li>
<li><kbd>Exchange</kbd>: The <kbd>Exchange</kbd> method provides the complete message, which can be converted back into a target type</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 7: Flow Control and Backpressure</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Why do we need the <kbd>groupBy</kbd> operator?</li>
</ol>
<p class="mce-root" style="padding-left: 60px">The <kbd>groupBy()</kbd> operator converts <kbd>Flux&lt;T&gt;</kbd> into batches. The operator associates a key with each element of <kbd>Flux&lt;T&gt;</kbd>. It then groups elements that have the same key. These groups are then emitted by the operator. </p>
<ol start="2">
<li class="mce-root">What is the difference between the <kbd>groupBy</kbd> and <kbd>buffer</kbd> operators?</li>
</ol>
<p class="mce-root" style="padding-left: 60px">The <kbd>groupBy</kbd> operator groups the stream of events based on a configured key, but the <kbd>buffer</kbd> operator splits the stream into chunks of a specified size. Thus, the <kbd>buffer</kbd> operator maintains the original ordering of events.</p>
<p class="mce-root"/>
<ol start="3">
<li class="mce-root">How can we throttle an event in Reactor?</li>
</ol>
<p class="mce-root" style="padding-left: 60px">The <kbd>sample()</kbd> operator allows us to accomplish throttling.</p>
<ol start="4">
<li class="mce-root">What is the difference between the <kbd>Overflow.Ignore</kbd> and the <kbd>OverFlow.Latest</kbd> strategies?</li>
</ol>
<p class="mce-root" style="padding-left: 60px"><kbd>Overflow.Ignore</kbd> ignores the limits of the subscriber backpressure and keeps delivering the next event to the subscriber. <kbd><span>OverFlow.Latest</span></kbd> keeps the latest event raised in the buffer. The subscriber will only get the latest produced event when the next request is raised.</p>
<ol start="5">
<li class="mce-root">Which operators are available for changing the backpressure strategy of a producer?</li>
</ol>
<ul>
<li><kbd><span>onBackpressureDrop() </span></kbd></li>
<li><kbd>onBackpressureLatest()</kbd></li>
<li><kbd>onBackpressureError()</kbd></li>
<li><kbd>onBackpressureBuffer()</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 8: Handling Errors</h1>
                </header>
            
            <article>
                
<ol>
<li>How is an error handled in Reactor?</li>
</ol>
<p style="padding-left: 60px">Errors arise when either the publisher or the subscriber throws back an exception. Reactor intercepts the exception, builds an <kbd>Error</kbd> event, and then sends it to the subscriber. The subscriber must implement <kbd>ErrorCallbackHandler</kbd> to handle the error.</p>
<ol start="2">
<li>Which operators allow us to configure error handling?</li>
</ol>
<ul>
<li><kbd>onErrorReturn</kbd></li>
<li><kbd>onErrorResume</kbd></li>
<li><kbd>onErrorMap</kbd></li>
</ul>
<ol start="3">
<li>What is the difference between <kbd>onErrorResume</kbd> and <kbd>onErrorReturn</kbd>?</li>
</ol>
<p style="padding-left: 60px">The <kbd>OnErrorReturn</kbd> operator provides a fall-back value in the event of an error. On the other hand, the <kbd>OnErrorResume</kbd> operator provides a fall-back value stream instead of a single fall-back value.</p>
<ol start="4">
<li>How can we generate a timely response for a Reactive Streams?</li>
</ol>
<p style="padding-left: 60px">The <kbd>timeout()</kbd> operator can be configured for a time interval. The operator will raise an error when it first discovers a delay of more than the configured time. The operator also has a fallback Flux. The fallback value is returned once the timeout expires.</p>
<ol start="5">
<li>How does the <kbd>retry</kbd> operator behave?</li>
</ol>
<p style="padding-left: 60px">The <kbd>retry</kbd> operator allows us to resubscribe to a published stream when an error is discovered. The <kbd>retry</kbd> operation can only be performed a fixed number of times. The resubscribed events are handled as next events by the subscriber. If the stream completes normally, no next retry takes place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 9: Execution Control</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the different types of schedulers available in Reactor?</li>
</ol>
<ul>
<li><kbd>Schedulers.immediate</kbd>: This schedules on the current thread</li>
<li><kbd>Schedulers.single</kbd>: This schedules on a single thread</li>
<li><kbd>Schedulers.parallel</kbd>: This schedules on the thread pool</li>
<li><kbd>Schedulers.elastic</kbd>: This schedules on a thread pool</li>
<li><kbd>Schedulers.fromExecutor</kbd>: This schedules the configured executor service</li>
</ul>
<ol start="2">
<li>Which scheduler should be used for blocking operations?</li>
</ol>
<p style="padding-left: 60px"><kbd>Schedulers.elastic</kbd> schedules on a thread pool.</p>
<ol start="3">
<li>Which scheduler should be used for computation intensive operations?</li>
</ol>
<ul>
<li><kbd>Schedulers.single</kbd>: This schedules on a single thread.</li>
<li><kbd>Schedulers.parallel</kbd>: This schedules on the thread pool</li>
</ul>
<ol start="4">
<li>How are <kbd>PublishOn</kbd> and <kbd>SubscriberOn</kbd> different from each other?</li>
</ol>
<p style="padding-left: 60px">The <kbd>subscribeOn</kbd> operator intercepts events from a publisher in the execution chain and sends them to a different scheduler for the complete chain. It is important to note that the operator changes the execution context for the complete chain, unlike the <kbd>publishOn</kbd> operator, which only alters the execution of a downstream chain.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>What is the limitation of <kbd>ParallelFlux</kbd>?</li>
</ol>
<p style="padding-left: 60px"> <kbd>ParallelFlux</kbd> does not offer the <kbd>doFinally</kbd> lifecycle hook. It can be converted back to a <kbd>Flux</kbd> using the <kbd>sequential</kbd> operator, which can then be configured using the <kbd>doFinally</kbd> hook.</p>
<ol start="6">
<li>Which operators are available for generating a <kbd>ConnectedFlux</kbd>?</li>
</ol>
<ul>
<li><kbd>replay</kbd></li>
<li><kbd>publish</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 10: Testing and Debugging</h1>
                </header>
            
            <article>
                
<ol>
<li>Which test utility class is available in Reactor to validate the invoked operations on a stream?</li>
</ol>
<p class="mce-root" style="padding-left: 60px"><span>Reactor provides the </span><kbd>StepVerifier</kbd><span> component to validate the required operations in isolation.</span></p>
<ol start="2">
<li>What is the difference between <kbd>PublisherProbe</kbd> and <kbd>TestPublisher</kbd>?</li>
</ol>
<p style="padding-left: 60px"><span>The </span><kbd>PublisherProbe</kbd><span> </span><span>utility can instrument an existing publisher. The probe keeps track of signals published by the publisher, which can be validated at the end of the test. On the other hand, <kbd>TestPublisher</kbd> is capable of generating the <kbd>Publisher</kbd> stub, which can be used to unit test Reactor operators. </span></p>
<ol start="3">
<li>How should the virtual clock be configured to validate time-bound operations ?</li>
</ol>
<p style="padding-left: 60px">The virtual clock must be injected before performing any time-based operations. </p>
<ol start="4">
<li>What is the difference between the <kbd>onOperatorDebug</kbd> hook and the <kbd>checkpoint</kbd> operator?</li>
</ol>
<p style="padding-left: 60px">The <kbd>onOperatorDebug</kbd><span> hook makes a global change for all reactive pipelines. On the other hand, the <kbd>checkpoint</kbd> operator makes the change specific to the stream it is applied to.</span></p>
<ol start="5">
<li>How can we turn on the logging of stream processing?</li>
</ol>
<p style="padding-left: 60px">The <kbd>log</kbd> operator can be used to turn on logging.</p>


            </article>

            
        </section>
    </body></html>