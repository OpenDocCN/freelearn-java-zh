<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Basic Operators</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, you learned a lot about the <kbd>Observable</kbd> and <kbd>Observer</kbd>. We also covered a small number of operators, particularly <kbd>map()</kbd> and <kbd>filter()</kbd>, to understand the role of operators as well. But there are hundreds of RxJava operators we can leverage to express business logic and behaviors. We will cover operators comprehensively throughout much of this book, so you know which ones to use and when. Being aware of the operators available and combining them is critical to being successful using ReactiveX. You should strive to use operators to express business logic so your code stays as reactive as possible.</p>
<p>It should be noted that operators themselves are Observers to the <kbd>Observable</kbd> they are called on. If you call <kbd>map()</kbd> on an <kbd>Observable</kbd>, the returned <kbd>Observable</kbd> will subscribe to it. It will then transform each emission and in turn be a producer for Observers downstream, including other operators and the terminal <kbd>Observer</kbd> itself.</p>
<p>You should strive to execute as much logic as possible using RxJava operators, and you should use an <kbd>Observer</kbd> to receive the end product emissions that are ready to be consumed. Try not to cheat or get creative by extracting values out of the <kbd>Observable</kbd> chain, or resort to blocking processes or imperative programming tactics. When you keep algorithms and processes reactive, you can easily leverage the benefits of reactive programming such as lower memory usage, flexible concurrency, and disposability.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Suppressing operators</li>
<li>Transforming operators</li>
<li>Reducing operators</li>
<li>Error-recovery operators</li>
<li>Action operators</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Suppressing operators</h1>
                </header>
            
            <article>
                
<p>There are a number of operators that will suppress emissions that fail to meet a specified criterion. These operators work by simply not calling the <kbd>onNext()</kbd> function downstream for a disqualified emission, and therefore does not go down the chain to <kbd>Observer</kbd>. We have already seen the <kbd>filter()</kbd> operator, which is probably the most common suppressing operator. We will start with this one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">filter()</h1>
                </header>
            
            <article>
                
<p>The  <kbd>filter()</kbd> operator accepts <kbd>Predicate&lt;T&gt;</kbd> for a given <kbd>Observable&lt;T&gt;</kbd>. This means that you provide it a lambda that qualifies each emission by mapping it to a Boolean value, and emissions with false will not go forward.</p>
<p>For instance,  you can use <kbd>filter()</kbd> to only allow string emissions that are not five characters in length:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>      Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>      .</span><span>filter</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>length</span><span>() </span><span>!= </span><span>5</span><span>)<br/></span><span>      </span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>));<br/></span><span>    }<br/></span><span>} </span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: Beta<br/>RECEIVED: Epsilon</pre>
<p>The <kbd>filter()</kbd> function is probably the most commonly used operator to suppress emissions.</p>
<div class="packt_infobox">Note that if all emissions fail to meet your criteria, the returned <kbd>Observable</kbd> will be empty, with no emissions occurring before <kbd>onComplete()</kbd> is called.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">take()</h1>
                </header>
            
            <article>
                
<p>The <kbd>take()</kbd> operator has two overloads. One will take a specified number of emissions and then call  <kbd>onComplete()</kbd> after it captures all of them. It will also dispose of the entire subscription so that no more emissions will occur. For instance, <kbd>take(3)</kbd> will emit the first three emissions and then call the <kbd>onComplete()</kbd> event:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/>      Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>      .</span><span>take</span><span>(</span><span>3</span><span>)<br/></span><span>      .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>s</span><span>));<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: Alpha<br/>    RECEIVED: Beta<br/>    RECEIVED: Gamma</pre>
<p>Note that if you receive fewer emissions than you specify in your <kbd>take()</kbd> function, it will simply emit what it does get and then call the <kbd>onComplete()</kbd> function.</p>
<p>The other overload will take emissions within a specific time duration and then call  <kbd>onComplete()</kbd>. Of course, our cold <kbd>Observable</kbd> here will emit so quickly that it would serve as a bad example for this case. Maybe a better example would be to use an <kbd>Observable.interval()</kbd> function. Let's emit every <kbd>300</kbd> milliseconds, but <kbd>take()</kbd>emissions for only <kbd>2</kbd> seconds in the following code snippet:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>300</span><span>, </span><span>TimeUnit</span><span>.</span><span>MILLISECONDS</span><span>)<br/></span><span>          .</span><span>take</span><span>(</span><span>2</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(i</span><span> </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>       </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>      }<br/></span><span><br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: 0<br/>RECEIVED: 1<br/>RECEIVED: 2<br/>RECEIVED: 3<br/>RECEIVED: 4<br/>RECEIVED: 5</pre>
<p>You will likely get the output that's shown here (each print happening every <kbd>300</kbd> milliseconds). You can only get six emissions in <kbd>2</kbd> seconds if they are spaced out by <kbd>300</kbd> milliseconds.</p>
<p>Note that there is also a <kbd>takeLast()</kbd> operator, which will take the last specified number of emissions (or time duration) before the <kbd>onComplete()</kbd>  function is called. Just keep in mind that it will internally queue emissions until its <kbd>onComplete()</kbd> function is called, and then it can logically identify and emit the last emissions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">skip()</h1>
                </header>
            
            <article>
                
<p>The <kbd>skip()</kbd> operator does the opposite of the <kbd>take()</kbd> operator. It will ignore the specified number of emissions and then emit the ones that follow.  If I wanted to skip the first <kbd>90</kbd> emissions of an <kbd>Observable</kbd>, I could use this operator, as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>100</span><span>)<br/></span><span>          .</span><span>skip</span><span>(</span><span>90</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(i</span><span> </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the following code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: 91<br/>RECEIVED: 92<br/>RECEIVED: 93<br/>RECEIVED: 94<br/>RECEIVED: 95<br/>RECEIVED: 96<br/>RECEIVED: 97<br/>RECEIVED: 98<br/>RECEIVED: 99<br/>RECEIVED: 100</pre>
<p>Just like the <kbd>take()</kbd> operator, there is also an overload accepting a time duration. There is also a <kbd>skipLast()</kbd> operator, which will skip the last specified number of items (or time duration) before the <kbd>onComplete()</kbd> event is called. Just keep in mind that the <kbd>skipLast()</kbd> operator will queue and delay emissions until it confirms the last emissions in that scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">takeWhile() and skipWhile()</h1>
                </header>
            
            <article>
                
<p>Another variant of the <kbd>take()</kbd> operator is the <kbd>takeWhile()</kbd> operator, which takes emissions while a condition derived from each emission is true. The following example will keep taking emissions while emissions are less than <kbd>5</kbd>. The moment it encounters one that is not, it will call the <kbd>onComplete()</kbd> function and dispose of this:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>100</span><span>)<br/></span><span>          .</span><span>takeWhile</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&lt; </span><span>5</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(i</span><span> </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: 1<br/>RECEIVED: 2<br/>RECEIVED: 3<br/>RECEIVED: 4</pre>
<p>Just like the <kbd>takeWhile()</kbd> function, there is a <kbd>skipWhile()</kbd> function. It will keep skipping emissions while they qualify with a condition. The moment that condition no longer qualifies, the emissions will start going through. In the following code, we skip emissions as long as they are less than or equal to <kbd>95</kbd>. The moment an emission is encountered that does not meet this condition, it will allow all subsequent emissions going forward:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>100</span><span>)<br/></span><span>          .</span><span>skipWhile</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&lt;= </span><span>95</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: 96<br/>RECEIVED: 97<br/>RECEIVED: 98<br/>RECEIVED: 99<br/>RECEIVED: 100</pre>
<div class="packt_infobox">The <kbd>takeUntil()</kbd> operator is similar to <kbd>takeWhile()</kbd>, but it accepts another <kbd>Observable</kbd> as a parameter. It will keep taking emissions until that other <kbd>Observable</kbd> pushes an emission. The <kbd>skipUntil()</kbd><span> operator </span>has similar behavior. It also accepts another <kbd>Observable</kbd> as an argument but it will keep skipping until the other <kbd>Observable</kbd> emits something. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">distinct()</h1>
                </header>
            
            <article>
                
<p>The <kbd>distinct()</kbd> operator will emit each unique emission, but it will suppress any duplicates that follow. Equality is based on <kbd>hashCode()/equals()</kbd> implementation of the emitted objects. If we wanted to emit the distinct lengths of a string sequence, it could be done as follows:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>distinct</span><span>()<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: 5<br/>RECEIVED: 4<br/>RECEIVED: 7</pre>
<p>Keep in mind that if you have a wide, diverse spectrum of unique values, <kbd>distinct()</kbd> can use a bit of memory. Imagine that each subscription results in a <kbd>HashSet</kbd> that tracks previously captured unique values.</p>
<p>You can also add a lambda argument that maps each emission to a key used for equality logic. This allows the emissions, but not the key, to go forward while using the key for distinct logic. For instance, we can key off each string's length and use it for uniqueness, but emit the strings rather than their lengths:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>distinct</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: Alpha<br/>RECEIVED: Beta<br/>RECEIVED: Epsilon</pre>
<p><kbd>Alpha</kbd> is five characters, and <kbd>Beta</kbd> is four. <kbd>Gamma</kbd> and <kbd>Delta</kbd> were ignored because <kbd>Alpha</kbd> was already emitted and is 5 characters. <kbd>Epsilon</kbd> is seven characters, and because no seven-character string was emitted yet, it was emitted forward.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">distinctUntilChanged()</h1>
                </header>
            
            <article>
                
<p>The <kbd>distinctUntilChanged()</kbd> function will ignore duplicate consecutive emissions. It is a helpful way to ignore repetitions until they change. If the same value is being emitted repeatedly, all the duplicates will be ignored until a new value is emitted. Duplicates of the next value will be ignored until it changes again, and so on. Observe the output for the following code to see this behavior in action:</p>
<p> </p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>1</span><span>, </span><span>1</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>1</span><span>, 1</span><span>)<br/></span><span>          .</span><span>distinctUntilChanged</span><span>()<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<p> </p>
<pre style="padding-left: 60px">RECEIVED: 1<br/>RECEIVED: 2<br/>RECEIVED: 3<br/>RECEIVED: 2<br/>RECEIVED: 1</pre>
<p>We first receive an emission of <kbd>1</kbd>, which is allowed forward. But the next two <kbd>1</kbd> are ignored because they are consecutive duplicates. When it switches to <kbd>2</kbd>, that initial 2 is emitted, but the following duplicate is ignored. A <kbd>3</kbd> is emitted and its following duplicate is ignored as well. Finally, we switch back to a <kbd>2</kbd> that emits and then a <kbd>1</kbd> whose duplicate is ignored.</p>
<p> </p>
<p>Just like <kbd>distinct()</kbd>, you can provide an optional argument for a key through a lambda mapping. In the following code snippet, we execute the <kbd>distinctUntilChanged()</kbd> operation with strings keyed on their lengths:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Zeta"</span><span>, </span><span>"Eta"</span><span>, </span><span>"Gamma"</span><span>, <br/></span><span>"Delta"</span><span>)<br/></span><span>          .</span><span>distinctUntilChanged</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: Alpha<br/>RECEIVED: Beta<br/>RECEIVED: Eta<br/>RECEIVED: Gamma</pre>
<p>Note that <kbd>Zeta</kbd> was skipped because it comes right after <kbd>Beta</kbd>, which also is four characters. <kbd>Delta</kbd> is ignored as well because it follows <kbd>Gamma</kbd>, which is five characters as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">elementAt()</h1>
                </header>
            
            <article>
                
<p>You can get a specific emission by its index specified by a Long, starting at <kbd>0</kbd>. After that item is found and emitted, <kbd>onComplete()</kbd> will be called and the subscription will be disposed of.</p>
<p>If you want to get the fourth emission coming from an <kbd>Observable</kbd>, you can do it as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Zeta"</span><span>, </span><span>"Eta"</span><span>, </span><span>"Gamma"</span><span>, <br/></span><span>"Delta"</span><span>)<br/></span><span>            .</span><span>elementAt</span><span>(</span><span>3</span><span>)<br/></span><span>            .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the following code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: Eta</pre>
<p>You may not have noticed, but <kbd>elementAt()</kbd> returns <kbd>Maybe&lt;T&gt;</kbd> instead of <kbd>Observable&lt;T&gt;</kbd>. This is because it will yield one emission, but if there are fewer emissions than the sought index, it will be empty.</p>
<p>There are other flavors of <kbd>elementAt()</kbd>, such as <kbd>elementAtOrError()</kbd>, which return a <kbd>Single</kbd> and will emit an error if an element at that index is not found. <kbd>singleElement()</kbd> will turn an <kbd>Observable</kbd> into a <kbd>Maybe</kbd>, but will produce an error if there is anything beyond one element. Finally, <kbd>firstElement()</kbd> and <kbd>lastElement()</kbd> will yield, maybe emitting the first or last emission, respectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transforming operators</h1>
                </header>
            
            <article>
                
<p>Next, we will cover various common operators that transform emissions. A series of operators in an <kbd>Observable</kbd> chain is a stream of transformations. You have already seen <kbd>map()</kbd>, which is the most obvious operator in this category. We will start with that one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">map()</h1>
                </header>
            
            <article>
                
<p>For a given <kbd>Observable&lt;T&gt;</kbd>, the <kbd>map()</kbd> operator will transform a <kbd>T</kbd> emission into an <kbd>R</kbd> emission using the provided <kbd>Function&lt;T,R&gt;</kbd> lambda. We have already used this operator many times, turning strings into lengths. Here is a new example: we can take raw date strings and use the <kbd>map()</kbd> operator to turn each one into a <kbd>LocalDate</kbd> emission, as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.time.LocalDate</span><span>;<br/></span><span>import </span><span>java.time.format.DateTimeFormatter</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>DateTimeFormatter </span><span>dtf </span><span>= </span><span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"M/d<br/>          /yyyy"</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"1/3/2016"</span><span>, </span><span>"5/9/2016"</span><span>, </span><span>"10/12/2016"</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>s </span>-&gt; <span>LocalDate</span><span>.</span><span>parse</span><span>(</span><span>s</span><span>, </span><span>dtf</span><span>))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: 2016-01-03<br/>RECEIVED: 2016-05-09<br/>RECEIVED: 2016-10-12</pre>
<p>We passed a lambda that turns each string into a <kbd>LocalDate</kbd> object. We created a <kbd>DateTimeFormatter</kbd> in advance in order to assist with the <kbd>LocalDate.parse()</kbd> operation, which returns a <kbd>LocalDate</kbd>. In turn, we pushed each <kbd>LocalDate</kbd> emission to our <kbd>Observer</kbd> to be printed.</p>
<p>The <kbd>map()</kbd> operator does a one-to-one conversion for each emission. If you need to do a one-to-many conversion (turn one emission into several emissions), you will likely want to use <kbd>flatMap()</kbd> or <kbd>concatMap()</kbd>, which we will cover in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">cast()</h1>
                </header>
            
            <article>
                
<p>A simple, map-like operator to cast each emission to a different type is <kbd>cast()</kbd>. If we want to take <kbd>Observable&lt;String&gt;</kbd> and cast each emission to an object (and return an <kbd>Observable&lt;Object&gt;</kbd>), we could use the <kbd>map()</kbd> operator like this:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>&lt;</span><span>Object</span><span>&gt; </span><span>items </span><span>= <br/></span><span>  </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>).</span><span>map</span><span>(</span><span>s -&gt; (Object) s</span><span>);</span></pre>
<p>But a shorthand we can use instead is <kbd>cast()</kbd>, and we can simply pass the class type we want to cast to, as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>&lt;</span><span>Object</span><span>&gt; </span><span>items </span><span>= <br/></span><span>  </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>).</span><span>cast</span><span>(</span><span>Object</span><span>.</span><span>class</span><span>);</span></pre>
<p>If you find that you are having typing issues due to inherited or polymorphic types being mixed, this is an effective brute-force way to cast everything down to a common base type. But strive to properly use generics and type wildcards appropriately first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">startWith()</h1>
                </header>
            
            <article>
                
<p>For a given <kbd>Observable&lt;T&gt;</kbd>, the <kbd>startWith()</kbd> operator allows you to insert a <kbd>T</kbd> emission that precedes all the other emissions. For instance, if we have an <kbd>Observable&lt;String&gt;</kbd>that emits items on a menu we want to print, we can use <kbd>startWith()</kbd> to append a title header first:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>menu </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Coffee"</span><span>, </span><span>"Tea"</span><span>, </span><span>"Espresso"</span><span>, </span><span>"Latte"</span><span>);<br/></span><span><br/></span><span>        </span><span>//print menu<br/></span><span>        </span><span>menu</span><span>.</span><span>startWith</span><span>(</span><span>"COFFEE SHOP MENU"</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">COFFEE SHOP MENU<br/>Coffee<br/>Tea<br/>Espresso<br/>Latte</pre>
<p>If you want to start with more than one emission, use <kbd>startWithArray()</kbd> to accept <kbd>varargs</kbd> parameters. If we want to add a divider between our header and menu items, we can start with both the header and divider as emissions:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>menu </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Coffee"</span><span>, </span><span>"Tea"</span><span>, </span><span>"Espresso"</span><span>, </span><span>"Latte"</span><span>);<br/></span><span><br/></span><span>        </span><span>//print menu<br/></span><span>        </span><span>menu</span><span>.</span><span>startWithArray</span><span>(</span><span>"COFFEE SHOP MENU"</span><span>,</span><span>"----------------"</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>     }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">COFFEE SHOP MENU<br/>----------------<br/>Coffee<br/>Tea<br/>Espresso<br/>Latte</pre>
<p>The <kbd>startWith()</kbd> operator is helpful for cases like this, where we want to seed an initial value or precede our emissions with one or more emissions.</p>
<div class="packt_infobox">If you want an entire emissions of <kbd>Observable</kbd> to precede emissions of another <kbd>Observable</kbd>, you will want to use <kbd>Observable.concat()</kbd> or <kbd>concatWith()</kbd>, which we will cover in the next chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">defaultIfEmpty()</h1>
                </header>
            
            <article>
                
<p>If we want to resort to a single emission if a given <kbd>Observable</kbd> comes out empty, we can use <kbd>defaultIfEmpty()</kbd>. For a given <kbd>Observable&lt;T&gt;</kbd>, we can specify a default <kbd>T</kbd> emission if no emissions occur when <kbd>onComplete()</kbd> is called.</p>
<p>If we have an <kbd>Observable&lt;String&gt;</kbd> and filter for items that start with <kbd>Z</kbd> but no items meet this criteria, we can resort to emitting <kbd>None</kbd>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>items </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>,</span><span>"Beta"</span><span>,</span><span>"Gamma"</span><span>,</span><span>"Delta"</span><span>,</span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>items</span><span>.</span><span>filter</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>startsWith</span><span>(</span><span>"Z"</span><span>))<br/></span><span>          .</span><span>defaultIfEmpty</span><span>(</span><span>"None"</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>     }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">None</pre>
<p>Of course, if emissions were to occur, we would never see <kbd>None</kbd> emitted. It will only happen if the preceding <kbd>Observable</kbd> is empty.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">switchIfEmpty()</h1>
                </header>
            
            <article>
                
<p>Similar to <kbd>defaultIfEmpty()</kbd>, <kbd>switchIfEmpty()</kbd> specifies a different <kbd>Observable</kbd> to emit values from if the source <kbd>Observable</kbd> is empty. This allows you specify a different sequence of emissions in the event that the source is empty rather than emitting just one value.</p>
<p>We could choose to emit three additional strings, for example, if the preceding <kbd>Observable</kbd> came out empty due to a <kbd>filter()</kbd> operation:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>filter</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>startsWith</span><span>(</span><span>"Z"</span><span>))<br/></span><span>          .</span><span>switchIfEmpty</span><span>(</span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Zeta"</span><span>, </span><span>"Eta"</span><span>, </span><span>"Theta"</span><span>))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>          </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>          );<br/></span><span>     }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: Zeta<br/>RECEIVED: Eta<br/>RECEIVED: Theta</pre>
<p>Of course, if the preceding <kbd>Observable</kbd> is not empty, then <kbd>switchIfEmpty()</kbd> will have no effect and not use that specified <kbd>Observable</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">sorted()</h1>
                </header>
            
            <article>
                
<p>If you have a finite <kbd>Observable&lt;T&gt;</kbd> emitting items that implement <kbd>Comparable&lt;T&gt;</kbd>, you can use <kbd>sorted()</kbd> to sort the emissions. Internally, it will collect all the emissions and then re-emit them in their sorted order. In the following code snippet, we sort emissions from <kbd>Observable&lt;Integer&gt;</kbd>so that they are emitted in their natural order:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>6</span><span>, </span><span>2</span><span>, </span><span>5</span><span>, </span><span>7</span><span>, </span><span>1</span><span>, </span><span>4</span><span>, </span><span>9</span><span>, </span><span>8</span><span>, </span><span>3</span><span>)<br/></span><span>          .</span><span>sorted</span><span>()<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9</pre>
<p>Of course, this can have some performance implications as it will collect all emissions in memory before emitting them again. If you use this against an infinite <kbd>Observable</kbd>, you may get an <kbd>OutOfMemory</kbd> error.</p>
<p>You can also provide <kbd>Comparator</kbd> as an argument to specify an explicit sorting criterion. We can provide <kbd>Comparator</kbd> to reverse the sorting order, such as the one shown as follows:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.</span><span>Comparator</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>6</span><span>, </span><span>2</span><span>, </span><span>5</span><span>, </span><span>7</span><span>, </span><span>1</span><span>, </span><span>4</span><span>, </span><span>9</span><span>, </span><span>8</span><span>, </span><span>3</span><span>)<br/></span><span>          .</span><span>sorted</span><span>(</span><span>Comparator</span><span>.</span><span>reverseOrder</span><span>())<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">9<br/>8<br/>7<br/>6<br/>5<br/>4<br/>3<br/>2<br/>1</pre>
<p>Since <kbd>Comparator</kbd> is a single-abstract-method interface, you can implement it quickly with a lambda. Specify the two parameters representing two emissions, and then map them to their comparison operation. We can use this to sort string emissions by their lengths, for instance. This also allows us to sort items that do not implement <span>Comparable</span>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma" </span><span>,</span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>sorted</span><span>((</span><span>x</span><span>,</span><span>y</span><span>) </span>-&gt; <span>Integer</span><span>.</span><span>compare</span><span>(</span><span>x</span><span>.</span><span>length</span><span>(), </span><span>y</span><span>.</span><span>length</span><span>()))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>     }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Beta<br/>    Alpha<br/>    Gamma<br/>    Delta<br/>    Epsilon</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">delay()</h1>
                </header>
            
            <article>
                
<p>We can postpone emissions using the <kbd>delay()</kbd> operator. It will hold any received emissions and delay each one for the specified time period. If we wanted to delay emissions by three seconds, we could do it like this:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;</span><span><br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {</span><span><br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma" </span><span>,</span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>delay</span><span>(</span><span>3</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>          </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>     }<br/></span><span>     </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>       </span><span>try </span><span>{<br/></span><span>         </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>       } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>         </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>       }<br/></span><span>     }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: Alpha<br/>    Received: Beta<br/>    Received: Gamma<br/>    Received: Delta<br/>    Received: Epsilon</pre>
<p>Because <kbd>delay()</kbd> operates on a different scheduler (such as <kbd>Observable.interval()</kbd>), we need to leverage a <kbd>sleep()</kbd> method to keep the application alive long enough to see this happen. Each emission will be delayed by three seconds. You can pass an optional third Boolean argument indicating whether you want to delay error notifications as well.</p>
<p>For more advanced cases, you can pass another <kbd>Observable</kbd> as your <kbd>delay()</kbd> argument, and this will delay emissions until that other <kbd>Observable</kbd> emits something.</p>
<div class="packt_infobox">Note that there is a <kbd>delaySubscription()</kbd> operator, which will delay subscribing to the <kbd>Observable</kbd> preceding it rather than delaying each individual emission.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">repeat()</h1>
                </header>
            
            <article>
                
<p> </p>
<p>The <kbd>repeat()</kbd> operator will repeat subscription upstream after <kbd>onComplete()</kbd> a specified number of times.</p>
<p> </p>
<p>For instance, we can repeat the emissions twice for a given <kbd>Observable</kbd> by passing a long <kbd>2</kbd> as an argument for <kbd>repeat()</kbd>, as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma" </span><span>,</span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>repeat</span><span>(</span><span>2</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));</span><span><br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: Alpha<br/>    Received: Beta<br/>    Received: Gamma<br/>    Received: Delta<br/>    Received: Epsilon<br/>    Received: Alpha<br/>    Received: Beta<br/>    Received: Gamma<br/>    Received: Delta<br/>    Received: Epsilon</pre>
<p>If you do not specify a number, it will repeat infinitely, forever re-subscribing after every <kbd>onComplete()</kbd>. There is also a <kbd>repeatUntil()</kbd> operator that accepts a Boolean Supplier lambda argument and will continue repeating until it yields <kbd>true</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">scan()</h1>
                </header>
            
            <article>
                
<p>The <kbd>scan()</kbd> method is a rolling aggregator. For every emission, you add it to an accumulation. Then, it will emit each incremental accumulation.</p>
<p>For instance, you can emit the rolling sum for each emission by passing a lambda to the<kbd>scan()</kbd> method that adds each <kbd>next</kbd> emission to the <kbd>accumulator</kbd>:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>3</span><span>, </span><span>7</span><span>, </span><span>10</span><span>, </span><span>2</span><span>, </span><span>14</span><span>)<br/></span><span>          .</span><span>scan</span><span>((</span><span>accumulator</span><span>, </span><span>next</span><span>) </span>-&gt; <span>accumulator </span><span>+ </span><span>next</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>      }<br/></span><span>    }<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">Received: 5<br/>Received: 8<br/>Received: 15<br/>Received: 25<br/>Received: 27<br/>Received: 41</pre>
<p>It emitted the initial value of <kbd>5</kbd>, which was the first emission it received. Then, it received <kbd>3</kbd> and added it to <kbd>5</kbd>, emitting <kbd>8</kbd>. After that, <kbd>7</kbd> was received, which was added to <kbd>8</kbd>, emitting <kbd>15</kbd>, and so on. This does not have to be used just for rolling sums. You can create many kinds of accumulations (even non-math ones such as string concatenations or Boolean reductions). </p>
<p>Note that <kbd>scan()</kbd> is very similar to <kbd>reduce()</kbd>, which we will learn about shortly. Be careful to not confuse the two. The <kbd>scan()</kbd>  method emits the rolling accumulation for each emission, whereas <kbd>reduce()</kbd> yields a single emission reflecting the final accumulation once <kbd>onComplete()</kbd> is called. <kbd>scan()</kbd>can be used on infinite Observables safely since it does not require an <kbd>onComplete()</kbd> call.</p>
<p>You can also provide an initial value for the first argument and aggregate into a different type than what is being emitted. If we wanted to emit the rolling count of emissions, we can provide an initial value of <kbd>0</kbd> and just add <kbd>1</kbd> to it for every emission. Keep in mind that the initial value will be emitted first, so use <kbd>skip(1)</kbd> after <kbd>scan()</kbd> if you do not want that initial emission:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>scan</span><span>(</span><span>0</span><span>, (</span><span>total</span><span>, </span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>1</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: 0<br/>    Received: 1<br/>    Received: 2<br/>    Received: 3<br/>    Received: 4<br/>    Received: 5</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing operators</h1>
                </header>
            
            <article>
                
<p>You will likely have moments where you want to take a series of emissions and consolidate them into a single emission (usually emitted through a <kbd>Single</kbd>). We will cover a few operators that accomplish this. Note that nearly all of these operators only work on a finite <kbd>Observable</kbd> that calls <kbd>onComplete()</kbd> because typically, we can consolidate only finite datasets. We will explore this behavior as we cover these operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">count()</h1>
                </header>
            
            <article>
                
<p>The simplest operator to consolidate emissions into a single one is <kbd>count()</kbd>. It will count the number of emissions and emit through a Single once <kbd>onComplete()</kbd> is called, shown as follows:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>count</span><span>()<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span><br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: 5</pre>
<p>Like most reduction operators, this should not be used on an infinite <kbd>Observable</kbd>. It will hang up and work infinitely, never emitting a count or calling <kbd>onComplete()</kbd>. You should consider using <kbd>scan()</kbd> to emit a rolling count instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">reduce()</h1>
                </header>
            
            <article>
                
<p>The <kbd>reduce()</kbd> operator is syntactically identical to <kbd>scan()</kbd>, but it only emits the final accumulation when the source calls <kbd>onComplete()</kbd>. Depending on which overload you use, it can yield <kbd>Single</kbd> or <kbd>Maybe</kbd>. If you want to emit the sum of all integer emissions, you can take each one and add it to the rolling total. But it will only emit once it is finalized:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>3</span><span>, </span><span>7</span><span>, </span><span>10</span><span>, </span><span>2</span><span>, </span><span>14</span><span>)<br/></span><span>          .</span><span>reduce</span><span>((</span><span>total</span><span>, </span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));</span><span><br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: 41</pre>
<p>Similar to <kbd>scan()</kbd>, there is a seed argument that you can provide that will serve as the initial value to accumulate on. If we wanted to turn our emissions into a single comma-separated value string, we could use <kbd>reduce()</kbd> like this, shown as follows:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>3</span><span>, </span><span>7</span><span>, </span><span>10</span><span>, </span><span>2</span><span>, </span><span>14</span><span>)<br/></span><span>          .</span><span>reduce</span><span>(</span><span>""</span><span>, (</span><span>total</span><span>, </span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>(</span><span>total</span><span>.</span><span>equals</span><span>(</span><span>""</span><span>) </span><span>? </span><span>"" </span><span>:<br/></span><span>            ","</span><span>) </span><span>+  </span><span>next</span><span>)<br/></span><span>              .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px"><span>    Received: 5,3,7,10,2,14<br/></span></pre>
<p>We provided an empty string as our seed value, and we maintain a rolling concatenation total and keep adding to it. We prevent a preceding comma using a ternary operator to check whether the <kbd>total</kbd> is the seed value and returning an empty string instead of a comma if it is.</p>
<div class="packt_tip">Your seed value should be immutable, such as an integer or string. Bad side-effects can happen if it is mutable, and you should use <kbd>collect()</kbd> (or <kbd>seedWith()</kbd>) for these cases, which we will cover in a moment. For instance, if you want to reduce <kbd>T</kbd> emissions into a collection, such as <kbd>List&lt;T&gt;</kbd>, use <kbd>collect()</kbd> instead of <kbd>reduce()</kbd>. Using <kbd>reduce()</kbd> will have an undesired side-effect of using the same list for each subscription, rather than creating a fresh, empty one each time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">all()</h1>
                </header>
            
            <article>
                
<p>The <kbd>all()</kbd> operator verifies that each emission qualifies with a specified condition and return a <kbd>Single&lt;Boolean&gt;</kbd>. If they all pass, it will emit <kbd>True</kbd>. If it encounters one that fails, it will immediately emit <kbd>False</kbd>. In the following code snippet, we emit a test against six integers, verifying that they all are less than <kbd>10</kbd>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>3</span><span>, </span><span>7</span><span>, </span><span>11</span><span>, </span><span>2</span><span>, </span><span>14</span><span>)<br/></span><span>          .</span><span>all</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&lt; </span><span>10</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>     }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: false</pre>
<p>When the <kbd>all()</kbd> operator encountered <kbd>11</kbd>, it immediately emitted <kbd>False</kbd> and called <kbd>onComplete()</kbd>. It did not even get to <kbd>2</kbd> or <kbd>14</kbd> because that would be unnecessary work. It already found an element that fails the entire test.</p>
<p> </p>
<div class="packt_infobox">If you call <kbd>all()</kbd> on an empty <kbd>Observable</kbd>, it will emit true due to the principle of vacuous truth. You can read more about vacuous truth on Wikipedia at <a href="https://en.wikipedia.org/wiki/Vacuous_truth" target="_blank">https://en.wikipedia.org/wiki/Vacuous_truth</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">any()</h1>
                </header>
            
            <article>
                
<p>The <kbd>any()</kbd> method will check whether at least one emission meets a specific criterion and return a <kbd>Single&lt;Boolean&gt;</kbd>. The moment it finds an emission that qualifies, it will emit true and then call <kbd>onComplete()</kbd>. If it processes all emissions and finds that they all are false, it will emit false and call <kbd>onComplete()</kbd>.</p>
<p>In the following code snippet, we emit four date strings, convert them into <kbd>LocalDate</kbd> emissions, and test for any that are in the month of June or later:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.time.LocalDate</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"2016-01-01"</span><span>, </span><span>"2016-05-02"</span><span>, </span><span>"2016-09-12"</span><span>, <br/></span><span>"2016-04-03"</span><span>)<br/></span><span>        .</span><span>map</span><span>(</span><span>LocalDate</span>::<span>parse</span><span>)<br/></span><span>        .</span><span>any</span><span>(</span><span>dt </span>-&gt; <span>dt</span><span>.</span><span>getMonthValue</span><span>() </span><span>&gt;= </span><span>6</span><span>)<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));</span><span><br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">    Received: true</pre>
<p>When it encountered the <kbd>2016-09-12</kbd> date, it immediately emitted true and called <kbd>onComplete()</kbd>. It did not proceed to process <kbd>2016-04-03</kbd>.</p>
<div class="packt_infobox">If you call <kbd>any()</kbd> on an empty <kbd>Observable</kbd>, it will emit false due to the principle of vacuous truth. You can read more about vacuous truth on Wikipedia at <a href="https://en.wikipedia.org/wiki/Vacuous_truth" target="_blank">https://en.wikipedia.org/wiki/Vacuous_truth</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">contains()</h1>
                </header>
            
            <article>
                
<p>The <kbd>contains()</kbd> operator will check whether a specific element (based on the <kbd>hashCode()/equals()</kbd> implementation) ever emits from an <kbd>Observable</kbd>. It will return a <kbd>Single&lt;Boolean&gt;</kbd> that will emit true if it is found and false if it is not.</p>
<p>In the following code snippet, we emit the integers <kbd>1</kbd> through <kbd>10000</kbd>, and we check whether the number <kbd>9563</kbd> is emitted from it using <kbd>contains()</kbd>:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>10000</span><span>)<br/></span><span>          .</span><span>contains</span><span>(</span><span>9563</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: true</pre>
<p>As you can probably guess, the moment the element is found, it will emit true and call <kbd>onComplete()</kbd> and dispose of the operation. If the source calls <kbd>onComplete()</kbd> and the element was not found, it will emit <kbd>false</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collection operators</h1>
                </header>
            
            <article>
                
<p>Collection operators will accumulate all emissions into a collection such as a list or map and then emit that entire collection as a single emission. Collection operators are another form of reducing operators since they consolidate emissions into a single one. We will cover them separately since they are a significant category on their own, though.</p>
<div class="packt_tip">Note that you should avoid reducing emissions into collections for the sake of it. It can undermine the benefits of reactive programming where items are processed in a beginning-to-end, one-at-a-time sequence. You only want to consolidate emissions into collections when you are logically grouping them in some way.</div>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">toList()</h1>
                </header>
            
            <article>
                
<p>A common collection operator is <kbd>toList()</kbd>. For a given <kbd>Observable&lt;T&gt;</kbd>, it will collect incoming emissions into a <kbd>List&lt;T&gt;</kbd> and then push that entire <kbd>List&lt;T&gt;</kbd> as a single emission (through <kbd>Single&lt;List&lt;T&gt;&gt;</kbd>). In the following code snippet, we collect string emissions into a <kbd>List&lt;String&gt;</kbd>. After the preceding <kbd>Observable</kbd> signals <kbd>onComplete()</kbd>, that list is pushed forward to the <kbd>observer</kbd> to be printed:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>toList</span><span>()<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: [Alpha, Beta, Gamma, Delta, Epsilon]</pre>
<p>By default, <kbd>toList()</kbd> will use a standard <kbd>ArrayList</kbd> implementation. You can optionally specify an integer argument to serve as the <kbd>capacityHint</kbd>, and that will optimize the initialization of ArrayList to expect roughly that number of items:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>1000</span><span>)<br/></span><span>          .</span><span>toList</span><span>(</span><span>1000</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>If you want to specify a different list implementation besides <kbd>ArrayList</kbd>, you can provide a <kbd>Callable</kbd> lambda as an argument to construct one. In the following code snippet, I provide a <kbd>CopyOnWriteArrayList</kbd> instance to serve as my list:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;</span><span><br/></span><span>import </span><span>java.util.concurrent.CopyOnWriteArrayList</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>toList</span><span>(</span><span>CopyOnWriteArrayList</span>::<span>new</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>If you want to use Google Guava's immutable list, this is a little trickier since it is immutable and uses a builder. We will show you how to do this with <kbd>collect()</kbd> later in this section. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">toSortedList()</h1>
                </header>
            
            <article>
                
<p>A different flavor of <kbd>toList()</kbd> is <kbd>toSortedList()</kbd>. This will collect the emissions into a list that sorts the items naturally based on their <kbd>Comparator</kbd> implementation. Then, it will emit that sorted <kbd>List&lt;T&gt;</kbd> forward to the <kbd>Observer</kbd>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>6</span><span>, </span><span>2</span><span>, </span><span>5</span><span>, </span><span>7</span><span>, </span><span>1</span><span>, </span><span>4</span><span>, </span><span>9</span><span>, </span><span>8</span><span>, </span><span>3</span><span>)<br/></span><span>          .</span><span>toSortedList</span><span>()<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>     }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 60px">Received: [1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>
<p>Like <kbd>sorted()</kbd>, you can provide a <kbd>Comparator</kbd> as an argument to apply a different sorting logic. You can also specify an initial capacity for the backing <kbd>ArrayList</kbd> just like <kbd>toList()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">toMap() and toMultiMap()</h1>
                </header>
            
            <article>
                
<p>For a given <kbd>Observable&lt;T&gt;</kbd>, the <kbd>toMap()</kbd> operator will collect emissions into <kbd>Map&lt;K,T&gt;</kbd>, where <kbd>K</kbd> is the key type derived off a lambda <kbd>Function&lt;T,K&gt;</kbd> argument producing the key for each emission.</p>
<p>If we want to collect strings into <kbd>Map&lt;Char,String&gt;</kbd>, where each string is keyed off their first character, we can do it like this:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>toMap</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>charAt</span><span>(</span><span>0</span><span>))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: {A=Alpha, B=Beta, D=Delta, E=Epsilon, G=Gamma}</pre>
<p>The <kbd>s -&gt; s.charAt(0)</kbd> lambda argument takes each string and derives the key to pair it with. In this case, we are making the first character of that string the key.</p>
<p>If we wanted to yield a different value other than the emission to associate with the key, we can provide a second lambda argument that maps each emission to a different value. We can, for instance, map each first letter key with the length of that string:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>toMap</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>charAt</span><span>(</span><span>0</span><span>), </span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: {A=5, B=4, D=5, E=7, G=5}</pre>
<p>By default, <kbd>toMap()</kbd> will use <kbd>HashMap</kbd>. You can also provide a third lambda argument that provides a different map implementation. For instance, I can provide <kbd>ConcurrentHashMap</kbd> instead of <kbd>HashMap</kbd> :</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.ConcurrentHashMap</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>toMap</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>charAt</span><span>(</span><span>0</span><span>), </span><span>String</span>::<span>length</span><span>,   <br/></span><span>ConcurrentHashMap</span>::<span>new</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>Note that if I have a key that maps to multiple emissions, the last emission for that key is going to replace subsequent ones. If I make the string length the key for each emission, <kbd>Alpha</kbd> is going to be replaced by <kbd>Gamma</kbd>, which is going to be replaced by <kbd>Delta</kbd>:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>toMap</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p> </p>
<p>The output of the preceding code snippet is as follows:</p>
<pre>    Received: {4=Beta, 5=Delta, 7=Epsilon}</pre>
<p> </p>
<p>If you want a given key to map to multiple emissions, you can use <kbd>toMultiMap()</kbd> instead, which will maintain a list of corresponding values for each key. <kbd>Alpha</kbd>, <kbd>Gamma</kbd>, and <kbd>Delta</kbd> will then all be put in a list that is keyed off the length five:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>toMultimap</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: {4=[Beta], 5=[Alpha, Gamma, Delta], 7=[Epsilon]}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">collect()</h1>
                </header>
            
            <article>
                
<p>When none of the collection operators have what you need, you can always use the <kbd>collect()</kbd> operator to specify a different type to collect items into. For instance, there is no <kbd>toSet()</kbd> operator to collect emissions into a <kbd>Set&lt;T&gt;</kbd>, but you can quickly use <kbd>collect()</kbd> to effectively do this. You will need to specify two arguments that are built with lambda expressions: <kbd>initialValueSupplier</kbd>, which will provide a new <kbd>HashSet</kbd>for a new <kbd>Observer</kbd>, and <kbd>collector</kbd>, which specifies how each emission is added to that <kbd>HashSet</kbd>:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.HashSet</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>collect</span><span>(</span><span>HashSet</span>::<span>new</span><span>, </span><span>HashSet</span>::<span>add</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: [Gamma, Delta, Alpha, Epsilon, Beta]</pre>
<p>Now our <kbd>collect()</kbd> operator will emit a single <kbd>HashSet&lt;String&gt;</kbd> containing all the emitted values.</p>
<p>Use <kbd>collect()</kbd> instead of <kbd>reduce()</kbd> when you are putting emissions into a mutable object, and you need a new mutable object seed each time. We can also use <kbd>collect()</kbd> for trickier cases that are not straightforward collection implementations.</p>
<p>Say you added Google Guava as a dependency (<a href="https://github.com/google/guava" target="_blank">https://github.com/google/guava</a>) and you want to collect emissions into an <kbd>ImmutableList</kbd>. To create an <kbd>ImmutableList</kbd> , you have to call its <kbd>builder()</kbd> factory to yield an <kbd>ImmutableList.Builder&lt;T&gt;</kbd><strong>.</strong> You then call its <kbd>add()</kbd> method to put items in the builder, followed by a call to <kbd>build()</kbd>, which returns a sealed, final <kbd>ImmutableList&lt;T&gt;</kbd> that cannot be modified.</p>
<p>To collect emissions into <kbd>ImmutableList</kbd>, you can supply an <kbd>ImmutableList.Builder&lt;T&gt;</kbd> for your first lambda argument and then add each element through its <kbd>add()</kbd> method in the second argument. This will emit <kbd>ImmutableList.Builder&lt;T&gt;</kbd> once it is fully populated, and you can <kbd>map()</kbd> it to its <kbd>build()</kbd> call in order to emit an <kbd>ImmutableList&lt;T&gt;</kbd>:</p>
<pre style="padding-left: 60px"><span>import </span><span>com.google.common.collect.</span><span>ImmutableList</span><span>;<br/></span><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        <br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>collect</span><span>(</span><span>ImmutableList</span>::<span>builder</span><span>, </span><span>ImmutableList</span><span>.</span><span>Builder</span>::<span>add</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>ImmutableList</span><span>.</span><span>Builder</span>::<span>build</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: [Alpha, Beta, Gamma, Delta, Epsilon]</pre>
<p>Again, the <kbd>collect()</kbd> operator is helpful to collect emissions into any arbitrary type that RxJava does not provide out of the box.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Error recovery operators</h1>
                </header>
            
            <article>
                
<p>Exceptions can occur in your <kbd>Observable</kbd> chain across many operators depending on what you are doing. We already know about the <kbd>onError()</kbd> event that is communicated down the <kbd>Observable</kbd> chain to the <kbd>Observer</kbd>. After that, the subscription terminates and no more emissions will occur. But sometimes, we want to intercept exceptions before they get to the <kbd>Observer</kbd> and attempt some form of recovery. We cannot necessarily pretend that the error never happened and expect emissions to resume, but we can attempt re-subscribing or switch to an alternate source <kbd>Observable</kbd>.</p>
<p>We can still do the former, just not with RxJava operators, which we will see shortly. If you find that the error recovery operators do not meet your needs, chances are you can compose them creatively.</p>
<p> </p>
<p>For these examples, let's divide each integer emission by 10, where one of the emissions is <kbd>0</kbd>. This will result in a "<kbd>/ by zero</kbd>" exception being emitted to the <kbd>Observer</kbd>, as shown in the following code snippet:</p>
<p> </p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>          </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>          );<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p> </p>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED ERROR: java.lang.ArithmeticException: / by zero</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">onErrorReturn() and onErrorReturnItem()</h1>
                </header>
            
            <article>
                
<p>When you want to resort to a default value when an exception occurs, you can use <kbd>onErrorReturnItem()</kbd>. If we want to emit <kbd>-1</kbd> when an exception occurs, we can do it like this:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>          .</span><span>onErrorReturnItem</span><span>(</span><span>-</span><span>1</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>          </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>          );<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED: -1</pre>
<p>You can also supply <kbd>Function&lt;Throwable,T&gt;</kbd> to dynamically produce the value using a lambda. This gives you access to <kbd>Throwable</kbd> , which you can use to determine the returned value as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>          .</span><span>onErrorReturn</span><span>(</span><span>e </span>-&gt; <span>- </span><span>1</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>          </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>          );<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The placement of <kbd>onErrorReturn()</kbd> matters. If we put it before the <kbd>map()</kbd> operator, the error would not be caught because it happened after <kbd>onErrorReturn()</kbd>. To intercept the emitted error, it must be downstream from where the error occurred.</p>
<p>Note that even though we emitted <kbd>-1</kbd> to handle the error, the sequence still terminated after that. We did not get the <kbd>3</kbd>, <kbd>2</kbd>, or <kbd>8</kbd> that was supposed to follow. If you want to resume emissions, you will just want to handle the error within the <kbd>map()</kbd> operator where the error can occur. You would do this in lieu of <kbd>onErrorReturn()</kbd> or <kbd>onErrorReturnItem()</kbd>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>{<br/></span><span>            </span><span>try </span><span>{<br/></span><span>                  </span><span>return </span><span>10 </span><span>/ </span><span>i</span><span>;<br/></span><span>                } </span><span>catch </span><span>(</span><span>ArithmeticException </span><span>e</span><span>) {<br/></span><span>                  </span><span>return </span><span>-</span><span>1</span><span>;<br/></span><span>                }<br/></span><span>                })<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>                </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>              );<br/></span><span>       }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED: -1<br/>    RECEIVED: 3<br/>    RECEIVED: 5<br/>    RECEIVED: 1</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">onErrorResumeNext()</h1>
                </header>
            
            <article>
                
<p>Similar to <kbd>onErrorReturn()</kbd> and <kbd>onErrorReturnItem()</kbd>, <kbd>onErrorResumeNext()</kbd> is very similar. The only difference is that it accepts another <kbd>Observable</kbd> as a parameter to emit potentially multiple values, not a single value, in the event of an exception.</p>
<p>This is somewhat contrived and likely has no business use case, but we can emit three <kbd>-1</kbd> emissions in the event of an error:</p>
<pre style="padding-left: 30px"><span>    import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>    public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>      </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>        .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>        .</span><span>onErrorResumeNext</span><span>(</span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>-</span><span>1</span><span>).</span><span>repeat</span><span>(</span><span>3</span><span>))<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>        </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>        );<br/></span><span>      }<br/></span><span>    }<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED: -1<br/>    RECEIVED: -1<br/>    RECEIVED: -1</pre>
<p>We can also pass it <kbd>Observable.empty()</kbd> to quietly stop emissions in the event that there is an error and gracefully call the <kbd>onComplete()</kbd> function:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>          .</span><span>onErrorResumeNext</span><span>(</span><span>Observable</span><span>.</span><span>empty</span><span>())<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>          </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>          );<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<p> </p>
<pre style="padding-left: 60px">RECEIVED: 2<br/>RECEIVED: 5<br/>RECEIVED: 2</pre>
<p>Similar to <kbd>onErrorReturn()</kbd>, you can provide a <kbd>Function&lt;Throwable,Observable&lt;T&gt;&gt;</kbd> lambda to produce an <kbd>Observable</kbd> dynamically from the emitted <kbd>Throwable</kbd>, as shown in the code snippet:</p>
<p> </p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>          .</span><span>onErrorResumeNext</span><span>((</span><span>Throwable </span><span>e</span><span>) </span>-&gt;   <br/><span>Observable</span><span>.</span><span>just</span><span>(</span><span>-</span><span>1</span><span>).</span><span>repeat</span><span>(</span><span>3</span><span>))<br/></span><span>              .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>            </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>            );<br/></span><span>       }<br/></span><span>}</span></pre>
<p>The output of the preceding code is as follows:</p>
<pre style="padding-left: 60px">RECEIVED: 2<br/>RECEIVED: 5<br/>RECEIVED: 2<br/>RECEIVED: -1<br/>RECEIVED: -1<br/>RECEIVED: -1</pre>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">retry()</h1>
                </header>
            
            <article>
                
<p>Another way to attempt recovery is to use the <kbd>retry()</kbd> operator, which has several parameter overloads. It will re-subscribe to the preceding <kbd>Observable</kbd> and, hopefully, not have the error again.</p>
<p>If you call <kbd>retry()</kbd> with no arguments, it will resubscribe an infinite number of times for each error. You need to be careful with <kbd>retry()</kbd> as it can have chaotic effects. Using it with our example will cause it to emit these integers infinitely and repeatedly:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>        .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>        .</span><span>retry</span><span>()<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>        </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>        );<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    ...</pre>
<p>It might be safer to specify a fixed number of times to <kbd>retry()</kbd> before it gives up and just emits the error to the <kbd>Observer</kbd>. In the following code snippet, we will only retry two times:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>          .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>          .</span><span>retry</span><span>(</span><span>2</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>          </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>          );<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    RECEIVED ERROR: java.lang.ArithmeticException: / by zero</pre>
<p>You can also provide <kbd>Predicate&lt;Throwable&gt;</kbd> or <kbd>BiPredicate&lt;Integer,Throwable&gt;</kbd> to conditionally control when <kbd>retry()</kbd> is attempted. The <kbd>retryUntil()</kbd> operator will allow retries while a given <kbd>BooleanSupplier</kbd> lambda is false. There is also an advanced <kbd>retryWhen()</kbd> operator that supports advanced composition for tasks such as delaying retries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Action operators</h1>
                </header>
            
            <article>
                
<p>To close this chapter, we will cover some helpful operators that can assist in debugging as well as getting visibility into an <kbd>Observable</kbd> chain. These are the action or <kbd>doOn</kbd> operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">doOnNext(), doOnComplete(), and doOnError()</h1>
                </header>
            
            <article>
                
<p>These three operators: <kbd>doOnNext()</kbd>, <kbd>doOnComplete()</kbd>, and <kbd>doOnError()</kbd> are like putting a mini <kbd>Observer</kbd> right in the middle of the <kbd>Observable</kbd> chain.</p>
<p>The <kbd>doOnNext()</kbd> operator allows you to peek at each emission coming out of an operator and going into the next. This operator does not affect the operation or transform the emissions in any way. We just create a side-effect for each event that occurs at that point in the chain. For instance, we can perform an action with each string before it is mapped to its length. In this case, we will just print them by providing a <kbd>Consumer&lt;T&gt;</kbd> lambda:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>doOnNext</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Processing: " </span><span>+ </span><span>s</span><span>))<br/></span><span>          .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Processing: Alpha<br/>    Received: 5<br/>    Processing: Beta<br/>    Received: 4<br/>    Processing: Gamma<br/>    Received: 5<br/>    Processing: Delta<br/>    Received: 5<br/>    Processing: Epsilon<br/>    Received: 7</pre>
<div class="packt_infobox">You can also leverage <kbd>doAfterNext()</kbd>, which performs the action after the emission is passed downstream rather than before.</div>
<p>The <kbd>onComplete()</kbd> operator allows you to fire off an action when <kbd>onComplete()</kbd> is called at the point in the <kbd>Observable</kbd> chain. This can be helpful in seeing which points of the <kbd>Observable</kbd> chain have completed, as shown in the following code snippet<strong>:</strong></p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>doOnComplete</span><span>(() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Source is done   <br/>            emitting!"</span><span>))<br/></span><span>          .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>i</span><span>));<br/></span><span>     }<br/></span><span>}<br/></span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Received: 5<br/>    Received: 4<br/>    Received: 5<br/>    Received: 5<br/>    Received: 7<br/>    Source is done emitting!</pre>
<p>And, of course, <kbd>onError()</kbd> will peek at the error being emitted up the chain, and you can perform an action with it. This can be helpful to put between operators to see which one is to blame for an error:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>2</span><span>, </span><span>4</span><span>, </span><span>0</span><span>, </span><span>3</span><span>, </span><span>2</span><span>, </span><span>8</span><span>)<br/></span><span>          .</span><span>doOnError</span><span>(</span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Source failed!"</span><span>))<br/></span><span>          .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>10 </span><span>/ </span><span>i</span><span>)<br/></span><span>          .</span><span>doOnError</span><span>(</span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Division failed!"</span><span>))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>),<br/></span><span>          </span><span>e </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED ERROR: " </span><span>+ </span><span>e</span><span>)<br/></span><span>          );<br/></span><span>     }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    RECEIVED: 2<br/>    RECEIVED: 5<br/>    RECEIVED: 2<br/>    Division failed!<br/>    RECEIVED ERROR: java.lang.ArithmeticException: / by zero</pre>
<p>We used <kbd>doOnError()</kbd> in two places to see where the error first appeared. Since we did not see <kbd>Source failed!</kbd> printed but we saw <kbd>Division failed!</kbd>, we can deduct that the error occurred in the <kbd>map()</kbd> operator.</p>
<p>Use these three operators together to get an insight into what your <kbd>Observable</kbd> operation is doing or to quickly create side-effects.</p>
<div class="packt_infobox">You can specify all three actions for <kbd>onNext()</kbd>, <kbd>onComplete()</kbd>, and <kbd>onError()</kbd> using <kbd>doOnEach()</kbd> as well. The <kbd>subscribe()</kbd> method accepts these three actions as lambda arguments or an entire <kbd>Observer&lt;T&gt;</kbd>. It is like putting <kbd>subscribe()</kbd> right in the middle of your Observable chain! There is also a <kbd>doOnTerminate()</kbd> operator, which fires for an <kbd>onComplete()</kbd> or <kbd>onError()</kbd> event.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">doOnSubscribe() and doOnDispose()</h1>
                </header>
            
            <article>
                
<p>Two other helpful action operators are <kbd>doOnSubscribe()</kbd> and <kbd>doOnDispose()</kbd>. The <kbd>doOnSubscribe()</kbd> fires a specific <kbd>Consumer&lt;Disposable&gt;</kbd> the moment subscription occurs at that point in the <kbd>Observable</kbd> chain. It provides access to the Disposable in case you want to call <kbd>dispose()</kbd> in that action. The <kbd>doOnDispose()</kbd> operator will perform a specific action when disposal is executed at that point in the <kbd>Observable</kbd> chain.</p>
<p>We use both operators to print when subscription and disposal occur, as shown in the following code snippet. As you can predict, we see the subscribe event fire off first. Then, the emissions go through, and then disposal is finally fired:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>          .</span><span>doOnSubscribe</span><span>(</span><span>d </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Subscribing!"</span><span>))<br/></span><span>          .</span><span>doOnDispose</span><span>(() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Disposing!"</span><span>))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"RECEIVED: " </span><span>+ </span><span>i</span><span>)</span><span>);<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Subscribing!<br/>    RECEIVED: Alpha<br/>    RECEIVED: Beta<br/>    RECEIVED: Gamma<br/>    RECEIVED: Delta<br/>    RECEIVED: Epsilon<br/>    Disposing!</pre>
<p>Note that <kbd>doOnDispose()</kbd> can fire multiple times for redundant disposal requests or not at all if it is not disposed of in some form or another. Another option is to use the <kbd>doFinally()</kbd> operator, which will fire after either <kbd>onComplete()</kbd> or <kbd>onError()</kbd> is called or disposed of by the downstream.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">doOnSuccess()</h1>
                </header>
            
            <article>
                
<p>Remember that <kbd>Maybe</kbd> and <kbd>Single</kbd> types do not have an <kbd>onNext()</kbd> event but rather an <kbd>onSuccess()</kbd> operator to pass a single emission. Therefore, there is no <kbd>doOnNext()</kbd> operator on either of these types, as observed in the following code snippet, but rather a <kbd>doOnSuccess()</kbd> operator. Its usage should effectively feel like <kbd>doOnNext()</kbd>:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>5</span><span>, </span><span>3</span><span>, </span><span>7</span><span>, </span><span>10</span><span>, </span><span>2</span><span>, </span><span>14</span><span>)<br/></span><span>          .</span><span>reduce</span><span>((</span><span>total</span><span>, </span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>          .</span><span>doOnSuccess</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Emitting: " </span><span>+ </span><span>i</span><span>))<br/></span><span>          .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received: " </span><span>+ </span><span>i</span><span>));<br/></span><span>      }<br/></span><span>}</span></pre>
<p>The output of the preceding code snippet is as follows:</p>
<pre style="padding-left: 30px">    Emitting: 41<br/>    Received: 41</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We covered a lot of ground in this chapter, and hopefully by now, you are starting to see that RxJava has a lot of practical use. We covered various operators that suppress and transform emissions as well as reduce them to a single emission in some form. You learned how RxJava provides robust ways to recover from errors as well as get visibility into what <kbd>Observable</kbd> chains are doing with action operators.</p>
<p>If you want to learn more about RxJava operators, there are many resources online. Marble diagrams are a popular form of Rx documentation, visually showing how each operator works. The <em>rxmarbles.com</em> (<a href="http://rxmarbles.com">http://rxmarbles.com</a>) site is a popular, interactive web app that allows you to drag marble emissions and see the affected behavior with each operator. There is also an <em>RxMarbles</em> Android App (<a href="https://play.google.com/store/apps/details?id=com.moonfleet.rxmarbles">https://play.google.com/store/apps/details?id=com.moonfleet.rxmarbles</a>) that you can use on your Android device. Of course, you can also see a comprehensive list of operators on the ReactiveX website (<a href="http://reactivex.io/documentation/operators.html">http://reactivex.io/documentation/operators.html</a>).</p>
<p>Believe it or not, we have barely gotten started. This chapter only covered the basic operators. In the coming chapters, we will cover operators that perform powerful behaviors, such as concurrency and multicasting. But before we do that, let's move on to operators that combine Observables.</p>


            </article>

            
        </section>
    </body></html>