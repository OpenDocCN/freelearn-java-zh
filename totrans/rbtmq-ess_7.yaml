- en: Best Practices and Broker Monitoring
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践和代理监控
- en: The previous chapters of this book focused on the setup of a successful microservice
    architecture using RabbitMQ at the example company **Complete Car** (**CC**).
    Many RabbitMQ features were included, however, no system is complete without an
    understanding of the best practices to use in its implementation. As with all
    production systems, proper monitoring and alerts are also needed to stay on top
    of things.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章专注于使用RabbitMQ在示例公司**Complete Car**（**CC**）中设置成功的微服务架构。虽然包括了众多RabbitMQ功能，但任何系统如果没有对其实施的最佳实践的理解都是不完整的。与所有生产系统一样，适当的监控和警报也是必要的，以便保持对事物的掌控。
- en: CC's cluster is stable and there are no performance issues. This chapter summarizes
    the key takeaways learned from CC's system, including best practices and recommendations
    for queues, routing, exchanges, message handling, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CC的集群稳定，没有性能问题。本章总结了从CC的系统中学到的关键要点，包括队列、路由、交换、消息处理等方面的最佳实践和建议。
- en: 'This chapter explores the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了以下主题：
- en: How to avoid losing messages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免丢失消息
- en: Keeping queues and brokers clean
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持队列和代理清洁
- en: Routing best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由最佳实践
- en: Networking over connections and channels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过连接和通道进行网络通信
- en: Exploring key takeaways
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索关键要点
- en: Monitoring – querying the REST API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控 - 查询REST API
- en: This chapter is an ideal reference guide when setting up infrastructure using
    RabbitMQ. Refer back to the key takeaways, best practices, and monitoring tips
    in this chapter for valuable insights when putting RabbitMQ into production.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用RabbitMQ设置基础设施时，本章是一个理想的参考指南。在将RabbitMQ投入生产时，请回顾本章中的关键要点、最佳实践和监控技巧，以获得宝贵的见解。
- en: How to avoid losing messages
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何避免丢失消息
- en: Losing messages can be avoided by following the best practices in this section.
    For the most part, CC has followed the best practice of **keeping queues short**
    and efficient. Queues that contain too many messages have a negative impact on
    the broker's performance. An identified **high RAM usage** could indicate that
    the number of queued messages rapidly went up.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本节中的最佳实践可以避免消息丢失。大部分情况下，CC遵循了最佳实践，即**保持队列短小高效**。包含太多消息的队列会对代理的性能产生负面影响。已识别的**高RAM使用**可能表明队列中的消息数量迅速增加。
- en: 'Here are some best practice recommendations for how to not lose messages in
    RabbitMQ:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于如何在RabbitMQ中不丢失消息的最佳实践建议：
- en: Use at least three nodes in the RabbitMQ cluster, and the **quorum queue** type
    to spread messages to different nodes.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RabbitMQ集群中使用至少三个节点，并使用**法定多数队列**类型将消息传播到不同的节点。
- en: If it is absolutely imperative that all messages are processed, declare a queue
    as **durable** and set the message delivery mode to **persistent**, as described
    in [Chapter 2](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi Application*.
    Queues, exchanges, and messages need to be able to handle any restarts, crashes,
    or hardware failures that may occur.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果绝对必要确保所有消息都被处理，则将队列声明为**持久**的，并将消息投递模式设置为**持久**，如[第2章](377ec533-342d-4a08-9011-7176de197886.xhtml)中所述，*创建出租车应用程序*。队列、交换和消息需要能够处理可能发生的任何重启、崩溃或硬件故障。
- en: 'Here are some clarifications regarding message handling in RabbitMQ:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于RabbitMQ中消息处理的澄清：
- en: Understanding the trade-offs that come with persistence is essential when designing
    a durable system architecture. **Lazy queues**, though using transient messages,
    have a similar effect on performance.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解持久性带来的权衡是设计耐用系统架构时的关键。**懒队列**虽然使用临时消息，但对性能的影响类似。
- en: Using transient messages with durable queues creates speed without losing configuration
    but may result in message loss.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用临时消息与持久队列结合可以创造速度，而不会丢失配置，但可能会导致消息丢失。
- en: What if all these best practices are followed and messages are still in jeopardy
    of being lost? The next section covers the dead letter exchange, so messages that
    would potentially be gone forever have a place to wait until they can be processed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遵循了所有这些最佳实践，消息仍然有丢失的风险，那么下一节将介绍死信交换，这样那些可能永远消失的消息就有地方等待，直到它们可以被处理。
- en: Using a dead letter exchange
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用死信交换
- en: Even when using durable queues and persistent messages, issues can occur that
    result in unhandled messages. A TTL might be set, a queue length might have been
    exceeded or the message might have been negatively acknowledged by the consumer.
    As a best practice, the routing key of the message should specify `x-dead-letter-routing-key`
    so that the message is never dropped. Attach queues to the exchange and manage
    messages programmatically. Try to avoid sending messages to the same exchange
    as this may result in a form of infinite recursion. Some messages might be unmanageable
    to handle and continually end up in the exchange. Make sure to handle these errors
    in the programming logic.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用持久队列和持久消息，也可能出现导致未处理消息的问题。可以设置TTL，队列长度可能已超过，或者消息可能被消费者否定确认。作为最佳实践，消息的路由键应指定`x-dead-letter-routing-key`，以确保消息永远不会丢失。将队列附加到交换机并按程序管理消息。尽量避免将消息发送到同一交换机，因为这可能导致无限递归。有些消息可能难以处理，并不断进入交换机。确保在编程逻辑中处理这些错误。
- en: Set the `x-dead-letter-routing-key` property in the declaration of a queue.
    This helps with performance and separate error handling by components in the architecture,
    as described in *[Chapter 4](bece97d2-6653-459f-bbdc-6e47f343c1d3.xhtml), Tweaking
    Message Delivery*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列的声明中设置`x-dead-letter-routing-key`属性。这有助于提高性能，并使架构中的组件能够分别处理错误，如[第4章](bece97d2-6653-459f-bbdc-6e47f343c1d3.xhtml)中所述，调整消息传递。
- en: It is recommended for applications that often get hit by spikes of messages
    to set a queue max-length. The queue max-length helps keeping the queue short
    by discarding messages from the head of the queue. The max-length can be set to
    a number of messages, or a set number of bytes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经常受到消息峰值冲击的应用程序，建议设置队列最大长度。队列最大长度通过丢弃队列头部的消息来保持队列较短。最大长度可以设置为消息数量，或固定字节数。
- en: Handling acknowledgments and confirms
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理确认和确认
- en: In the event of a connection failure, a message in transit may get lost. Acknowledgments
    provide an alert to the server and the clients if messages need to be retransmitted.
    The client can either ack the message when it is received or when it has processed
    the message. However, it is important to remember that the application that consumes
    important messages should not ack until handled. That way, unprocessed messages
    from crashes or exceptions don't end up being missed. A publisher confirmation
    requires the server to confirm a message has been received from a publisher.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接失败的情况下，传输中的消息可能会丢失。如果需要重新传输消息，确认会向服务器和客户端提供警报。客户端可以在收到消息时或处理完消息后确认消息。然而，重要的是要记住，消费重要消息的应用程序应在处理后再确认，这样未处理的来自崩溃或异常的消息就不会丢失。发布者确认需要服务器确认已从发布者接收消息。
- en: Confirms can also have an impact on system performance, but they are required
    if the publisher must process messages at least once.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 确认也可能影响系统性能，但如果发布者必须至少处理一次消息，则它们是必需的。
- en: Best practices of message handling
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息处理最佳实践
- en: Queues and clients handle the burden of their payloads – messages. To further
    improve performance, fine-tune messages and message handling.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 队列和客户端处理它们的负载——消息。为了进一步提高性能，微调消息和消息处理。
- en: Limiting message size
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制消息大小
- en: The number of messages sent per second is a much larger concern than the size
    of the messages themselves. However, sending large messages is not a best practice,
    and neither is sending too small messages since AMQP adds a small packet overhead
    to all messages sent.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒发送的消息数量比消息本身的大小更令人担忧。然而，发送大消息不是最佳实践，发送过小的消息也不是，因为AMQP会给所有发送的消息添加一个小数据包开销。
- en: 'Examine messages to see whether they can be split and sent to different queues,
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 检查消息，看是否可以将其拆分并发送到不同的队列，如下所示：
- en: Split iterable data into chunks and send a small chunk per message.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可迭代数据拆分为块，每条消息发送一个小块。
- en: Store large files in a distributed store, such as Hadoop or networked attached
    storage.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大文件存储在分布式存储中，如Hadoop或网络附加存储。
- en: Split the architecture into more modular components with a queue per component.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将架构拆分为更多模块化组件，每个组件一个队列。
- en: Offload appropriate metadata to a key-value store.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将适当的元数据卸载到键值存储中。
- en: While sending large messages can be avoided, bandwidth, architecture, and fail-over
    limits are a consideration. The size of the message will depend on the application
    but should be as small as possible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以避免发送大消息，但带宽、架构和故障转移限制是需要考虑的因素。消息的大小取决于应用程序，但应尽可能小。
- en: Using consumers and prefetching
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用消费者和预取
- en: Setting a prefetch value distributes workloads evenly across the system. Prefetching
    is allowed in RabbitMQ, but it is important to remember that prefetching is only
    effective when all consumers are busy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 设置预取值可以在系统内均匀地分配工作负载。RabbitMQ 允许预取，但重要的是要记住，只有在所有消费者都忙碌时，预取才是有效的。
- en: RabbitMQ must manage consumption across queues and consumers. A prefetch value
    that is too low keeps the consumers idle as they wait for messages to arrive,
    which in turn will slow down the broker's ability to handle requests. Setting
    the prefetch value too high keeps one consumer busy while the rest remain idle,
    as described in *[Chapter 3](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml), Sending
    Messages to Multiple Taxi Drivers*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 必须管理跨队列和消费者的消费。预取值过低会使消费者空闲，等待消息到达，这反过来会减慢代理处理请求的能力。设置预取值过高会使一个消费者忙碌，而其余的消费者保持空闲，如*[第
    3 章](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml)，向多个出租车司机发送消息*中所述。
- en: If processing time is low and the network is stable, then the prefetch value
    can be increased. In this case, the prefetch value can be determined easily by
    dividing the total round trip time by the processing time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理时间低且网络稳定，则可以增加预取值。在这种情况下，可以通过将总往返时间除以处理时间来确定预取值。
- en: If there are many consumers and a longer processing time, the prefetch value
    trends lower. If processing times are long enough, set the prefetch limit to 1.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个消费者和较长的处理时间，预取值会趋于较低。如果处理时间足够长，可以将预取限制设置为 1。
- en: As queues get busier with demand, more system resources are consumed. Keeping
    the queues and brokers clean is imperative for good performance, which is covered
    in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 随着需求增加，队列变得更加繁忙，系统资源消耗也更多。保持队列和代理的清洁对于良好的性能至关重要，这将在下一节中介绍。
- en: Keeping queues and brokers clean
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持队列和代理的清洁
- en: A clean broker is an efficient broker. To keep power and space at an optimum
    level, making sure queues and brokers are clean is easy. RabbitMQ provides mechanisms
    for auto-deleting messages and queues to keep space free. These include setting
    the **time to live** (**TTL**) and auto-deletion of unused queues, which are detailed
    in the following sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁的代理是高效的代理。为了保持功率和空间在最佳水平，确保队列和代理清洁是很容易的。RabbitMQ 提供了自动删除消息和队列以保持空间空闲的机制。这包括设置**存活时间**（**TTL**）和自动删除未使用的队列，这些将在以下章节中详细介绍。
- en: Setting the TTL for messages or the max-length on queues
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为消息设置 TTL 或队列的最大长度
- en: Queues providing messaging support for long-running processes may grow extremely
    large. A too large queue might affect the performance of the broker. Setting the
    **TTL **allows messages to be removed from the queue after a certain time. If
    specified, these messages enter the dead letter exchange. This saves more messages
    and even handles potential issues without losing data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为长时间运行的过程提供消息支持的队列可能会变得非常大。过大的队列可能会影响代理的性能。设置 **TTL** 允许在一段时间后从队列中删除消息。如果指定，这些消息将进入死信交换。这可以保存更多消息，甚至处理潜在问题而不会丢失数据。
- en: Set a reasonable **TTL** with the `x-message-ttl` property when declaring a
    queue. Make sure to provide `x-dead-letter-exchange` and `x-dead-letter-routing-key`
    to avoid losing messages entirely.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明队列时，使用 `x-message-ttl` 属性设置合理的 **TTL**。请确保提供 `x-dead-letter-exchange` 和 `x-dead-letter-routing-key`
    以避免完全丢失消息。
- en: It is recommended for applications that often get hit by spikes of messages
    to set a queue max-length. The queue max-length helps keeping the queue short
    by discarding messages from the head of the queue. The max-length can be set to
    a number of messages, or a set number of bytes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经常受到消息高峰冲击的应用程序，建议设置队列最大长度。队列最大长度通过丢弃队列头部的消息来保持队列短小。最大长度可以设置为消息数量，或字节数量。
- en: Auto-deleting unused queues
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动删除未使用的队列
- en: In addition to keeping queues from becoming overly large, queues can be dropped
    based on use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了防止队列变得过大之外，还可以根据使用情况删除队列。
- en: 'There are three ways to delete an unused queue automatically, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自动删除未使用队列有三种方法，如下所示：
- en: Set an expiration policy for the queue using the `x-expires` property on the
    declaration, keeping queues alive only for a number of non-zero milliseconds when
    unused.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用声明中的`x-expires`属性为队列设置过期策略，当未使用时，只保持队列活跃数毫秒。
- en: 'Set the `auto-delete` queue property to `true` on the declaration. This means
    the queue will be dropped after the following scenarios:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明中将`auto-delete`队列属性设置为`true`。这意味着在以下情况下队列将被删除：
- en: The initial connection is made.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立了初始连接。
- en: The last consumer shuts down.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个消费者关闭。
- en: The channel/connection is closed or the queue has lost the **Transmission Control
    Protocol** (**TCP**) connection with the server.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道/连接被关闭或队列失去了与服务器之间的**传输控制协议**（**TCP**）连接。
- en: Set the exclusive property to `true` on queue declaration so that the structure
    belongs to the declaring connection and is deleted when the connection closes.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在队列声明中将独占属性设置为`true`，这样结构就属于声明连接，并在连接关闭时被删除。
- en: Sometimes, the journey itself is what creates inefficiency in a message queue.
    To make sure messages are taking the best path possible, follow the best practices
    for routing found in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，消息队列中的旅程本身就会造成低效。为了确保消息走的是最佳路径，请遵循下一节中找到的路由最佳实践。
- en: Routing best practices
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由最佳实践
- en: As a best practice, direct exchanges are the fastest to use. Even when using
    direct exchanges, those with multiple bindings require more time to calculate
    where messages must be sent. There are some additional best practices to consider
    for routing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，直接交换是使用最快的。即使在使用直接交换时，具有多个绑定也需要更多时间来计算消息必须发送的位置。在路由方面还有一些额外的最佳实践需要考虑。
- en: Designing a system with routing in mind
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑路由设计系统
- en: Every endpoint is a service or application. Unlike CC, which operates between
    a car and, for the most part, a single application layer, many microservice architectures
    pass messages through dozens of services.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个端点都是一个服务或应用程序。与CC不同，CC在汽车和大部分单一应用层之间运行，而许多微服务架构通过数十个服务传递消息。
- en: CC designed their system architecture around small services. They combined operations
    where it did make sense. After designing a smaller system, they consider where
    additional exchanges or queues could be beneficial. This kept the overall design
    small enough without limiting processing power.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CC围绕小型服务设计了他们的系统架构。他们结合了有意义的操作。在设计了较小的系统之后，他们考虑了额外的交换或队列可能有益的地方。这保持了整体设计足够小，同时不会限制处理能力。
- en: Networking over connections and channels
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过连接和通道进行网络通信
- en: Thousands of connections add up to a heavy burden on a RabbitMQ server, causing
    it to run out of memory and crash. A large number of connections and channels
    can also negatively impact the RabbitMQ management interface due to the large
    number of performance metrics being processed. To avoid this, configure each application
    to create an extremely small number of connections – 1, if possible. Instead of
    using multiple connections, establish a channel for each thread. Each connection
    should be long-lived and the following best practices should be considered depending
    on the application structure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数千个连接对RabbitMQ服务器来说是一个沉重的负担，导致其内存耗尽并崩溃。大量连接和通道也可能由于处理大量性能指标而负面影响RabbitMQ管理界面。为了避免这种情况，请为每个应用程序配置创建极少数量的连接——如果可能的话，1个。而不是使用多个连接，为每个线程建立一个通道。每个连接应该是长久的，并且应根据应用程序结构考虑以下最佳实践。
- en: Remember that even if new hardware offers hundreds of threads, only the number
    of channels set can be established and this number should be kept from growing
    too large. As some clients don't make channels thread-safe, it is best not to
    share channels between threads. Doing so may create a race condition, which could
    completely crash the application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，即使新的硬件提供了数百个线程，也只能建立设置的通道数，并且这个数字不应过大。由于一些客户端没有使通道线程安全，最好不要在线程之间共享通道。这样做可能会创建竞争条件，这可能导致应用程序完全崩溃。
- en: Repeatedly opening and closing connections and channels is also detrimental
    to system performance. Doing so increases latency as more TCP packets are sent
    over the network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重复打开和关闭连接和通道也会损害系统性能。这样做会增加延迟，因为更多的TCP数据包通过网络发送。
- en: Using TLS and AMQPS for security
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TLS和AMQPS进行安全
- en: RabbitMQ can be connected over AMQPS, which is the AMQP protocol wrapped in
    TLS. Data passed over the network is encrypted, but there is a performance impact
    to consider. To maximize performance, use VPC or VPN peering instead since they
    provide a private, isolated environment for traffic and do not involve the AMQP
    client and server directly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 可以通过 AMQPS 连接，即 TLS 包装的 AMQP 协议。通过网络传输的数据被加密，但需要考虑性能影响。为了最大化性能，请使用
    VPC 或 VPN 对等连接，因为它们为流量提供了一个私有、隔离的环境，并且不直接涉及 AMQP 客户端和服务器。
- en: Do not expose the backend over the frontend. The CC example is simplified. In
    reality, there would likely be an application layer added between unknown users
    and the broker.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在前端暴露后端。CC 示例被简化了。在现实中，很可能在未知用户和代理之间添加一个应用层。
- en: Separate connections
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离的连接
- en: By default, RabbitMQ will reduce the speed of connections that publish too quickly
    for queues to keep up. RabbitMQ simply applies back-pressure on the TCP connection,
    which places it in flow control. A flow-controlled connection shows a state of
    flow in the management UI and through HTTP API responses. This means the connection
    is experiencing blocking and unblocking several times a second to keep the message
    flow rate at a level that the rest of the server and the queues can handle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，RabbitMQ 会降低发布速度过快的连接速度，以便队列能够跟上。RabbitMQ 简单地对 TCP 连接应用反向压力，将其置于流量控制状态。流量控制的连接在管理
    UI 和 HTTP API 响应中显示流量状态。这意味着连接每秒经历多次阻塞和解阻塞，以保持消息流率在一个服务器和队列都能处理的水准。
- en: When the publisher is using the same TCP connection as the consumer, messages
    can be blocked while replying to the broker. The server may not receive the acks
    from the client, which will have a negative impact on the speed and cause it to
    be overwhelmed. Achieving higher throughput is, therefore, best accomplished through
    separate connections for publishers and consumers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布者使用与消费者相同的 TCP 连接时，在回复代理时可能会阻塞消息。服务器可能无法从客户端收到确认，这将对其速度产生负面影响，并可能导致其过载。因此，通过为发布者和消费者使用单独的连接来实现更高的吞吐量是最佳选择。
- en: Splitting queues over different cores
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同的核心上分割队列
- en: The CC infrastructure runs on multiple cores. To achieve better performance,
    queues are split among different cores and nodes. Queues in RabbitMQ are bound
    to the node where they are first declared. This holds true even for clustered
    brokers, as all messages routed to a specific queue go to the node where the queue
    lives. One queue in RabbitMQ can handle up to 50,000 messages a second. Better
    performance is therefore achieved when queues are split over different cores and
    nodes, and when they are spread between multiple queues.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CC 基础设施运行在多个核心上。为了获得更好的性能，队列被分散在不同的核心和节点之间。RabbitMQ 中的队列绑定到它们首次声明的节点。即使对于集群代理也是如此，因为所有路由到特定队列的消息都发送到队列所在的节点。RabbitMQ
    中的一个队列每秒可以处理高达 50,000 条消息。因此，当队列在不同核心和节点之间分割，并在多个队列之间分散时，可以获得更好的性能。
- en: It is possible to manually split queues evenly between nodes, but this can be
    difficult to remember. Alternatively, there are two plugins to assist with organizing
    multiple nodes or a single node cluster with multiple cores. These are the **Consistent
    Hash Exchange** and the **RabbitMQ sharding** plugins.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以手动在节点之间均匀分割队列，但这可能难以记住。或者，有两个插件可以帮助组织多个节点或单个节点集群的多核。这些是**一致性哈希交换**和**RabbitMQ
    分片**插件。
- en: RabbitMQ sharding
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RabbitMQ 分片
- en: 'Sharding makes it easy to distribute messages among queues on different nodes. A
    queue can be spread among multiple actual queues. Once an exchange is defined
    as sharded, the supporting queues automatically start on every cluster node with
    messages spreading accordingly, as shown in the following diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 分片使得在不同节点上的队列之间分配消息变得容易。一个队列可以分散到多个实际队列中。一旦交换被定义为分片，支持队列将自动在每个集群节点上启动，消息相应地分散，如下所示：
- en: '![](img/284071c3-7926-4dae-8b99-dca7de34ec89.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/284071c3-7926-4dae-8b99-dca7de34ec89.png)'
- en: 'Fig 7.1: Sharding among queues'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：队列间的分片
- en: The routing keys ensure an even distribution of messages among queues. The plugin
    expects you to run a consumer per shard with new nodes being automatically incorporated.
    Note that it's important to consume from all queues. The plugin provides a centralized
    place to send messages, and load-balances messages across nodes by adding queues
    across the cluster. Read more about the RabbitMQ sharding plugin at: [https://github.com/rabbitmq/rabbitmq-sharding](https://github.com/rabbitmq/rabbitmq-sharding).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 路由键确保消息在队列之间均匀分布。插件期望你为每个分片运行一个消费者，新节点会自动纳入。请注意，从所有队列中消费是很重要的。插件提供了一个集中位置来发送消息，并通过在集群中添加队列来跨节点负载均衡消息。更多关于RabbitMQ分片插件的详细信息请参阅：[https://github.com/rabbitmq/rabbitmq-sharding](https://github.com/rabbitmq/rabbitmq-sharding)。
- en: Consistent Hash Exchange
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一致性哈希交换
- en: RabbitMQ offers another plugin that helps load-balance messages through the
    Consistent Hash Exchange. Based on the routing key, **bound** queues in this exchange
    are sent messages equally. This optimizes the use of a cluster with multiple cores,
    as the plugin creates a hash of the routing key and is consistent about spreading
    messages between queues bound to the exchange, ensuring optimal use over many
    cores in a cluster.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ提供了一个插件，可以帮助通过一致性哈希交换来负载均衡消息。基于路由键，此交换中**绑定**的队列会均匀地发送消息。这优化了具有多个核心的集群的使用，因为插件会创建路由键的哈希，并确保在交换绑定的队列之间均匀分配消息，确保在集群的多个核心上优化使用。
- en: Read more about the Consistent Hash Exchange plugin at: [https://github.com/rabbitmq/rabbitmq-consistent-hash-exchange](https://github.com/rabbitmq/rabbitmq-consistent-hash-exchange).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于一致性哈希交换插件的详细信息请参阅：[https://github.com/rabbitmq/rabbitmq-consistent-hash-exchange](https://github.com/rabbitmq/rabbitmq-consistent-hash-exchange)。
- en: Exploring key takeaways
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索关键要点
- en: For the sake of simplification, optimization can be broken into two forms, and
    since cars have been a popular topic in this book, let's stick with that theme.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，优化可以分为两种形式，鉴于本书中汽车是一个热门话题，让我们继续这个主题。
- en: '**Ferrari** **–** **fast and smooth**: If the system must have fast performance
    and high throughput, use a single node. Keep queues as short as possible, and
    set the max length or TTL if possible. Do not set the lazy queue policies to keep
    retrieval time short. Use transient messages, rather than persistent ones, for
    the same reason. Take advantage of using multiple queues and consumers, providing
    maximum throughput. For the fastest possible throughput, manual acks should be
    disabled. Always strive to use the latest stable RabbitMQ version.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**法拉利** **–** **快速平稳**：如果系统必须具有快速性能和高吞吐量，则使用单个节点。尽可能保持队列最短，如果可能的话，设置最大长度或TTL。不要设置懒队列策略以保持检索时间短。出于相同的原因，使用临时消息而不是持久消息。利用多个队列和消费者的使用，提供最大吞吐量。为了实现最快的吞吐量，应禁用手动确认。始终努力使用最新的稳定RabbitMQ版本。'
- en: '**Volvo** **–** **stable and reliable**:A system that must be highly available
    and cannot afford to lose messages should have durable queues and send persistent
    messages. Queues should still be kept short.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**沃尔沃** **–** **稳定可靠**：一个必须高度可用且不能丢失消息的系统应该有耐用的队列并发送持久消息。队列仍然应该保持较短。'
- en: It is recommended that clustering is set up through quorum queues. If mirrored
    queues are already in use, add the lazy queue policy to get a more stable setup.
    Make sure that three or five nodes are used in the system to achieve high availability.
    When setting up a RabbitMQ cluster, split queues among different cores and into
    different nodes, using the Consistent Hash Exchange or sharding plugins to keep
    everything running smoothly and efficiently. Always strive to use the latest stable
    RabbitMQ version.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过法定队列来设置集群。如果已经使用镜像队列，添加懒队列策略以获得更稳定的设置。确保系统中使用三个或五个节点以实现高可用性。在设置RabbitMQ集群时，使用一致性哈希交换或分片插件在不同核心和不同节点之间分割队列，以保持一切运行顺畅和高效。始终努力使用最新的稳定RabbitMQ版本。
- en: Now that the best practice tips have been covered, it's time to consider what
    should occur if and when something goes wrong. Monitoring the cluster and setting
    alarm policies are two very important finishing touches to any production environment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 既然最佳实践提示已经介绍完毕，现在是时候考虑如果出现问题应该发生什么了。监控集群和设置警报策略是任何生产环境的重要收尾工作。
- en: Monitoring – querying the REST API
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控 – 查询REST API
- en: 'There are two main ways to retrieve live information when monitoring a RabbitMQ
    broker: one through the `rabbitmqctl` command-line tool and another through the
    **REST API** exposed over HTTP by the management console.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 监控RabbitMQ代理时，检索实时信息有两种主要方式：一种是通过`rabbitmqctl`命令行工具，另一种是通过管理控制台通过HTTP公开的**REST
    API**。
- en: Any monitoring system can use these tools to collect metrics and report them
    to the log, analytics, reporting, and alert frameworks. Information could be pushed
    to external logging services for further analysis, as an example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 任何监控系统都可以使用这些工具来收集指标并将它们报告给日志、分析、报告和警报框架。例如，可以将信息推送到外部日志服务进行进一步分析。
- en: Since CC installed the management console, as described in [Chapter 1](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml)*,
    A Rabbit Springs to Life*, the team opts to use the rich, well-documented API
    over the command line. RabbitMQ provides documentation at the `http://localhost:15672/` API
    on any node that has the management plugin installed. It is possible to retrieve
    the same raw metrics over the command line, albeit without graphics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 自从CC安装了管理控制台，如[第1章](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml)*《Rabbit Springs
    to Life》*中所述，团队选择使用丰富、文档齐全的API而不是命令行。RabbitMQ在任何安装了管理插件的节点上提供`http://localhost:15672/`
    API的文档。虽然如此，也可以通过命令行检索相同的原始指标，但缺乏图形界面。
- en: Keep in mind that the management console is backed by the API, so anything that
    is seen and done within a browser can be done through the API.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，管理控制台由API支持，因此浏览器内看到的任何操作都可以通过API完成。
- en: 'RabbitMQ exposes a variety of different metric types for collection, as discussed
    in the preceding sections. These include, but are not limited to, the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ公开了各种不同的指标类型以供收集，如前文所述。这些包括但不限于以下内容：
- en: '**Node status**: Testing the performance of RabbitMQ involves executing a set
    of commands to declare an aliveness-test queue and then publishing as well as
    consuming it. Set an alarm to fire if the command returns `0` (no messages consumed)
    through the appropriate request:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点状态**：测试RabbitMQ的性能涉及执行一系列命令来声明一个存活性测试队列，然后发布和消费它。如果命令返回`0`（没有消费消息），则通过适当的请求设置一个警报：'
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Cluster size**: Testing the cluster size is useful for discovering network
    partitions. Set an alarm to fire if the cluster size is lower than expected:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群大小**：测试集群大小对于发现网络分区很有用。如果集群大小低于预期，则设置一个警报：'
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: CC uses a `bash` script and Python to send an error when the number of nodes
    is less than expected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: CC使用`bash`脚本和Python发送错误，当节点数量低于预期时。
- en: '**Federation status**: Federated queues may become unlinked due to a restart
    or another issue. Check the active upstream links on the central log aggregation
    broker and raise an alarm if it''s less than the optimal size (`3`, in CC''s case),
    as follows:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联邦状态**：由于重启或其他问题，联邦队列可能会解耦。请检查中央日志聚合代理上的活动上游链接，如果其数量小于最佳大小（在CC的情况下为`3`），则发出警报，如下所示：'
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Queues'' high watermarks**: Cloud-based brokers sometimes offer scale at
    low cost but with message limits. In other cases, message latency is an issue.
    Ensure that the number of available messages in a queue is below a certain threshold:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列的高水位**：基于云的代理有时以低成本提供扩展，但有限制消息。在其他情况下，消息延迟是一个问题。确保队列中可用的消息数量低于某个阈值：'
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In CC's case, they want to verify that the `taxi-dlq` queue has less than 25
    messages. Otherwise, they raise an alarm indicating a bottleneck. Scripts need
    to handle a graceful failure if the queue does not exist.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在CC的情况下，他们想验证`taxi-dlq`队列中的消息少于25条。否则，他们发出警报，表明存在瓶颈。如果队列不存在，脚本需要处理优雅的失败。
- en: '**Overall message throughput**: Monitoring the intensity of messaging traffic
    on a particular broker makes it possible to increase or decrease resources as
    required. Collect message rates with the following command:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整体消息吞吐量**：监控特定代理上的消息流量强度可以使资源根据需要增加或减少。使用以下命令收集消息速率：'
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: CC adds an alarm if the throughput threshold exceeds the upper limit of what
    one its brokers can withstand.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当CC的吞吐量阈值超过其代理可以承受的上限时，CC会添加一个警报。
- en: 'Some metrics come with rigid upper limits whose values are also available through
    the API. A recommendation is to raise an alarm whenever a threshold of 80 percent
    of the upper limit is reached. The following scripts return false when the alarm
    must be raised. These metrics include the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指标具有严格的最高限制，其值也通过API提供。建议在达到上限80%的阈值时发出警报。以下脚本在必须发出警报时返回false。这些指标包括以下内容：
- en: '**File descriptors**: Many OSes have file descriptor limits. The performance
    of the message persistence on the disk can be affected if not enough descriptors
    are available. The number of file descriptors used can be compared with the amount
    of available file descriptors:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件描述符**：许多操作系统都有文件描述符限制。如果可用的描述符不足，磁盘上消息持久化的性能可能会受到影响。使用的文件描述符数量可以与可用文件描述符的数量进行比较：'
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is possible to increase the number of available file descriptors on macOS
    X and Linux. File descriptors are used to access other files. It's a good idea
    to check throughputs if this limit is exceeded as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS X和Linux上，可以增加可用的文件描述符数量。文件描述符用于访问其他文件。如果超过这个限制，检查吞吐量也是一个好主意。
- en: '**Socket descriptors**: Socket descriptors maintain a handle to an individual
    socket for a connection. RabbitMQ stops accepting new connections if these descriptors
    are exhausted, which is a common issue with large clusters:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字描述符**：套接字描述符维护对单个套接字的连接句柄。如果这些描述符耗尽，RabbitMQ将停止接受新的连接，这是大型集群中常见的问题：'
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Linux uses file descriptors for sockets, adjusting the count with the `ulimit`
    command. Using more channels and fewer connections, in line with best practices,
    helps to handle this issue as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Linux使用文件描述符来处理套接字，可以通过`ulimit`命令调整计数。遵循最佳实践，使用更多通道和更少的连接可以帮助处理这个问题。
- en: '**Erlang processes**: There is an upper limit to the number of processes an
    Erlang virtual machine creates. Although typically near 1 million processes, each
    requires resources to run. The number of Erlang processes used can be compared
    with the Erlang process limit:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Erlang进程**：Erlang虚拟机创建的进程数量有一个上限。尽管通常接近100万进程，但每个进程都需要资源来运行。使用的Erlang进程数量可以与Erlang进程限制进行比较：'
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An OS thread is not created for each process. Still, each uses a lightweight
    stack and requires time to schedule and maintain.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统不会为每个进程创建线程。尽管如此，每个进程都使用轻量级栈，并且需要时间来调度和维护。
- en: '**Memory and disk space**: If memory or disk space is exhausted, RabbitMQ will
    not work properly – for example, flow control can be triggered. Check that there
    are sufficient resources and tune the hardware appropriately.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存和磁盘空间**：如果内存或磁盘空间耗尽，RabbitMQ将无法正常工作——例如，可能会触发流控制。请确保有足够的资源，并相应地调整硬件。'
- en: 'The total amount of memory used should be less then 80 percent of the memory
    usage high watermark:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该使用的总内存量应小于内存使用量高水位线的80%：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The disk free space limit should be compared to the current free disk space:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘可用空间限制应与当前可用磁盘空间进行比较：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In addition to metrics, a working instance runs the following programs:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指标外，一个运行实例还会运行以下程序：
- en: '`rabbitmq-server`: This is obvious but should not be forgotten!'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rabbitmq-server`：这是显而易见的，但不应被遗忘！'
- en: '`epmd`: The Erlang port mapper daemon, `epmd`, plays a critical role in clustering
    and networking. It is advisable to set up scripts to check that these services
    are running. List programs using `ps` on Linux or macOS X and `Get-Process` in
    Windows.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`epmd`：Erlang端口映射器守护进程`epmd`在集群和网络中起着关键作用。建议设置脚本以检查这些服务是否正在运行。在Linux或macOS
    X上使用`ps`列出程序，在Windows上使用`Get-Process`。'
- en: '`ERROR REPORT` entries in the main log file reveal issues within the system.
    In Linux, RabbitMQ stores log files at `/var/log/rabbitmq/rabbit@<hostname>.log`.
    For more information, check the configuration file at [https://www.rabbitmq.com/logging.html#log-file-location](https://www.rabbitmq.com/logging.html#log-file-location).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 主日志文件中的`ERROR REPORT`条目揭示了系统中的问题。在Linux中，RabbitMQ将日志文件存储在`/var/log/rabbitmq/rabbit@<hostname>.log`。有关更多信息，请检查配置文件[https://www.rabbitmq.com/logging.html#log-file-location](https://www.rabbitmq.com/logging.html#log-file-location)。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter concludes the study of microservices built on RabbitMQ with an
    examination of best practices as well as monitoring. The book went through the
    application funnel for CC, beginning with the basic service and scaling. New features
    and processes were added with ease and without interruption to the CC application.
    Over time, CC’s development team created a holistic, useful, reliable, long-life
    application. To avoid failures that could lead to bad user experience or even
    data loss, the CC team implemented a monitoring strategy. Collecting, logging,
    analyzing, and reporting metrics were outlined as CC formed an alert plan. Finally,
    the alert parameters were set up through the RabbitMQ management console.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过考察最佳实践和监控，总结了基于RabbitMQ构建的微服务的研究。本书经历了CC应用的应用流程，从基本服务到扩展。新功能和流程轻松添加，且没有中断CC应用。随着时间的推移，CC的开发团队创建了一个全面、实用、可靠、长期运行的应用。为了避免可能导致不良用户体验或甚至数据丢失的故障，CC团队实施了一个监控策略。在CC形成警报计划的过程中，概述了收集、记录、分析和报告指标。最后，通过RabbitMQ管理控制台设置了警报参数。
- en: Congratulations on completing your journey through this book! Armed with sufficient
    RabbitMQ wrangling skills, the next step is to create an instance for yourself.
    An easy way to get started with RabbitMQ is through the manager of the largest
    fleet of RabbitMQ clusters in the world – hosted RabbitMQ provider CloudAMQP.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您完成了这本书的阅读之旅！拥有了足够的RabbitMQ驯服技能后，下一步是为您自己创建一个实例。开始使用RabbitMQ的一个简单方法是通过世界上最大的RabbitMQ集群托管服务提供商CloudAMQP。
