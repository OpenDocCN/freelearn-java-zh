- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Identifying the Right Data Platform
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定合适的数据平台
- en: In the previous chapter, we discussed the various data types, their formats,
    and their storage. We also covered different databases and provided an overview
    of them. Then, we understood the factors and features we should compare when choosing
    a data format, storage type, or database for any use case to solve a data engineering
    problem effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了各种数据类型、它们的格式和存储。我们还介绍了不同的数据库，并提供了它们的概述。然后，我们了解了在选择数据格式、存储类型或数据库时，我们应该比较的因素和特性，以有效地解决数据工程问题。
- en: In this chapter, we will look at the various kinds of popular platforms that
    are available to run data engineering solutions. You will also learn about the
    considerations you should make as an architect to choose one of them. To do so,
    we will discuss the finer details of each platform and the alternatives these
    platforms provide. Finally, you will learn how to make the most of these platforms
    to architect an efficient, robust, and cost-effective solution for a business
    problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨各种流行的平台，这些平台可用于运行数据工程解决方案。你还将了解作为架构师在选择其中之一时应考虑的因素。为此，我们将讨论每个平台的详细信息和这些平台提供的替代方案。最后，你将学习如何充分利用这些平台，为业务问题构建一个高效、健壮且成本效益高的解决方案。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主要主题：
- en: Virtualization and containerization platforms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化和容器化平台
- en: Hadoop platforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hadoop平台
- en: Cloud platforms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云平台
- en: Choosing the correct platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的平台
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you’ll need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章内容，你需要以下内容：
- en: JDK 1.8 or above
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8或更高版本
- en: Apache Maven 3.3 or above
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Maven 3.3或更高版本
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter03](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter03)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter03](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter03)
- en: Virtualization and containerization platforms
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化和容器化平台
- en: With the spread of **information technology** (**IT**) in all spheres of life,
    the dependency and reliability on IT infrastructure have increased manifold. Now,
    IT runs so many critical and real-time businesses. This means that there can be
    zero or negligible downtime for maintenance or failure. Also, rapid real-time
    demands have grown. For example, during the holiday season, there’s a huge amount
    of traffic on online shopping websites. So, now, IT needs to be highly available,
    elastic, flexible, and quick. These were the reasons that motivated the creation
    of virtual platforms such as virtualization and containerization. For example,
    Barclays, a multinational financial firm based in the UK, was facing a hard time
    from competitors due to their slow pace of innovation and project deliveries.
    One of its major roadblocks was the time it took to provision new servers. So,
    they decided to use Red Hat OpenShift to containerize their application. This
    reduced the provisioning time dramatically from weeks to hours. As a result, time
    to market became super fast, which helped Barclays stay ahead of its competitors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着信息技术（**IT**）在生活各个领域的普及，对IT基础设施的依赖性和可靠性成倍增加。现在，IT运行着许多关键和实时的业务。这意味着维护或故障期间可以零或极小的停机时间。此外，快速实时需求也在增长。例如，在假日季节，在线购物网站上的流量巨大。因此，现在IT需要高度可用、弹性、灵活和快速。这些正是推动虚拟平台如虚拟化和容器化创建的原因。例如，总部位于英国的跨国金融公司巴克莱斯，由于创新和项目交付速度缓慢，正面临来自竞争对手的困难。其主要障碍之一是新服务器配置所需的时间。因此，他们决定使用Red
    Hat OpenShift来容器化他们的应用程序。这显著减少了从周级到小时级的配置时间。结果，上市时间变得超级快，这帮助巴克莱斯在竞争中保持领先。
- en: '**Virtualization** abstracts the hardware and allows you to run multiple operating
    systems on a single server or piece of hardware. It uses software to create a
    virtual abstraction over the hardware resources so that multiple **virtual machines**
    (**VMs**) can run over the physical hardware with their *virtual OS*, **virtual
    CPU** (**vCPU**), virtual storage, and virtual networking. The following diagram
    shows how virtualization works:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟化**抽象化了硬件，并允许您在单个服务器或硬件上运行多个操作系统。它使用软件在硬件资源上创建一个虚拟抽象，这样多个**虚拟机（VM**）就可以在物理硬件上运行，它们拥有自己的*虚拟操作系统（virtual
    OS*）、**虚拟CPU（vCPU**）、虚拟存储和虚拟网络。以下图表显示了虚拟化是如何工作的：'
- en: '![Figure 3.1 – Virtualization  ](img/B17084_03_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 虚拟化](img/B17084_03_001.jpg)'
- en: Figure 3.1 – Virtualization
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 虚拟化
- en: As shown in the preceding diagram, VMs run on a host machine with the help of
    a hypervisor. A hypervisor is a piece of software or firmware that can host a
    VM on physical hardware such as a server or a computer. The physical machine where
    hypervisors create VMs are called host machines and the VMs are called guest machines.
    The operating system in the host machine is called the host OS, while the operating
    system in the VMs is called the guest OS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，虚拟机在宿主机的帮助下运行。虚拟机可以在物理硬件（如服务器或计算机）上运行的软件或固件称为虚拟机管理程序。虚拟机管理程序创建虚拟机的物理机器称为宿主机，而虚拟机称为客户机。宿主机中的操作系统称为宿主操作系统，而虚拟机中的操作系统称为客户操作系统。
- en: Benefits of virtualization
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化的好处
- en: 'The following are the benefits of virtualization:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是虚拟化的好处：
- en: '**Better resource utilization**: As multiple VMs run on the same hardware,
    hardware resources such as storage/memory and network can be more efficiently
    used to serve more applications that might have high loads at different times.
    Since spawning a VM is much quicker than spawning a new server. VMs can be spawned
    during high demand load cycles and switched off when the load on the application
    comes down.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的资源利用率**：由于多个虚拟机在同一硬件上运行，存储/内存和网络等硬件资源可以更有效地用于服务可能在不同时间具有高负载的更多应用程序。由于创建虚拟机比创建新服务器快得多，因此可以在高需求负载周期中创建虚拟机，并在应用程序负载下降时关闭它们。'
- en: '**Less downtime/higher availability**: When physical servers have issues or
    go down, need routine maintenance, or require upgrades, it results in costly downtime.
    With virtual servers, applications can readily move between guest hosts to make
    sure there is minimal downtime in the order of minutes rather than hours or days.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更少的停机时间/更高的可用性**：当物理服务器出现问题时，需要例行维护或需要升级，这会导致昂贵的停机时间。使用虚拟服务器时，应用程序可以轻松地在客户主机之间移动，以确保停机时间最小，仅为几分钟，而不是数小时或数天。'
- en: '**Quicker to market and scalability**: Since provisioning a VM takes minutes
    rather than weeks or months, the overall software delivery cycles have reduced
    substantially. This enables quicker testing since you can mock up production environment
    using VMs.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快上市和可扩展性**：由于配置虚拟机只需几分钟而不是数周或数月，整体软件交付周期大大缩短。这使得测试更快，因为您可以使用虚拟机模拟生产环境。'
- en: '**Faster disaster recovery (DR)**: Unlike physical servers, whose DR takes
    hours or days, VMs can recover within minutes. Hence, VMs enable us to have faster
    DR.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的灾难恢复（DR）**：与需要数小时或数天的物理服务器相比，虚拟机可以在几分钟内恢复。因此，虚拟机使我们能够实现更快的灾难恢复。'
- en: 'The following are a few examples of popular VMs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的虚拟机示例：
- en: Microsoft’s Hyper-V
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软的Hyper-V
- en: VMware’s vSphere
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware的vSphere
- en: Oracle’s VirtualBox
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle的VirtualBox
- en: 'Let’s see how a VM works. We will start this exercise by downloading and installing
    Oracle VirtualBox:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看虚拟机是如何工作的。我们将通过下载和安装Oracle VirtualBox来开始这个练习：
- en: Based on your host operating system, you can download the appropriate installer
    of Oracle VirtualBox from [https://www.virtualbox.org/](https://www.virtualbox.org/).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的宿主操作系统，您可以从[https://www.virtualbox.org/](https://www.virtualbox.org/)下载Oracle
    VirtualBox的相应安装程序。
- en: Then, install VirtualBox using the installation instructions at [https://www.virtualbox.org/manual/ch02.xhtml](https://www.virtualbox.org/manual/ch02.xhtml).
    These instructions are likely to vary by OS.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照[https://www.virtualbox.org/manual/ch02.xhtml](https://www.virtualbox.org/manual/ch02.xhtml)中的安装说明安装VirtualBox。这些说明可能因操作系统而异。
- en: 'Once it has been installed, open Oracle VirtualBox. You will see the **Oracle
    VM VirtualBox Manager** home page, as shown here:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，打开Oracle VirtualBox。您将看到**Oracle VM VirtualBox管理器**主页，如下所示：
- en: '![Figure 3.2 – The Oracle VirtualBox Manager home page ](img/B17084_03_002.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Oracle VirtualBox管理器主页](img/B17084_03_002.jpg)'
- en: Figure 3.2 – The Oracle VirtualBox Manager home page
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Oracle VirtualBox管理器主页
- en: 'Then, click the **New** button to create a new VM on your machine (here, this
    serves as a guest OS). The following screenshot shows the **Create Virtual Machine**
    dialog screen popup (which appears upon clicking the **New** button):'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**新建**按钮在你的机器上创建一个新的虚拟机（在此，这作为客户操作系统）。以下截图显示了**创建虚拟机**对话框弹出窗口（在点击**新建**按钮时出现）：
- en: '![Figure 3.3 – Configuring the guest VM using Oracle VirtualBox  ](img/B17084_03_003.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 使用Oracle VirtualBox配置虚拟机](img/B17084_03_003.jpg)'
- en: Figure 3.3 – Configuring the guest VM using Oracle VirtualBox
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 使用Oracle VirtualBox配置虚拟机
- en: 'In the preceding screenshot, you can see that you need to provide a unique
    name for the VM. You can also select the OS type and its version, as well as configure
    the memory (RAM) size. Finally, you can choose to configure or add a new virtual
    hard disk. If you choose to add a new hard disk, then a popup similar to the following
    will appear:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到你需要为虚拟机提供一个唯一的名称。你还可以选择操作系统类型及其版本，以及配置内存（RAM）大小。最后，你可以选择配置或添加一个新的虚拟硬盘。如果你选择添加一个新的硬盘，那么将出现一个类似于以下弹出的窗口：
- en: '![Figure 3.4 – Creating a virtual hard disk using Oracle VirtualBox ](img/B17084_03_004.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 使用Oracle VirtualBox创建虚拟硬盘](img/B17084_03_004.jpg)'
- en: Figure 3.4 – Creating a virtual hard disk using Oracle VirtualBox
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 使用Oracle VirtualBox创建虚拟硬盘
- en: 'As shown in the preceding screenshot, when configuring a virtual hard disk,
    you can choose from various kinds of available virtual hard disk drives. The major
    popular virtual hard disks are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，在配置虚拟硬盘时，你可以从各种可用的虚拟硬盘驱动器中选择。主要的流行虚拟硬盘如下：
- en: '**VirtualBox Disk Image** (**VDI**)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VirtualBox磁盘镜像**（**VDI**）'
- en: '**Virtual Hard Disk** (**VHD**)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟硬盘**（**VHD**）'
- en: '**Virtual Machine Disk** (**VMDK**)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机磁盘**（**VMDK**）'
- en: Once you have configured your desired virtual hard disk configuration, you can
    create the VM by clicking the **Create** button.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了所需的虚拟硬盘配置，你可以通过点击**创建**按钮来创建虚拟机。
- en: 'Once a VM has been created, it will be listed on the **Oracle VM VirtualBox
    Manager** screen, as shown in the following screenshot. You can start the virtual
    machine by selecting the appropriate VM and clicking the **Start** button:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了一个虚拟机，它将列在**Oracle VM VirtualBox管理器**屏幕上，如下面的截图所示。你可以通过选择适当的虚拟机并点击**启动**按钮来启动虚拟机：
- en: '![Figure 3.5 – Guest VM created and listed in Oracle VirtualBox ](img/B17084_03_005.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 在Oracle VirtualBox中创建并列出的虚拟机](img/B17084_03_005.jpg)'
- en: Figure 3.5 – Guest VM created and listed in Oracle VirtualBox
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 在Oracle VirtualBox中创建并列出的虚拟机
- en: 'Although VMs simplify our delivery and make the platform more available and
    quicker than traditional servers, they have some limitations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管虚拟机简化了我们的交付，使平台比传统服务器更可用且更快，但它们有一些局限性：
- en: '**VMs are heavyweight components**: This means that every time you are doing
    a disaster recovery, you need to acquire all the resources and boot the guest
    operating system so that you can run your application. It takes a few minutes
    to reboot. Also, it is resource-heavy to boot a new guest OS.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机是重量级组件**：这意味着每次进行灾难恢复时，你都需要获取所有资源并启动客户操作系统，以便运行你的应用程序。重启需要几分钟时间。此外，启动一个新的客户操作系统资源密集。'
- en: '**They slow down the performance of the OS**: Since there are only a few resources
    in VMs, and they can only be thick provisioned, this slows down the performance
    of the host OS, which, in turn, affects the performance of the guest OS.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们会降低操作系统的性能**：由于虚拟机中资源有限，并且它们只能进行厚配置，这会降低宿主操作系统的性能，进而影响客户操作系统的性能。'
- en: '**Limited portability**: Since the applications running on the VMs are tightly
    coupled to the guest OS, there will always be a portability issue when moving
    to a different guest OS with a different type or configuration.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的便携性**：由于在虚拟机上运行的应用程序与客户操作系统紧密耦合，当迁移到具有不同类型或配置的不同客户操作系统时，总会存在便携性问题。'
- en: Containerization can help us overcome these shortcomings. We’ll take a look
    at containerization in the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化可以帮助我们克服这些缺点。我们将在下一节中查看容器化。
- en: Containerization
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化
- en: 'Containerization is a technique that abstracts the OS (instead of the hardware)
    and lets applications run on top of it directly. Containerization is more efficient
    than virtualization as applications don’t need a guest OS to run. Applications
    use the same kernel of the host OS to run multiple applications targeted for different
    types of OS. The following diagram shows how containerization works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化是一种技术，它抽象了操作系统（而不是硬件）并允许应用程序直接在其上运行。与虚拟化相比，容器化更高效，因为应用程序不需要客户操作系统来运行。应用程序使用宿主操作系统的相同内核来运行针对不同类型操作系统的多个应用程序。以下图表显示了容器化是如何工作的：
- en: '![Figure 3.6 – Containerization  ](img/B17084_03_006.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 容器化](img/B17084_03_006.jpg)'
- en: Figure 3.6 – Containerization
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 容器化
- en: In containerization, a piece of software called a **container engine** runs
    on the host OS. This allows applications to run on top of the container engine,
    without any need to create a separate guest OS. Each running instance of the application,
    along with its dependencies, is called a container. Here, the application, along
    with its dependencies, can be bundled into a portable package called an image.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化中，一个名为容器引擎的软件在宿主操作系统上运行。这允许应用程序在容器引擎上运行，而无需创建单独的客户操作系统。每个应用程序的运行实例及其依赖项被称为容器。在这里，应用程序及其依赖项可以被打包成一个可移植的包，称为镜像。
- en: Benefits of containerization
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化的好处
- en: 'The following are the advantages of containerization over virtualization:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与虚拟化相比容器化的优势：
- en: '**Lightweight**: Containers use dependencies and binaries to run applications
    directly on a container engine. Containers don’t need to create VMs, so they don’t
    need to initialize a dedicated virtual memory/hard disk to run the application.
    Containers boot significantly faster than VMs. While VMs take minutes to boot,
    containers can boot in seconds.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级**: 容器使用依赖和二进制文件直接在容器引擎上运行应用程序。容器不需要创建虚拟机，因此不需要初始化专用的虚拟内存/硬盘来运行应用程序。容器的启动速度比虚拟机快得多。虽然虚拟机需要几分钟才能启动，但容器可以在几秒钟内启动。'
- en: '**Portable**: Applications, along with their dependencies and base container,
    can be bundled in a package called an image that can easily be ported across any
    container engine run on any kind of host.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携性**: 应用程序及其依赖和基础容器可以打包成一个名为镜像的包，可以轻松地跨任何在任意主机上运行的容器引擎进行移植。'
- en: '**Reduces single points of failure**: Due to the easy portability and lightweight
    nature of containers, testing, deploying, and scaling applications has become
    easier. This has led to the development of microservices, which ensures reduced
    single points of failure.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少单点故障**: 由于容器易于移植和轻量级特性，测试、部署和扩展应用程序变得更加容易。这导致了微服务的开发，从而确保了单点故障的减少。'
- en: '**Increased development velocity**: In containerization, containers can be
    seamlessly migrated from one environment to another, enabling seamless continuous
    deployments. It also enables on-the-fly testing while building and packaging,
    hence improving continuous integration workflows. Application scaling becomes
    super fast if the application is run on containers. These features have made development
    easier and faster, enabling businesses to deliver solutions to the market quickly.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高开发速度**: 在容器化中，容器可以无缝地从一种环境迁移到另一种环境，从而实现无缝的持续部署。它还允许在构建和打包的同时进行即时测试，从而提高持续集成工作流程。如果应用程序在容器上运行，应用程序扩展变得超级快。这些特性使得开发更加容易和快速，使企业能够快速将解决方案推向市场。'
- en: 'Docker is the most popular container engine. Let’s look at some of the most
    important and common terms related to Docker:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是最受欢迎的容器引擎。让我们看看与 Docker 相关的一些最重要和常见的术语：
- en: '**Docker image**: A Docker image is a blueprint or template with instructions
    to create a Docker container. We can create a Docker image by bundling an already
    existing image with an application and its dependencies.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 镜像**: Docker 镜像是一个蓝图或模板，包含创建 Docker 容器的指令。我们可以通过将现有镜像与应用程序及其依赖项打包来创建
    Docker 镜像。'
- en: '**Docker container**: A Docker container is a running instance of a Docker
    image. A Docker container contains a write layer on top of one or more read layers.
    The writable layer allows us to write anything on the container, as well as execute
    commands.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 容器**: Docker 容器是 Docker 镜像的运行实例。Docker 容器包含一个或多个只读层之上的写层。可写层允许我们在容器上写入任何内容，以及执行命令。'
- en: '**Docker registry**: This is a repository that stores Docker images developed
    and uploaded by developers to be leveraged by other developers. Container repositories
    are physical locations where your Docker images are stored. Related images with
    the same name can be also stored, but each image will be uniquely identified by
    a tag. Maven repositories are to Java artifacts what Docker registries are to
    Docker images. Just like a Maven repository supports multiple versions of the
    related JAR files with the same name, a Docker registry supports multiple tags
    for images with the same name. Docker Hub is the official cloud-based public Docker
    registry.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 仓库**：这是一个存储由开发者开发和上传的 Docker 镜像的仓库，以便其他开发者可以利用它们。容器仓库是存储您的 Docker
    镜像的物理位置。具有相同名称的相关镜像也可以存储，但每个镜像都将通过一个标签唯一标识。Maven 仓库对 Java 艺术品的作用类似于 Docker 仓库对
    Docker 镜像的作用。就像 Maven 仓库支持具有相同名称的相关 JAR 文件的多版本一样，Docker 仓库支持具有相同名称的镜像的多标签。Docker
    Hub 是官方基于云的公共 Docker 仓库。'
- en: '**Docker networking**: Docker networking is responsible for communication between
    the Docker host and Docker applications. It is also responsible for basic inter-container
    communication. External applications and developers can access applications running
    in a Docker container on the port exposed to the external world.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 网络**：Docker 网络负责 Docker 主机和 Docker 应用程序之间的通信。它还负责基本的容器间通信。外部应用程序和开发者可以通过暴露给外部世界的端口访问在
    Docker 容器中运行的应用程序。'
- en: '**Docker storage**: Docker has multiple storage drivers that allow you to work
    with the underlying storage devices, such as Device Mapper, AUFS, and Overlay.
    Data volumes can be shared across multiple Docker containers. This enables shared
    resources to be stored in such data volumes. However, there is no way to share
    memory between Docker containers.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 存储**：Docker 有多个存储驱动程序，允许您与底层存储设备（如 Device Mapper、AUFS 和 Overlay）一起工作。数据卷可以在多个
    Docker 容器之间共享。这使得共享资源可以存储在这样的数据卷中。然而，Docker 容器之间无法共享内存。'
- en: 'Now that we have learned about the important terminologies related to Docker,
    let’s learn how to set up Docker in a local machine using Docker Desktop. We will
    also show you how to deploy an image and start a Docker container:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了与 Docker 相关的重要术语，让我们学习如何在本地机器上使用 Docker Desktop 设置 Docker。我们还将向您展示如何部署镜像并启动
    Docker 容器：
- en: 'First, you must install Docker Desktop on our local machine. You can download
    the appropriate Docker Desktop version from the following link based on your OS
    type and version: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop).'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须在本地机器上安装 Docker Desktop。您可以根据操作系统类型和版本，从以下链接下载合适的 Docker Desktop 版本：[https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)。
- en: Based on your operating system, you can follow the installation instructions
    at [https://docs.docker.com/desktop/mac/install/](https://docs.docker.com/desktop/mac/install/)
    (for Mac) or [https://docs.docker.com/desktop/windows/install/](https://docs.docker.com/desktop/windows/install/)
    (for Windows).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，您可以在以下链接中找到安装说明：[https://docs.docker.com/desktop/mac/install/](https://docs.docker.com/desktop/mac/install/)（适用于
    Mac）或 [https://docs.docker.com/desktop/windows/install/](https://docs.docker.com/desktop/windows/install/)（适用于
    Windows）。
- en: If you don’t have Maven installed in your system, please download and install
    it (instruction[s for installing Maven can be found a](https://maven.apache.org/install.xhtml)t
    [https://maven.apache.org/install.xhtml](https://maven.apache.org/install.xhtml)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统中没有安装 Maven，请下载并安装它（安装 Maven 的说明可以在 [https://maven.apache.org/install.xhtml](https://maven.apache.org/install.xhtml)
    找到）。
- en: 'Once you have installed Docker Desktop, open it. You will be asked to accept
    an agreement. Please read and accept it. Once you have done this and the application
    opens, you will see the following home page:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Docker Desktop 后，打开它。您将需要接受一个协议。请阅读并接受它。完成此操作并打开应用程序后，您将看到以下主页：
- en: '![Figure 3.7 – Docker Desktop home page ](img/B17084_03_007.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – Docker Desktop 主页](img/B17084_03_007.jpg)'
- en: Figure 3.7 – Docker Desktop home page
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – Docker Desktop 主页
- en: Next, you must create a Docker Hub personal account to make use of Docker Desktop
    efficiently. Please sign up to create a personal Docker account at [https://hub.docker.com/signup](https://hub.docker.com/signup).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您必须创建一个 Docker Hub 个人账户，以便有效地使用 Docker Desktop。请在 [https://hub.docker.com/signup](https://hub.docker.com/signup)
    上注册以创建个人 Docker 账户。
- en: 'Once you have successfully created your account, click the **Sign In** button
    and enter your Docker ID and password to log in, as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您成功创建了账户，点击**登录**按钮，并输入您的 Docker ID 和密码进行登录，如下所示：
- en: '![Figure 3.8 – Logging into Docker Desktop ](img/B17084_03_008.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 登录 Docker Desktop](img/B17084_03_008.jpg)'
- en: Figure 3.8 – Logging into Docker Desktop
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 登录 Docker Desktop
- en: 'Now, let’s build our own Docker file. To build a Docker file, we need to know
    basic Docker `build` commands. The following table lists a few important Docker
    `build` commands:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建自己的 Dockerfile。要构建 Dockerfile，我们需要了解基本的 Docker `build` 命令。以下表格列出了几个重要的
    Docker `build` 命令：
- en: '![Figure 3.9 – Docker build commands ](img/B17084_03_009.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – Docker 构建命令](img/B17084_03_009.jpg)'
- en: Figure 3.9 – Docker build commands
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – Docker 构建命令
- en: 'To build the Docker file, first, download the code from [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter03/sourcecode/DockerExample](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter03/sourcecode/DockerExample).
    In this project, we will create a simple REST API using Spring Boot and deploy
    and run this application using our Docker environment locally. The artifact that
    will be generated when we build this project is `DockerExample-1.0-SNAPSHOT.jar`.
    The Docker file will look as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 Dockerfile，首先，从 [https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter03/sourcecode/DockerExample](https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter03/sourcecode/DockerExample)
    下载代码。在这个项目中，我们将使用 Spring Boot 创建一个简单的 REST API，并使用我们的本地 Docker 环境部署和运行此应用程序。当我们构建此项目时将生成的工件是
    `DockerExample-1.0-SNAPSHOT.jar`。Dockerfile 将如下所示：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In *step 1* of the Docker file’s source code, we import a base image from Docker
    Hub. In *step 2*, we set the working directory inside the Docker container as
    `/opt/app`. In the next step, we copy our artifact to the working directory on
    Docker. After that, we expose port `8080` from Docker. Finally, we execute the
    Java app using the `java -jar` command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dockerfile 源代码的 *步骤 1* 中，我们从 Docker Hub 导入一个基础镜像。在 *步骤 2* 中，我们将 Docker 容器内的工作目录设置为
    `/opt/app`。在下一步中，我们将我们的工件复制到 Docker 的工作目录。之后，我们从 Docker 暴露端口 `8080`。最后，我们使用 `java
    -jar` 命令执行 Java 应用程序。
- en: 'Next, we will build the JAR file using Maven. First, using the command line
    (Windows) or a Terminal (Mac), go to the root folder of the `DockerExample` project.
    Run the following command to build the JAR file from the root folder of the project:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Maven 构建 JAR 文件。首先，使用命令行（Windows）或终端（Mac），转到 `DockerExample` 项目的根目录。从项目根目录运行以下命令以构建
    JAR 文件：
- en: '[PRE1]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, run the following command to create a customized Docker image named `hello-docker`
    from the Docker file we just created:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行以下命令从我们刚刚创建的 Dockerfile 创建一个名为 `hello-docker` 的自定义 Docker 镜像：
- en: '[PRE2]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you run this command, you will be able to see the Docker image in Docker
    Desktop, in the **Images** tab, as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您运行此命令，您将能够在 Docker Desktop 的**镜像**标签页中看到 Docker 镜像，如下所示：
- en: '![Figure 3.10 – Docker container created successfully and listed ](img/B17084_03_010.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 成功创建 Docker 容器并列入列表](img/B17084_03_010.jpg)'
- en: Figure 3.10 – Docker container created successfully and listed
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 成功创建 Docker 容器并列入列表
- en: 'Now, you can start the container by clicking the **RUN** button, as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过点击**运行**按钮来启动容器，如下所示：
- en: '![Figure 3.11 – Running a Docker container ](img/B17084_03_011.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 运行 Docker 容器](img/B17084_03_011.jpg)'
- en: Figure 3.11 – Running a Docker container
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 运行 Docker 容器
- en: 'Provide a container name and a host port value and click **Run** in the popup
    dialog to start the container, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个容器名称和主机端口值，然后在弹出对话框中点击**运行**以启动容器，如下所示：
- en: '![Figure 3.12 – Setting up Docker Run configurations ](img/B17084_03_012.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 设置 Docker 运行配置](img/B17084_03_012.jpg)'
- en: Figure 3.12 – Setting up Docker Run configurations
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 设置 Docker 运行配置
- en: 'Once you click **Run**, the container will be instantiated and you will be
    able to see the container listed (with its status set to **RUNNING**) in the **Containers
    / Apps** tab of Docker Desktop, as shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击**运行**，容器将被实例化，您将能够在 Docker Desktop 的**容器/应用**标签页中看到容器列表（其状态设置为**运行中**），如下所示：
- en: '![Figure 3.13 – Running instance on Docker Desktop ](img/B17084_03_013.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 在 Docker Desktop 上运行实例](img/B17084_03_013.jpg)'
- en: Figure 3.13 – Running instance on Docker Desktop
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 在 Docker Desktop 上运行实例
- en: 'Now, you can validate the app by testing it in a browser. Please make sure
    you are using the host port (configured during container creation) in the HTTP
    address while validating the application. For our example, you can validate the
    application using port `8887` (which you mapped earlier), as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过在浏览器中测试应用程序来验证应用程序。请确保在验证应用程序时使用主机端口（在容器创建期间配置），在 HTTP 地址中使用。对于我们的示例，您可以使用端口
    `8887`（您之前已映射）来验证应用程序，如下所示：
- en: '![Figure 3.14 – Testing the app deployed on Docker ](img/B17084_03_014.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 测试在 Docker 上部署的应用](img/B17084_03_014.jpg)'
- en: Figure 3.14 – Testing the app deployed on Docker
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 测试在 Docker 上部署的应用
- en: 'You can log into the Docker CLI using the **CLI** button in Docker Desktop,
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Docker Desktop 中的 **CLI** 按钮登录 Docker CLI，如下所示：
- en: '![Figure 3.15 – Opening the Docker CLI from Docker Desktop ](img/B17084_03_015.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 从 Docker Desktop 打开 Docker CLI](img/B17084_03_015.jpg)'
- en: Figure 3.15 – Opening the Docker CLI from Docker Desktop
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 从 Docker Desktop 打开 Docker CLI
- en: 'In this section, we learned about Docker. While Docker makes our lives easy
    and makes development and deployment considerably faster, it comes with the following
    set of challenges:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 Docker。虽然 Docker 让我们的生活变得更简单，并且使开发和部署变得相当快，但它也带来了一系列挑战：
- en: Inter-container communication is usually not possible or very complex to set
    up
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器间通信通常不可能或非常复杂
- en: There is no incoming traffic distribution mechanism, which might cause a skewed
    distribution of incoming traffic to a set of containers
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有入站流量分发机制，这可能会导致入站流量在一系列容器中的分布不均
- en: Container management is overhead to manage the cluster manually
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动管理集群的容器管理是开销
- en: Auto-scaling is not possible
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展不可行
- en: In a production environment, we need to solve these shortcomings if we want
    to run a robust, efficient, scalable, and cost-effective solution. Here, container
    orchestrators come to the rescue. There are many container orchestrators on the
    market. However, Kubernetes, which was developed and open-sourced by Google, is
    one of the most popular and widely used container orchestrators. In the next section,
    we will discuss Kubernetes in more detail.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，如果我们想要运行一个健壮、高效、可扩展且成本效益高的解决方案，我们需要解决这些不足。在这里，容器调度器就派上用场了。市场上有很多容器调度器。然而，由
    Google 开发并开源的 Kubernetes 是最受欢迎和最广泛使用的容器调度器之一。在下一节中，我们将更详细地讨论 Kubernetes。
- en: Kubernetes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes
- en: 'Kubernetes is an open source container orchestrator that effectively manages
    containerized applications and their inter-container communication. It also automates
    how containers are deployed and scaled. Each Kubernetes cluster has multiple components:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个开源容器调度器，它有效地管理容器化应用程序及其容器间通信。它还自动化了容器的部署和扩展。每个 Kubernetes 集群都有多个组件：
- en: Master
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点
- en: Nodes
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点
- en: Kubernetes objects (namespaces, pods, containers, volumes, deployments, and
    services)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 对象（命名空间、pod、容器、卷、部署和服务）
- en: 'The following diagram shows the various components of a Kubernetes cluster:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了 Kubernetes 集群的各个组件：
- en: '![Figure 3.16 – A Kubernetes cluster and its components ](img/B17084_03_016.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – Kubernetes 集群及其组件](img/B17084_03_016.jpg)'
- en: Figure 3.16 – A Kubernetes cluster and its components
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – Kubernetes 集群及其组件
- en: 'Now, let’s briefly describe each of the components shown in the preceding diagram:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要描述一下前面图中显示的每个组件：
- en: '`configMap`. Apart from this, there is a default namespace.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configMap`。除此之外，还有一个默认命名空间。'
- en: '**User namespace**: Users/teams can create a namespace inside the default namespace.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户命名空间**：用户/团队可以在默认命名空间内创建命名空间。'
- en: '**Master nodes**: The master node is the cluster orchestrator. It scales and
    allocates app containers whenever a new request for a deployment comes into the
    Kubernetes cluster.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主节点**：主节点是集群的调度器。每当 Kubernetes 集群收到新的部署请求时，它会扩展和分配应用容器。'
- en: '**Worker nodes**: These are the nodes where the pods are deployed and the applications
    run.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作节点**：这些是部署 pod 和运行应用程序的节点。'
- en: '**Pod**: A pod is an abstraction on top of a container that helps it become
    easily portable between different runtimes, auto-detects the available ports in
    a cluster, and gives it a unique IP address. A pod can consist of multiple containers
    in which multiple helper containers can communicate seamlessly and assist the
    primary application. These multiple containers in a single pod not only share
    volumes but also share memory spaces such as **Portable Operating System Interface**
    (**POSIX**) shared memory.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**：Pod 是在容器之上的一个抽象，它帮助容器在不同运行时之间轻松便携，自动检测集群中可用的端口，并为其分配一个唯一的 IP 地址。Pod
    可以包含多个容器，其中多个辅助容器可以无缝通信并协助主要应用程序。这些单个 Pod 中的多个容器不仅共享卷，还共享内存空间，例如 **可移植操作系统接口**（**POSIX**）共享内存。'
- en: '**Agents**: There are two types of agents, as follows:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：有两种类型的代理，如下所示：'
- en: '**Kubelet agent**: This is a service that runs in each node. It ensures all
    the containers within that node are up and running.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubelet 代理**：这是一个在每个节点上运行的服务。它确保该节点内的所有容器都处于运行状态。'
- en: '**Docker agent**: This is a service that is used to run a container.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 代理**：这是一个用于运行容器的服务。'
- en: 'Now that we have briefly seen the components of Kubernetes and its role in
    containerization, let’s try to deploy the Docker image we created in the previous
    section in a Kubernetes cluster locally. To do that, we must install **minikube**
    (a Kubernetes cluster for running Kubernetes on your local machine):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要地了解了 Kubernetes 的组件及其在容器化中的作用，让我们尝试在本节中创建的 Docker 镜像在本地 Kubernetes 集群中部署。为此，我们必须安装
    **minikube**（一个在本地机器上运行 Kubernetes 的 Kubernetes 集群）：
- en: You can install the appropriate version of `minikube` by following the instructions
    at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过遵循 [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    中的说明来安装合适的 `minikube` 版本。
- en: 'Once `minikube` has been installed, you can start `minikube` using the following
    command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了 `minikube`，您可以使用以下命令启动 `minikube`：
- en: '[PRE3]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A successful `minikube start` looks as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 `minikube start` 看起来如下：
- en: '![Figure 3.17 – Starting minikube ](img/B17084_03_017.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – 启动 minikube](img/B17084_03_017.jpg)'
- en: Figure 3.17 – Starting minikube
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 启动 minikube
- en: 'Now, just like we have to create a Dockerfile to create a Docker image, we
    have to create a `YAML` file to give deployment instructions to the Kubernetes
    cluster. In our project, we will name this `YAML` file `deployment.yaml`. The
    following is the code in the `deployment.yaml` file:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就像我们必须创建 Dockerfile 来创建 Docker 镜像一样，我们必须创建一个 `YAML` 文件来向 Kubernetes 集群提供部署指令。在我们的项目中，我们将此
    `YAML` 文件命名为 `deployment.yaml`。以下是在 `deployment.yaml` 文件中的代码：
- en: '[PRE4]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `deployment.yaml` file contains two types of configuration: one for `Service`
    and one for `Deployment`. Each Kubernetes component configuration consists of
    mainly three parts:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`deployment.yaml` 文件包含两种类型的配置：一种用于 `Service`，另一种用于 `Deployment`。每个 Kubernetes
    组件配置主要由以下三个部分组成：'
- en: '`metadata` consists of the name and any other meta information.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata` 包含名称和任何其他元信息。'
- en: '`spec` contains the specification. This is directly dependent on the kind of
    component that is being configured.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec` 包含规范。这直接取决于正在配置的组件类型。'
- en: '`status` is not something we have to configure. The Kubernetes cluster adds
    that part and keeps updating it after the deployment is done.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status` 不是我们必须配置的内容。Kubernetes 集群会添加这部分并在部署完成后持续更新它。'
- en: 'First, you have to build the `hello-docker-app` image and expose it to the
    `minikube` Docker environment. You can do that by executing the following commands:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须构建 `hello-docker-app` 镜像并将其暴露给 `minikube` Docker 环境。您可以通过执行以下命令来完成此操作：
- en: '[PRE5]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you can deploy this application in a Kubernetes cluster using the following
    command from the project root folder:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令从项目根目录部署此应用程序：
- en: '[PRE6]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After executing this command, you should be able to see that `hello-docker-service`
    and `hello-docker-app` were created successfully, as shown in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，您应该能够看到 `hello-docker-service` 和 `hello-docker-app` 已成功创建，如下面的截图所示：
- en: '![Figure 3.18 – Applications created in Kubernetes cluster  ](img/B17084_03_018.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – 在 Kubernetes 集群中创建的应用程序](img/B17084_03_018.jpg)'
- en: Figure 3.18 – Applications created in Kubernetes cluster
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – Kubernetes 集群中创建的应用程序
- en: 'You can also check the deployments and their status in the minikube dashboard
    by executing the following command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过执行以下命令在 minikube 仪表板中检查部署及其状态：
- en: '[PRE7]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once executed, you should see the dashboard appear in your default browser.
    Here, you will be able to see the status of your deployment, as well as other
    monitoring information:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，您应该在默认浏览器中看到仪表板出现。在这里，您将能够看到您的部署状态以及其他监控信息：
- en: '![Figure 3.19 – The minikube dashboard ](img/B17084_03_019.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19 – minikube仪表板](img/B17084_03_019.jpg)'
- en: Figure 3.19 – The minikube dashboard
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – minikube仪表板
- en: 'Now, you can access the deployed application and start its services using the
    following command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令访问已部署的应用程序并启动其服务：
- en: '[PRE8]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once you have started the service, you can check the base URL that’s been exposed
    by the Docker service linked to your application by executing the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了服务，您可以通过执行以下命令来检查由与您的应用程序关联的Docker服务暴露的基本URL：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command will show an output similar to the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示类似于以下内容的输出：
- en: '![Figure 3.20 – Checking the base URL ](img/B17084_03_020.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20 – 检查基本URL](img/B17084_03_020.jpg)'
- en: Figure 3.20 – Checking the base URL
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – 检查基本URL
- en: 'You can verify the running application from your browser by using the `http://127.0.0.1:63883/hello`
    URL for this example, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过使用此示例的`http://127.0.0.1:63883/hello` URL来通过浏览器验证运行中的应用程序，如下所示：
- en: '![Figure 3.21 – Testing app deployed using Kubernetes ](img/B17084_03_021.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21 – 使用Kubernetes部署的应用程序测试](img/B17084_03_021.jpg)'
- en: Figure 3.21 – Testing app deployed using Kubernetes
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 使用Kubernetes部署的应用程序测试
- en: In this section, we discussed how virtualization and containerization can help
    you manage, deploy, and develop an application in more effective, faster, and
    cost-optimized ways. General web applications, backend applications, and other
    processing applications work extremely well on scalable virtual platforms such
    as containers and VMs. However, big data, which amounts to terabytes and petabytes
    of data, requires a platform with a different kind of architecture to perform
    well. From the next section onwards, we will discuss platforms that are apt for
    big data processing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了虚拟化和容器化如何帮助您以更有效、更快、成本优化的方式管理、部署和开发应用程序。通用Web应用程序、后端应用程序和其他处理应用程序在可扩展的虚拟平台（如容器和虚拟机）上运行得非常好。然而，大数据，其数据量达到千兆或太字节，需要一个具有不同架构的平台才能良好运行。从下一节开始，我们将讨论适合大数据处理的平台。
- en: Hadoop platforms
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hadoop平台
- en: With the advent of search engines, social networks, and online marketplaces,
    data volumes grew exponentially. Searching and processing such data volumes needed
    a different approach to meet the **service-level agreements** (**SLAs**) and customer
    expectations. Both Google and Nutch used a new technology paradigm to solve this
    problem, thus storing and processing data in a distributed way automatically.
    As a result of this approach, Hadoop was born in 2008 and has proved to be a lifesaver
    for storing and processing huge volumes (in the order of terabytes or more) of
    data efficiently and quickly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 随着搜索引擎、社交网络和在线市场的出现，数据量呈指数级增长。搜索和处理如此大的数据量需要不同的方法来满足**服务级别协议**（**SLAs**）和客户期望。谷歌和Nutch都使用了一种新的技术范式来解决这个问题，因此自动以分布式方式存储和处理数据。由于这种方法，Hadoop于2008年出生，并已被证明是存储和处理大量数据（以千兆或更多）的有效和快速的生命线。
- en: Apache Hadoop is an open source framework that enables distributed storage and
    processing of large datasets across a cluster of computers. It is designed to
    scale from a single server to thousands of machines easily. It provides high availability
    by having strong node failover and recovery features, which enables a Hadoop cluster
    to run on cheap commodity hardware.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Hadoop是一个开源框架，它使计算机集群中的大数据集的分布式存储和处理成为可能。它设计得可以从单台服务器轻松扩展到数千台机器。它通过强大的节点故障转移和恢复功能提供高可用性，这使得Hadoop集群能够在廉价的通用硬件上运行。
- en: Hadoop architecture
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hadoop架构
- en: 'In this section, we will discuss the architecture and various components of
    a Hadoop cluster. The following diagram provides a top-level overview of the Hadoop
    ecosystem:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Hadoop集群的架构和各种组件。以下图表提供了Hadoop生态系统的顶层概述：
- en: '![Figure 3.22 – Hadoop ecosystem overview ](img/B17084_03_022.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图3.22 – Hadoop生态系统概述](img/B17084_03_022.jpg)'
- en: Figure 3.22 – Hadoop ecosystem overview
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – Hadoop生态系统概述
- en: 'As shown in the preceding diagram, the Hadoop ecosystem consists of three separate
    layers, as discussed here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Hadoop生态系统由三个独立的层组成，如下所述：
- en: '**Storage layer**: The storage layer in Hadoop is known as **Hadoop Distributed
    File System** (**HDFS**). HDFS supports distributed and replicated storage of
    large datasets, which provides high availability and high-performance access to
    data. The following diagram provides an overview of the HDFS architecture:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储层**：Hadoop中的存储层被称为**Hadoop分布式文件系统**（**HDFS**）。HDFS支持大型数据集的分布式和复制存储，这为数据提供了高可用性和高性能访问。以下图表提供了HDFS架构的概述：'
- en: '![Figure 3.23 – HDFS architecture ](img/B17084_03_023.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23 – HDFS架构](img/B17084_03_023.jpg)'
- en: Figure 3.23 – HDFS architecture
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 – HDFS架构
- en: HDFS has a master-slave architecture where the **NameNode** is the master and
    all **DataNodes** are the slaves. The **NameNode** is responsible for storing
    metadata about all the files and directories in HDFS. It is also responsible for
    storing a mapping of which blocks are stored in which **DataNode**. There is a
    secondary **NameNode** that is responsible for the housekeeping jobs of the **NameNode**
    such as compaction. DataNodes are the real horsepower in an HDFS system. They
    are responsible for storing block-level data and performing all the necessary
    block-level operations on it. The **DataNode** sends periodical signals called
    heartbeats to the **NameNode** to specify that they are up and running. It also
    sends a block report to the **NameNode** every tenth heartbeat.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: HDFS采用主从架构，其中**NameNode**是主节点，所有的**DataNode**都是从节点。**NameNode**负责存储HDFS中所有文件和目录的元数据。它还负责存储哪些块存储在哪个**DataNode**的映射。存在一个二级**NameNode**，负责**NameNode**的维护工作，如压缩等。在HDFS系统中，DataNode是真正的动力所在。它们负责存储块级数据，并对其执行所有必要的块级操作。**DataNode**会定期向**NameNode**发送心跳信号，以表明它们正在运行。它还会在每个第十次心跳时向**NameNode**发送一个块报告。
- en: When the client makes a read request, it gets the metadata information about
    the files and blocks from the **NameNode**. Then, it fetches the required blocks
    from the correct **DataNode**(s) using this metadata. When a client makes a write
    call, the data gets written into distributed blocks across various DataNodes.
    These blocks are then replicated across the nodes (on a different rack) for high
    availability in case there is an outage in the current rack.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发起读取请求时，它会从**NameNode**获取关于文件和块元数据信息。然后，它使用这些元数据从正确的**DataNode**(s)获取所需的块。当客户端发起写入调用时，数据会被写入到分布在不同DataNode上的分布式块中。这些块随后会在不同的节点（位于不同的机架上）进行复制，以确保在当前机架出现故障时仍能保持高可用性。
- en: '**Resource manager layer**: The resource manager is a framework that manages
    cluster resources and is also responsible for scheduling Hadoop jobs. The following
    diagram shows how the resource manager works:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理器层**：资源管理器是一个管理集群资源的框架，同时也负责调度Hadoop作业。以下图表展示了资源管理器的工作方式：'
- en: '![Figure 3.24 – How resource manager works ](img/B17084_03_024.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图3.24 – 资源管理器的工作原理](img/B17084_03_024.jpg)'
- en: Figure 3.24 – How resource manager works
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 – 资源管理器的工作原理
- en: As we can see, each client sends a request to the **Resource Manager** when
    they submit a processing job in Hadoop. The **Resource Manager** consists of a
    **Scheduler** and an **Application Manager**. Here, the **Application Manager**
    is responsible for negotiating with the application’s master container by communicating
    with node managers in different data nodes. Each application master is responsible
    for executing a single application. Then, the **Scheduler** in the **Resource
    Manager** is responsible for negotiating other container resources by interacting
    with the node managers based on the resource requests from the ApplicationMaster.
    Two of the most popular resource managers in Hadoop are **Apache YARN** and **Apache
    Mesos**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当客户端在Hadoop中提交处理作业时，他们会向**资源管理器**发送请求。**资源管理器**由一个**调度器**和一个**应用程序管理器**组成。在这里，**应用程序管理器**通过与应用程序的主容器进行通信，与不同数据节点中的节点管理器协商。每个应用程序主节点负责执行单个应用程序。然后，**资源管理器**中的**调度器**通过根据应用程序主节点的资源请求与节点管理器交互，协商其他容器资源。Hadoop中最受欢迎的两个资源管理器是**Apache
    YARN**和**Apache Mesos**。
- en: '**Processing layer**: The processing layer is responsible for the parallel
    processing of distributed datasets in the Hadoop ecosystem. Two of the most popular
    Hadoop processing engines are **MapReduce** and **Apache Spark**. MapReduce programs
    are tightly coupled to the Hadoop environment. It primarily processes data using
    two mandatory phases – the map phase and the reduce phase – and uses several optional
    data processing phases. It writes intermediate data back to HDFS between these
    phases. On the other hand, Spark reads the distributed data in a logically distributed
    dataset called **Resilient Distributed Dataset** (**RDD**) and creates a **Directed
    Acyclic Graph** (**DAG**) consisting of stages and tasks to process the data.
    Since it doesn’t write the intermediate data to disk (unless shuffling is explicitly
    required), it usually works 10 times faster than MapReduce.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理层**：处理层负责在Hadoop生态系统中并行处理分布式数据集。Hadoop中最受欢迎的两个处理引擎是**MapReduce**和**Apache
    Spark**。MapReduce程序与Hadoop环境紧密耦合。它主要使用两个强制阶段——映射阶段和减少阶段——以及几个可选的数据处理阶段来处理数据。它在这些阶段之间将中间数据写回HDFS。另一方面，Spark读取逻辑上分布的分布式数据集，称为**弹性分布式数据集**（**RDD**），并创建一个由阶段和任务组成的**有向无环图**（**DAG**）来处理数据。由于它通常不需要将中间数据写入磁盘（除非需要显式地进行洗牌），它通常比MapReduce快10倍。'
- en: Although these three layers are interdependent, the design is such that the
    layers are decoupled from each other. This decoupled layer architecture makes
    Hadoop more flexible, powerful, and extendable. This is why Hadoop processing
    has improved and evolved, even though the sizes of datasets have grown at a tremendous
    rate and expected SLAs to process data have reduced over time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三个层次相互依赖，但设计是这样的，即层次之间是解耦的。这种解耦层架构使Hadoop更加灵活、强大和可扩展。这就是为什么尽管数据集的大小以惊人的速度增长，并且处理数据的预期SLA随着时间的推移而降低，Hadoop处理仍然得到了改进和演变。
- en: 'Although Hadoop is an open source framework, all production Hadoop clusters
    run in one of the following distributions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Hadoop是一个开源框架，但所有生产Hadoop集群都运行在以下分发之一中：
- en: '**Hortonworks Data Platform** or **HDP** (discontinued)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hortonworks 数据平台**或**HDP**（已停售）'
- en: '**Cloudera Distribution of Hadoop** or **CDH** (discontinued)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloudera Hadoop 分发**或**CDH**（已停售）'
- en: '**Cloudera Data Platform** (both HDP and CDH can migrate to this platform after
    the Hortonworks and Cloudera merger)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloudera 数据平台**（HDP和CDH在Hortonworks和Cloudera合并后均可迁移到该平台）'
- en: '**MapR Distributions**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MapR 分发**'
- en: 'Apart from these distributions, which are meant for on-premise Hadoop deployments,
    some popular cloud distributions for Hadoop are available:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些针对本地Hadoop部署的分发之外，还有一些流行的Hadoop云分发可供选择：
- en: '**CDP Public cloud** from Cloudera'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloudera的**CDP 公共云**
- en: '**Elastic MapReduce** (**EMR**) from **Amazon Web Services** (**AWS**)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性映射减少**（**EMR**）来自**亚马逊网络服务**（**AWS**）'
- en: '**HDInsight** from Microsoft Azure'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Azure**的**HDInsight**'
- en: '**Cloud Dataproc** from **Google Cloud Platform** (**GCP**)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google Cloud Platform**（**GCP**）的**Cloud Dataproc**'
- en: In this section, we briefly discussed Hadoop distributions and how they work.
    We also covered the various Hadoop distributions that are available from various
    vendors for running Hadoop in a production environment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要讨论了Hadoop分发及其工作方式。我们还介绍了来自不同供应商的各种Hadoop分发，这些分发可以在生产环境中运行Hadoop。
- en: As data keeps growing, there is a need to grow the on-premise infrastructure.
    Such infrastructure capacities need to be planned to support the maximum load.
    This creates either underutilization of resources or overutilization of resources
    if an unexpected load occurs. The answer to this problem is cloud computing. In
    the next section, we will discuss various cloud platforms and the benefit they
    bring to data engineering solutions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据的不断增长，需要扩展本地基础设施。这种基础设施容量需要规划以支持最大负载。如果发生意外负载，这可能会导致资源利用率不足或资源过度利用。解决这个问题的答案是云计算。在下一节中，我们将讨论各种云平台以及它们为数据工程解决方案带来的好处。
- en: Cloud platforms
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云平台
- en: Cloud computing involves delivering computing services such as storage, compute,
    networking, and intelligence over the internet. It offers a pay-as-you-go model,
    which means you only pay for the service you use. This helps cut down on your
    operating costs, as well as **capital expenditure** (**CapEx**) costs. Cloud enables
    optimal resource utilization, instant scalability, agility, and ease of maintenance,
    enabling faster innovation and economies of scale. For example, Canva is a design
    tool that anyone can access via its simple user interface. In 2019, it had 55
    million users. At the time of writing, it has 85 million users worldwide, creating
    100+ designs per second. To accommodate this exponential customer and data volume
    growth seamlessly with similar or better performance, Canva uses the AWS platform.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算涉及通过互联网提供计算服务，如存储、计算、网络和智能。它提供按使用付费的模式，这意味着你只为使用的服务付费。这有助于降低你的运营成本以及**资本支出**（**CapEx**）成本。云使资源利用最优化，实现即时可扩展性、敏捷性和易于维护，从而促进更快的技术创新和规模经济。例如，Canva是一个任何人都可以通过其简单的用户界面访问的设计工具。到2019年，它有5500万用户。在撰写本文时，它在全球有8500万用户，每秒创建100多个设计。为了无缝地适应这种指数级的客户和数据量增长，同时保持相似或更好的性能，Canva使用了AWS平台。
- en: 'The following cloud computing distributions are the market leaders in cloud
    computing and are often referred to as the Big 3 of cloud computing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下云计算分布是云计算市场的领导者，通常被称为云计算的“三大巨头”：
- en: AWS by Amazon
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS，由亚马逊提供
- en: Microsoft Azure by Microsoft
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软Azure，由微软提供
- en: GCP by Google
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP，由谷歌提供
- en: Apart from the Big 3, there are other smaller or lesser-known cloud distributions
    such as Red Hat OpenShift, HPE GreenLake, and IBM Cloud.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“三大巨头”之外，还有其他较小或不太知名的云分布，如Red Hat OpenShift、HPE GreenLake和IBM Cloud。
- en: Benefits of cloud computing
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云计算的好处
- en: 'The following are the benefits of cloud computing:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的是云计算的好处：
- en: '**Cost-effective**: Cloud computing reduces the CapEx cost by eliminating the
    huge costs involved in the infrastructure setup. It also reduces cost by applying
    a pay-as-you-go model.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经济高效**: 云计算通过消除基础设施设置中的巨大成本来降低资本支出（CapEx）成本。它还通过应用按使用付费的模式来降低成本。'
- en: '**Scalable**: Since cloud services are all virtualized, they can be spun up
    within minutes or seconds, enabling extremely fast scalability.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**: 由于云服务都是虚拟化的，它们可以在几分钟或几秒钟内启动，从而实现极快的可扩展性。'
- en: '**Elastic**: Cloud services can be easily scaled up or down based on the resource
    and compute demand.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**: 云服务可以根据资源和计算需求轻松地进行扩展或缩减。'
- en: '**Reliable**: Since each service is replicated across availability zones as
    well as regions, the services are highly reliable and guarantee minimum downtime.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠**: 由于每个服务都在可用区域以及地区内进行了复制，因此服务非常可靠，并保证最小化停机时间。'
- en: '**Global**: Since the cloud service is on the internet, the computation power
    can be delivered across the globe, from the right geographic location.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全球性**: 由于云服务在互联网上，计算能力可以从全球的任何地理位置提供。'
- en: '**Increased productivity**: Since provisioning, managing, and deploying resources
    and services are no longer headaches for developers, they can focus on business
    functionality and deliver solutions much faster and effectively.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高生产力**: 由于资源和服务配置、管理和部署不再是开发者的头疼问题，他们可以专注于业务功能，并更快、更有效地交付解决方案。'
- en: '**Secure**: Along with the other benefits, the cloud has a lot of security
    layers and services, making the cloud a secure infrastructure.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**: 除了其他好处之外，云拥有许多安全层和服务，使云成为一个安全的基础设施。'
- en: 'There are three types of cloud computing, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算有三种类型，如下所示：
- en: '**Public cloud**: Public clouds are owned and operated by third-party vendors
    who deliver computing resources and services over the internet. Here, as a user
    of the public cloud, you must pay for what you use.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公有云**: 公有云由第三方供应商拥有和运营，通过互联网提供计算资源和服务。在这里，作为公有云的用户，你必须为所使用的服务付费。'
- en: '**Private cloud**: A private cloud is a form of cloud computing where the computing
    resources are owned by the customer, usually in a private on-premise data center.
    The cloud provider only provides the cloud software and its support. Usually,
    this is used by big enterprises where security and compliance are constraints
    for moving toward the public cloud. Here, the customers are responsible for managing
    and monitoring cloud resources.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有云**：私有云是一种云计算形式，其中计算资源由客户拥有，通常是在私有本地数据中心。云服务提供商仅提供云软件及其支持。通常，这种云被大型企业使用，因为安全和合规性是向公共云迁移的约束。在这里，客户负责管理和监控云资源。'
- en: '**Hybrid cloud**: Hybrid clouds combine both public and private clouds, bound
    together by technology through which data and applications can communicate and
    move seamlessly between private and public clouds. This provides higher flexibility
    when it comes to security, compliance, and agility.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合云**：混合云结合了公共云和私有云，通过技术将数据和应用连接在一起，可以在私有云和公共云之间无缝通信和迁移。这为安全、合规性和敏捷性提供了更高的灵活性。'
- en: 'Now that we have discussed the different types of cloud computing, let’s try
    to understand the various types of cloud services available in a public cloud
    distribution. The various types of cloud services are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了不同类型的云计算，让我们尝试了解在公共云分布中可用的各种云服务类型。以下是一些云服务的类型：
- en: '**Infrastructure as a Service** (**IaaS**)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施即服务**（**IaaS**）'
- en: '**Platform as a Service** (**PaaS**)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台即服务**（**PaaS**）'
- en: '**Software as a Service** (**SaaS**)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件即服务**（**SaaS**）'
- en: 'In the cloud, the responsibility of owning various stacks in application development
    is shared between cloud vendors and the customers. The following diagram shows
    the shared responsibility model for these kinds of cloud computing services:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中，应用开发中拥有各种堆栈的责任在云服务提供商和客户之间共享。以下图表显示了这类云计算服务的共享责任模型：
- en: '![Figure 3.25 – Shared responsibility model ](img/B17084_03_025.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图3.25 – 共享责任模型](img/B17084_03_025.jpg)'
- en: Figure 3.25 – Shared responsibility model
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 – 共享责任模型
- en: As we can see, if the customer is running a private cloud, all the resources,
    services, applications, and data are the customer’s responsibility. However, if
    you opt for a public cloud, then you can choose between IaaS, PaaS, and SaaS.
    Cloud vendors promise to manage and own infrastructure services such as compute,
    storage, and networking in an IaaS model. If you go for a PaaS model, apart from
    what you get in IaaS, cloud providers also manage the OS, VMs, and runtime so
    that you can own, develop, and manage your applications, data, and access. In
    SaaS, everything except data and access is managed by your cloud vendor. Even
    the application or software is managed by the cloud provider. Although this might
    be costlier if you take a single unit compared to the other two models, based
    on your business, it might be cheaper and more hassle-free.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，如果客户正在运行私有云，所有资源、服务、应用和数据都是客户的责任。然而，如果您选择公共云，则可以选择IaaS、PaaS和SaaS。云服务提供商承诺在IaaS模型中管理和拥有计算、存储和网络等基础设施服务。如果您选择PaaS模型，除了IaaS中提供的内容外，云提供商还会管理操作系统、虚拟机和运行时，以便您可以拥有、开发和管理工作负载、数据和访问。在SaaS中，除了数据和访问之外的所有内容都由您的云服务提供商管理。即使与另外两种模型相比，单个单元的成本可能更高，但根据您的业务，它可能更便宜且更省事。
- en: With that, we have discussed the various platforms where data engineering applications
    may be deployed. Now, let’s discuss the various design choices that an architect
    needs to know to choose the correct platform for them.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过讨论，我们已经讨论了数据工程应用可能部署的各种平台。现在，让我们讨论架构师需要了解的各种设计选择，以便为他们选择正确的平台。
- en: Choosing the correct platform
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的平台
- en: In this section, we will look at one of the most important decisions architects
    have to make – *how to choose the most suitable platform for a use case*. Here,
    we will understand when to choose between virtualization versus containerization
    and on-premise versus the cloud when considering various cloud data platforms.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨架构师必须做出的最重要的决策之一——*如何选择最适合用例的平台*。在这里，我们将了解在考虑各种云数据平台时，何时选择虚拟化与容器化，以及本地与云之间的选择。
- en: When to choose virtualization versus containerization
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时选择虚拟化与容器化
- en: Although both these technologies ensure that we can use resources to the best
    of our ability by provisioning virtual resources, each has its advantages based
    on the type of application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种技术都确保我们可以通过配置虚拟资源来最大限度地利用资源，但每种技术基于应用程序的类型都有其优势。
- en: Microservices is a variant of the service-oriented architecture where an application
    is perceived as a collection of loosely coupled services. Each service is fine-grained
    and lightweight. Microservices are best suited for container-based platforms.
    For example, a REST service can be easily deployed using containers. Since microservices
    consist of loosely coupled services, they should be easily deployable and scalable.
    Since each service can be independently consumed and reused by other services
    and stacks, they need to be portable so that they can quickly migrate to any containerized
    platform.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是面向服务架构的一种变体，其中应用程序被视为松散耦合的服务集合。每个服务都是细粒度和轻量级的。微服务最适合基于容器的平台。例如，可以使用容器轻松部署REST服务。由于微服务由松散耦合的服务组成，它们应该易于部署和扩展。由于每个服务都可以由其他服务和堆栈独立消费和重用，因此它们需要是可移植的，以便可以快速迁移到任何容器化平台。
- en: On the other hand, monolithic applications are designed to perform multiple
    related tasks, but it is built as a tightly coupled single application. Such applications
    are more suited for small teams or **Proof of Concept** (**POC**) purposes. Another
    use case where such monolithic architectures are used is in legacy applications.
    Such monolithic applications are best suited for virtualization. Another use case
    where virtualized platforms are preferred over containerization is in any application
    that is dependent on an OS or talks directly to a specific OS.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，单体应用程序旨在执行多个相关任务，但它被构建为一个紧密耦合的单个应用程序。这类应用程序更适合小型团队或**概念验证**（**POC**）目的。这种单体架构被用于遗留应用程序的另一个用例。这类单体应用程序最适合虚拟化。在依赖操作系统或直接与特定操作系统通信的应用程序中，虚拟化平台比容器化更受欢迎。
- en: However, in the cloud, all the servers that are provisioned are VMs. Containerized
    platforms such as Amazon **Elastic Container Service** (**ECS**) and Amazon **Elastic
    Kubernetes Service** (**EKS**) run on top of virtual servers such as Amazon **Elastic
    Compute Cloud** (**EC2**). So, in modern architectures, especially in the cloud,
    the question is not choosing between containerization and virtualization – it
    is choosing between containerization along with virtualization versus virtualization.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在云中，所有配置的服务器都是虚拟机。例如，亚马逊**弹性容器服务**（**ECS**）和亚马逊**弹性Kubernetes服务**（**EKS**）都是在虚拟服务器，如亚马逊**弹性计算云**（**EC2**）之上运行的。因此，在现代架构中，特别是在云中，问题不是在容器化和虚拟化之间选择——而是在容器化加虚拟化与虚拟化之间选择。
- en: When to use big data
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用大数据
- en: If we are handling data that is terabytes or petabytes in size, big data is
    a good choice. As **artificial intelligence** (**AI**) and **machine learning**
    (**ML**) applications are growing in popularity, we need to deal with huge volumes
    of data – the larger the data, more accurate will be the AI models. These volumes
    of data run into the terabytes. Processing such data in a scalable fashion can
    be done by big data applications. There are use cases where, due to processing
    complexity, processing hundreds of gigabytes of data takes an unnecessarily long
    time. In such scenarios, big data may be a good solution. Most big data use cases
    are for analytics, **Online Analytical Processing** (**OLAP**), AI, and ML.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的数据大小为太字节或拍字节，大数据是一个不错的选择。随着**人工智能**（**AI**）和**机器学习**（**ML**）应用的日益流行，我们需要处理大量数据——数据量越大，AI模型越准确。这些数据量达到太字节级别。通过大数据应用以可扩展的方式处理这些数据是可行的。在某些情况下，由于处理复杂性，处理数百吉字节的数据需要不必要的时间。在这种情况下，大数据可能是一个好的解决方案。大多数大数据用例是用于分析、**在线分析处理**（**OLAP**）、AI和ML。
- en: Choosing between on-premise versus cloud-based solutions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地部署与基于云的解决方案之间选择
- en: 'This is an obvious question that architects face today. In this section, we
    will try to see what factors affect this decision, as well as recommend a few
    general criteria to help you decide on one over the other. The factors that will
    help you decide between on-premise versus cloud solutions are as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是架构师今天面临的一个明显问题。在本节中，我们将尝试了解影响这一决策的因素，并推荐一些一般标准以帮助您决定选择哪一个。以下因素将帮助您决定本地部署与云解决方案：
- en: '**Cost**: Enterprises are responsible for all infrastructure and maintenance
    costs, including human resources for on-premise environments. Costs also include
    migration costs from on-premise to the cloud. Another important cost metric is
    about CapEx versus **operating expenses** (**OpEx**) and how cost-efficient OpEx
    will be versus CapEx for the enterprise. All these factors determine the total
    cost of ownership, which ultimately determines what is best for your business.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：企业负责所有基础设施和维护成本，包括本地环境的人力资源。成本还包括从本地到云的迁移成本。另一个重要的成本指标是关于资本支出（CapEx）与**运营支出**（OpEx）的比较，以及OpEx相对于CapEx对企业的成本效益。所有这些因素决定了总拥有成本，这最终决定了什么最适合您的业务。'
- en: '**Control**: Enterprises are completely in control of the data, its storage,
    and all hardware related to the on-premise infrastructure. However, although enterprises
    own the data, the storage and its hardware are managed by the cloud provider.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**：企业完全控制数据、其存储以及所有与本地基础设施相关的硬件。然而，尽管企业拥有数据，但存储及其硬件由云服务提供商管理。'
- en: '**Resource demand pattern**: If the demand for resources is elastic and infrastructure
    demand is seasonal, then the cloud may be the correct choice. On the other hand,
    if resource demand is static, then opting for on-premise may be the correct option.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源需求模式**：如果资源需求是弹性的，基础设施需求是季节性的，那么云可能是正确的选择。另一方面，如果资源需求是静态的，那么选择本地化可能是正确的选项。'
- en: '**Agility and scalability**: If your company is a start-up and growing exponentially,
    which means your demand scales up and down based on the feedback you receive and
    your volatile customer base, then the cloud will be a better choice for you.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏捷性和可扩展性**：如果您的公司是一家初创公司且呈指数级增长，这意味着您的需求根据您收到的反馈和波动性客户群上下波动，那么云服务将是您的更好选择。'
- en: '**Security**: Security is a big concern for a few industries, such as finance
    and healthcare. Although there have been many advances in cloud security and they
    have a strong robust security model, since the data is stored in hardware managed
    by a public cloud provider, many such businesses with very sensitive data choose
    on-premise over the cloud for security reasons.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：对于一些行业，如金融和医疗保健，安全性是一个大问题。尽管云计算的安全性已经取得了许多进步，并且它们有一个强大的稳健安全模型，但由于数据存储在由公共云服务提供商管理的硬件中，许多拥有非常敏感数据的此类企业出于安全原因选择本地化而非云服务。'
- en: '**Compliance**: Several industries have very strict regulatory controls and
    policies, such as federal agencies and healthcare. In such businesses, having
    complete control over the data and its storage makes more sense. Hence, on-premise
    options are more suitable.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性**：一些行业有非常严格的监管控制和政策，如联邦机构和医疗保健。在这些企业中，对数据和其存储的完全控制更有意义。因此，本地化选项更为合适。'
- en: Based on these factors, here are some broad guidelines that you can use to make
    this decision. However, note that these are only recommendations – the actual
    choice will depend on your specific business needs and context.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些因素，以下是一些广泛指南，您可以使用这些指南来做出这个决定。然而，请注意，这些只是建议——实际的选择将取决于您的具体业务需求和背景。
- en: 'You should choose on-premise architectures in the following circumstances:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，您应该选择本地化架构：
- en: Security is a major concern and you don’t want to take the chance of any data
    risks occurring
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性是一个主要关注点，您不希望冒任何数据风险发生的风险
- en: Regulatory policies and controls are stringent, stipulating that control of
    data and its storage should remain within the organization
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监管政策和控制非常严格，规定数据及其存储的控制应保持在组织内部
- en: Legacy systems can’t easily be moved or replicated
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧系统难以移动或复制
- en: The time, effort, and cost involved are not justifiable to migrate data and
    processing from on-premise to the cloud
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移数据和处理从本地到云所需的时间、努力和成本是不合理的
- en: 'You should choose cloud architectures in the following circumstances:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，您应该选择云架构：
- en: Flexibility and agility to scale and grow are needed
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要灵活性和敏捷性以进行扩展和增长
- en: You are a start-up and you have a limited client base and limited CapEx, but
    you have high growth potential
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是一家初创公司，您有有限的客户群和有限的资本支出，但您有很高的增长潜力
- en: You want dynamic configurations of the environment that can easily be modified
    on demand
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望环境具有动态配置，可以轻松按需修改
- en: You do not want to do a CapEx investment on infrastructure and prefer a pay-as-you-go
    model
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不希望对基础设施进行资本支出投资，而更倾向于按需付费模式
- en: You are uncertain about the business demand, and you need to scale your resources
    up and down frequently
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对业务需求不确定，需要频繁地调整资源的大小
- en: You do not want to expend resources and time to maintain your infrastructure
    and the cost associated with it
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不希望花费资源和时间来维护你的基础设施及其相关成本
- en: You want an agile setup, quicker deliveries, and a faster turnaround time for
    operations
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个敏捷的设置，更快的交付，以及更快的运营周转时间
- en: Finally, let’s compare the Big 3 cloud vendors to decide which provider is a
    best fit for your business.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们比较大三大云供应商，以决定哪个供应商最适合你的业务。
- en: Choosing between various cloud vendors
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在各种云供应商之间进行选择
- en: 'In this section, we will compare the Big 3 public cloud vendors and how they
    perform in various categories, even though there is no clear answer to the question,
    *Which cloud vendor is best for my business?* The following table provides a comparison
    between the Big 3 cloud providers and throws light on their strengths and weaknesses:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较大三大公有云供应商，并探讨它们在各个类别中的表现，尽管对于“哪个云供应商最适合我的业务？”这个问题没有明确的答案。以下表格提供了大三大云供应商的比较，并揭示了它们的优点和缺点：
- en: '|  | **AWS** | **Azure** | **GCP** |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|  | **AWS** | **Azure** | **GCP** |'
- en: '| Services | Huge range of services | Good range of services available. Exceptional
    services in AI/ML. | Limited services are available. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | 服务种类繁多 | 可用的服务范围良好。在AI/ML方面有卓越的服务。 | 可用的服务有限。 |'
- en: '| Maturity | Most mature | Catching up with AWS. | Still relatively less mature
    than the other two. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 成熟度 | 最成熟 | 追赶AWS。 | 相对来说不如其他两个成熟。 |'
- en: '| Marketplace | All vendors make their products available | Good vendor support
    but less than AWS. |  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 市场place | 所有供应商都提供他们的产品 | 良好的供应商支持，但不如AWS。 |  |'
- en: '| Reliability | Excellent | Excellent. | Excellent. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 可靠性 | 极佳 | 极佳。 | 极佳。 |'
- en: '| Security | Excellent | Excellent. | Fewer notches than AWS and Azure. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 极佳 | 极佳。 | 比AWS和Azure少一些等级。 |'
- en: '| Cost | Varies | Most cost-efficient. | Varies. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 成本 | 各不相同 | 最具成本效益。 | 各不相同。 |'
- en: '|  | **AWS** | **Azure** | **GCP** |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  | **AWS** | **Azure** | **GCP** |'
- en: '| Support | Paid dev/enterprise support | Paid dev/enterprise support. More
    support options than AWS. | Paid dev/premium support. Costlier support than the
    other two. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 支持 | 支付开发者/企业支持 | 支付开发者/企业支持。比AWS有更多支持选项。 | 支付开发者/高级支持。比其他两个更昂贵。 |'
- en: '| Hybrid Cloud Support | Limited | Excellent. | Good. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 混合云支持 | 有限 | 极佳。 | 良好。 |'
- en: '| Special Notes | More compute capacity versus Azure and GCP | Easy integration
    and migrations for existing Microsoft services. | Excellent support for containerized
    workloads.Global fiber network. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 特别说明 | 与Azure和GCP相比，计算能力更强 | 现有Microsoft服务的集成和迁移简单。 | 对容器化工作负载有出色的支持。全球光纤网络。
    |'
- en: Figure 3.26 – Comparison of the Big 3 cloud vendors
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26 – 大三大云供应商的比较
- en: In short, AWS is the market leader but both Azure and GCP are catching up. If
    you are looking for the maximum number of services available across the globe,
    AWS will be your obvious choice, but it comes with a higher learning curve.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，AWS是市场领导者，但Azure和GCP都在迎头赶上。如果你在寻找全球可用的服务数量最多，AWS将是你的明显选择，但它有一个更高的学习曲线。
- en: If your use case revolves only around AI/ML and you have a Microsoft on-premise
    infrastructure, Azure may be the correct choice. They have excellent enterprise
    support and hybrid cloud support. If you need a robust hybrid cloud infrastructure,
    Microsoft Azure is your go-to option.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的用例仅围绕AI/ML，并且你有Microsoft本地基础设施，Azure可能是正确的选择。他们有出色的企业支持和混合云支持。如果你需要一个强大的混合云基础设施，Microsoft
    Azure是你的首选选项。
- en: GCP entered the race late, but they have excellent integration and support for
    open source and third-party services.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: GCP进入比赛较晚，但他们有出色的开源和第三方服务的集成和支持。
- en: But in the end, it boils down to your specific use case. As the market is growing,
    most enterprises are looking for multi-cloud strategies to leverage the best of
    each vendor.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但最终，这取决于你的具体用例。随着市场的增长，大多数企业都在寻找多云策略，以利用每个供应商的最佳功能。
- en: Now, let’s summarize this chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结本章内容。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed various virtualization platforms. First, we briefly
    covered the architectures of the virtualization, containerization, and container
    orchestration frameworks. Then, we deployed VMs, Docker containers, and Kubernetes
    containers and ran an application on top of them. In doing so, we learned how
    to configure Dockerfiles and Kubernetes deployment scripts. After that, we discussed
    the Hadoop architecture and the various Hadoop distributions that are available
    on the market. Then, we briefly discussed cloud computing and its basic concepts.
    Finally, we covered the decisions that every data architect has to make: *containers
    or VMs?* *Do I need big data processing?* *Cloud or on-premise?* *If the cloud,
    which cloud?*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了各种虚拟化平台。首先，我们简要介绍了虚拟化、容器化和容器编排框架的架构。然后，我们部署了虚拟机（VMs）、Docker容器和Kubernetes容器，并在其上运行应用程序。在这个过程中，我们学习了如何配置Dockerfile和Kubernetes部署脚本。之后，我们讨论了Hadoop架构和市场上可用的各种Hadoop发行版。接着，我们简要介绍了云计算及其基本概念。最后，我们讨论了每位数据架构师必须做出的决策：*容器还是虚拟机？*
    *我需要大数据处理吗？* *云还是本地？* *如果是云，哪个云？*
- en: With that, we have a good understanding of some of the basic concepts and nuances
    of data architecting, including the basic concepts, databases, data storage, and
    the various platforms these solutions run on in production. In the next chapter,
    we will dive deeper into how to architect various data processing and data ingestion
    pipelines.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对数据架构的一些基本概念和细微差别有了良好的理解，包括基本概念、数据库、数据存储以及这些解决方案在生产环境中运行的各种平台。在下一章中，我们将更深入地探讨如何架构各种数据处理和数据摄取管道。
- en: Section 2 – Building Data Processing Pipelines
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2节 – 构建数据处理管道
- en: This section focuses on guiding you to learn how to architect and develop batch
    processing and stream processing solutions using various technologies in the Java
    stack. Finally, it will also help you to understand and apply data governance
    and security to a solution practically.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点指导您学习如何使用Java堆栈中的各种技术来架构和开发批处理和流处理解决方案。最后，它还将帮助您实际理解和应用数据治理和安全。
- en: 'This section comprises the following chapters:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 4*](B17084_04.xhtml#_idTextAnchor062)*, ETL Data Load – A Batch-Based
    Solution to Ingest Data in a Data Warehouse*'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B17084_04.xhtml#_idTextAnchor062)*，ETL数据加载 – 数据仓库中数据摄取的基于批处理解决方案*'
- en: '[*Chapter 5*](B17084_05.xhtml#_idTextAnchor074)*, Architecting a Batch Processing
    Pipeline*'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B17084_05.xhtml#_idTextAnchor074)*，架构批处理管道*'
- en: '[*Chapter 6*](B17084_06.xhtml#_idTextAnchor092)*, Architecting a Real-Time
    Processing Pipeline*'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B17084_06.xhtml#_idTextAnchor092)*，架构实时处理管道*'
- en: '[*Chapter 7*](B17084_07.xhtml#_idTextAnchor110)*, Core Architectural Design
    Patterns*'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B17084_07.xhtml#_idTextAnchor110)*，核心架构设计模式*'
- en: '[*Chapter 8*](B17084_08.xhtml#_idTextAnchor130)*, Enabling Data security and
    Governance*'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B17084_08.xhtml#_idTextAnchor130)*，启用数据安全和治理*'
