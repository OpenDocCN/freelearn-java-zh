- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays, Collections, Generics, Functions, and Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have used variables to represent a single instance of a primitive
    data type and a reference data type. More frequently encountered in the real world,
    though, is the need to work with and process multiple data elements. In this chapter,
    we will look at the various options available for managing multiple elements.
    In examining the options in Java for this purpose, we will see how we can enhance
    type safety.
  prefs: []
  type: TYPE_NORMAL
- en: To process multiple elements more efficiently, we will examine streams—a replacement
    for traditional loops when coupled with functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the array data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Collections Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sequential implementations and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Generics in the Collections Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sequential implementations and interfaces with Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Collections Framework map structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding functions in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using streams in collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon completion of this chapter, you will be able to work with multiple instances
    of data as an array or collection and apply algorithms available in the `Stream`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter08](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the array data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most languages, Java has a built-in array data structure and does not
    require any imports or external libraries. As such, the array behaves as most
    arrays in other languages. The only difference is that to instantiate an array,
    you need the `new` keyword. Here are the two ways to declare an array of 10 elements
    of type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The difference is where the empty square brackets are placed on the left-hand
    side. Placing them after the type is considered the Java way. Placing it after
    the identifier is thought of as the C-language way. Either syntax is fine.
  prefs: []
  type: TYPE_NORMAL
- en: In most programming languages, numbers can be either ordinal or cardinal. The
    length of the array as declared when we instantiate it is a cardinal—or count—number.
    In the examples so far, the length has been 10\. An ordinal number represents
    the position in a structure such as in an array. Ordinals begin with zero in most
    programming languages. When we declare an array of cardinal length 10, the ordinal
    positions range from 0 to 9 and not 1 to 10.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are of a fixed length; they cannot be expanded or contracted. Each position
    in an array is ready for use. You can assign a value to the last position before
    assigning one to the first position.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can defer instantiating an array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Arrays store the values of an array in a contiguous block of memory. This tells
    us that the array will be 10 elements times 4 bytes per `int` to consume 40 bytes
    plus the necessary overhead for an object in Java. The length of the array is
    part of this overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'An array of objects consists of an array of references. For example, you could
    create an array of four strings, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the array will consume 4 bytes for the reference to each `String`
    object as well as the usual array object overhead. The strings themselves are
    stored in memory as the `null` until you assign a valid reference to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When using references in arrays, what we are storing in the data structure is
    the reference and not the object. Only primitives can be stored directly in an
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we read and write to the array using the subscript. To get the length
    of the array, we use the final constant variable, `length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To visit every element in an array with a `for` loop, you would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Java also has an enhanced `for` loop for visiting every element in an array.
    The subscript value is no longer available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One last thing to point out: Java has a library for performing a range of operations
    on an array, called the `Arrays` library. This class contains static methods for
    sorting and searching as well as creating a list, one of the collections, from
    an array. We will see an example of turning an array into a list in the later
    section, *Using streams* *in collections*.'
  prefs: []
  type: TYPE_NORMAL
- en: You should already be comfortable with working with an array. You can read and
    write to any valid subscripted element. If you use an invalid subscript that is
    out of range, Java will throw an `ArrayIndexOutOfBoundsException`. Now, let’s
    look at the Collections Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Collections Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once an array is instantiated, it cannot have its length increased or decreased.
    This means that you must know the exact number of elements you will need before
    you instantiate the array. You can use a variable to declare the array but once
    created it cannot be resized. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is where collections come in. These are dynamic data structures that can
    increase in size as elements are added. You can also remove elements, although
    reducing the size is not always available, and if it can be reduced, then you
    must call an appropriate method.
  prefs: []
  type: TYPE_NORMAL
- en: The Collections Framework is divided into implementations and interfaces. An
    implementation may support more than one interface. While an implementation can
    have a large selection of methods, the use of an interface allows you to restrict
    what you can do with a collection.
  prefs: []
  type: TYPE_NORMAL
- en: The Collections Framework classes fall into two categories. There are sequential
    collections that preserve the order in which elements are added. Then, there are
    map collections where elements are stored in pairs of data. The first is typically
    a field of an object called the key, while the second is a reference to the object
    itself called the value. These collections organize themselves based on the key.
  prefs: []
  type: TYPE_NORMAL
- en: The default data type that all members of these classes manage is `Object`.
    This means that you can store any object in a collection as all classes extend
    `Object`, and polymorphism allows you to use a subclass wherever a superclass
    is called for. The problem with this approach is that you can conceivably have
    a collection of apples and oranges. Until the introduction of Generics to the
    language, it was the responsibility of the developer to avoid mixing types.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look more closely at sequential structures.
  prefs: []
  type: TYPE_NORMAL
- en: Using sequential implementations and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s begin with the implementation. These are classes that manage the data
    in many ways. They are `ArrayList`, `LinkedList`, and `ArrayDeque`.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a dynamic array-like structure. As a class, you must use methods rather
    than subscripts to access specific elements. You add elements at the end of the
    list. Once you add an element, you can read from it, write to it, search for a
    specific value, and remove elements from a specific position or that match a specific
    value.
  prefs: []
  type: TYPE_NORMAL
- en: You can instantiate an `ArrayList` class with or without an initial capacity.
    If you do not specify a capacity, then it will default to a capacity of 10\. If
    you know in advance how many elements you will need, then include that value when
    you instantiate the `ArrayList` class. The auto-resizing of an `ArrayList` class
    entails overhead that you can avoid if you know the precise size. In either case,
    you cannot access elements until you first add an element. As you add elements,
    the size increases. You can access any element that you add but you cannot access
    any positions between the last element added and the unused capacity that follows
    it.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This structure stores data in node objects, with each node knowing what comes
    before and after it. On the surface, it would seem to be quite efficient as you
    create nodes as needed. The major drawback to a linked list is that it does not
    support random access. In `ArrayList`, you can access any element such as an array
    by using the integer that represents its position using a method rather than square
    brackets. This access is direct. In a `LinkedList` class, the only elements you
    can access directly are the first and last elements. To access any other element,
    you must start at the beginning or end and then follow the forward or backward
    references to the subsequent nodes. This makes access to elements far slower than
    in `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I instruct students about linked lists because they make for nice blackboard
    diagrams. The `Map` structures that we will look at shortly are based on variants
    of the linked list. Let me end with a tweet from Joshua Bloch concerning the Java
    `LinkedList` class he wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Famous LinkedList tweet](img/B19088_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Famous LinkedList tweet
  prefs: []
  type: TYPE_NORMAL
- en: ArrayDeque
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ArrayDeque` class is like `ArrayList` in that it is a dynamic structure
    that stores elements in an array-like structure. Unlike `ArrayList`, it does not
    support direct access. Instead, it is optimized for inserting or removing elements
    at the beginning (`Deque`, `Queue`, and `Stack` interfaces. Prior to the introduction
    of the `ArrayDeque` class in Java 1.6, you used a `LinkedList` class as the implementation
    for these interfaces. The `ArrayDeque` class outperforms the `LinkedList` class.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a complete list. For example, there is a `Stack` class, but using
    the `ArrayDeque` class with a `Deque` interface will outperform the `Stack` class.
    A second issue relates to thread safety. These three implementations are not thread-safe.
    There are specialized versions of the implementations in the framework, specifically
    for when threads must share access to a data structure.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement any of these classes, but it is considered a poor choice.
    Each of these implementations has numerous methods to support the use of the structure
    in numerous ways. When you use a Java collections class, you want to use the smallest
    interface for what you are trying to accomplish rather than allowing access to
    every method in the implementation. Let’s look at these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The Collection interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a diagram of the most common interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The Collection interfaces](img/B19088_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The Collection interfaces
  prefs: []
  type: TYPE_NORMAL
- en: Each of the boxes represents an interface that a collection implementation may
    or may not support. `Collection` is the super interface. Any class that implements
    the interfaces below it must also implement `Collection`.
  prefs: []
  type: TYPE_NORMAL
- en: The most common interface is `List`. This is the closest to an array. `Set`
    and `SortedSet` are interfaces that ensure that an element cannot appear more
    than once. `Queue` is a FIFO structure. You can only add elements to the end of
    the structure, and you can only remove them from the front of the structure. `Deque`
    is a structure that supports LIFO. What is unique about `Deque` is that you add
    or remove from either end. Neither `Queue` nor `Deque` permit access by subscript.
  prefs: []
  type: TYPE_NORMAL
- en: How to declare a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have already discussed in [*Chapter 6*](B19088_06.xhtml#_idTextAnchor128),
    *Methods, Interfaces, Records, and Their Relationships*, you use an interface
    class to define which methods the class must implement. The most widely used interface
    for sequential collections is the `List`. We can now declare a data structure
    that can only use the methods shown in the `List` interface and no others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Before we look at more interfaces, it is time to look at the concept of Generics
    and how they relate to the collections interface. We need to look at this now
    because while the previous line of code is executable, rarely will a Java developer
    write it this way.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Generics in the Collections Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As pointed out, the default classes in the Collections framework were designed
    to manage only references to objects of type `Object`. Polymorphism then permitted
    the use of any subclass in an implementation of any of these classes. The problem
    with this approach is that it is not type-safe. Look at this code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code begins by declaring two variables. The first is an `int` type with
    the `numberOfApples` identifier. Collections cannot contain primitive data types,
    so an object of type `Integer` is required if the primitive is an `int` type.
    Java will perform this conversion from primitive to object for you. The second
    line creates a `String` object.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the instantiation of an object of type `ArrayList` but whose interface
    is restricted to just what the `List` interface class permits. Now, we can add
    the `Integer` and the `String` objects to the collection. The last line displays
    the contents of the `List` as its `toString()` method creates a `String` object
    of all members. This leads to the expression that you should not mix apples and
    oranges. Collections must be of a single type. While the default syntax for Collections
    does not restrict what can be added, the use of Generic notation will.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a new variation of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we kept our `int` type and then created two strings. The declaration
    of the `List` now includes angle brackets. Within the brackets is the class type
    you want to restrict the `List` to contain. In this example, the class is `String`.
    While we must show the class type on the left-hand side, we can just have empty
    angle brackets on the right side as there is never a situation where these two
    class types could be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next lines add the objects to the `List`. The first two will work, but
    the third, where we are trying to add an object of type `Integer`, will generate
    an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Java will no longer allow you to mix apples and oranges. This test for ensuring
    all objects added to a collection are the same type only occurs at compile time.
    This means it is possible to add a different object type if this operation only
    occurs at runtime. This can occur when multiple processes are running in the JVM,
    and one process calls a method in another process.
  prefs: []
  type: TYPE_NORMAL
- en: We will now return to the collections and only use Generic syntax from here
    on in.
  prefs: []
  type: TYPE_NORMAL
- en: Using sequential implementations and interfaces with Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have just seen, the best practice for creating a `List` will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Any valid class type can be used. Once we have elements in our collection,
    we can access them with the `get` method and the subscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last two lines, we are referring to specific positions in the list.
    To change the object stored in a specific position, we use the `set` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The interfaces and the implementation classes all support methods that allow
    you to determine if a specific object is contained in the collections. For this
    reason, you must override the `equals` method inherited from `Object`. Certain
    collection methods require the hash value, so your classes must have a `hashCode`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also sort collections. To do this, the class type of the objects you
    are storing must implement the `Comparable` interface. This interface requires
    you to write just one method named `compareTo` that returns a negative number,
    zero, or a positive number. Here is a fragment of a class that implements `compareTo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This class has only one field that is initialized by the constructor. It implements
    the `Comparable` interface using Generic notation to indicate that we can only
    compare this object to an object of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compareTo` method, required because we are implementing the `Comparable`
    interface, must return:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive integer if the value of the current object we are comparing is greater
    than the value of the object that is being compared to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value 0 if the value of the current object we are comparing is equal to
    the value of the object that is being compared to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative integer if the value of the current object we are comparing is less
    than the value of the object that is being compared to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may wonder how we can access the value of `ComparableClass` that is passed
    to `compareTo` using dot notation when the field is private. This is possible
    because Java permits objects of the same class to access private members of another
    instance of this same class. Here is the class that tests this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `perform` method, we are displaying the result of calling the `compareTo`
    method. Let’s now create a `List` of objects and then sort the list. There is
    a small modification to `ComparableClass`. A method to return the value stored
    in the class has been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a class that creates 10 objects of `ComparableClass`, places them
    in a `List`, and sorts the `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the constructor that instantiates an object of type `ArrayList` that
    will be restricted to use only methods from the `List` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the angle brackets after `ArrayList` are empty. When we declared `comparableClasses`,
    we declared the `List` as containing `ComparableClass` objects. There is no need
    to repeat this.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next method creates 10 instances of `ComparableClass`, initializing them
    with a random integer as they are added to the `List`. Each value is also displayed
    on the console so that we can see the original values as they are assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This method displays the values in each object in the `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s fill the list, display it, sort it, and display it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Collections` class contains a family of static methods that can be applied
    to an object that implements the `Collection` interface. One is the `Collections.sort`
    method. It alters the input rather than returning a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What we have seen so far is how sequential collections can be used. The need
    for special interfaces such as `Comparable` was also highlighted. Let’s now look
    at ordered collections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Collections Framework map structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second family of collections is the map family. A map is a data structure
    in which you add elements to a map with a pair of values. The first value is the
    key. This is a reference to an object that, depending on the type of map, either
    implements the `Comparable` interface—as we saw in the previous section—or overrides
    the `hashCode` and `equals` methods. If the key is a primitive, then we declare
    it as its wrapper class, and Java will manage the necessary conversion to and
    from the primitive. The second is the value—a reference to the object you are
    storing in the map. This class does not need to implement the `Comparable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: There are three map implementations in Java, which we will now cover.
  prefs: []
  type: TYPE_NORMAL
- en: HashMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of all the data types available in Java and most other languages, the fastest
    performing is the integer. The size of an integer is the same as the word size
    of the CPU. The JVM is a 32-bit or 4-word machine. Even 64-bit Java is just modeling
    a 32-bit machine. This is where the hash code comes in.
  prefs: []
  type: TYPE_NORMAL
- en: As with all map structures, entries are comprised of two components. The first
    is the key and the second is the value. What makes `HashMap` special is that the
    hash code of the key value determines where it will store the pair. The underlying
    structure is an array, and each position in the array is a bucket. Using arithmetic
    operations such as modulus, the subscript in the array can be determined from
    the hash code of the key.
  prefs: []
  type: TYPE_NORMAL
- en: A hash code is not unique. This means that two or more keys may generate the
    same hash code. In this case, they will also want to use the same subscript, and
    the bucket becomes a single linked list of buckets. If the number of keys becomes
    greater than eight, then the linked list is converted into a balance binary tree.
    When searching for a key in a list, the `equals` method is used to test each bucket
    to find the value.
  prefs: []
  type: TYPE_NORMAL
- en: Use a hash map when you must collect data that you must be able to retrieve
    from the structure rapidly. There is no defined order. The first item you put
    in a hash map could be the seventh element in the array of buckets. This also
    means that the order of elements put into the structure cannot be determined.
  prefs: []
  type: TYPE_NORMAL
- en: To find a value in a `HashMap` object given a key, you can use the `get` method.
    This method takes the key as a parameter and returns the value if found or it
    returns `null` if not found. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `HashMap` object using the `Map` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can put data into the `HashMap` object using the `put` method that
    takes two parameters. These are the key and the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These next two lines will retrieve the value associated with the key if the
    key exists. Otherwise, `null` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There is no entry in the `HashMap` object that uses the integer 1 as a key,
    so it will print out `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate or work with every element over the entire `HashMap` object, we
    need to first create a `Set` object from all the entries in the hash map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `Set` object, we create an `Iterator` object. An iterator allows us
    to access every element in the set in the order determined by the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Iterator` object’s `hasNext` method returns `true` if there is another
    element in the `Set` object; otherwise, it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Iterator` object’s `next` method returns the key/value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the order of keys is not the same as the order they were put into
    the hash map.
  prefs: []
  type: TYPE_NORMAL
- en: LinkedHashMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This structure is a variant of `HashMap`. Internally it operates just like `HashMap`
    but also includes a second data structure. This is a linked list that preserves
    the order in which data is put into `LinkedHashMap`. If the order of entry is
    not significant, use a `HashMap` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we used `LinkedHashMap` in the previous example code, the only change we
    would make would be to use `LinkedHashMap` instead of `HashMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this version will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is the same order that the key/value pairs were put into the map.
  prefs: []
  type: TYPE_NORMAL
- en: TreeMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike `HashMap` and `LinkedHashMap`, the underlying structure of `TreeMap`
    is a red-black binary tree. The key value is used as is and must implement the
    `Comparable` interface. You do not need the `hashCode` and `equals` methods, but
    it is good practice to include them. Here is the same code using `TreeMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the keys are not in any order. As integers, they do have a natural order
    that will determine where in the binary tree the key/value pairs are placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the iterator to display all the key/value pairs, they will be in
    the order based on the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: While an array is frequently the go-to structure when you need multiple elements,
    consider that its interface is quite limited. Collections have a rich set of methods
    that expand what you can do in your code. Before we move on to functions, keep
    in mind the following note.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The Collections shown in this chapter are not thread-safe. There are variants
    of each collection that are thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functions in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, we call units of code in a class a method. In C and C++, we call them
    functions. In JavaScript, we even use the `keyword` function. What sets Java apart
    from these other languages is that functions represent a different coding model
    than classes and their methods. There are functional rather than **object-oriented**
    (**OO**) languages, of which Haskell is one example. We are briefly examining
    functions because our next topic, streams, is based on the function rather than
    the class model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some code that attached an event handler to a button in JavaFX.
    We will be looking at JavaFX in [*Chapter 13*](B19088_13.xhtml#_idTextAnchor254),
    *Desktop Graphical User Interface Coding with Swing and JavaFX*. Let’s begin by
    looking at what a functional `EventHandler` interface is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the interface class for `EventHandler` that is part of JavaFX. The
    `@FunctionalInterface` annotation is optional but adds clarity to the purpose
    behind this interface. Functional interfaces can only have one abstract method.
    There is no implementation of this interface in JavaFX. You must supply the code
    for the `handle` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This code registers an event handler for when a button is pressed. The handler
    must be an object of type `EventHandler` and must have a method named `handle`.
    The `handle` method is calling upon the `toString` method from `userBean` to return
    a string that will be assigned to a `Text` field named `actionTarget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first fragment demonstrates an anonymous inner class. It is anonymous because
    the reference is never assigned to an identifier. It can only be used in the method
    call. We do this in situations where the action to be performed is unique for
    just this button press. It cannot be reused elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This second fragment uses lambda notation. There is only one method, `handle`,
    in `EventHandler`. Therefore, we do not require additional decorations. `(ActionEvent
    event)` is the parameter that the `handle` method must receive. Our lambda is
    providing the code for the `handle` method that will execute when the button is
    pressed. While there is no limit to the number of lines of code that can be in
    a lambda, the best practice is no more than three, while just one line is preferred.
    But what if multiple lines need to be executed? This leads us to the third syntax
    for using a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions in Java can be passed as a parameter to a method and can also be
    returned by a method. In this fragment, we are stating that the `signInButtonHandler`
    method will be invoked as if it were the `handle` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, this method is in the same file. Therefore, we are referring to it with
    `this` in `setOnAction`. It must have the same return value and parameters as
    the `handle` method.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming helps to simplify our code. In any situation where we
    need a method whose action must be defined where it will be used, then using functions
    is the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: Using streams in collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing all data elements in a collection is a common action. Maybe you want
    to extract a subset of the collection based on a specific requirement. You might
    want to increase or decrease values or change the case of strings. This is where
    streams come in. All classes that implement the `Collection` interface have a
    stream method from which we can chain numerous stream methods. You cannot use
    streams directly on maps, but if you convert a map into a set, then you can use
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important characteristic of stream methods is that they operate as pure
    functions. A pure function does not change the state of any fields in the class
    or any of the parameters passed to it. A stream method always returns a new stream.
    The original stream has not changed. Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a record that contains fields that represent information on an
    employee. Now, let’s create a `List` of six employees. This information should
    come from a database, but for our purposes, we will create the `List` in the constructor
    of the `StreamsExample.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This code demonstrates that an array, not a collection, can be created by listing
    the elements separated by commas when declared in a block. There are six `Employee`
    objects created, and by using the `Arrays` method `asList`, they are converted
    into a `List`-compatible structure. This is necessary as streams do not work on
    arrays. With our list complete, we can now apply the methods available to streams.
    Many of the stream methods behave in a similar manner to SQL actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the list in place, let’s use some of the stream methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: After we call upon `stream()`, we can apply the stream methods. The first one
    is `filter`. It requires a function that can return `true` or `false` depending
    on the code in the function. The function is expressed as a lambda that will receive
    a record object of type `Employee`. The code in the lambda retrieves the `firstName`
    string from the record and applies the `startsWith` string method to find names
    that begin with `"J"`.
  prefs: []
  type: TYPE_NORMAL
- en: The result from `filter` is a new stream with only the objects that match the
    criteria. A stream must be converted back into a collection, and that is the role
    of the `collect` method. It takes as its argument the `Collectors.toList()` function
    from the `Collectors` class that will return a `List` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last example, and that is to print out the employee objects in order sorted
    by the `lastName` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This line of code uses the `sorted` stream function. It requires a function
    that determines the order of two objects based on a field. The field chosen is
    a `String` object, so it already has a `compareTo` method; otherwise, you will
    need to write a `compareTo` method. The lambda expression takes two parameters
    that are defined as `String` objects from the `Record`. This will produce a stream
    in sorted order that is then used by the `forEach` function. Rather than return
    a new `List` object, the `forEach` function receives a stream and passes each
    member of it to the `println` method of `System.out`.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Java programs rely heavily on streams. The alternative is to use iterators
    or `for` loops to access all elements. If you need to process all elements in
    a collection, look at streams before anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we appear to have covered a lot of topics in this chapter, you should
    recognize that they are all related. Whether you are retrieving records from a
    database or receiving user input from the keyboard, as soon as there is more than
    one item, you will need what has been presented here. We began with a basic array
    that is like a structure in other languages. From the array, we moved on to the
    Collections Framework. These are dynamic structures that can grow as needed. From
    the sequential to the map collections, Java provides us with a rich set of choices.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at Generics next. Unlike an array that is declared as a specific type,
    raw collections can store any object without regard to what has already been stored.
    Using generic notation, we can tie a collection to a specific data type.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Java 8, functions became part of the Java language. While ordinary
    methods in a class can be used as a function, the use of lambdas allows us to
    define specific actions for a particular problem. The Stream library, available
    in sequential collections, simplifies processing the elements of a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will examine how we can document our code and record information
    on the operation of our program in logs.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Guide to the java.util.Arrays* *class*: [https://www.baeldung.com/java-util-arrays](https://www.baeldung.com/java-util-arrays)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Collections in* *Java*: [https://www.scaler.com/topics/java/collections-in-java/](https://www.scaler.com/topics/java/collections-in-java/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional Programming in* *Java*: [https://www.scaler.com/topics/java/functional-programming-in-java/](https://www.scaler.com/topics/java/functional-programming-in-java/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Java* *Stream*: [https://zetcode.com/java/stream/](https://zetcode.com/java/stream/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
