<html><head></head><body>
		<div id="_idContainer097">
			<h1 id="_idParaDest-264" class="chapter-number"><a id="_idTextAnchor388"/>6</h1>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor389"/>Concurrency Design Patterns</h1>
			<p>Previous chapters on creational, structural, and behavioral patterns proposed a design that concerns the base code. Their main focus was on the maintainable base code that operates in the main single application thread. In other words, the generated byte code is executed in a defined sequence to achieve the <span class="No-Break">desired results.</span></p>
			<p>Nowadays, business requirements have shifted the application expectations described by the GoF’s book over the years more and more within a concurrent and parallel world. This has been succeeded by a massive improvement <span class="No-Break">in hardware.</span></p>
			<p>The Java platform provides concurrency functionality under the hood from the very beginning. The Flight Recorder tool of Mission Control set helps collect data points about thread behavior and displays them visually, improving our awareness of application dynamics. In this chapter, we are going to examine some of the most common scenarios in the information <span class="No-Break">technology industry:</span></p>
			<ul>
				<li>Decoupling a method execution with an active <span class="No-Break">object pattern</span></li>
				<li>Non-blocking tasks using an async method <span class="No-Break">invocation pattern</span></li>
				<li>Delaying execution until the previous task has been completed with the <span class="No-Break">balking pattern</span></li>
				<li>Providing a unique object instance with a double-checked <span class="No-Break">locking pattern</span></li>
				<li>Using purposeful thread blocking via a read-write <span class="No-Break">lock pattern</span></li>
				<li>Decoupling the execution logic with the <span class="No-Break">producer-consumer pattern</span></li>
				<li>Executing isolated tasks with the <span class="No-Break">scheduler pattern</span></li>
				<li>Effective thread utilization with the <span class="No-Break">thread-pool pattern</span></li>
			</ul>
			<p>By the end of this chapter, we will have built a solid foundation for understanding the concurrency possibilities of the Java platform and starting to apply <span class="No-Break">them effectively.</span></p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor390"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor391"/>Decoupling a method execution with an active object pattern</h1>
			<p>The active object design pattern<a id="_idIndexMarker512"/> separates and defers method<a id="_idIndexMarker513"/> execution from method invocation by running its own <span class="No-Break">control thread.</span></p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor392"/>Motivation</h2>
			<p>The active object pattern<a id="_idIndexMarker514"/> introduces a transparently concurrent model to the application. It creates and starts an internal thread that executes the required logical, critical section. An active object instance exposes a public interface that a client can use to run an encapsulated critical section. An external, client-initiated event is queued and ready to execute. The execution step is performed by the internal scheduler. The result can be passed to the appropriate handler in a <span class="No-Break">callback style.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor393"/>Sample code</h2>
			<p>Let us introduce an example<a id="_idIndexMarker515"/> of a moving vehicle with a radio system (<span class="No-Break"><em class="italic">Example 6.1</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static v<a id="_idTextAnchor394"/>oid main(String[] args) throws Exception {
    System.out.println("Active Object Pattern, moving
        vehicle");
    var sportVehicle = new SportVehicle("super_sport");
    sportVehicle.move();
    sportVehicle.turnOnRadio();
    sportVehicle.turnOffRadio();
    sportVehicle.turnOnRadio();
    sportVehicle.stopVehicle();
    sportVehicle.turnOffRadio();
    TimeUnit.MILLISECONDS.sleep(400);
    System.out.println("ActiveObjectMain, sportVehicle
    moving:" + sportVehicle.isMoving());
}</pre>
			<p>Here's <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Active Object Pattern, moving vehicle</strong>
<strong class="bold">MovingVehicle:'super_sport', moving</strong>
<strong class="bold">MovingVehicle:'super_sport', radio on</strong>
<strong class="bold">MovingVehicle:'super_sport', moving</strong>
<strong class="bold">MovingVehicle:'super_sport', stopping, commands_active:'3'</strong>
<strong class="bold">MovingVehicle:'super_sport', stopped</strong>
<strong class="bold">ActiveObjectMain, sportVehicle moving:false</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.1 – The SportVehicle instance allows the client to create an event by using its public meth<a id="_idTextAnchor395"/>ods</p>
			<p>The newly created<a id="_idIndexMarker516"/> abstract class, <strong class="source-inline">MovingVehi<a id="_idTextAnchor396"/>cle</strong>, def<a id="_idTextAnchor397"/>ines public methods – <strong class="source-inline">move</strong>, <strong class="source-inline">turnOnRadio</strong>, <strong class="source-inline">turnOffRadio</strong>, and <strong class="source-inline">stopVehicle</strong>. In addition to the control thread, the class defines a conditional queue for incoming events (<span class="No-Break"><em class="italic">Example 6.2</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
abstract class MovingVehicle {
    private static final AtomicInteger COUNTER = new
       AtomicInteger();
    private final BlockingDeque&lt;Runnable&gt; commands;
    private final String type;
    private final Th<a id="_idTextAnchor398"/>read thread;
    private boolean <strong class="bold">active</strong>;
    MovingVehicle(String type) {
        this.commands = new LinkedBlockingDeque&lt;&gt;();
        this.type = type;
        this.thread = createMovementThread(<a id="_idTextAnchor399"/>);
    }
   …
  private Thread createMovementThread() {
    var thread =<a id="_idTextAnchor400"/> new Thread(() -&gt; {
        while (<strong class="bold">active</strong>) {
            try {
                var command = commands.take();
                command.run();
               ...
        }
    });
    thread.setDaemon(true);
    thread.setName("moving-vehicle-" +
        COUNTER.getAndIncrement());
    return thread;
   …
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.2 – MovingVehicle contains an active flag for purpose of scheduling events</p>
			<p>Events in the queue are received and fired<a id="_idIndexMarker517"/> based on an internal period. <strong class="source-inline">LinkedBlockingDeque</strong> provides additional functions for inserting or removing elements from the top or bottom, which is useful when the vehicle needs to be stopped. The <strong class="source-inline">StopVehicle</strong> event has priority over the r<a id="_idTextAnchor401"/>adios (<span class="No-Break"><em class="italic">Example 6.3</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
abstract class MovingVehicle {
  ...
  void turnOffRadio() throws InterruptedException {
    commands.putLast(() -&gt; {...});
  }
  void stopVehicle() throws InterruptedException {
    commands.putFirst(() -&gt; {...});
  }
  ...
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.3 – The received events are added to the queue conditionally</p>
			<p>A lifecycle of the <strong class="source-inline">SportVehicle</strong> instance doe<a id="_idTextAnchor402"/>s not interfere with the main application thread. <a id="_idTextAnchor403"/>It is predictable and does not block the application (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B18884_06_01.jpg" alt="Figure 6.1 – The moving-vehicle thread shows the sequence of commands"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The moving-vehicle thread shows the sequence of commands</p>
			<p>The compon<a id="_idTextAnchor404"/>ents introduced<a id="_idIndexMarker518"/> in the example seamlessly cooperate (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B18884_06_02.jpg" alt="Figure 6.2 – The UML class diagram shows the SportVehicle class’s relation to the Java concurrency features"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The UML class diagram shows the SportVehicle class’s relation to the Java concurrency features</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor405"/>Conclusion</h2>
			<p>A well-developed active object pattern<a id="_idIndexMarker519"/> respects the SOLID design approaches because it encapsulates the critical parts and only exposes the control interface required. The instance does not interfere with the application and the whole approach can be generalized to the desired level. An active object can be a good candidate for introducing a concurrency model into an application, but there are a few challenges to keep in mind. One of these challenges is the number of possible application threads, where a high number can make the application fragile or lead to instability as it depends on <span class="No-Break">available resources.</span></p>
			<p>Let’s explore the asynchronous nature of events in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor406"/>Non-blocking tasks using async method invocation pattern</h1>
			<p>The asynchronous method<a id="_idIndexMarker520"/> invocation pattern<a id="_idIndexMarker521"/> is a way to solve the challenge of not penalizing the main process thread with possibly <span class="No-Break">time-consuming tasks.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor407"/>Motivation</h2>
			<p>Asynchronous method invocation patterns<a id="_idIndexMarker522"/> introduce the ability to receive a result by a callback from an asynchronously running task without blocking the main process thread. The pattern presents the threading model and level of parallelism for processing the required task types. The task results are processed by dedicated callback handlers and provided to the main process regardless of the task’s execution time. These handlers may already belong to the <span class="No-Break">main process.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor408"/>Sample code</h2>
			<p>Let us look at a trivial scenario<a id="_idIndexMarker523"/> of several vehicle temperature sensors required to provide results to the driver, which is the client (<span class="No-Break"><em class="italic">Example 6.4</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) throws Exception {
    System.out.println("Async method invocation Pattern,
        moving vehicle");
    var sensorTaskExecutor = new
        TempSensorExecutor&lt;Integer&gt;();
    var tempSensorCallback = new TempSensorCallback();
    var tasksNumber = 5;
    var measurements = new ArrayList&lt;SensorResult
       &lt;Integer&gt;&gt;();
    System.out.printf("""
                AsyncMethodMain, tasksNumber:'%d' %n""",
                    tasksNumber);
    for(int i=0; i&lt;tasksNumber; i++) {
        var sensorResult = sensorTaskExecutor.measure(new
            TempSensorTask(), tempSensorCallback);
        measurements.add(sensorResult);
    }
    sensorTaskExecutor.start();
    AsyncMethodUtils.delayMills(10);
    for(int i=0; i&lt; tasksNumber; i++){
        var temp = sensorTaskExecutor.stopMeasurement
            (measurements.get(i));
        System.out.printf("""
                AsyncMethodMain, sensor:'%d'
                    temp:'%d'%n""", i, temp);
    }</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker524"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Async method invocation Pattern, moving vehicle</strong>
<strong class="bold">AsyncMethodMain, tasksNumber:'5'</strong>
<strong class="bold">SensorTaskExecutor, started:5</strong>
<strong class="bold">...</strong>
<strong class="bold">TempSensorTask,n:'4' temp:'5', thread:'thread-3'</strong>
<strong class="bold">TempSensorTask,n:'3' temp:'26', thread:'thread-0'</strong>
<strong class="bold">TemperatureSensorCallback, recorded value:'26',</strong>
<strong class="bold">  thread:'main'</strong>
<strong class="bold">AsyncMethodMain, sensor:'0' temp:'26'</strong>
<strong class="bold">…</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.4 – The example task temp:26, is asynchronously executed in thread-0 thread</p>
			<p>The instance of <strong class="source-inline">TempSensorCallback</strong> that mo<a id="_idTextAnchor409"/>nitors<a id="_idIndexMarker525"/> all results resides in the <strong class="source-inline">main</strong> process thread (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B18884_06_03.jpg" alt="Figure 6.3 - TemperatoreSensorCallback instance is called asynchronously, therefore different thread finish times"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 - TemperatoreSensorCallback instance is called asynchronously, therefore different thread finish times</p>
			<p><strong class="source-inline">TempSensorTask</strong> instances are handled by custom <strong class="source-inline">TempSensorExecutor</strong> instances, which not only provides control over initiated threads, but can also terminate long-running measurements of a particular sensor by providing a task reference. The <strong class="source-inline">TempSensorExecutor</strong> instance exposes a measure public method that provides a <strong class="source-inline">TempSensorResult</strong> instance of a long-running task (<span class="No-Break"><em class="italic">Example 6.5</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class TempSensorExecutor&lt;T&gt; implements SensorExecutor&lt;T&gt; {
    ...
    @Override
    public SensorResult&lt;T&gt; measure(Callable&lt;T&gt; sensor,
        SensorCallback&lt;T&gt; callback) {
        var result = new TempSensorResult&lt;T&gt;(callback);
      <a id="_idTextAnchor410"/>  Runnable runnable = () -&gt; {
            try {
                result.setResult(sensor.call());
            } catch (Exception e) {
                result.addException(e);
            }
        };
        var thread = new Thread(runnable, "thread-" +
            COUNTER.getAndIncrement());
        thread.setDaemon(true);
        threads.add(thread);
        return result;
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.5 – Each new thread specific long-term measurement will pass its result to the callback handler</p>
			<p>The nature of processing<a id="_idIndexMarker526"/> the information served by multiple temperature sensors is clearly parallel. The asynchronous method invocation patterns provide a very small set of classes to<a id="_idTextAnchor411"/> solve this challenge (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B18884_06_04.jpg" alt="Figure 6.4 – The UML class diagram draws how data are acquired from temperature sensors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The UML class diagram draws how data are acquired from temperature sensors</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor412"/>Conclusion</h2>
			<p>The given examples clearly<a id="_idIndexMarker527"/> show how to handle a long-running task with a preliminary detachment from the main processing thread. In other words, it is not causing by delas. The Java platform provides multiple options to create this pattern. One of them is to employ the <strong class="source-inline">Callable</strong> interface and send an instance to the <strong class="source-inline">ExecutorService</strong> using its <strong class="source-inline">submit</strong> method. The <strong class="source-inline">submit</strong> method returns a result that implements the <strong class="source-inline">Future</strong> interface. The <strong class="source-inline">Future</strong> has similarities to the sample <strong class="source-inline">TempSensorResult</strong> instance but does not provide a callback function that needs to be handled differently. Another possibility can be explored using <strong class="source-inline">CompletableFuture</strong>, which not only exposes the <strong class="source-inline">supplyAsync</strong> method, but also provides many other useful functions. All of the suggestions mentioned can be found in the <strong class="source-inline">java.base</strong> module and the <span class="No-Break"><strong class="source-inline">java.util.concurren</strong></span><span class="No-Break">t package.</span></p>
			<p>The next section shows how to delay the execution of a task until the previous one is complete; let’s get <span class="No-Break">to it.</span></p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor413"/>Delay execution until the previous task is completed with the balking pattern</h1>
			<p>Sometimes it is required to consider<a id="_idIndexMarker528"/> the task state changes to properly execute next task and fulfill <span class="No-Break">the goal.</span></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor414"/>Motivation</h2>
			<p>Although the instance mutability<a id="_idIndexMarker529"/> is not a desirable state, especially not in the concurrency field the ability to depend on the object state may come handy. The case where multiple threads try to acquire an object to execute its critical sections can be limited by the object state. The state can decide whether the processing time will be used or not in order to coordinate the resources available. For example, a vehicle cannot stop without being <span class="No-Break">in motion.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor415"/>Sample code</h2>
			<p>Consider the example<a id="_idIndexMarker530"/> of one <strong class="source-inline">Vehicle</strong> instance sharing two groups of drivers. Although there are multiple groups, only one vehicle ca<a id="_idTextAnchor416"/>n oper<a id="_idTextAnchor417"/>ate at a time (<span class="No-Break"><em class="italic">Example 6.6</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) throws Exception {
    System.out.println("Balking pattern, vehicle move");
    var vehicle = new Vehicle();
    var numberOfDrivers = 5;
    var executors = Executors.newFixedThreadPool(2);
    for (int i = 0; i &lt; numberOfDrivers; i++) {
        executors.submit(vehicle::drive);
    }
    TimeUnit.MILLISECONDS.sleep(1000);
    executors.shutdown();
    System.out.println("Done");
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Balking pattern, vehicle move</strong>
<strong class="bold">Vehicle state:'MOVING', moving, mills:'75',</strong>
<strong class="bold">  thread='Thread[pool-1-thread-2,5,main]'</strong>
<strong class="bold">Vehicle state:'STOPPED' stopped, mills:'75',</strong>
<strong class="bold">  thread='Thread[pool-1-thread-2,5,main]'</strong>
<strong class="bold">Vehicle state:'MOVING', moving, mills:'98',</strong>
<strong class="bold">  thread='Thread[pool-1-thread-1,5,main]'</strong>
<strong class="bold">…</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.6 – Driver groups are represented by provided threads created by ExecutorService</p>
			<p>The balking pattern provides a solution<a id="_idIndexMarker531"/> in which the critical<a id="_idTextAnchor418"/> section of the task is executed based on the <strong class="source-inline">Vehicle</strong> instance state represented by the <strong class="source-inline">VehicleState</strong> enum (<span class="No-Break"><em class="italic">Example 6.7</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class Vehicle {
    synchronized void driveWithMills(int mills) throws
        InterruptedException {
        var internalState = getState();
        switch (internalState) {
            case MOVING -&gt; System.out.printf("""
                    Vehicle state:'%s', vehicle in move,
                        millis:'%d', thread='%s'%n""",
                           state, mills, Thread
                             .currentThread());
            case STOPPED -&gt; startEngineAndMove(mills);
            case null -&gt; init();
        }
}
...</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.7 – The usage of the synch<a id="_idTextAnchor419"/>ronized keyword makes the driver groups aware of whether the Vehicle instance is ready to use or not</p>
			<p>The driver group threads<a id="_idIndexMarker532"/> are blocked and only one is active at a time (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B18884_06_05.jpg" alt="Figure 6.5 – The blue and green colors represent group activity while the other is blocked"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The blue and green colors represent group activity while the other is blocked</p>
			<p>The example presented requires<a id="_idTextAnchor420"/> a very minimal number of created classes, which are clearly encapsulated (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B18884_06_06.jpg" alt="Figure 6.6 – The UML class diagram shows the two most required custom classes, Vehicle and VehicleState"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The UML class diagram shows the two most required custom classes, Vehicle and VehicleState</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor421"/>Conclusion</h2>
			<p>The balking pattern<a id="_idIndexMarker533"/> is easy to implement in the Java platform. It is important to keep the Java memory model in mind in order to properly handle object state volatility. It may be particularly useful to consider using atomic types (<strong class="source-inline">AtomicInteger</strong> and <strong class="source-inline">AtomicBoolean</strong>, for example), which automatically come with a happens-before guarantee. This guarantee is part of the Java memory model to maintain memory consistency across the interacting threads, as we learned in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em>. Another option to consider is the <strong class="source-inline">volatile</strong> keyword, which comes with a guarantee of equal-value visibility <span class="No-Break">across threads.</span></p>
			<p>The next section examines guaranteed instance uniqueness – <span class="No-Break">let’s roll.</span></p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor422"/>Providing a unique object instance with a double-checked locking pattern</h1>
			<p>The double-checked locking pattern<a id="_idIndexMarker534"/> solves the problem<a id="_idIndexMarker535"/> of an application requiring only one instance of a particular class <span class="No-Break">at runtime.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor423"/>Motivation</h2>
			<p>The Java platform<a id="_idIndexMarker536"/> is multi-threaded by default, as we learned in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em>. It’s not just the garbage collection threads that take care of the main program lifecycle. Different frameworks introduce additional tread models, which may have an unintended impact on a class institution’s process. A double-checked locking pattern ensures that only one instance of a class is present at runtime. This state can become challenging in a multi-threaded environment, as it may depend on <span class="No-Break">its implementation.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor424"/>Sample code</h2>
			<p>Let’s use a simple <strong class="source-inline">Vehicle</strong> instance<a id="_idIndexMarker537"/> to demonstrate the importance of a double-checked locking pattern in a multithreading environment. The example presents two different implementations of the singleton pattern. <strong class="source-inline">VehicleSingleton</strong> is expected to keep its promise due to multiple threads accessing the <strong class="source-inline">getInstance</strong> method (<span class="No-Break"><em class="italic">Example 6.8</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Double checked locking pattern,
        only one vehicle");
    var amount = 5;
    ExecutorService executor = Executors
        .newFixedThreadPool(amount);
    System.out.println("Number of executors:" + amount);
    for (int i = 0; i &lt; amount; i++) {
        executor.submit(VehicleSingleton::getInstance);
        executor.submit(VehicleSingletonChecked
           ::getInstance);
    }
    executor.shutdown();
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Double checked locking pattern, only one vehicle</strong>
<strong class="bold">Number of executors:5</strong>
<strong class="bold">VehicleSingleton, constructor thread:'pool-1-thread-1'</strong>
<strong class="bold">hashCode:'1460252997'</strong>
<strong class="bold">VehicleSingleton, constructor thread:'pool-1-thread-5'</strong>
<strong class="bold">hashCode:'1421065097'</strong>
<strong class="bold">VehicleSingleton, constructor thread:'pool-1-thread-3'</strong>
<strong class="bold">hashCode:'1636104814'</strong>
<strong class="bold">VehicleSingletonChecked, constructor thread:'pool-1-thread-</strong>
<strong class="bold">2' hashCode:'523532675'</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.8 – The VehicleSingleton construc<a id="_idTextAnchor425"/>tor has been called multiple times, which violates the given promi<a id="_idTextAnchor426"/>se through multiple instantiations (see the hashCode values)</p>
			<p>The <strong class="source-inline">ExecutorService</strong> instance provided by <strong class="source-inline">Executors<a id="_idTextAnchor427"/>.newFixed<a id="_idTextAnchor428"/>ThreadPool</strong> receives multiple<a id="_idIndexMarker538"/> instances of the <strong class="source-inline">Run<a id="_idTextAnchor429"/>nable</strong> interface. The <strong class="source-inline">Runnable</strong> met<a id="_idTextAnchor430"/>hod’s implementation represents the critical section of the <a id="_idTextAnchor431"/><strong class="source-inline">getInstance</strong> method’s call in both cases (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B18884_06_07.jpg" alt="Figure 6.7 – All pool threads continuously execute the getInstance method and VehicleSingletonCheck i﻿s cre﻿ated only once"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – All pool threads continuously execute the getInstance method and VehicleSingletonCheck i<a id="_idTextAnchor432"/>s cre<a id="_idTextAnchor433"/>ated only once</p>
			<p>Both implementations<a id="_idIndexMarker539"/> differ in the very small details of the <strong class="source-inline">getInstance</strong> method implementation (<span class="No-Break"><em class="italic">Example 6.9</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static VehicleSingleto<a id="_idTextAnchor434"/>n getInstance(){
    if (INSTANCE == null){
        INSTANCE = new VehicleSingleton();
    }
    return INSTANCE;
}
...
static VehicleSingletonChecked getInstance() {
    if (INSTANCE == null) {
        synchronized (VehicleSingletonChecked.class) {
            if (INSTANCE == null) {
                INSTANCE = new VehicleSingletonChecked();
            }
        }
    }
    return INSTANCE;
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.9 – The <a id="_idTextAnchor435"/>getInstance method’s implementation of VehicleSingletonChecked uses a synchronized keyword to ensure the thre<a id="_idTextAnchor436"/>ad stack<a id="_idTextAnchor437"/> frame state</p>
			<p>In both cases, the UML<a id="_idTextAnchor438"/> diag<a id="_idTextAnchor439"/>ram<a id="_idIndexMarker540"/> remains the same (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B18884_06_08.jpg" alt="Figure 6.8 – The UML class diagram does not highlight the implementation details of the double-checked singleton pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The UML class diagram does not highlight the implementation details of the double-checked singleton pattern</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor440"/>Conclusion</h2>
			<p>This example<a id="_idIndexMarker541"/> has shown a possible way to implement a double-check locking pattern. The Java platform may also enforce double-checked locking patterns by using an <strong class="source-inline">Enum</strong> construct, which provides only one element – its <strong class="source-inline">INSTANCE</strong> object of <span class="No-Break">desired type.</span></p>
			<p>The next section demonstrates how to deal with <span class="No-Break">locking exclusivity.</span></p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor441"/>Using purposeful thread blocking via a read-write lock pattern</h1>
			<p>A concurrent application<a id="_idIndexMarker542"/> may consider granting exclusive access<a id="_idIndexMarker543"/> to a critical section just to update the information of the specific instance. This particular challenge can be solved by using a read-write <span class="No-Break">lock pattern.</span></p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor442"/>Motivation</h2>
			<p>The read-write locking pattern<a id="_idIndexMarker544"/> introduces natural exclusivity for lock acquisition. This context is used to differentiate the whether the critical section can be executed. In other words, the write action takes precedence by its nature before reading, as the goal of any reader is to get the most accurate and up-to-date value possible. Under the hood, this means that all readers are blocked when the writer thread is modifying data and unblocked when the writer completes <span class="No-Break">its task.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor443"/>Sample code</h2>
			<p>Suppose that multiple sensors<a id="_idIndexMarker545"/> inside a vehicle require accurate information about the temperature value, but there is only one temperature device capable of updating the temperature value (<span class="No-Break"><em class="italic">Example 6.10</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) throws Exception {
    System.out.println("Read-Write Lock pattern, writing
        and reading sensor values");
    ReentrantReadWriteLock readWriteLock = new
        ReentrantReadWriteLock();
    var sensor = new Sensor(readWriteLock.readLock(),
        readWriteLock.writeLock());
    var sensorWriter = new SensorWriter("writer-1",
        sensor);
    var writerThread = getWriterThread(sensorWriter);
    ExecutorService executor = Executors.newFixedThreadPool
        (NUMBER_READERS);
    var readers = IntStream.range(0, NUMBER_READERS)
            .boxed().map(i -&gt; new SensorReader("reader-"
               + i, sensor, CYCLES_READER)).toList();
    readers.forEach(executor::submit);
    writerThread.start();
    executor.shutdown();
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker546"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Read-Write Lock pattern, writing and reading sensor values</strong>
<strong class="bold">SensorReader read, type:'reader-2', value:'50,</strong>
<strong class="bold">thread:'pool-1-thread-3'</strong>
<strong class="bold">SensorReader read, type:'reader-0', value:'50,</strong>
<strong class="bold">thread:'pool-1-thread-1'</strong>
<strong class="bold">SensorReader read, type:'reader-1', value:'50,</strong>
<strong class="bold">thread:'pool-1-thread-2'</strong>
<strong class="bold">SensorWriter write, type:'writer-1', value:'26',</strong>
<strong class="bold">thread:'pool-2-writer-1'</strong>
<strong class="bold">SensorReader read, type:'reader-2', value:'26,</strong>
<strong class="bold">thread:'pool-1-thread-3'</strong>
<strong class="bold">...</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.10 – The Senso<a id="_idTextAnchor444"/>rWriter instance that runs its own thread obtains exclusive access to the Sensor instance</p>
			<p>Readers continuously<a id="_idIndexMarker547"/> read the sensor value without being blocked. The situation changes when the writer enters the game – at which point, readers are blocked and have to wait for the <strong class="source-inline">SensorWriter</strong> instance to finish (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B18884_06_09.jpg" alt="Figure 6.9 – Thread activity highlighting writer lock exclusivity when reader threads are being blocked"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Thread activity highlighting writer lock exclusivity when reader threads are being blocked</p>
			<p>The critical section is served by two methods, <strong class="source-inline">writeValue</strong> and <strong class="source-inline">readValue</strong>.<a id="_idTextAnchor445"/> Both belong to the <strong class="source-inline">Sensor</strong> class (<span class="No-Break"><em class="italic">Example 6.11</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
clas<a id="_idTextAnchor446"/>s Sensor {
    ...
  <a id="_idTextAnchor447"/>  int getValue() {
        readLock.lock();
        int result;
    <a id="_idTextAnchor448"/>    try {  resu<a id="_idTextAnchor449"/>lt = value; … } finally {  readLock.
          unlock(); }
        retu<a id="_idTextAnchor450"/>rn result;
    }
    void writeValue(int v) {
        write<a id="_idTextAnchor451"/>Lock.lock();
        try { this.value = v; ...} finally {
            writeLock.unlock();}
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.11 – readLock is paused when writeLock is acquired</p>
			<p>It is important to note<a id="_idIndexMarker548"/> that lock instances reside in the main thread of execution and are acquired by the threads provided by the <strong class="source-inline">ExecutorSer<a id="_idTextAnchor452"/>vice</strong> instance (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B18884_06_10.jpg" alt="Figure 6.10 – The UML class diagram for a read-write lock pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – The UML class diagram for a read-write lock pattern</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor453"/>Conclusion</h2>
			<p>The read-write lock is very powerful and can contribute<a id="_idIndexMarker549"/> very positively to the stability of the application. It clearly separates the participant from the critical section code that drives the logic. Each example class can be generalized or adapted according to SOLID design principles <span class="No-Break">upon request.</span></p>
			<p>The JDK defines another approach worth considering for exchanging the sensor value. The <strong class="source-inline">java.base</strong> module package, <strong class="source-inline">java.util.concurrent</strong>, contains the <strong class="source-inline">Exchanger</strong> class, which provides<a id="_idIndexMarker550"/> the required <span class="No-Break">synchronization guarantees.</span></p>
			<p>Let’s examine another common pattern where the instance is broadcasted to <span class="No-Break">the target.</span></p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor454"/>Decoupling the execution logic with a producer-consumer pattern</h1>
			<p>The common industrial scenario<a id="_idIndexMarker551"/> represents producing and consuming<a id="_idIndexMarker552"/> values without blocking the main application thread. The producer-consumer pattern helps to solve this challenge by decoupling the logic and separating <span class="No-Break">the lines.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor455"/>Motivation</h2>
			<p>A common industrial scenario<a id="_idIndexMarker553"/> involves producing and consuming values without blocking the main execution thread. The producer-consumer pattern is designed exactly to rise to the challenge by decoupling the logic and separating the <span class="No-Break">target receivers.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor456"/>Sample code</h2>
			<p>Another scenario is where<a id="_idIndexMarker554"/> the vehicle produces multiple events from multiple sources and these events need to be broadcasted and delivered to consumers (<span class="No-Break"><em class="italic">Example 6.12</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) throws Exception{
    System.out.println("Producer-Consumer pattern,
        decoupling receivers and emitters");
    var producersNumber = 12;
    var consumersNumber = 10;
    var container = new EventsContainer(3);
    ExecutorService producerExecutor =
        Executors.newFixedThreadPool(4, new
            ProdConThreadFactory("prod"));
    ExecutorService consumersExecutor = Executors.
        newFixedThreadPool(2, new ProdConThreadFactory
            ("con"));
    IntStream.range(0, producersNumber)
            .boxed().map(i -&gt; new EventProducer(container))
            .forEach(producerExecutor::submit);
    IntStream.range(0, consumersNumber)
            .boxed().map(i -&gt; new EventConsumer(i,container))
            .forEach(consumersExecutor::submit);
    TimeUnit.MILLISECONDS.sleep(200);
    producerExecutor.shutdown();
    consumersExecutor.shutdown();
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker555"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Producer-Consumer pattern, decoupling mess</strong>
<strong class="bold">VehicleSecurityConsumer,event:'Event[number=0, source=pool-</strong>
<strong class="bold">prod-0]', number:'0', thread:'pool-con-0'</strong>
<strong class="bold">VehicleSecurityConsumer,event:'Event[number=1, source=pool-</strong>
<strong class="bold">prod-3]', number:'1', thread:'pool-con-1'</strong>
<strong class="bold">VehicleSecurityConsumer,event:'Event[number=3, source=pool-</strong>
<strong class="bold">prod-1]', number:'2', thread:'pool-con-0'</strong>
<strong class="bold">VehicleSecurityConsumer,event:'Event[number=2, source=pool-prod-2]', number:'3', thread:'pool-con-1'</strong>
<strong class="bold">...</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.12 – Compared to producers, consumers are in the minority, not only in terms of quantity but also in terms of available resources</p>
			<p>Each of the <strong class="source-inline">ExecutorService</strong> instances u<a id="_idTextAnchor457"/>ses a <strong class="source-inline">ProdConThreadFactory</strong> object <a id="_idTextAnchor458"/>type to provide<a id="_idIndexMarker556"/> meaningful thread names (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B18884_06_11.jpg" alt="Figure 6.11 – Consumers are in the minority and sometimes may be blocked as the event storage is full"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Consumers are in the minority and sometimes may be blocked as the event storage is full</p>
			<p>The participant classes are decoupled and ready for extension (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B18884_06_12.jpg" alt="Figure 6.12 – The UML class diagram shows how event classes are related to the internals of the Java platform"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – The UML class diagram shows how event classes are related to the internals of the Java platform</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor459"/>Conclusion</h2>
			<p>In the field of distributed<a id="_idIndexMarker557"/> systems, the production-consumer approach is widely used. It is advantageous for clearly separating and defining groups of event senders and receivers. The groups can be placed in different threads according to the desired <span class="No-Break">thread model.</span></p>
			<p>The JDK 19 release comes with the newly added concept of virtual threads. Virtual threads attempt to simplify the use of core platform threads by introducing thread-like frames, and wrappers. The virtual thread wrappers are scheduled by the JVM to run on available platform threads by using newly added executors – for example, <strong class="source-inline">Executors.newVirtualThreadPerTaskExecutor</strong>. This approach fulfills the definition of the producer-consumer pattern, in which the producer is an application that uses new virtual thread executors and the platform consumes scheduled <span class="No-Break">virtual threads.</span></p>
			<p>Let’s uncover the scheduler approach in the next section in <span class="No-Break">more detail.</span></p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor460"/>Executing isolated tasks with the scheduler pattern</h1>
			<p>An application behaving<a id="_idIndexMarker558"/> deterministically can play<a id="_idIndexMarker559"/> a critical role in its success. A scheduler pattern can help to achieve the <span class="No-Break">desired goal.</span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor461"/>Motivation</h2>
			<p>Although schedulers<a id="_idIndexMarker560"/> are sometimes poorly designed to keep the application busy, their main purpose is important. The importance of using patterns comes to light more with microservices or distributed approaches in which the system is required to behave predictably. The general goal is to determine when a specific task is performed so that the underlying resources are properly used or a budget estimate can be created for the required resources described in site <span class="No-Break">reliability engineering.</span></p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor462"/>Sample code</h2>
			<p>The following example<a id="_idIndexMarker561"/> brings us to temperature measurement. Every vehicle contains temperature sensors in a mechanical or digital form. Temperature sensors play a key role in vehicle operati<a id="_idTextAnchor463"/>on (<span class="No-Break"><em class="italic">Ex<a id="_idTextAnchor464"/>ample 6.13</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main (String [] args) throws Exception {
    System.out.println("Scheduler pattern, temperature
        measurement");
    var scheduler = new CustomSch<a id="_idTextAnchor465"/>eduler(100);
    scheduler.run();
    for (int i=0; i &lt; 15; i++){
        scheduler.addTask(new SensorTask(
            "temperature-"+i));
    }
    TimeUnit.SECONDS.sleep(1);
    scheduler.stop();
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker562"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Scheduler pattern, providing sensor values</strong>
<strong class="bold">SensorTask, type:'temperature-0'</strong>
<strong class="bold">,activeTime:'58',thread:'scheduler-1'</strong>
<strong class="bold">SensorTask, type:'temperature-1',</strong>
<strong class="bold">activeTime:'65',thread:'scheduler-1'</strong>
<strong class="bold">SensorTask, type:'temperature-2',</strong>
<strong class="bold">activeTime:'75',thread:'scheduler-1'</strong>
<strong class="bold">...</strong>
<strong class="bold">CustomScheduler, stopped</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.13 – The CustomScheduler instance executes a SensorTask instance from the blocking queue every 100 milliseconds</p>
			<p><strong class="source-inline">CustomerScheduler</strong> shows a trivial implementation<a id="_idIndexMarker563"/> that administers the execution process (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B18884_06_13.jpg" alt="Figure 6.13 – Each task execution has a 100 ms time window allocated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Each task execution has a 100 ms time window allocated</p>
			<p>The scheduler instantiation prepares a thread with an active flag to control the lifecycle (<span class="No-Break"><em class="italic">Example 6.14</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
CustomScheduler  { ...
    CustomScheduler(int intervalMillis) {
    this.intervalMills = intervalMillis;
    this.queue = new ArrayBlockingQueue&lt;&gt;(10);
    this.thread = new Thread(() -&gt; {
        while (active){
            try {
                var runnable = queue.poll(intervalMillis,
                    TimeUnit.MILLISECONDS);
                 ...
                 var delay = intervalMillis – runnable
                    .activeTime();
                TimeUnit.MILLISECONDS.sleep(delay);
            } catch (InterruptedException e) {  throw new
                RuntimeException(e); }
        }
        System.out.println("CustomScheduler, stopped");
    }, "scheduler-1");
}
...</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.14 – CustomScheduler ensures that the time window is maintained</p>
			<p>The task of creating a simple<a id="_idIndexMarker564"/> scheduler is trivial, but beyond that, it’s good to keep in mind the threading model – as in, where and how execution takes place (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B18884_06_14.jpg" alt="Figure 6.14 – The UML class diagram highlights the CustomScheduler threading model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – The UML class diagram highlights the CustomScheduler threading model</p>
			<p>In the case of the scheduler pattern, it is only fair to mention the second example. The second example uses the built-in JDK functions and their customizations. The planning process is fully managed by the platform. The application example is, again, similar to the first example, temperature<a id="_idIndexMarker565"/> measurement (<span class="No-Break"><em class="italic">Example 6.15</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) throws Exception {
    System.out.println("Pooled scheduler pattern ,
        providing sensor values");
    var pool = new CustomScheduledThreadPoolExecutor(2);
    for(int i=0; i &lt; 4; i++){
        pool.scheduleAtFixedRate(new SensorTask
           ("temperature-"+i), 0, 50,
                TimeUnit.MILLISECONDS);
    }
    TimeUnit.MILLISECONDS.sleep(200);
    pool.shutdown();
}</pre>
			<p>Here’s <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pooled scheduler pattern, providing sensor values</strong>
<strong class="bold">POOL: scheduled task:'468121027', every MILLS:'50'</strong>
<strong class="bold">POOL, before execution, thread:'custom-scheduler-pool-0',</strong>
<strong class="bold">task:'852255136'</strong>
<strong class="bold">...</strong>
<strong class="bold">POOL: scheduled task:'1044036744', every MILLS:'50'</strong>
<strong class="bold">SensorTask, type:'temperature-1',</strong>
<strong class="bold">activeTime:'61',thread:'custom-scheduler-pool-1'</strong>
<strong class="bold">SensorTask, type:'temperature-0',</strong>
<strong class="bold">activeTime:'50',thread:'custom-scheduler-pool-0'</strong>
<strong class="bold">POOL, after execution, task:'852255136', diff:'56'</strong>
<strong class="bold">POOL, before execution, thread:'custom-scheduler-pool-0',</strong>
<strong class="bold">task:'1342170835'</strong>
<strong class="bold">SensorTask, type:'temperature-2'</strong>
<strong class="bold">,activeTime:'71',thread:'custom-scheduler-pool-0'</strong>
<strong class="bold">...</strong>
<strong class="bold">POOL is going down</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.15 – The period is set to 100 ms and the SensorTask instance is reused for each iteration</p>
			<p>An extended <strong class="source-inline">CustomScheduledThreadPoolExecutor</strong> instance can provide additional information<a id="_idIndexMarker566"/> based on task execution by overriding an available method such as <strong class="source-inline">beforeExecute</strong> or <strong class="source-inline">afterExecute</strong>. Using the JDK internals makes it easy to scale a <strong class="source-inline">SensorTask</strong> instance across threads (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B18884_06_15.jpg" alt="Figure 6.15 – A CustomScheduledThreadPoolExecutor instance facilitates easier thread management and easier management of other JDK internals"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – A CustomScheduledThreadPoolExecutor instance facilitates easier thread management and easier management of other JDK internals</p>
			<p>Leveraging the JDK internals for scheduling does not require you to create a customized solution while gaining<a id="_idIndexMarker567"/> better visibility into the scheduling cycle (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.16</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B18884_06_16.jpg" alt="Figure 6.16 – The UML class diagram shows the minimal effort required to create a custom scheduler with all the internals"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – The UML class diagram shows the minimal effort required to create a custom scheduler with all the internals</p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor466"/>Conclusion</h2>
			<p>Both preset examples<a id="_idIndexMarker568"/> show possible uses of the scheduler pattern. Using the JDK internals has a number of advantages to consider. It gives the platform the ability to more efficiently use and optimize available resources, such as the dynamic JIT translation we learned about in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">,</em> <em class="italic">Discovering the Java Platform for </em><span class="No-Break"><em class="italic">Design Patterns</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor467"/>Effective thread utilization using a thread-pool pattern</h1>
			<p>It is not always necessary<a id="_idIndexMarker569"/> to create a new thread for each task, as this<a id="_idIndexMarker570"/> can lead to improper resource usage. A thread-pool pattern may be a good solution to <span class="No-Break">this challenge.</span></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor468"/>Motivation</h2>
			<p>A short-lived task does<a id="_idIndexMarker571"/> not need to create a new thread every time it runs, because each instantiation of a thread is related to the allocation of underlying resources. Wasting resources could result in an application throughput or performance penalty. A better option is described by the thread-pool pattern, which defines the required number of reusable threads to execute a critical section. Specific workers can transparently operate above the critical section code that needs to <span class="No-Break">be executed.</span></p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor469"/>Sample code</h2>
			<p>Let us imagine<a id="_idIndexMarker572"/> again a temperature measurement by sensors with different measurement<a id="_idTextAnchor470"/> dynamics (<span class="No-Break"><em class="italic">Example 6.16</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main (String[] args) throws Exception{
    System.out.println("Thread-Pool pattern, providing
        sensor values");
    var exec<a id="_idTextAnchor471"/>utor = Executors.newFixedThreadPool(5);
    for (int i=0; i &lt; 15; i++){
        var task = <a id="_idTextAnchor472"/>new TemperatureTask("temp" + i);
        var worker  = new SensorWorker(task);
        executor.submit(worker);
    }
    executor.shutdown();
}</pre>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker573"/></span><span class="No-Break"> output:</span></p>
			<pre class="source-code">
<strong class="bold">Thread-Pool pattern, providing sensor values</strong>
<strong class="bold">TemperatureTask, type:'temp3', temp:'0', thread:'pool-1-</strong>
<strong class="bold">thread-4'</strong>
<strong class="bold">TemperatureTask, type:'temp4', temp:'7', thread:'pool-1-</strong>
<strong class="bold">thread-5'</strong>
<strong class="bold">TemperatureTask, type:'temp2', temp:'15', thread:'pool-1-</strong>
<strong class="bold">thread-3'</strong>
<strong class="bold">TemperatureTask, type:'temp1', temp:'20', thread:'pool-1-</strong>
<strong class="bold">thread-2'</strong>
<strong class="bold">..</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.16 – The thread pool runs the worker temperature measurement task on<a id="_idTextAnchor473"/> demand</p>
			<p>A thread pool helps to use and manage created threads so that there is always a task to process. This positively affects the application behavior and facilitates planning ba<a id="_idTextAnchor474"/>sed on the resources available (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.17</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B18884_06_17.jpg" alt="Figure 6.17 – The behavior of the thread pool shows the usage of the created thread"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – The behavior of the thread pool shows the usage of the created thread</p>
			<p>The core<a id="_idTextAnchor475"/> example element is <strong class="source-inline">SensorWorker</strong>. The worker implements a <strong class="source-inline">Runnable</strong> interface and is responsible for the <strong class="source-inline">TemperatureTask</strong> evaluation (<span class="No-Break"><em class="italic">Example 6.17</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class SensorWorker implements Runnable {
    ...
    @Override
    public void run () {
        try {task.measure();} catch (InterruptedException
            e) {...}
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6.17 – The SensorTask instance can provide additional logic for the task evaluation wrapped around it</p>
			<p>The example implementation<a id="_idIndexMarker574"/> does not require any additional custom class types to introduce concurrency (<span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.16</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B18884_06_18.jpg" alt="Figure 6.18 – The UML class diagram highlights that all the required thread pool elements are provided by the Java platform"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – The UML class diagram highlights that all the required thread pool elements are provided by the Java platform</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor476"/>Conclusion</h2>
			<p>A thread-pool pattern <a id="_idIndexMarker575"/>can provide another acceptable way to introduce concurrency into an application. It not only supports the execution of class types that inherit the <strong class="source-inline">Runnable</strong> interface but also the <strong class="source-inline">Callable</strong> interface. Using a <strong class="source-inline">Callable</strong> interface allows you to create a result through a <strong class="source-inline">Future</strong> interface. The result of executing a <strong class="source-inline">Callable</strong> instance into an instance of the <strong class="source-inline">Future</strong> type is that the execution of the critical section is done asynchronously by the controlling thread. In other words, the time required to produce a result is <span class="No-Break">not known.</span></p>
			<p>The thread-pool pattern is also another SOLID approach to properly structuring your code base to ensure maintainability and <span class="No-Break">resource utilization.</span></p>
			<p>Let us briefly summarize the lessons learned in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor477"/>Summary</h1>
			<p>This chapter demonstrated some of the most commonly used approaches to solving concurrent problems. It also showed the importance of previously acquired knowledge, concurrent application development requires more precision and discipline to achieve the desired result, similar to the knowledge of Java platform internals discussed in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for </em><span class="No-Break"><em class="italic">Design Patterns</em></span><span class="No-Break">.</span></p>
			<p>Each currently adopted pattern forces the creation of a sustainable, clean application code base. Many of them clearly follow and use discussed development approaches such as APIE <span class="No-Break">or SOLID.</span></p>
			<p>The evolution of the Java platform tends to simplify how to approach the platform’s concurrency capabilities. One good example has been already mentioned in some of the sections in this chapter. Features such as <strong class="source-inline">CompletableFuture</strong> or <strong class="source-inline">Executors</strong> utils have been around for a while, but upcoming ones might be worth considering. The tentative goal with virtual threads is to increase application throughput while making proper use of the underlying resources and still maintaining threading conveniences such as debugging and providing relevant stack frames. Structure concurrency, on the other hand, attempts to provide a framework for simply designing callbacks while using an imperative code style. In addition to upcoming features that try to improve application throughput or simplify the usage of the concurrency framework, we should not forget about the immutability of the instances served by the <strong class="source-inline">record</strong> type. The <strong class="source-inline">record</strong> type provides a strong state contract due to equality. Instance immutability can play a critical role in <span class="No-Break">thread interactions.</span></p>
			<p>The entire application development can sometimes deviate from the desired goal. Some common symptoms have already been identified in this kind of situation. These signals could signal our attention to reconsider the direction <span class="No-Break">of development.</span></p>
			<p>We will touch on some of them in the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor478"/>Questions</h1>
			<ol>
				<li>What challenges are solved by the double-check <span class="No-Break">singleton pattern?</span></li>
				<li>What is the best way to create the desired thread pool with <span class="No-Break">the JDK?</span></li>
				<li>Which concurrent design pattern reflects the variability of an instance to process the <span class="No-Break">next step?</span></li>
				<li>What is the best pattern for handling a <span class="No-Break">repeatable task?</span></li>
				<li>What pattern helps separate the dispatch logic and <span class="No-Break">event handling?</span></li>
			</ol>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor479"/>Further reading</h1>
			<ul>
				<li><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, <span class="No-Break">Addison-Wesley, 1995</span></li>
				<li><em class="italic">Design Principles and Design Patterns</em> by Robert C. Martin, Object <span class="No-Break">Mentor, 2000</span></li>
				<li><em class="italic">JEP-425: Virtual </em><span class="No-Break"><em class="italic">Threads</em></span><span class="No-Break">, </span><a href="https://openjdk.org/jeps/425"><span class="No-Break">https://openjdk.org/jeps/425</span></a></li>
				<li><em class="italic">JSR-428: Structured Concurrency (</em><span class="No-Break"><em class="italic">Incubator)</em></span><span class="No-Break"> (</span><a href="https://openjdk.org/jeps/428"><span class="No-Break">https://openjdk.org/jeps/428</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">Patterns of Enterprise Application Architecture</em> by Martin Fowler, Pearson Education, <span class="No-Break">Inc, 2003</span></li>
				<li><em class="italic">Effective Java, Third Edition</em> by Joshua Bloch, <span class="No-Break">Addison-Wesley, 2018</span></li>
				<li><em class="italic">JDK 17: Class </em><span class="No-Break"><em class="italic">Exchanger</em></span><span class="No-Break"> (</span><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html"><span class="No-Break">https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Exchanger.html</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">JDK 17: Class </em><span class="No-Break"><em class="italic">CompletableFuture</em></span><span class="No-Break"> (</span><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html"><span class="No-Break">https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CompletableFuture.html</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">JDK 17: Class </em><span class="No-Break"><em class="italic">Executors</em></span><span class="No-Break"> (</span><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html"><span class="No-Break">https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html</span></a><span class="No-Break">)</span></li>
				<li><em class="italic">Java Mission </em><span class="No-Break"><em class="italic">Control</em></span><span class="No-Break"> (</span><a href="https://wiki.openjdk.org/display/jmc"><span class="No-Break">https://wiki.openjdk.org/display/jmc</span></a><span class="No-Break">)</span></li>
			</ul>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor480"/>Answers</h1>
			<ol>
				<li value="1">The challenge solved by the double-checked singleton pattern is ensuring that only one class instance is present in the running JVM to avoid <span class="No-Break">possible leaks</span></li>
				<li>The usage of the <strong class="source-inline">Executors</strong> utility that resides in the <strong class="source-inline">java.base</strong> module and <span class="No-Break"><strong class="source-inline">java.util.concurrent</strong></span><span class="No-Break"> package</span></li>
				<li>The balking pattern depends on the <span class="No-Break">instance stat</span></li>
				<li>The <span class="No-Break">scheduler pattern</span></li>
				<li>The producer-consumer pattern is one of the most common concurrent design patterns, with clearly separated and <span class="No-Break">addressed logic</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer098" class="IMG---Figure">
			</div>
		</div>
	</body></html>