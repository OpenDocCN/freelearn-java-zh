- en: The HTTP Client API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP客户端API
- en: With the HTTP Client API, your Java code can request HTTP resources over the
    network, using the HTTP/2 protocol, in a non-blocking and asynchronous way. It
    brings major improvements to the existing `HttpURLConnection` class, which was
    added to Java in Version 1.1, and only works in a blocking and synchronous way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP客户端API，你的Java代码可以通过HTTP/2协议以非阻塞和异步的方式请求网络上的HTTP资源。它对现有的`HttpURLConnection`类进行了重大改进，该类在Java
    1.1版本中添加，并且仅以阻塞和同步的方式工作。
- en: The HTTP Client was incubated in Java 9, with multiple modifications in Java
    10, and was standardized in Java 11\. It resides in the `java.net.http` package
    and module.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP客户端在Java 9中被孵化，Java 10中进行了多次修改，并在Java 11中标准化。它位于`java.net.http`包和模块中。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to the HTTP Client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端简介
- en: Sending requests synchronously and asynchronously
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步和异步发送请求
- en: Converting response bytes to high-level formats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将响应字节转换为高级格式
- en: Using Reactive Streams to handle HTTP requests and responses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式流处理HTTP请求和响应
- en: '`BodyHandler`, `BodyPublisher`, and `BodySubscriber`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BodyHandler`、`BodyPublisher`和`BodySubscriber`'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code in this chapter will use the standardized HTTP Client API classes from
    Java 11\. If you are using the incubated HTTP Client from the previous Java versions,
    such as 9 or 10, all of the code in this chapter won't work as specified. A lot
    of method names have changed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码将使用Java 11的标准HTTP客户端API类。如果你使用的是之前Java版本（如9或10）的孵化HTTP客户端，那么本章中的所有代码将无法按指定方式工作。许多方法名称已经更改。
- en: All of the code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)找到。
- en: Before diving into the details, let's get a hang of the problem that led to
    the introduction of this new API for requesting HTTP resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们了解一下导致引入这个新API以请求HTTP资源的问题。
- en: A quick flashback
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾
- en: The HTTP Client API was incubated in Java 9\. Essentially, this means that this
    API wasn't a part of the Java SE. It was defined in the `jdk.incubator.httpclient` package. The
    incubated features should explicitly be added to a project's classpath. The incubated
    features are released by Oracle to enable developers to use and experiment with
    them and provide their feedback, which decides the fate of HTTP Client API. In
    a future Java version, incubated APIs and features are either included as a full
    feature or just dropped off. There is no partial inclusion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP客户端API在Java 9中被孵化。本质上，这意味着这个API不是Java SE的一部分。它定义在`jdk.incubator.httpclient`包中。孵化特性应该明确添加到项目的类路径中。Oracle通过发布孵化特性来允许开发者使用和实验它们，并提供反馈，这决定了HTTP客户端API的命运。在未来的Java版本中，孵化API和特性要么作为完整功能包含，要么完全取消。没有部分包含。
- en: Just in case you need a quick refresher on HTTP, we will provide one here.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要快速回顾一下HTTP，我们在这里提供。
- en: What can you do with HTTP?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以用HTTP做什么？
- en: HTTP is a protocol to transfer hypertext (remember `<html>`?) on the **World
    Wide Web** (**WWW**). If you have used a web browser to access any website (chances
    are that you have), then you've already used HTTP. Your web browser works as a
    client on your system, requesting access to resources, such as web pages or files,
    over the network. Your web browser uses HTTP to send the request to the server.
    The requested resources are transferred from the server to the client, using the
    HTTP protocol.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种在**万维网**（**WWW**）上传输超文本（记得`<html>`吗？）的协议。如果你已经使用网页浏览器访问过任何网站（可能性很大），那么你已经使用了HTTP。你的网页浏览器作为系统上的客户端工作，通过网络请求访问资源，如网页或文件。你的网页浏览器使用HTTP将请求发送到服务器。请求的资源使用HTTP协议从服务器传输到客户端。
- en: 'The most common HTTP operations are `GET`, `POST`, `PUT`, and `DELETE`. Here
    are a few quick examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的HTTP操作是`GET`、`POST`、`PUT`和`DELETE`。以下是一些快速示例：
- en: Imagine registration on a website; you fill in your details and submit them.
    This is a `POST` request, in which the form values are not appended to the URI.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象一下在网站上注册的过程；你填写你的详细信息并提交它们。这是一个`POST`请求，其中表单值不会附加到URI上。
- en: Now, imagine bookmarking the details page of your favorite book in an online
    portal (say, [https://www.amazon.co.uk/](https://www.amazon.co.uk/)). You'll notice
    a set of variable names and values appended to the URI (separated by `&`) following
    the question mark (`?`). There's an example at [https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=mala+oca+8](https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=mala+oca+8).
    This is a `GET` request.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，想象一下在在线门户（比如 [https://www.amazon.co.uk/](https://www.amazon.co.uk/)）中为您最喜欢的书的详情页面设置书签。您会注意到在问号（`?`）之后跟随的
    URI 后附加了一系列变量名和值（由 `&` 分隔）。在 [https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=mala+oca+8](https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=mala+oca+8)
    有一个示例。这是一个 `GET` 请求。
- en: The `PUT` request is used to create or update an entity on a server, using a
    URI. The `PUT` request refers to the entity, whereas a `POST` request refers to
    a resource that will handle the submitted data.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` 请求用于在服务器上创建或更新一个实体，使用 URI。`PUT` 请求指的是实体，而 `POST` 请求指的是将处理提交数据的资源。'
- en: The `DELETE` request can delete an entity, using an identifying ID appended
    to a URI.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` 请求可以通过将标识 ID 添加到 URI 来删除实体。'
- en: Don't worry if you couldn't follow all of the HTTP operations, such as `GET`,
    `POST`, `PUT`, or `DELETE`. You'll be able to follow them as you progress with
    the chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法理解所有的 HTTP 操作，例如 `GET`、`POST`、`PUT` 或 `DELETE`，请不要担心。随着您对本章的深入，您将能够理解它们。
- en: In the same way that you can access resources over the network by using a web
    browser, you can use your Java code to access the same resources programmatically.
    There are multiple use cases; for example, imagine connecting to a website, downloading
    the latest news and simply listing it for the users of your application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您可以使用网页浏览器通过网络访问资源一样，您也可以使用您的 Java 代码以编程方式访问相同的资源。有多种用例；例如，想象一下连接到一个网站，下载最新的新闻，并将其简单地列出给您的应用程序用户。
- en: More information on HTTP/2 can be accessed at [https://tools.ietf.org/html/rfc7540](https://tools.ietf.org/html/rfc7540).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 HTTP/2 的信息可以在 [https://tools.ietf.org/html/rfc7540](https://tools.ietf.org/html/rfc7540)
    查找。
- en: The need for the HTTP Client API
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 客户端 API 的需求
- en: Until now, Java developers have been using the `HttpURLConnection` class to
    request HTTP resources over the network. However, it has multiple downsides, which
    led to the development of the HTTP Client API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Java 开发者一直在使用 `HttpURLConnection` 类通过网络请求 HTTP 资源。然而，它有多个缺点，这导致了 HTTP
    客户端 API 的发展。
- en: Introduced in JDK 1.1, the `HttpURLConnection` class was never designed to work
    in an asynchronous way; it works in a blocking mode only. This contrasts with
    the changing nature of the applications and the data that we work with today.
    The world is moving toward responsive programming, which deals with processing
    real-time data, and we can't afford to work with blocking communications or one
    request or response over a connection.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 1.1 中引入的 `HttpURLConnection` 类从未被设计为以异步方式工作；它仅以阻塞模式工作。这与今天我们处理的应用程序和数据的变化性质形成对比。世界正在向响应式编程迈进，它涉及处理实时数据，我们无法承担使用阻塞通信或通过连接发送一个请求或响应。
- en: The `HttpURLConnection` class is also difficult to use for the developers; part
    of its behavior is not documented. The base class of `HttpURLConnection`, that
    is, the `URLConnection` API, supports multiple protocols, most of which are not
    used now (for example, Gopher). This API doesn't support HTTP/2, since it was
    created way earlier than the formulation of HTTP/2.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpURLConnection` 类对于开发者来说也难以使用；其行为的一部分没有文档记录。`HttpURLConnection` 的基类，即 `URLConnection`
    API，支持多种协议，其中大多数现在不再使用（例如 Gopher）。此 API 不支持 HTTP/2，因为它是在 HTTP/2 制定之前很久就创建的。'
- en: Also, similar advanced APIs were available, such as Apache `HttpClient`, Eclipse
    Netty and Jetty, and others. It was high time that Oracle updated its own HTTP
    access API, keeping pace with the development and supporting its developers. One
    of the main goals of the HTTP Client is to have its memory consumption and performance
    on par with Apache `HttpClient`, Netty, and Jetty.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有类似的先进 API 可用，例如 Apache `HttpClient`、Eclipse Netty 和 Jetty 等。现在是时候 Oracle
    更新其自己的 HTTP 访问 API，以跟上发展并支持其开发者了。HTTP 客户端的主要目标之一是使其内存消耗和性能与 Apache `HttpClient`、Netty
    和 Jetty 相当。
- en: '`HttpURLConnection` can''t work in an asynchronous, non-blocking manner, which
    was one of the main reasons for the creation of the HTTP Client.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpURLConnection` 无法以异步、非阻塞的方式工作，这是创建 HTTP 客户端的主要原因之一。'
- en: Now that you know why you need the HTTP Client API, let's get to work with its
    usage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了为什么你需要 HTTP 客户端 API，让我们开始使用它。
- en: HTTP Client usage
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 客户端使用
- en: You can use the HTTP Client to access HTTP resources across the network, using
    either HTTP/1.1 or HTTP/2, sending a request and accepting responses asynchronously,
    in a non-blocking manner. It uses Reactive Streams to work asynchronously with
    requests and responses.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 HTTP 客户端通过网络访问 HTTP 资源，使用 HTTP/1.1 或 HTTP/2，异步发送请求并接受响应，以非阻塞方式。它使用响应式流以异步方式与请求和响应一起工作。
- en: It can also be used to send requests and receive responses synchronously.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用于同步发送请求并接收响应。
- en: 'The HTTP Client API consists of three main classes or interfaces:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端 API 由三个主要类或接口组成：
- en: The `HttpClient` class
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient` 类'
- en: The `HttpRequest` class
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpRequest` 类'
- en: The `HttpResponse` interface
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpResponse` 接口'
- en: The `HttpClient` class is used to send a request and retrieve the corresponding
    responses; `HttpRequest` encapsulates the details of the requested resource, including
    the request URI. The `HttpResponse` class encapsulates the response from the server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 类用于发送请求并检索相应的响应；`HttpRequest` 封装了请求资源的细节，包括请求 URI。`HttpResponse`
    类封装了来自服务器的响应。'
- en: In Java 11, the standardized HTTP Client is defined in the `java.net.http` module
    and package.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 11 中，标准化的 HTTP 客户端定义在 `java.net.http` 模块和包中。
- en: A basic example
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个基本示例
- en: Before diving into the details of the individual classes of the HTTP Client,
    I'm including a basic example to let you get a hang of sending a request to a
    server and processing the response using the HTTP Client. I'll add to this example
    as we move forward, covering `HttpClient`, `HttpRequest`, and `HttpResponse` in
    detail. This is to help you get the bigger picture and thendive into the details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到 HTTP 客户端各个类的细节之前，我包括了一个基本示例，让你熟悉发送请求到服务器并使用 HTTP 客户端处理响应。随着我们继续前进，我会添加到这个示例中，详细涵盖
    `HttpClient`、`HttpRequest` 和 `HttpResponse`。这是为了帮助你获得更大的图景，然后深入细节。
- en: 'The following example shows how to create a basic `HttpClient` instance, use
    it to access a URI encapsulated by `HttpRequest`, and process the response, accessible
    as a `HttpResponse` instance:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何创建一个基本的 `HttpClient` 实例，使用它来访问由 `HttpRequest` 封装的 URI，并处理响应，该响应作为 `HttpResponse`
    实例可访问：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, the `newHttpClient()` factory method returns a basic
    `HttpClient` instance, which can be used to send an HTTP request and receive its
    corresponding response. `HttpRequest` is created using the builder pattern by
    passing it the URI to connect with (which is the minimum requirement). The `HttpResponse`
    instance is not created explicitly by a developer but is received after a request
    is sent from `HttpClient` to a server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`newHttpClient()` 工厂方法返回一个基本的 `HttpClient` 实例，该实例可用于发送 HTTP 请求并接收其相应的响应。`HttpRequest`
    通过传递要连接的 URI（这是最低要求）使用构建器模式创建。`HttpResponse` 实例不是由开发者显式创建的，而是在从 `HttpClient` 发送请求到服务器后接收到的。
- en: The `send()` method sends the request synchronously and waits for the response.
    When the client receives the response code and headers, it invokes `BodyHandler` before
    the response body is received. Upon invocation, `BodyHandler` creates `BodySubscriber`
    (a Reactive Stream subscriber), which receives the streams of response data from
    the server and converts them to an appropriate higher-level Java type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()` 方法以同步方式发送请求并等待响应。当客户端收到响应代码和头信息时，在接收到响应体之前，它将调用 `BodyHandler`。在调用时，`BodyHandler`
    创建 `BodySubscriber`（一个响应式流订阅者），它接收来自服务器的响应数据流并将它们转换为适当的更高层次的 Java 类型。'
- en: If you didn't understand the preceding explanation completely, don't worry;
    I'll cover this in detail in the following sections.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完全理解前面的解释，不要担心；我将在以下部分中详细说明。
- en: The HTTP Client uses Reactive Streams (`BodyPublisher` and `BodySubscriber`)
    to send and receive data streams in an asynchronous and non-blocking way. Basic
    familiarity with Reactive Streams is recommended in order to understand how HTTP
    Client sends and receives data with them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端使用响应式流（`BodyPublisher` 和 `BodySubscriber`）以异步和非阻塞方式发送和接收数据流。建议对响应式流有基本了解，以便理解
    HTTP 客户端如何使用它们发送和接收数据。
- en: Let's dive into the details, starting with the `HttpClient` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入细节，从 `HttpClient` 类开始。
- en: The HttpClient class
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`HttpClient` 类'
- en: The `HttpClient` class is used to send requests and receive responses. It encapsulates
    details such as which version of the HTTP protocol to use, whether to follow redirects
    (if the resource you are trying to connect to has moved to another location),
    whether to use a proxy or an authenticator, and a few more things. The `HttpClient` class is
    used to configure a client state (an HTTP Client sends and receives data from
    a client to server). An `HttpClient` instance can be used to send multiple requests
    and receive their corresponding responses. However, once created, an `HttpClient`
    instance is immutable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 类用于发送请求并接收响应。它封装了诸如使用哪个版本的 HTTP 协议、是否遵循重定向（如果您尝试连接的资源已移动到另一个位置）、是否使用代理或验证器等细节。`HttpClient`
    类用于配置客户端状态（`HttpClient` 从客户端发送数据到服务器并接收数据）。`HttpClient` 实例可以用来发送多个请求并接收它们相应的响应。然而，一旦创建，`HttpClient`
    实例就是不可变的。'
- en: Creating an HttpClient instance
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 HttpClient 实例
- en: 'You can create an instance of `HttpClient` in two ways: by using its static
    `getHttpClient()` method, or by using the `newBuilder()` method (this follows
    the builder pattern).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式创建 `HttpClient` 实例：使用其静态 `getHttpClient()` 方法，或使用 `newBuilder()` 方法（这遵循构建器模式）。
- en: 'The static `getHttpClient()` method returns a `HttpClient` instance with basic
    or default settings, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `getHttpClient()` 方法返回具有基本或默认设置的 `HttpClient` 实例，如下所示：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To add custom settings, you can use its `newBuilder()` method, which follows
    the builder design pattern and calls relevant methods. Let''s start with a basic
    version, and then add to it. For example, you can use the following code to set
    the HTTP version as `2`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加自定义设置，您可以使用其 `newBuilder()` 方法，该方法遵循构建器设计模式并调用相关方法。让我们从一个基本版本开始，然后添加到它。例如，您可以使用以下代码将
    HTTP 版本设置为 `2`：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If HTTP/2 protocol is not supported, the `HttpClient` instance defaults to HTTP/1.1.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不支持 HTTP/2 协议，`HttpClient` 实例默认使用 HTTP/1.1。
- en: 'Often, when you access a resource using a web browser, you see a message stating
    that the resource has moved to another location and that you are being redirected
    to the new address. In this case, your web browser receives the new URI. You can
    accomplish the redirection to the new URI programmatically, by specifying so,
    through the method `followRedirects()`. Here''s an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您使用网络浏览器访问资源时，您会看到一个消息，表明资源已移动到另一个位置，并且您正在被重定向到新地址。在这种情况下，您的网络浏览器接收新的 URI。您可以通过指定
    `followRedirects()` 方法程序化地完成到新 URI 的重定向。以下是一个示例：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code calls `followRedirects()`, passing `Redirect.NORMAL`. Now, `Redirect`
    is a nested enum defined in the `HttpClient` class, with the following constant
    values:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用 `followRedirects()`，传递 `Redirect.NORMAL`。现在，`Redirect` 是在 `HttpClient`
    类中定义的一个嵌套枚举，具有以下常量值：
- en: '| **Enum Value** | **Description** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **枚举值** | **描述** |'
- en: '| `ALWAYS` | Always redirect |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `ALWAYS` | 总是重定向 |'
- en: '| `NEVER` | Never redirect |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `NEVER` | 永不重定向 |'
- en: '| `NORMAL` | Always redirect, except for HTTPS URLs to HTTP URLs |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `NORMAL` | 总是重定向，除了 HTTPS URL 重定向到 HTTP URL |'
- en: 'It''s common for a lot of websites to authenticate a user by its registered
    username and password. You can add the authentication values to `HttpClient` by
    using the `authenticator()` method. The following example uses the default authentication:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站通常通过注册的用户名和密码来验证用户。您可以通过使用 `authenticator()` 方法将身份验证值添加到 `HttpClient`。以下示例使用默认身份验证：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code uses custom values (`"admin"` and `"adminPassword"`) for
    authentication:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用自定义值（`"admin"` 和 `"adminPassword"`）进行身份验证：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code snippets in this section demonstrated how to create an instance of
    `HttpClient`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码片段展示了如何创建 `HttpClient` 的实例。
- en: Methods of the HttpClient class
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpClient 类的方法
- en: To request an HTTP resource over the network, you'll need to call either of
    the methods `send()` or `sendAsync()` on the `HttpClient` instance. The `send()`
    method sends a request and receives its response synchronously; it will block
    until these tasks are not complete. The method `sendAsync()` communicates with
    a server asynchronously; it sends a request and immediately returns with `CompletableFuture`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过网络请求 HTTP 资源，您需要在 `HttpClient` 实例上调用 `send()` 或 `sendAsync()` 方法之一。`send()`
    方法同步地发送请求并接收其响应；它将在这些任务完成之前阻塞。`sendAsync()` 方法异步地与服务器通信；它发送请求并立即返回 `CompletableFuture`。
- en: Before I include examples of the `send()` and `sendAsync()` methods, it is important
    to understand the other two classes: `HttpRequest` and `HttpResponse`. I'll cover
    these methods (`send()` and `sendAsync()`) in the section on `HttpResponse`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我包含 `send()` 和 `sendAsync()` 方法的示例之前，理解其他两个类（`HttpRequest` 和 `HttpResponse`）非常重要。我将在
    `HttpResponse` 部分介绍这些方法（`send()` 和 `sendAsync()`）。
- en: 'Here''s a quick list of the important methods of the `HttpClient` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 `HttpClient` 类的重要方法的快速列表：
- en: '| **Method Return Type** | **Method Name** | **Method Description** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **方法返回类型** | **方法名称** | **方法描述** |'
- en: '| **`abstract Optional<Authenticator>`** | **`authenticator()`** | Returns `Optional`
    containing the `Authenticator` instance set on this client |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **`抽象 Optional<Authenticator>`** | **`authenticator()`** | 返回包含在此客户端上设置的
    `Authenticator` 实例的 `Optional` |'
- en: '| `abstract Optional<Executor>` | `executor()` | Returns `Optional` containing
    this client''s `Executor` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 Optional<Executor>` | `executor()` | 返回包含此客户端的 `Executor` 的 `Optional`
    |'
- en: '| `abstract HttpClient.Redirect` | `followRedirects()` | Returns the `followRedirects`
    policy for this client |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 HttpClient.Redirect` | `followRedirects()` | 返回此客户端的 `followRedirects`
    策略 |'
- en: '| `static HttpClient.Builder` | `newBuilder()` | Creates a new `HttpClient`
    builder |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `静态 HttpClient.Builder` | `newBuilder()` | 创建一个新的 `HttpClient` 构建器 |'
- en: '| `static HttpClient` | `newHttpClient()` | Returns a new `HttpClient` with
    default settings |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `静态 HttpClient` | `newHttpClient()` | 返回一个具有默认设置的新的 `HttpClient` |'
- en: '| `WebSocket.Builder` | `newWebSocketBuilder()` | Creates a new `WebSocket`
    builder (optional operation) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `WebSocket.Builder` | `newWebSocketBuilder()` | 创建一个新的 `WebSocket` 构建器（可选操作）|'
- en: '| `abstract Optional<ProxySelector>` | `proxy()` | Returns `Optional` containing
    the `ProxySelector` instance supplied to this client |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 Optional<ProxySelector>` | `proxy()` | 返回包含此客户端提供的 `ProxySelector` 实例的
    `Optional` |'
- en: '| `abstract <T> HttpResponse<T>` | `send (HttpRequest request, HttpResponse.BodyHandler<T>
    responseBodyHandler)` | Sends the given request using this client, blocking, if
    necessary, to get the response |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 <T> HttpResponse<T>` | `send (HttpRequest request, HttpResponse.BodyHandler<T>
    responseBodyHandler)` | 使用此客户端发送给定的请求，如果需要，则阻塞以获取响应 |'
- en: '| `abstract <T> CompletableFuture<HttpResponse<T>>` | `sendAsync (HttpRequest
    request, HttpResponse.BodyHandler<T> responseBodyHandler)` | Sends the given request
    asynchronously, using this client with the given response body handler |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 <T> CompletableFuture<HttpResponse<T>>` | `sendAsync (HttpRequest request,
    HttpResponse.BodyHandler<T> responseBodyHandler)` | 以异步方式发送给定的请求，使用此客户端和给定的响应体处理器
    |'
- en: '| `abstract <T> CompletableFuture<HttpResponse<T>>` | `sendAsync (HttpRequest
    request, HttpResponse.BodyHandler<T> responseBodyHandler, HttpResponse.PushPromiseHandler<T>
    pushPromiseHandler)` | Sends the given request asynchronously, using this client
    with the given response body handler and push promise handler |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 <T> CompletableFuture<HttpResponse<T>>` | `sendAsync (HttpRequest request,
    HttpResponse.BodyHandler<T> responseBodyHandler, HttpResponse.PushPromiseHandler<T>
    pushPromiseHandler)` | 以异步方式发送给定的请求，使用此客户端和给定的响应体处理器以及推送承诺处理器 |'
- en: '| `abstract SSLContext` | `sslContext()` | Returns this client''s `SSLContext`
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 SSLContext` | `sslContext()` | 返回此客户端的 `SSLContext` |'
- en: '| `abstract SSLParameters` | `sslParameters()` | Returns a copy of this client''s
    `SSLParameters` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 SSLParameters` | `sslParameters()` | 返回此客户端的 `SSLParameters` 的副本 |'
- en: '| `abstract HttpClient.Version` | `version()` | Returns the preferred HTTP
    protocol version for this client |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `抽象 HttpClient.Version` | `version()` | 返回此客户端首选的 HTTP 协议版本 |'
- en: The next step is to work with the `HttpRequest` class to define the details
    of the request.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 `HttpRequest` 类来定义请求的详细信息。
- en: HttpRequest
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpRequest
- en: The `HttpRequest` class encapsulates the information required to be sent across
    the network to the server by the client. It includes the URI to connect with,
    headers with a set of variable names and their corresponding values, the timeout
    value (the time to wait before discarding the request), and the HTTP method to
    invoke (`PUT`, `POST`, `GET`, or `DELETE`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequest` 类封装了客户端需要通过网络发送到服务器的信息。它包括连接的 URI、带有一系列变量名及其对应值的头信息、超时值（丢弃请求前等待的时间）以及要调用的
    HTTP 方法（`PUT`、`POST`、`GET` 或 `DELETE`）。'
- en: Unlike the `HttpClient` class, `HttpRequest` doesn't give you a class instance
    with the default values, and it makes sense not to. Imagine the URI that the client
    would connect to if you don't specify it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `HttpClient` 类不同，`HttpRequest` 不提供具有默认值的类实例，这很有意义。想象一下，如果你不指定它，客户端将连接到的 URI。
- en: 'Let''s create an `HttpRequest` instance by calling its `newBuilder()` method
    and passing a URI to it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用其 `newBuilder()` 方法并传递一个 URI 来创建一个 `HttpRequest` 实例：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can add the timeout to your requests by using the `timeout()` method, as
    follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `timeout()` 方法将超时添加到你的请求中，如下所示：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A `request` instance must include the HTTP method to use. If no method is specified,
    a `GET` request is made, by default. In the preceding code, a `GET` request is
    made. Let's specify the HTTP method explicitly. The most common HTTP methods are
    `GET` and `POST`. The `DELETE` and `PUT` HTTP methods are also used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `request` 实例必须包含要使用的 HTTP 方法。如果没有指定方法，则默认执行 `GET` 请求。在上面的代码中，执行了一个 `GET`
    请求。让我们明确指定 HTTP 方法。最常用的 HTTP 方法是 `GET` 和 `POST`。`DELETE` 和 `PUT` HTTP 方法也被使用。
- en: 'The following example specifies the method as the `POST` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例指定了方法为 `POST` 方法：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `POST` method requires you to pass an instance of the `BodyProcessor` class.
    For a `POST` request that doesn''t require a body, you can pass `HttpRequest.noBody()`.
    You can use multiple sources, such as a string, `InputStream`, byte array, or
    file, and pass it to the `POST` method. Here''s an example that passes a file
    to the `POST` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 方法要求你传递 `BodyProcessor` 类的实例。对于不需要正文的 `POST` 请求，你可以传递 `HttpRequest.noBody()`。你可以使用多个来源，例如字符串、`InputStream`、字节数组或文件，并将其传递给
    `POST` 方法。以下是一个将文件传递给 `POST` 方法的示例：'
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following example passes a string to the `POST()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将一个字符串传递给 `POST()` 方法：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Imagine that you are working with an application that deals with buying shares
    when their prices rise or fall above or below a threshold. Here's some good news
    for you. `BodyProcessor` is a Reactive Stream publisher; you can deal with real-time
    data (such as stock prices) with controlled back pressure by using it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在处理一个应用程序，该应用程序在股票价格上升或下降到或低于某个阈值时购买股票。对你来说这是个好消息。`BodyProcessor` 是一个响应式流发布者；你可以通过使用它来处理实时数据（如股票价格），并通过控制背压来处理。
- en: '`BodyProcessor` defines convenient methods, such as `fromFile()`, `fromString()`,
    `fromInputStream()`, and `fromByteArray()`, to pass varied values conveniently.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`BodyProcessor` 定义了方便的方法，例如 `fromFile()`、`fromString()`、`fromInputStream()`
    和 `fromByteArray()`，以便方便地传递各种值。'
- en: 'Another frequently used method is `header()`, which specifies the contents
    of the request. Here''s an example, which specifies the contents of `request`
    as `text/plain`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常用的方法是 `header()`，它用于指定请求的内容。以下是一个示例，它将 `request` 的内容指定为 `text/plain`：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s a list of the important methods of the `HttpClient` class :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `HttpClient` 类的重要方法的列表：
- en: '| Method Return Type | Method Name | Method Description |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 方法 返回类型 | 方法名称 | 方法描述 |'
- en: '| `abstract Optional<HttpRequest.BodyPublisher>` | `bodyPublisher()` | Returns
    `Optional` containing the `HttpRequest.BodyPublisher` instance set on this request
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `abstract Optional<HttpRequest.BodyPublisher>` | `bodyPublisher()` | 返回包含在此请求上设置的
    `HttpRequest.BodyPublisher` 实例的 `Optional` |'
- en: '| `abstract boolean` | `expectContinue()` | Returns the requests to continue
    setting |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `abstract boolean` | `expectContinue()` | 返回请求继续设置 |'
- en: '| `abstract HttpHeaders` | `headers()` | The (user-accessible) request headers
    that this request was (or will be) sent with |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `abstract HttpHeaders` | `headers()` | 返回此请求（或将要发送的）请求头（用户可访问的） |'
- en: '| `abstract String` | `method()` | Returns the request method for this request
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `abstract String` | `method()` | 返回此请求的请求方法 |'
- en: '| `static HttpRequest.Builder` | `newBuilder()` | Creates an `HttpRequest`
    builder |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `static HttpRequest.Builder` | `newBuilder()` | 创建 `HttpRequest` 构建器 |'
- en: '| `static HttpRequest.Builder` | `newBuilder (URI uri)` | Creates an `HttpRequest`
    builder with the given URI |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `static HttpRequest.Builder` | `newBuilder (URI uri)` | 使用给定的 URI 创建 `HttpRequest`
    构建器 |'
- en: '| `abstract Optional<Duration>` | `timeout()` | Returns `Optional` containing
    this request''s timeout duration |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `abstract Optional<Duration>` | `timeout()` | 返回包含此请求的超时持续时间的 `Optional`
    |'
- en: '| `abstract URI` | `uri()` | Returns this request''s URI |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `abstract URI` | `uri()` | 返回此请求的 URI |'
- en: '| `abstract Optional<HttpClient.Version>` | `version()` | Returns `Optional`
    containing the HTTP protocol version that will be requested for this `HttpRequest`
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `abstract Optional<HttpClient.Version>` | `version()` | 返回包含将为此 `HttpRequest`
    请求的 HTTP 协议版本的 `Optional` |'
- en: Unlike the `HttpClient` and `HttpRequest` classes, you don't create instances
    of the `HttpResponse` class. Let's look at how you can instantiate it in the next
    section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `HttpClient` 和 `HttpRequest` 类不同，你不需要创建 `HttpResponse` 类的实例。让我们在下一节中看看如何实例化它。
- en: HttpResponse
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpResponse
- en: When you send an `HttpRequest` instance using an `HttpClient` instance, you
    receive `HttpResponse`. Upon sending an HTTP request, a server typically returns
    the status code of the response, the response header, and the response body.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `HttpClient` 实例发送 `HttpRequest` 实例时，您会收到 `HttpResponse`。在发送 HTTP 请求后，服务器通常会返回响应的状态码、响应头和响应正文。
- en: So, when can you access the response body? It depends on the `BodyHandler` that
    you specify to be used, when you send the request using the `HttpClient` `send()`
    or `sendAsync()` methods. Depending on the specified `BodyHandler`, you might
    be able to access the response body after the response status code and header
    are available (and before the response body is made available).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您何时可以访问响应正文？这取决于您在发送请求时指定的 `BodyHandler`，使用 `HttpClient` 的 `send()` 或 `sendAsync()`
    方法。根据指定的 `BodyHandler`，您可能在响应状态码和头信息可用后（在响应正文可用之前）能够访问响应正文。
- en: 'Let''s revisit the first example from this chapter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾本章的第一个示例：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, the `send()` method specifies `BodyHandler` as `BodyHandlers.ofString()`.
    It converts the received response body bytes to a high-level Java type: string.
    You can also use `BodyHandlers.ofFile()`, `BodyHandlers.ofInputStream()`, or `BodyHandlers.discard()`
    to save the response to a file, use the response as an input stream, or discard
    it.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`send()` 方法将 `BodyHandler` 指定为 `BodyHandlers.ofString()`。它将接收到的响应正文字节转换为高级
    Java 类型：字符串。您还可以使用 `BodyHandlers.ofFile()`、`BodyHandlers.ofInputStream()` 或 `BodyHandlers.discard()`
    将响应保存到文件、将响应用作输入流或丢弃它。
- en: '`BodyHandler` is a static interface defined within the `HttpResponse` interface. `HttpResponse`
    also defines a static class, `BodyHandler`, which defines a varied and useful
    implementation of the `BodyHandler` interface. For example, you could use `BodyHandlers.ofFile()`
    to write the received response to the specified file. Behind the scenes, `BodyHandler`
    uses `BodySubscriber` (a Reactive Stream), which subscribes to the response bytes
    from the server.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`BodyHandler` 是在 `HttpResponse` 接口中定义的静态接口。`HttpResponse` 还定义了一个静态类，`BodyHandler`，它定义了
    `BodyHandler` 接口的多种有用实现。例如，您可以使用 `BodyHandlers.ofFile()` 将接收到的响应写入指定的文件。幕后，`BodyHandler`
    使用 `BodySubscriber`（一个响应式流），它订阅来自服务器的响应字节。'
- en: The convenient static methods of `BodyHandlers` (`ofFile()`, `ofString()`, `ofInputStream()`,
    and `discard()`) let you work with a reactive data stream: `BodySubscriber`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`BodyHandlers` 的便捷静态方法（`ofFile()`、`ofString()`、`ofInputStream()` 和 `discard()`）让您可以与响应式数据流：`BodySubscriber`
    一起工作。'
- en: 'Here''s a list of the important methods of the `HttpResponse` interface:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `HttpResponse` 接口的重要方法列表：
- en: '| **Method Return Type** | **Method Name** | **Method** **Description** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **方法返回类型** | **方法名称** | **方法** **描述** |'
- en: '| `T` | `body()` | Returns the body |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `T` | `body()` | 返回正文 |'
- en: '| `HttpHeaders` | `headers()` | Returns the received response headers |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `HttpHeaders` | `headers()` | 返回接收到的响应头 |'
- en: '| `Optional<HttpResponse<T>>` | `previousResponse()` | Returns `Optional` containing
    the previous intermediate response, if one was received |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `Optional<HttpResponse<T>>` | `previousResponse()` | 返回包含前一个中间响应的 `Optional`，如果已接收
    |'
- en: '| `HttpRequest` | `request()` | Returns the `HttpRequest` instance corresponding
    to this response |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `HttpRequest` | `request()` | 返回与该响应对应的 `HttpRequest` 实例 |'
- en: '| `Optional<SSLSession>` | `sslSession()` | Returns `Optional` containing the
    `SSLSession` instance in effect for this response |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Optional<SSLSession>` | `sslSession()` | 返回包含此响应中有效 `SSLSession` 实例的 `Optional`
    |'
- en: '| `int` | `statusCode()` | Returns the status code for this response |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `statusCode()` | 返回此响应的状态码 |'
- en: '| `URI` | `uri()` | Returns the URI that the response was received from |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `URI` | `uri()` | 返回接收响应的 URI |'
- en: '| `HttpClient.Version` | `version()` | Returns the HTTP protocol version that
    was used for this response |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `HttpClient.Version` | `version()` | 返回用于此响应的 HTTP 协议版本 |'
- en: Let's work with some examples.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些示例。
- en: Some examples
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些示例
- en: What happens when you connect with a web application or web service using HTTP?
    The server can return text or data in multiple formats, including HTML, JSON,
    XML, binary, and many others. Also, the language or framework used to write the
    server-side application or service doesn't matter. For instance, a web application
    or service that you connect with might be written using PHP, Node, Spring, C#,
    Ruby on Rails, or others.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 HTTP 连接到网络应用程序或网络服务时会发生什么？服务器可以以多种格式返回文本或数据，包括 HTML、JSON、XML、二进制等。此外，编写服务器端应用程序或服务的语言或框架无关紧要。例如，您连接到的网络应用程序或服务可能使用
    PHP、Node、Spring、C#、Ruby on Rails 或其他语言编写。
- en: Let's work with some simple use cases, such as connecting to a web server using
    `GET` or `POST` requests, synchronously or asynchronously, submitting request
    data, and receiving the response and storing it using multiple formats.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理一些简单的用例，例如使用 `GET` 或 `POST` 请求连接到网络服务器，同步或异步地提交请求数据，并使用多种格式接收响应并存储。
- en: Accessing HTML pages using synchronous GET
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用同步 GET 访问 HTML 页面
- en: '`HttpClient` can receive a response from a server in either a synchronous or
    asynchronous manner. To receive a response synchronously, use the `HttpClient` method, `send()`.
    This request will block the thread until the response is completely received.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 可以以同步或异步的方式从服务器接收响应。要同步接收响应，请使用 `HttpClient` 的 `send()` 方法。此请求将阻塞线程，直到完全接收到响应。'
- en: 'The following code connects to Oracle''s web server that hosts the API documentation
    of the `HttpClient` class, using a `GET` request sent synchronously:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用同步发送 `GET` 请求连接到托管 `HttpClient` 类 API 文档的 Oracle 网络服务器：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code generates a lot of text. The following are just a few initial
    lines from the output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码生成了大量文本。以下只是输出的一小部分初始行：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code receives the HTML data as a string since it passes `BodyHandlers.ofString()`
    to the `send()` method. The variable used for the reception of this response is
    the `HttpResponse<String>` instance that matches with the response body subscriber
    (`BodyHandlers.ofString()`) used to process the response body bytes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码通过将 `BodyHandlers.ofString()` 传递给 `send()` 方法，将 HTML 数据作为字符串接收。用于接收此响应的变量是
    `HttpResponse<String>` 实例，它与用于处理响应体字节的响应体订阅者 (`BodyHandlers.ofString()`) 匹配。
- en: 'Let''s see what happens if we store the response from the preceding request
    as a `.html` file. Here''s the modified code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们将前一个请求的响应存储为 `.html` 文件会发生什么。以下是修改后的代码：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, the content of `HttpClient.html` is the same as the text
    that is sent to the console in the previous example. In this example, the response
    body bytes are written to a file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码中，`HttpClient.html` 的内容与之前示例中发送到控制台的文字相同。在这个例子中，响应体字节被写入到文件中。
- en: Since the file is saved as a `.html` file, you can view it in your web browser.
    However, the display of this file won't match with the display of the hosted `HttpClient`
    class, because your local `.html` file can't access `.css` or other hosted styles
    used by `HttpClient.html`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件保存为 `.html` 格式，您可以在您的网页浏览器中查看它。然而，此文件的显示效果将与托管 `HttpClient` 类的显示效果不匹配，因为您的本地
    `.html` 文件无法访问 `HttpClient.html` 所使用的 `.css` 或其他托管样式。
- en: 'The following screenshot compares the rendering of the local and hosted `HttpClient.html`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图比较了本地和托管 `HttpClient.html` 的渲染效果：
- en: '![](img/42d3c4c3-6578-4782-b53d-493b24f16031.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42d3c4c3-6578-4782-b53d-493b24f16031.png)'
- en: Let's modify the preceding example to receive the response asynchronously.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的示例以异步接收响应。
- en: Accessing HTML pages using asynchronous GET
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步 GET 访问 HTML 页面
- en: To receive a response asynchronously, you can use the `HttpClient` `sendAsync()`
    method. This request will immediately return `CompletableFuture`. You can call
    the `get()` method on `CompletableFuture` to retrieve the response.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要异步接收响应，您可以使用 `HttpClient` 的 `sendAsync()` 方法。此请求将立即返回 `CompletableFuture`。您可以在
    `CompletableFuture` 上调用 `get()` 方法来检索响应。
- en: 'Let''s modify the example used in the preceding section to receive the response
    (HTML text) in a file in an asynchronous manner:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一节中使用的示例，以异步方式将响应（HTML 文本）存储到文件中：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`BodyHandlers.ofFile()` is an implementation of the `BodyHandler` interface,
    which uses `BodySubscriber` (a Reactive Stream) to subscribe to the body response
    bytes. Upon receiving the response body, it writes it to the specified file.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`BodyHandlers.ofFile()` 是 `BodyHandler` 接口的一个实现，它使用 `BodySubscriber`（一个响应式流）来订阅响应体字节。在接收到响应体后，它将内容写入指定的文件。'
- en: With the HTTP `GET` request, you can also include a set of parameter names and
    their values as a part of the URI. For example, by defining the URI as `http://www.eJavaGuru.com/Java11.html?name="Mala"`,
    a client can pass the `Mala` value to the parameter name.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTP `GET` 请求，你还可以将一组参数名称及其值作为 URI 的一部分包含在内。例如，通过将 URI 定义为 `http://www.eJavaGuru.com/Java11.html?name="Mala"`，客户端可以将
    `Mala` 值传递给参数名称。
- en: Downloading multiple hosted image files
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载多个托管图像文件
- en: Imagine that you want to download multiple hosted images files without using
    an FTP client (or similar applications). Don't worry; you can do so by using the
    HTTP Client, either synchronously or asynchronously.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想下载多个托管图像文件，而不使用 FTP 客户端（或类似的应用程序）。别担心；你可以通过使用 HTTP 客户端，无论是同步还是异步地做到这一点。
- en: The code to do so is similar to what you saw in the preceding section; just
    save the response body bytes to a file with an appropriate file extension.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一功能，代码与上一节中看到的大致相同；只需将响应体字节保存到具有适当文件扩展名的文件中。
- en: 'The following code downloads three hosted images from eJavaGuru ([http://ejavaguru.com/](http://ejavaguru.com/))
    to the same folder as your source code file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从 eJavaGuru ([http://ejavaguru.com/](http://ejavaguru.com/)) 下载三个托管图像到与你的源代码文件相同的文件夹：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code uses the same `HttpClient` instance, `client`, to download
    multiple hosted images, by sending multiple asynchronous requests to the server.
    The `URI` instance to the images is stored in a list of URIs: `imageURIs`. This
    list is then used to create multiple `HttpRequest` instances: `imgDwnldRequests`.
    Then, the code calls the `sendAsync()` method on the client, sending the requests
    asynchronously.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用相同的 `HttpClient` 实例，`client`，通过向服务器发送多个异步请求来下载多个托管图像。图像的 `URI` 实例存储在
    URI 列表 `imageURIs` 中。然后，使用此列表创建多个 `HttpRequest` 实例：`imgDwnldRequests`。然后，代码在客户端上调用
    `sendAsync()` 方法，以异步方式发送请求。
- en: As stated in the previous example, `BodyHandlers.ofFile()` creates an implementation
    of `BodyHandler`, which creates and subscribes to `BodySubscriber`. `BodySubscriber`
    is a Reactive Stream subscriber that receives the response body from the server
    with non-blocking back pressure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所述，`BodyHandlers.ofFile()` 创建了一个 `BodyHandler` 的实现，该实现创建并订阅 `BodySubscriber`。`BodySubscriber`
    是一个反应式流订阅者，它以非阻塞背压从服务器接收响应体。
- en: Posting form details
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布表单详细信息
- en: 'Imagine that you want to post the details of a form to a web application or
    web service programmatically. You can do so by sending a `POST` request, using
    the HTTP Client API. The following code uses the `send()` method from `HttpClient` to
    post a set of parameter names and values to a server. The parameter names and
    their values are stored as a `String` value:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想以编程方式将表单的详细信息发布到 Web 应用程序或 Web 服务。你可以通过发送 `POST` 请求，使用 HTTP 客户端 API 来做到这一点。以下代码使用
    `HttpClient` 的 `send()` 方法将一组参数名称和值发布到服务器。参数名称及其值存储为 `String` 值：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, the `HttpRequest` builder includes the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`HttpRequest` 构建器包括以下代码：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `BodyPublishers` class defines common implementations of `BodyPublisher`,
    which is a Reactive Stream to publish request body bytes to the server. `BodyPublishers`
    defines static methods as `ofString`, `ofFile`, `ofInputStream`, and `ofByteArray` to
    publish a request body from `String`, file, or `InputStream`, converting high-level
    Java types into a flow of data to be sent as a request body.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`BodyPublishers` 类定义了 `BodyPublisher` 的常见实现，`BodyPublisher` 是一个反应式流，用于将请求体字节发布到服务器。`BodyPublishers`
    定义了静态方法 `ofString`、`ofFile`、`ofInputStream` 和 `ofByteArray`，用于从 `String`、文件或 `InputStream`
    发布请求体，将高级 Java 类型转换为要作为请求体发送的数据流。'
- en: In this example, the `POST` data is stored in a string, `postData`, which is
    sent with the request to the server. In this case, I don't wish to process the
    received response from the server, so I use `BodyHandlers.discarding()` while
    accessing the response.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`POST` 数据存储在字符串 `postData` 中，该字符串与请求一起发送到服务器。在这种情况下，我不想处理从服务器接收到的响应，因此在访问响应时使用
    `BodyHandlers.discarding()`。
- en: If you remember, all of the previous examples in this chapter used a Reactive
    Stream to receive the response body bytes from the server in a non-blocking and
    asynchronous manner. So, the HTTP Client enables you to send a request and receive
    responses to and from the server, using Reactive Streams.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，本章中所有之前的示例都使用反应式流以非阻塞和异步方式从服务器接收响应体字节。因此，HTTP 客户端使你能够发送请求并从服务器接收响应，使用反应式流。
- en: The HTTP Client uses `BodySubscriber` and `BodyPublishers` to send and receive
    the response to and from the server asynchronously, in a non-blocking manner.
    The `BodyPublisher` interface extends the `Flow.Publisher` interface. The `BodySubcriber` interface extends
    the `Flow.Subscriber` interface.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端使用 `BodySubscriber` 和 `BodyPublishers` 以非阻塞方式异步地发送和接收来自服务器的响应。`BodyPublisher`
    接口扩展了 `Flow.Publisher` 接口。`BodySubscriber` 接口扩展了 `Flow.Subscriber` 接口。
- en: When you work with the HTTP Client, you can also receive the response as a JSON,
    XML, or other data type. Similarly, you can also send multiple data types to a
    server. You can use the appropriate API from Java SE or another vendor to convert
    from one format to another.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 HTTP 客户端工作时，您还可以以 JSON、XML 或其他数据类型接收响应。同样，您也可以向服务器发送多种数据类型。您可以使用 Java SE
    或其他供应商的适当 API 将一种格式转换为另一种格式。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Incubated in Java 9, the HTTP Client was standardized in Java 11\. This chapter
    started with an introduction to the HTTP Client API, including the factors that
    led to its creation. Today's web applications and services should be responsive,
    supporting asynchronous, non-blocking data transfers. The HTTP Client uses Reactive
    Streams to achieve these goals.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端是在 Java 9 中孵化出来的，并在 Java 11 中标准化。本章从介绍 HTTP 客户端 API 开始，包括导致其创建的因素。今天的网络应用程序和服务应该是响应式的，支持异步、非阻塞的数据传输。HTTP
    客户端使用反应式流来实现这些目标。
- en: 'The HTTP Client can be used to access HTTP resources across the network, using
    either HTTP/1.1 or HTTP/2, in both synchronous and non-synchronous manners. The
    HTTP Client API consists of three main classes or interfaces: the `HttpClient` class, 
    the `HttpRequest` class, and the `HttpResponse` interface. The `HttpClient` class
    is used to send a request and retrieve the corresponding responses; `HttpRequest`
    encapsulates the details of the requested resource, including the request URI.
    The `HttpResponse` class encapsulates the response from the server.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端可用于通过网络访问 HTTP 资源，使用 HTTP/1.1 或 HTTP/2，以同步和非同步的方式进行。HTTP 客户端 API 由三个主要类或接口组成：`HttpClient`
    类、`HttpRequest` 类和 `HttpResponse` 接口。`HttpClient` 类用于发送请求并检索相应的响应；`HttpRequest`
    封装了请求资源的详细信息，包括请求 URI。`HttpResponse` 类封装了来自服务器的响应。
- en: Under the hood, the HTTP Client uses `BodySubscriber` and `BodyPublishers` to
    send and receive the response to and from the server asynchronously, in a non-blocking
    manner. The `BodyPublisher` interface extends the `Flow.Publisher` interface. The
    `BodySubcriber` interface extends the `Flow.Subscriber` interface.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，HTTP 客户端使用 `BodySubscriber` 和 `BodyPublishers` 以非阻塞方式异步地发送和接收来自服务器的响应。`BodyPublisher`
    接口扩展了 `Flow.Publisher` 接口。`BodySubscriber` 接口扩展了 `Flow.Subscriber` 接口。
- en: The chapter included multiple examples to demonstrate common use cases.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含多个示例，以演示常见用例。
- en: A lot of interesting language additions and modifications are in progress as
    a part of Project Amber at the Oracle Corporation. We'll get started with exploring
    that in the next chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在甲骨文公司的 Project Amber 项目中正在进行许多有趣的语言添加和修改。我们将在下一章开始探索这一点。
