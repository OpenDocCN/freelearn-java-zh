- en: The HTTP Client API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the HTTP Client API, your Java code can request HTTP resources over the
    network, using the HTTP/2 protocol, in a non-blocking and asynchronous way. It
    brings major improvements to the existing `HttpURLConnection` class, which was
    added to Java in Version 1.1, and only works in a blocking and synchronous way.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Client was incubated in Java 9, with multiple modifications in Java
    10, and was standardized in Java 11\. It resides in the `java.net.http` package
    and module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the HTTP Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending requests synchronously and asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting response bytes to high-level formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Reactive Streams to handle HTTP requests and responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BodyHandler`, `BodyPublisher`, and `BodySubscriber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this chapter will use the standardized HTTP Client API classes from
    Java 11\. If you are using the incubated HTTP Client from the previous Java versions,
    such as 9 or 10, all of the code in this chapter won't work as specified. A lot
    of method names have changed.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the details, let's get a hang of the problem that led to
    the introduction of this new API for requesting HTTP resources.
  prefs: []
  type: TYPE_NORMAL
- en: A quick flashback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP Client API was incubated in Java 9\. Essentially, this means that this
    API wasn't a part of the Java SE. It was defined in the `jdk.incubator.httpclient` package. The
    incubated features should explicitly be added to a project's classpath. The incubated
    features are released by Oracle to enable developers to use and experiment with
    them and provide their feedback, which decides the fate of HTTP Client API. In
    a future Java version, incubated APIs and features are either included as a full
    feature or just dropped off. There is no partial inclusion.
  prefs: []
  type: TYPE_NORMAL
- en: Just in case you need a quick refresher on HTTP, we will provide one here.
  prefs: []
  type: TYPE_NORMAL
- en: What can you do with HTTP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is a protocol to transfer hypertext (remember `<html>`?) on the **World
    Wide Web** (**WWW**). If you have used a web browser to access any website (chances
    are that you have), then you've already used HTTP. Your web browser works as a
    client on your system, requesting access to resources, such as web pages or files,
    over the network. Your web browser uses HTTP to send the request to the server.
    The requested resources are transferred from the server to the client, using the
    HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common HTTP operations are `GET`, `POST`, `PUT`, and `DELETE`. Here
    are a few quick examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine registration on a website; you fill in your details and submit them.
    This is a `POST` request, in which the form values are not appended to the URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, imagine bookmarking the details page of your favorite book in an online
    portal (say, [https://www.amazon.co.uk/](https://www.amazon.co.uk/)). You'll notice
    a set of variable names and values appended to the URI (separated by `&`) following
    the question mark (`?`). There's an example at [https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=mala+oca+8](https://www.amazon.co.uk/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=mala+oca+8).
    This is a `GET` request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PUT` request is used to create or update an entity on a server, using a
    URI. The `PUT` request refers to the entity, whereas a `POST` request refers to
    a resource that will handle the submitted data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DELETE` request can delete an entity, using an identifying ID appended
    to a URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't worry if you couldn't follow all of the HTTP operations, such as `GET`,
    `POST`, `PUT`, or `DELETE`. You'll be able to follow them as you progress with
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that you can access resources over the network by using a web
    browser, you can use your Java code to access the same resources programmatically.
    There are multiple use cases; for example, imagine connecting to a website, downloading
    the latest news and simply listing it for the users of your application.
  prefs: []
  type: TYPE_NORMAL
- en: More information on HTTP/2 can be accessed at [https://tools.ietf.org/html/rfc7540](https://tools.ietf.org/html/rfc7540).
  prefs: []
  type: TYPE_NORMAL
- en: The need for the HTTP Client API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, Java developers have been using the `HttpURLConnection` class to
    request HTTP resources over the network. However, it has multiple downsides, which
    led to the development of the HTTP Client API.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced in JDK 1.1, the `HttpURLConnection` class was never designed to work
    in an asynchronous way; it works in a blocking mode only. This contrasts with
    the changing nature of the applications and the data that we work with today.
    The world is moving toward responsive programming, which deals with processing
    real-time data, and we can't afford to work with blocking communications or one
    request or response over a connection.
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpURLConnection` class is also difficult to use for the developers; part
    of its behavior is not documented. The base class of `HttpURLConnection`, that
    is, the `URLConnection` API, supports multiple protocols, most of which are not
    used now (for example, Gopher). This API doesn't support HTTP/2, since it was
    created way earlier than the formulation of HTTP/2.
  prefs: []
  type: TYPE_NORMAL
- en: Also, similar advanced APIs were available, such as Apache `HttpClient`, Eclipse
    Netty and Jetty, and others. It was high time that Oracle updated its own HTTP
    access API, keeping pace with the development and supporting its developers. One
    of the main goals of the HTTP Client is to have its memory consumption and performance
    on par with Apache `HttpClient`, Netty, and Jetty.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpURLConnection` can''t work in an asynchronous, non-blocking manner, which
    was one of the main reasons for the creation of the HTTP Client.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know why you need the HTTP Client API, let's get to work with its
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Client usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the HTTP Client to access HTTP resources across the network, using
    either HTTP/1.1 or HTTP/2, sending a request and accepting responses asynchronously,
    in a non-blocking manner. It uses Reactive Streams to work asynchronously with
    requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: It can also be used to send requests and receive responses synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP Client API consists of three main classes or interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpClient` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HttpRequest` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HttpResponse` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HttpClient` class is used to send a request and retrieve the corresponding
    responses; `HttpRequest` encapsulates the details of the requested resource, including
    the request URI. The `HttpResponse` class encapsulates the response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 11, the standardized HTTP Client is defined in the `java.net.http` module
    and package.
  prefs: []
  type: TYPE_NORMAL
- en: A basic example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into the details of the individual classes of the HTTP Client,
    I'm including a basic example to let you get a hang of sending a request to a
    server and processing the response using the HTTP Client. I'll add to this example
    as we move forward, covering `HttpClient`, `HttpRequest`, and `HttpResponse` in
    detail. This is to help you get the bigger picture and thendive into the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to create a basic `HttpClient` instance, use
    it to access a URI encapsulated by `HttpRequest`, and process the response, accessible
    as a `HttpResponse` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `newHttpClient()` factory method returns a basic
    `HttpClient` instance, which can be used to send an HTTP request and receive its
    corresponding response. `HttpRequest` is created using the builder pattern by
    passing it the URI to connect with (which is the minimum requirement). The `HttpResponse`
    instance is not created explicitly by a developer but is received after a request
    is sent from `HttpClient` to a server.
  prefs: []
  type: TYPE_NORMAL
- en: The `send()` method sends the request synchronously and waits for the response.
    When the client receives the response code and headers, it invokes `BodyHandler` before
    the response body is received. Upon invocation, `BodyHandler` creates `BodySubscriber`
    (a Reactive Stream subscriber), which receives the streams of response data from
    the server and converts them to an appropriate higher-level Java type.
  prefs: []
  type: TYPE_NORMAL
- en: If you didn't understand the preceding explanation completely, don't worry;
    I'll cover this in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Client uses Reactive Streams (`BodyPublisher` and `BodySubscriber`)
    to send and receive data streams in an asynchronous and non-blocking way. Basic
    familiarity with Reactive Streams is recommended in order to understand how HTTP
    Client sends and receives data with them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into the details, starting with the `HttpClient` class.
  prefs: []
  type: TYPE_NORMAL
- en: The HttpClient class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HttpClient` class is used to send requests and receive responses. It encapsulates
    details such as which version of the HTTP protocol to use, whether to follow redirects
    (if the resource you are trying to connect to has moved to another location),
    whether to use a proxy or an authenticator, and a few more things. The `HttpClient` class is
    used to configure a client state (an HTTP Client sends and receives data from
    a client to server). An `HttpClient` instance can be used to send multiple requests
    and receive their corresponding responses. However, once created, an `HttpClient`
    instance is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HttpClient instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create an instance of `HttpClient` in two ways: by using its static
    `getHttpClient()` method, or by using the `newBuilder()` method (this follows
    the builder pattern).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The static `getHttpClient()` method returns a `HttpClient` instance with basic
    or default settings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To add custom settings, you can use its `newBuilder()` method, which follows
    the builder design pattern and calls relevant methods. Let''s start with a basic
    version, and then add to it. For example, you can use the following code to set
    the HTTP version as `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If HTTP/2 protocol is not supported, the `HttpClient` instance defaults to HTTP/1.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, when you access a resource using a web browser, you see a message stating
    that the resource has moved to another location and that you are being redirected
    to the new address. In this case, your web browser receives the new URI. You can
    accomplish the redirection to the new URI programmatically, by specifying so,
    through the method `followRedirects()`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code calls `followRedirects()`, passing `Redirect.NORMAL`. Now, `Redirect`
    is a nested enum defined in the `HttpClient` class, with the following constant
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Enum Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ALWAYS` | Always redirect |'
  prefs: []
  type: TYPE_TB
- en: '| `NEVER` | Never redirect |'
  prefs: []
  type: TYPE_TB
- en: '| `NORMAL` | Always redirect, except for HTTPS URLs to HTTP URLs |'
  prefs: []
  type: TYPE_TB
- en: 'It''s common for a lot of websites to authenticate a user by its registered
    username and password. You can add the authentication values to `HttpClient` by
    using the `authenticator()` method. The following example uses the default authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code uses custom values (`"admin"` and `"adminPassword"`) for
    authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code snippets in this section demonstrated how to create an instance of
    `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of the HttpClient class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To request an HTTP resource over the network, you'll need to call either of
    the methods `send()` or `sendAsync()` on the `HttpClient` instance. The `send()`
    method sends a request and receives its response synchronously; it will block
    until these tasks are not complete. The method `sendAsync()` communicates with
    a server asynchronously; it sends a request and immediately returns with `CompletableFuture`.
  prefs: []
  type: TYPE_NORMAL
- en: Before I include examples of the `send()` and `sendAsync()` methods, it is important
    to understand the other two classes: `HttpRequest` and `HttpResponse`. I'll cover
    these methods (`send()` and `sendAsync()`) in the section on `HttpResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick list of the important methods of the `HttpClient` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Return Type** | **Method Name** | **Method Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **`abstract Optional<Authenticator>`** | **`authenticator()`** | Returns `Optional`
    containing the `Authenticator` instance set on this client |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract Optional<Executor>` | `executor()` | Returns `Optional` containing
    this client''s `Executor` |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract HttpClient.Redirect` | `followRedirects()` | Returns the `followRedirects`
    policy for this client |'
  prefs: []
  type: TYPE_TB
- en: '| `static HttpClient.Builder` | `newBuilder()` | Creates a new `HttpClient`
    builder |'
  prefs: []
  type: TYPE_TB
- en: '| `static HttpClient` | `newHttpClient()` | Returns a new `HttpClient` with
    default settings |'
  prefs: []
  type: TYPE_TB
- en: '| `WebSocket.Builder` | `newWebSocketBuilder()` | Creates a new `WebSocket`
    builder (optional operation) |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract Optional<ProxySelector>` | `proxy()` | Returns `Optional` containing
    the `ProxySelector` instance supplied to this client |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract <T> HttpResponse<T>` | `send (HttpRequest request, HttpResponse.BodyHandler<T>
    responseBodyHandler)` | Sends the given request using this client, blocking, if
    necessary, to get the response |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract <T> CompletableFuture<HttpResponse<T>>` | `sendAsync (HttpRequest
    request, HttpResponse.BodyHandler<T> responseBodyHandler)` | Sends the given request
    asynchronously, using this client with the given response body handler |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract <T> CompletableFuture<HttpResponse<T>>` | `sendAsync (HttpRequest
    request, HttpResponse.BodyHandler<T> responseBodyHandler, HttpResponse.PushPromiseHandler<T>
    pushPromiseHandler)` | Sends the given request asynchronously, using this client
    with the given response body handler and push promise handler |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract SSLContext` | `sslContext()` | Returns this client''s `SSLContext`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract SSLParameters` | `sslParameters()` | Returns a copy of this client''s
    `SSLParameters` |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract HttpClient.Version` | `version()` | Returns the preferred HTTP
    protocol version for this client |'
  prefs: []
  type: TYPE_TB
- en: The next step is to work with the `HttpRequest` class to define the details
    of the request.
  prefs: []
  type: TYPE_NORMAL
- en: HttpRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HttpRequest` class encapsulates the information required to be sent across
    the network to the server by the client. It includes the URI to connect with,
    headers with a set of variable names and their corresponding values, the timeout
    value (the time to wait before discarding the request), and the HTTP method to
    invoke (`PUT`, `POST`, `GET`, or `DELETE`).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `HttpClient` class, `HttpRequest` doesn't give you a class instance
    with the default values, and it makes sense not to. Imagine the URI that the client
    would connect to if you don't specify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `HttpRequest` instance by calling its `newBuilder()` method
    and passing a URI to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add the timeout to your requests by using the `timeout()` method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A `request` instance must include the HTTP method to use. If no method is specified,
    a `GET` request is made, by default. In the preceding code, a `GET` request is
    made. Let's specify the HTTP method explicitly. The most common HTTP methods are
    `GET` and `POST`. The `DELETE` and `PUT` HTTP methods are also used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example specifies the method as the `POST` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `POST` method requires you to pass an instance of the `BodyProcessor` class.
    For a `POST` request that doesn''t require a body, you can pass `HttpRequest.noBody()`.
    You can use multiple sources, such as a string, `InputStream`, byte array, or
    file, and pass it to the `POST` method. Here''s an example that passes a file
    to the `POST` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example passes a string to the `POST()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Imagine that you are working with an application that deals with buying shares
    when their prices rise or fall above or below a threshold. Here's some good news
    for you. `BodyProcessor` is a Reactive Stream publisher; you can deal with real-time
    data (such as stock prices) with controlled back pressure by using it.
  prefs: []
  type: TYPE_NORMAL
- en: '`BodyProcessor` defines convenient methods, such as `fromFile()`, `fromString()`,
    `fromInputStream()`, and `fromByteArray()`, to pass varied values conveniently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another frequently used method is `header()`, which specifies the contents
    of the request. Here''s an example, which specifies the contents of `request`
    as `text/plain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a list of the important methods of the `HttpClient` class :'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method Return Type | Method Name | Method Description |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract Optional<HttpRequest.BodyPublisher>` | `bodyPublisher()` | Returns
    `Optional` containing the `HttpRequest.BodyPublisher` instance set on this request
    |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract boolean` | `expectContinue()` | Returns the requests to continue
    setting |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract HttpHeaders` | `headers()` | The (user-accessible) request headers
    that this request was (or will be) sent with |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract String` | `method()` | Returns the request method for this request
    |'
  prefs: []
  type: TYPE_TB
- en: '| `static HttpRequest.Builder` | `newBuilder()` | Creates an `HttpRequest`
    builder |'
  prefs: []
  type: TYPE_TB
- en: '| `static HttpRequest.Builder` | `newBuilder (URI uri)` | Creates an `HttpRequest`
    builder with the given URI |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract Optional<Duration>` | `timeout()` | Returns `Optional` containing
    this request''s timeout duration |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract URI` | `uri()` | Returns this request''s URI |'
  prefs: []
  type: TYPE_TB
- en: '| `abstract Optional<HttpClient.Version>` | `version()` | Returns `Optional`
    containing the HTTP protocol version that will be requested for this `HttpRequest`
    |'
  prefs: []
  type: TYPE_TB
- en: Unlike the `HttpClient` and `HttpRequest` classes, you don't create instances
    of the `HttpResponse` class. Let's look at how you can instantiate it in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: HttpResponse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you send an `HttpRequest` instance using an `HttpClient` instance, you
    receive `HttpResponse`. Upon sending an HTTP request, a server typically returns
    the status code of the response, the response header, and the response body.
  prefs: []
  type: TYPE_NORMAL
- en: So, when can you access the response body? It depends on the `BodyHandler` that
    you specify to be used, when you send the request using the `HttpClient` `send()`
    or `sendAsync()` methods. Depending on the specified `BodyHandler`, you might
    be able to access the response body after the response status code and header
    are available (and before the response body is made available).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the first example from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `send()` method specifies `BodyHandler` as `BodyHandlers.ofString()`.
    It converts the received response body bytes to a high-level Java type: string.
    You can also use `BodyHandlers.ofFile()`, `BodyHandlers.ofInputStream()`, or `BodyHandlers.discard()`
    to save the response to a file, use the response as an input stream, or discard
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BodyHandler` is a static interface defined within the `HttpResponse` interface. `HttpResponse`
    also defines a static class, `BodyHandler`, which defines a varied and useful
    implementation of the `BodyHandler` interface. For example, you could use `BodyHandlers.ofFile()`
    to write the received response to the specified file. Behind the scenes, `BodyHandler`
    uses `BodySubscriber` (a Reactive Stream), which subscribes to the response bytes
    from the server.'
  prefs: []
  type: TYPE_NORMAL
- en: The convenient static methods of `BodyHandlers` (`ofFile()`, `ofString()`, `ofInputStream()`,
    and `discard()`) let you work with a reactive data stream: `BodySubscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of the important methods of the `HttpResponse` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Return Type** | **Method Name** | **Method** **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | `body()` | Returns the body |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpHeaders` | `headers()` | Returns the received response headers |'
  prefs: []
  type: TYPE_TB
- en: '| `Optional<HttpResponse<T>>` | `previousResponse()` | Returns `Optional` containing
    the previous intermediate response, if one was received |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpRequest` | `request()` | Returns the `HttpRequest` instance corresponding
    to this response |'
  prefs: []
  type: TYPE_TB
- en: '| `Optional<SSLSession>` | `sslSession()` | Returns `Optional` containing the
    `SSLSession` instance in effect for this response |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `statusCode()` | Returns the status code for this response |'
  prefs: []
  type: TYPE_TB
- en: '| `URI` | `uri()` | Returns the URI that the response was received from |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpClient.Version` | `version()` | Returns the HTTP protocol version that
    was used for this response |'
  prefs: []
  type: TYPE_TB
- en: Let's work with some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens when you connect with a web application or web service using HTTP?
    The server can return text or data in multiple formats, including HTML, JSON,
    XML, binary, and many others. Also, the language or framework used to write the
    server-side application or service doesn't matter. For instance, a web application
    or service that you connect with might be written using PHP, Node, Spring, C#,
    Ruby on Rails, or others.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work with some simple use cases, such as connecting to a web server using
    `GET` or `POST` requests, synchronously or asynchronously, submitting request
    data, and receiving the response and storing it using multiple formats.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing HTML pages using synchronous GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HttpClient` can receive a response from a server in either a synchronous or
    asynchronous manner. To receive a response synchronously, use the `HttpClient` method, `send()`.
    This request will block the thread until the response is completely received.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code connects to Oracle''s web server that hosts the API documentation
    of the `HttpClient` class, using a `GET` request sent synchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates a lot of text. The following are just a few initial
    lines from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code receives the HTML data as a string since it passes `BodyHandlers.ofString()`
    to the `send()` method. The variable used for the reception of this response is
    the `HttpResponse<String>` instance that matches with the response body subscriber
    (`BodyHandlers.ofString()`) used to process the response body bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we store the response from the preceding request
    as a `.html` file. Here''s the modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the content of `HttpClient.html` is the same as the text
    that is sent to the console in the previous example. In this example, the response
    body bytes are written to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Since the file is saved as a `.html` file, you can view it in your web browser.
    However, the display of this file won't match with the display of the hosted `HttpClient`
    class, because your local `.html` file can't access `.css` or other hosted styles
    used by `HttpClient.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot compares the rendering of the local and hosted `HttpClient.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42d3c4c3-6578-4782-b53d-493b24f16031.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's modify the preceding example to receive the response asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing HTML pages using asynchronous GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To receive a response asynchronously, you can use the `HttpClient` `sendAsync()`
    method. This request will immediately return `CompletableFuture`. You can call
    the `get()` method on `CompletableFuture` to retrieve the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the example used in the preceding section to receive the response
    (HTML text) in a file in an asynchronous manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`BodyHandlers.ofFile()` is an implementation of the `BodyHandler` interface,
    which uses `BodySubscriber` (a Reactive Stream) to subscribe to the body response
    bytes. Upon receiving the response body, it writes it to the specified file.'
  prefs: []
  type: TYPE_NORMAL
- en: With the HTTP `GET` request, you can also include a set of parameter names and
    their values as a part of the URI. For example, by defining the URI as `http://www.eJavaGuru.com/Java11.html?name="Mala"`,
    a client can pass the `Mala` value to the parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading multiple hosted image files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you want to download multiple hosted images files without using
    an FTP client (or similar applications). Don't worry; you can do so by using the
    HTTP Client, either synchronously or asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The code to do so is similar to what you saw in the preceding section; just
    save the response body bytes to a file with an appropriate file extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code downloads three hosted images from eJavaGuru ([http://ejavaguru.com/](http://ejavaguru.com/))
    to the same folder as your source code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the same `HttpClient` instance, `client`, to download
    multiple hosted images, by sending multiple asynchronous requests to the server.
    The `URI` instance to the images is stored in a list of URIs: `imageURIs`. This
    list is then used to create multiple `HttpRequest` instances: `imgDwnldRequests`.
    Then, the code calls the `sendAsync()` method on the client, sending the requests
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the previous example, `BodyHandlers.ofFile()` creates an implementation
    of `BodyHandler`, which creates and subscribes to `BodySubscriber`. `BodySubscriber`
    is a Reactive Stream subscriber that receives the response body from the server
    with non-blocking back pressure.
  prefs: []
  type: TYPE_NORMAL
- en: Posting form details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you want to post the details of a form to a web application or
    web service programmatically. You can do so by sending a `POST` request, using
    the HTTP Client API. The following code uses the `send()` method from `HttpClient` to
    post a set of parameter names and values to a server. The parameter names and
    their values are stored as a `String` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `HttpRequest` builder includes the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `BodyPublishers` class defines common implementations of `BodyPublisher`,
    which is a Reactive Stream to publish request body bytes to the server. `BodyPublishers`
    defines static methods as `ofString`, `ofFile`, `ofInputStream`, and `ofByteArray` to
    publish a request body from `String`, file, or `InputStream`, converting high-level
    Java types into a flow of data to be sent as a request body.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `POST` data is stored in a string, `postData`, which is
    sent with the request to the server. In this case, I don't wish to process the
    received response from the server, so I use `BodyHandlers.discarding()` while
    accessing the response.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, all of the previous examples in this chapter used a Reactive
    Stream to receive the response body bytes from the server in a non-blocking and
    asynchronous manner. So, the HTTP Client enables you to send a request and receive
    responses to and from the server, using Reactive Streams.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Client uses `BodySubscriber` and `BodyPublishers` to send and receive
    the response to and from the server asynchronously, in a non-blocking manner.
    The `BodyPublisher` interface extends the `Flow.Publisher` interface. The `BodySubcriber` interface extends
    the `Flow.Subscriber` interface.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with the HTTP Client, you can also receive the response as a JSON,
    XML, or other data type. Similarly, you can also send multiple data types to a
    server. You can use the appropriate API from Java SE or another vendor to convert
    from one format to another.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incubated in Java 9, the HTTP Client was standardized in Java 11\. This chapter
    started with an introduction to the HTTP Client API, including the factors that
    led to its creation. Today's web applications and services should be responsive,
    supporting asynchronous, non-blocking data transfers. The HTTP Client uses Reactive
    Streams to achieve these goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP Client can be used to access HTTP resources across the network, using
    either HTTP/1.1 or HTTP/2, in both synchronous and non-synchronous manners. The
    HTTP Client API consists of three main classes or interfaces: the `HttpClient` class, 
    the `HttpRequest` class, and the `HttpResponse` interface. The `HttpClient` class
    is used to send a request and retrieve the corresponding responses; `HttpRequest`
    encapsulates the details of the requested resource, including the request URI.
    The `HttpResponse` class encapsulates the response from the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the HTTP Client uses `BodySubscriber` and `BodyPublishers` to
    send and receive the response to and from the server asynchronously, in a non-blocking
    manner. The `BodyPublisher` interface extends the `Flow.Publisher` interface. The
    `BodySubcriber` interface extends the `Flow.Subscriber` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter included multiple examples to demonstrate common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of interesting language additions and modifications are in progress as
    a part of Project Amber at the Oracle Corporation. We'll get started with exploring
    that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
