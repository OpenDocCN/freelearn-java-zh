<html><head></head><body>
		<div id="_idContainer051">
			<h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor097"/>5</h1>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor098"/>Building APIs with Spring</h1>
			<p>In the previous chapter, you learned about the concepts and advantages of PostgreSQL and set it up on your local machine using the installer or the Docker container. You know how to configure <strong class="bold">Spring Data Java Persistence API</strong> (<strong class="bold">Spring Data JPA</strong>) on our project and use its provided repositories to perform <strong class="bold">Create, Read, Update</strong>, and <strong class="bold">Delete</strong> (<strong class="bold">CRUD</strong>) operations on our database with less boilerplate code. Lastly, you have also learned to connect your application with PostgreSQL using the <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) driver and Spring <span class="No-Break">Data JPA.</span></p>
			<p>This chapter will create your Spring Boot <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) project; we will focus on coding, making our models, and adding controllers and services to develop our endpoints. We will also add <strong class="bold">Remote Dictionary Server</strong> (<strong class="bold">Redis</strong>) for caching to help improve our <span class="No-Break">application performance.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Starting <span class="No-Break">the server</span></li>
				<li><span class="No-Break">Adding models</span></li>
				<li><span class="No-Break">Writing services</span></li>
				<li><span class="No-Break">Adding controllers</span></li>
				<li>Adding Redis <span class="No-Break">for caching</span></li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor099"/>Technical requirements</h1>
			<p>There are no technical requirements for <span class="No-Break">this chapter.</span></p>
			<p>The link to the finished version of this chapter can be <span class="No-Break">found here:</span></p>
			<p><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-05/superheroes"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-05/superheroes</span></a></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor100"/>Starting the server</h1>
			<p>In this section, we will now<a id="_idIndexMarker309"/> attempt to run our Spring Boot application on our server but first, let’s have a recap of the previous chapter: we learned how to configure Spring Data JPA and connect our application to our PostgreSQL database, and—most importantly—we have installed all of the needed dependencies in our application. These are all prerequisites before running the Spring <span class="No-Break">Boot application.</span></p>
			<p>In the following examples, we will be using an application named <strong class="source-inline">spring-boot-superheroes</strong>. We will generate a new Spring Boot application using <strong class="bold">Spring Initializr</strong> with<a id="_idIndexMarker310"/> the same dependencies. Throughout developing our application, we will also show you several ways to write the different parts of your API, such as how to write models, services, and controllers. These are the most common ways used now in the industry. Still, first things first: let’s proceed with running our Spring <span class="No-Break">Boot application.</span></p>
			<p>We assume that you have already generated your Spring Boot application with the needed dependencies. However, if you have missed this part or are unsure whether all dependencies are included on your generated project, let’s list again all the dependencies we installed in the previous chapter, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Spring Data JPA</strong>: Dependency<a id="_idIndexMarker311"/> for adding Spring Data JPA used for built-in data <span class="No-Break">store-related implementation.</span></li>
				<li><strong class="bold">PostgreSQL Driver</strong>: A <a id="_idIndexMarker312"/>JDBC and <strong class="bold">Reactive Relational Database Connectivity</strong> (<strong class="bold">R2DBC</strong>) driver<a id="_idIndexMarker313"/> that will allow the connection of Java applications to the <span class="No-Break">PostgreSQL database.</span></li>
				<li><strong class="bold">H2 Database</strong>: An in-memory <a id="_idIndexMarker314"/>database that supports JDBC API and R2DBC access; this is commonly used for <span class="No-Break">unit testing.</span></li>
			</ul>
			<p>If you have successfully initialized your application with the listed dependencies, open your project in your <a id="_idIndexMarker315"/>preferred <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>); we will <a id="_idIndexMarker316"/>be using IntelliJ for Spring Boot in the<a id="_idIndexMarker317"/> following examples. Then, proceed <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Expand the project folder; we will see several folders inside, as indicated in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer043">
					<img alt="Figure 5.1 – Project structure of ﻿the Spring Boot application" src="image/B18159_05_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Project structure of the Spring Boot application</p>
			<p>We can see<a id="_idIndexMarker318"/> the files and folders in our Spring Boot application<a id="_idIndexMarker319"/> in the preceding screenshot. We can find our main class, named <strong class="source-inline">SuperHeroesApplication</strong>, under <strong class="source-inline">src/main/java</strong>. This main class will be used in running our application on <span class="No-Break">the server.</span></p>
			<p><strong class="source-inline">application.properties</strong> is also an important file that we need to configure, as this is where all the properties are placed that are necessary for connecting to <span class="No-Break">our database.</span></p>
			<ol>
				<li value="2">Open the <strong class="source-inline">application.properties</strong> file, and we should set the <span class="No-Break">following configuration:</span><pre class="console">
spring.main.allow-bean-definition-overriding=true</pre><pre class="console">
spring.datasource.url=jdbc:postgresql://localhost:5432/{{databasename}}</pre><pre class="console">
spring.datasource.username=postgres</pre><pre class="console">
spring.datasource.password=pass</pre><pre class="console">
spring.jpa.hibernate.ddl-auto=update</pre><pre class="console">
spring.jpa.show-sql=true</pre><pre class="console">
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect</pre><pre class="console">
spring.jpa.properties.hibernate.format_sql=true</pre></li>
			</ol>
			<p>This <a id="_idIndexMarker320"/>configuration will allow us to conn<a id="_idTextAnchor101"/><a id="_idTextAnchor102"/>ect to<a id="_idIndexMarker321"/> our <strong class="bold">PostgreSQL database</strong> on our local machine. Remember that the database should exist on our PostgreSQL servers; otherwise, our<a id="_idIndexMarker322"/> application will not run successfully. If you haven’t created your database, open <strong class="bold">pgAdmin</strong> and enter your master password; on the left panel, expand the <span class="No-Break"><strong class="bold">Servers</strong></span><span class="No-Break"> section.</span></p>
			<ol>
				<li value="3">You will see the PostgreSQL instance on your local machine. Right-click on the instance, select <strong class="bold">Connect Server</strong>, and enter the password for the <strong class="source-inline">postgres</strong> user. This will now access the databases on our server, as illustrated in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer044">
					<img alt="Figure 5.2 – Accessing PostgreSQL server using pgAdmin" src="image/B18159_05_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Accessing PostgreSQL server using pgAdmin</p>
			<ol>
				<li value="4">After<a id="_idIndexMarker323"/> successfully accessing the server, right-click<a id="_idIndexMarker324"/> on <strong class="bold">Database</strong>, select <strong class="bold">Create</strong>, and click on <strong class="bold">Database</strong>; this will open the <span class="No-Break">following modal:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 5.3 – Creating a database" src="image/B18159_05_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Creating a database</p>
			<p>In the preceding screenshot, we named our database <strong class="source-inline">SpringDevDB</strong> and set the <strong class="source-inline">postgres</strong> user value in the <strong class="bold">Owner</strong> field. Click <strong class="bold">Save</strong>, and our database is all set in <span class="No-Break">our server.</span></p>
			<ol>
				<li value="5">Our <a id="_idIndexMarker325"/>Spring Boot application is now ready to run <a id="_idIndexMarker326"/>on our server; in your IntelliJ IDE, click on <strong class="bold">Add Configuration</strong>, found on the upper-right side of the panel. This will open the modal where we will configure our entry point to run our application, as illustrated in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Figure 5.4 – Adding configuration for Spring Boot" src="image/B18159_05_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Adding configuration for Spring Boot</p>
			<ol>
				<li value="6">Click on <strong class="bold">Add new run configuration…</strong> shown in the preceding screenshot and select <strong class="bold">Application</strong>. Under the <strong class="bold">Main class</strong> field, type the main class, which is <strong class="source-inline">SuperheroesApplication</strong>, and this will automatically fill the program arguments with the correct fully qualified name of the class, as illustrated in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 5.5 – Configuration for application" src="image/B18159_05_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Configuration for application</p>
			<p>Click on <strong class="bold">Apply</strong> and then click <strong class="bold">OK</strong> to save the <span class="No-Break">configuration changes.</span></p>
			<ol>
				<li value="7">In the<a id="_idIndexMarker327"/> upper-right panel of the IDE, select the <a id="_idIndexMarker328"/>created configuration and run the project by clicking on the green play icon. The application will run on the installed Tomcat server on the default port <strong class="source-inline">8080</strong>; we can also use the terminal to check whether the Spring Boot project has successfully started on the server. You can see the process running in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 5.6 – Spring Boot logs" src="image/B18159_05_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Spring Boot logs</p>
			<p>In the<a id="_idIndexMarker329"/> preceding screenshot, we can see that our application<a id="_idIndexMarker330"/> has started successfully; we are also connected to our PostgreSQL database, and we can now start writing <span class="No-Break">our code.</span></p>
			<p>We will now try to create our application models in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor103"/>Adding models</h1>
			<p>In this section, we <a id="_idIndexMarker331"/>will now write code for our application, and the first thing we will create is models. In simple terms, models are the object of our application; the models will serve as our entities and will define our tables in <span class="No-Break">the database.</span></p>
			<p>Once we create models and run the application, this will also generate tables in our database automatically with the help of annotations, which will also be discussed throughout <span class="No-Break">this example.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor104"/>Creating models with DTOs and Lombok</h2>
			<p>We will first show you how to <a id="_idIndexMarker332"/>write models using Lombok and <strong class="bold">data transfer objects</strong> (<strong class="bold">DTOs</strong>). First, we<a id="_idIndexMarker333"/> will <span class="No-Break">discuss DTOs.</span></p>
			<h3>DTOs</h3>
			<p>DTOs are<a id="_idIndexMarker334"/> responsible for carrying data between processes to reduce the number of method calls. DTOs <a id="_idIndexMarker335"/>are <strong class="bold">plain old Java objects</strong> (<strong class="bold">POJOs</strong>) that commonly consist of <span class="No-Break">data accessors.</span></p>
			<p>DTOs are <a id="_idIndexMarker336"/>very useful for creating<a id="_idIndexMarker337"/> representations of our entities to have views for clients without affecting the pattern and design. Let’s have an example use case for DTOs. You can see <span class="No-Break">this here:</span></p>
			<pre class="source-code">
public class Blog {
private String id;
private String title;
private String description;
private String author;
public Blog(String title, String description,
            String author) {
   this.name = title;
   this.description = description
   this.author = author
}</pre>
			<p>In the preceding code, we have created an example domain model that will represent entities in our database. There are instances where we would not want to include some information on sending data to the client, which is where DTOs would enter the scene. We will create two DTOs for the blog model used for getting and creating data, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Public class BlogDTO {
     private String title;
     private String description;
}</pre>
			<p>In the preceding example DTO, we have created a <strong class="source-inline">BlogDTO</strong> class that will be used for retrieving data; our objective is to hide the author’s name, thus not including it as a field in the DTO. The code is illustrated in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
Public class BlogCreationDTO {
     private String title;
     private String description;
     private String author;
}</pre>
			<p>The next <a id="_idIndexMarker338"/>DTO we have created is <strong class="source-inline">BlogCreationDTO</strong>, which will create a new blog. We can see that all fields necessary<a id="_idIndexMarker339"/> to create a new blog <span class="No-Break">are included.</span></p>
			<p>The created DTOs will be used for our controllers in the <span class="No-Break">following sections.</span></p>
			<h3>Lombok</h3>
			<p><strong class="bold">Lombok</strong> is <a id="_idIndexMarker340"/>a third-party library used to reduce boilerplate<a id="_idIndexMarker341"/> code using annotations. Lombok allows us to avoid repetitive code, especially in creating models such as getter and <span class="No-Break">setter methods.</span></p>
			<p>Let’s have a<a id="_idIndexMarker342"/> comparison between a model without Lombok and a model using Lombok, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public class Blog {
     private String title;
     private String description;
     private String author;
     public Blog() {}
     public Blog(String title, String description,
                 String author) {
     super()
       this.name = title;
       this.description = description
       this.author = author
}
     public String getAuthor() {return author;}
     public void setAuthor(String author) {
     this.author = author; }
     public String getTitle() {return title;}
     public void setTitle(String title) {
     this.title = title; }
     public String getDescription() {return description;}
     public void setDescription(String description) {
     this.description = description; }
    @Override public String toString()
    {return "Blog ["
            + "author=" + author + ", title=" + title
            + ", " + " description =" + description + "]";
    }
}</pre>
			<p>In the <a id="_idIndexMarker343"/>preceding code example, we have created a blog model without using Lombok; we can see that we have created a getter and setter method for<a id="_idIndexMarker344"/> each field, and we have also created constructors with and without arguments. The code in this example is <span class="No-Break">still manageable.</span></p>
			<p>Still, if our model is required to contain more fields, we need to create setters and getters for the new fields, creating more boilerplate code inside our model and sacrificing the maintainability of <span class="No-Break">our code.</span></p>
			<p>The class and annotations should be as shown in the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Blog {
     private String title;
     private String description;
     private String author;
}</pre>
			<p>In the <a id="_idIndexMarker345"/>preceding screenshot, we have used Lombok to<a id="_idIndexMarker346"/> create our blog model, and we can see that a considerable amount of code has been omitted from the model. The <strong class="source-inline">@Data</strong> annotation generates setter and getter methods, a <strong class="source-inline">toString()</strong> method, and a constructor with <span class="No-Break">required arguments.</span></p>
			<p><strong class="source-inline">@AllArgsConstructor</strong> and <strong class="source-inline">@NoArgsConstructor</strong> are accountable for the constructor with all and <span class="No-Break">no arguments.</span></p>
			<p>The advantage of using Lombok is evident in the previous examples; it makes code easier to read and less error-prone, promotes easy cleanup and maintainability, and gives effortless logging <span class="No-Break">and debugging.</span></p>
			<h3>Model application</h3>
			<p>Now that <a id="_idIndexMarker347"/>we have learned about the importance of DTO and Lombok, let’s go back to our Spring Boot application. Under the <strong class="source-inline">java</strong> folder, right-click on the package and select <strong class="bold">Package</strong>. This will display a small window that will allow you to enter a <span class="No-Break">new package.</span></p>
			<p>In this example, we will create a new package named <strong class="source-inline">antiHero</strong>. After completing the new package, we will create two new packages under <strong class="source-inline">antiHero</strong>, calling them <strong class="source-inline">dto</strong> and <strong class="source-inline">entity</strong>. You can see the packages in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer049">
					<img alt="Figure 5.7 – Project structure after the creation of packages" src="image/B18159_05_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Project structure after the creation of packages</p>
			<p>Our<a id="_idIndexMarker348"/> project structure should now look just as it is presented in the preceding screenshot. Let’s first create our entity; right-click on the entity package we have created, and then click on <strong class="bold">New</strong> | <strong class="bold">JPA</strong> | <strong class="bold">Entity</strong>. This will open a model for creating a new entity. We will name our entity <strong class="source-inline">AntiHeroEntity</strong> and click on the <strong class="bold">OK</strong> button. The process is illustrated in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer050">
					<img alt="Figure 5.8 – Creating an entity" src="image/B18159_05_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Creating an entity</p>
			<p>We will see a newly generated class under the <strong class="source-inline">entity</strong> package, and it will have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
package com.example.springbootsuperheroes.superheroes.antiHero.entity;
import javax. persistence.Entity;
import javax.persistence.Table;
@Entity
@Table(name = "anti_hero_entity")
public class AntiHeroEntity {
}</pre>
			<p>An entity <a id="_idIndexMarker349"/>was automatically generated with the <strong class="source-inline">@Entity</strong> and <strong class="source-inline">@Table</strong> annotations that will be used to identify this model as an object in the database. The current code will have some issues, stating that the entity does not have<a id="_idIndexMarker350"/> a <strong class="bold">primary key</strong> (<strong class="bold">PK</strong>); in this case, we will add the following to <span class="No-Break">our model:</span></p>
			<ul>
				<li><strong class="source-inline">@Data</strong>: Lombok annotations that will set the getter and setter methods, the <strong class="source-inline">toString()</strong> method, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">@RequiredArgsConstructor</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@AllArgsConstructor</strong>: Lombok annotations for generating a constructor for the model with all fields <span class="No-Break">as arguments.</span></li>
				<li><strong class="source-inline">@NoArgsConstructor</strong>: Lombok annotations for generating a constructor for the model with <span class="No-Break">no arguments.</span></li>
				<li><strong class="source-inline">@Id</strong>: Found under <strong class="source-inline">javax.persistence.*</strong>, this will determine the <span class="No-Break">model’s PK.</span></li>
				<li><strong class="source-inline">@GeneratedValue</strong>: Used on the PK to determine which generation type will <span class="No-Break">be used.</span></li>
				<li><strong class="source-inline">@NotNull</strong>: Found under <strong class="source-inline">javax.validation.constraints</strong> and validates that a specific field cannot <span class="No-Break">be null.</span></li>
			</ul>
			<p>The<a id="_idIndexMarker351"/> dependency should be installed by adding the following code <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
			<p>After adding the dependency to <strong class="source-inline">pom.xml</strong>, right-click on your project and select <strong class="bold">Maven</strong> | <strong class="bold">Reload project</strong> to install the <span class="No-Break">new dependency.</span></p>
			<p>After successfully adding the Lombok annotations, PK, validations, and fields to our model, we will have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
package com.example.springbootsuperheroes
.superheroes.antiHero.entity;
…
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.UUID;
import javax.persistence.*;
import javax.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
…</pre>
			<p>After adding all the <a id="_idIndexMarker352"/>preceding packages, we can now start writing our class and the annotations, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
@Data
@Entity
@Table
@AllArgsConstructor
@NoArgsConstructor
public class AntiHeroEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO,
                    generator = "UUID")
    @Column(nullable = false, updatable = false)
    private UUID id;
    @NotNull(message = "First Name is required")
    private String firstName;
    private String lastName;
    private String house;
    private String knownAs;
    private String createdAt =
      new SimpleDateFormat("dd-MM-yyyy HH:mm:ss z")
            .format(new Date());
}</pre>
			<p>In the <a id="_idIndexMarker353"/>preceding code block, we can see that we have added a PK of the <strong class="source-inline">UUID</strong> type; this will be automatically generated once we insert new anti-hero data into our database. The type is defined using the <strong class="source-inline">@GeneratedValue</strong> annotation, where we have also indicated that the strategy will be using an auto generator. We have also added several fields that will be used to store the <span class="No-Break">anti-hero information.</span></p>
			<p>We have successfully created our entity; now, we will create a DTO for the anti-hero entity. Right-click on the <strong class="source-inline">dto</strong> package, select <strong class="bold">New</strong> | <strong class="bold">Java class</strong>, and we will name the new class <strong class="source-inline">AntiHeroDto</strong>. After successfully creating the DTO, we will place the following code <span class="No-Break">into it:</span></p>
			<pre class="source-code">
package com.example.superheroes.antiHero.dto;
import java.util.UUID;
import javax.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;
@Getter
@Setter
public class AntiHeroDto {
  private UUID id;
  @NotNull(message = "First Name is required")
  private String firstName;
  private String lastName;
  private String house;
  private String knownAs;
}</pre>
			<p>In the<a id="_idIndexMarker354"/> preceding code example, we have added fields that we only want to display as we send the anti-hero data to the client; in this case, we have removed the <strong class="source-inline">createdAt</strong> field in our DTO. We have also added <strong class="source-inline">@Getter</strong> and <strong class="source-inline">@Setter</strong> annotations to generate getter and setter methods for our DTO, and lastly, we have also added <strong class="source-inline">@NotNull</strong> validation to match our constraint with <span class="No-Break">the entity.</span></p>
			<p>We have successfully created our DTO and models with Lombok in our application. In the next section, we will make our services responsible for the CRUD functionalities of our Spring <span class="No-Break">Boot application.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor105"/>Writing services</h1>
			<p>In this section, we <a id="_idIndexMarker355"/>will now write the services for our application, but first, let’s discuss the primary purpose of services in Spring Boot. Services are classes where we place all of our business logic; this is where we will write our CRUD functionalities with the help of JPA repositories. In this case, we will not only make our service class but will also create our <span class="No-Break">JPA repository.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor106"/>JPA repository</h2>
			<p>As <a id="_idIndexMarker356"/>discussed in <a href="B18159_04.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Setting Up the Database and Spring Data JPA</em>, the JPA repository is a widely used specification for managing relational data in Java applications. It helps develop Spring by reducing boilerplate code by not implementing read and <span class="No-Break">write operations.</span></p>
			<p>It is simple to create a JPA repository in Spring Boot; having said that, the JPA library provides classes such as <strong class="source-inline">CrudRepository</strong> that we can use to extend our classes. Let’s make one in our Spring Boot application example. Proceed <span class="No-Break">as follows:</span></p>
			<ol>
				<li value="1">Right-click on our <strong class="source-inline">antiHero</strong> package, select <strong class="bold">New</strong>, and click on the <span class="No-Break"><strong class="bold">Package </strong></span><span class="No-Break">option.</span></li>
				<li>Create a new package <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">repository</strong></span><span class="No-Break">.</span></li>
				<li>After creating the new package, right-click on the <strong class="source-inline">repository</strong> package, select <strong class="bold">New</strong>, and click on the <span class="No-Break"><strong class="bold">Class</strong></span><span class="No-Break"> option.</span></li>
				<li>As the <a id="_idIndexMarker357"/>small modal pops up, switch to the <strong class="bold">Interface</strong> option and name the interface <strong class="source-inline">AntiHeroRepository</strong>. The following code will <span class="No-Break">be generated:</span><pre class="console">
package com.example.springbootsuperheroes.superheroes.antiHero.repository;</pre><pre class="console">
import com.example.springbootsuperheroes.superheroes.antiHero.entity.AntiHeroEntity;</pre><pre class="console">
import org.springframework.data.repository.CrudRepository;</pre><pre class="console">
import java.util.UUID;</pre><pre class="console">
public interface AntiHeroRepository {</pre><pre class="console">
}</pre></li>
			</ol>
			<p>We have created our interface, but this is just a simple interface. We will extend our interface with the <strong class="source-inline">CrudRepository</strong> class to convert it to a JPA repository, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public interface AntiHeroRepository extends CrudRepository&lt;AntiHeroEntity, UUID&gt; {
}</pre>
			<p><strong class="source-inline">AntiHeroRepository</strong>, as we have already extended it with <strong class="source-inline">CrudRepository&lt;Type, ID&gt;</strong>, will have methods that have the <span class="No-Break">following functionalities:</span></p>
			<ul>
				<li>Persisting, updating, and deleting one of the <span class="No-Break">blog entities</span></li>
				<li>Finding one or multiple blogs by <span class="No-Break">their PKs</span></li>
				<li>Counting <span class="No-Break">all blogs</span></li>
				<li>Validating whether a single <span class="No-Break">blog exists</span></li>
			</ul>
			<p>We have <a id="_idIndexMarker358"/>successfully created our JPA repository; our next step is to do our service. Our goal is to create a service that will have the capability to get an entire list, get a single database in a PK, insert new data, update selected data, and delete data. We can achieve this through the following methods provided by the <span class="No-Break">JPA repository:</span></p>
			<ul>
				<li><strong class="source-inline">findAll()</strong>: Gets all the existing data in a <span class="No-Break">specific entity</span></li>
				<li><strong class="source-inline">findById(Id)</strong>: Finds a particular database <span class="No-Break">by PK</span></li>
				<li><strong class="source-inline">save()</strong>: Inserts new data in <span class="No-Break">the table</span></li>
				<li><strong class="source-inline">save(data)</strong>: Updates existing data in <span class="No-Break">the table</span></li>
				<li><strong class="source-inline">deleteById(id)</strong>: Deletes specific data in the table <span class="No-Break">by PK</span></li>
			</ul>
			<p>Now that we have successfully identified the methods we need for our service, let’s next create our service. Right-click on the <strong class="source-inline">antiHero</strong> package and create a new package named <strong class="source-inline">service</strong>; after creating the new package, create a new class under the <strong class="source-inline">service</strong> package called <strong class="source-inline">AntiHeroService</strong>, and we will place the following methods inside <span class="No-Break">the service:</span></p>
			<pre class="source-code">
public class AntiHeroService {
    private final AntiHeroRepository repo;
    public Iterable&lt;AntiHeroEntity&gt; findAllAntiHeroes() {
        return repo.findAll();
    }
    public AntiHeroEntity findAntiHeroById(UUID id) {
        return findById(id);
    }
    public void removeAntiHeroById(UUID id) {
        repo.deleteById(id);
    }
    public AntiHeroEntity addAntiHero(
      AntiHeroEntity antiHero) {
        return repo.save(antiHero);
    }
    public void updateAntiHero(UUID id,
      AntiHeroEntity antiHero) {
        repo.save(antiHero);
    }
}</pre>
			<p>Let’s discuss<a id="_idIndexMarker359"/> the preceding code; we have added several methods to our service, and these are explained in more <span class="No-Break">detail here:</span></p>
			<ul>
				<li><strong class="source-inline">Iterable&lt;AntiHeroEntity&gt; findAllAntiHeroes()</strong>: This method calls <strong class="source-inline">findAll()</strong> from <strong class="source-inline">AntiHeroRepository</strong>, which returns an <strong class="source-inline">Iterable</strong> instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">AntiHeroEntity</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">AntiHeroEntity findAntiHeroById(UUID id)</strong>: This method calls <strong class="source-inline">findById(id)</strong> from <strong class="source-inline">AntiHeroRepository</strong>, which returns a single <strong class="source-inline">AntiHeroEntity</strong> instance based on the <span class="No-Break"><strong class="source-inline">Id</strong></span><span class="No-Break"> value.</span></li>
				<li><strong class="source-inline">removeAntiHeroById(UUID id)</strong>: This method calls <strong class="source-inline">deleteById(id)</strong> from <strong class="source-inline">AntiHeroRepository</strong>, which deletes a single <strong class="source-inline">AntiHeroEntity</strong> instance based on the <span class="No-Break"><strong class="source-inline">Id</strong></span><span class="No-Break"> value.</span></li>
				<li><strong class="source-inline">void AntiHeroEntity addAntiHero(AntiHeroEntity antiHero)</strong>: This method calls <strong class="source-inline">save()</strong> from <strong class="source-inline">AntiHeroRepository</strong> and inserts a new <strong class="source-inline">AntiHeroEntity</strong> instance in <span class="No-Break">the database.</span></li>
				<li><strong class="source-inline">void updateAntiHero(UUID id, AntiHeroEntity antiHero)</strong>: This method calls <strong class="source-inline">save(antiHero)</strong> from <strong class="source-inline">AntiHeroRepository</strong>, which updates a specific <strong class="source-inline">AntiHeroEntity</strong> instance in <span class="No-Break">the database.</span></li>
			</ul>
			<p>After <a id="_idIndexMarker360"/>successfully adding the method for our service, we will add <strong class="source-inline">@AllArgsConstructor</strong> and <strong class="source-inline">@Service</strong> annotations to <strong class="source-inline">AntiHeroService</strong>. <strong class="source-inline">@AllArgsConstructor</strong> is an annotation from Lombok that will generate a constructor that requires one argument of each field; in our example, this will produce the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
public AntiHeroService(AntiHeroRepository repo) {
  this.repo = repo;
}</pre>
			<p>This will now allow the wiring of our <strong class="source-inline">AntiHeroRepository</strong> dependency on <span class="No-Break">our service.</span></p>
			<p>The <strong class="source-inline">@Service</strong> annotation, on the other hand, is functional when we want Spring Context to autodetect classes based on <span class="No-Break">their classification.</span></p>
			<p>We have now successfully created our service with CRUD methods, but what if something went wrong as we call our service? For example, the <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) of the anti-hero we have passed may not exist. We would want to catch the error and return an understandable message to the user. Now, we will create runtime exception handling for <span class="No-Break">our service.</span></p>
			<h3>Runtime exceptions</h3>
			<p><strong class="bold">Runtime exceptions</strong> are <a id="_idIndexMarker361"/>also known as unchecked exceptions. These are programming errors and will happen upon the current execution of our application. This should be prevented directly by <span class="No-Break">the developers.</span></p>
			<p>Some known runtime exceptions are <span class="No-Break">listed here:</span></p>
			<ul>
				<li><strong class="source-inline">IndexOutOfBoundsException</strong>: This<a id="_idIndexMarker362"/> exception occurs when we access an index of an array string or an iterable that is out of range, as illustrated in the following <span class="No-Break">code snippet:</span><pre class="console">
String[] array = new String[100];</pre><pre class="console">
String name = array[200]; // throws index out of bounds as array variable only has a length of 100</pre></li>
				<li><strong class="source-inline">IllegalArgumentException</strong>: This <a id="_idIndexMarker363"/>exception occurs when a method has been passed by an illegal argument, as illustrated in the following <span class="No-Break">code snippet:</span><pre class="console">
public class Hero {</pre><pre class="console">
   int number;</pre><pre class="console">
   public void givePositiveNumber(int number) {</pre><pre class="console">
      if(number &lt; 0)  throw new</pre><pre class="console">
        IllegalArgumentException(</pre><pre class="console">
          Integer.toString(number));</pre><pre class="console">
      else { m = number; }</pre><pre class="console">
   }</pre><pre class="console">
   public static void main(String[] args) {</pre><pre class="console">
      Hero h = new Hero();</pre><pre class="console">
      // throws illegal argument exception as -1 is a</pre><pre class="console">
      // negative number</pre><pre class="console">
      h.givePositiveNumber(-1);</pre><pre class="console">
}</pre><pre class="console">
   }</pre></li>
				<li><strong class="source-inline">NullPointerException</strong>: This <a id="_idIndexMarker364"/>exception occurs when a variable is accessed that does <a id="_idIndexMarker365"/>not point to any object or is simply null, as illustrated in the following <span class="No-Break">code snippet:</span><pre class="console">
public void doAction(ExampleObject obj) {   obj.doActionOnMethod();</pre><pre class="console">
}</pre><pre class="console">
// call doAction()</pre><pre class="console">
// throws null pointer exception as we are accessing a</pre><pre class="console">
// method on a null object</pre><pre class="console">
doAction(null)</pre></li>
			</ul>
			<p>These are just common runtime exceptions that we use in our application; we can also create runtime exceptions using the <strong class="source-inline">RunTimeException</strong> class. In this example, let’s create a <strong class="source-inline">NotFoundException</strong> runtime exception that we will use to get a non-existent ID. Proceed <span class="No-Break">as follows:</span></p>
			<ol>
				<li value="1">Under the <strong class="source-inline">main</strong> package, create a new package named <strong class="source-inline">exception</strong>; after successfully creating the package, create a class named <strong class="source-inline">NotFoundException</strong>. We will extend our created class with the <strong class="source-inline">RunTimeException</strong> class and will add the <span class="No-Break">following code:</span><pre class="console">
public class NotFoundException extends RuntimeException {</pre><pre class="console">
    public NotFoundException(String message) {</pre><pre class="console">
        super(message);</pre><pre class="console">
    }</pre><pre class="console">
    public NotFoundException(String message,</pre><pre class="console">
                             Throwable cause) {</pre><pre class="console">
        super(message, cause);</pre><pre class="console">
    }</pre><pre class="console">
    public NotFoundException(Throwable cause) {</pre><pre class="console">
        super(cause);</pre><pre class="console">
    }</pre><pre class="console">
}</pre></li>
			</ol>
			<p>In the preceding code snippet, we have declared several methods with <strong class="source-inline">NotFoundException</strong> with different arguments; having successfully created our custom exception, we can now use it on <span class="No-Break">our service.</span></p>
			<ol>
				<li value="2">Go back<a id="_idIndexMarker366"/> to <strong class="source-inline">AntiHeroService</strong>, and we will add the <span class="No-Break">following method:</span><pre class="console">
private AntiHeroEntity findOrThrow(final UUID id) {</pre><pre class="console">
    return repo</pre><pre class="console">
            .findById(id)</pre><pre class="console">
            .orElseThrow(</pre><pre class="console">
               () -&gt; new NotFoundException("Anti-hero</pre><pre class="console">
                     by id " + id + " was not found")</pre><pre class="console">
            );</pre><pre class="console">
}</pre></li>
			</ol>
			<p>In the preceding code example, we have created a new method named <strong class="source-inline">findOrThrow()</strong>; this is also calling the <strong class="source-inline">findById()</strong> method. The only difference is that it checks whether the given ID exists on the database; otherwise, it will throw something based on our code. In this case, we would want to throw a <strong class="source-inline">NotFoundException</strong> <span class="No-Break">runtime exception.</span></p>
			<ol>
				<li value="3">After this, we can use it now on <strong class="source-inline">findAntiHeroById()</strong> by replacing <strong class="source-inline">findById()</strong> with the <strong class="source-inline">findOrThrow()</strong> method and also add it to the <strong class="source-inline">updateAntiHero()</strong> and <strong class="source-inline">deleteAntiHero()</strong> methods to check whether the data exists before updating or deleting it. The code to accomplish this is <span class="No-Break">illustrated here:</span><pre class="console">
public AntiHeroEntity findAntiHeroById(UUID id) {</pre><pre class="console">
  return findOrThrow(id);</pre><pre class="console">
}</pre><pre class="console">
public void updateAntiHero(UUID id,</pre><pre class="console">
                           AntiHeroEntity antiHero) {</pre><pre class="console">
  findOrThrow(id);</pre><pre class="console">
  repo.save(antiHero);</pre><pre class="console">
}</pre></li>
			</ol>
			<p>We have now<a id="_idIndexMarker367"/> successfully created our service for our application. The next section will discuss how to make controllers and define endpoints in <span class="No-Break">our code.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor107"/>Adding controllers</h2>
			<p>This section will now discuss the use of controllers and how to create them in our application. <strong class="bold">Controllers</strong> are<a id="_idIndexMarker368"/> responsible for intercepting incoming requests and converting the payload of the request for the internal structure of the data; this is also where we will define our endpoint paths that will be available for access for our <span class="No-Break">frontend applications.</span></p>
			<p>In creating controllers, we<a id="_idIndexMarker369"/> will use several annotations, as <span class="No-Break">described here:</span></p>
			<ul>
				<li><strong class="source-inline">@RestController</strong>: This is a <a id="_idIndexMarker370"/>specialized form of the <strong class="source-inline">@Controller</strong> annotation; compared to using the <strong class="source-inline">@Controller</strong> annotation, it already includes both the <strong class="source-inline">@Controller</strong> and <strong class="source-inline">@ResponseBody</strong> annotation, not needing to specify the <strong class="source-inline">@ResponseBody</strong> annotation on <span class="No-Break">each method.</span></li>
				<li><strong class="source-inline">@RequestMapping</strong>: This<a id="_idIndexMarker371"/> is an annotation used to map <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) requests<a id="_idIndexMarker372"/> to the methods<a id="_idIndexMarker373"/> of <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">REST</strong>) controllers. It is also where we define a base path for <span class="No-Break">the controller.</span></li>
				<li><strong class="source-inline">@GetMapping</strong>: This<a id="_idIndexMarker374"/> maps HTTP <strong class="source-inline">GET</strong> requests on a method; the annotation is a shortcut for <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.GET)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@PutMapping</strong>: This<a id="_idIndexMarker375"/> maps HTTP <strong class="source-inline">PUT</strong> requests on a method; the annotation is a shortcut for <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.PUT)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@PostMapping</strong>: This<a id="_idIndexMarker376"/> maps HTTP <strong class="source-inline">POST</strong> requests on a method; the annotation is a shortcut for <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.POST</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">@DeleteMapping</strong>: This <a id="_idIndexMarker377"/>maps HTTP <strong class="source-inline">DELETE</strong> requests on a method; the annotation is a shortcut for <strong class="source-inline">@RequestMapping(method = </strong><span class="No-Break"><strong class="source-inline">RequestMethod.DELETE)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">@PathVariable</strong>: This <a id="_idIndexMarker378"/>annotation is used to get the value of <span class="No-Break">endpoint parameters.</span></li>
				<li><strong class="source-inline">@Valid</strong>: This<a id="_idIndexMarker379"/> annotation is used to check the validity of an object; it is commonly used on the request body to check whether a passed request is a <span class="No-Break">valid object.</span></li>
			</ul>
			<p>We have successfully identified the annotations we will use for our controller. We can now create our controller. Under the <strong class="source-inline">antiHero</strong> package, create a new package named <strong class="source-inline">controller</strong>, and after completing the <strong class="source-inline">controller</strong> package, create a new class <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">AntiHeroController</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="source-inline">AntiHeroController</strong> class, we will use the <strong class="source-inline">@AllArgsConstructor</strong>, <strong class="source-inline">@RestController</strong>, and <strong class="source-inline">@RequestMapping</strong> annotations, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@AllArgsConstructor
@RestController
@RequestMapping("api/v1/anti-heroes")
public class AntiHeroController {
}</pre>
			<p>Our <a id="_idIndexMarker380"/>controller is now configured; the next step is to place our dependencies inside our controller. We have used the <strong class="source-inline">@AllArgsContructor</strong> annotation. We don’t need to create a constructor method with the parameters; we only need to <span class="No-Break">define dependencies.</span></p>
			<p>First, we will determine the <strong class="source-inline">AntiHeroService</strong> class where all our CRUD logic is baked. The next one is <strong class="source-inline">ModelMapper</strong>; this is important, seeing as we need to convert our entity into a DTO when we use it as a response, and vice versa if we want to read an object from a request body. <strong class="source-inline">ModelMapper</strong> will easily map the values of an entity to a DTO object with the <span class="No-Break">same property.</span></p>
			<p>To install the dependency, we just need to add the following code to our <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;!--Dto mapper--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.modelmapper&lt;/groupId&gt;
   &lt;artifactId&gt;modelmapper&lt;/artifactId&gt;
   &lt;version&gt;2.3.9&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>After successfully adding the <strong class="source-inline">ModelMapper</strong> dependency, we need to define our <strong class="source-inline">ModelMapper</strong> dependency as a Bean in our configuration to use it on our application. To achieve this, we will create a new package named <strong class="source-inline">config</strong> under the <strong class="source-inline">main</strong> package, and we will create a new class called <strong class="source-inline">ModelMapperConfig</strong>. After creating a new class, we will add a new method annotated with <strong class="source-inline">@Bean</strong> and return a new instance of <strong class="source-inline">ModelMapper</strong>. The code is illustrated in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
@Configuration
public class ModelMapperConfig {
  @Bean
  public ModelMapper modelMapper() {
    return new ModelMapper();
  }
}</pre>
			<p>Our <a id="_idIndexMarker381"/>configuration is all done, and now, we can add <strong class="source-inline">AntiHeroService</strong> and <strong class="source-inline">ModelMapper</strong> to our controller, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@AllArgsConstructor
@RestController
@RequestMapping("api/v1/anti-heroes")
public class AntiHeroController {
    private final AntiHeroService service;
     private final ModelMapper mapper;
}</pre>
			<p>We now have our controllers with the needed dependencies. Now, let’s create two functions that will convert our entity into a DTO, or vice versa. As mentioned a while ago, we will be using the <strong class="source-inline">ModelMapper</strong> dependency to make these methods, and in this case, we will add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
private AntiHeroDto convertToDto(AntiHeroEntity entity) {
  return mapper.map(entity, AntiHeroDto.class);
}
private AntiHeroEntity convertToEntity(AntiHeroDto dto) {
  return mapper.map(dto, AntiHeroEntity.class);
}</pre>
			<p>We have <a id="_idIndexMarker382"/>created two functions in the preceding code example. First, we created the <strong class="source-inline">convertToDto()</strong> method, which will convert the given <strong class="source-inline">AntiHeroEntity</strong> instance into an <strong class="source-inline">AntiHeroDto</strong> instance, for which we have used the <strong class="source-inline">map()</strong> method from <strong class="source-inline">ModelMapper</strong> to map the entity’s values. The second function is the <strong class="source-inline">convertToEntity()</strong> method, which converts the DTO into <span class="No-Break">an entity.</span></p>
			<p>Now, we can create mappings for our CRUD methods. Let’s first start a method that will return a specific entity base on the <strong class="source-inline">id</strong> value; we will use the <strong class="source-inline">@GetMapping</strong> annotation to identify that this will use a <strong class="source-inline">GET</strong> request, and we will add <strong class="source-inline">/{id}</strong> as a parameter to indicate that we can pass the entity ID as a dynamic parameter in <span class="No-Break">the endpoint.</span></p>
			<p>In creating the method, we will use the <strong class="source-inline">@PathVariable</strong> annotation to get the value of <strong class="source-inline">/{id}</strong> in the endpoint and define it as a <strong class="source-inline">UUID</strong> type. Lastly, we will call the <strong class="source-inline">service.findAntiHeroById()</strong> function under <strong class="source-inline">AntiHeroService</strong> and pass the retrieved ID to get the entity in the database, and we will use the <strong class="source-inline">convertToDto()</strong> function to convert it to a DTO. The code is illustrated in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
@GetMapping("/{id}")
public AntiHeroDto getAntiHeroById(@PathVariable("id") UUID id) {
  return convertToDto(service.findAntiHeroById(id));
}</pre>
			<p>Now, to create the <strong class="source-inline">create</strong> mapping, we will use the <strong class="source-inline">@PostMapping</strong> annotation to identify that this will use a <strong class="source-inline">POST</strong> request, we will use the <strong class="source-inline">@RequestBody</strong> annotation to get the object on the request body, and we can also use the <strong class="source-inline">@Valid</strong> annotation to check whether the object is a <span class="No-Break">valid entity.</span></p>
			<p>In creating the function, we will call the <strong class="source-inline">convertToEntity()</strong> method to convert the object into an entity, and we will call the <strong class="source-inline">service.addAntiHero()</strong> method to insert the converted entity into the database. The code is illustrated in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
@PostMapping
public AntiHeroDto postAntiHero(@Valid @RequestBody AntiHeroDto antiHeroDto) {
  var entity = convertToEntity(antiHeroDto);
  var antiHero = service.addAntiHero(entity);
  return convertToDto(antiHero);
}</pre>
			<p>The <a id="_idIndexMarker383"/>next thing we need to create is the <strong class="source-inline">PUT</strong> mapping. We will use the <strong class="source-inline">@PutMapping</strong> annotation to identify that this will use a <strong class="source-inline">PUT</strong> request, the same as how we created the <strong class="source-inline">GET</strong> mapping. We will add <strong class="source-inline">/{id}</strong> as a parameter, and we will also use the <strong class="source-inline">@RequestBody</strong> annotation to get the object on the request body and the <strong class="source-inline">@PathVariable</strong> annotation to get the value of <strong class="source-inline">id</strong> in <span class="No-Break">the parameter.</span></p>
			<p>In implementing the function, we will also call the <strong class="source-inline">convertToEntity()</strong> method and call the <strong class="source-inline">service.updateAntiHero(id, entity)</strong> method to update the specific entity with the DTO values. The code is illustrated in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
@PutMapping("/{id}")
public void putAntiHero(
  @PathVariable("id") UUID id,
  @Valid @RequestBody AntiHeroDto antiHeroDto
) {
  if (!id.equals(antiHeroDto.getId())) throw new
    ResponseStatusException(
    HttpStatus.BAD_REQUEST,
    "id does not match."
  );
  var antiHeroEntity = convertToEntity(antiHeroDto);
  service.updateAntiHero(id, antiHeroEntity);
}</pre>
			<p>Next, we’ll create <strong class="source-inline">DELETE</strong> mapping. We will use the <strong class="source-inline">@DeleteMapping</strong> annotation to identify that this will use a <strong class="source-inline">DELETE</strong> request. We will also add <strong class="source-inline">/{id}</strong> as a parameter to receive the ID of the entity we need to delete, and we will add the <strong class="source-inline">@PathVariable</strong> annotation to get the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break">.</span></p>
			<p>To<a id="_idIndexMarker384"/> implement the method, we simply call the <strong class="source-inline">service.removeAntiHeroById()</strong> method to delete the specific entity in the database, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@DeleteMapping("/{id}")
public void deleteAntiHeroById(@PathVariable("id") UUID id) {
  service.removeAntiHeroById(id);
}</pre>
			<p>And lastly, we need to create a method that will return all the entities in the database. One way we can implement this is using <strong class="source-inline">StreamSupport</strong> to convert our retrieved list into a stream and convert each object into a DTO, but first, we will create a method that returns a type of <strong class="source-inline">List&lt;AntiHeroDto&gt;</strong> with the <strong class="source-inline">@GetMapping</strong> annotation. After completing the method, we will now call the <strong class="source-inline">service.findAllAntiHeroes()</strong> method to get the entities in the database. Since this returns to an <strong class="source-inline">Iterable</strong> instance, we will convert it into a stream and transform it into a list using <strong class="source-inline">Collectors.toList()</strong>. The code is illustrated in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
  var antiHeroList = StreamSupport
    .stream(service.findAllAntiHeroes().spliterator(),
            false)
    .collect(Collectors.toList());</pre>
			<p>After successfully retrieving and converting the data into a list, we want each object converted into a DTO. We can achieve this by converting the list into a stream. Call the <strong class="source-inline">convertToDto()</strong> method and convert it to a list again, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
  antiHeroList
    .stream()
    .map(this::convertToDto)
    .collect(Collectors.toList());</pre>
			<p>We will <a id="_idIndexMarker385"/>return the converted list in response, and our method will now look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
@GetMapping
public List&lt;AntiHeroDto&gt; getAntiHeroes() {
  var antiHeroList = StreamSupport
    .stream(service.findAllAntiHeroes().spliterator(),
            false)
    .collect(Collectors.toList());
  return antiHeroList
    .stream()
    .map(this::convertToDto)
    .collect(Collectors.toList());
}</pre>
			<p>We have successfully created mappings on our controller, and our code should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
@AllArgsConstructor
@RestController
@RequestMapping("api/v1/anti-heroes")
public class AntiHeroController {
    private final AntiHeroService service;
    private final ModelMapper mapper;
…
    public AntiHeroDto getAntiHeroById(
      @PathVariable("id") UUID id) {
        return convertToDto(service.findAntiHeroById(id));
    }
    @DeleteMapping("/{id}")
    public void deleteAntiHeroById(
      @PathVariable("id") UUID id) {
        service.removeAntiHeroById(id);
    }
    @PostMapping
    public AntiHeroDto postAntiHero(
       @Valid @RequestBody AntiHeroDto antiHeroDto) {
        var entity = convertToEntity(antiHeroDto);
        var antiHero = service.addAntiHero(entity);
…
        return mapper.map(dto, AntiHeroEntity.class);
    }
}</pre>
			<p>We have <a id="_idIndexMarker386"/>completed our Spring Boot application, we have created our models and DTO that defines the structure of our object, we have built services that are responsible for the business logic, and we have created controllers that map the HTTP requests in our applications, so our endpoint will work <span class="No-Break">as expected.</span></p>
			<p>Still, we can improve our backend in terms of performance, and we can do this with caching mechanisms. In the next section, we will discuss the concepts and application <span class="No-Break">of Redis.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor108"/>Adding Redis for caching</h1>
			<p>In this section, we will now discuss Redis, which can improve the performance of our REST applications. Redis<a id="_idIndexMarker387"/> is an open source, in-memory, key-value data store that <a id="_idIndexMarker388"/>allows data to reside in memory to enable low latency and faster data access. Compared to traditional databases, Redis doesn’t require disk access, having all data cached in the memory, which gives a <span class="No-Break">quicker response.</span></p>
			<p>It is now widely used, especially for large applications that receive millions of requests. It is compatible with different data structures such as strings, lists, sets, hashes, bitmaps, and geospatial and is compatible<a id="_idIndexMarker389"/> with <strong class="bold">Publish/Subscribe</strong> (<strong class="bold">Pub/Sub</strong>), used for real-time <span class="No-Break">chat applications.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor109"/>Installing the Redis server</h2>
			<p>Before <a id="_idIndexMarker390"/>using Redis on our Spring Boot application, we will need to install the Redis server in our terminal. Let’s discuss how to install Redis on different <span class="No-Break">operating systems.</span></p>
			<h3>macOS</h3>
			<p>Redis is<a id="_idIndexMarker391"/> simple to install<a id="_idIndexMarker392"/> in a macOS system; we can use Homebrew to install Redis and execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
brew install redis</pre>
			<p>After <a id="_idIndexMarker393"/>successful installation, we can set the Redis server to start<a id="_idIndexMarker394"/> automatically with the <span class="No-Break">following command:</span></p>
			<pre class="console">
brew services start redis</pre>
			<p>And we have successfully installed and run our Redis server <span class="No-Break">on macOS.</span></p>
			<h3>Ubuntu Linux</h3>
			<p>For<a id="_idIndexMarker395"/> installing Redis on Ubuntu OS, we will execute the<a id="_idIndexMarker396"/> <span class="No-Break">following command:</span></p>
			<pre class="console">
sudo apt-get install redis-server</pre>
			<p>This will automatically install and start the Redis server on port <strong class="source-inline">6739</strong>, and we have successfully installed and run our Redis server <span class="No-Break">on Linux.</span></p>
			<h3>Windows</h3>
			<p>For<a id="_idIndexMarker397"/> installing Redis on Windows, we can install the different <a id="_idIndexMarker398"/>versions from the following link: <a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a>, download the <strong class="source-inline">.zip</strong> or <strong class="source-inline">.msi</strong> file, and extract to your chosen directory. Run the <strong class="source-inline">Redis-server.exe</strong> file to start the Redis server on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">6739</strong></span><span class="No-Break">.</span></p>
			<p>Thus, we have successfully installed and run our Redis server on Windows. We can now use Redis on our Spring <span class="No-Break">Boot application.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor110"/>Configuring Redis on Spring Boot</h2>
			<p>We have <a id="_idIndexMarker399"/>successfully configured and started the <a id="_idIndexMarker400"/>Redis server on our local machine; our next step is to use Redis in our developed Spring Boot project. We’ll now follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li value="1">The first thing we need to do is include the Redis dependency; to achieve this, we need to add the following code to our <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="console">
&lt;!-- Redis --&gt;</pre><pre class="console">
&lt;dependency&gt;</pre><pre class="console">
   &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</pre><pre class="console">
   &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</pre><pre class="console">
   &lt;version&gt;2.4.5&lt;/version&gt;</pre><pre class="console">
&lt;/dependency&gt;</pre><pre class="console">
&lt;dependency&gt;</pre><pre class="console">
   &lt;groupId&gt;redis.clients&lt;/groupId&gt;</pre><pre class="console">
   &lt;artifactId&gt;jedis&lt;/artifactId&gt;</pre><pre class="console">
   &lt;version&gt;3.5.1&lt;/version&gt;</pre><pre class="console">
   &lt;type&gt;jar&lt;/type&gt;</pre><pre class="console">
&lt;/dependency&gt;</pre></li>
			</ol>
			<p>After successfully adding the Redis dependency, we will add our <strong class="bold">Redis configuration</strong> that <a id="_idIndexMarker401"/>will define the connection properties for the Redis server, under the <span class="No-Break"><strong class="source-inline">config</strong></span><span class="No-Break"> package.</span></p>
			<ol>
				<li value="2">Create <a id="_idIndexMarker402"/>a class named <strong class="source-inline">RedisConfig</strong>. We will<a id="_idIndexMarker403"/> use the <strong class="source-inline">@Configuration</strong> annotation to identify whether this class has Bean definition methods that will be bootstrapped on the execution of the application. We will also add the following method to <span class="No-Break">our class:</span><pre class="console">
@Bean</pre><pre class="console">
JedisConnectionFactory jedisConnectionFactory() {</pre><pre class="console">
  RedisStandaloneConfiguration</pre><pre class="console">
    redisStandaloneConfiguration =</pre><pre class="console">
      new RedisStandaloneConfiguration();</pre><pre class="console">
  return new JedisConnectionFactory(</pre><pre class="console">
    redisStandaloneConfiguration);</pre><pre class="console">
}</pre></li>
			</ol>
			<p><strong class="source-inline">jedisConnectionFactory()</strong> is the method used to identify the connection properties for our Redis server; this uses default values since we have not specified <span class="No-Break">connection properties.</span></p>
			<p>Still, if our<a id="_idIndexMarker404"/> Redis server is hosted on a different server, hosted on a different port, or has a username and password, we can use the <span class="No-Break">following methods:</span></p>
			<ul>
				<li><strong class="source-inline">redisStandaloneConfiguration.setHostName("host")</strong>: This sets the<a id="_idIndexMarker405"/> host <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) where the Redis server <span class="No-Break">is running.</span></li>
				<li><strong class="source-inline">redisStandaloneConfiguration.setPort("port")</strong>: This sets the port where the application <span class="No-Break">will connect.</span></li>
				<li><strong class="source-inline">redisStandaloneConfiguration.setUsername("username")</strong>: This sets the username for the <span class="No-Break">Redis server.</span></li>
				<li><strong class="source-inline">redisStandaloneConfiguration.setPassword("password")</strong>: This sets the password for the <span class="No-Break">Redis server.</span></li>
			</ul>
			<p>The <a id="_idIndexMarker406"/>next step is to use the connection factory to create a Redis template; this is used for Redis data interactions. It allows the automatic serialization and deserialization between objects and binary data stored in the <span class="No-Break">Redis server.</span></p>
			<ol>
				<li value="3">We will create a method that will also use the <strong class="source-inline">@Bean</strong> annotation; we will create a new Redis template and set the connection factory with the <span class="No-Break">following code:</span><pre class="console">
RedisTemplate&lt;UUID, Object&gt; template = new RedisTemplate&lt;&gt;();</pre><pre class="console">
template.setConnectionFactory(jedisConnectionFactory());</pre></li>
			</ol>
			<p>After<a id="_idIndexMarker407"/> successfully creating the template instance with the connection factory, we can also define serializers depending on the data structures. If we want to use the default serializer, which is <strong class="source-inline">JdkSerializationRedisSerializer</strong>, we will just return a <span class="No-Break">template instance.</span></p>
			<ol>
				<li value="4">In the <a id="_idIndexMarker408"/>following code snippet, we have used different serializers for different <span class="No-Break">data structures:</span><pre class="console">
@Bean</pre><pre class="console">
  public RedisTemplate&lt;UUID, Object&gt; redisTemplate() {</pre><pre class="console">
    RedisTemplate&lt;UUID, Object&gt; template =</pre><pre class="console">
      new RedisTemplate&lt;&gt;();</pre><pre class="console">
    template.setConnectionFactory(</pre><pre class="console">
      jedisConnectionFactory());</pre><pre class="console">
    template.setKeySerializer(</pre><pre class="console">
      new StringRedisSerializer());</pre><pre class="console">
    template.setHashKeySerializer(</pre><pre class="console">
      new StringRedisSerializer());</pre><pre class="console">
    template.setHashKeySerializer(</pre><pre class="console">
      new JdkSerializationRedisSerializer());</pre><pre class="console">
    template.setValueSerializer(</pre><pre class="console">
      new JdkSerializationRedisSerializer());</pre><pre class="console">
    template.setEnableTransactionSupport(true);</pre><pre class="console">
    template.afterPropertiesSet();</pre><pre class="console">
    return template;</pre><pre class="console">
  }</pre><pre class="console">
}</pre></li>
				<li>The last thing we need to do is add the <strong class="source-inline">@RedishHash</strong> annotation to our entity. This<a id="_idIndexMarker409"/> serves as a mark for objects as an <a id="_idIndexMarker410"/>aggregate root to be stored on the Redis hash; in our example, we will use it on <strong class="source-inline">AntiHeroEntity</strong>, <span class="No-Break">as follows:</span><pre class="console">
@RedishHash("AntiHero")</pre><pre class="console">
public class AntiHeroEntity {</pre><pre class="console">
…</pre><pre class="console">
}</pre></li>
			</ol>
			<p>And this will successfully use the Redis server to cache data on our Spring Boot application as operations <span class="No-Break">are executed.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor111"/>Summary</h1>
			<p>With this, we have reached the end of this chapter. Let’s have a recap of the valuable things you have learned. You have learned how to start the Spring Boot application on a Tomcat server using IntelliJ. You have also known how to create a complete Spring Boot application step by step by creating entities, using Lombok and DTOs, writing services with CRUD logic with the help of JPA repositories, and creating controllers using HTTP annotations and <strong class="source-inline">ModelMapper</strong> for converting entities to DTO, and <span class="No-Break">vice versa.</span></p>
			<p>Lastly, you have also learned how to configure a Redis server and use it on a Spring <span class="No-Break">Boot application.</span></p>
			<p>The skills you have learned here will make your code readable and concise because of the Lombok and <span class="No-Break">JPA repositories.</span></p>
			<p>In the next chapter, we will be learning how to create documentation for our APIs using <strong class="source-inline">springdoc-openapi</strong> and <span class="No-Break">Swagger UI.</span></p>
		</div>
	</body></html>