["```java\ncase class Price(value: BigDecimal) \ncase class OrderId(value: Long) \n\nsealed trait LimitOrder { \n  def id: OrderId \n  def price: Price \n} \n\ncase class BuyLimitOrder(id: OrderId, price: Price)  \n  extends LimitOrder \ncase class SellLimitOrder(id: OrderId, price: Price)  \n  extends LimitOrder \n\ncase class Execution(orderId: OrderId, price: Price) \n\n```", "```java\nobject OrderBook { \n  // all the commands that can be handled by the OrderBook module \n  object Commands { \n    sealed trait Command \n    case class AddLimitOrder(o: LimitOrder) extends Command \n    case class CancelOrder(id: OrderId) extends Command \n  } \n\n  // events are the results of processing a command \n  object Events { \n    sealed trait Event \n    case class OrderExecuted(buy: Execution, sell: Execution) \n      extends Event \n    case object LimitOrderAdded extends Event \n    case object OrderCancelRejected extends Event \n    case object OrderCanceled extends Event \n  } \n\n  // the entry point of the module - the current book and  \n  // the command to process are passed as parameters,  \n  // the new state of the book and the event describing the  \n  // result of processing the command are returned \n  def handle(book: OrderBook, command: Command): (OrderBook, Event) = // omitted for brevity \n} \n\n```", "```java\nobject ThroughputBenchmark { \n\n  def main(args: Array[String]): Unit = { \n    val commandSample = DataCodec.read(new File(args(0))) \n    val commandCount = args(1).toInt \n\n    jvmWarmUp(commandSample) \n\n    val commands = generateCount(commandSample, commandCount) \n\n    val start = System.currentTimeMillis() \n    commands.foldLeft(OrderBook.empty)(OrderBook.handle(_, _)._1) \n    val end = System.currentTimeMillis() \n    val delayInSeconds = (end - start) / 1000.0 \n\n    println { \n      s\"\"\" \n         |Processed ${commands.size} commands \n         |in $delayInSeconds seconds \n         |Throughput: ${commands.size / delayInSeconds} operations/sec\"\"\" \n        .stripMargin \n    } \n  } \n} \n\n```", "```java\nsbt 'project chapter2' 'set javaOptions := Seq(\"-Xmx1G\")' 'runMain highperfscala.benchmarks.ThroughputBenchmark src/main/resources/historical_data 250000'\n\n```", "```java\n object FirstLatencyBenchmark { \n\n  def main(args: Array[String]): Unit = { \n\n    val commandSample = DataCodec.read(new File(args(0))) \n    val (commandsPerSecond, iterations) = (args(1).toInt, args(2).toInt) \n    val totalCommandCount = commandsPerSecond * iterations \n\n    jvmWarmUp(commandSample) \n\n    @tailrec \n    def sendCommands( \n      xs: List[(List[Command], Int)], \n      ob: OrderBook, \n      testStart: Long, \n      histogram: HdrHistogramReservoir): (OrderBook, HdrHistogramReservoir) \n      = \n      xs match { \n        case head :: tail => \n          val (batch, offsetInSeconds) = head \n          val shouldStart = testStart + (1000 * offsetInSeconds) \n\n          while (shouldStart > System.currentTimeMillis()) { \n            // keep the thread busy while waiting for the next batch to be \n            sent \n          } \n\n          val updatedBook = batch.foldLeft(ob) { \n            case (accBook, c) => \n              val operationStart = System.currentTimeMillis() \n              val newBook = OrderBook.handle(accBook, c)._1 \n              val operationEnd = System.currentTimeMillis() \n              // record latency \n              histogram.update(operationEnd - operationStart) \n              newBook \n          } \n\n          sendCommands(tail, updatedBook, testStart, histogram) \n        case Nil => (ob, histogram) \n      } \n\n    val (_, histogram) = sendCommands( \n      // Organizes commands per 1 second batches \n      generateCount(commandSample, totalCommandCount) \n        .grouped(commandsPerSecond).zipWithIndex \n        .toList, \n      OrderBook.empty, \n      System.currentTimeMillis(), \n      new HdrHistogramReservoir()) \n\n    printSnapshot(histogram.getSnapshot) \n  } \n} \n\n```", "```java\n sbt 'project chapter2' 'set javaOptions := Seq(\"-Xmx1G\")' 'runMain highperfscala.benchmarks.FirstLatencyBenchmark src/main/resources/historical_data 45000 10'\n    ... // removed for brevity\n    [info] Processed 450000 commands\n    [info] 99p latency: 1.0 ms\n    [info] 99.9p latency: 1.0 ms\n    [info] Maximum latency: 24 ms \n```", "```java\nhistogram.update(operationEnd - shouldStart) \n\n```", "```java\n sbt 'project chapter2' 'set javaOptions := Seq(\"-Xmx1G\")' 'runMain highperfscala.benchmarks.SecondLatencyBenchmark src/main/resources/historical_data 45000 10'\n    ... // removed for brevity\n    [info] Processed 450000 commands\n    [info] 99p latency: 743.0 ms\n    [info] 99.9p latency: 855.0 ms\n    [info] Maximum latency: 899 ms \n```", "```java\n  generateCount(sampleCommands, totalCommandCount) \n    .grouped(cps.value) \n    .toList.zipWithIndex \n    .flatMap { \n      case (secondBatch, sBatchIndex) => \n        val batchOffsetInMs = sBatchIndex * 1000 \n        val commandIntervalInMs = 1000.0 / cps.value \n        secondBatch.zipWithIndex.map { \n          case (command, commandIndex) => \n            val commandOffsetInMs = \n              Math.floor(commandIntervalInMs * commandIndex).toInt \n            (command, batchOffsetInMs + commandOffsetInMs) \n        } \n    }  \n\n```", "```java\n sbt 'project chapter2' 'set javaOptions := Seq(\"-Xmx1G\")' 'runMain highperfscala.benchmarks.FinalLatencyBenchmark src/main/resources/historical_data 45000 10'\n    [info] Processed 450000 commands\n    [info] 99p latency: 92.0 ms\n    [info] 99.9p latency: 137.0 ms\n    [info] Maximum latency: 145 ms \n```", "```java\n sbt 'project chapter2' 'set javaOptions := Seq(\"-Xmx1G\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:FlightRecorderOptions=defaultrecording=true,dumponexit=true,dumponexitpath=/tmp/order-book.jfr\")' \n```", "```java\n sbt 'project chapter2' 'set javaOptions := Seq(\"-Xmx1G\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:StartFlightRecording=delay=10s,duration=60s,name=Recording,filename=/tmp/order-book.jfr\")' \n```", "```java\n sbt 'project chapter2' 'set javaOptions := Seq(\"-Xmx1G\", \"-XX:+UnlockCommercialFeatures\", \"-XX:+FlightRecorder\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\", \"-XX:FlightRecorderOptions=defaultrecording=true,dumponexit=true,dumponexitpath=/tmp/order-book.jfr\")' 'runMain highperfscala.benchmarks.ThroughputBenchmark src/main/resources/historical_data 2000000'\n    [info] \n    [info] Processed 2000000 commands\n    [info] in 93.276 seconds\n    [info] Throughput: 21441.742784853555 commands/sec \n```", "```java\njmc\n\n```", "```java\nsbt 'project chapter2' 'set   javaOptions := Seq(\"-Xmx1G\")' 'runMain   highperfscala.benchmarks.FinalLatencyBenchmark src/main/resources/historical_data   45000 10'\n\n```", "```java\nsbt 'project chapter2' 'set   javaOptions := Seq(\"-Xmx1G\",   \"-XX:+UseConcMarkSweepGC\")' 'runMainhighperfscala.benchmarks.FinalLatencyBenchmark   src/main/resources/historical_data 45000 10'\n\n```", "```java\nsbt 'project chapter2' 'set   javaOptions := Seq(\"-Xmx1G\", \"-XX:NewSize=750M\")' 'runMain   highperfscala.benchmarks.FinalLatencyBenchmark   src/main/resources/historical_data 45000 10'\n\n```", "```java\nsbt 'project chapter2' 'set   javaOptions := Seq(\"-Xmx1G\", \"-XX:NewSize=750M\", \"-XX:+UseConcMarkSweepGC\")'   'runMain highperfscala.benchmarks.FinalLatencyBenchmark   src/main/resources/historical_data 45000 10'\n\n```", "```java\n@BenchmarkMode(Array(Throughput)) \n@OutputTimeUnit(TimeUnit.SECONDS) \nclass CancelBenchmarks { \n\n  @Benchmark \n  def cancelLastOrderInLine(b: BookWithLargeQueue): (OrderBook, Event) = OrderBook.handle(b.book, b.cancelLast) \n\n  @Benchmark \n  def cancelFirstOrderInLine(b: BookWithLargeQueue): (OrderBook, Event) = OrderBook.handle(b.book, b.cancelFirst) \n\n  @Benchmark \n  def cancelNonexistentOrder(b: BookWithLargeQueue): (OrderBook, Event) = OrderBook.handle(b.book, b.cancelNonexistent) \n} \n\nobject CancelBenchmarks { \n\n  @State(Scope.Benchmark) \n  class BookWithLargeQueue { \n    private val p = Price(BigDecimal(1.00)) \n    private val firstId: Int = 1 \n    private val defaultCancelLast = CancelOrder(OrderId(-1)) \n\n    @Param(Array(\"1\", \"100\", \"1000\")) \n    var enqueuedOrderCount: Int = 0 \n\n    var book: OrderBook = OrderBook.empty \n\n    @Setup(Level.Trial) \n    def setup(): Unit = { \n      if (enqueuedOrderCount < 0) \n        sys.error(s\"Invalid enqueued order count = $enqueuedOrderCount\") \n      assert(book == OrderBook.empty) \n      assert(cancelLast == defaultCancelLast) \n\n      cancelLast = CancelOrder(OrderId(enqueuedOrderCount)) \n      book = { \n        (firstId to enqueuedOrderCount).foldLeft(OrderBook.empty) { \n           case (ob, i) => \n             OrderBook.handle(ob, AddLimitOrder(BuyLimitOrder(OrderId(i), \n             p)))._1 \n         } \n      } \n\n      assert(cancelLast != defaultCancelLast) \n      if (enqueuedOrderCount > 0) \n        assert(book.bids.head._2.size == enqueuedOrderCount, \n          s\"Book built incorrectly! Expected book to contain \" + \n            s\"$enqueuedOrderCount bids for $p, but actual book is $book\") \n   } \n\n    var cancelLast: CancelOrder = defaultCancelLast \n    val cancelFirst: CancelOrder = CancelOrder(OrderId(firstId)) \n    val cancelNonexistent: CancelOrder = CancelOrder(OrderId(-1)) \n  } \n} \n\n```", "```java\nsbt 'project chapter2' 'jmh:run -help'\n\n```", "```java\nsbt 'project chapter2' 'jmh:run CancelBenchmarks -wi 3 -w 5s -i 30 -r 10s -jvmArgs \"-Xmx1G -Xms1G\" -gc true -foe true -p enqueuedOrderCount=1,10,50,100'\n\n```"]