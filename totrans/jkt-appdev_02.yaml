- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contexts and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Contexts and Dependency Injection** (**CDI**) is a powerful dependency injection
    framework that allows us to easily integrate different parts of our Jakarta EE
    applications. CDI beans can have different scopes, allowing their life cycle to
    be managed automatically by the Jakarta EE runtime. They can be easily injected
    as dependencies by using a simple annotation. CDI also includes an event mechanism
    to allow decoupled communication between different parts of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI bean scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI Lite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Code samples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch02_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch02_src).
  prefs: []
  type: TYPE_NORMAL
- en: Named beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDI provides us with the ability to name our beans via the `@Named` annotation.
    Named beans allow us to easily inject our beans into other classes that depend
    on them (see the next section) and to easily refer to them from Jakarta Faces
    via the unified expression language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta Faces is covered in detail in *Chapters 6* and *7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the `@Named` annotation in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, all we need to do to name our class is to decorate it with the
    `@Named` annotation. By default, the name of the bean will be the class name with
    its first letter switched to lowercase. In our example, the name of the bean would
    be `customer`. If we wish to use a different name, we can do so by setting the
    `value` attribute of the `@Named` annotation. For example, if we wanted to use
    the name `customerBean` for our bean, we could have done so by modifying the `@Named`
    annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could simply use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the `value` attribute name does not need to be specified, if we don’t
    use an attribute name, then `value` is implied.
  prefs: []
  type: TYPE_NORMAL
- en: 'This name can be used to access our bean from Jakarta Faces pages using the
    unified expression language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the `firstName` and `lastName` properties or our `Customer`
    named bean are bound to two text input fields in our Jakarta Faces page.
  prefs: []
  type: TYPE_NORMAL
- en: 'When deployed and executed, our simple application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – CDI named beans in action](img/B21231_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – CDI named beans in action
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how we can name our CDI beans, we will focus our attention
    on the dependency injection capabilities of CDI.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@Inject` annotation, which can be used to inject instances of CDI beans into
    any dependent objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jakarta Faces applications typically follow the **Model-View-Controller** (**MVC**)
    design pattern. As such, frequently some Jakarta Faces managed beans take the
    role of controllers in the pattern, while others take the role of the model. This
    approach typically requires the controller-managed bean to have access to one
    or more of the model-managed beans. CDI’s dependency injection capabilities make
    injecting beans into one another very simple, as illustrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all we had to do to initialize our `Customer` instance was to annotate
    it with the `@Inject` annotation. When the bean is constructed by the application
    server, an instance of the `Customer` bean is automatically injected into this
    field. Notice that the injected bean is used in the `saveCustomer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in this section, CDI dependency injection is very simple. We
    simply need to annotate the instance variable of the class we wish to inject with
    the `@``Inject` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some instances, the type of bean we wish to inject into our code may be an
    interface or a Java superclass. However, we may be interested in injecting a specific
    subclass or a class implementing the interface. For cases like this, CDI provides
    qualifiers we can use to indicate the specific type we wish to inject into our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: A CDI qualifier is an annotation that must be decorated with the `@Qualifier`
    annotation. This annotation can then be used to decorate the specific subclass
    or interface implementation we wish to qualify. Additionally, the injected field
    in the client code needs to be decorated with the qualifier as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose our application could have a special kind of customer; for example,
    frequent customers could be given the status of premium customers. To handle these
    premium customers, we could extend our `Customer` named bean and decorate it with
    the following qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, qualifiers are standard annotations. They typically
    have retention of runtime and can target methods, fields, parameters, or types,
    as illustrated in the preceding example. The only difference between a qualifier
    and a standard annotation however is that qualifiers are decorated with the `@``Qualifier`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our qualifier in place, we need to use it to decorate the specific
    subclass or interface implementation, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have decorated the specific instance, we need to qualify it. We can
    use our qualifiers in the controller to specify the exact type of dependency we
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since we used our `@Premium` qualifier to annotate the `customer` field, an
    instance of `PremiumCustomer` is injected into that field, since this class is
    also decorated with the `@``Premium` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as our Jakarta Faces pages go, we simply access our named bean as usual
    using its name, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the default name for our bean, which is the class
    name with the first letter switched to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: Our simple application renders and acts just like a “plain” Jakarta Faces application,
    as far as the user is concerned. See *Figure 2**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Premium customer data displayed in the browser](img/B21231_2_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Premium customer data displayed in the browser
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to use CDI qualifiers to inject different implementations
    of the same type, we’ll focus our attention on CDI scopes.
  prefs: []
  type: TYPE_NORMAL
- en: CDI bean scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDI stands for “Contexts and Dependency Injection,” CDI Beans have a scope which
    defines their lifecycle, their scope determines when the Jakarta EE runtime creates
    and destroys CDI beans. “Contexts” in “Contexts and Dependency Injection” refers
    to CDI scopes. When a CDI bean is needed, either because of injection or because
    it is referred to from a Jakarta Faces page, CDI looks for an instance of the
    bean in the scope it belongs to and injects it into the dependent code. If no
    instance is found, one is created and stored in the appropriate scope for future
    use. The different scopes are the context in which the bean exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the different valid CDI scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scope** | **Annotation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Request | `@``RequestScoped` | Request-scoped beans are shared through the
    duration of a single request. A single request could refer to an HTTP request,
    an invocation to a method in an EJB, a web service invocation, or sending a JMS
    message to a message-driven bean. |'
  prefs: []
  type: TYPE_TB
- en: '| Conversation | `@``ConversationScoped` | The conversation scope can span
    multiple requests, but is typically shorter than the session scope. |'
  prefs: []
  type: TYPE_TB
- en: '| Session | `@``SessionScoped` | Session-scoped beans are shared across all
    requests in an HTTP session. Each user of an application gets their own instance
    of a session-scoped bean. |'
  prefs: []
  type: TYPE_TB
- en: '| Application | `@``ApplicationScoped` | Application-scoped beans live through
    the whole application lifetime. Beans in this scope are shared across user sessions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dependent | `@``Dependent` | Dependent-scoped beans are not shared. Any time
    a dependent scoped bean is injected, a new instance is created. |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – CDI scopes
  prefs: []
  type: TYPE_NORMAL
- en: CDI’s **request scope** does not necessarily refer to an HTTP request; it could
    simply be an invocation on an EJB method, a web service invocation, or sending
    a JMS message to a message-driven bean.
  prefs: []
  type: TYPE_NORMAL
- en: The `jakarta.enterprise.context.Conversation` injected. At the point, where
    we want to start the conversation, the `begin()` method must be invoked on this
    object. At the point where we want to end the conversation, its `end()` method
    must be invoked on it.
  prefs: []
  type: TYPE_NORMAL
- en: CDI’s **session scope** ties the life cycle of a CDI bean to an HTTP session.
    Session-scoped CDI beans are created when they are first injected, and stick around
    until the HTTP session is destroyed, usually when a user logs out of a web application
    or closes the browser.
  prefs: []
  type: TYPE_NORMAL
- en: CDI’s **application scope** ties the life cycle of a CDI bean to the life of
    an application. A single instance of each application-scoped bean exists per application,
    which means that the same instance is accessible to all HTTP sessions.
  prefs: []
  type: TYPE_NORMAL
- en: CDI’s **dependent scope** is the default scope if none is explicitly specified.
    A new instance of a dependent-scoped bean is instantiated every time it is needed,
    usually when it is injected into a class that depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: For most of CDI’s scopes, simply annotating our CDI bean with the desired scope
    annotation is all we need to do. The Jakarta EE runtime then manages the bean’s
    life cycle behind the scenes. The conversation scope requires a bit more work
    on our part, namely we need to indicate when a conversation starts and ends. For
    this reason, we will use the conversation scope to illustrate the usage of CDI
    scopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wanted to have a user enter some data that would be stored in a
    single named bean; however, this bean has several fields. Therefore, we would
    like to split the data entry into several pages. For cases like this, CDI’s conversation
    scope is a good solution. The following example illustrates how to use CDI’s conversation
    scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We declare that our bean is conversation scoped by decorating it with the `@ConversationScoped`
    annotation. Conversation-scoped beans also need to implement `java.io.Serializable`.
    Other than these two requirements, there is nothing special about our code; it
    is a simple Java class with private properties and corresponding getter and setter
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to having our conversation-scoped bean injected, our client code
    must also have an instance of `jakarta.enterprise.context.Conversation` injected,
    as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Conversations can be either **long-running** or **transient**. Transient conversations
    end at the end of a request. Long-running conversations span multiple requests.
    In most cases, we will use long-running conversations to hold a reference to a
    conversation-scoped bean across multiple HTTP requests in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: A long-running conversation starts when the `begin()` method is invoked in the
    injected `Conversation` instance, and it ends when we invoke the `end()` method
    on this same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jakarta Faces pages simply access our CDI beans as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we navigate from one page to the next, we keep the same instance of our conversation-scoped
    bean; therefore, all user-entered data remains. When the `end()` method is called
    on our Conversation bean, the conversation ends and our conversation-scoped bean
    is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping our bean in the conversation scope simplifies the task of implementing
    “wizard-style” user interfaces, where data can be entered across several pages.
    See *Figure 2**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF2.3 – Page 1 of CDI Conversation Scope Example](img/B21231_2_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Page 1 of CDI Conversation Scope Example
  prefs: []
  type: TYPE_NORMAL
- en: In our example, after clicking the **Next** button on the first page, we can
    see our partially populated bean in the application server log.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the second page in our simple wizard is displayed, as shown in
    *Figure 2**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF2.4 – Page 2 of CDI Conversation Scope Example](img/B21231_2_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Page 2 of CDI Conversation Scope Example
  prefs: []
  type: TYPE_NORMAL
- en: When clicking **Next**, we can see that additional fields are populated in our
    conversation-scoped bean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we submit the third page in our wizard (not shown), additional bean properties
    corresponding to the fields on that page are populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are at the point where we don’t need to keep the customer information
    in memory anymore, we need to call the `end()` method on the Conversation bean
    that was injected into our code. This is exactly what we do in our code before
    displaying the confirmation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After the request to show the confirmation page is completed, our conversation-scoped
    bean is destroyed, since we invoked the `end()` method in our injected `Conversation`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen all scopes supported by CDI, we will turn our attention
    to how we can implement loosely coupled communication via CDI events.
  prefs: []
  type: TYPE_NORMAL
- en: CDI events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDI provides event-handling facilities. Events allow loosely coupled communication
    between different CDI beans. A CDI bean can fire an event, then one or more event
    listeners handle the event.
  prefs: []
  type: TYPE_NORMAL
- en: Firing CDI events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example is a new version of the `CustomerInfoController` class
    we discussed in the previous section. The class has been modified to fire an event
    every time the user navigates to a new page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, to create an event, we inject an instance of `jakarta.enterprise.event.Event`.
    This class uses generics; therefore, we need to specify its type. The type of
    the `Event` class can be any class implementing `java.io.Serializable`. In our
    case, we are passing an instance of a simple POJO we wrote as the type parameter,
    our POJO is called `NavigationInfo` and has two properties, one of type `Customer`
    and a `String` containing the page the user is navigating to. Recall from the
    previous sections that each of the methods on our `CustomerInfoController` class
    triggers navigation from one page in the application to another. In this version
    of the controller, a CDI event is fired every time we navigate to a new page.
    In each case, we create a new instance of `NavigationInfo`, populate it, then
    fire the event by invoking the `fire()` method on our instance of `jakarta.enterprise.event.Event`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling CDI events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle CDI events, the CDI bean handling the event needs to implement an
    `NavigationInfo`, as can be seen in the declaration of our event in the preceding
    section. To handle the event, the observer method needs to annotate the corresponding
    parameter with the `@Observes` annotation, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example event handler, the `handleNavigationEvent()` method takes an
    instance of `NavigationInfo` as a parameter. Notice that this parameter is annotated
    with `@Observes`. This causes the method to be invoked automatically by CDI every
    time an event of type `NavigationInfo` is fired. Notice that we never explicitly
    call this method; the Jakarta EE runtime invokes it automatically whenever a navigation
    event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: CDI events allow us to implement loosely coupled communication between CDI beans.
    In our example, notice that our `CustomerController` CDI bean has no direct reference
    to `NavigationEventListener`. In general, the CDI bean firing the event does not
    need to know any details about the listeners; it just fires the event and CDI
    takes over the details.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have only one event listener, but in practice, we can have
    as many event listeners as we need.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CDI has the ability to fire events asynchronously. Firing events asynchronously
    can help with performance, since various observer methods can be invoked concurrently.
    Firing an event asynchronously is very similar to firing an event synchronously.
    The only syntactical difference is that instead of invoking the `fire()` method
    in our `Event` instance, we invoke its `fireAsync()` method. The following example
    illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Observer methods to handle asynchronous events are identical to their synchronous
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Event ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another new feature introduced in CDI 2.0 is the ability to specify in what
    order our observer methods handle CDI events. This can be accomplished via the
    `@Priority` annotation, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `@Priority` annotation takes an argument of type `int`. This argument specifies
    the priority for the observer method. The highest priority is defined by the `APPLICATION`
    constant defined in the `Interceptor.Priority` class. This is the priority we
    gave to the observer method in our example. Lower-priority values take precedence
    and the default priority is `Interceptor.Priority.APPLICATION +` `100`.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 1*](B21231_01.xhtml#_idTextAnchor014), in addition
    to the full Jakarta EE specification, there are two Jakarta EE profiles we can
    use if we are developing simpler applications that don’t need the full power of
    Jakarta EE. There’s the Web Profile, suitable for web applications, and the Core
    Profile, suitable for microservices. The Core Profile includes CDI support but
    does not support all of CDI’s features. This lightweight version of CDI included
    in the Jakarta EE Core Profile is called CDI Lite.
  prefs: []
  type: TYPE_NORMAL
- en: CDI Lite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jakarta EE Core Profile contains a subset of the full CDI specification,
    named, appropriately enough, CDI Lite. Most of the changes of CDI Lite are at
    the implementation level; namely, some functionality that the full CDI implementation
    performs at runtime is moved to build time, allowing applications utilizing CDI
    Lite to initialize faster.
  prefs: []
  type: TYPE_NORMAL
- en: CDI Lite is primarily meant to be used in microservices applications, implementing
    functionality as RESTful web services. Since REST applications are typically stateless,
    not all CDI scopes are applicable when working on this type of application. For
    this reason, the session and conversation scopes are not available when using
    CDI Lite. This is the primary limitation of CDI Lite when compared to the full
    CDI specification.
  prefs: []
  type: TYPE_NORMAL
- en: We only need to be concerned with CDI Lite limitations when deploying our code
    to a Jakarta EE Core Profile implementation. The Jakarta EE Web Profile and the
    full Jakarta EE platform contain full CDI functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we provided an introduction to CDI, an integral part of the
    Jakarta EE specification. We looked into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We covered how Jakarta Faces pages can access CDI-named beans via the unified
    expression language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also covered how CDI makes it easy to inject dependencies into our code via
    the `@``Inject` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we explained how we can use qualifiers to determine what specific
    implementation of a dependency to inject into our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also discussed all the scopes that a CDI bean can be placed into, allowing
    us to delegate the life cycle of CDI beans to the Jakarta EE runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed how to implement loosely coupled communication between CDI beans
    via CDI’s event handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we discussed CDI Lite, a lightweight version of CDI suitable for microservices
    development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI is an integral part of Jakarta EE, as it is used to integrate different
    layers of our Jakarta EE applications.
  prefs: []
  type: TYPE_NORMAL
