- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures are important components that contribute to, or detract from,
    the performance of our Java applications. They are foundational parts that are
    used throughout our programs and can help us organize and manipulate data efficiently.
    Data structures are essential for optimizing the performance of our Java applications
    because they can ensure that our data access, memory management, and caching are
    efficient. Proper use of data structures can lead to algorithm efficiency, the
    scalability of our solutions, and the safety of our threads.
  prefs: []
  type: TYPE_NORMAL
- en: The significance of data structures can be evidenced by reducing the time complexity
    of operations. With proper data structure implementation, we can improve the predictability
    and consistency of our application’s performance. In addition to improving the
    performance of our Java applications, properly chosen data structures result in
    increased code readability, making them easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacks and queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should understand how specific data structures,
    such as **lists**, **arrays**, **trees**, **stacks**, and **queues**, can impact
    the performance of Java applications. You will have the opportunity to gain hands-on
    experience with Java code that demonstrates how to improve performance through
    proper data structure selection and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need to be
    able to load, edit, and run Java code. If you haven’t set up your development
    environment, please refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A list is a fundamental data structure in the Java programming language. They
    give us the ability to easily create, store, and manipulate an ordered collection
    of elements. This data structure uses the `java.util.list` interface and extends
    the `java.util.Collection` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a close look at lists, why and when to use them,
    and techniques for getting the highest performance out of them.
  prefs: []
  type: TYPE_NORMAL
- en: Why use lists?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps the most common way of explaining what the list data structure can
    be used for is as a check-off/to-do list or a grocery shopping list. We create
    lists in our programs because we want to leverage one or more of its advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ordered elements**: Lists are used to maintain the order of our elements,
    even as we add new elements. This allows us to manipulate our data in a specific
    sequence. Consider a system log that has new entries added with date and time
    stamps. We would want those entries to be maintained in a specific order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic resizing**: Lists can be used to dynamically resize themselves
    as our programs add and remove elements. This is especially true in **ArrayLists**,
    which are covered later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Positional data access**: Lists allow us to obtain random access efficiently
    by using the element’s index, also referred to as **positional data**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duplicate elements**: Lists allow us to have duplicate elements. So, if this
    is important for your use case, then you might consider using a list as your data
    structure selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach` method. We will look at an example of this in the next section of
    this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinkedList`, `ArrayList`, or `Vector` list type. These list types offer unique
    characteristics. The following table shows the different characteristics of these
    list types. Pay special attention to the performance row:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  | **LinkedList** | **ArrayList** | **Vector** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Data structure** | Doubly-linked list | Dynamic array | Dynamic array |'
  prefs: []
  type: TYPE_TB
- en: '| **Use case** | To frequently manipulate data | For fast reads | When thread
    safety is required |'
  prefs: []
  type: TYPE_TB
- en: '| **Performance** | + Adds and deletes- Access by index | - Adds and deletes+
    Access by index | - Adds and deletes- Access by index |'
  prefs: []
  type: TYPE_TB
- en: '| **Thread safety** | No, not by default | No, not by default | Yes, by default
    |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – Lists
  prefs: []
  type: TYPE_NORMAL
- en: When choosing between `LinkedList`, `ArrayList`, and `Vector` list types, we
    should consider the requirements based on our use case. For example, if our use
    case includes frequent adds and deletes, then `LinkedList` might be the best option.
    Alternatively, if we have infrequent adds and deletes, but heavy reads, then `ArrayList`
    is likely our best option. Finally, if we are most concerned about thread safety,
    `Vector` might be our best option.
  prefs: []
  type: TYPE_NORMAL
- en: Important note about thread safety
  prefs: []
  type: TYPE_NORMAL
- en: While `LinkedList` and `ArrayList` are not thread-safe by default, they can
    be made thread-safe by explicitly synchronizing access. This should prevent concurrent
    access-related data corruption, but it will likely lead to lower performance regarding
    your Java application.
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.List` interface, which the list implements. These built-in methods
    include functionality for searching, adding, and removing elements. A full list
    of `java.util.Llist` methods are available in the official Java documentation:
    [https://docs.oracle.com/javase/8/docs/api/java/util/List.html](https://docs.oracle.com/javase/8/docs/api/java/util/List.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve reviewed why we should use lists, let’s look at examples of common
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Common list implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at implementation examples for `ArrayList`, `LinkedList`,
    and `Vector`.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our first list implementation example is an `ArrayList` list type of numbers.
    We will assume that this is part of a human resources (HR) system that stores
    start dates, end dates, and length of service. As shown in the following code,
    we must import both `java.util.ArrayList` and `java.util.List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have our class declaration and main method. Here, we must create an
    `ArrayList` list type called `hr_numbers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: hr_numbers.add(1983);
  prefs: []
  type: TYPE_NORMAL
- en: 'hr_numbers.get method, and use them to calculate a value to add as a third
    element to ArrayList:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last section of the code is a `for` loop. This iterates through the list
    and provides output to the terminal window:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the program’s output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our output is as expected; we simply print each of the three
    elements to the terminal window using a `for-each` loop.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: for-each loops
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Java 5 introduced an enhanced `for` loop called the `for-each` loop. We can
    use this loop to iterate through elements without using an explicit iterator or
    index. This makes our code quicker to write and more readable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: LinkedList example
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our `LinkedList` implementation example is a simple `get`, `remove`, `contains`,
    and `size` methods. As you can see, we import both `java.util.LinkedList` and
    `java.util.List`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have our class declaration and the main method. Here, we create a
    `LinkedList` list type called `petNames`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: petNames.add("Brandy");
  prefs: []
  type: TYPE_NORMAL
- en: petNames.add("Muzz");
  prefs: []
  type: TYPE_NORMAL
- en: petNames.add("Java");
  prefs: []
  type: TYPE_NORMAL
- en: 'petNames.get method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section of the code is a `for-each` loop that iterates through the
    list and provides output to the terminal window:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the loop’s output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove an element from our `LinkedList` by using the `remove` method,
    as illustrated here. As you can see, after calling the `remove` method, `Brandy`
    is no longer an element in `LinkedList`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of our code calls the `contains` method to check if a specific
    value is found in `LinkedList`. Since we previously removed this pet from `LinkedList`,
    the Boolean result is `false`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `println` statement is as expected:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This final section of our code demonstrates the use of the `size` method. Here,
    we make a call to that method, which returns an integer. We use that value in
    our final output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The final output reflects the expected size of our `LinkedList`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve looked at how to implement `ArrayList` and `LinkedList`, let’s
    look at our final example, **Vector**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Vector example
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Our last list implementation example is a `Vector` list type. As you will see,
    `Vector` is similar to `ArrayList`. We implement them as dynamic arrays so that
    we can benefit from efficient random access to our vector’s elements. Vectors
    have the added benefit of being thread-safe by default. This is due to the default
    synchronization we previously discussed. Let’s look at some example code.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our example program will store a set of lucky numbers. It starts by importing
    the `java.util.Vector` and `java.util.Enumeration` packages:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have our class declaration and the main method. Here, we create a
    `Vector` list type called `luckyNumbers` that will store integers:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: luckyNumbers.add(8);
  prefs: []
  type: TYPE_NORMAL
- en: luckyNumbers.add(19);
  prefs: []
  type: TYPE_NORMAL
- en: 'luckyNumbers.get method. Note that indices start at zero (0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section of the code uses a legacy approach for iterating through a
    `Vector` list type. The enumeration approach can be used in place of an enhanced
    or `for-each` loop. Vectors, in and of themselves, are considered a list type
    that’s falling out of common use. The following code iterates through the list
    and provides output to the terminal window:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the program’s output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove an element from our `Vector` by using the `removeElement` method,
    as illustrated here. After calling the `removElement` method, the lucky number
    19 is removed as an element from `Vector`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of our code calls the `contains` method to check if a specific
    value is found in `Vector`. Since we previously removed this lucky number from
    `Vector`, the Boolean result is `false`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `println` statement is as expected:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This final section of our code demonstrates the use of the `size` method. Here,
    we make a call to that method, which returns an integer. We use that value in
    our final output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The final output reflects the expected size of our `LinkedList` list type:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This section provided examples of using lists for `ArrayList`, `LinkedList`,
    and `Vector`. There are additional implementations that you can consider, including
    `CopyOnWriteArrayList`, `CopyOnWriteArraySet`, and `LinkedHashSet`. Stacks are
    another implementation and are covered later in this chapter. Next, we will look
    at achieving high performance with lists.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: High performance with lists
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can improve the performance of our Java apps when
    using lists. The following code example implements a `LinkedList` list type of
    integers. Here, we’ll create a `LinkedList` list type, add four elements to it,
    and then iterate through the list, printing each element to the screen:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this first section is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section of code removes an element using the `remove` method – specifically,
    the first occurrence of 8:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code segment performs two checks using the `contains` method.
    First, it checks for a 3 and then an 8\. The results are printed on the screen:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this section of code is shown here:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This final segment of code iterates through `LinkedList` and prints its values:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this final section of code is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to see what we can do to modify our code to improve overall
    performance. There are several techniques we can use:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`List<Integer>` objects. The `Integer` class is essentially a wrapper around
    the primitive `int` data type. The `Integer` object only contains one field of
    the `int` type. Here’s how we can modify our code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`LinkedList`, we should use an `java.util.Iterator` package. This is an efficient
    method of avoiding errors such as **ConcurrentModificationsException**, which
    is thrown when we attempt to make two simultaneous modifications to a collection.
    Here’s how we can write such an iterator:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The fully revised example is available at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example5.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example5.java).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should now have increased knowledge and confidence in using lists in Java
    to help improve the performance of your applications. Next, we will look at arrays
    and how to use them optimally.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Improving performance with arrays
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Previously, we discussed `ArrayList`; in this section, we will focus on arrays.
    There are key differences in these two data types: arrays have a fixed size, while
    ArrayLists do not. In this section, we will review the characteristics of arrays
    and how to improve the performance of our Java applications when implementing
    arrays.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Array characteristics
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are four primary characteristics of arrays. Let’s take a look:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Size**: The size of an array is determined when it’s created. It cannot be
    changed when the application is running. This fixed-sized characteristic is also
    referred to as **static**. Here’s the syntax for creating an array:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we explicitly specify a size of `10` as part of the array’s
    declaration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Homeogeneous**: Homeogeneous means that all data in an array must be of the
    same kind. As with the previous example, we created an array of integers. We could
    have used strings, but we cannot mix data types in a single array. We can also
    have an array of objects and arrays of arrays.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexing**: This should go without saying, so as a reminder, our indexes
    start with 0, not 1\. So, the array that we previously created has 10 elements,
    indexed from 0 to 9.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous memory**: One of the great efficiencies offered to us by arrays
    is random access. This efficiency stems from the fact that all elements in an
    array are stored in contiguous memory. In other words, the elements are stored
    in memory locations next to each other.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a firm understanding of array characteristics, let’s explore
    some code that implements this important data structure.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing arrays
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This section features a basic Java application that implements an array of planets
    using the `String` data type. As we walk through the code, we will create the
    array, access and print array elements, use the length method, access an array
    element using its index, and modify an array.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This first section of code creates an array of **strings**:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we created an array of eight strings. This next section of
    code demonstrates accessing and printing all elements of an array:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output of the preceding code snippet:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `length` method to determine the size of our array. It might
    seem like we don’t need to determine the size since it is determined when the
    array is created. Often, we don’t know the initial size of our arrays because
    they’re based on external data sources. Here’s how to determine an array’s size:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is shown here:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will look at how to access an array element by referencing its index
    position within the array:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous two lines of code is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we printed the third element in our array by using an index
    reference of `2`. Remember, our indexes start with 0.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our last segment of code shows how we can modify an element in our array:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is shown here. As you can see, the new name
    for the element at index position 1 is reflected in the output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The fully revised example is available at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example6.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example6.java).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you’ve learned how to implement arrays in Java, let’s look at some
    approaches to improving our application’s performance in terms of array usage.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: High performance with arrays
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As we have seen with lists, our implementation approaches to data structures
    can have a direct impact on our Java application’s performance. This section documents
    several strategies and best practices for optimizing array-related Java code.
    These strategies can be categorized as algorithmic optimization, data structures,
    memory management, parallel processing, vectorization, caching, and benchmarking
    and profiling. Let’s look at each of them.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Algorithmic optimization
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever we select algorithms, we should ensure they are the most appropriate
    for the data types we’re using. For example, it’s important to select the most
    efficient sorting algorithm (that is mergesort, quicksort, and so on) based on
    our array’s size and characteristics. In addition, binary searches can be implemented
    when searching in sorted arrays.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional information is provided in [*Chapter 5*](B21942_05.xhtml#_idTextAnchor088)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The core of this chapter focuses on selecting the right data structure based
    on your use case and requirements. When it comes to arrays, we should select them
    when we need frequent read access; here, our dataset can be of a fixed size. In
    addition, knowing when to select `ArrayList` over `LinkedList` is equally important.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever possible, we should avoid creating temporary objects to support array
    operations. Instead, we should reuse arrays or use methods such as `Arrays.copyOf`
    or `System.arraycopy` for greater efficiency.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional information is provided in [*Chapter 8*](B21942_08.xhtml#_idTextAnchor143)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Parallel processing
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: When we must sort and process large arrays, it can be beneficial to employ Java’s
    parallel processing capabilities, such as by using `parallelSort`. You should
    consider using multithreading with concurrent array processing. This is especially
    important for large arrays.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional information is provided in [*Chapter 9*](B21942_09.xhtml#_idTextAnchor159)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Vectorization
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the context of Java arrays, vectorization is a technique that involves performing
    operations on more than one element of an array simultaneously. This typically
    includes optimizing modern central processors. The goal is to increase array processing
    operations. This is often referred to as `java.util.Vector` class, which was introduced
    with Java 16.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Vectorization can provide significant performance benefits, especially with
    large arrays. This is exponentially true when operations can be parallelized.
    There are limits to what can be vectorized, such as dependencies and complex operations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A proven performance approach is to optimize array access patterns to support
    cache locality. This can be achieved by accessing contiguous memory locations.
    Another approach is to minimize pointer aliasing to the best extent possible.
    While point aliasing might support compiler optimizations, local variables or
    array indexes should be used instead for optimal performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional information is provided in [*Chapter 8*](B21942_08.xhtml#_idTextAnchor143)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Benchmarking and profiling
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Whenever possible, we should conduct benchmarking so that we can compare our
    approach to array operations. Armed with this analysis, we can select the most
    efficient and proven approach. As part of our analysis, we can employ profiling
    tools to help identify performance bottlenecks specific to our array operations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional information is provided in [*Chapter 13*](B21942_13.xhtml#_idTextAnchor227)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you’ve learned how to improve Java application performance when dealing
    with arrays, let’s look at how this can be done with trees.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Improving performance with trees
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A **tree** is a hierarchical data structure that consists of parent and child
    **nodes**, analogous to that of a physical tree. The topmost node is referred
    to as the **root** and there can only be one in a tree data structure. The nodes
    are the foundational components of this data structure. Each node contains both
    data and references to child nodes. There are additional terms that you should
    be familiar with regarding trees. A **leaf node** has no child. Any node and its
    descendants can be considered a **subtree**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples of a tree structure
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As shown in the following example, we can implement trees as objects or classes:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet defines a `TreeNode` class that can be used along
    with another class for tree operation management. We need to create our tree in
    our `main()` method. Here’s an example of how to do that:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert data into our tree, we can use the following code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To use or search our tree, we can perform a binary search for an element in
    our tree using code similar to the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: A full working example is available at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example7.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example7.java).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: High-performance considerations
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The tree data structure can be very complex, so we should consider our Java
    application’s overall performance, especially regarding algorithms that manipulate
    our trees. Additional considerations can be categorized as type, safety, iteration,
    memory, operations, and caching. Let’s briefly look at each of these categories.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Type
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s important to carefully construct our trees so that they are as balanced
    as possible. We should be mindful of the **tree’s height**, which is the longest
    path from the root to a leaf node. The data requirements should be reviewed so
    that we can select the most optimal tree. For example, we can use a **binary search
    tree**, which can provide us with efficient searches.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Safety
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As with other data structures, you should always implement thread safety protocols
    or, at a minimum, use concurrent tree structures.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Iteration operations can often present bottlenecks, calling for an optimization
    strategy. In addition, the use of recursive algorithms should be minimized to
    improve overall performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Memory
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Generally, and as it applies to trees specifically, we should minimize object
    creation and overhead. We should strive to do our best to manage memory efficiently.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional information is provided in [*Chapter 8*](B21942_08.xhtml#_idTextAnchor143)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There are several things we can do to optimize operations. For example, we can
    use batch operations to reduce processing overhead. Optimizing our algorithms
    can help us avoid excessive processing and data updates.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional information is provided in [*Chapter 5*](B21942_05.xhtml#_idTextAnchor088)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We can optimize the way our data is laid out to maximize cache locality. Our
    goal with caching is to reduce memory access times. In addition, we can access
    nearly all nodes in memory to further improve performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional information is provided in [*Chapter 8*](B21942_08.xhtml#_idTextAnchor143)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Improving performance with stacks and queues
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stacks** and **queues** are almost always grouped because they can both be
    used to manage and manipulate collections of data elements. They are both linear
    stacks; that’s where their similarities end. While grouped, there are key differences
    in how they operate. In this section, we’ll look at how to implement stacks and
    queues and how to optimize them for high-performance Java applications.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing stacks
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Stacks are linear data structures that use the `push` elements to the top, `peek`
    to view an element, and `pop` to remove the top element.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to create a stack in Java. You will
    notice that we start by importing the `java.util.Stack` package:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a simple implementation of a Java stack. The purpose of
    the program is to process bank transactions. Now that you’ve seen this simple
    implementation, let’s see how we can refine our code for greater performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Improving the performance of stacks
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using our previous example as a starting point, we will refine it for higher
    performance at runtime. We’ll start by using a custom stack implementation. This
    type of refinement is especially effective when use cases involve a high volume
    of transactions. As you can see, we must import the `java.util.EmptyStackException`
    package.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we must declare a class and use an array with a **double** data type.
    We’re opting for this approach to avoid processing overhead due to **auto-boxing**:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following segment of code establishes a method for `push`, `pop`, and `isEmpty`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last section of code is our `main()` method, which processes the stack:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for both sets of programs, simple and optimized, are the same and
    are shown here:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Full working examples of both versions of our stack implementations are available
    at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example8.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example8.java)
    and [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example9.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example9.java).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing queues
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A queue is another linear data structure and uses the `enqueue`, `peek`, and
    `dequeue` to manage our queues.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to create a queue in Java. As you can
    see, we start by importing the `java.util.LinkedList` and `java.util.Queue` packages:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a simple implementation of a Java queue. The purpose of
    the program, just like that of the stack example, is to process bank transactions.
    Now that you’ve seen this simple implementation, let’s see how we can refine our
    code for greater performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Improving the performance of queues
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our refined version of a queue implementation has been optimized for runtime
    performance. This is especially important for high transactional applications.
    We start by importing the `java.util.NoSuchElementException` package, after which
    we declare the class and a set of private class variables before creating a constructor
    for our custom queue implementation:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following section of code includes methods for `enqueue`, `dequeue`, and
    `isEmpty`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last section of code is our `main()` method, which processes the queue:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for both sets of programs, simple and optimized, are the same and
    are provided here:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Full working examples of both versions of our queue implementations are available
    at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example10.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example10.java)
    and [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example11.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example11.java).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Both stacks and queues can be used for multiple use cases in Java. It’s important
    to ensure we use them when it makes the most sense from a performance standpoint.
    Furthermore, we must consider the previously detailed optimization approaches.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Improving performance with advanced data structures
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There are more data structures available to us than the ones covered in this
    chapter thus far. Sometimes, instead of improving our use of a data structure,
    such as a list, array, tree, stack, or queue, we should implement more advanced
    data structures that are tailored to our specific use case and then optimize their
    use.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s look at some additional, more advanced, data structures that have performance
    considerations.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Hash tables
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use **hash tables** when we need fast **key-value** lookups. There are
    multiple hash functions to choose from and you should be mindful of hash collisions
    – they need to be managed efficiently. Some additional considerations are load
    factor, resizing, memory usage, and performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s an example of how to create a hash table:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Graphs
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Graphs, such as **matrices** or **adjacency lists**, can be used to network
    an application and model complex data relationships. When implementing graphs,
    we should implement algorithms that transverse the graph efficiently. Two algorithms
    that are worth exploring are **breadth-first search** and **depth-first search**.
    Comparing the efficiencies of these algorithms can help you select the most optimized
    solution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s how we can implement a graph:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Trie
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A **trie** is a data structure that is useful when you’re programming methods
    for auto-completion, prefix matching, and more. Tries allow us to efficiently
    store and search for string sequences.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s an example of how to create a trie and create a root node for it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We will cover string manipulation in [*Chapter 7*](B21942_07.xhtml#_idTextAnchor127)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Heap
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Priority queues** are usually implemented as **heaps** because they can efficiently
    manage elements based on their order or priority. This can be an ideal data structure
    for use cases that include scheduling, prioritizing, and element order.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s an example of how to implement a priority queue as a heap. This example
    demonstrates both `minHeap` and `maxHeap` and adds an element to each:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Quad trees
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A **quad tree** is a two-dimensional partition that’s used to organize spatial
    data efficiently. They can be useful for spatial indexing, geographic information
    systems, collision detection, and more.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating a quad tree is a bit more involved than implementing other data structures.
    Here’s a straightforward approach:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Octrees
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: An **octree** is a three-dimensional partition that’s used to organize spatial
    data efficiently. Like quad trees, octrees can be useful for spatial indexing,
    geographic information systems, collision detection, and more.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Octrees can be difficult to implement in Java, as is true with most three- or
    greater-dimensional data structures.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Bitsets
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: When we need space-efficient storage for integer or Boolean datasets and also
    want to ensure their manipulation is efficient, the **bitset** data structure
    is worth considering. Example use cases include algorithms that traverse graphs
    and mark visited nodes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s an example of how to implement a bitset:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Ropes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ropes are great for implementing efficient string handling, especially large
    strings. They are used for performing concatenation and substring operations.
    Some example use cases are text editing applications and string manipulation functionality.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ropes are extremely complex data structures to implement from scratch. Developers
    often turn to packages and tools that are external to the JDK to do this.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We will cover string manipulation in [*Chapter 7*](B21942_07.xhtml#_idTextAnchor127)
    of this book.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: These are just some of the advanced data structures available to us in Java.
    When incorporating these structures, we must understand how they work, their strengths,
    and their weaknesses.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This chapter took an in-depth look at several data structures and demonstrated
    their significance to a Java application’s overall performance. We embraced the
    essential nature of data structures for optimizing the performance of our Java
    applications because they can ensure that our data access, memory management,
    and caching are efficient. Proper use of data structures can lead to algorithm
    efficiency, the scalability of our solutions, and the safety of our threads.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Through code examples, we looked at nonoptimized and optimized examples of code
    for lists, arrays, trees, stacks, and queues. We also explored several advanced
    data structures and examined their added complexities. When we implement data
    structures properly, we can improve the predictability and consistency of our
    application’s performance and make our code more readable and easier to maintain.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on loops and how to optimize them for increased
    performance regarding our Java applications. This is a natural progression following
    our coverage of data structures as we will use them in our examples in the next
    chapter.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
