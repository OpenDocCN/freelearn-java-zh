- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Data Structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: Data structures are important components that contribute to, or detract from,
    the performance of our Java applications. They are foundational parts that are
    used throughout our programs and can help us organize and manipulate data efficiently.
    Data structures are essential for optimizing the performance of our Java applications
    because they can ensure that our data access, memory management, and caching are
    efficient. Proper use of data structures can lead to algorithm efficiency, the
    scalability of our solutions, and the safety of our threads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是我们Java应用程序性能的组成部分，它们可能有助于提高性能，也可能降低性能。它们是程序中的基础部分，用于整个程序，可以帮助我们有效地组织和操纵数据。数据结构对于优化我们的Java应用程序的性能至关重要，因为它们可以确保我们的数据访问、内存管理和缓存效率。正确使用数据结构可以提高算法效率，提高解决方案的可扩展性，并确保线程的安全性。
- en: The significance of data structures can be evidenced by reducing the time complexity
    of operations. With proper data structure implementation, we can improve the predictability
    and consistency of our application’s performance. In addition to improving the
    performance of our Java applications, properly chosen data structures result in
    increased code readability, making them easier to maintain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构的重要性可以通过减少操作的时间复杂度来证明。通过适当的数据结构实现，我们可以提高应用程序性能的可预测性和一致性。除了提高Java应用程序的性能外，适当选择的数据结构还可以提高代码的可读性，使它们更容易维护。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Lists
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树
- en: Stacks and queues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列
- en: Advanced data structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级数据结构
- en: By the end of this chapter, you should understand how specific data structures,
    such as **lists**, **arrays**, **trees**, **stacks**, and **queues**, can impact
    the performance of Java applications. You will have the opportunity to gain hands-on
    experience with Java code that demonstrates how to improve performance through
    proper data structure selection and implementation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该了解特定数据结构，如**列表**、**数组**、**树**、**栈**和**队列**，如何影响Java应用程序的性能。您将有机会通过Java代码的实际操作来获得经验，展示如何通过适当的数据结构选择和实现来提高性能。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need to be
    able to load, edit, and run Java code. If you haven’t set up your development
    environment, please refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例和说明，您需要能够加载、编辑和运行Java代码。如果您还没有设置您的开发环境，请参阅[*第1章*](B21942_01.xhtml#_idTextAnchor014)。
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02)。
- en: Improving performance with lists
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表提高性能
- en: A list is a fundamental data structure in the Java programming language. They
    give us the ability to easily create, store, and manipulate an ordered collection
    of elements. This data structure uses the `java.util.list` interface and extends
    the `java.util.Collection` interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是Java编程语言中的基本数据结构。它们使我们能够轻松创建、存储和操作有序元素集合。此数据结构使用`java.util.list`接口，并扩展了`java.util.Collection`接口。
- en: In this section, we will take a close look at lists, why and when to use them,
    and techniques for getting the highest performance out of them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将仔细研究列表，探讨何时以及为什么使用它们，以及如何从它们中获得最佳性能的技术。
- en: Why use lists?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用列表？
- en: 'Perhaps the most common way of explaining what the list data structure can
    be used for is as a check-off/to-do list or a grocery shopping list. We create
    lists in our programs because we want to leverage one or more of its advantages:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 解释列表数据结构可以用于的最常见方式可能是作为一个勾选/to-do列表或购物清单。我们在程序中创建列表，因为我们想利用其一或多个优势：
- en: '**Ordered elements**: Lists are used to maintain the order of our elements,
    even as we add new elements. This allows us to manipulate our data in a specific
    sequence. Consider a system log that has new entries added with date and time
    stamps. We would want those entries to be maintained in a specific order.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序元素**：列表用于保持我们元素的顺序，即使在添加新元素时也是如此。这使我们能够以特定的顺序操纵我们的数据。考虑一个系统日志，它通过日期和时间戳添加新条目。我们希望这些条目保持特定的顺序。'
- en: '**Automatic resizing**: Lists can be used to dynamically resize themselves
    as our programs add and remove elements. This is especially true in **ArrayLists**,
    which are covered later in this chapter.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动调整大小**：列表可以在我们的程序添加和删除元素时动态调整大小。这在**ArrayList**中尤其如此，这将在本章后面进行介绍。'
- en: '**Positional data access**: Lists allow us to obtain random access efficiently
    by using the element’s index, also referred to as **positional data**.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置数据访问**：列表允许我们通过使用元素的索引（也称为**位置数据**）来高效地获得随机访问。'
- en: '**Duplicate elements**: Lists allow us to have duplicate elements. So, if this
    is important for your use case, then you might consider using a list as your data
    structure selection.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复元素**：列表允许我们拥有重复元素。因此，如果这对您的用例很重要，那么您可能需要考虑使用列表作为您的数据结构选择。'
- en: '`forEach` method. We will look at an example of this in the next section of
    this chapter.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`方法。我们将在本章下一节中查看此示例。'
- en: '`LinkedList`, `ArrayList`, or `Vector` list type. These list types offer unique
    characteristics. The following table shows the different characteristics of these
    list types. Pay special attention to the performance row:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedList`、`ArrayList`或`Vector`列表类型。这些列表类型具有独特的特性。以下表格显示了这些列表类型的不同特性。请特别注意性能这一行：'
- en: '|  | **LinkedList** | **ArrayList** | **Vector** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  | **LinkedList** | **ArrayList** | **Vector** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Data structure** | Doubly-linked list | Dynamic array | Dynamic array |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **数据结构** | 双向链表 | 动态数组 | 动态数组 |'
- en: '| **Use case** | To frequently manipulate data | For fast reads | When thread
    safety is required |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **用例** | 经常操纵数据 | 快速读取 | 需要线程安全 |'
- en: '| **Performance** | + Adds and deletes- Access by index | - Adds and deletes+
    Access by index | - Adds and deletes- Access by index |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **性能** | + 添加和删除- 通过索引访问 | - 添加和删除+ 通过索引访问 | - 添加和删除- 通过索引访问 |'
- en: '| **Thread safety** | No, not by default | No, not by default | Yes, by default
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **线程安全** | 否，默认情况下不是 | 否，默认情况下不是 | 是，默认情况下是 |'
- en: Table 2.1 – Lists
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – 列表
- en: When choosing between `LinkedList`, `ArrayList`, and `Vector` list types, we
    should consider the requirements based on our use case. For example, if our use
    case includes frequent adds and deletes, then `LinkedList` might be the best option.
    Alternatively, if we have infrequent adds and deletes, but heavy reads, then `ArrayList`
    is likely our best option. Finally, if we are most concerned about thread safety,
    `Vector` might be our best option.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择`LinkedList`、`ArrayList`和`Vector`列表类型时，我们应该根据我们的用例考虑需求。例如，如果我们的用例包括频繁的添加和删除，那么`LinkedList`可能是最佳选择。或者，如果我们添加和删除不频繁，但读取量大，那么`ArrayList`可能是我们的最佳选择。最后，如果我们最关心线程安全，那么`Vector`可能是我们的最佳选择。
- en: Important note about thread safety
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程安全的重要注意事项
- en: While `LinkedList` and `ArrayList` are not thread-safe by default, they can
    be made thread-safe by explicitly synchronizing access. This should prevent concurrent
    access-related data corruption, but it will likely lead to lower performance regarding
    your Java application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`LinkedList`和`ArrayList`默认不是线程安全的，但可以通过显式同步访问来使其线程安全。这应该可以防止并发访问相关的数据损坏，但可能会降低Java应用程序的性能。
- en: '`java.util.List` interface, which the list implements. These built-in methods
    include functionality for searching, adding, and removing elements. A full list
    of `java.util.Llist` methods are available in the official Java documentation:
    [https://docs.oracle.com/javase/8/docs/api/java/util/List.html](https://docs.oracle.com/javase/8/docs/api/java/util/List.html).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.List`接口，列表实现了它。这些内置方法包括搜索、添加和删除元素的功能。`java.util.List`的完整方法列表可在官方Java文档中找到：[https://docs.oracle.com/javase/8/docs/api/java/util/List.html](https://docs.oracle.com/javase/8/docs/api/java/util/List.html)。'
- en: Now that we’ve reviewed why we should use lists, let’s look at examples of common
    implementations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了为什么我们应该使用列表，让我们看看常见的实现示例。
- en: Common list implementations
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的列表实现
- en: In this section, we will look at implementation examples for `ArrayList`, `LinkedList`,
    and `Vector`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看`ArrayList`、`LinkedList`和`Vector`的实现示例。
- en: ArrayList example
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArrayList示例
- en: 'Our first list implementation example is an `ArrayList` list type of numbers.
    We will assume that this is part of a human resources (HR) system that stores
    start dates, end dates, and length of service. As shown in the following code,
    we must import both `java.util.ArrayList` and `java.util.List`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个列表实现示例是一个数字的`ArrayList`列表类型。我们将假设这是一个人力资源（HR）系统的一部分，该系统存储开始日期、结束日期和服务长度。如下所示，我们必须导入`java.util.ArrayList`和`java.util.List`：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we have our class declaration and main method. Here, we must create an
    `ArrayList` list type called `hr_numbers`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的类声明和主方法。在这里，我们必须创建一个名为`hr_numbers`的`ArrayList`列表类型：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: hr_numbers.add(1983);
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: hr_numbers.add(1983);
- en: 'hr_numbers.get method, and use them to calculate a value to add as a third
    element to ArrayList:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: hr_numbers.get方法，并使用它们来计算一个值，将其作为ArrayList的第三个元素添加：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last section of the code is a `for` loop. This iterates through the list
    and provides output to the terminal window:'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的最后部分是一个`for`循环。这个循环遍历列表，并将输出提供给终端窗口：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the program’s output:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, our output is as expected; we simply print each of the three
    elements to the terminal window using a `for-each` loop.
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们的输出符合预期；我们只是使用`for-each`循环将三个元素简单地打印到终端窗口。
- en: for-each loops
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: for-each循环
- en: Java 5 introduced an enhanced `for` loop called the `for-each` loop. We can
    use this loop to iterate through elements without using an explicit iterator or
    index. This makes our code quicker to write and more readable.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java 5引入了一个增强的`for`循环，称为`for-each`循环。我们可以使用这个循环来遍历元素，而无需使用显式的迭代器或索引。这使得我们的代码更快地编写，更易于阅读。
- en: LinkedList example
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 链接示例
- en: 'Our `LinkedList` implementation example is a simple `get`, `remove`, `contains`,
    and `size` methods. As you can see, we import both `java.util.LinkedList` and
    `java.util.List`:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`LinkedList`实现示例包括简单的`get`、`remove`、`contains`和`size`方法。如您所见，我们导入了`java.util.LinkedList`和`java.util.List`：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we have our class declaration and the main method. Here, we create a
    `LinkedList` list type called `petNames`:'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的类声明和主方法。在这里，我们创建一个名为`petNames`的`LinkedList`列表类型：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: petNames.add("Brandy");
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: petNames.add("Brandy");
- en: petNames.add("Muzz");
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: petNames.add("Muzz");
- en: petNames.add("Java");
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: petNames.add("Java");
- en: 'petNames.get method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: petNames.get方法：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next section of the code is a `for-each` loop that iterates through the
    list and provides output to the terminal window:'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的下一部分是一个`for-each`循环，它遍历列表并将输出提供给终端窗口：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the loop’s output:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是循环的输出：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can remove an element from our `LinkedList` by using the `remove` method,
    as illustrated here. As you can see, after calling the `remove` method, `Brandy`
    is no longer an element in `LinkedList`:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过使用`remove`方法从我们的`LinkedList`中删除一个元素，如下所示。如您所见，在调用`remove`方法后，`Brandy`不再是`LinkedList`中的一个元素：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next part of our code calls the `contains` method to check if a specific
    value is found in `LinkedList`. Since we previously removed this pet from `LinkedList`,
    the Boolean result is `false`:'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们代码的下一部分调用`contains`方法来检查特定值是否在`LinkedList`中。由于我们之前已经从这个`LinkedList`中删除了这个宠物，布尔结果是`false`：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the `println` statement is as expected:'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`println`语句的输出符合预期：'
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This final section of our code demonstrates the use of the `size` method. Here,
    we make a call to that method, which returns an integer. We use that value in
    our final output:'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们代码的最后一部分展示了`size`方法的使用。在这里，我们调用该方法，它返回一个整数。我们使用这个值在我们的最终输出中：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final output reflects the expected size of our `LinkedList`:'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终输出反映了我们的`LinkedList`预期的长度：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we’ve looked at how to implement `ArrayList` and `LinkedList`, let’s
    look at our final example, **Vector**.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何实现`ArrayList`和`LinkedList`，让我们看看我们的最后一个示例，**Vector**。
- en: Vector example
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向量示例
- en: Our last list implementation example is a `Vector` list type. As you will see,
    `Vector` is similar to `ArrayList`. We implement them as dynamic arrays so that
    we can benefit from efficient random access to our vector’s elements. Vectors
    have the added benefit of being thread-safe by default. This is due to the default
    synchronization we previously discussed. Let’s look at some example code.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最后一个列表实现示例是一个`Vector`列表类型。如您将看到的，`Vector`与`ArrayList`类似。我们将它们实现为动态数组，以便我们可以从向量的元素中获得高效的随机访问。向量默认是线程安全的，这是由于我们之前讨论的默认同步。让我们看看一些示例代码。
- en: 'Our example program will store a set of lucky numbers. It starts by importing
    the `java.util.Vector` and `java.util.Enumeration` packages:'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的示例程序将存储一组幸运数字。它首先导入`java.util.Vector`和`java.util.Enumeration`包：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we have our class declaration and the main method. Here, we create a
    `Vector` list type called `luckyNumbers` that will store integers:'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的类声明和主方法。在这里，我们创建一个名为`luckyNumbers`的`Vector`列表类型，它将存储整数：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: luckyNumbers.add(8);
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: luckyNumbers.add(8);
- en: luckyNumbers.add(19);
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: luckyNumbers.add(19);
- en: 'luckyNumbers.get method. Note that indices start at zero (0):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: luckyNumbers.get方法。请注意，索引从零（0）开始：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next section of the code uses a legacy approach for iterating through a
    `Vector` list type. The enumeration approach can be used in place of an enhanced
    or `for-each` loop. Vectors, in and of themselves, are considered a list type
    that’s falling out of common use. The following code iterates through the list
    and provides output to the terminal window:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的下一部分使用了一个传统的遍历`Vector`列表类型的方法。枚举方法可以用作替代增强型或`for-each`循环。实际上，向量被视为一个正在逐渐被淘汰的列表类型。以下代码遍历列表并向终端窗口提供输出：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the program’s output:'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是程序的输出：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can remove an element from our `Vector` by using the `removeElement` method,
    as illustrated here. After calling the `removElement` method, the lucky number
    19 is removed as an element from `Vector`:'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过使用`removeElement`方法从我们的`Vector`中移除一个元素，如下所示。在调用`removElement`方法后，幸运数字19被从`Vector`中移除作为一个元素：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next part of our code calls the `contains` method to check if a specific
    value is found in `Vector`. Since we previously removed this lucky number from
    `Vector`, the Boolean result is `false`:'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们代码的下一部分调用`contains`方法来检查特定值是否在`Vector`中。由于我们之前已经从`Vector`中移除了这个幸运数字，布尔结果为`false`：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the `println` statement is as expected:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`println`语句的输出符合预期：'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This final section of our code demonstrates the use of the `size` method. Here,
    we make a call to that method, which returns an integer. We use that value in
    our final output:'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码的最后一部分展示了`size`方法的使用。在这里，我们调用该方法，它返回一个整数。我们使用这个值在我们的最终输出中：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The final output reflects the expected size of our `LinkedList` list type:'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终输出反映了我们`LinkedList`列表类型的预期大小：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This section provided examples of using lists for `ArrayList`, `LinkedList`,
    and `Vector`. There are additional implementations that you can consider, including
    `CopyOnWriteArrayList`, `CopyOnWriteArraySet`, and `LinkedHashSet`. Stacks are
    another implementation and are covered later in this chapter. Next, we will look
    at achieving high performance with lists.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节提供了使用`ArrayList`、`LinkedList`和`Vector`的列表的示例。还有其他实现可以考虑，包括`CopyOnWriteArrayList`、`CopyOnWriteArraySet`和`LinkedHashSet`。栈是另一种实现，将在本章后面介绍。接下来，我们将探讨如何通过列表实现高性能。
- en: High performance with lists
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高性能的列表
- en: 'Let’s take a look at how we can improve the performance of our Java apps when
    using lists. The following code example implements a `LinkedList` list type of
    integers. Here, we’ll create a `LinkedList` list type, add four elements to it,
    and then iterate through the list, printing each element to the screen:'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看如何提高我们使用列表时Java应用程序的性能。以下代码示例实现了整数类型的`LinkedList`列表类型。在这里，我们将创建一个`LinkedList`列表类型，向其中添加四个元素，然后遍历列表，将每个元素打印到屏幕上：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of this first section is as follows:'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节的第一部分输出如下：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next section of code removes an element using the `remove` method – specifically,
    the first occurrence of 8:'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个代码部分使用`remove`方法删除一个元素——具体来说，是第一个出现的8：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following code segment performs two checks using the `contains` method.
    First, it checks for a 3 and then an 8\. The results are printed on the screen:'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码段使用`contains`方法执行两个检查。首先，它检查3，然后是8。结果被打印在屏幕上：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of this section of code is shown here:'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节代码的输出如下所示：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This final segment of code iterates through `LinkedList` and prints its values:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码段遍历`LinkedList`并打印其值：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of this final section of code is as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码段是本节最后部分的输出：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, it’s time to see what we can do to modify our code to improve overall
    performance. There are several techniques we can use:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，是时候看看我们如何修改我们的代码来提高整体性能了。我们可以使用几种技术：
- en: '`List<Integer>` objects. The `Integer` class is essentially a wrapper around
    the primitive `int` data type. The `Integer` object only contains one field of
    the `int` type. Here’s how we can modify our code:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<Integer>`对象。`Integer`类本质上是对原始`int`数据类型的包装。`Integer`对象只包含一个`int`类型的字段。以下是我们如何修改我们的代码的方法：'
- en: '[PRE32]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`LinkedList`, we should use an `java.util.Iterator` package. This is an efficient
    method of avoiding errors such as **ConcurrentModificationsException**, which
    is thrown when we attempt to make two simultaneous modifications to a collection.
    Here’s how we can write such an iterator:'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`LinkedList`，我们应该使用`java.util.Iterator`包。这是一个避免诸如**ConcurrentModificationsException**等错误的有效方法，这种异常会在我们尝试同时对一个集合进行两次修改时抛出。以下是我们如何编写这样的迭代器的方法：
- en: '[PRE33]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The fully revised example is available at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example5.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example5.java).
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完全修订的示例可在[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example5.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example5.java)找到。
- en: You should now have increased knowledge and confidence in using lists in Java
    to help improve the performance of your applications. Next, we will look at arrays
    and how to use them optimally.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你应该对在Java中使用列表以帮助提高应用程序性能有了更多的知识和信心。接下来，我们将探讨数组以及如何最优地使用它们。
- en: Improving performance with arrays
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用数组提高性能
- en: 'Previously, we discussed `ArrayList`; in this section, we will focus on arrays.
    There are key differences in these two data types: arrays have a fixed size, while
    ArrayLists do not. In this section, we will review the characteristics of arrays
    and how to improve the performance of our Java applications when implementing
    arrays.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在之前，我们讨论了`ArrayList`；在本节中，我们将专注于数组。这两种数据类型之间存在关键差异：数组具有固定的大小，而ArrayList没有。在本节中，我们将回顾数组的特性和如何在实现数组时提高Java应用程序的性能。
- en: Array characteristics
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组特性
- en: 'There are four primary characteristics of arrays. Let’s take a look:'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组有四个主要特性。让我们看看：
- en: '**Size**: The size of an array is determined when it’s created. It cannot be
    changed when the application is running. This fixed-sized characteristic is also
    referred to as **static**. Here’s the syntax for creating an array:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：数组的大小在创建时确定。在应用程序运行时无法更改。这种固定大小的特性也被称为**静态**。以下是创建数组的语法：'
- en: '[PRE34]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, we explicitly specify a size of `10` as part of the array’s
    declaration.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们在数组声明中明确指定了大小为`10`。
- en: '**Homeogeneous**: Homeogeneous means that all data in an array must be of the
    same kind. As with the previous example, we created an array of integers. We could
    have used strings, but we cannot mix data types in a single array. We can also
    have an array of objects and arrays of arrays.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同质**：同质意味着数组中的所有数据必须属于同一类型。就像之前的例子一样，我们创建了一个整数数组。我们可以使用字符串，但不能在单个数组中混合数据类型。我们也可以有对象数组和数组数组。'
- en: '**Indexing**: This should go without saying, so as a reminder, our indexes
    start with 0, not 1\. So, the array that we previously created has 10 elements,
    indexed from 0 to 9.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**：这一点不言而喻，所以作为一个提醒，我们的索引从0开始，而不是1。因此，我们之前创建的数组有10个元素，索引从0到9。'
- en: '**Continuous memory**: One of the great efficiencies offered to us by arrays
    is random access. This efficiency stems from the fact that all elements in an
    array are stored in contiguous memory. In other words, the elements are stored
    in memory locations next to each other.'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续内存**：数组为我们提供的一项巨大效率是随机访问。这种效率源于数组中的所有元素都存储在连续内存中的事实。换句话说，元素存储在相邻的内存位置。'
- en: Now that we have a firm understanding of array characteristics, let’s explore
    some code that implements this important data structure.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们对数组特性有了牢固的理解，让我们探索一些实现这种重要数据结构的代码。
- en: Implementing arrays
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现数组
- en: This section features a basic Java application that implements an array of planets
    using the `String` data type. As we walk through the code, we will create the
    array, access and print array elements, use the length method, access an array
    element using its index, and modify an array.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节介绍了一个基本的Java应用程序，该程序使用`String`数据类型实现行星数组。随着我们遍历代码，我们将创建数组，访问和打印数组元素，使用`length`方法，使用索引访问数组元素，并修改数组。
- en: 'This first section of code creates an array of **strings**:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码的第一个部分创建了一个**字符串**数组：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, we created an array of eight strings. This next section of
    code demonstrates accessing and printing all elements of an array:'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个包含八个字符串的数组。接下来的代码部分展示了如何访问和打印数组的所有元素：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s the output of the preceding code snippet:'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是前面代码片段的输出：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can use the `length` method to determine the size of our array. It might
    seem like we don’t need to determine the size since it is determined when the
    array is created. Often, we don’t know the initial size of our arrays because
    they’re based on external data sources. Here’s how to determine an array’s size:'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用`length`方法来确定我们数组的大小。虽然看起来我们不需要确定大小，因为数组创建时大小就已经确定了。通常，我们不知道数组的初始大小，因为它们基于外部数据源。以下是确定数组大小的步骤：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the preceding code is shown here:'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面代码的输出如下所示：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will look at how to access an array element by referencing its index
    position within the array:'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何通过在数组中引用其索引位置来访问数组元素：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of the previous two lines of code is as follows:'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一两行代码的输出如下：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, we printed the third element in our array by using an index
    reference of `2`. Remember, our indexes start with 0.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们通过使用索引引用`2`打印了数组中的第三个元素。请记住，我们的索引从0开始。
- en: 'Our last segment of code shows how we can modify an element in our array:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最后的代码段展示了我们如何修改数组中的元素：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the preceding code is shown here. As you can see, the new name
    for the element at index position 1 is reflected in the output:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码的输出如下。如您所见，索引位置1的元素的新名称已反映在输出中：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The fully revised example is available at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example6.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example6.java).
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完全修订的示例可在[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example6.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example6.java)找到。
- en: Now that you’ve learned how to implement arrays in Java, let’s look at some
    approaches to improving our application’s performance in terms of array usage.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何在Java中实现数组，让我们看看一些提高应用程序性能的方法，特别是关于数组的使用。
- en: High performance with arrays
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用数组实现高性能
- en: As we have seen with lists, our implementation approaches to data structures
    can have a direct impact on our Java application’s performance. This section documents
    several strategies and best practices for optimizing array-related Java code.
    These strategies can be categorized as algorithmic optimization, data structures,
    memory management, parallel processing, vectorization, caching, and benchmarking
    and profiling. Let’s look at each of them.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的列表实现方法对Java应用程序的性能有直接影响。本节记录了优化与数组相关的Java代码的几种策略和最佳实践。这些策略可以分为算法优化、数据结构、内存管理、并行处理、向量化、缓存以及基准测试和性能分析。让我们逐一查看它们。
- en: Algorithmic optimization
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 算法优化
- en: Whenever we select algorithms, we should ensure they are the most appropriate
    for the data types we’re using. For example, it’s important to select the most
    efficient sorting algorithm (that is mergesort, quicksort, and so on) based on
    our array’s size and characteristics. In addition, binary searches can be implemented
    when searching in sorted arrays.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在选择算法时，我们应该确保它们是最适合我们使用的数据类型的。例如，根据我们数组的尺寸和特性选择最有效的排序算法（例如归并排序、快速排序等）是很重要的。此外，在排序数组中进行搜索时可以实现二分查找。
- en: Additional information is provided in [*Chapter 5*](B21942_05.xhtml#_idTextAnchor088)
    of this book.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书[*第5章*](B21942_05.xhtml#_idTextAnchor088)提供了更多信息。
- en: Data structures
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据结构
- en: The core of this chapter focuses on selecting the right data structure based
    on your use case and requirements. When it comes to arrays, we should select them
    when we need frequent read access; here, our dataset can be of a fixed size. In
    addition, knowing when to select `ArrayList` over `LinkedList` is equally important.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章的核心内容是针对您的用例和需求选择合适的数据结构。当涉及到数组时，我们应该在我们需要频繁读取访问时选择它们；在这里，我们的数据集可以是固定大小的。此外，知道何时选择`ArrayList`而不是`LinkedList`同样重要。
- en: Memory management
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内存管理
- en: Whenever possible, we should avoid creating temporary objects to support array
    operations. Instead, we should reuse arrays or use methods such as `Arrays.copyOf`
    or `System.arraycopy` for greater efficiency.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们应该避免创建临时对象来支持数组操作。相反，我们应该重用数组或使用`Arrays.copyOf`或`System.arraycopy`等方法以提高效率。
- en: Additional information is provided in [*Chapter 8*](B21942_08.xhtml#_idTextAnchor143)
    of this book.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书[*第8章*](B21942_08.xhtml#_idTextAnchor143)提供了更多信息。
- en: Parallel processing
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并行处理
- en: When we must sort and process large arrays, it can be beneficial to employ Java’s
    parallel processing capabilities, such as by using `parallelSort`. You should
    consider using multithreading with concurrent array processing. This is especially
    important for large arrays.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们必须对大型数组进行排序和处理时，利用Java的并行处理能力，如使用`parallelSort`，可能是有益的。您应该考虑使用多线程进行并发数组处理。这对于大型数组尤为重要。
- en: Additional information is provided in [*Chapter 9*](B21942_09.xhtml#_idTextAnchor159)
    of this book.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书[*第9章*](B21942_09.xhtml#_idTextAnchor159)提供了更多信息。
- en: Vectorization
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向量化
- en: In the context of Java arrays, vectorization is a technique that involves performing
    operations on more than one element of an array simultaneously. This typically
    includes optimizing modern central processors. The goal is to increase array processing
    operations. This is often referred to as `java.util.Vector` class, which was introduced
    with Java 16.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Java数组的上下文中，向量化是一种涉及同时对一个数组的多个元素执行操作的技术。这通常包括优化现代中央处理器。目标是增加数组处理操作。这通常被称为`java.util.Vector`类，它是随着Java
    16引入的。
- en: Vectorization can provide significant performance benefits, especially with
    large arrays. This is exponentially true when operations can be parallelized.
    There are limits to what can be vectorized, such as dependencies and complex operations.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向量化可以提供显著的性能优势，尤其是在处理大型数组时。当操作可以并行化时，这一点更是如此。可以向量化的内容有限，例如依赖关系和复杂操作。
- en: Caching
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存
- en: A proven performance approach is to optimize array access patterns to support
    cache locality. This can be achieved by accessing contiguous memory locations.
    Another approach is to minimize pointer aliasing to the best extent possible.
    While point aliasing might support compiler optimizations, local variables or
    array indexes should be used instead for optimal performance.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一种经过验证的性能方法是优化数组访问模式以支持缓存局部性。这可以通过访问连续的内存位置来实现。另一种方法是尽可能减少指针别名。虽然指针别名可能支持编译器优化，但为了获得最佳性能，应使用局部变量或数组索引。
- en: Additional information is provided in [*Chapter 8*](B21942_08.xhtml#_idTextAnchor143)
    of this book.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书[*第8章*](B21942_08.xhtml#_idTextAnchor143)提供了更多信息。
- en: Benchmarking and profiling
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基准测试和分析
- en: Whenever possible, we should conduct benchmarking so that we can compare our
    approach to array operations. Armed with this analysis, we can select the most
    efficient and proven approach. As part of our analysis, we can employ profiling
    tools to help identify performance bottlenecks specific to our array operations.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们应该进行基准测试，以便比较我们的数组操作方法。有了这种分析，我们可以选择最有效且经过验证的方法。作为我们分析的一部分，我们可以使用分析工具来帮助我们识别特定于我们的数组操作的性能瓶颈。
- en: Additional information is provided in [*Chapter 13*](B21942_13.xhtml#_idTextAnchor227)
    of this book.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书[*第13章*](B21942_13.xhtml#_idTextAnchor227)提供了更多信息。
- en: Now that you’ve learned how to improve Java application performance when dealing
    with arrays, let’s look at how this can be done with trees.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何提高处理数组时的Java应用程序性能，让我们看看如何使用树来实现这一点。
- en: Improving performance with trees
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用树提高性能
- en: A **tree** is a hierarchical data structure that consists of parent and child
    **nodes**, analogous to that of a physical tree. The topmost node is referred
    to as the **root** and there can only be one in a tree data structure. The nodes
    are the foundational components of this data structure. Each node contains both
    data and references to child nodes. There are additional terms that you should
    be familiar with regarding trees. A **leaf node** has no child. Any node and its
    descendants can be considered a **subtree**.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**树**是一种层次数据结构，由父节点和子节点**节点**组成，类似于物理树。最顶部的节点被称为**根**，在树数据结构中只能有一个。节点是这个数据结构的基础组件。每个节点都包含数据和指向子节点的引用。还有其他你应该熟悉的关于树的概念。**叶节点**没有子节点。任何节点及其后代都可以被认为是**子树**。'
- en: Examples of a tree structure
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 树结构的示例
- en: 'As shown in the following example, we can implement trees as objects or classes:'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如以下示例所示，我们可以将树实现为对象或类：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code snippet defines a `TreeNode` class that can be used along
    with another class for tree operation management. We need to create our tree in
    our `main()` method. Here’s an example of how to do that:'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码片段定义了一个`TreeNode`类，它可以与另一个类一起用于树操作管理。我们需要在`main()`方法中创建我们的树。以下是如何做到这一点的示例：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To insert data into our tree, we can use the following code:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将数据插入我们的树，我们可以使用以下代码：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To use or search our tree, we can perform a binary search for an element in
    our tree using code similar to the following:'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用或搜索我们的树，我们可以使用类似于以下代码的代码在树中执行二分查找：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A full working example is available at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example7.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example7.java).
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个完整的示例代码可以在[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example7.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example7.java)找到。
- en: High-performance considerations
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高性能考虑因素
- en: The tree data structure can be very complex, so we should consider our Java
    application’s overall performance, especially regarding algorithms that manipulate
    our trees. Additional considerations can be categorized as type, safety, iteration,
    memory, operations, and caching. Let’s briefly look at each of these categories.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 树数据结构可能非常复杂，因此我们应该考虑我们的Java应用程序的整体性能，特别是关于操作我们的树的算法。额外的考虑可以归类为类型、安全性、迭代、内存、操作和缓存。让我们简要地看看这些类别。
- en: Type
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型
- en: It’s important to carefully construct our trees so that they are as balanced
    as possible. We should be mindful of the **tree’s height**, which is the longest
    path from the root to a leaf node. The data requirements should be reviewed so
    that we can select the most optimal tree. For example, we can use a **binary search
    tree**, which can provide us with efficient searches.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要仔细构建我们的树，使它们尽可能平衡。我们应该注意**树的高度**，即从根节点到叶节点的最长路径。我们应该审查数据需求，以便我们可以选择最优的树。例如，我们可以使用**二叉搜索树**，它可以为我们提供高效的搜索。
- en: Safety
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安全性
- en: As with other data structures, you should always implement thread safety protocols
    or, at a minimum, use concurrent tree structures.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与其他数据结构一样，你应该始终实现线程安全协议，或者至少使用并发树结构。
- en: Iteration
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 迭代
- en: Iteration operations can often present bottlenecks, calling for an optimization
    strategy. In addition, the use of recursive algorithms should be minimized to
    improve overall performance.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 迭代操作常常会呈现瓶颈，需要调用优化策略。此外，应尽量减少递归算法的使用，以提高整体性能。
- en: Memory
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内存
- en: Generally, and as it applies to trees specifically, we should minimize object
    creation and overhead. We should strive to do our best to manage memory efficiently.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，具体到树，我们应该尽量减少对象创建和开销。我们应该努力高效地管理内存。
- en: Additional information is provided in [*Chapter 8*](B21942_08.xhtml#_idTextAnchor143)
    of this book.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书[*第8章*](B21942_08.xhtml#_idTextAnchor143)提供了更多信息。
- en: Operations
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作
- en: There are several things we can do to optimize operations. For example, we can
    use batch operations to reduce processing overhead. Optimizing our algorithms
    can help us avoid excessive processing and data updates.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以采取一些措施来优化操作。例如，我们可以使用批量操作来减少处理开销。优化我们的算法可以帮助我们避免过度处理和数据更新。
- en: Additional information is provided in [*Chapter 5*](B21942_05.xhtml#_idTextAnchor088)
    of this book.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书[*第5章*](B21942_05.xhtml#_idTextAnchor088)提供了更多信息。
- en: Caching
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存
- en: We can optimize the way our data is laid out to maximize cache locality. Our
    goal with caching is to reduce memory access times. In addition, we can access
    nearly all nodes in memory to further improve performance.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以优化数据布局的方式，以最大化缓存局部性。我们的目标是减少内存访问时间。此外，我们可以访问内存中的几乎所有节点，以进一步提高性能。
- en: Additional information is provided in [*Chapter 8*](B21942_08.xhtml#_idTextAnchor143)
    of this book.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书[*第8章*](B21942_08.xhtml#_idTextAnchor143)提供了更多信息。
- en: Improving performance with stacks and queues
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用栈和队列提高性能
- en: '**Stacks** and **queues** are almost always grouped because they can both be
    used to manage and manipulate collections of data elements. They are both linear
    stacks; that’s where their similarities end. While grouped, there are key differences
    in how they operate. In this section, we’ll look at how to implement stacks and
    queues and how to optimize them for high-performance Java applications.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**栈**和**队列**几乎总是放在一起，因为它们都可以用来管理和操作数据元素集合。它们都是线性栈；这就是它们的相似之处。虽然它们被分组，但它们在操作方式上有关键的区别。在本节中，我们将探讨如何实现栈和队列，以及如何为高性能Java应用程序优化它们。'
- en: Implementing stacks
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现栈
- en: Stacks are linear data structures that use the `push` elements to the top, `peek`
    to view an element, and `pop` to remove the top element.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 栈是线性数据结构，使用`push`元素到顶部，`peek`查看一个元素，以及`pop`移除顶部元素。
- en: 'The following example demonstrates how to create a stack in Java. You will
    notice that we start by importing the `java.util.Stack` package:'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例演示了如何在Java中创建一个栈。你会注意到我们首先导入`java.util.Stack`包：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code is a simple implementation of a Java stack. The purpose of
    the program is to process bank transactions. Now that you’ve seen this simple
    implementation, let’s see how we can refine our code for greater performance.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码是Java栈的简单实现。该程序的目的是对银行交易进行处理。现在你已经看到了这个简单的实现，让我们看看我们如何可以改进我们的代码以获得更好的性能。
- en: Improving the performance of stacks
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提高栈的性能
- en: Using our previous example as a starting point, we will refine it for higher
    performance at runtime. We’ll start by using a custom stack implementation. This
    type of refinement is especially effective when use cases involve a high volume
    of transactions. As you can see, we must import the `java.util.EmptyStackException`
    package.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以我们之前的示例为起点，我们将对其进行优化以提高运行时的性能。我们将首先使用自定义的栈实现。这种优化特别适用于涉及大量事务的使用案例。正如您所看到的，我们必须导入
    `java.util.EmptyStackException` 包。
- en: 'Next, we must declare a class and use an array with a **double** data type.
    We’re opting for this approach to avoid processing overhead due to **auto-boxing**:'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们必须声明一个类并使用具有 **double** 数据类型的数组。我们选择这种方法是为了避免由于 **auto-boxing** 而产生的处理开销：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following segment of code establishes a method for `push`, `pop`, and `isEmpty`:'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码段定义了 `push`、`pop` 和 `isEmpty` 方法：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our last section of code is our `main()` method, which processes the stack:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最后的代码段是 `main()` 方法，它处理栈：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output for both sets of programs, simple and optimized, are the same and
    are shown here:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单和优化后的两组程序的输出相同，并在此展示：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Full working examples of both versions of our stack implementations are available
    at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example8.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example8.java)
    and [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example9.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example9.java).
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们栈实现的两个版本的完整工作示例可在 [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example8.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example8.java)
    和 [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example9.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example9.java)
    找到。
- en: Implementing queues
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现队列
- en: A queue is another linear data structure and uses the `enqueue`, `peek`, and
    `dequeue` to manage our queues.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 队列是另一种线性数据结构，并使用 `enqueue`、`peek` 和 `dequeue` 来管理我们的队列。
- en: 'The following example demonstrates how to create a queue in Java. As you can
    see, we start by importing the `java.util.LinkedList` and `java.util.Queue` packages:'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例演示了如何在 Java 中创建一个队列。正如您所看到的，我们首先导入 `java.util.LinkedList` 和 `java.util.Queue`
    包：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding code is a simple implementation of a Java queue. The purpose of
    the program, just like that of the stack example, is to process bank transactions.
    Now that you’ve seen this simple implementation, let’s see how we can refine our
    code for greater performance.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码是 Java 队列的简单实现。程序的目的，就像栈示例一样，是处理银行交易。现在您已经看到了这个简单实现，让我们看看我们如何可以优化我们的代码以获得更好的性能。
- en: Improving the performance of queues
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提高队列的性能
- en: 'Our refined version of a queue implementation has been optimized for runtime
    performance. This is especially important for high transactional applications.
    We start by importing the `java.util.NoSuchElementException` package, after which
    we declare the class and a set of private class variables before creating a constructor
    for our custom queue implementation:'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们优化的队列实现已经针对运行时性能进行了优化。这对于高事务性应用尤为重要。我们首先导入 `java.util.NoSuchElementException`
    包，然后声明类和一组私有类变量，在创建自定义队列实现构造函数之前：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following section of code includes methods for `enqueue`, `dequeue`, and
    `isEmpty`:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码段包括 `enqueue`、`dequeue` 和 `isEmpty` 方法：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our last section of code is our `main()` method, which processes the queue:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最后的代码段是 `main()` 方法，它处理队列：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output for both sets of programs, simple and optimized, are the same and
    are provided here:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单和优化后的两组程序的输出相同，并在此提供：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Full working examples of both versions of our queue implementations are available
    at [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example10.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example10.java)
    and [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example11.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example11.java).
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们队列实现的两个版本的完整工作示例可在 [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example10.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example10.java)
    和 [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example11.java](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example11.java)
    找到。
- en: Both stacks and queues can be used for multiple use cases in Java. It’s important
    to ensure we use them when it makes the most sense from a performance standpoint.
    Furthermore, we must consider the previously detailed optimization approaches.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Java中，栈和队列都可以用于多种用例。确保我们从性能角度出发最合理地使用它们非常重要。此外，我们必须考虑之前详细说明的优化方法。
- en: Improving performance with advanced data structures
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用高级数据结构提高性能
- en: There are more data structures available to us than the ones covered in this
    chapter thus far. Sometimes, instead of improving our use of a data structure,
    such as a list, array, tree, stack, or queue, we should implement more advanced
    data structures that are tailored to our specific use case and then optimize their
    use.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用的比本章迄今为止介绍的数据结构还要多。有时，我们不应该改进我们对数据结构（如列表、数组、树、栈或队列）的使用，而应该实现针对我们特定用例量身定制的高级数据结构，然后优化它们的使用。
- en: Let’s look at some additional, more advanced, data structures that have performance
    considerations.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看一些额外的、更高级的数据结构，它们需要考虑性能因素。
- en: Hash tables
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哈希表
- en: We can use **hash tables** when we need fast **key-value** lookups. There are
    multiple hash functions to choose from and you should be mindful of hash collisions
    – they need to be managed efficiently. Some additional considerations are load
    factor, resizing, memory usage, and performance.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们需要快速的**键值**查找时，我们可以使用**哈希表**。有多种哈希函数可供选择，你应该注意哈希冲突——它们需要被高效地管理。一些额外的考虑因素包括负载因子、调整大小、内存使用和性能。
- en: 'Here’s an example of how to create a hash table:'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个创建哈希表并为其创建根节点的示例：
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Graphs
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图
- en: Graphs, such as **matrices** or **adjacency lists**, can be used to network
    an application and model complex data relationships. When implementing graphs,
    we should implement algorithms that transverse the graph efficiently. Two algorithms
    that are worth exploring are **breadth-first search** and **depth-first search**.
    Comparing the efficiencies of these algorithms can help you select the most optimized
    solution.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图，例如**矩阵**或**邻接表**，可以用来网络化一个应用程序并建模复杂的数据关系。在实现图时，我们应该实现能够高效遍历图的算法。值得探索的两个算法是**广度优先搜索**和**深度优先搜索**。比较这些算法的效率可以帮助你选择最优化的解决方案。
- en: 'Here’s how we can implement a graph:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是如何实现图的方法：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Trie
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字典树
- en: A **trie** is a data structure that is useful when you’re programming methods
    for auto-completion, prefix matching, and more. Tries allow us to efficiently
    store and search for string sequences.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**字典树**是一种在编程自动完成、前缀匹配等方法时非常有用的数据结构。字典树允许我们高效地存储和搜索字符串序列。'
- en: 'Here’s an example of how to create a trie and create a root node for it:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个创建字典树并为它创建根节点的示例：
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We will cover string manipulation in [*Chapter 7*](B21942_07.xhtml#_idTextAnchor127)
    of this book.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本书的[*第7章*](B21942_07.xhtml#_idTextAnchor127)中介绍字符串操作。
- en: Heap
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 堆
- en: '**Priority queues** are usually implemented as **heaps** because they can efficiently
    manage elements based on their order or priority. This can be an ideal data structure
    for use cases that include scheduling, prioritizing, and element order.'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**优先队列**通常实现为**堆**，因为它们可以基于元素的顺序或优先级高效地管理元素。这对于包括调度、优先级排序和元素顺序在内的用例来说是一个理想的数据结构。'
- en: 'Here’s an example of how to implement a priority queue as a heap. This example
    demonstrates both `minHeap` and `maxHeap` and adds an element to each:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个将优先队列实现为堆的示例。此示例演示了`minHeap`和`maxHeap`，并为每个添加了一个元素：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Quad trees
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 四叉树
- en: A **quad tree** is a two-dimensional partition that’s used to organize spatial
    data efficiently. They can be useful for spatial indexing, geographic information
    systems, collision detection, and more.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**四叉树**是一种用于高效组织空间数据的二维分区。它们在空间索引、地理信息系统、碰撞检测等方面非常有用。'
- en: 'Creating a quad tree is a bit more involved than implementing other data structures.
    Here’s a straightforward approach:'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建四叉树比实现其他数据结构要复杂一些。下面是一个简单的方法：
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Octrees
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 八叉树
- en: An **octree** is a three-dimensional partition that’s used to organize spatial
    data efficiently. Like quad trees, octrees can be useful for spatial indexing,
    geographic information systems, collision detection, and more.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**八叉树**是一种用于高效组织空间数据的三维分区。像四叉树一样，八叉树在空间索引、地理信息系统、碰撞检测等方面非常有用。'
- en: Octrees can be difficult to implement in Java, as is true with most three- or
    greater-dimensional data structures.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Java中实现八叉树可能比较困难，这与大多数三维或更高维度的数据结构一样。
- en: Bitsets
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 位图集
- en: When we need space-efficient storage for integer or Boolean datasets and also
    want to ensure their manipulation is efficient, the **bitset** data structure
    is worth considering. Example use cases include algorithms that traverse graphs
    and mark visited nodes.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们需要为整数或布尔数据集提供空间高效的存储，并确保它们的操作是高效的，**位集**数据结构值得考虑。示例用例包括遍历图并标记已访问节点的算法。
- en: 'Here’s an example of how to implement a bitset:'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个实现位集的示例：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Ropes
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 线索
- en: Ropes are great for implementing efficient string handling, especially large
    strings. They are used for performing concatenation and substring operations.
    Some example use cases are text editing applications and string manipulation functionality.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 线索非常适合实现高效的字符串处理，尤其是大型字符串。它们用于执行连接和子字符串操作。一些示例用例包括文本编辑应用程序和字符串操作功能。
- en: Ropes are extremely complex data structures to implement from scratch. Developers
    often turn to packages and tools that are external to the JDK to do this.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从零开始实现线索是一个非常复杂的数据结构。开发者通常会转向JDK之外的包和工具来完成这项工作。
- en: We will cover string manipulation in [*Chapter 7*](B21942_07.xhtml#_idTextAnchor127)
    of this book.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本书的[*第7章*](B21942_07.xhtml#_idTextAnchor127)中介绍字符串操作。
- en: These are just some of the advanced data structures available to us in Java.
    When incorporating these structures, we must understand how they work, their strengths,
    and their weaknesses.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些只是Java中可用的部分高级数据结构。当我们采用这些结构时，我们必须了解它们的工作原理、它们的优点和缺点。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter took an in-depth look at several data structures and demonstrated
    their significance to a Java application’s overall performance. We embraced the
    essential nature of data structures for optimizing the performance of our Java
    applications because they can ensure that our data access, memory management,
    and caching are efficient. Proper use of data structures can lead to algorithm
    efficiency, the scalability of our solutions, and the safety of our threads.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章深入探讨了几个数据结构，并展示了它们对Java应用程序整体性能的重要性。我们拥抱数据结构的基本性质，以优化我们的Java应用程序的性能，因为它们可以确保我们的数据访问、内存管理和缓存都是高效的。正确使用数据结构可以提高算法效率、我们解决方案的可扩展性和线程的安全性。
- en: Through code examples, we looked at nonoptimized and optimized examples of code
    for lists, arrays, trees, stacks, and queues. We also explored several advanced
    data structures and examined their added complexities. When we implement data
    structures properly, we can improve the predictability and consistency of our
    application’s performance and make our code more readable and easier to maintain.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过代码示例，我们研究了列表、数组、树、栈和队列的非优化和优化代码示例。我们还探索了几个高级数据结构，并检查了它们的附加复杂性。当我们正确实现数据结构时，我们可以提高我们应用程序性能的可预测性和一致性，并使我们的代码更易于阅读和维护。
- en: In the next chapter, we will focus on loops and how to optimize them for increased
    performance regarding our Java applications. This is a natural progression following
    our coverage of data structures as we will use them in our examples in the next
    chapter.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于循环以及如何优化它们以提高我们的Java应用程序的性能。这是在介绍数据结构之后的一个自然进展，因为我们将使用它们在下一章的示例中。
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
