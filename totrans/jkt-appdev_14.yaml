- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Services with Jakarta XML Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web services** are application programming interfaces that can be invoked
    remotely. Web services can be invoked from clients written in any language.'
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta EE includes the XML Web Services API as one of its technologies. We
    can use **XML Web Services** to develop **SOAP** (**Simple Object Access Protocol**)
    web services in the Java platform. Jakarta XML Web Services is a high-level API;
    invoking web services via Jakarta XML Web Services is done via remote procedure
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP-based web services are now a legacy technology. In most cases, RESTful
    web services are preferred to SOAP-based services for new development. Knowledge
    of SOAP-based web services is primarily useful for maintaining legacy applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing web services with Jakarta XML Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing Enterprise Beans as web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The example source code for this chapter can be found on GitHub at the following
    link: [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch14_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch14_src).'
  prefs: []
  type: TYPE_NORMAL
- en: Developing web services with Jakarta XML Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jakarta XML Web Services is a high-level API that simplifies the development
    of SOAP-based web services. Developing a web service with Jakarta XML Web Services
    consists of writing a class with public methods to be exposed as web services.
    The class needs to be annotated with `@WebService`. All public methods in the
    class are automatically exposed as web services; they can optionally be annotated
    with `@WebMethod`. The following example illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class exposes its two methods as web services. The `add()` method
    simply adds the two `int` primitives it receives as parameters and returns the
    result, and the `substract()` method subtracts its two parameters and returns
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: We indicate that the class implements a web service by decorating it with the
    `@WebService` annotation. Any methods that we would like to expose as web services
    can be decorated with the `@WebMethod` annotation, but this isn’t necessary. Since
    all public methods are automatically exposed as web services, we can still use
    the `@WebMethod` annotation for clarity, but it isn’t strictly necessary. To deploy
    our web service, we simply need to package it in a WAR file as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Web service clients need a **WSDL** (**Web Services Definition Language**) file
    in order to generate executable code that they can use to invoke the web service.
    WSDL is an XML-based language that describes the functionality offered by a SOAP-based
    web service. WSDL files are typically placed in a web server and accessed by the
    client via its URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'When deploying web services developed using Jakarta XML Web Services, a WSDL
    is automatically generated for us. The exact URL for the generated WSDL varies
    depending on the Jakarta EE runtime we are using. When using GlassFish, URLs for
    the generated WSDLs follow the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the URL for our web service’s WSDL (when deployed to GlassFish)
    would be `http://localhost:8080/calculatorservice/CalculatorService?wsdl` (assuming
    GlassFish is running on our local workstation, and GlassFish is listening for
    HTTP connections in its default `8080` port).
  prefs: []
  type: TYPE_NORMAL
- en: We can see the generated WSDL by pointing the browser to its URL, as illustrated
    in *Figure 14**.1.*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Automatically generated WSDL](img/B21231_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Automatically generated WSDL
  prefs: []
  type: TYPE_NORMAL
- en: The specifics of the WSDL aren’t really relevant to the discussion. It can be
    considered as “behind-the-scenes plumbing,” which is necessary for SOAP-based
    web services to work correctly. The WSDL URL though, is needed when developing
    web service clients.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a web service client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, web service clients need to generate executable code
    from a web service’s WSDL. A web service client will then invoke this executable
    code to access the web service.
  prefs: []
  type: TYPE_NORMAL
- en: In order to generate Java code from a WSDL, we need to use a tool called `wsimport`.
  prefs: []
  type: TYPE_NORMAL
- en: The `wsimport` tool can be obtained by downloading Eclipse Metro, at [https://eclipse-ee4j.github.io/metro-wsit/](https://eclipse-ee4j.github.io/metro-wsit/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The only required argument for `wsimport` is the URL of the WSDL corresponding
    to the web service, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will generate a number of compiled Java classes that allow client
    applications to access our web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddResponse.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Calculator.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CalculatorService.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectFactory.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package-info.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subtract.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubtractResponse.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, the source code for the generated class files is automatically deleted.
    It can be kept by passing the `-keep` parameter to `wsimport`.
  prefs: []
  type: TYPE_NORMAL
- en: These classes need to be added to the client’s `CLASSPATH` in order for them
    to be accessible to the client’s code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using Apache Maven to build our code, we can take advantage of the
    JAX-WS Maven plugin to automatically invoke `wsimport` when building our client
    code. This approach is illustrated in the following `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `pom.xml` Maven build file will automatically invoke the `wsimport`
    utility whenever we build our code via the `mvn package` or `mvn` `install` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are ready to develop a simple client to access our web service.
    We will implement our client as a Jakarta Faces application; the most relevant
    parts of our client application source are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `@WebServiceRef` annotation injects an instance of the web service into
    our client application. Its `wsdlLocation` attribute contains the URL of the WSDL
    corresponding to the web service we are invoking.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the web service class is an instance of a class called `CalculatorService`.
    This class was created when we invoked the `wsimport` utility, as `wsimport` always
    generates a class whose name is the name of the class we implemented plus the
    “Service” suffix. We use this service class to obtain an instance of the web service
    class we developed. In our example, we do this by invoking the `getCalculatorPort()`
    method on the `CalculatorService` instance. In general, the method to invoke an
    instance of our web service class follows the pattern of `getNamePort()`, where
    `Name` is the name of the class we wrote to implement the web service. Once we
    get an instance of our web service class, we can simply invoke its methods like
    with any regular Java object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, the `getNamePort()` method of the service class returns an
    instance of a class implementing an interface generated by `wsimport`. This interface
    is given the name of our web service class and declares all of the methods we
    declared to be web services. For all practical purposes, the object returned is
    equivalent to our web service class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interface for our simple client application is developed using Facelets,
    as customary when developing Jakarta Faces applications. The following code snippet
    shows the most relevant markup for our Jakarta Faces Facelets client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The user interface uses Ajax to invoke the relevant methods on the `CalculatorClientController`
    CDI named bean (refer to [*Chapter 6*](B21231_06.xhtml#_idTextAnchor073) for details).
  prefs: []
  type: TYPE_NORMAL
- en: After deploying our code, our browser should render our page as shown in *Figure
    14**.2* (this is shown after entering some data and clicking the corresponding
    buttons).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – XML Web Service Client in action](img/B21231_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – XML Web Service Client in action
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we passed the `Integer` objects as parameters and return values.
    Of course, it is also possible to pass primitive types both as parameters and
    as return values. Unfortunately, not all standard Java classes or primitive types
    can be used as method parameters or return values when invoking SOAP-based web
    services implemented with Jakarta XML Web Services. The reason for this is that
    behind the scenes, method parameters and return types get mapped to XML definitions,
    and not all types can be properly mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid types that can be used in Jakarta XML Web Service calls are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.awt.Image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Java.lang.String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.math.BigDecimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.math.BigInteger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.net.URI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Calendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.UUID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jakarta.activation.DataHandler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.datatype.Duration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.datatype.XMLGregorianCalendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.namespace.QName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.transform.Source`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, the following primitive types can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use our own custom classes as method parameters and/or return values
    for web service methods, but member variables of our classes must be one of the
    listed types.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is legal to use arrays both as method parameters or return
    values. However, when executing `wsimport`, these arrays get converted to Lists,
    generating a mismatch between the method signature in the web service and the
    method call invoked in the client. For this reason, it is preferred to use Lists
    as method parameters and/or return values, since this is also legal and does not
    create a mismatch between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Jakarta XML Web Services internally uses the **Jakarta XML Binding API** to
    create SOAP messages from method calls. The types we are allowed to use for method
    calls and return values are the ones that Jakarta XML Binding supports. For more
    information, see https://jakarta.ee/specifications/xml-binding/.
  prefs: []
  type: TYPE_NORMAL
- en: Sending attachments to web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to sending and accepting the data types discussed in the previous
    sections, web service methods can send and accept file attachments. The following
    example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In order to write a web service method that receives one or more attachments,
    all we need to do is add a parameter of the `jakarta.activation.DataHandler` type
    for each attachment the method will receive. In our example, the `attachFile()`
    method takes a single parameter of this type and simply writes it to the file
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with any standard web service, the web service code needs to be packaged
    in a `WAR` file and deployed. Once deployed, a WSDL will automatically be generated.
    We then need to execute the `wsimport` utility to generate the code that our web
    service client can use to access the web service. As previously discussed, the
    `wsimport` can be invoked from the command line or via an Apache Maven plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have executed `wsimport` to generate code to access the web service,
    we can write and compile our client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Web service attachments need to be sent as a byte array to the web service;
    therefore, web service clients need to convert the file to attach to this type.
    In our example, we send an image as an attachment, we load the image into memory
    by creating an instance of `java.net.URL`, passing the URL of the image in question
    as a parameter to its constructor. We then obtain an `InputStream` instance corresponding
    to the image by invoking the `openStream()` method on our URL instance, convert
    our `InputStream` instance to a byte array, and then pass this byte array to the
    web service method that expects an attachment.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, unlike when passing standard parameters, the parameter type used
    when the client invokes a method expecting an attachment is different from the
    parameter type of the method in the web server code. The method in the web server
    code expects an instance of `jakarta.activation.DataHandler` for each attachment;
    however, the code generated by `wsimport` expects an array of bytes for each attachment.
    These arrays of bytes are converted to the right type (`jakarta.activation.DataHandler`)
    behind the scenes by the `wsimport` generated code. We as application developers
    don’t need to concern ourselves with the details of why this happens, we just
    need to keep in mind that when sending attachments to a web service method, the
    parameter types will be different in the web service code and in the client invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Enterprise Beans as web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to creating web services as described in the previous section,
    public methods of stateless session beans can easily be exposed as web services
    by simply adding an annotation to the Enterprise Bean class. The following example
    illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the only thing we need to do to expose a stateless session bean’s
    public methods as web services is to decorate its class declaration with the `@WebService`
    annotation. Needless to say, since the class is a session bean, it also needs
    to be decorated with the `@``Stateless` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Just like regular stateless session beans, the ones whose methods are exposed
    as web services need to be deployed in a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Just like standard web services, WSDL URLs for Enterprise Beans web services
    depend on the application server being used. You can consult your application
    server documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise Beans web service clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following class illustrates the procedure to be followed to access an Enterprise
    Beans web service from a client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, nothing special needs to be done when accessing an Enterprise
    Beans web service from a client. The procedure is the same as with standard web
    services.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding class is a CDI named bean. *Figure 14**.3* illustrates a simple
    Jakarta Faces user interface utilizing the preceding class to invoke our web service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Enterprise Bean Web Service Client](img/B21231_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Enterprise Bean Web Service Client
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the **Int to Hex** button generates a call to the web service, which
    returns a hexadecimal value equivalent to the decimal value the user entered in
    the text input field.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to develop web services and web service clients
    via the Jakarta XML Web Service API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to develop SOAP-based web services using Jakarta XML Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to incorporate web service code generation for web service clients when
    using Maven as a build tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Valid data types that can be used for remote method calls via Jakarta XML Web
    Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to send attachments to a web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to expose Enterprise Beans methods as web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with the knowledge in this chapter, we can now develop SOAP-based web
    services, as well as maintain existing SOAP-based applications.
  prefs: []
  type: TYPE_NORMAL
