- en: Microbenchmarking Applications with JMH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took an in-depth review of **garbage collection**
    to include an object life cycle, garbage collection algorithms, garbage collection
    options, and methods related to garbage collection. We took a brief look at upgrades
    to garbage collection in Java 8 and focused on changes with the new Java 9 platform.
    Our exploration of garbage collection in Java 9 included looks at default garbage
    collection, depreciated garbage collection combinations, unified garbage collection
    logging, and garbage collection issues that persist, even after Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to write performance tests using the **Java
    Microbenchmark Harness** (**JMH**), a Java harness library for writing benchmarks
    for the **Java Virtual Machine** (**JVM**). We will use Maven along with JMH to
    help illustrate the power of microbenchmarking with the new Java 9 platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Microbenchmarking overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microbenchmarking with Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for avoiding microbenchmarking pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microbenchmarking overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microbenchmarking is used to test the performance of a system. This differs
    from macrobenchmarking which runs tests on different platforms for efficiency
    comparison and subsequent analysis. With microbenchmarking, we typically target
    a specific slice of code on one system such as a method or loop. The primary purpose
    of microbenchmarking is to identify optimization opportunities in our code.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple approaches to benchmarking and we will focus on using the
    JMH tool. So, why benchmark at all? Developers do not always concern themselves
    with performance issues unless performance is a stated requirement. This can lead
    to post-deployment surprises that could have been avoided if microbenchmarking
    was conducted as part of the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microbenchmarking takes place across several phases of a process. As shown
    in the following diagram, the process involves design, implementation, execution,
    analysis, and enhancement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9977e7cd-6e56-40fc-abfd-4c115659bf82.png)'
  prefs: []
  type: TYPE_IMG
- en: In the **Design** phase, we determine our goals and design our microbenchmark
    accordingly. In the **Implement** phase, we are writing the microbenchmark and
    then, in the **Execution** phase, we actually run the test. With microbenchmarking
    results in hand, we interpret and analyze the results in the **Analysis** phase.
    This leads to code improvements in the **Enhancement** phase. Once our code has
    been updated, we redesign the microbenchmarking test, adjust the implementation,
    or go straight to the **Execution** phase. This is a cyclical process that continues
    until we have achieved the performance optimization we identified in our goals.
  prefs: []
  type: TYPE_NORMAL
- en: Approach to using JMH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oracle's documentation indicates that the most ideal JMH use case is to use
    a Maven project that is dependent on the application's JAR files. They further
    recommend that microbenchmarking take place via the command-line and not from
    within an **Integrated Development Environment** (**IDE**), as that could impact
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: Maven, also referred to as Apache Maven, is a project management and comprehension
    tool that we can use to manage our application project build, reporting, and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: To use JMH, we will use bytecode processors (annotations) to generate the benchmark
    code. We use Maven archetypes to enable JMH.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test the JMH, we require an IDE with support for Maven and Java
    9\. If you do not yet have Java 9 or an IDE with Java 9 support, you can follow
    the steps in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Java 9 and Eclipse with Java 9 support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download and install Java 9 from the JDK 9 early access builds page--[http://jdk.java.net/9/](http://jdk.java.net/9/).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Java 9 installed, download the latest version of Eclipse. At the
    time of writing this book, that was Oxygen. Here is the relevant link--[https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to enable Java 9 support in your IDE. Launch Eclipse Oxygen
    and select Help | Eclipse Marketplace... , as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e58605c5-04d5-43d6-942f-30f91ead584a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the Eclipse Marketplace dialog window present search for `Java 9 support`
    using the search box. As you can see in the following screenshot, you will be
    presented with an Install button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88048ea3-6896-40f5-8e18-0ca017da2467.png)'
  prefs: []
  type: TYPE_IMG
- en: During the installation process, you will be required to accept the license
    agreement and, upon completion, you will be required to restart Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have Eclipse updated to support Java 9, you can run a quick test
    to determine if JMH is working on your development computer. Start by creating
    a new Maven project as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0904716-b8d9-449f-9268-135f980bb6c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to add a dependency. We can do this by editing the `pom.xml`
    file directly with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the dependencies tab to enter the data in a dialog
    window, as shown in the following screenshot. Using this form updates the `pom.xml`
    file with the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ffc4351-aeba-4856-9192-4a51606dc064.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to write a class that contains a JMH method. This is just as
    an initial test to confirm our recently updated development environment. Here
    is sample code you can use for your test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now compile and run our very simple test program. The results are provided
    in the Console tab, or the actual console if you are using the command-line. Here
    is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2805c145-4579-4ce4-8cb5-ae9b8cb969e1.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the program worked sufficiently to let us know that JMH is
    working. Of course, there was, as the output indicates, no benchmarks set up.
    We will take care of that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Microbenchmarking with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One approach to getting started with JMH is to use the JMH Maven archetype.
    The first step is to create a new JMH project. At our system''s command prompt,
    we will enter the `mvn` command followed by a long set of parameters to create
    a new Java project and the necessary Maven `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you enter the `mvn` command and the preceding detailed parameters, you
    will see the results reported to you via the Terminal. Depending on your level
    of use, you might see a large number of downloads from [https://repo.maven.apache.org/maven2/org/apache/mave/plugins](https://repo.maven.apache.org/maven2/org/apache/mave/plugins)
    and other similar repository sites.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also see an information section that informs you about the project
    build process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14f51f0d-5ca9-43ef-9dc3-12be9b272e61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There will likely be additional plugin and other resources downloaded from
    the [https://repo.maven.apache.org](https://repo.maven.apache.org) repositories.
    Then, you will see an informational feedback component that lets you know the
    project is being generated in batch mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1426df05-6070-4f4c-a711-451f75765d2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you will be presented with a set of parameters and a note that your
    project build was successful. As you can see with the following example, the process
    took less than 21 seconds to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/188f1b35-cf34-416f-8019-07dd0806dbe4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A folder will be created based on the parameter we included in the `-DartifactId`
    option. In our example, we used `-DartifactId=chapter8-benchmark`, and Maven created
    a `chapter8-benchmark` project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3aa8bd9-3964-4a9d-8f04-d22ae270f386.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see that Maven created the `pom.xml` file as well as a source (`src`)
    folder. In that folder, under the subdirectory structure of `C:chapter8-benchmarksrcmainjavacompackt`,
    is the `MyBenchmark.java` file. Maven created a benchmark class for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12e79714-00f2-4413-8eb4-1705d52cbc06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the contents of the `MyBenchmark.java` class created by the JMH Maven
    project creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to modify the `testMethod()` so that there is something to
    test. Here is the modified method we will use for the benchmark test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With our code edited, we will navigate back to the project folder, `C:chapter8-benchmark`,
    in our example, and execute `mvn clean install` at the command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see several repository downloads, source compilations, plugin installations
    and, finally the Build Success indicator, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe83ee6f-a43d-461b-9a11-b0d6a8f67a51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will now see `.classpath` and `.project` files as well as a new `.settings`
    and target subfolders in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62579177-8493-4b9f-8973-68928d464e29.png)'
  prefs: []
  type: TYPE_IMG
- en: If you navigate to the `target` subfolder, you will see that our `benchmarks.jar`
    file was created. This JAR contains what we need to run our benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update our `MyBenchmark.java` file in an IDE, such as Eclipse. Then,
    we can execute `mvn clean install` again to overwrite our files. After the initial
    time, our builds will be much faster, as nothing will need to be downloaded. Here
    is a look at the output from the build process other than the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25c6fa3b-caf1-4c57-af99-8c1b1cc7c8db.png)'
  prefs: []
  type: TYPE_IMG
- en: Our last step is to run the benchmark tool. We can do that with the following
    command--`java -jar benchmarks.jar`. Even for small benchmarks on simplistic code,
    as with our example, the benchmarks could take some time to run. There will likely
    be several iterations including warmups to provide a more concise and valid set
    of benchmark results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our benchmark results are provided here. As you can see, the test ran for 8
    minutes and 8 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fccf36e9-565b-4d8b-a090-3a168879b908.png)'
  prefs: []
  type: TYPE_IMG
- en: Benchmarking options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how to run a benchmark test. In this section,
    we will look at the following configurable options for running our benchmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: Modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The output of our benchmark results, from the previous section, included a
    **Mode** column that had the value of **thrpt** which is short for **throughput**.
    This is the default mode and there are an additional four modes. All JMH benchmark
    modes are listed and described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| All | Measures all other modes inclusively. |'
  prefs: []
  type: TYPE_TB
- en: '| Average | This mode measures the average time for a single benchmark to run.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sample Time | This mode measures the benchmark execution time and includes
    min and max times. |'
  prefs: []
  type: TYPE_TB
- en: '| Single Shot Time | With this mode, there is no JVM warm up and the test is
    to determine how long a single benchmark method takes to run. |'
  prefs: []
  type: TYPE_TB
- en: '| Throughput | This is the default mode and measures the number of operations
    per second the benchmark could be run. |'
  prefs: []
  type: TYPE_TB
- en: 'To dictate which benchmark mode to use, you will modify your `@Benchmark` line
    of code to one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Time units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to gain greater fidelity in benchmark output, we can designate a specific
    unit of time, listed here from shortest to longest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NANOSECONDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MICROSECONDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MILLISECONDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SECONDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MINUTES`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HOURS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DAYS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to make this designation, we simply add the following code to our
    `@Benchmark` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have designated the average mode and nanoseconds
    as the time unit.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for avoiding microbenchmarking pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microbenchmarking is not something that every developer will have to worry about,
    but for those that do, there are several pitfalls that you should be aware of.
    In this section we will review the most common pitfalls and suggest strategies
    for avoiding them.
  prefs: []
  type: TYPE_NORMAL
- en: Power management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many subsystems that can be used to help you manage the balance between
    power and performance (that is, `cpufreq`). These systems can alter the state
    of time during benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two suggested strategies to this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable any power management systems before running tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the benchmarks for longer periods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS schedulers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operating system schedulers, such as Solaris schedulers, help determine which
    software processes gain access to a system's resources. Use of these schedulers
    can result in unreliable benchmarking results.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two suggested strategies to this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: Refine your system scheduling policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the benchmarks for longer periods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time-sharing systems are used to help balance system resources. Use of these
    systems often results in irregular gaps between a thread's start and stop time.
    Also, CPU load will not be uniform and our benchmarking data will not be as useful
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two suggested strategies to avoid this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: Test all code before running benchmarks to ensure things work as they should
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JMH to measure only after all threads have started or all threads have stopped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eliminating dead-code and constant folding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dead-code and constant folding are often referred to as redundant code and
    our modern compilers are pretty good at eliminating them. An example of dead-code
    is code that will never be reached. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our preceding example, the line identified as dead-code is never reached
    since the variable value will never be equal to null. It is set to `10` immediately
    before the conditional `if` statement evaluates the variable.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that benchmarking code can sometimes be removed in the attempt
    to eliminate dead-code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constant folding is the compiler operation that occurs when compile-time constraints
    are replaced with actual results. The compiler performs constant folding to remove
    any redundant runtime computations. In the following example, we have a `final
    int` followed by a second `int` based on a mathematical calculation involving
    the first `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The constant folding operation would convert the two lines of the preceding
    code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one suggested strategy to this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the JMH API support to ensure your benchmarking code is not eliminated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run-to-run variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a plethora of issues that can drastically impact the run-to-run variance
    in benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two suggested strategies to this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the JVM multiple times within every subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiple JMH folks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache capacity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dynamic randomly accessed memory** (**DRAM**) is very slow. This can result
    in very different performance results during benchmarking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two suggested strategies to this pitfall:'
  prefs: []
  type: TYPE_NORMAL
- en: Run multiple benchmarks with varying problem sets. Keep track of your memory
    footprint during tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the `@State` annotation to dictate the JMH state. This annotation is sued
    to define the instance''s scope. There are three states:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scope.Benchmark`: The instance is shared across all threads that are running
    the same test.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scope.Group`: One instance is allocated per thread group.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scope.Thread`: Each thread will have its own instance. This is the default
    state.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that the JMH is a Java harness library for writing
    benchmarks for the JVM. We experimented with writing performance tests using Maven
    along with JMH to help illustrate the procedures of microbenchmarking with the
    new Java 9 platform. We started with a microbenchmarking overview, then dove deep
    into microbenchmarking with Maven, reviewed benchmarking options, and concluded
    with a few techniques for avoiding microbenchmarking pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn to write an application that is managing
    other processes and utilizes the modern process management API of the Java 9 platform.
  prefs: []
  type: TYPE_NORMAL
