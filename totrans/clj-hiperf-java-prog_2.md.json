["```java\nuser=> (identical? \"foo\" \"foo\")  ; literals are automatically interned\ntrue\nuser=> (identical? (String. \"foo\") (String. \"foo\"))  ; created string is not interned\nfalse\nuser=> (identical? (.intern (String. \"foo\")) (.intern (String. \"foo\")))\ntrue\nuser=> (identical? (str \"f\" \"oo\") (str \"f\" \"oo\"))  ; str creates string\nfalse\nuser=> (identical? (str \"foo\") (str \"foo\"))  ; str does not create string for 1 arg\ntrue\nuser=> (identical? (read-string \"\\\"foo\\\"\") (read-string \"\\\"foo\\\"\"))  ; not interned\nfalse\nuser=> (require '[clojure.edn :as edn])  ; introduced in Clojure 1.5\nnil\nuser=> (identical? (edn/read-string \"\\\"foo\\\"\") (edn/read-string \"\\\"foo\\\"\"))\nfalse\n```", "```java\nuser=> (identical? (.intern \"foo\") (.intern \"foo\"))\ntrue\nuser=> (identical? (symbol \"foo\") (symbol \"foo\"))\nfalse\nuser=> (identical? (symbol (.intern \"foo\")) (symbol (.intern \"foo\")))\nfalse\n```", "```java\n    {:a 10 :b 20}  ; array-map up to 8 pairs\n    {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9}  ; hash-map for 9 or more pairs\n    ```", "```java\n    (sorted-map :a 10 :b 20 :c 30)  ; (keys ..) should return sorted\n    ```", "```java\n    (sorted-set :a :b :c)\n    ```", "```java\n    (import 'clojure.lang.PersistentQueue)\n    (reduce conj PersistentQueue/EMPTY [:a :b :c :d])  ; add to queue\n    (peek queue)  ; read from queue\n    (pop queue)  ; remove from queue\n    ```", "```java\nList<String> titles = getTitles();\nint goodCount = 0;\nfor (String each: titles) {\n  String checksum = computeChecksum(each);\n  if (verifyOK(checksum)) {\n    goodCount++;\n  }\n}\n```", "```java\n(->> (get-titles)\n  (map compute-checksum)\n  (filter verify-ok?)\n  count)\n```", "```java\n(defn retry? [n]\n  (if (<= n 0)\n    (cons false (lazy-seq (retry? 0)))\n    (cons true (lazy-seq (retry? (dec n))))))\n```", "```java\nuser=> (take 7 (retry? 5))\n(true true true true true false false)\n```", "```java\n(loop [r (retry? 5)]\n  (if-not (first r)\n    (println \"No more retries\")\n    (do\n      (println \"Retrying\")\n      (recur (rest r)))))\n```", "```java\nRetrying\nRetrying\nRetrying\nRetrying\nRetrying\nNo more retries\nnil\n```", "```java\n(defn count-down [n]\n  (if (<= n 0)\n    '(0)\n    (cons n (lazy-seq (count-down (dec n))))))\n```", "```java\nuser=> (count-down 8)\n(8 7 6 5 4 3 2 1 0)\n```", "```java\n(defn chunked-line-seq\n  \"Returns the lines of text from rdr as a chunked[size] sequence of strings.\n  rdr must implement java.io.BufferedReader.\"\n  [^java.io.BufferedReader rdr size]\n  (lazy-seq\n    (when-let [line (.readLine rdr)]\n      (chunk-cons\n        (let [buffer (chunk-buffer size)]\n          (chunk-append buffer line)\n          (dotimes [i (dec size)]\n            (when-let [line (.readLine rdr)]\n              (chunk-append buffer line)))\n  (chunk buffer))\n(chunked-line-seq rdr size)))))\n```", "```java\n(defmacro do-something\n  [& body]\n  `(do-something* (fn [] ~@body)))\n```", "```java\n(defmacro do-something\n  [& body]\n  `(do-something* (^:once fn* [] ~@body)))\n```", "```java\nuser> (let [x (for [n (range)] (make-array Object 10000))\n      f (^:once fn* [] (nth x 1e6))]  ; using ^:once\n        (f))\n#<Object[] [Ljava.lang.Object;@402d3105>\nuser> (let [x (for [n (range)] (make-array Object 10000))\n            f (fn* [] (nth x 1e6))]         ; not using ^:once\n        (f))\nOutOfMemoryError GC overhead limit exceeded\n```", "```java\nuser=> (reduce ((filter odd?) +) [1 2 3 4 5])\n9\nuser=> (transduce (filter odd?) + [1 2 3 4 5])\n9\nuser=> (defn filter-odd? [xf]\n         (fn\n           ([] (xf))\n           ([result] (xf result))\n           ([result input] (if (odd? input)\n                               (xf result input)\n                               result))))\n#'user/filter-odd?\nuser=> (reduce (filter-odd? +) [1 2 3 4 5])\n9\n```", "```java\n;; traditional way\nuser=> (time (dotimes [_ 10000] (reduce + (filter odd? (range 10000)))))\n\"Elapsed time: 2746.782033 msecs\"\nnil\n;; using transducer\n(def fodd? (filter odd?))\nuser=> (time (dotimes [_ 10000] (transduce fodd? + (range 10000))))\n\"Elapsed time: 1998.566463 msecs\"\nnil\n```", "```java\nuser=> (let [t (transient [:a])]\n  @(future (conj! t :b)))\nIllegalAccessError Transient used by non-owner thread  clojure.lang.PersistentVector$TransientVector.ensureEditable (PersistentVector.java:463)\n```", "```java\nuser=> (let [t (transient [:a])] (seq t))\n\nIllegalArgumentException Don't know how to create ISeq from: clojure.lang.PersistentVector$TransientVector  clojure.lang.RT.seqFrom (RT.java:505)\n```", "```java\n(let [t (transient [])]\n  (conj! t :a)\n  (persistent! t)\n  (conj! t :b))\nIllegalAccessError Transient used after persistent! call  clojure.lang.PersistentVector$TransientVector.ensureEditable (PersistentVector.java:464)\n```", "```java\n(defn repeatedly*\n  \"Like `repeatedly` but faster and returns given collection type.\"\n  [coll n f]\n  (if-not (instance? clojure.lang.IEditableCollection coll)\n    (loop [v coll idx 0]\n      (if (>= idx n)\n        v\n        (recur (conj v (f)) (inc idx))))\n    (loop [v (transient coll) idx 0]\n      (if (>= idx n)\n        (persistent! v)\n        (recur (conj! v (f)) (inc idx))))))\n```", "```java\n:dependencies [;; other dependencies…\n                            [pjstadig/assertions \"0.1.0\"]]\n```", "```java\n(ns example.core\n\n  (:refer-clojure :exclude [assert])\n\n  (:require [pjstadig.assertions :refer [assert]]))\n```", "```java\n$ JVM_OPTS=-ea lein run -m example.core\n$ java -ea -jar example.jar\n```", "```java\n(defn oddsum-1 [n]  ; using iteration\n  (->> (range (inc n))\n    (filter odd?)\n    (reduce +)))\n(defn oddsum-2 [n]  ; using loop-recur\n  (loop [i 1 s 0]\n    (if (> i n)\n      s\n      (recur (+ i 2) (+ s i)))))\n```", "```java\nuser=> (time (oddsum-1 1000000))\n\"Elapsed time: 109.314908 msecs\"\n\n250000000000\nuser=> (time (oddsum-2 1000000))\n\"Elapsed time: 42.18116 msecs\"\n\n250000000000\n```", "```java\n;; let coll be a collection of numbers\n(reduce (fn ([x] x) ([x y] (if (or (zero? x) (zero? y)) (reduced 0) (* x y))))\n             coll)\n```", "```java\n(def PI Math/PI)\n(definline circumference [radius]\n  `(* 2 PI ~radius))\n```", "```java\n(def ^:const PI Math/PI)\n```", "```java\nuser=> (def a 10)\nuser=> (def ^:const b 10)\nuser=> (def ^:dynamic c 10)\nuser=> (time (dotimes [_ 100000000] (inc a)))\n\"Elapsed time: 1023.745014 msecs\"\nnil\nuser=> (time (dotimes [_ 100000000] (inc b)))\n\"Elapsed time: 226.732942 msecs\"\nnil\nuser=> (time (dotimes [_ 100000000] (inc c)))\n\"Elapsed time: 1094.527193 msecs\"\nnil\n```", "```java\n(ns foo.core)\n\n(defn mul [x y]\n  (* x y))\n```", "```java\ntarget/classes/\n`-- foo\n    |-- core$fn__18.class\n    |-- core__init.class\n    |-- core$loading__4910__auto__.class\n    `-- core$mul.class\n```", "```java\npackage foo;\n\nimport clojure.lang.AFunction;\nimport clojure.lang.Numbers;\nimport clojure.lang.RT;\nimport clojure.lang.Var;\n\npublic final class core$mul extends AFunction\n{\n  public static final Var const__0 = (Var)RT.var(\"clojure.core\", \"*\");\n\n  public Object invoke(Object x, Object y) { x = null; y = null; return Numbers.multiply(x, y);\n  }\n}\n```", "```java\nuser=> (binding [*compiler-options* {:disable-locals-clearing true}] (compile 'foo.core))\nfoo.core\n```", "```java\n(set! *unchecked-math* true)\n```", "```java\nuser=> (set! *warn-on-reflection* true)\ntrue\nuser=> (def s \"Hello, there\")\n#'user/s\nuser=> (.length s)\nReflection warning, NO_SOURCE_PATH:1 - reference to field length can't be resolved.\n12\nuser=> (defn str-len [^String s] (.length s))\n#'user/str-len\nuser=> (str-len s)\n12\nuser=> (.length ^String s)  ; type hint when passing argument\n12\nuser=> (def ^String t \"Hello, there\")  ; type hint at var level\n#'user/t\nuser=> (.length t)  ; no more reflection warning\n12\nuser=> (time (dotimes [_ 1000000] (.length s)))\nReflection warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init6904047906685577265.clj:1:28 - reference to field length can't be resolved.\n\"Elapsed time: 2409.155848 msecs\"\nnil\nuser=> (time (dotimes [_ 1000000] (.length t)))\n\"Elapsed time: 12.991328 msecs\"\nnil\n```", "```java\n:profiles {:dev {:global-vars {*warn-on-reflection* true}}}\n```", "```java\n(def a (int-array [10 20 30 40 50 60]))\n;; amap example\n(seq\n (amap ^ints a idx ret\n    (do (println idx (seq ret))\n      (inc (aget ^ints a idx)))))\n;; areduce example\n(areduce ^ints a idx ret 0\n  (do (println idx ret)\n    (+ ret idx)))\n```", "```java\n(def ^ints a (int-array [10 20 30 40 50 60]))  ; wrong, will complain later\n(def ^\"[I\" a (int-array [10 20 30 40 50 60]))  ; correct\n(def ^{:tag 'ints} a (int-array [10 20 30 40 50 60])) ; correct\n```", "```java\n(defn do-something\n  [^long a ^long b ^long c ^long d]\n  ..)\n```", "```java\n(defmacro str-len\n  [s]\n  `(.length ~(with-meta s {:tag String})))\n;; below is another way to write the same macro\n(defmacro str-len\n  [s]\n  `(.length ~(vary-meta s assoc :tag `String)))\n```", "```java\n(defmacro str-len\n  [s]\n  `(let [^String s# ~s] (.length s#)))\n```", "```java\n(defn foo [] \"Hello\")\n(defn foo ^String [] \"Hello\")\n(defn foo (^String [] \"Hello\") (^String [x] (str \"Hello, \" x)))\n```", "```java\n(require '[stringer.core :as s])\nuser=> (time (dotimes [_ 10000000] (str \"foo\" :bar 707 nil 'baz)))\n\"Elapsed time: 2044.284333 msecs\"\nnil\nuser=> (time (dotimes [_ 10000000] (s/strcat \"foo\" :bar 707 nil 'baz)))\n\"Elapsed time: 555.843271 msecs\"\nnil\n```", "```java\n(deftype Counter [^:volatile-mutable ^long now]\n  ..)\n```", "```java\n(definterface Foo\n  (^long doSomething [^long a ^double b]))\n```", "```java\n(proxy [Object][]\n  (equals [other]\n    (let [^Object this this]\n      (proxy-super equals other))))\n```", "```java\n:dependencies [;; other dependencies\n               [prismatic/hiphip \"0.2.0\"]]\n```", "```java\n(require '[hiphip.double :as hd])\n\n(def xs (double-array [12.3 23.4 34.5 45.6 56.7 67.8]))\n\n(let [s (hd/asum xs)] (hd/amap [x xs] (/ x s)))\n```", "```java\n:dependencies [;; other dependencies\n               [primitive-math \"0.1.4\"]]\n```", "```java\n;; must enable reflection warnings for extra warnings from primitive-math\n(set! *warn-on-reflection* true)\n(require '[primitive-math :as pm])\n(defn mul [x y] (pm/* x y))  ; primitive-math produces reflection warning\n(mul 10.3 2)                        ; throws exception\n(defn mul [^long x ^long y] (pm/* x y))  ; no warning after type hinting\n(mul 10.3 2)  ; returns 20\n```", "```java\n(set! *unchecked-math* :warn-on-boxed)\n\n(defn sum-till [n] (/ (* n (inc n)) 2))  ; causes warning\nBoxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:28 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_inc(java.lang.Object).\nBoxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:23 - call: public static java.lang.Number clojure.lang.Numbers.unchecked_multiply(java.lang.Object,java.lang.Object).\nBoxed math warning, /private/var/folders/cv/myzdv_vd675g4l7y92jx9bm5lflvxq/T/form-init3701519533014890866.clj:1:20 - call: public static java.lang.Number clojure.lang.Numbers.divide(java.lang.Object,long).\n\n;; now we define again with type hint\n(defn sum-till [^long n] (/ (* n (inc n)) 2))\n```", "```java\n:global-vars {*unchecked-math* :warn-on-boxed}\n```", "```java\n:dependencies [;;other dependencies\n               [proteus \"0.1.4\"]]\n```", "```java\n(require '[proteus :as p])\n(p/let-mutable [a 10]\n  (println a)\n  (set! a 20)\n  (println a))\n;; Output below:\n;; 10\n;; 20\n```", "```java\n(p/let-mutable [a 10 add2! (fn [x] (set! x (+ 2 x)))]\n  (add2! a)\n  (println a))\n```", "```java\n(require 'clojure.repl)\n(clojure.repl/pst (Throwable.))\n```", "```java\njava \\\n  -server \\\n  -Xms4096m -Xmx4096m \\\n  -XX:+UseParallelOldGC XX:ParallelGCThreads=4 \\\n  -jar application-standalone.jar\n```", "```java\nuser=> (time (reduce + (range 100000)))\n\"Elapsed time: 112.480752 msecs\"\n4999950000\nuser=> (time (reduce + (range 1000000)))\n\"Elapsed time: 387.974799 msecs\"\n499999500000\n```", "```java\n{:user {:plugins [[criterium \"0.4.3\"]]}}\n```", "```java\n:dependencies [[org.clojure/clojure \"1.7.0\"]\n               [criterium \"0.4.3\"]]\n```", "```java\nuser=> (require '[criterium.core :as c])\nnil\nuser=> (c/bench (reduce + (range 100000)))\nEvaluation count : 1980 in 60 samples of 33 calls.\n             Execution time mean : 31.627742 ms\n    Execution time std-deviation : 431.917981 us\n   Execution time lower quantile : 30.884211 ms ( 2.5%)\n   Execution time upper quantile : 32.129534 ms (97.5%)\nnil\n```", "```java\n:jvm-opts ^:replace [\"-server\"]\n```", "```java\n// Java example\nsynchronized (someObject) {\n    // do something\n}\n;; Clojure example\n(locking some-object\n  ;; do something\n  )\n\n```", "```java\n// Java example\npublic class Person {\n    volatile long age;\n}\n;; Clojure example\n(deftype Person [^:volatile-mutable ^long age])\n```", "```java\nuser=> (def a (volatile! 10))\n#'user/a\nuser=> (vswap! a inc)\n11\nuser=> @a\n11\nuser=> (vreset! a 20)\n20\nuser=> (volatile? a)\ntrue\n```", "```java\n(import 'java.util.concurrent.atomic.AtomicReference)\n(def ^AtomicReference x (AtomicReference. \"foo\"))\n(.compareAndSet x \"foo\" \"bar\")\n(import 'java.util.concurrent.atomic.AtomicInteger)\n(def ^AtomicInteger y (AtomicInteger. 10))\n(.getAndAdd y 5)\n```", "```java\nuser=> (def a (atom 0))\n#'user/a\nuser=> (swap! a inc)\n1\nuser=> @a\n1\nuser=> (compare-and-set! a 1 5)\ntrue\nuser=> (reset! a 20)\n20\n```", "```java\nuser=> (def a (atom 0 :meta {:foo :bar}))\nuser=> (meta a)\n{:foo :bar}\nuser=> (def age (atom 0 :validator (fn [x] (if (> x 200) false true))))\nuser=> (reset! age 200)\n200\nuser=> (swap! age inc)\nIllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\n```", "```java\n(def ^:const n-cpu (.availableProcessors (Runtime/getRuntime)))\n(def counters (vec (repeatedly n-cpu #(atom 0))))\n(defn inc! []\n  ;; consider java.util.concurrent.ThreadLocalRandom in Java 7+\n  ;; which is faster than Math/random that rand-int is based on\n  (let [i (rand-int n-cpu)]\n    (swap! (get counters i) inc)))\n(defn value []\n  (transduce (map deref) + counters))\n```", "```java\n(import 'java.util.concurrent.ThreadLocalRandom)\n(defn inc! []\n  (let [i (.nextLong (ThreadLocalRandom/current) n-cpu)]\n    (swap! (get counters i) inc)))\n```", "```java\n(def a (agent 0))\n;; invoke (inc 0) in another thread and set state of a to result\n(send a inc)\n@a  ; returns 1\n;; invoke (+ 1 2 3) in another thread and set state of a to result\n(send a + 2 3)\n@a  ; returns 6\n\n(shutdown-agents)  ; shuts down the thread-pools\n;; no execution of action anymore, hence no result update either\n(send a inc)\n@a  ; returns 6\n```", "```java\n(import 'clojure.lang.Agent)\nAgent/pooledExecutor  ; thread-pool for low latency actions\nAgent/soloExecutor  ; thread-pool for I/O actions\n(import 'java.util.concurrent.Executors)\n(def a-pool (Executors/newFixedThreadPool 10))  ; thread-pool with 10 threads\n(def b-pool (Executors/newFixedThreadPool 100)) ; 100 threads pool\n(def a (agent 0))\n(send-via a-pool a inc)  ; use 'a-pool' for the action\n(set-agent-send-executor! a-pool)  ; override default thread-pool\n(set-agent-send-off-executor! b-pool)  ; override default pool\n```", "```java\n(def g (agent 0))\n(send g (partial / 10))  ; ArithmeticException due to divide-by-zero\n@g  ; returns 0, because the error did not change the old state\n(send g inc)  ; throws the cached ArithmeticException\n(agent-error g)  ; returns (doesn't throw) the exception object\n(restart-agent g @g)  ; clears the suspension of the agent\n(agent-error g)  ; returns nil\n(send g inc)  ; works now because we cleared the cached error\n@g  ; returns 1\n(dotimes [_ 1000] (send-off g long-task))\n;; block for 100ms or until all actions over (whichever earlier)\n(await-for 100 g)\n(await g)  ; block until all actions dispatched till now are over\n```", "```java\n(def g (agent 0 :error-handler (fn [x] (println \"Found:\" x))))  ; incorrect arity\n(send g (partial / 10))  ; no error encountered because error-handler arity is wrong\n(def g (agent 0 :error-handler (fn [ag x] (println \"Found:\" x))))  ; correct arity\n(send g (partial / 10))  ; prints the message\n(set-error-handler! g (fn [ag x] (println \"Found:\" x)))  ; equiv of :error-handler arg\n(def h (agent 0 :error-mode :continue))\n(send h (partial / 10))  ; error encountered, but agent not suspended\n(send h inc)\n@h  ; returns 1\n(set-error-mode! h :continue)  ; equiv of :error-mode arg, other possible value :fail\n```", "```java\n(def r1 (ref [:a :b :c]))\n(def r2 (ref [1 2 3]))\n(alter r1 conj :d)  ; IllegalStateException No transaction running...\n(dosync (let [v (last @r1)] (alter r1 pop) (alter r2 conj v)))\n@r1  ; returns [:a :b]\n@r2  ; returns [1 2 3 :c]\n(dosync (ref-set r1 (conj @r1 (last @r2))) (ref-set r2 (pop @r2)))\n@r1  ; returns [:a :b :c]\n@r2  ; returns [1 2 3]\n```", "```java\n(def r (ref 0 :min-history 5 :max-history 10))\n(ref-history-count r)  ; returns 0, because no snapshot instances are queued so far\n(ref-min-history r)  ; returns 5\n(ref-max-history r)  ; returns 10\n(future (dosync (println \"Sleeping 20 sec\") (Thread/sleep 20000) (ref-set r 10)))\n(dosync (alter r inc))  ; enter this within few seconds after the previous expression\n;; The message \"Sleeping 20 sec\" should appear twice due to transaction-retry\n(ref-history-count r)  ; returns 2, the number of snapshot history elements\n(.trimHistory ^clojure.lang.Ref r)\n(ref-history-count r)  ; returns 0 because we wiped the history\n(ref-min-history r 10)  ; reset the min history\n(ref-max-history r 20)  ; reset the max history count\n```", "```java\n(def ^:dynamic *foo* \"bar\")\n(println *foo*)  ; prints bar\n(binding [*foo* \"baz\"] (println *foo*))  ; prints baz\n(binding [*foo* \"bar\"] (set! *foo* \"quux\") (println *foo*))  ; prints quux\n```", "```java\n(def t (atom 1 :validator pos?))\n(def g (agent 1 :validator pos?))\n(def r (ref 1 :validator pos?))\n(swap! t inc)  ; goes through, because value after increment (2) is positive\n(swap! t (constantly -3))  ; throws exception\n(def v 10)\n(set-validator! (var v) pos?)\n(set-validator! t (partial < 10)) ; throws exception\n(set-validator! g (partial < 10)) ; throws exception\n(set-validator! r #(< % 10)) ; works\n```", "```java\n(def t (atom 1))\n(defn w [key iref oldv newv] (println \"Key:\" key \"Old:\" oldv \"New:\" newv))\n(add-watch t :foo w)\n(swap! t inc)  ; prints \"Key: :foo Old: 1 New: 2\"\n```", "```java\n(import 'java.util.concurrent.ConcurrentHashMap)\n(def ^ConcurrentHashMap m (ConcurrentHashMap.))\n(.put m :english \"hi\")                    ; individual operation\n(.get m :english)                           ; individual operation\n(.putIfAbsent m :spanish \"alo\")    ; individual operation\n(.replace m :spanish \"hola\")         ; individual operation\n(.replace m :english \"hi\" \"hello\")  ; individual compare-and-swap atomic operation\n(.remove m :english)                     ; individual operation\n(.clear m)    ; aggregate operation\n(.size m)      ; aggregate operation\n(count m)    ; internally uses the .size() method\n;; aggregate operation\n(.putAll m {:french \"bonjour\" :italian \"buon giorno\"})\n(.keySet m)  ; aggregate operation\n(keys m)      ; calls CHM.entrySet() and on each pair java.util.Map.Entry.getKey()\n(vals m)       ; calls CHM.entrySet() and on each pair java.util.Map.Entry.getValue()\n```", "```java\n(import 'java.util.concurrent.ConcurrentLinkedQueue)\n(def ^ConcurrentLinkedQueue q (ConcurrentLinkedQueue.))\n(.add q :foo)\n(.add q :bar)\n(.poll q)  ; returns :foo\n(.poll q)  ; returns :bar\n```", "```java\n(defn foo5 [] (dotimes [_ 5] (println \"Foo\")))\n(defn barN [n] (dotimes [_ n] (println \"Bar\")))\n(.start (Thread. foo5))  ; prints \"Foo\" 5 times\n(.start (Thread. (partial barN 3)))  ; prints \"Bar\" 3 times\n```", "```java\n(import 'java.util.concurrent.Executors)\n(import 'java.util.concurrent.ExecutorService)\n(def ^ExecutorService a (Executors/newSingleThreadExecutor))  ; bounded pool\n(def ^ExecutorService b (Executors/newCachedThreadPool))  ; unbounded pool\n(def ^ExecutorService c (Executors/newFixedThreadPool 5))  ; bounded pool\n(.execute b #(dotimes [_ 5] (println \"Foo\")))  ; prints \"Foo\" 5 times\n```", "```java\n(import 'java.util.concurrent.Callable)\n(import 'java.util.concurrent.Future)\n(def ^ExecutorService e (Executors/newSingleThreadExecutor))\n(def ^Future f (.submit e (cast Callable #(reduce + (range 10000000)))))\n(.get f)  ; blocks until result is processed, then returns it\n```", "```java\n;; runs body in new thread\n(def f (future (println \"Calculating\") (reduce + (range 1e7))))\n(def g (future-call #(do (println \"Calculating\") (reduce + (range 1e7)))))  ; takes no-arg fn\n(future? f)                  ; returns true\n(future-cancel g)        ; cancels execution unless already over (can stop mid-way)\n(future-cancelled? g) ; returns true if canceled due to request\n(future-done? f)         ; returns true if terminated successfully, or canceled\n(realized? f)               ; same as future-done? for futures\n@f                              ; blocks if computation not yet over (use deref for timeout)\n```", "```java\n(let [f (future (println \"[f] Before sleep\")\n                (Thread/sleep 2000)\n                (println \"[f] After sleep\")\n                2000)]\n  (Thread/sleep 1000)\n  (future-cancel f)\n  (future-cancelled? f))\n;; [f] Before sleep  ← printed message (second message is never printed)\n;; true  ← returned value (due to future-cancelled?)\n```", "```java\n(def p (promise))\n(realized? p)  ; returns false\n@p  ; at this point, this will block until another thread delivers the promise\n(deliver p :foo)\n@p  ; returns :foo (for timeout use deref)\n```", "```java\n(pmap (partial reduce +)\n        [(range 1000000)\n         (range 1000001 2000000)\n         (range 2000001 3000000)])\n```", "```java\n(def tdata [23 19 21 24 26 20 22 21 25 168 23 20 29 172 22 24 26])\n\n(defn var-std-dev\n  \"Return variance and standard deviation in a vector\"\n  [data]\n  (let [size (count data)\n        mean (/ (reduce + data) size)\n        sum (->> data\n                 (map #(let [v (- % mean)] (* v v)))                 (reduce +))\n        variance (double (/ sum (dec size)))]\n    [variance (Math/sqrt variance)]))\n\nuser=> (println (var-std-dev tdata))\n[2390.345588235294 48.89116063497873]\n```", "```java\nuser=> (require '[criterium.core :refer [bench]])\nnil\nuser=> (bench (reduce + (range 1000)))\nEvaluation count : 162600 in 60 samples of 2710 calls.\n             Execution time mean : 376.756518 us\n    Execution time std-deviation : 3.083305 us\n   Execution time lower quantile : 373.021354 us ( 2.5%)\n   Execution time upper quantile : 381.687904 us (97.5%)\n\nFound 3 outliers in 60 samples (5.0000 %)\nlow-severe 2 (3.3333 %)\nlow-mild 1 (1.6667 %)\n Variance from outliers : 1.6389 % Variance is slightly inflated by outliers\n```", "```java\n(ns foo.bench\n  (:require [perforate.core :as p]))\n\n(p/defgoal str-concat \"String concat\")\n(p/defcase str-concat :apply\n  [] (apply str [\"foo\" \"bar\" \"baz\"]))\n(p/defcase str-concat :reduce\n  [] (reduce str [\"foo\" \"bar\" \"baz\"]))\n\n(p/defgoal sum-numbers \"Sum numbers\")\n(p/defcase sum-numbers :apply\n  [] (apply + [1 2 3 4 5 6 7 8 9 0]))\n(p/defcase sum-numbers :reduce\n  [] (reduce + [1 2 3 4 5 6 7 8 9 0]))\n```", "```java\n(ns foo.bench\n  (:require [citius.core :as c]))\n\n(c/with-bench-context [\"Apply\" \"Reduce\"]\n  {:chart-title \"Apply vs Reduce\"\n   :chart-filename \"bench-simple.png\"}\n  (c/compare-perf\n    \"concat strs\"\n    (apply str [\"foo\" \"bar\" \"baz\"])\n    (reduce str [\"foo\" \"bar\" \"baz\"]))\n  (c/compare-perf\n    \"sum numbers\"\n    (apply + [1 2 3 4 5 6 7 8 9 0])\n    (reduce + [1 2 3 4 5 6 7 8 9 0])))\n```", "```java\n(ns foo.bench\n  (:require\n    [clojure.test :refer [deftest]]\n    [citius.core :as c])\n  (:import [java.util.concurrent.atomic AtomicLong]))\n\n(def a (atom 0))\n(def ^AtomicLong b (AtomicLong. 0))\n\n(deftest test-counter\n  (c/with-bench-context [\"Atom\" \"AtomicLong\"] {}\n    (c/compare-perf \"counter\"\n      (swap! a unchecked-inc) (.incrementAndGet b))))\n\n;; Under Unix-like systems run the following command in terminal:\n;; CITIUS_CONCURRENCY=4,4 lein test\n```", "```java\n(import '[java.util.concurrent ExecutorService Executors Future])\n(defn concurrently\n  ([n f]\n    (concurrently n f #(mapv deref %)))\n  ([n f g]\n    (let [^ExecutorService\n          thread-pool (Executors/newFixedThreadPool n)\n          future-vals (transient [])]\n      (dotimes [i n]\n        (let [^Callable task (if (coll? f) (nth f i) f)\n              ^Future each-future (.submit thread-pool task)]\n          (conj! future-vals each-future)))\n      (try\n        (g (persistent! future-vals))\n        (finally\n          (.shutdown thread-pool))))))\n\n(defn call-count\n  []\n  (let [stats (atom 0)]\n    (fn\n      ([] (deref stats))\n      ([k] (if (identical? :reset k)\n             (reset! stats 0)\n             (swap! stats unchecked-inc))))))\n\n(defn wrap-call-stats\n  [stats f]\n  (fn [& args]\n    (try\n      (let [result (apply f args)]\n        (stats :count)\n        result))))\n\n(defn wait-until-millis\n  ([^long timeout-millis]\n    (wait-until-millis timeout-millis 100))\n  ([^long timeout-millis ^long progress-millis]\n    (while (< (System/currentTimeMillis) timeout-millis)\n      (let [millis (min progress-millis\n                     (- timeout-millis (System/currentTimeMillis)))]\n        (when (pos? millis)\n          (try\n            (Thread/sleep millis)\n            (catch InterruptedException e\n              (.interrupt ^Thread (Thread/currentThread))))\n          (print \\.)\n          (flush))))))\n```", "```java\n(defn benchmark-throughput*\n  [^long concurrency ^long warmup-millis ^long bench-millis f]\n  (let [now        #(System/currentTimeMillis)\n        exit?      (atom false)\n        stats-coll (repeatedly concurrency call-count)\n        g-coll     (->> (repeat f)\n                     (map wrap-call-stats stats-coll)\n                     (map-indexed (fn [i g]\n                                    (fn []\n                                      (let [r (nth stats-coll i)]\n                                        (while (not (deref exit?))\n                                          (g))\n                                        (r)))))\n                     vec)\n        call-count (->> (fn [future-vals]\n                          (print \"\\nWarming up\")\n                          (wait-until-millis (+ (now) warmup-millis))\n                          (mapv #(% :reset) stats-coll) ; reset count\n                          (print \"\\nBenchmarking\")\n                          (wait-until-millis (+ (now) bench-millis))\n                          (println)\n                          (swap! exit? not)\n                          (mapv deref future-vals))\n                     (concurrently concurrency g-coll)\n                     (apply +))]\n    {:concurrency concurrency\n     :calls-count call-count\n     :duration-millis bench-millis\n     :calls-per-second (->> (/ bench-millis 1000)\n                         double\n                         (/ ^long call-count)\n                         long)}))\n\n(defmacro benchmark-throughput\n  \"Benchmark a body of code for average throughput.\"\n  [concurrency warmup-millis bench-millis & body]\n  `(benchmark-throughput*\n    ~concurrency ~warmup-millis ~bench-millis (fn [] ~@body)))\n```", "```java\n(def a (atom 0))\n(println\n  (benchmark-throughput\n    4 20000 40000 (swap! a inc)))\n```", "```java\n(let [^Runtime r (Runtime/getRuntime)]\n  (println \"Maximum memory\" (.maxMemory r))\n  (println \"Total memory\" (.totalMemory r))\n  (println \"Free memory\" (.freeMemory r)))\nOutput:\nMaximum memory 704643072\nTotal memory 291373056\nFree memory 160529752\n```", "```java\n(defn cpu-work []\n  (reduce + (range 100000000)))\n\n(defn mem-work []\n  (->> (range 1000000)\n       (map str)\n       vec\n       (map keyword)\n       count))\n```", "```java\n:global-vars {*unchecked-math* :warn-on-boxed ; in Clojure 1.7+\n              *warn-on-reflection* true}\n```", "```java\n:profiles {:perf {:test-paths ^:replace [\"perf-test\"]\n                  :jvm-opts ^:replace [\"-server\"\n                                       \"-Xms2048m\" \"-Xmx2048m\"]}}\n```", "```java\nlein with-profile perf test\n```", "```java\n(require '[plumbing.core :refer [fnk]])\n(require '[plumbing.graph :as g])\n\n(def layers\n  {:db      (fnk [config]    (let [pool (db-pool config)]\n                               (reify IDatabase ...)))\n   :cache   (fnk [config db] (let [cache-obj (mk-cache config)]\n                               (reify ICache    ...)))\n   :service (fnk [config db cache] (reify IService  ...))\n   :web     (fnk [config service]  (reify IWeb      ...))})\n\n(defn resolve-layers\n  \"Return a map of reified layers\"\n  [app-config]\n  (let [compiled (g/compile layers)]\n    (compiled {:config app-config})))\n```", "```java\n(require '[espejito.core :as e])\n\n;; in the top level handler (entry point to the use case)\n(e/report e/print-table\n  ...)\n\n;; in web.clj\n(e/measure \"web/add-cart-item\"\n  (biz/add-item-to-cart (resolve-cart request) item-code qty)\n  ...)\n\n;; in service.clj (biz)\n(defn add-item-to-cart\n  [cart item qty]\n  (e/measure \"biz/add-cart-item\"\n    (db/save-cart-item (:id cart) (:id item) qty)\n    ...))\n\n;; in db.clj (db)\n(defn save-cart-item\n  [cart-id item-id qty]\n  (e/measure \"db/save-cart-item\"\n    ...))\n```", "```java\n|                 :name|:cumulat|:cumul%|:indiv |:indiv%|:thrown?|\n|----------------------+--------+-------+-------+-------+--------|\n|    web/add-cart-item |11.175ms|100.00%|2.476ms|22.16% |        |\n| biz/add-item-to-cart | 8.699ms| 77.84%|1.705ms|15.26% |        |\n|    db/save-cart-item | 6.994ms| 62.59%|6.994ms|62.59% |        |\n```", "```java\n(defmacro report-when\n  [test & body]\n  `(if ~test\n    (e/report e/print-table\n      ~@body)\n    ~@body))\n```", "```java\n(report-when (= \"true\" (get-in request [:params \"report\"]))\n  ...)\n```", "```java\n:jvm-options ^:replace [..other options..\n \"-verbose:gc\" \"-XX:+PrintGCDetails\"\n \"-XX:+PrintGC\" \"-XX:+PrintGCTimeStamps\"\n                        ..other options..]\n```", "```java\n:jvm-options ^:replace [..other options..\n                        \"-verbose:gc\" \"-XX:+PrintGCDetails\"\n                        \"-XX:+PrintGC\" \"-XX:+PrintGCTimeStamps\"\n \"-Xloggc:./memory.log\"\n                        ..other options..]\n```", "```java\n:jvm-options ^:replace [..other options..\n                        \"-verbose:gc\" \"-XX:+PrintGCDetails\"\n                        \"-XX:+PrintGC\" \"-XX:+PrintGCTimeStamps\"\n \"-XX:+PrintGCApplicationStoppedTime\"\n \"-XX:+PrintGCApplicationConcurrentTime\"\n                        ..other options..]\n```", "```java\n:jvm-options ^:replace [..other options..\n                        \"-verbose:gc\" \"-XX:+PrintGCDetails\"\n                        \"-XX:+PrintGC\" \"-XX:+PrintGCTimeStamps\"\n \"-XX:+PrintSafepointStatistics\"\n                        ..other options..]\n```", "```java\njstat -gc -t <process-id> 10000\njstat -gccause -t <process-id> 10000\n```", "```java\n:plugins [[lein-nodisassemble \"0.1.3\"]]\n```", "```java\n(require '[no.disassemble :as n])\n(println (n/disassemble (map inc (range 10))))\n```", "```java\njvisualvm\n```", "```java\n(.setName ^Thread (Thread/currentThread) \"service-thread-12\")\n```", "```java\n(defmacro with-thread-name\n  \"Set current thread name; execute body of code in that context.\"\n  [new-name & body]\n  `(let [^Thread thread# (Thread/currentThread)\n         ^String t-name# thread#]\n     (.setName thread# ~new-name)\n     (try\n       ~@body\n       (finally\n         (.setName thread# t-name#)))\n```", "```java\n(with-thread-name (str \"process-order-\" order-id)\n  ;; business code\n  )\n```", "```java\nlein with-profile dev,benchmark test\n```", "```java\nlein with-profile dev,c17,perf test\n```", "```java\n[ch.qos.logback/logback-classic \"1.1.2\"]\n[ch.qos.logback/logback-core    \"1.1.2\"]\n[org.slf4j/slf4j-api            \"1.7.9\"]\n[org.codehaus.janino/janino     \"2.6.1\"]  ; for Logback-config\n[org.clojure/tools.logging      \"0.3.1\"]\n```", "```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n\n  <appender name=\"FILE\"\n            class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <file>${logfile.general.name:-logs/application.log}</file>\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n      <!-- daily rollover -->\n      <fileNamePattern>${logfile.general.name:-logs/application.log}.%d{yyyy-MM-dd}.%i.gz</fileNamePattern>\n      <timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\">\n        <!-- or whenever the file size reaches 100MB -->\n        <maxFileSize>100MB</maxFileSize>\n      </timeBasedFileNamingAndTriggeringPolicy>\n      <!-- keep 30 days worth of history -->\n      <maxHistory>30</maxHistory>\n    </rollingPolicy>\n    <append>true</append>\n    <encoder class=\"ch.qos.logback.core.encoder.LayoutWrappingEncoder\">\n      <layout class=\"ch.qos.logback.classic.PatternLayout\">\n        <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n      </layout>\n <immediateFlush>false</immediateFlush>\n    </encoder>\n  </appender>\n\n <appender name=\"AsyncFile\" class=\"ch.qos.logback.classic.AsyncAppender\">\n <queueSize>500</queueSize>\n <discardingThreshold>0</discardingThreshold>\n <appender-ref ref=\"FILE\" />\n </appender>\n\n  <!-- You may want to set the level to DEBUG in development -->\n  <root level=\"ERROR\">\n <appender-ref ref=\"AsyncFile\" />\n  </root>\n\n  <!-- Replace com.example with base namespace of your app -->\n  <logger name=\"com.example\" additivity=\"false\">\n    <!-- You may want to set the level to DEBUG in development -->\n    <level value=\"INFO\"/>\n <appender-ref ref=\"AsyncFile\" />\n  </logger>\n\n</configuration>\n```", "```java\n(defn summarize [daily-data]  ; daily-data is a map\n  (let [s (items-summary (:items daily-data))]\n    (-> daily-data\n      (select-keys [:digest :invoices])  ; keep required k/v pairs\n      (assoc :summary s))))\n\n;; now inside report generation code\n(-> (fetch-items period-from period-to :interval-day)\n  (map summarize)\n  generate-report)\n```", "```java\n(def ^:const K 1024)\n\n;; create the buffered reader using custom 128K buffer-size\n(-> filename\n  java.io.FileInputStream.\n  java.io.InputStreamReader.\n  (java.io.BufferedReader. (* K 128)))\n```", "```java\n(require '[clojure.java.jdbc :as jdbc])\n\n;; using prepare-statement directly\n(with-open\n  [stmt (jdbc/prepare-statement\n          conn sql :fetch-size 1000 :max-rows 9000)\n   rset (resultset-seq (.executeQuery stmt))]\n  (vec rset))\n\n;; using query\n(jdbc/query db [{:fetch-size 1000}\n           \"SELECT empno FROM emp WHERE country=?\" 1])\n```", "```java\n(require '[clojure.java.jdbc :as jdbc])\n\n;; multiple SQL statements\n(jdbc/db-do-commands\n  db true\n  [\"INSERT INTO emp (name, countrycode) VALUES ('John Smith', 3)\"\n   \"UPDATE emp SET countrycode=4 WHERE empid=1379\"])\n\n;; similar statements with only different parametrs\n(jdbc/db-do-prepared\n  db true\n  \"UPDATE emp SET countrycode=? WHERE empid=?\"\n  [4 1642]\n  [9 1186]\n  [2 1437])\n```", "```java\n(require '[clojure.java.jdbc :as j])\n\n(def db {:subprotocol \"mysql\"\n         :subname \"//127.0.0.1:3306/clojure_test\"\n         :user \"clojure_test\" :password \"clojure_test\"})\n\n;; the snippet below uses N+1 selects\n;; (typically characterized by SELECT in a loop)\n(def rq \"select order_id from orders where status=?\")\n(def tq \"select * from items where fk_order_id=?\")\n(doseq [order (j/query db [rq \"pending\"])]\n  (let [items (j/query db [tq (:order_id order)])]\n    ;; do something with items\n    …))\n\n;; the snippet below avoids N+1 selects,\n;; but requires fk_order_id to be indexed\n(def jq \"select t.* from orders r, items t\n  where t.fk_order_id=r.order_id and r.status=? order by t.fk_order_id\")\n(let [all-items (group-by :fk_order_id (j/query db [jq \"pending\"]))]\n  (doseq [[order-id items] all-items]\n    ;; do something with items\n    ...))\n```", "```java\n(import 'java.util.concurrent.LinkedBlockingDeque)\n(import 'java.util.concurrent.TimeUnit)\n(import 'java.util.concurrent.ThreadPoolExecutor)\n(import 'java.util.concurrent.ThreadPoolExecutor$AbortPolicy)\n(def tpool\n  (let [q (LinkedBlockingDeque. 100)\n        p (ThreadPoolExecutor$AbortPolicy.)]\n    (ThreadPoolExecutor. 1 10 30 TimeUnit/SECONDS q p)))\n```", "```java\n(require '[org.httpkit.server :as hk])\n\n;; handler is a typical Ring handler\n(hk/run-server handler {:port 3000 :thread 32 :queue-size 600})\n```", "```java\n(require '[aleph.http :as a])\n\n;; handler is a typical Ring handler\n(a/start-server handler {:executor tpool})\n```"]