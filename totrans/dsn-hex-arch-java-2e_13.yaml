- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Persisting Data with Output Adapters and Hibernate Reactive
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输出适配器和 Hibernate Reactive 持久化数据
- en: In the previous chapter, we learned about some of the advantages that can be
    brought to a system by using Quarkus reactive capabilities. Our first step on
    the reactive road was to implement Reactive input adapters using **RESTEasy Reactive**.
    Although the input adapters’ endpoints are being served reactively, we still have
    the output adapters working in a synchronous and blocking fashion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了使用 Quarkus 反应式能力可以为系统带来的某些优势。我们在反应式道路上的第一步是使用 **RESTEasy Reactive**
    实现反应式输入适配器。尽管输入适配器的端点正在以反应式方式提供服务，但我们仍然有输出适配器以同步和阻塞的方式工作。
- en: To turn the hexagonal system into a more Reactive one, in this chapter, we’ll
    first learn how to configure `Panache`. Once the system entities are properly
    configured, we’ll learn how to use these entities to connect to a MySQL database
    reactively.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将六边形系统转变为更反应式的一个，在本章中，我们首先将学习如何配置 `Panache`。一旦系统实体得到适当配置，我们将学习如何使用这些实体以反应式方式连接到
    MySQL 数据库。
- en: 'The following are the topics we’ll cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introducing Hibernate Reactive and `Panache`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Hibernate Reactive 和 `Panache`
- en: Enabling reactive behavior on output adapters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输出适配器上启用反应式行为
- en: Testing reactive output adapters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试反应式输出适配器
- en: As we have already implemented reactive input adapters in the previous chapter,
    our goal here is to extend the reactive behavior in a hexagonal system by implementing
    reactive output adapters. This implementation takes place at the Framework hexagon,
    which is the architecture element where we concentrate on adapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一章已经实现了反应式输入适配器，我们的目标是在本章中通过实现反应式输出适配器来扩展六边形系统的反应式行为。这种实现发生在框架六边形上，这是我们专注于适配器的架构元素。
- en: By the end of this chapter, you’ll have learned how to integrate Quarkus with
    a hexagonal system to access databases reactively. By understanding the required
    configuration steps and fundamental implementation details, you’ll be able to
    implement reactive output adapters. This knowledge will help you tackle situations
    where non-blocking I/O requests offer more advantages than I/O-blocking ones.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学习如何将 Quarkus 与六边形系统集成以以反应式方式访问数据库。通过理解所需的配置步骤和基本实现细节，您将能够实现反应式输出适配器。这些知识将帮助您应对非阻塞
    I/O 请求比 I/O 阻塞请求提供更多优势的情况。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you need the
    latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are all available for Linux, Mac, and Windows operating systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中提供的代码示例，您需要在您的计算机上安装最新的 **Java SE 开发工具包** 和 **Maven 3.8**。它们都适用于 Linux、Mac
    和 Windows 操作系统。
- en: Also, you’ll need **Docker** installed on your machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要在您的机器上安装 **Docker**。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter13).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，链接为 [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter13)。
- en: Introducing Hibernate Reactive and Panache
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Hibernate Reactive 和 Panache
- en: The available technologies and techniques to handle database operations in Java
    have evolved a lot in the last few years. Based on the **Java Persistence API**
    (**JPA**) specification, we’ve been presented with different ORM implementations
    such as Spring Data JPA, EclipseLink, and, of course, Hibernate. These technologies
    make our lives easier by abstracting away much of the plumber work required to
    deal with databases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，处理 Java 中数据库操作的技术和技巧已经发生了很大的变化。基于 **Java 持久化 API**（**JPA**）规范，我们被介绍了几种
    ORM 实现，如 Spring Data JPA、EclipseLink，当然还有 Hibernate。这些技术通过抽象出处理数据库所需的大部分管道工作，使我们的生活变得更加容易。
- en: Quarkus is integrated with Hibernate ORM and its reactive counterpart, Hibernate
    Reactive. Also, Quarkus comes with a library called `Panache`, which simplifies
    our interaction with databases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 集成了 Hibernate ORM 和其反应式对应物 Hibernate Reactive。此外，Quarkus 还附带了一个名为 `Panache`
    的库，该库简化了我们与数据库的交互。
- en: Next, we’ll take a brief look at Hibernate Reactive and Panache’s main features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要介绍 Hibernate Reactive 和 Panache 的主要功能。
- en: Hibernate Reactive features
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hibernate Reactive 功能
- en: It’s rare, if not impossible, to find a silver-bullet solution that solves all
    problems related to database access. When we talk about the reactive and imperative
    approaches to database handling, it’s fundamental to understand the advantages
    and disadvantages of both approaches.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个能够解决与数据库访问相关所有问题的银弹方案，如果不是不可能的话，是非常罕见的。当我们谈论数据库处理的反应式和命令式方法时，理解这两种方法的优势和劣势是至关重要的。
- en: What’s so appealing about the imperative approach to database access is the
    simplicity with which you develop your code. There are fewer things to adjust
    and think about when you need to read or persist things using an imperative approach.
    However, this approach may cause setbacks when its blocking nature starts to impact
    the use cases of your system. To avoid such setbacks, we have the reactive approach,
    enabling us to deal with databases in a non-blocking fashion, but not without
    additional complexities in our development and the new problems and challenges
    that arise when reactively handling databases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式方法访问数据库之所以吸引人，在于其开发代码的简单性。当你需要使用命令式方法读取或持久化数据时，需要调整和思考的事情较少。然而，当其阻塞特性开始影响系统的用例时，这种方法可能会导致问题。为了避免这种问题，我们有了反应式方法，它使我们能够以非阻塞的方式处理数据库，但这并不是没有在开发和处理数据库时带来额外的复杂性以及新的问题和挑战。
- en: The original Hibernate implementation was conceived to solve the problems that
    developers had to deal with when mapping Java objects to database entities. The
    original implementation relies on I/O blocking synchronous communication to interact
    with databases. It’s been, and still is, the most conventional way to access databases
    in Java. On the other hand, Hibernate Reactive arose from the urge for reactive
    programming movements and the need for asynchronous communication to database
    access. Instead of I/O blocking, Hibernate Reactive relies upon I/O non-blocking
    communication to interact with databases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Hibernate实现是为了解决开发者在将Java对象映射到数据库实体时遇到的问题而设计的。原始实现依赖于I/O阻塞同步通信与数据库交互。这曾经是，现在仍然是Java中访问数据库最传统的方式。另一方面，Hibernate
    Reactive源于对反应式编程运动的渴望以及对异步通信访问数据库的需求。Hibernate Reactive不是依赖于I/O阻塞，而是依赖于I/O非阻塞通信与数据库交互。
- en: The entity mapping properties remain the same in a reactive implementation.
    However, what changes is how we open a database’s Reactive connection and how
    we should structure the software code to handle database entities reactively.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应式实现中，实体映射属性保持不变。然而，变化的是我们打开数据库反应式连接的方式以及我们应如何构建软件代码以反应式地处理数据库实体。
- en: When using Quarkus, there is no need to provide a reactive persistence configuration
    based on the `persistence.xml` file because Quarkus already configures it for
    us. Still, we will briefly explore it to have an idea of how Hibernate Reactive
    alone works.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Quarkus时，无需基于`persistence.xml`文件提供反应式持久化配置，因为Quarkus已经为我们配置好了。尽管如此，我们仍将简要探讨它，以便了解Hibernate
    Reactive单独的工作方式。
- en: 'To set up Hibernate Reactive, you can follow the standard approach to configuring
    the `META-INF/persistence.xml` file, as shown in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Hibernate Reactive，你可以遵循配置`META-INF/persistence.xml`文件的常规方法，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that we’re using `ReactivePersistenceProvider` to open a reactive connection
    to the database. Once the `persistence.xml` file is properly configured, we can
    start using Hibernate Reactive in our code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`ReactivePersistenceProvider`来打开数据库的反应式连接。一旦`persistence.xml`文件配置得当，我们就可以在我们的代码中开始使用Hibernate
    Reactive：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start by importing the static `javax.persistence.Persistence.createEntityManagerFactory`
    method provided by Hibernate Reactive. This static method facilitates the creation
    of `SessionFactory` objects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入Hibernate Reactive提供的静态`javax.persistence.Persistence.createEntityManagerFactory`方法。这个静态方法简化了`SessionFactory`对象的创建。
- en: 'In order to create a `SessionFactory` object, the system uses the properties
    defined by the `persistence.xml` file. With `SessionFactory`, we can start reactive
    communication with the database:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建`SessionFactory`对象，系统使用`persistence.xml`文件中定义的属性。有了`SessionFactory`，我们可以开始与数据库进行反应式通信：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To persist data, first, we need to create a transaction by calling the `withTransaction`
    method. Inside a transaction, we call the `persistAll` method from `SessionFactory`
    to persist an object. We call the `subscribe` method to trigger the persistence
    operation in a non-blocking way.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要持久化数据，首先，我们需要通过调用 `withTransaction` 方法创建一个事务。在事务内部，我们从 `SessionFactory` 调用
    `persistAll` 方法来持久化一个对象。我们调用 `subscribe` 方法以非阻塞方式触发持久化操作。
- en: By establishing a layer between the application and the database, Hibernate
    provides all the basic things we need to handle databases in Java.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在应用程序和数据库之间建立一层，Hibernate 提供了我们处理 Java 数据库所需的所有基本功能。
- en: Now, let’s see how `Panache` can make things even simpler.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Panache` 如何使事情变得更加简单。
- en: Panache features
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Panache 特性
- en: '`Panache` sits on top of Hibernate and enhances it even more by providing a
    simple interface for handling the database entities. `Panache` was primarily developed
    to work with the Quarkus framework, and it is a library aimed to abstract much
    of the boilerplate code required to handle the database entities. With `Panache`,
    you can easily apply database patterns such as **Active Record** and **Repository**.
    Let’s briefly see how to do that.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panache` 位于 Hibernate 之上，并通过提供处理数据库实体的简单接口来进一步增强它。`Panache` 主要是为了与 Quarkus
    框架一起使用而开发的，它是一个旨在抽象处理数据库实体所需的大量样板代码的库。使用 `Panache`，你可以轻松地应用如 **Active Record**
    和 **Repository** 这样的数据库模式。让我们简要地看看如何做到这一点。'
- en: Applying the Active Record pattern
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用活动记录模式
- en: 'In the `PanacheEntity`. Look at the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PanacheEntity` 中，看看以下示例：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding `Location` class is a regular Hibernate-based entity that extends
    `PanacheEntity`. Besides extending `PanacheEntity`, there is nothing new in this
    `Location` class. We have annotations such as `@NotNull` and `@Size` that we use
    to validate the data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `Location` 类是一个基于 Hibernate 的常规实体，它扩展了 `PanacheEntity`。除了扩展 `PanacheEntity`
    之外，这个 `Location` 类没有其他新内容。我们使用了 `@NotNull` 和 `@Size` 等注解来验证数据。
- en: 'The following are some of the things we can do with an Active Record entity:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些我们可以使用活动记录实体执行的操作：
- en: 'To list entities, we can call the `listAll` method. This method is available
    on `Location` because we’re extending the `PanacheEntity` class:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要列出实体，我们可以调用 `listAll` 方法。此方法在 `Location` 上可用，因为我们正在扩展 `PanacheEntity` 类：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To delete all the `Location` entities, we can call the `deleteAll` method:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除所有 `Location` 实体，我们可以调用 `deleteAll` 方法：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To find a specific `Location` entity by its ID, we can use the `findByIdOptional`
    method:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要通过其 ID 查找特定的 `Location` 实体，我们可以使用 `findByIdOptional` 方法：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To persist a `Location` entity, we have to call the `persist` method on the
    `Location` instance we intend to persist:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要持久化 `Location` 实体，我们必须在打算持久化的 `Location` 实例上调用 `persist` 方法：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Every time we execute one of the preceding described operations, they are immediately
    committed to the database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们执行前面描述的任何操作时，它们都会立即提交到数据库。
- en: Now, let’s see how to use `Panache` to apply the Repository pattern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `Panache` 来应用仓储模式。
- en: Applying the Repository pattern
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用仓储模式
- en: Instead of using an entity class to perform actions on the database, we use
    a separate class that is usually dedicated to providing database operations in
    the Repository pattern. This kind of class works like a repository interface for
    the database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用实体类在数据库上执行操作，而是使用一个单独的类，这个类通常专门用于在仓储模式中提供数据库操作。这种类就像数据库的仓储接口一样工作。
- en: 'To apply the Repository pattern, we should use regular Hibernate entities:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用仓储模式，我们应该使用常规的 Hibernate 实体：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that at this time, we’re not extending the `PanacheEntity` class. In the
    Repository pattern, we don’t call the database operations directly through the
    entity class. Instead, we call them through the repository class. Here is an example
    of how we can implement a repository class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此时我们并没有扩展 `PanacheEntity` 类。在仓储模式中，我们不是通过实体类直接调用数据库操作。相反，我们通过仓储类调用它们。以下是如何实现仓储类的示例：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By implementing `PanacheRepository` on the `LocationRepository` class, we’re
    enabling all the standard operations such as `findById`, `delete`, `persist`,
    and so on that are present in the `PanacheEntity` class. Also, we can define our
    own custom queries, as we did in the preceding example, by using the `find` and
    `delete` methods provided by the `PanacheEntity` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `LocationRepository` 类上实现 `PanacheRepository`，我们启用了 `PanacheEntity` 类中存在的所有标准操作，如
    `findById`、`delete`、`persist` 等。此外，我们可以通过使用 `PanacheEntity` 类提供的 `find` 和 `delete`
    方法来定义我们自己的自定义查询，就像前面的示例中所做的那样。
- en: 'Note that we annotated the repository class as an `@ApplicationScoped` bean.
    This means we can inject and use it in other classes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将仓库类标注为`@ApplicationScoped`类型的bean。这意味着我们可以在其他类中注入并使用它：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we have the most common operations available on the repository class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有在仓库类上可用的最常见操作：
- en: 'To list all the `Location` entities, we need to call the `listAll` method from
    `LocationRepository`:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要列出所有`Location`实体，我们需要从`LocationRepository`调用`listAll`方法：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By calling `deleteAll` on `LocationRepository`, we remove all the `Location`
    entities:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在`LocationRepository`上调用`deleteAll`，我们移除所有的`Location`实体：
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To find a `Location` entity by its ID, we call the `findByIdOptional` method
    on `LocationRepository`:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要通过其ID查找`Location`实体，我们在`LocationRepository`上调用`findByIdOptional`方法：
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To persist a `Location` entity, we need to pass a `Location` instance to the
    `persist` method from `LocationRepository`:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要持久化`Location`实体，我们需要将`Location`实例传递给`LocationRepository`中的`persist`方法：
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding examples, we are executing all database operations using the
    repository class. The methods we call here are the same as those present in the
    entity class from the Active Record approach. The only difference here is the
    usage of the repository class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用仓库类执行所有数据库操作。我们在这里调用的方法与Active Record方法中存在的那些方法相同。这里唯一的区别是仓库类的使用。
- en: By learning how to use `Panache` to apply the Active Record and Repository patterns,
    we increase our capacity to provide good approaches to handling database entities.
    There is no better or worse pattern. The project’s circumstances will ultimately
    dictate which pattern is more suitable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何使用`Panache`来应用Active Record和Repository模式，我们提高了提供处理数据库实体良好方法的能力。没有更好的或更差的模式。项目的具体情况最终将决定哪种模式更适合。
- en: '`Panache` is a library made especially for Quarkus. So, the best way to connect
    Hibernate Reactive objects such as `SessionFactory` and `Transaction` to `Panache`
    is by delegating the database configuration to Quarkus, which will automatically
    provide these objects to you.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panache`是一个专门为Quarkus制作的库。因此，将数据库配置委托给Quarkus以连接Hibernate Reactive对象（如`SessionFactory`和`Transaction`）到`Panache`的最佳方式是，Quarkus将自动为您提供这些对象。'
- en: Now that we’re acquainted with Hibernate Reactive and `Panache`, let’s see how
    we can implement output adapters in a hexagonal system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Hibernate Reactive和`Panache`，让我们看看如何在六边形系统中实现输出适配器。
- en: Enabling reactive behavior on output adapters
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用输出适配器的反应式行为
- en: One of the most important benefits of using hexagonal architecture is the improved
    flexibility to change technologies without significant refactoring. The hexagonal
    system is designed so that its domain logic and business rules are oblivious to
    the technologies utilized to execute them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用六边形架构最重要的好处之一是提高了在不进行重大重构的情况下更改技术的灵活性。六边形系统设计得如此之好，以至于其领域逻辑和业务规则对执行它们所使用的技术一无所知。
- en: There is no free lunch – when we decide to use the hexagonal architecture, we
    have to pay the price for the benefits that this architecture can provide. (By
    price, I mean a considerable increase in the effort and complexity required to
    structure the system code by following the hexagonal principles.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 没有免费的午餐——当我们决定使用六边形架构时，我们必须为这种架构能提供的利益付出代价。（这里的代价是指按照六边形原则结构化系统代码所需的工作量和复杂性的显著增加。）
- en: If you’re concerned about code reuse, you may find some practices awkward to
    decouple code from specific technologies. For example, consider a scenario in
    which we have a domain entity class and a database entity class. We may argue,
    *why not have just one class that serves both purposes?* Well, in the end, it’s
    all a matter of priorities. If the coupling of the domain and technology-specific
    classes is not an issue for you, go ahead. In this case, you will not have the
    burden of maintaining a domain model plus all the infrastructure code that supports
    it. However, the same code would serve different purposes, thus violating the
    **Single Responsibility Principle** (**SRP**). Otherwise, if you see a risk in
    using the same code for serving different purposes, then the output adapters can
    help.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您担心代码重用，您可能会发现一些实践难以将代码从特定技术中解耦。例如，考虑一个场景，其中我们有一个领域实体类和一个数据库实体类。我们可能会争论，*为什么不只有一个类同时服务于这两个目的呢？*
    好吧，最终，这完全是一个优先级的问题。如果您认为领域和特定技术类之间的耦合不是问题，那么请继续。在这种情况下，您将不会承担维护领域模型及其所有支持基础设施代码的负担。然而，相同的代码会服务于不同的目的，从而违反了**单一职责原则**（**SRP**）。否则，如果您认为使用相同代码服务于不同目的存在风险，那么输出适配器可以帮助您。
- en: In [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038), *Wrapping Business Rules
    Inside the Domain Hexagon*, we introduced an output adapter that integrated the
    application with the filesystem. In [*Chapter 4*](B19777_04.xhtml#_idTextAnchor083),
    *Creating Adapters to Interact with the Outside World*, we created a more elaborated
    output adapter to communicate with an H2 in-memory database. Now that we have
    the Quarkus toolkit at our disposal, we can create reactive output adapters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B19777_02.xhtml#_idTextAnchor038)《在领域六边形内封装业务规则》中，我们介绍了一个输出适配器，该适配器将应用程序与文件系统集成。在[*第四章*](B19777_04.xhtml#_idTextAnchor083)《创建与外部世界交互的适配器》中，我们创建了一个更详细的输出适配器，用于与H2内存数据库通信。现在，我们有了Quarkus工具箱，我们可以创建响应式输出适配器。
- en: Configuring reactive data sources
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置响应式数据源
- en: 'To continue the reactive effort that we started in the previous chapter by
    implementing reactive input adapters, we’ll create and connect reactive output
    adapters to these reactive input adapters by executing the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续在前一章中通过实现响应式输入适配器开始的响应式努力，我们将通过执行以下步骤创建和连接响应式输出适配器到这些响应式输入适配器：
- en: 'Let’s get started by configuring the required dependencies in the `pom.xml`
    file of the Framework hexagon:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在框架六边形的`pom.xml`文件中配置所需的依赖项开始：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `quarkus-reactive-mysql-client` dependency contains the libraries we need
    to open a reactive connection with MySQL databases and the `quarkus-hibernate-reactive-panache`
    dependency contains Hibernate Reactive and `Panache`. It’s important to note that
    this library is especially suited for reactive activities. For non-reactive activities,
    Quarkus offers a different library.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`quarkus-reactive-mysql-client`依赖包含我们需要的库，用于与MySQL数据库建立响应式连接，而`quarkus-hibernate-reactive-panache`依赖包含Hibernate
    Reactive和`Panache`。需要注意的是，这个库特别适合响应式活动。对于非响应式活动，Quarkus提供不同的库。'
- en: 'Now, we need to configure the database connection on the `application.properties`
    file from the Bootstrap hexagon. Let’s start with the data source properties:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在启动六边形的`application.properties`文件上配置数据库连接。让我们从数据源属性开始：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `quarkus.datasource.db-kind` property is not mandatory because Quarkus can
    infer the database kind by looking into the specific database client that is loaded
    from Maven dependencies. With `quarkus.datasource.reactive` set to `true`, we’re
    enforcing reactive connections. We need to specify the reactive database connection
    URL on `quarkus.datasource.reactive.url`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`quarkus.datasource.db-kind`属性不是必需的，因为Quarkus可以通过查看从Maven依赖中加载的特定数据库客户端来推断数据库类型。将`quarkus.datasource.reactive`设置为`true`，我们正在强制执行响应式连接。我们需要在`quarkus.datasource.reactive.url`上指定响应式数据库连接URL。'
- en: 'Finally, we have to define the Hibernate configuration:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须定义Hibernate配置：
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After Quarkus has created the database and its tables, you can load a `.sql`
    file to execute more instructions on the database. By default, it searches for
    and loads a file called `import.sql`. We can change this behavior by using the
    `quarkus.hibernate-orm.sql-load-script` property.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Quarkus创建数据库及其表之后，您可以加载一个`.sql`文件来在数据库上执行更多指令。默认情况下，它会搜索并加载一个名为`import.sql`的文件。我们可以通过使用`quarkus.hibernate-orm.sql-load-script`属性来改变这种行为。
- en: Be aware of not using `quarkus.hibernate-orm.database.generation = drop-and-create`
    in production. Otherwise, it will drop all your database tables. If you don’t
    set any value, the default one, `none`, is used. The default behavior doesn’t
    make any changes to the database.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意在生产环境中不要使用`quarkus.hibernate-orm.database.generation = drop-and-create`。否则，它将删除您所有的数据库表。如果您没有设置任何值，默认值`none`将被使用。默认行为不会对数据库进行任何更改。
- en: And, finally, we enable `quarkus.hibernate-orm.log.sql` to see which SQL queries
    Hibernate is executing behind the hood. I recommend you enable the `log` feature
    only for development purposes. When running the application in production, don’t
    forget to disable this option.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们启用`quarkus.hibernate-orm.log.sql`来查看Hibernate在幕后执行的SQL查询。我建议您只为开发目的启用`log`功能。在生产环境中运行应用程序时，别忘了禁用此选项。
- en: Let’s now see how to configure application entities to work with a MySQL database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何配置应用程序实体以与MySQL数据库一起工作。
- en: Configuring entities
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置实体
- en: 'The topology and inventory system requires four database tables to store its
    data: routers, switches, networks, and location. Each one of these tables will
    be mapped to a Hibernate entity class properly configured to work with a MySQL
    data source.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑和库存系统需要四个数据库表来存储其数据：路由器、交换机、网络和位置。每个这些表都将被映射到一个正确配置以与MySQL数据源一起工作的Hibernate实体类。
- en: We’ll apply the Repository pattern, so we won’t have the entities to perform
    database operations. Instead, we’ll create separate repository classes to trigger
    actions on the database, but before creating repository classes, let’s start by
    implementing Hibernate entities for the topology and inventory system. We’ll configure
    these entities to work with MySQL databases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用Repository模式，因此我们不需要实体来执行数据库操作。相反，我们将创建单独的仓库类来在数据库上触发操作，但在创建仓库类之前，让我们先实现拓扑和库存系统的Hibernate实体。我们将配置这些实体以与MySQL数据库一起工作。
- en: The Router entity
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由器实体
- en: For this entity and the others that will be implemented subsequently, we should
    create classes in the `dev.davivieira.topologyinventory.framework.adapters.output.mysql.data`
    package of the Framework hexagon.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实体以及随后将要实现的其它实体，我们应该在框架六角形的`dev.davivieira.topologyinventory.framework.adapters.output.mysql.data`包中创建类。
- en: 'Here is what the `Router` entity class should look like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router`实体类应该看起来像这样：'
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the `routerId` and `routerParentCoreId` fields, we must set `columnDefinition`,
    the `@Column` annotation parameter, to `BINARY(16)`. It’s a requirement to make
    `UUID` attributes work on MySQL databases.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`routerId`和`routerParentCoreId`字段，我们必须将`columnDefinition`，即`@Column`注解参数，设置为`BINARY(16)`。这是在MySQL数据库上使`UUID`属性工作所必需的。
- en: 'Then, we create the relationship mapping between routers and other tables:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建路由器与其他表之间的关系映射：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we define a many-to-one relation between routers and location. After that,
    we have two one-to-many relationships with switches and routers, respectively.
    The `fetch = FetchType.EAGER` property is used to avoid any mapping errors that
    may occur during the reactive connections.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了路由器和位置之间的多对一关系。之后，我们有两个与交换机和路由器分别的一对多关系。使用`fetch = FetchType.EAGER`属性来避免在反应式连接期间可能发生的任何映射错误。
- en: Let’s move on to the configuration of the `Switch` entity class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续配置`Switch`实体类。
- en: The Switch entity
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Switch实体
- en: 'The following code shows us how we should implement the `Switch` entity class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们应该如何实现`Switch`实体类：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have omitted other column attributes to focus only on the IDs and relationships.
    We start by defining a many-to-one relationship between switches and a router.
    The primary key is the `switchId` field, which happens to be a `UUID` attribute.
    We have another `UUID` attribute for mapping the `routerId` field.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了其他列属性，只关注ID和关系。我们首先定义了交换机和路由器之间的多对一关系。主键是`switchId`字段，它恰好是一个`UUID`属性。我们还有一个`UUID`属性来映射`routerId`字段。
- en: Also, there is a one-to-many relationship between a switch and networks, and
    a many-to-one relationship between switches and a location.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，交换机和网络之间存在一对一关系，交换机和位置之间存在多对一关系。
- en: Now, let’s configure the `Network` entity class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置`Network`实体类。
- en: The Network entity
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络实体
- en: Although we do not consider networks to be entities in the domain model, they
    have a separate table in the database. So, at the Framework hexagon level, we
    treat them as database entities, but when they reach the Domain hexagon, we treat
    them as value objects. This example shows that the hexagon system dictates how
    the data will be treated at the Domain hexagon level. By doing so, the hexagonal
    system shields the domain model from technical details.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不将网络视为领域模型中的实体，但在数据库中有一个单独的表。因此，在框架六边形级别，我们将它们视为数据库实体，但当它们达到领域六边形时，我们将它们视为值对象。这个例子表明，六边形系统决定了数据在领域六边形级别如何被处理。通过这样做，六边形系统保护了领域模型免受技术细节的影响。
- en: 'We implement the `Network` entity class as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下实现`Network`实体类：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a straightforward entity class with a many-to-one relationship between
    networks and a switch. For networks, we rely on the database to generate network
    IDs. Also, networks are not considered entities in the domain model. Instead,
    we treat networks as value objects that are controlled by an aggregate. For aggregates,
    we need to handle the `UUID`, but for value objects, we do not. That’s why we
    don’t handle UUIDs for network database entities.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实体类，它在网络和交换之间有一个多对一的关系。对于网络，我们依赖数据库生成网络ID。此外，网络在领域模型中不被视为实体。相反，我们将网络视为由聚合控制的值对象。对于聚合，我们需要处理`UUID`，但对于值对象，我们不需要。这就是为什么我们不处理网络数据库实体的UUID。
- en: We still need to implement one last entity for location. Let’s do that.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现一个用于位置的最后一个实体。让我们来做这件事。
- en: The Location entity
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置实体
- en: In networks, location is not considered an entity at the Domain hexagon level,
    but because we have a separate table for location, we need to treat it as a database
    entity at the Framework hexagon level.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，位置在领域六边形级别不被视为一个实体，但由于我们有一个单独的位置表，因此我们需要在框架六边形级别将其视为数据库实体。
- en: 'The following code is used to implement the `Location` entity class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于实现`Location`实体类：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We again rely on the database’s built-in ID generation mechanism to handle IDs
    for location data. After that, we have attributes such as `address` and `city`
    that are part of a location.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次依赖数据库内置的ID生成机制来处理位置数据的ID。之后，我们有了`address`和`city`等属性，它们是位置的一部分。
- en: Now that we have all the required entities adequately configured, we can move
    ahead and use `Panache` to create reactive repository classes, which we’ll use
    to trigger database operations with the entities we’ve configured.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经适当地配置了所有必需的实体，我们可以继续前进并使用`Panache`创建响应式存储库类，我们将使用这些类来触发我们配置的实体所进行的数据库操作。
- en: Implementing reactive repository classes
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现响应式存储库类
- en: By implementing the `PanacheRepositoryBase` interface, you create a reactive
    repository class. We’ll need one repository class for router operations and another
    for switch operations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`PanacheRepositoryBase`接口，您创建了一个响应式存储库类。我们需要一个存储库类用于路由操作，另一个用于交换操作。
- en: It’s paramount to define only one repository for the aggregate root. In our
    case, the `Router` entity is the aggregate root for router management operations,
    and `Switch` is the aggregate root for switch management operations. The purpose
    of an aggregate is to ensure consistency across all objects that are controlled
    by such an aggregate. The entry point for any aggregate is always the aggregate
    root. To ensure aggregate consistency in a database transaction, we define only
    one repository class, which is dedicated to controlling the database operations
    based on the aggregate root.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个聚合根的单一存储库至关重要。在我们的案例中，`Router`实体是路由管理操作的聚合根，而`Switch`是交换管理操作的聚合根。聚合的目的在于确保所有受该聚合控制的对象的一致性。任何聚合的入口点始终是聚合根。为了确保数据库事务中的聚合一致性，我们定义了一个专门的存储库类，该类仅用于根据聚合根控制数据库操作。
- en: 'The classes we’re about to implement are located in the `dev.davivieira.topologyinventory.framework.adapters.output.mysql.repository`
    package:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将实现的类位于`dev.davivieira.topologyinventory.framework.adapters.output.mysql.repository`包中：
- en: 'The following code implements the `RouterManagementRepository` class:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码实现了`RouterManagementRepository`类：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we’re passing `RouterData` as the entity we’re working on and `UUID`
    as the attribute type mapped to be used by the ID. If we don’t need any custom
    queries, we can leave this class empty because `Panache` already provides lots
    of standard database operations.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们正在传递`RouterData`作为我们正在处理的实体，以及`UUID`作为映射到ID的属性类型。如果我们不需要任何自定义查询，我们可以留这个类为空，因为`Panache`已经提供了大量的标准数据库操作。
- en: Note that we’re also annotating that class with `@ApplicationScoped`, so we
    can inject that component in other places, such as the output adapter, which we’ll
    implement soon.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们还在该类上标注了`@ApplicationScoped`，这样我们就可以在其他地方注入该组件，例如我们即将实现的输出适配器。
- en: 'The following code implements the `SwitchManagementRepository` class:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码实现了`SwitchManagementRepository`类：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we’re following the same approach we did for the `RouterManagementRepository`
    class.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们遵循与`RouterManagementRepository`类相同的方法。
- en: With the reactive repository classes properly implemented, we’re ready to create
    reactive output adapters. Let’s do that!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确实现了响应式存储库类之后，我们准备好创建响应式输出适配器。让我们这么做吧！
- en: Implementing reactive output adapters
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现响应式输出适配器
- en: 'Just to recap, we need to provide an adapter implementation for the `RouterManagementOutputPort`
    output port interface:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了回顾一下，我们需要为`RouterManagementOutputPort`输出端口接口提供一个适配器实现：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When implementing the MySQL output adapter, we’ll provide a reactive implementation
    for each one of the preceding method declarations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现MySQL输出适配器时，我们将为前面每个方法声明提供一个响应式实现。
- en: 'We also need to implement the `SwitchManagementOutputPort` output adapter interface:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现`SwitchManagementOutputPort`输出适配器接口：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s simpler, as there’s just one method for which we need to provide a reactive
    implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这比较简单，因为我们只需要提供一个响应式实现的方法。
- en: Let’s start by implementing the reactive output adapter for router management.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来实现路由管理响应式输出适配器。
- en: Reactive router management of the MySQL output adapter
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL输出适配器的响应式路由管理
- en: 'In order to enable the hexagonal system to communicate with a MySQL database,
    we need to create a new output adapter to allow such integration (because we’re
    using Quarkus, such an output adapter implementation is fairly simple). We’ll
    use the following steps to do so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使六边形系统能够与MySQL数据库通信，我们需要创建一个新的输出适配器以允许这种集成（因为我们使用Quarkus，这样的输出适配器实现相当简单）。我们将按照以下步骤进行：
- en: 'We start by injecting the `RouterManagementRepository` repository class:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先注入`RouterManagementRepository`存储库类：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ll use the `RouterManagementRepository` repository to make database operations.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`RouterManagementRepository`存储库来执行数据库操作。
- en: 'Then, we implement the `retrieveRouter` method:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现`retrieveRouter`方法：
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When we call `routerManagementRepository.findById(id.getUuid())`, the system
    starts an I/O non-blocking operation. This `subscribe` call tries to resolve the
    item produced by the `findById` operation. Then, we call `asCompletionStage` to
    receive the item. Finally, we call `join`, which returns the result value when
    the operation is complete.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们调用`routerManagementRepository.findById(id.getUuid())`时，系统启动一个I/O非阻塞操作。这个`subscribe`调用试图解析由`findById`操作产生的项目。然后，我们调用`asCompletionStage`来接收项目。最后，我们调用`join`，它在操作完成时返回结果值。
- en: 'Now, we need to implement the `removeRouter` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实现`removeRouter`方法：
- en: '[PRE29]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we call the `routerManagementRepository.deleteById(id.getUuid())` `Panache`
    operation to remove a router from the database. After that, we call `subscribe`,
    `asCompletionStage`, and `join` to execute the operations reactively.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们调用`routerManagementRepository.deleteById(id.getUuid())` `Panache`操作从数据库中删除一个路由器。之后，我们调用`subscribe`、`asCompletionStage`和`join`来执行这些操作以实现响应式。
- en: 'Finally, we implement the `persistRouter` method:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现`persistRouter`方法：
- en: '[PRE30]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The construct is different here. To ensure that the transaction will not be
    lost between the client and server during the request, we wrap the persistence
    operation inside `Panache.withTransaction`. This is a requirement for operations
    where we need to persist data.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的结构不同。为了确保在请求过程中客户端和服务器之间事务不会丢失，我们将持久化操作包裹在`Panache.withTransaction`中。这是需要持久化数据操作的要求。
- en: Let’s now implement the reactive output adapter for switch management.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现开关管理的响应式输出适配器。
- en: Reactive switch management of the MySQL output adapter
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL输出适配器的响应式开关管理
- en: 'The approach used here is the same one utilized when we implemented the reactive
    output adapter for router management. We’ll execute the following steps to implement
    the reactive output adapter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的方法与我们实现路由管理响应式输出适配器时使用的方法相同。我们将执行以下步骤来实现响应式输出适配器：
- en: 'Let’s start by injecting the `SwitchManagementRepository` repository class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先注入`SwitchManagementRepository`仓库类：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we already saw, the injection of a repository class is required so we can
    use it to trigger database operations.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，注入一个仓库类是必要的，这样我们就可以用它来触发数据库操作。
- en: 'After that, we implement the `retrieveSwitch` method:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们实现`retrieveSwitch`方法：
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use this method to retrieve a `Switch` object reactively. There are no persistence
    methods because all the write operations should always occur through a router
    management output adapter.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用这个方法来响应式地检索一个`Switch`对象。因为没有持久化方法，因为所有的写操作都应该始终通过路由管理输出适配器来执行。
- en: By implementing reactive output adapters in the hexagonal system, we can tap
    into the advantages of reactive programming techniques. With hexagonal architecture,
    it’s not a big deal to have both reactive and imperative output adapters serving
    different needs in the same system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在六边形系统中实现响应式输出适配器，我们可以利用响应式编程技术的优势。在六边形架构中，在同一系统中同时拥有响应式和命令式输出适配器来满足不同的需求并不是什么大问题。
- en: The Quarkus reactive features for databases are paramount for anyone venturing
    into developing reactive systems. We can provide a reactive alternative to how
    our application deals with databases by understanding how to use these features.
    That does not mean that the reactive approach is always a better choice than the
    traditional imperative one; it’s up to you and your project’s needs to decide
    which approach is more suitable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus数据库的响应式特性对于任何尝试开发响应式系统的开发者来说至关重要。通过理解如何使用这些特性，我们可以为我们的应用程序处理数据库的方式提供一个响应式的替代方案。但这并不意味着响应式方法总是比传统的命令式方法更好；这取决于你和你项目的需求，来决定哪种方法更适合。
- en: Now that we’ve implemented the `RouterManagementMySQLAdapter` and `SwitchManagementMySQLAdapter`
    output adapters, let’s test them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`RouterManagementMySQLAdapter`和`SwitchManagementMySQLAdapter`输出适配器，让我们测试它们。
- en: Testing the reactive output adapters
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试响应式输出适配器
- en: 'We need to implement unit tests to ensure the methods from the output adapters
    are working as expected. Here is an example of how we can create unit tests for
    `RouterManagementMySQLAdapter`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现单元测试来确保输出适配器的方法按预期工作。以下是如何为`RouterManagementMySQLAdapter`创建单元测试的示例：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It’s possible to use the `@InjectMock` annotation to mock the `RouterManagementMySQLAdapter`
    output adapter. When executing the `testRetrieveRouter` test method, we can mock
    a call to `routerManagementMySQLAdapter.retrieveRouter(router.getId)` by using
    `Mockito.when`. The `thenReturn` method returns the object that our mock test
    should return. In this case, it is a `Router` object. With `Assertions.assertSame(router,
    retrievedRouter)`, we can assert the result for the execution of `retrieveRouter(router.getId)`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@InjectMock`注解来模拟`RouterManagementMySQLAdapter`输出适配器。在执行`testRetrieveRouter`测试方法时，我们可以通过使用`Mockito.when`来模拟对`routerManagementMySQLAdapter.retrieveRouter(router.getId)`的调用。`thenReturn`方法返回我们的模拟测试应该返回的对象。在这种情况下，它是一个`Router`对象。通过`Assertions.assertSame(router,
    retrievedRouter)`，我们可以断言`retrieveRouter(router.getId)`的执行结果。
- en: We won’t need to implement new test classes to execute integration tests for
    Reactive output adapters. We can rely on the same tests used in the previous chapter
    to test the reactive input adapters. These tests call the input adapters, which,
    in turn, call the output adapters by using the use case operations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要实现新的测试类来执行响应式输出适配器的集成测试。我们可以依赖之前章节中使用的相同测试来测试响应式输入适配器。这些测试调用输入适配器，反过来，通过使用用例操作调用输出适配器。
- en: However, what changes is that we’ll need a MySQL database to test the reactive
    output adapters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，变化的是，我们将需要一个MySQL数据库来测试响应式输出适配器。
- en: 'Quarkus provides Docker-based containers that we can use for development purposes
    or testing. In order to enable such a database container, there is no need to
    provide a detailed data source connection configuration in the `application.properties`
    file. Here is how we should configure that file for testing purposes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus提供了基于Docker的容器，我们可以用于开发或测试目的。为了启用这样的数据库容器，在`application.properties`文件中不需要提供详细的数据源连接配置。以下是我们在测试目的下应该如何配置该文件的方法：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we’re not specifying a database connection URL. By doing that, Quarkus
    understands that it needs to provide a database. The previously described `application.properties`
    file should be placed in the `tests/resource/` directory. Inside this directory,
    we should also place the `inventory.sql` file, which loads data into the database.
    This `.sql` file is available in this chapter’s GitHub repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有指定数据库连接 URL。通过这样做，Quarkus 理解它需要提供一个数据库。之前描述的 `application.properties`
    文件应放置在 `tests/resource/` 目录中。在这个目录内，我们还应放置 `inventory.sql` 文件，该文件将数据加载到数据库中。这个
    `.sql` 文件在本章的 GitHub 仓库中可用。
- en: You can override entries in `application.properties` to use environment variables.
    This may be useful for configurations such as `quarkus.hibernate-orm.database.generation`
    where you can set the property value based on the application’s environment variables.
    For example, for local or development purposes, you can use `${DB_GENERATION}`,
    an environment variable that resolves to `drop-and-create`. In production, this
    environment variable can resolve to `none`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以覆盖 `application.properties` 中的条目以使用环境变量。这可能对配置如 `quarkus.hibernate-orm.database.generation`
    有用，其中您可以根据应用程序的环境变量设置属性值。例如，对于本地或开发目的，您可以使用 `${DB_GENERATION}`，这是一个解析为 `drop-and-create`
    的环境变量。在生产中，这个环境变量可以解析为 `none`。
- en: 'After properly setting up the `application.properties` and `inventory.sql`
    files, we can test the application by running the following command in the project’s
    root directory:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置 `application.properties` 和 `inventory.sql` 文件后，我们可以在项目的根目录中运行以下命令来测试应用程序：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following output shows the MySQL Docker container being brought up to be
    used during tests:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了在测试期间启动的 MySQL Docker 容器：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Quarkus creates a database called `default`, where the tables are created. The
    `inventory.sql` file is run against this `default` database.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 创建了一个名为 `default` 的数据库，其中创建了表。`inventory.sql` 文件在此 `default` 数据库上运行。
- en: 'After the database is ready, Quarkus starts testing the system, resulting in
    a result similar to the following one:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库准备就绪后，Quarkus 开始测试系统，结果类似于以下内容：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In order to test the output adapters, we need to call the input adapters. If
    we can test the input adapters successfully, that means we’re also testing the
    output adapters successfully.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试输出适配器，我们需要调用输入适配器。如果我们能够成功测试输入适配器，那么这也意味着我们已成功测试了输出适配器。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Hibernate Reactive and `Panache` make our lives much easier when we need to
    handle databases reactively using Quarkus. We learned that Hibernate Reactive
    is built on top of the traditional Hibernate implementation but with the addition
    of reactive features.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要使用 Quarkus 处理数据库的响应式操作时，Hibernate Reactive 和 `Panache` 使我们的生活变得更加简单。我们了解到
    Hibernate Reactive 是建立在传统 Hibernate 实现之上，但增加了响应式功能。
- en: While looking into `Panache`, we learned that it can help us implement the Active
    Record and Repository patterns to implement database operations. For the hands-on
    part, we implemented database entities, repositories, and reactive output adapters,
    which we used together to interact with the MySQL database. Finally, we configured
    the hexagonal system tests to use the MySQL Docker container that Quarkus provides.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究 `Panache` 的过程中，我们了解到它可以帮助我们实现 Active Record 和 Repository 模式以执行数据库操作。对于实践部分，我们实现了数据库实体、仓库和响应式输出适配器，并将它们一起使用以与
    MySQL 数据库进行交互。最后，我们配置了六边形系统测试以使用 Quarkus 提供的 MySQL Docker 容器。
- en: In the next chapter, we’ll learn about some techniques for packaging the hexagonal
    system in a Docker image. We’ll also learn how to run the hexagonal system in
    a Kubernetes cluster. This knowledge will enable us to make our hexagonal application
    ready to be deployed in cloud-based environments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些将六边形系统打包到 Docker 镜像中的技术。我们还将学习如何在 Kubernetes 集群中运行六边形系统。这些知识将使我们能够使我们的六边形应用程序准备好在基于云的环境中部署。
- en: Questions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which Java specification does Hibernate Reactive implement?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hibernate Reactive 实现了哪个 Java 规范？
- en: What is the difference between the Active Record and Repository patterns?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Active Record 和 Repository 模式之间的区别是什么？
- en: Which interface should we implement to apply the Repository pattern?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该实现哪个接口来应用 Repository 模式？
- en: Why should we run write operations inside the `withTransaction` method?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该在 `withTransaction` 方法内运行写操作？
- en: Answers
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Hibernate Reactive implements the **JPA** specification.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hibernate Reactive 实现了 **JPA** 规范。
- en: The Active Record pattern allows us to use the entity class to perform operations
    on the database, whereas we have a dedicated class in the Repository pattern to
    perform such operations.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Active Record 模式允许我们使用实体类对数据库进行操作，而 Repository 模式则有一个专门的类来执行此类操作。
- en: We should implement the `PanacheRepositoryBase` interface.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该实现 `PanacheRepositoryBase` 接口。
- en: To ensure the database transaction won’t be lost during the reactive operation.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保在反应式操作过程中数据库事务不会丢失。
