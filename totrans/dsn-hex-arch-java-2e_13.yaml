- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persisting Data with Output Adapters and Hibernate Reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about some of the advantages that can be
    brought to a system by using Quarkus reactive capabilities. Our first step on
    the reactive road was to implement Reactive input adapters using **RESTEasy Reactive**.
    Although the input adapters’ endpoints are being served reactively, we still have
    the output adapters working in a synchronous and blocking fashion.
  prefs: []
  type: TYPE_NORMAL
- en: To turn the hexagonal system into a more Reactive one, in this chapter, we’ll
    first learn how to configure `Panache`. Once the system entities are properly
    configured, we’ll learn how to use these entities to connect to a MySQL database
    reactively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics we’ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Hibernate Reactive and `Panache`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling reactive behavior on output adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing reactive output adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have already implemented reactive input adapters in the previous chapter,
    our goal here is to extend the reactive behavior in a hexagonal system by implementing
    reactive output adapters. This implementation takes place at the Framework hexagon,
    which is the architecture element where we concentrate on adapters.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have learned how to integrate Quarkus with
    a hexagonal system to access databases reactively. By understanding the required
    configuration steps and fundamental implementation details, you’ll be able to
    implement reactive output adapters. This knowledge will help you tackle situations
    where non-blocking I/O requests offer more advantages than I/O-blocking ones.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you need the
    latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are all available for Linux, Mac, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you’ll need **Docker** installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Hibernate Reactive and Panache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The available technologies and techniques to handle database operations in Java
    have evolved a lot in the last few years. Based on the **Java Persistence API**
    (**JPA**) specification, we’ve been presented with different ORM implementations
    such as Spring Data JPA, EclipseLink, and, of course, Hibernate. These technologies
    make our lives easier by abstracting away much of the plumber work required to
    deal with databases.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus is integrated with Hibernate ORM and its reactive counterpart, Hibernate
    Reactive. Also, Quarkus comes with a library called `Panache`, which simplifies
    our interaction with databases.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll take a brief look at Hibernate Reactive and Panache’s main features.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate Reactive features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s rare, if not impossible, to find a silver-bullet solution that solves all
    problems related to database access. When we talk about the reactive and imperative
    approaches to database handling, it’s fundamental to understand the advantages
    and disadvantages of both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: What’s so appealing about the imperative approach to database access is the
    simplicity with which you develop your code. There are fewer things to adjust
    and think about when you need to read or persist things using an imperative approach.
    However, this approach may cause setbacks when its blocking nature starts to impact
    the use cases of your system. To avoid such setbacks, we have the reactive approach,
    enabling us to deal with databases in a non-blocking fashion, but not without
    additional complexities in our development and the new problems and challenges
    that arise when reactively handling databases.
  prefs: []
  type: TYPE_NORMAL
- en: The original Hibernate implementation was conceived to solve the problems that
    developers had to deal with when mapping Java objects to database entities. The
    original implementation relies on I/O blocking synchronous communication to interact
    with databases. It’s been, and still is, the most conventional way to access databases
    in Java. On the other hand, Hibernate Reactive arose from the urge for reactive
    programming movements and the need for asynchronous communication to database
    access. Instead of I/O blocking, Hibernate Reactive relies upon I/O non-blocking
    communication to interact with databases.
  prefs: []
  type: TYPE_NORMAL
- en: The entity mapping properties remain the same in a reactive implementation.
    However, what changes is how we open a database’s Reactive connection and how
    we should structure the software code to handle database entities reactively.
  prefs: []
  type: TYPE_NORMAL
- en: When using Quarkus, there is no need to provide a reactive persistence configuration
    based on the `persistence.xml` file because Quarkus already configures it for
    us. Still, we will briefly explore it to have an idea of how Hibernate Reactive
    alone works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Hibernate Reactive, you can follow the standard approach to configuring
    the `META-INF/persistence.xml` file, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we’re using `ReactivePersistenceProvider` to open a reactive connection
    to the database. Once the `persistence.xml` file is properly configured, we can
    start using Hibernate Reactive in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing the static `javax.persistence.Persistence.createEntityManagerFactory`
    method provided by Hibernate Reactive. This static method facilitates the creation
    of `SessionFactory` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a `SessionFactory` object, the system uses the properties
    defined by the `persistence.xml` file. With `SessionFactory`, we can start reactive
    communication with the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To persist data, first, we need to create a transaction by calling the `withTransaction`
    method. Inside a transaction, we call the `persistAll` method from `SessionFactory`
    to persist an object. We call the `subscribe` method to trigger the persistence
    operation in a non-blocking way.
  prefs: []
  type: TYPE_NORMAL
- en: By establishing a layer between the application and the database, Hibernate
    provides all the basic things we need to handle databases in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how `Panache` can make things even simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Panache features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Panache` sits on top of Hibernate and enhances it even more by providing a
    simple interface for handling the database entities. `Panache` was primarily developed
    to work with the Quarkus framework, and it is a library aimed to abstract much
    of the boilerplate code required to handle the database entities. With `Panache`,
    you can easily apply database patterns such as **Active Record** and **Repository**.
    Let’s briefly see how to do that.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Active Record pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `PanacheEntity`. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `Location` class is a regular Hibernate-based entity that extends
    `PanacheEntity`. Besides extending `PanacheEntity`, there is nothing new in this
    `Location` class. We have annotations such as `@NotNull` and `@Size` that we use
    to validate the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the things we can do with an Active Record entity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To list entities, we can call the `listAll` method. This method is available
    on `Location` because we’re extending the `PanacheEntity` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To delete all the `Location` entities, we can call the `deleteAll` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To find a specific `Location` entity by its ID, we can use the `findByIdOptional`
    method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To persist a `Location` entity, we have to call the `persist` method on the
    `Location` instance we intend to persist:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time we execute one of the preceding described operations, they are immediately
    committed to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how to use `Panache` to apply the Repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the Repository pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using an entity class to perform actions on the database, we use
    a separate class that is usually dedicated to providing database operations in
    the Repository pattern. This kind of class works like a repository interface for
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the Repository pattern, we should use regular Hibernate entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that at this time, we’re not extending the `PanacheEntity` class. In the
    Repository pattern, we don’t call the database operations directly through the
    entity class. Instead, we call them through the repository class. Here is an example
    of how we can implement a repository class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By implementing `PanacheRepository` on the `LocationRepository` class, we’re
    enabling all the standard operations such as `findById`, `delete`, `persist`,
    and so on that are present in the `PanacheEntity` class. Also, we can define our
    own custom queries, as we did in the preceding example, by using the `find` and
    `delete` methods provided by the `PanacheEntity` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we annotated the repository class as an `@ApplicationScoped` bean.
    This means we can inject and use it in other classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the most common operations available on the repository class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all the `Location` entities, we need to call the `listAll` method from
    `LocationRepository`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By calling `deleteAll` on `LocationRepository`, we remove all the `Location`
    entities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To find a `Location` entity by its ID, we call the `findByIdOptional` method
    on `LocationRepository`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To persist a `Location` entity, we need to pass a `Location` instance to the
    `persist` method from `LocationRepository`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding examples, we are executing all database operations using the
    repository class. The methods we call here are the same as those present in the
    entity class from the Active Record approach. The only difference here is the
    usage of the repository class.
  prefs: []
  type: TYPE_NORMAL
- en: By learning how to use `Panache` to apply the Active Record and Repository patterns,
    we increase our capacity to provide good approaches to handling database entities.
    There is no better or worse pattern. The project’s circumstances will ultimately
    dictate which pattern is more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: '`Panache` is a library made especially for Quarkus. So, the best way to connect
    Hibernate Reactive objects such as `SessionFactory` and `Transaction` to `Panache`
    is by delegating the database configuration to Quarkus, which will automatically
    provide these objects to you.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re acquainted with Hibernate Reactive and `Panache`, let’s see how
    we can implement output adapters in a hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling reactive behavior on output adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important benefits of using hexagonal architecture is the improved
    flexibility to change technologies without significant refactoring. The hexagonal
    system is designed so that its domain logic and business rules are oblivious to
    the technologies utilized to execute them.
  prefs: []
  type: TYPE_NORMAL
- en: There is no free lunch – when we decide to use the hexagonal architecture, we
    have to pay the price for the benefits that this architecture can provide. (By
    price, I mean a considerable increase in the effort and complexity required to
    structure the system code by following the hexagonal principles.)
  prefs: []
  type: TYPE_NORMAL
- en: If you’re concerned about code reuse, you may find some practices awkward to
    decouple code from specific technologies. For example, consider a scenario in
    which we have a domain entity class and a database entity class. We may argue,
    *why not have just one class that serves both purposes?* Well, in the end, it’s
    all a matter of priorities. If the coupling of the domain and technology-specific
    classes is not an issue for you, go ahead. In this case, you will not have the
    burden of maintaining a domain model plus all the infrastructure code that supports
    it. However, the same code would serve different purposes, thus violating the
    **Single Responsibility Principle** (**SRP**). Otherwise, if you see a risk in
    using the same code for serving different purposes, then the output adapters can
    help.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19777_02.xhtml#_idTextAnchor038), *Wrapping Business Rules
    Inside the Domain Hexagon*, we introduced an output adapter that integrated the
    application with the filesystem. In [*Chapter 4*](B19777_04.xhtml#_idTextAnchor083),
    *Creating Adapters to Interact with the Outside World*, we created a more elaborated
    output adapter to communicate with an H2 in-memory database. Now that we have
    the Quarkus toolkit at our disposal, we can create reactive output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring reactive data sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To continue the reactive effort that we started in the previous chapter by
    implementing reactive input adapters, we’ll create and connect reactive output
    adapters to these reactive input adapters by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started by configuring the required dependencies in the `pom.xml`
    file of the Framework hexagon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `quarkus-reactive-mysql-client` dependency contains the libraries we need
    to open a reactive connection with MySQL databases and the `quarkus-hibernate-reactive-panache`
    dependency contains Hibernate Reactive and `Panache`. It’s important to note that
    this library is especially suited for reactive activities. For non-reactive activities,
    Quarkus offers a different library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to configure the database connection on the `application.properties`
    file from the Bootstrap hexagon. Let’s start with the data source properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `quarkus.datasource.db-kind` property is not mandatory because Quarkus can
    infer the database kind by looking into the specific database client that is loaded
    from Maven dependencies. With `quarkus.datasource.reactive` set to `true`, we’re
    enforcing reactive connections. We need to specify the reactive database connection
    URL on `quarkus.datasource.reactive.url`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we have to define the Hibernate configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After Quarkus has created the database and its tables, you can load a `.sql`
    file to execute more instructions on the database. By default, it searches for
    and loads a file called `import.sql`. We can change this behavior by using the
    `quarkus.hibernate-orm.sql-load-script` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be aware of not using `quarkus.hibernate-orm.database.generation = drop-and-create`
    in production. Otherwise, it will drop all your database tables. If you don’t
    set any value, the default one, `none`, is used. The default behavior doesn’t
    make any changes to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And, finally, we enable `quarkus.hibernate-orm.log.sql` to see which SQL queries
    Hibernate is executing behind the hood. I recommend you enable the `log` feature
    only for development purposes. When running the application in production, don’t
    forget to disable this option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s now see how to configure application entities to work with a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The topology and inventory system requires four database tables to store its
    data: routers, switches, networks, and location. Each one of these tables will
    be mapped to a Hibernate entity class properly configured to work with a MySQL
    data source.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll apply the Repository pattern, so we won’t have the entities to perform
    database operations. Instead, we’ll create separate repository classes to trigger
    actions on the database, but before creating repository classes, let’s start by
    implementing Hibernate entities for the topology and inventory system. We’ll configure
    these entities to work with MySQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: The Router entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this entity and the others that will be implemented subsequently, we should
    create classes in the `dev.davivieira.topologyinventory.framework.adapters.output.mysql.data`
    package of the Framework hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `Router` entity class should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For the `routerId` and `routerParentCoreId` fields, we must set `columnDefinition`,
    the `@Column` annotation parameter, to `BINARY(16)`. It’s a requirement to make
    `UUID` attributes work on MySQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create the relationship mapping between routers and other tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a many-to-one relation between routers and location. After that,
    we have two one-to-many relationships with switches and routers, respectively.
    The `fetch = FetchType.EAGER` property is used to avoid any mapping errors that
    may occur during the reactive connections.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the configuration of the `Switch` entity class.
  prefs: []
  type: TYPE_NORMAL
- en: The Switch entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code shows us how we should implement the `Switch` entity class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have omitted other column attributes to focus only on the IDs and relationships.
    We start by defining a many-to-one relationship between switches and a router.
    The primary key is the `switchId` field, which happens to be a `UUID` attribute.
    We have another `UUID` attribute for mapping the `routerId` field.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there is a one-to-many relationship between a switch and networks, and
    a many-to-one relationship between switches and a location.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s configure the `Network` entity class.
  prefs: []
  type: TYPE_NORMAL
- en: The Network entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we do not consider networks to be entities in the domain model, they
    have a separate table in the database. So, at the Framework hexagon level, we
    treat them as database entities, but when they reach the Domain hexagon, we treat
    them as value objects. This example shows that the hexagon system dictates how
    the data will be treated at the Domain hexagon level. By doing so, the hexagonal
    system shields the domain model from technical details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement the `Network` entity class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a straightforward entity class with a many-to-one relationship between
    networks and a switch. For networks, we rely on the database to generate network
    IDs. Also, networks are not considered entities in the domain model. Instead,
    we treat networks as value objects that are controlled by an aggregate. For aggregates,
    we need to handle the `UUID`, but for value objects, we do not. That’s why we
    don’t handle UUIDs for network database entities.
  prefs: []
  type: TYPE_NORMAL
- en: We still need to implement one last entity for location. Let’s do that.
  prefs: []
  type: TYPE_NORMAL
- en: The Location entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In networks, location is not considered an entity at the Domain hexagon level,
    but because we have a separate table for location, we need to treat it as a database
    entity at the Framework hexagon level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to implement the `Location` entity class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We again rely on the database’s built-in ID generation mechanism to handle IDs
    for location data. After that, we have attributes such as `address` and `city`
    that are part of a location.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the required entities adequately configured, we can move
    ahead and use `Panache` to create reactive repository classes, which we’ll use
    to trigger database operations with the entities we’ve configured.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing reactive repository classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By implementing the `PanacheRepositoryBase` interface, you create a reactive
    repository class. We’ll need one repository class for router operations and another
    for switch operations.
  prefs: []
  type: TYPE_NORMAL
- en: It’s paramount to define only one repository for the aggregate root. In our
    case, the `Router` entity is the aggregate root for router management operations,
    and `Switch` is the aggregate root for switch management operations. The purpose
    of an aggregate is to ensure consistency across all objects that are controlled
    by such an aggregate. The entry point for any aggregate is always the aggregate
    root. To ensure aggregate consistency in a database transaction, we define only
    one repository class, which is dedicated to controlling the database operations
    based on the aggregate root.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes we’re about to implement are located in the `dev.davivieira.topologyinventory.framework.adapters.output.mysql.repository`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements the `RouterManagementRepository` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we’re passing `RouterData` as the entity we’re working on and `UUID`
    as the attribute type mapped to be used by the ID. If we don’t need any custom
    queries, we can leave this class empty because `Panache` already provides lots
    of standard database operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we’re also annotating that class with `@ApplicationScoped`, so we
    can inject that component in other places, such as the output adapter, which we’ll
    implement soon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code implements the `SwitchManagementRepository` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we’re following the same approach we did for the `RouterManagementRepository`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the reactive repository classes properly implemented, we’re ready to create
    reactive output adapters. Let’s do that!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing reactive output adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just to recap, we need to provide an adapter implementation for the `RouterManagementOutputPort`
    output port interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When implementing the MySQL output adapter, we’ll provide a reactive implementation
    for each one of the preceding method declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to implement the `SwitchManagementOutputPort` output adapter interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It’s simpler, as there’s just one method for which we need to provide a reactive
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by implementing the reactive output adapter for router management.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive router management of the MySQL output adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to enable the hexagonal system to communicate with a MySQL database,
    we need to create a new output adapter to allow such integration (because we’re
    using Quarkus, such an output adapter implementation is fairly simple). We’ll
    use the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by injecting the `RouterManagementRepository` repository class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll use the `RouterManagementRepository` repository to make database operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we implement the `retrieveRouter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we call `routerManagementRepository.findById(id.getUuid())`, the system
    starts an I/O non-blocking operation. This `subscribe` call tries to resolve the
    item produced by the `findById` operation. Then, we call `asCompletionStage` to
    receive the item. Finally, we call `join`, which returns the result value when
    the operation is complete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to implement the `removeRouter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we call the `routerManagementRepository.deleteById(id.getUuid())` `Panache`
    operation to remove a router from the database. After that, we call `subscribe`,
    `asCompletionStage`, and `join` to execute the operations reactively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we implement the `persistRouter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The construct is different here. To ensure that the transaction will not be
    lost between the client and server during the request, we wrap the persistence
    operation inside `Panache.withTransaction`. This is a requirement for operations
    where we need to persist data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s now implement the reactive output adapter for switch management.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive switch management of the MySQL output adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The approach used here is the same one utilized when we implemented the reactive
    output adapter for router management. We’ll execute the following steps to implement
    the reactive output adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by injecting the `SwitchManagementRepository` repository class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we already saw, the injection of a repository class is required so we can
    use it to trigger database operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After that, we implement the `retrieveSwitch` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use this method to retrieve a `Switch` object reactively. There are no persistence
    methods because all the write operations should always occur through a router
    management output adapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By implementing reactive output adapters in the hexagonal system, we can tap
    into the advantages of reactive programming techniques. With hexagonal architecture,
    it’s not a big deal to have both reactive and imperative output adapters serving
    different needs in the same system.
  prefs: []
  type: TYPE_NORMAL
- en: The Quarkus reactive features for databases are paramount for anyone venturing
    into developing reactive systems. We can provide a reactive alternative to how
    our application deals with databases by understanding how to use these features.
    That does not mean that the reactive approach is always a better choice than the
    traditional imperative one; it’s up to you and your project’s needs to decide
    which approach is more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve implemented the `RouterManagementMySQLAdapter` and `SwitchManagementMySQLAdapter`
    output adapters, let’s test them.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the reactive output adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to implement unit tests to ensure the methods from the output adapters
    are working as expected. Here is an example of how we can create unit tests for
    `RouterManagementMySQLAdapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It’s possible to use the `@InjectMock` annotation to mock the `RouterManagementMySQLAdapter`
    output adapter. When executing the `testRetrieveRouter` test method, we can mock
    a call to `routerManagementMySQLAdapter.retrieveRouter(router.getId)` by using
    `Mockito.when`. The `thenReturn` method returns the object that our mock test
    should return. In this case, it is a `Router` object. With `Assertions.assertSame(router,
    retrievedRouter)`, we can assert the result for the execution of `retrieveRouter(router.getId)`.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t need to implement new test classes to execute integration tests for
    Reactive output adapters. We can rely on the same tests used in the previous chapter
    to test the reactive input adapters. These tests call the input adapters, which,
    in turn, call the output adapters by using the use case operations.
  prefs: []
  type: TYPE_NORMAL
- en: However, what changes is that we’ll need a MySQL database to test the reactive
    output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quarkus provides Docker-based containers that we can use for development purposes
    or testing. In order to enable such a database container, there is no need to
    provide a detailed data source connection configuration in the `application.properties`
    file. Here is how we should configure that file for testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’re not specifying a database connection URL. By doing that, Quarkus
    understands that it needs to provide a database. The previously described `application.properties`
    file should be placed in the `tests/resource/` directory. Inside this directory,
    we should also place the `inventory.sql` file, which loads data into the database.
    This `.sql` file is available in this chapter’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: You can override entries in `application.properties` to use environment variables.
    This may be useful for configurations such as `quarkus.hibernate-orm.database.generation`
    where you can set the property value based on the application’s environment variables.
    For example, for local or development purposes, you can use `${DB_GENERATION}`,
    an environment variable that resolves to `drop-and-create`. In production, this
    environment variable can resolve to `none`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After properly setting up the `application.properties` and `inventory.sql`
    files, we can test the application by running the following command in the project’s
    root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows the MySQL Docker container being brought up to be
    used during tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Quarkus creates a database called `default`, where the tables are created. The
    `inventory.sql` file is run against this `default` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the database is ready, Quarkus starts testing the system, resulting in
    a result similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In order to test the output adapters, we need to call the input adapters. If
    we can test the input adapters successfully, that means we’re also testing the
    output adapters successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hibernate Reactive and `Panache` make our lives much easier when we need to
    handle databases reactively using Quarkus. We learned that Hibernate Reactive
    is built on top of the traditional Hibernate implementation but with the addition
    of reactive features.
  prefs: []
  type: TYPE_NORMAL
- en: While looking into `Panache`, we learned that it can help us implement the Active
    Record and Repository patterns to implement database operations. For the hands-on
    part, we implemented database entities, repositories, and reactive output adapters,
    which we used together to interact with the MySQL database. Finally, we configured
    the hexagonal system tests to use the MySQL Docker container that Quarkus provides.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn about some techniques for packaging the hexagonal
    system in a Docker image. We’ll also learn how to run the hexagonal system in
    a Kubernetes cluster. This knowledge will enable us to make our hexagonal application
    ready to be deployed in cloud-based environments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which Java specification does Hibernate Reactive implement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the Active Record and Repository patterns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which interface should we implement to apply the Repository pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we run write operations inside the `withTransaction` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hibernate Reactive implements the **JPA** specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Active Record pattern allows us to use the entity class to perform operations
    on the database, whereas we have a dedicated class in the Repository pattern to
    perform such operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should implement the `PanacheRepositoryBase` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure the database transaction won’t be lost during the reactive operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
