<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Behavioral Design Patterns – Part Two</h1>
                </header>
            
            <article>
                
<p class="mce-root">The group of behavioral design patterns is a relatively big one. In the previous chapter, we looked at the first part of behavioral design patterns and understood what their purpose is. As we already know, these patterns are used to deal with behavior and modeling object communication in computer programs.</p>
<p>In this chapter, we will continue going through the different behavioral design patterns as seen from the point of view of Scala. We will look at the following topics:</p>
<ul>
<li>Iterator</li>
<li>Mediator</li>
<li>Memento</li>
<li>Observer</li>
<li>State</li>
<li>Template method</li>
<li>Visitor</li>
</ul>
<p>The design patterns that we will cover in this chapter might not be as relevant to functional programming as some of the others we've seen earlier. They might look like Scala implementations of Java design patterns and this will actually be the case. However, this does not make them unnecessary and they are still important due to the hybrid nature of Scala.</p>
<p>As in the previous chapters, we will follow the same structure, give a pattern definition, show a class diagram and a code example, and talk about the pros and cons of the specific design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The iterator design pattern</h1>
                </header>
            
            <article>
                
<p>We use iterators in software projects all the time. When we traverse a list or go through the items of a set or a map, we use an <strong>iterator</strong>.</p>
<div class="packt_infobox">The iterator design pattern provides a way to access the elements of an aggregate object (collection) in a sequential manner without exposing the underlying representation of the items.</div>
<p>When using the iterator design pattern, the developer doesn't need to know whether there is a linked list, array, tree, or a hash map underneath.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>Using the iterator design pattern, we can create our own objects that act as collections and we can use them in loops. In Java, there is an interface called <kbd>Iterator</kbd>, which we can implement for this purpose. In Scala, we can mix in the <kbd>Iterator</kbd> trait and implement its <kbd>hasNext</kbd> and <kbd>next</kbd> methods.</p>
<p>For the class diagram and the example, let's have a <strong>ClassRoom</strong> class that will support a foreach loop running through all students. The following diagram shows our class diagram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/2c7a71c4-8afa-4b1a-8caf-e6f2ee9dd195.png" style="width:43.25em;height:18.83em;" width="1105" height="481"/></div>
<p>We've decided on our <strong>ClassRoom</strong> class to implement <strong>Iterable</strong>, which should return an <strong>Iterator</strong> and then return a new instance of our iterator when the method is called. The iterator design pattern is represented by the right-hand side of the diagram. The rest of the diagram is something we've done to make working with our class easier.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Let's see the code that implements the preceding diagram. First of all, the <kbd>Student</kbd> class is simply a case class that looks as follows:</p>
<pre><span>case class </span>Student(name: <span>String</span><span>, </span>age: <span>Int</span>)</pre>
<p>We have implemented the standard Scala <kbd>Iterator</kbd> trait in the <kbd>StudentIterator</kbd> class. Here is the implementation:</p>
<pre><span>class </span>StudentIterator(students: Array[Student]) <span>extends </span><span>Iterator</span>[Student] {<br/>  <span>var </span><span>currentPos </span>= <span>0<br/></span><span><br/></span><span>  </span><span>override def </span><span>hasNext</span>: <span>Boolean </span>= <span>currentPos </span>&lt; students.size<br/><br/>  <span>override def </span><span>next</span>(): Student = {<br/>    <span>val </span>result = students(<span>currentPos</span>)<br/>    <span>currentPos </span>= <span>currentPos </span>+ <span>1<br/></span><span>    </span>result<br/>  }<br/>}</pre>
<p>One thing to know about iterators is that they work in only one direction and you cannot go back. That's why we simply use a <kbd>currentPos</kbd> variable to remember how far we are in an iteration. We have used a mutable variable here, which is against the Scala principles; however, this is just an example and it is not too critical. In practice, you would probably use the iterator design pattern in conjunction with data structures, rather than in this form. The reason we've chosen the underlying structure of the iterator to be an <kbd>Array</kbd> is that indexing access of arrays is constant and it will improve the performance of large collections and keep our implementation simple.</p>
<p>The preceding code is really enough to show the iterator design pattern. The rest of the code is here to help us show how it can be used. Let's have a look at the <kbd>ClassRoom</kbd> class:</p>
<pre><span><span class="pl-k">import</span> <span class="pl-smi">scala.collection.mutable.</span><span class="pl-smi">ListBuffer</span><br/><br/>class </span>ClassRoom <span>extends </span><span>Iterable</span>[Student] {<br/>  <span>val </span><span>students</span>: ListBuffer[Student] = ListBuffer[Student]()<br/><br/>  <span>def </span><span>add</span>(student: Student): <span>Unit </span>= {<br/>    student +=: <span>students<br/></span><span>  </span>}<br/><br/>  <span>override def </span><span>iterator</span>: <span>Iterator</span>[Student] = <span>new </span>StudentIterator(<span>students</span>.toArray)<br/>}</pre>
<p>We mix in the <kbd>Iterable</kbd> trait in the preceding code and implement its <kbd>iterator</kbd> method. We return our <kbd>StudentIterator</kbd>.</p>
<div class="packt_tip">We've created a custom iterator just as an example. However, in reality, you would just implement <kbd>Iterable</kbd> in the <kbd>ClassRoom</kbd> class and return the iterator of the underlying collection (students, in this case).</div>
<p>Let's see an example that uses our <kbd>ClassRoom</kbd> class:</p>
<pre><span>object </span>ClassRoomExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>classRoom = <span>new </span>ClassRoom<br/>    classRoom.add(<span>Student</span>(<span>"Ivan"</span><span>, </span><span>26</span>))<br/>    classRoom.add(<span>Student</span>(<span>"Maria"</span><span>, </span><span>26</span>))<br/>    classRoom.add(<span>Student</span>(<span>"John"</span><span>, </span><span>25</span>))<br/>    classRoom.foreach(<span>println</span>)<br/>  }<br/>}</pre>
<p>The fact that we have mixed in the <kbd>Iterable</kbd> trait allows us to use <kbd>foreach</kbd>, <kbd>map</kbd>, <kbd>flatMap</kbd>, and many others on an object of the <kbd>ClassRoom</kbd> type. The following screenshot shows the output of our example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2f0de080-e9ce-4cea-9d7a-39600bc53d73.png" width="739" height="120"/></div>
<p>As you can see in this example, the user of our <kbd>ClassRoom</kbd> class has no idea about the underlying data structure that holds our <kbd>Student</kbd> objects. We could replace it at any time (we can even get the data of the students from a database) and the entire code will keep working as long as we still have the <kbd>Iterable</kbd> trait in our class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The iterator design pattern is used all the time in software engineering. It is probably one of the most often used design patterns and everyone knows about it. It is used with almost all collections one can think of, it is pretty simple, and allows us to hide the details of how a composite object is internally organized.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>One obvious drawback of our implementation, which shows a possible problem with the iteration design pattern, is its use in parallel code. What would happen if another thread adds or removes objects to or from the original collection? Our iterator will not reflect that and it could lead to problems due to lack of synchronization. Making iterators capable of handling multithreaded environments is not a simple task.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The mediator design pattern</h1>
                </header>
            
            <article>
                
<p>Real-world software projects usually contain a large number of different classes. This helps to distribute complexity and logic so that each class does one specific thing, which is simple, rather than many complex tasks. This, however, requires classes to communicate with each other in some way in order to realize some specific functionality, but then keeping the loose coupling principle in place could become a challenge.</p>
<div class="packt_infobox">The purpose of the mediator design pattern is to define an object that encapsulates how a set of other objects interact with each other in order to promote loose coupling and allow us to vary class interactions independently.</div>
<p>The mediator design pattern defines a specific object called <strong>mediator</strong> that enables other ones to communicate with each other instead of doing this directly. This reduces dependencies between them, which makes a program easy to change and maintain in the future as well as have it properly tested.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>Let's imagine that we are building a system for a school where each student can take multiple classes and each class is taken by multiple students. We might want to have a functionality that notifies all the students of a specific class that it is canceled, or we might want to easily add or remove users from classes. We can impulsively start writing our code and have a list of classes as a part of the <kbd>student</kbd> class and a list of students in the <kbd>group</kbd> class. This way, however, our objects will become interconnected and not really reusable. This is a good use case for the mediator pattern.</p>
<p>Let's take a look at our class diagram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/5b14b59f-2fc7-40fe-9160-bbf7c61ed3cb.png" width="1705" height="917"/></div>
<p>As you can see from the preceding diagram, the school is the mediator and it contains information about users to groups and groups to users. It manages the interaction between these entities and allows us to make our <strong>Student</strong> and <strong>Group</strong> classes reusable and independent from each other.</p>
<p>We've given an example with students and classes; however, this could be easily applied to any many-to-many relationships—permission groups in software, taxi systems, air traffic control systems, and many more.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Now that we have presented our class diagram, let's take a look at the source code for the example. First of all, let's see the model classes we have:</p>
<pre><span>trait </span>Notifiable {<br/>  <span>def </span><span>notify</span>(message: <span>String</span>)<br/>}<br/><br/><span>case class </span>Student(name: <span>String</span><span>, </span>age: <span>Int</span>) <span>extends </span>Notifiable {<br/>  <span>override def </span><span>notify</span>(message: <span>String</span>): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"Student </span><span>$</span>name<span> was notified with message:<br/>    '</span><span>$</span>message<span>'."</span>)<br/>  }<br/>}<br/><br/><span>case class </span>Group(name: <span>String</span>)</pre>
<p>The <kbd>Notifiable</kbd> trait in the preceding code is not needed in the current example; however, for example, if we add teachers, then it would be useful in the cases where we want to send notifications to everyone in the same group. The classes in the previous code can have their own independent functionality.</p>
<p>Our <kbd>Mediator</kbd> trait has the following definition:</p>
<pre><span>trait </span>Mediator {<br/>  <span>def </span><span>addStudentToGroup</span>(student: Student<span>, </span>group: Group)<br/><br/>  <span>def </span><span>isStudentInGroup</span>(student: Student<span>, </span>group: Group): <span>Boolean<br/></span><span><br/></span><span>  </span><span>def </span><span>removeStudentFromGroup</span>(student: Student<span>, </span>group: Group)<br/><br/>  <span>def </span><span>getStudentsInGroup</span>(group: Group): <span>List</span>[Student]<br/><br/>  <span>def </span><span>getGroupsForStudent</span>(student: Student): <span>List</span>[Group]<br/><br/>  <span>def </span><span>notifyStudentsInGroup</span>(group: Group<span>, </span>message: <span>String</span>)<br/>}</pre>
<p>As you can see, the preceding code defines methods that allow interactions between students and groups. The implementation of these methods is as follows:</p>
<pre><span>import scala.collection.mutable.Map<br/>import scala.collection.mutable.Set<br/><br/>class </span>School <span>extends </span>Mediator {<br/>  <span>val </span><span>studentsToGroups</span>: Map[Student<span>, </span><span>Set</span>[Group]] = Map()<br/>  <span>val </span><span>groupsToStudents</span>: Map[Group<span>, </span><span>Set</span>[Student]] = Map()<br/><br/>  <span>override def </span><span>addStudentToGroup</span>(student: Student<span>, </span>group: Group): <span>Unit </span>= {<br/>    <span>studentsToGroups</span>.getOrElseUpdate(student<span>, </span><span>Set</span>()) += group<br/>    <span>groupsToStudents</span>.getOrElseUpdate(group<span>, </span><span>Set</span>()) += student<br/>  }<br/><br/>  <span>override def </span><span>isStudentInGroup</span>(student: Student<span>, </span>group: Group): <span>Boolean </span>=<br/>    <span>groupsToStudents</span>.getOrElse(group<span>, </span><span>Set</span>()).contains(student) &amp;&amp;<br/>      <span>studentsToGroups</span>.getOrElse(student<span>, </span><span>Set</span>()).contains(group)<br/><br/>  <span>override def </span><span>getStudentsInGroup</span>(group: Group): <span>List</span>[Student] =<br/>    <span>groupsToStudents</span>.getOrElse(group<span>, </span><span>Set</span>()).toList<br/><br/>  <span>override def </span><span>getGroupsForStudent</span>(student: Student): <span>List</span>[Group] = <span>studentsToGroups</span>.getOrElse(student<span>, </span><span>Set</span>()).toList<br/><br/>  <span>override def </span><span>notifyStudentsInGroup</span>(group: Group<span>, </span>message: <span>String</span>): <span>Unit </span>= {<br/>    <span>groupsToStudents</span>.getOrElse(group<span>, </span><span>Set</span>()).foreach(_.notify(message))<br/>  }<br/><br/>  <span>override def </span><span>removeStudentFromGroup</span>(student: Student<span>, </span>group: Group): <span>Unit </span>= {<br/>    <span>studentsToGroups</span>.getOrElse(student<span>, </span><span>Set</span>()) -= group<br/>    <span>groupsToStudents</span>.getOrElse(group<span>, </span><span>Set</span>()) -= student<br/>  }<br/>}</pre>
<p>The <kbd>School</kbd> is the actual mediator that our application will be using. As you can see, it does exactly what the mediator design pattern is supposed to do—keeps the objects from directly referring to each other and internally defines their interactions. An application that uses our <kbd>School</kbd> class is shown in the following code:</p>
<pre><span>object </span>SchoolExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>school = <span>new </span>School<br/>    <span>// create students<br/></span><span>    </span><span>val </span>student1 = <span>Student</span>(<span>"Ivan"</span><span>, </span><span>26</span>)<br/>    <span>val </span>student2 = <span>Student</span>(<span>"Maria"</span><span>, </span><span>26</span>)<br/>    <span>val </span>student3 = <span>Student</span>(<span>"John"</span><span>, </span><span>25</span>)<br/>    <span>// create groups<br/></span><span>    </span><span>val </span>group1 = <span>Group</span>(<span>"Scala design patterns"</span>)<br/>    <span>val </span>group2 = <span>Group</span>(<span>"Databases"</span>)<br/>    <span>val </span>group3 = <span>Group</span>(<span>"Cloud computing"</span>)<br/>    school.addStudentToGroup(student1<span>, </span>group1)<br/>    school.addStudentToGroup(student1<span>, </span>group2)<br/>    school.addStudentToGroup(student1<span>, </span>group3)<br/>    school.addStudentToGroup(student2<span>, </span>group1)<br/>    school.addStudentToGroup(student2<span>, </span>group3)<br/>    school.addStudentToGroup(student3<span>, </span>group1)<br/>    school.addStudentToGroup(student3<span>, </span>group2)<br/>    <span>// notify<br/></span><span>    </span>school.notifyStudentsInGroup(group1<span>, </span><span>"Design patterns in Scala<br/>    are amazing!"</span>)<br/>    <span>// see groups<br/></span><span>    </span>System.<span>out</span>.println(<span>s"</span><span>$</span>student3<span> is in groups:<br/>     </span><span>$</span>{school.getGroupsForStudent(student3)}<span>"</span>)<br/>    <span>// remove from group<br/></span><span>    </span>school.removeStudentFromGroup(student3<span>, </span>group2)<br/>    System.<span>out</span>.println(<span>s"</span><span>$</span>student3<span> is in groups:<br/>     </span><span>$</span>{school.getGroupsForStudent(student3)}<span>"</span>)<br/>    <span>// see students in group<br/></span><span>    </span>System.<span>out</span>.println(<span>s"Students in </span><span>$</span>group1<span> are <br/></span><span>     $</span>{school.getStudentsInGroup(group1)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The preceding example application is really simple—it creates objects of the <kbd>Student</kbd> and <kbd>Group</kbd> types and uses the mediator object to wire them up and make it possible for them to interact. The output of the example is as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/901246e8-42dc-40cc-b003-72274b151a20.png" style="width:41.50em;height:12.58em;" width="735" height="222"/></div>
<p>As the output shows, our code does exactly what is expected, and it managed to keep the concepts loosely coupled in the application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The mediator design pattern is good for keeping coupling between classes loose in an application. It helps to achieve simplicity and maintainability, while still allowing us to model complex interactions between objects in our applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>A possible pitfall when using the mediator design pattern is to put a lot of different interaction functionalities in one class. Mediators tend to become more complex with time, and it will become hard to change or understand what our application can do at all. Moreover, if we actually have many more classes that have to interact with each other, it will imminently affect the mediator as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The memento design pattern</h1>
                </header>
            
            <article>
                
<p>Depending on the software we are writing, we might have a requirement to be able to restore the state of an object back to its previous state.</p>
<div class="packt_infobox">The purpose of the memento design pattern is to provide the ability to execute an undo action in order to restore an object to a previous state.</div>
<p>The original memento design pattern is implemented with the help of three main objects:</p>
<ul>
<li><kbd>Originator</kbd>: The object whose state we want to be able to restore</li>
<li><kbd>Caretaker</kbd>: The object that triggers the changes to the <kbd>originator</kbd> object and uses the <kbd>memento</kbd> objects for rollback, if needed</li>
<li><kbd>Memento</kbd>: The object that carries the actual state of the originator and can be used to restore to one of the previous states</li>
</ul>
<p>It is important to know that the <kbd>memento</kbd> object can be handled only by the originator. The caretaker and all other classes can just store it and nothing else.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>A classic example of the memento design pattern that comes to mind is text editors. We can always undo whatever we have changed. We will present something similar in our class diagram and example.</p>
<p>The following is the class diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/149ecc52-915e-4584-bbc3-aab6c184eafc.png" style="width:46.92em;height:20.00em;" width="1423" height="606"/></div>
<p>As you can see in the preceding diagram, our caretaker is the <strong>TextEditorManipulator</strong>. It automatically saves the state in the states stack on every manipulation. The <strong>TextEditor</strong> implements the <strong>Originator</strong> and creates a <kbd>memento</kbd> object and restores from one. Finally, the <strong>TextEditorMemento</strong> is the concrete <kbd>memento</kbd> object that our text editor will be using to save the state. Our state is just the current string representation of the text in the editor.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>In this subsection, we will go through the text editor code one step at a time and see how the memento design pattern could be implemented in Scala.</p>
<p>First of all, let's see the <kbd>Caretaker</kbd>, <kbd>Memento</kbd>, and <kbd>Originator</kbd> traits:</p>
<pre><span>trait </span>Memento[<span>T</span>] {<br/>  <span>protected val </span>state: <span>T<br/></span><span><br/></span><span>  </span><span>def </span><span>getState</span>(): <span>T </span>= state<br/>}<br/><br/><span>trait </span>Caretaker[<span>T</span>] {<br/>  <span>val </span><span>states</span>: mutable.Stack[Memento[<span>T</span>]] = mutable.Stack[Memento[<span>T</span>]]()<br/>}<br/><br/><span>trait </span>Originator[<span>T</span>] {<br/>  <span>def </span><span>createMemento</span>: Memento[<span>T</span>]<br/><br/>  <span>def </span><span>restore</span>(memento: Memento[<span>T</span>])<br/>}</pre>
<p>We have used generics, and this allows us to reuse those traits multiple times when we want to implement the memento design pattern. Now, let's take a look at the specific implementations of the traits that are necessary in our application:</p>
<pre><span>class </span>TextEditor <span>extends </span>Originator[<span>String</span>] {<br/>  <span>private var </span><span>builder</span>: <span>StringBuilder </span>= <span>new </span>StringBuilder<br/><br/>  <span>def </span><span>append</span>(text: <span>String</span>): <span>Unit </span>= {<br/>    <span>builder</span>.append(text)<br/>  }<br/><br/>  <span>def </span><span>delete</span>(): <span>Unit </span>= {<br/>    <span>if </span>(<span>builder</span>.nonEmpty) {<br/>      <span>builder</span>.deleteCharAt(<span>builder</span>.length - <span>1</span>)<br/>    }<br/>  }<br/><br/>  <span>override def </span><span>createMemento</span>: Memento[<span>String</span>] = <span>new </span>TextEditorMemento(<span>builder</span>.toString)<br/><br/>  <span>override def </span><span>restore</span>(memento: Memento[<span>String</span>]): <span>Unit </span>= {<br/>    <span>this</span>.<span>builder </span>= <span>new </span>StringBuilder(memento.getState())<br/>  }<br/><br/>  <span>def </span><span>text</span>(): <span>String </span>= <span>builder</span>.toString<br/><br/>  <span>private class </span>TextEditorMemento(<span>val </span>state: <span>String</span>) <span>extends </span>Memento[<span>String</span>]<br/>}</pre>
<p>The preceding code shows the actual <kbd>Originator</kbd> implementation as well as the <kbd>Memento</kbd> one. It is common to create the memento class as being private to the object, which will be creating and restoring from the class, and that's why we have done the same. The reason for this is that the originator should be the only one who knows how to create and restore from a <kbd>memento</kbd> object and how to read its state.</p>
<p>Finally, let's take a look at the <kbd>Caretaker</kbd> implementation:</p>
<pre><span>class </span>TextEditorManipulator <span>extends </span>Caretaker[<span>String</span>] {<br/>  <span>private val </span><span>textEditor </span>= <span>new </span>TextEditor<br/><br/>  <span>def </span><span>save</span>(): <span>Unit </span>= {<br/>    <span>states</span>.push(<span>textEditor</span>.createMemento)<br/>  }<br/><br/>  <span>def </span><span>undo</span>(): <span>Unit </span>= {<br/>    <span>if </span>(<span>states</span>.nonEmpty) {<br/>      <span>textEditor</span>.restore(<span>states</span>.pop())<br/>    }<br/>  }<br/><br/>  <span>def </span><span>append</span>(text: <span>String</span>): <span>Unit </span>= {<br/>    save()<br/>    <span>textEditor</span>.append(text)<br/>  }<br/><br/>  <span>def </span><span>delete</span>(): <span>Unit </span>= {<br/>    save()<br/>    <span>textEditor</span>.delete()<br/>  }<br/><br/>  <span>def </span><span>readText</span>(): <span>String </span>= <span>textEditor</span>.text()<br/>}</pre>
<p>In our implementation, the caretaker exposes methods to manipulate the <kbd>originator</kbd> object. Before every manipulation, we save the state to the stack in order to be able to rollback if needed at a future point.</p>
<p>Now that we've seen all the code for our example, let's see an application that uses it:</p>
<pre><span>object </span>TextEditorExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>textEditorManipulator = <span>new </span>TextEditorManipulator<br/>    textEditorManipulator.append(<span>"This is a chapter about memento."</span>)<br/>    System.<span>out</span>.println(<span>s"The text is:<br/>    '</span><span>$</span>{textEditorManipulator.readText()}<span>'"</span>)<br/>    <span>// delete 2 characters<br/></span><span>    </span>System.<span>out</span>.println(<span>"Deleting 2 characters..."</span>)<br/>    textEditorManipulator.delete()<br/>    textEditorManipulator.delete()<br/>    <span>// see the text<br/></span><span>    </span>System.<span>out</span>.println(<span>s"The text is:<br/>     '</span><span>$</span>{textEditorManipulator.readText()}<span>'"</span>)<br/>    <span>// undo<br/></span><span>    </span>System.<span>out</span>.println(<span>"Undoing..."</span>)<br/>    textEditorManipulator.undo()<br/>    System.<span>out</span>.println(<span>s"The text is:<br/>     '</span><span>$</span>{textEditorManipulator.readText()}<span>'"</span>)<br/>    <span>// undo again<br/></span><span>    </span>System.<span>out</span>.println(<span>"Undoing..."</span>)<br/>    textEditorManipulator.undo()<br/>    System.<span>out</span>.println(<span>s"The text is: <br/>     '</span><span>$</span>{textEditorManipulator.readText()}<span>'"</span>)<br/>  }<br/>}</pre>
<p>In the preceding code, we just manually added some text to our text editor, deleted some characters, and then did an undo of the deletions. The following screenshot shows the output of this example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6e153bbc-6ed5-4353-a2f8-c4d2bc73f28b.png" style="width:41.08em;height:10.58em;" width="735" height="189"/></div>
<p>One possible issue with our application design that might need improvement is the <kbd>states</kbd> stack—we have absolutely no limit and if a lot of changes are made, it could grow too much. In real text editors, we cannot go back infinitely, and this stack is limited to a certain number of operations. Another performance issue could be the fact that we call <kbd>toString</kbd> on the internal <kbd>StringBuilder</kbd> on each operation. Passing the actual <kbd>StringBuilder</kbd>, however, could have undesired effects on the application, as changes will affect all of the builder's references.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The memento design pattern is useful for applications that want to support a revertable state. In our example, we used a stack of states; however, this is not necessary—some applications might need only the last operation to be saved.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>Developers should be careful when they use the memento design pattern. They should try to have the state saved in value objects if possible because if a mutable type is passed, it would be changed by reference and this will lead to unwanted results. Developers should also be careful about how far back in time they allow changes to be undoable because the more operations are saved in the stack, the more memory will be required. Finally, Scala is immutable and the memento design pattern does not always coincide with the language philosophy.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The observer design pattern</h1>
                </header>
            
            <article>
                
<p>There are sometimes cases where some objects are interested in the state change of another object and want to perform some specific action when this happens. A common example could be whenever you click a button in an app; some other objects subscribe to the click event and perform some actions. The observer design pattern helps us to achieve this.</p>
<div class="packt_infobox">The purpose of the observer design pattern is to have an object (called <strong>subject</strong>) that automatically notifies all of its observers of any state change by calling one of their methods.</div>
<p>The observer design pattern is employed in most GUI toolkits. It is also part of the MVC architectural pattern where the view is an observer. Java even comes with the <kbd>Observable</kbd> class and the <kbd>Observer</kbd> interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>For the class diagram, let's focus on the following example—we have a website with posts, and people can subscribe to get notifications whenever a new comment is added. The following diagram shows how something like this could be represented using the observer design pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8a5ebb64-ca4e-4f47-91c7-c15754f0b16f.png" width="1489" height="491"/></div>
<p>The <strong>Post</strong> class is our observable, and it has observers of the <strong>User</strong> type that are notified whenever the post changes (in our case, when a comment is added).</p>
<p>Note that the preceding scenario is just an example. In reality, subscriptions can be done in a database and people will receive an email notification. However, if we are talking about some kind of notification while you are on the site, then this example is valid.</p>
<div class="packt_tip">The observer pattern in the example could and probably should be replaced with reactive programming in Scala using Akka and actors. This way, we could achieve much better scalability and implement a proper asynchronous publish-subscribe system.</div>
<p>In the following subsection, we will take a look at the code that represents the preceding diagram.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Now, let's go through all the code that represents the preceding diagram. First, let's see the <kbd>Observer</kbd> interface. We have decided to have it as a trait that can be mixed in any class:</p>
<pre><span>trait </span>Observer[<span>T</span>] {<br/>  <span>def </span><span>handleUpdate</span>(subject: <span>T</span>)<br/>}</pre>
<p>This is extremely simple. Next, we will take a look at the <kbd>Observable</kbd> class. It is a trait that can also be mixed in and can make classes observable:</p>
<pre><span>trait </span>Observable[<span>T</span>] {<br/>  <span>this</span>: <span>T </span>=&gt;<br/>  <span>private val </span><span>observers </span>= ListBuffer[Observer[<span>T</span>]]()<br/><br/>  <span>def </span><span>addObserver</span>(observer: Observer[<span>T</span>]): <span>Unit </span>= {<br/>    <span>observers</span>.+=:(observer)<br/>  }<br/><br/>  <span>def </span><span>notifyObservers</span>(): <span>Unit </span>= {<br/>    <span>observers</span>.foreach(_.handleUpdate(<span>this</span>))<br/>  }<br/>}</pre>
<p>In the preceding code, we have used a self-type in order to make sure that we limit how the <kbd>Observable</kbd> trait is mixed in. This makes sure that the parameterized type will be the same as that of the object we are mixing it into.</p>
<p>Our implementation of the <kbd>Observer</kbd> interface will be our <kbd>User</kbd> class. It has the following code:</p>
<pre><span>case class </span>User(name: <span>String</span>) <span>extends </span>Observer[Post] {<br/>  <span>override def </span><span>handleUpdate</span>(subject: Post): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"Hey, I'm </span><span>$</span>{name}<span>. The post got some new comments: </span><span>$</span>{subject.comments}<span>"</span>)<br/>  }<br/>}</pre>
<p>It is as simple as implementing one method and doing something with the changed <kbd>Post</kbd> subject.</p>
<p>The <kbd>Comment</kbd> class is just a simple model class that has nothing special about it:</p>
<pre><span>case class </span>Comment(user: User<span>, </span>text: <span>String</span>)</pre>
<p>The <kbd>Post</kbd> class will be <kbd>Observable</kbd>. On every comment that is added, this class will notify all the registered observers. The code is as follows:</p>
<pre><span>case class </span>Post(user: User<span>, </span>text: <span>String</span>) <span>extends </span>Observable[Post] {<br/>  <span>val </span><span>comments </span>= ListBuffer[Comment]()<br/><br/>  <span>def </span><span>addComment</span>(comment: Comment): <span>Unit </span>= {<br/>    <span>comments</span>.+=:(comment)<br/>    notifyObservers()<br/>  }<br/>}</pre>
<p>All the preceding code snippets implement our observer design pattern. It is interesting to see how this works in an example. The following block of code has an example of how our classes can be used together:</p>
<pre><span>object </span>PostExample <span>extends </span>LazyLogging {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>userIvan = <span>User</span>(<span>"Ivan"</span>)<br/>    <span>val </span>userMaria = <span>User</span>(<span>"Maria"</span>)<br/>    <span>val </span>userJohn = <span>User</span>(<span>"John"</span>)<br/>    logger.info(<span>"Create a post"</span>)<br/>    <span>val </span>post = <span>Post</span>(userIvan<span>, </span><span>"This is a post about the observer<br/>     design pattern"</span>)<br/>    logger.info(<span>"Add a comment"</span>)<br/>    post.addComment(<span>Comment</span>(userIvan<span>, </span><span>"I hope you like the post!"</span>))<br/>    logger.info(<span>"John and Maria subscribe to the comments."</span>)<br/>    post.addObserver(userJohn)<br/>    post.addObserver(userMaria)<br/>    logger.info(<span>"Add a comment"</span>)<br/>    post.addComment(<span>Comment</span>(userIvan<span>, </span><span>"Why are you so quiet? Do you<br/>     like it?"</span>))<br/>    logger.info(<span>"Add a comment"</span>)<br/>    post.addComment(<span>Comment</span>(userMaria<span>, </span><span>"It is amazing! Thanks!"</span>))<br/>  }<br/>}</pre>
<p>The output of our application is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8da265bf-706e-4497-9c27-6814a9f64a41.png" style="width:39.00em;height:20.25em;" width="739" height="384"/></div>
<p>As you can see in the preceding screenshot, the observer design pattern is quite easy to implement. As we mentioned earlier, a better approach would be to use reactive programming in order to make things asynchronous and more scalable. It will be more functional as well. We will see an example of how this can be done with Akka in the future chapters of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The observer design pattern is easy to implement and allows us to add new observers or remove old observers at runtime. It helps to decouple logic and communication, which makes for some good quality classes that have only one responsibility.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>In functional programming with Scala, one would possibly prefer using Akka and creating a publish-subscribe design instead. Moreover, in the observer design pattern, object references are held in the observer's collection of the subject, which could cause memory leaks or unnecessary allocations during the lifetime of the application or the subject object. Finally, as with any other design pattern, the observer design pattern should be used only where necessary. Otherwise, we might end up complicating our application for no good reason.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The state design pattern</h1>
                </header>
            
            <article>
                
<p>The state design pattern is really similar to the strategy design pattern that we looked at in the previous chapter.</p>
<div class="packt_infobox">The purpose of the state design pattern is to allow us to choose a different behavior of an object based on the object's internal state.</div>
<p>Basically, the difference between the state design pattern and the strategy design pattern comes from the following two points:</p>
<ul>
<li>The strategy design pattern is about <em>how</em> an action is performed. It is usually an algorithm that produces the same results as other algorithms.</li>
<li>The state design pattern is about <em>what</em> action is performed. Depending on the state, an object could be doing different things.</li>
</ul>
<p>Implementing the state design pattern also closely resembles the implementation of the strategy design pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>Imagine a media player. Most media players have a play button—when we activate it, it usually changes its appearance and becomes a pause button. Clicking the pause button now also does something different—it pauses the playback and reverts to a play button. This is a good candidate for the state design pattern, where depending on which state the player is in, a different action happens.</p>
<p>The following class diagram shows the classes that are needed to implement this functionality for the play and pause buttons:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d6e6c64d-73fd-4078-88fe-dd5b1a99e71d.png" width="1465" height="378"/></div>
<p>Our <strong>Playing</strong> and <strong>Paused</strong> implementations set the state to the opposite one and make our player functional. Using the state design pattern also makes our code much more elegant—we could, of course, use if statements and depending on the value, perform different actions. However, it could easily get out of control when there are many states.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Let's have a look at the code for the class diagram that we showed previously. First of all, let's see the <kbd>State</kbd> trait:</p>
<pre><span>trait </span>State[<span>T</span>] {<br/>  <span>def </span><span>press</span>(context: <span>T</span>)<br/>}</pre>
<p>It is really simple and allows the extending classes to implement the <kbd>press</kbd> method. We have two implementations according to our class diagram:</p>
<pre><span>class </span>Playing <span>extends </span>State[MediaPlayer] {<br/>  <span>override def </span><span>press</span>(context: MediaPlayer): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>"Pressing pause."</span>)<br/>    context.setState(<span>new </span>Paused)<br/>  }<br/>}<br/><br/><span>class </span>Paused <span>extends </span>State[MediaPlayer] {<br/>  <span>override def </span><span>press</span>(context: MediaPlayer): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>"Pressing play."</span>)<br/>    context.setState(<span>new </span>Playing)<br/>  }<br/>}</pre>
<p>We have made them simple and they only print a relevant message and then change the current state to the opposite state.</p>
<p>Our model defines a <kbd>MediaPlayer</kbd> class, which looks as follows:</p>
<pre><span>case class </span>MediaPlayer() {<br/>  <span>private var </span><span>state</span>: State[MediaPlayer] = <span>new </span>Paused<br/><br/>  <span>def </span><span>pressPlayOrPauseButton</span>(): <span>Unit </span>= {<br/>    <span>state</span>.press(<span>this</span>)<br/>  }<br/><br/></pre>
<pre>  <span>def </span><span>setState</span>(state: State[MediaPlayer]): <span>Unit </span>= {<br/>    <span>this</span>.<span>state </span>= state<br/>  }<br/>}</pre>
<p>This really is everything we need. Now, we can use our media player in the following application:</p>
<pre><span>object </span>MediaPlayerExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>player = <span>MediaPlayer</span>()<br/>    player.pressPlayOrPauseButton()<br/>    player.pressPlayOrPauseButton()<br/>    player.pressPlayOrPauseButton()<br/>    player.pressPlayOrPauseButton()<br/>  }<br/>}</pre>
<p>If we run the preceding code, we will see the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a14359fd-0bc3-4a61-b240-a059bb6e8acd.png" width="732" height="130"/></div>
<p>As you can see in the example output, the state changes on every button press and it performs a different action, which we've illustrated using a different print message.</p>
<p>A possible improvement to our application would involve making the state objects singletons. As you can see, they are always the same, so there really is no need to create new ones every single time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The state design pattern is really useful for making code readable and getting rid of conditional statements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>The state design pattern has no major drawbacks. One thing that developers should be careful about is the side effects caused by the change of the state of objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The template method design pattern</h1>
                </header>
            
            <article>
                
<p>Sometimes when we implement some algorithm or a family of algorithms, we define a common skeleton. Then later, the different implementations deal with the specifics of each method in the skeleton. The template method design pattern allows us to achieve what we mentioned previously.</p>
<div class="packt_infobox">The purpose of the template method design pattern is to defer algorithm steps to subclasses using template methods.</div>
<p>The template method design pattern seems really natural to object-oriented programming. Whenever polymorphism is used, this actually represents the design pattern itself. Usually, the template method is implemented using abstract methods.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>The template method design pattern is suitable for implementing frameworks. A typical thing here is that algorithms usually perform the same set of steps, and then these steps are implemented differently by different clients. You can come up with various possible use cases.</p>
<p>For our example, let's imagine that we want to write an application that will read some data from a data source, parse it, and find whether there is an object that satisfies some condition and returns it. If we think about it, we have the following main operations:</p>
<ul>
<li>Read the data</li>
<li>Parse the data</li>
<li>Search for items satisfying the condition</li>
<li>Clean up any resources if needed</li>
</ul>
<p>The following diagram shows the class diagram of our code:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8daa82f0-913c-41f8-b80f-4de4a9c2e8a4.png" width="1620" height="515"/></div>
<p>We have used an example that we've shown before—reading data about people from files. Here, however, we use it in order to find data of the person that satisfies a filtering function. Using the template method design pattern, we can have the list of the people read from files with different formats from a server, database, or anything that comes to mind, really. Using polymorphism, our application makes sure that the right methods are called and everything works correctly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Let's go through the code that represents the preceding diagram and take a look at what it does. First of all, our model <kbd>Person</kbd> class:</p>
<pre><span>case class </span>Person(name: <span>String</span><span>, </span>age: <span>Int, </span>address: <span>String</span>)</pre>
<p>There is nothing special about it. Now, let's move on to the interesting part—the <kbd>DataFinder</kbd> class:</p>
<pre><span>abstract class </span>DataFinder[<span>T</span><span>, </span><span>Y</span>] {<br/>  <span>def </span><span>find</span>(f: <span>T </span>=&gt; Option[<span>Y</span>]): Option[<span>Y</span>] =<br/>    <span>try </span>{<br/>      <span>val </span>data = readData()<br/>      <span>val </span>parsed = parse(data)<br/>      f(parsed)<br/>    } <span>finally </span>{<br/>      cleanup()<br/>    }<br/><br/>  <span>def </span><span>readData</span>(): Array[<span>Byte</span>]<br/><br/>  <span>def </span><span>parse</span>(data: Array[<span>Byte</span>]): <span>T<br/></span><span><br/></span><span>  </span><span>def </span><span>cleanup</span>()<br/>}</pre>
<p>We have used generics in order to make this class usable for various types. As you can see in the preceding code, three of the methods of the <kbd>DataFinder</kbd> class have no implementations, but they are still referred to in the <kbd>find</kbd> method. The latter is the actual template method, and the abstract methods will be implemented in the different classes that extend the <kbd>DataFinder</kbd>.</p>
<p>For our example, we have provided two different implementations, one for JSON and one for the CSV files. The JSON finder looks as follows:</p>
<pre><span>import org.json4s.{StringInput, DefaultFormats}<br/>import org.json4s.jackson.JsonMethods<br/><br/>class </span>JsonDataFinder <span>extends </span>DataFinder[<span>List</span>[Person]<span>, </span>Person] {<br/>  <span>implicit val </span><span>formats </span>= DefaultFormats<br/><br/>  <span>override def </span><span>readData</span>(): Array[<span>Byte</span>] = {<br/>    <span>val </span>stream = <span>this</span>.getClass.getResourceAsStream(<span>"people.json"</span>)<br/>    <span>Stream</span>.<span>continually</span>(stream.read).takeWhile(_ != -<span>1</span>).map(_.toByte).toArray<br/>  }<br/><br/>  <span>override def </span><span>cleanup</span>(): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>"Reading json: nothing to do."</span>)<br/>  }<br/><br/>  <span>override def </span><span>parse</span>(data: Array[<span>Byte</span>]): <span>List</span>[Person] =<br/>    JsonMethods.parse(StringInput(<span>new </span>String(data<span>, </span><span>"UTF-8"</span>))).extract[<span>List</span>[Person]]<br/>}</pre>
<p>The CSV finder has the following code:</p>
<pre><span>import com.github.tototoshi.csv.CSVReader<br/><br/>class </span>CSVDataFinder <span>extends </span>DataFinder[<span>List</span>[Person]<span>, </span>Person] {<br/>  <span>override def </span><span>readData</span>(): Array[<span>Byte</span>] = {<br/>    <span>val </span>stream = <span>this</span>.getClass.getResourceAsStream(<span>"people.csv"</span>)<br/>    <span>Stream</span>.<span>continually</span>(stream.read).takeWhile(_ != -<span>1</span>).map(_.toByte).toArray<br/>  }<br/><br/>  <span>override def </span><span>cleanup</span>(): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>"Reading csv: nothing to do."</span>)<br/>  }<br/><br/>  <span>override def </span><span>parse</span>(data: Array[<span>Byte</span>]): <span>List</span>[Person] =<br/>    CSVReader.open(<span>new </span>InputStreamReader(<span>new </span>ByteArrayInputStream(data))).all().map {<br/>      <span>case </span>List(name<span>, </span>age<span>, </span>address) =&gt; Person(name<span>, </span>age.toInt<span>, </span>address)<br/>    }<br/>}</pre>
<p>Whenever we use it, depending on what specific instance we have, the <kbd>find</kbd> method will call the right implementations through polymorphism. It is possible to add new formats and data sources by extending the <kbd>DataFinder</kbd> class.</p>
<p>Using our data finders is now straightforward:</p>
<pre><span>object </span>DataFinderExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>jsonDataFinder: DataFinder[<span>List</span>[Person]<span>, </span>Person] = <span>new </span>JsonDataFinder<br/>    <span>val </span>csvDataFinder: DataFinder[<span>List</span>[Person]<span>, </span>Person] = <span>new </span>CSVDataFinder<br/>    System.<span>out</span>.println(<span>s"Find a person with name Ivan in the json:<br/>     </span><span>$</span>{jsonDataFinder.find(_.find(_.name == <span>"Ivan"</span>))}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Find a person with name James in the json:<br/>     </span><span>$</span>{jsonDataFinder.find(_.find(_.name == <span>"James"</span>))}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Find a person with name Maria in the csv:<br/>     </span><span>$</span>{csvDataFinder.find(_.find(_.name == <span>"Maria"</span>))}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Find a person with name Alice in the csv:<br/>     </span><span>$</span>{csvDataFinder.find(_.find(_.name == <span>"Alice"</span>))}<span>"</span>)<br/>  }<br/>}</pre>
<p>We have provided some example data files. The CSV has the following contents:</p>
<pre>Ivan,26,London<br/>Maria,23,Edinburgh<br/>John,36,New York<br/>Anna,24,Moscow</pre>
<p>The following data is for the JSON file:</p>
<pre>[<br/>  {<br/>    "name": "Ivan",<br/>    "age": 26,<br/>    "address": "London"<br/>  },<br/>  {<br/>    "name": "Maria",<br/>    "age": 23,<br/>    "address": "Edinburgh"<br/>  },<br/>  {<br/>    "name": "John",<br/>    "age": 36,<br/>    "address": "New York"<br/>  },<br/>  {<br/>    "name": "Anna",<br/>    "age": 24,<br/>    "address": "Moscow"<br/>  }<br/>]</pre>
<p>Running the preceding example against these datasets will produce the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b306141c-93fd-4717-8962-23606b69910f.png" width="737" height="217"/></div>
<p>The code in our example uses an abstract class. This makes it slightly limiting in the sense that we can only extend one class. However, it would be straightforward to change the abstract class to a trait and then mix it into classes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>As you can see, whenever we have a use case where the structure of an algorithm is the same and we provide different implementations, we can use the template method design pattern. This is a really good fit for creating frameworks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>Whenever the frameworks we implement using the template method design pattern become large, it is harder to simply extend a huge class and implement a few of its methods. In cases like these, passing an interface to the constructor and using it in the skeleton might be a better idea (strategy design pattern).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The visitor design pattern</h1>
                </header>
            
            <article>
                
<p>There are some applications out there where during design time, not all possible use cases are known. There might be new application features coming out from time to time, and in order to implement them, some refactoring has to be done.</p>
<div class="packt_infobox">The visitor design pattern helps us add new operations to existing object structures without modifying them.</div>
<p>This helps us to design our structures separately and then use the visitor design pattern to add functionality on top.</p>
<p>Another case where the visitor design pattern could be useful is if we are building a big object structure with many different types of nodes that support different operations. Instead of creating a base node that has all the operations and only a few of them are implemented by the concrete nodes or use type casting, we could create visitors that will add the functionality we need where we need it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Example class diagram</h1>
                </header>
            
            <article>
                
<p>Initially, when a developer sees the visitor design pattern, it seems that it can be easily replaced using polymorphism and can rely on the dynamic types of the classes. However, what if we have a huge type hierarchy? In such a case, every single change will have to change an interface as well, which will lead to changing a whole bunch of classes, and so on.</p>
<p>For our class diagram and example, let's imagine that we are writing a text editor and we have documents. We want to be able to save each document in at least two data formats, but new ones could come. The following diagram shows the class diagram for our application that uses the visitor design pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d50c3004-14aa-4773-913b-260d42cede9b.png" width="1999" height="593"/></div>
<p>As you can see in the preceding diagram, we have two seemingly disconnected hierarchies. The one to the left represents our document—each document is simply a list of different elements. All of them subclass the <strong>Element</strong> abstract class, which has an <kbd>accept</kbd> method that accepts a <strong>Visitor</strong>. To the right, we have the visitor hierarchy—each of our visitors will mix in the <kbd>Visitor</kbd> trait, which contains the <kbd>visit</kbd> methods with overrides for each of our document elements.</p>
<p>The way the visitor pattern will work is that it will create an instance of <kbd>Visitor</kbd> depending on what needs to be done, and then it will be passed to the <kbd>Document accept</kbd> method. This way, we can add extra functionality really easily (different formats, in our case), and the extra functionality will not involve any changes to the model.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Let's take a step-by-step look at the code that implements the visitor design pattern for the previous example. First of all, we have our model of the document and all the elements that can build it:</p>
<pre><span>abstract class </span>Element(<span>val </span>text: <span>String</span>) {<br/>  <span>def </span><span>accept</span>(visitor: Visitor)<br/>}<br/><br/><span>class </span>Title(text: <span>String</span>) <span>extends </span>Element(text) {<br/>  <span>override def </span><span>accept</span>(visitor: Visitor): <span>Unit </span>= {<br/>    visitor.visit(<span>this</span>)<br/>  }<br/>}<br/><br/><span>class </span>Text(text: <span>String</span>) <span>extends </span>Element(text) {<br/>  <span>override def </span><span>accept</span>(visitor: Visitor): <span>Unit </span>= {<br/>    visitor.visit(<span>this</span>)<br/>  }<br/>}<br/><br/><span>class </span>Hyperlink(text: <span>String</span><span>, </span><span>val </span>url: <span>String</span>) <span>extends</span><span> </span>Element(text) {<br/>  <span>override def </span><span>accept</span>(visitor: Visitor): <span>Unit </span>= {<br/>    visitor.visit(<span>this</span>)<br/>  }<br/>}<br/><br/><span>class </span>Document(parts: <span>List</span>[Element]) {<br/>  <span>def </span><span>accept</span>(visitor: Visitor): <span>Unit </span>= {<br/>    parts.foreach(p =&gt; p.accept(visitor))<br/>  }<br/>}</pre>
<p>There is nothing special about the preceding code, just a simple subclassing for the different document elements and a composition for the <kbd>Document</kbd> class and the elements it contains. The important method here is <kbd>accept</kbd>. It takes a visitor, and since the trait type is given, we can pass different visitor implementations. In all the cases, it calls the <kbd>visit</kbd> method of the visitor with the current instance passed as a parameter.</p>
<p>Now, let's have a look on the other side—the <kbd>Visitor</kbd> trait and its implementations. The <kbd>Visitor</kbd> trait looks as simple as this:</p>
<pre><span>trait </span>Visitor {<br/>  <span>def </span><span>visit</span>(title: Title)<br/>  <span>def </span><span>visit</span>(text: Text)<br/>  <span>def </span><span>visit</span>(hyperlink: Hyperlink)<br/>}</pre>
<p>In this case, it has overloads of the visit method with different concrete element types. In the preceding code, the visitors and elements allow us to use <strong>double dispatch</strong> in order to determine which calls will be made.</p>
<p>Now, let's have a look at the concrete <kbd>Visitor</kbd> implementations. The first one is the <kbd>HtmlExporterVisitor</kbd>:</p>
<pre><span>class </span>HtmlExporterVisitor <span>extends </span>Visitor {<br/>  <span>val </span><span>line </span>= System.<span>getProperty</span>(<span>"line.separator"</span>)<br/>  <span>val </span><span>builder </span>= <span>new </span>StringBuilder<br/><br/>  <span>def </span><span>getHtml</span>(): <span>String </span>= <span>builder</span>.toString<br/><br/>  <span>override def </span><span>visit</span>(title: Title): <span>Unit </span>= {<br/>    <span>builder</span>.append(<span>s"&lt;h1&gt;</span><span>$</span>{title.text}<span>&lt;/h1&gt;"</span>).append(<span>line</span>)<br/>  }<br/><br/>  <span>override def </span><span>visit</span>(text: Text): <span>Unit </span>= {<br/>    <span>builder</span>.append(<span>s"&lt;p&gt;</span><span>$</span>{text.text}<span>&lt;/p&gt;"</span>).append(<span>line</span>)<br/>  }<br/><br/>  <span>override def </span><span>visit</span>(hyperlink: Hyperlink): <span>Unit </span>= {<br/>    <span>builder</span>.append(<span>s"""&lt;a href=\"</span><span>$</span>{hyperlink.url}<span>\"&gt;</span><span>$</span>{hyperlink.text}<span>&lt;/a&gt;"""</span>).append(<span>line</span>)<br/>  }<br/>}</pre>
<p>It simply provides different implementations depending on what type of <kbd>Element</kbd> it gets. There are no conditional statements, just overloads.</p>
<p>If we want to save the document we have in plain text, we can use the <kbd>PlainTextExporterVisitor</kbd>:</p>
<pre><span>class </span>PlainTextExporterVisitor <span>extends </span>Visitor {<br/>  <span>val </span><span>line </span>= System.<span>getProperty</span>(<span>"line.separator"</span>)<br/>  <span>val </span><span>builder </span>= <span>new </span>StringBuilder<br/><br/>  <span>def </span><span>getText</span>(): <span>String </span>= <span>builder</span>.toString<br/><br/>  <span>override def </span><span>visit</span>(title: Title): <span>Unit </span>= {<br/>    <span>builder</span>.append(title.text).append(<span>line</span>)<br/>  }<br/><br/>  <span>override def </span><span>visit</span>(text: Text): <span>Unit </span>= {<br/>    <span>builder</span>.append(text.text).append(<span>line</span>)<br/>  }<br/><br/>  <span>override def </span><span>visit</span>(hyperlink: Hyperlink): <span>Unit </span>= {<br/>    <span>builder</span>.append(<span>s"</span><span>$</span>{hyperlink.text}<span> (</span><span>$</span>{hyperlink.url}<span>)"</span>).append(<span>line</span>)<br/>  }<br/>}</pre>
<p>After having the visitors and the document structure, wiring everything up is pretty straightforward:</p>
<pre><span>object </span>VisitorExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>document = <span>new </span>Document(<br/>      <span>List</span>(<br/>        <span>new </span>Title(<span>"The Visitor Pattern Example"</span>)<span>,<br/></span><span>        </span><span>new </span>Text(<span>"The visitor pattern helps us add extra functionality<br/>         without changing the classes."</span>)<span>,<br/></span><span>        </span><span>new </span>Hyperlink(<span>"Go check it online!"</span><span>, </span><span>"https://www.google.com/"</span>)<span>,<br/></span><span>        </span><span>new </span>Text(<span>"Thanks!"</span>)<br/>      )<br/>    )<br/>    <span>val </span>htmlExporter = <span>new </span>HtmlExporterVisitor<br/>    <span>val </span>plainTextExporter = <span>new </span>PlainTextExporterVisitor<br/>    System.<span>out</span>.println(<span>s"Export to html:"</span>)<br/>    document.accept(htmlExporter)<br/>    System.<span>out</span>.println(htmlExporter.getHtml())<br/>    System.<span>out</span>.println(<span>s"Export to plain:"</span>)<br/>    document.accept(plainTextExporter)<br/>    System.<span>out</span>.println(plainTextExporter.getText())<br/>  }<br/>}</pre>
<p>The preceding example shows how to use both the visitors we implemented. The output of our program is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/8869ffc0-c488-49cd-90c5-aba15deaeb2e.png" style="width:41.25em;height:16.92em;" width="745" height="306"/></div>
<p>As you can see, using the visitor is simple. Adding new visitors and new formats in our case is even easier. We just need to create a class that implements all the visitor methods and use it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The visitor design pattern the Scala way</h1>
                </header>
            
            <article>
                
<p>As with many other design patterns we saw earlier, the visitor design pattern could be represented in a way that is less verbose and closer to Scala. The way things can be done in order to implement a visitor in Scala is the same as the strategy design pattern—pass functions to the <kbd>accept</kbd> method. Moreover, we can also use pattern matching instead of having multiple different <kbd>visit</kbd> methods in the <kbd>Visitor</kbd> trait.</p>
<p>In this subsection, we will show both the improvement steps. Let's start with the latter.</p>
<p>First of all, we need to make the model classes case classes in order to be able to use them in pattern matching:</p>
<pre><span>abstract class </span>Element(text: <span>String</span>) {<br/>  <span>def </span><span>accept</span>(visitor: Visitor)<br/>}<br/><br/><span>case class </span>Title(text: <span>String</span>) <span>extends </span>Element(text) {<br/>  <span>override def </span><span>accept</span>(visitor: Visitor): <span>Unit </span>= {<br/>    visitor.visit(<span>this</span>)<br/>  }<br/>}<br/><br/><span>case class </span>Text(text: <span>String</span>) <span>extends </span>Element(text) {<br/>  <span>override def </span><span>accept</span>(visitor: Visitor): <span>Unit </span>= {<br/>    visitor.visit(<span>this</span>)<br/>  }<br/>}<br/><br/><span>case class </span>Hyperlink(text: <span>String</span><span>, </span><span>val </span>url: <span>String</span>) <span>extends </span>Element(text) {<br/>  <span>override def </span><span>accept</span>(visitor: Visitor): <span>Unit </span>= {<br/>    visitor.visit(<span>this</span>)<br/>  }<br/>}<br/><br/><span>class </span>Document(parts: <span>List</span>[Element]) {<br/>  <span>def </span><span>accept</span>(visitor: Visitor): <span>Unit </span>= {<br/>    parts.foreach(p =&gt; p.accept(visitor))<br/>  }<br/>}</pre>
<p>Then, we change our <kbd>Visitor</kbd> trait to the following:</p>
<pre><span>trait </span>Visitor {<br/>  <span>def </span><span>visit</span>(element: Element)<br/>}</pre>
<p>Since we will be using pattern matching, we will only need one method to implement it. Finally, we can have our visitor implementations as follows:</p>
<pre><span>class </span>HtmlExporterVisitor <span>extends </span>Visitor {<br/>  <span>val </span><span>line </span>= System.<span>getProperty</span>(<span>"line.separator"</span>)<br/>  <span>val </span><span>builder </span>= <span>new </span>StringBuilder<br/><br/>  <span>def </span><span>getHtml</span>(): <span>String </span>= <span>builder</span>.toString<br/><br/>  <span>override def </span><span>visit</span>(element: Element): <span>Unit </span>= {<br/>    element <span>match </span>{<br/>      <span>case </span><span>Title</span>(text) =&gt;<br/>        <span>builder</span>.append(<span>s"&lt;h1&gt;</span><span>$</span>{text}<span>&lt;/h1&gt;"</span>).append(<span>line</span>)<br/>      <span>case </span><span>Text</span>(text) =&gt;<br/>        <span>builder</span>.append(<span>s"&lt;p&gt;</span><span>$</span>{text}<span>&lt;/p&gt;"</span>).append(<span>line</span>)<br/>      <span>case </span><span>Hyperlink</span>(text<span>, </span>url) =&gt;<br/>        <span>builder</span>.append(<span>s"""&lt;a href=\"</span><span>$</span>{url}<span>\"&gt;</span><span>$</span>{text}<span>&lt;/a&gt;"""</span>).append(<span>line</span>)<br/>    }<br/>  }<br/>}<br/><br/><span>class </span>PlainTextExporterVisitor <span>extends </span>Visitor {<br/>  <span>val </span><span>line </span>= System.<span>getProperty</span>(<span>"line.separator"</span>)<br/>  <span>val </span><span>builder </span>= <span>new </span>StringBuilder<br/><br/>  <span>def </span><span>getText</span>(): <span>String </span>= <span>builder</span>.toString<br/><br/>  <span>override def </span><span>visit</span>(element: Element): <span>Unit </span>= {<br/>    element <span>match </span>{<br/>      <span>case </span><span>Title</span>(text) =&gt;<br/>        <span>builder</span>.append(text).append(<span>line</span>)<br/>      <span>case </span><span>Text</span>(text) =&gt;<br/>        <span>builder</span>.append(text).append(<span>line</span>)<br/>      <span>case </span><span>Hyperlink</span>(text<span>, </span>url) =&gt;<br/>        <span>builder</span>.append(<span>s"</span><span>$</span>{text}<span> (</span><span>$</span>{url}<span>)"</span>).append(<span>line</span>)<br/>    }<br/>  }<br/>}</pre>
<p>Pattern matching is similar to the <kbd>instanceOf</kbd> checks in Java; however, it is a powerful feature of Scala and it is quite commonly used. Our example, then, doesn't need to change at all and the output will be the same as before.</p>
<p>Next, we will show how we can pass functions instead of visitor objects. The fact that we will be passing functions means that now, we can change our model to the following:</p>
<pre><span>abstract class </span>Element(text: <span>String</span>) {<br/>  <span>def </span><span>accept</span>(visitor: Element =&gt; <span>Unit</span>): <span>Unit </span>= {<br/>    visitor(<span>this</span>)<br/>  }<br/>}<br/><br/><span>case class </span>Title(text: <span>String</span>) <span>extends </span>Element(text)<br/><br/><span>case class </span>Text(text: <span>String</span>) <span>extends </span>Element(text)<br/><br/><span>case class </span>Hyperlink(text: <span>String</span><span>, </span><span>val </span>url: <span>String</span>) <span>extends </span>Element(text)<br/><br/><span>class </span>Document(parts: <span>List</span>[Element]) {<br/>  <span>def </span><span>accept</span>(visitor: Element =&gt; <span>Unit</span>): <span>Unit </span>= {<br/>    parts.foreach(p =&gt; p.accept(visitor))<br/>  }<br/>}</pre>
<p>We moved the <kbd>accept</kbd> method implementation to the base <kbd>Element</kbd> class (which can also be represented as a trait) and inside this, we simply called the function passed as parameter. Since we will be passing functions, we can get rid of the <kbd>Visitor</kbd> trait and its implementations. Everything we have now is the example, which looks as follows:</p>
<pre><span>object </span>VisitorExample {<br/>  <span>val </span><span>line </span>= System.<span>getProperty</span>(<span>"line.separator"</span>)<br/><br/>  <span>def </span><span>htmlExporterVisitor</span>(builder: <span>StringBuilder</span>): Element =&gt; <span>Unit </span>= {<br/>      <span>case </span><span>Title</span>(text) =&gt;<br/>        builder.append(<span>s"&lt;h1&gt;</span><span>$</span>{text}<span>&lt;/h1&gt;"</span>).append(<span>line</span>)<br/>      <span>case </span><span>Text</span>(text) =&gt;<br/>        builder.append(<span>s"&lt;p&gt;</span><span>$</span>{text}<span>&lt;/p&gt;"</span>).append(<span>line</span>)<br/>      <span>case </span><span>Hyperlink</span>(text<span>, </span>url) =&gt; builder.append(<span>s"""&lt;a href=\"</span><span>$</span>{url}<span>\"&gt;</span><span>$</span>{text}<span>&lt;/a&gt;"""</span>).append(<span>line</span>)<br/>    }<br/><br/>  <span>def </span><span>plainTextExporterVisitor</span>(builder: <span>StringBuilder</span>): Element =&gt; <span>Unit </span>= {<br/>      <span>case </span><span>Title</span>(text) =&gt; builder.append(text).append(<span>line</span>)<br/>      <span>case </span><span>Text</span>(text) =&gt; builder.append(text).append(<span>line</span>)<br/>      <span>case </span><span>Hyperlink</span>(text<span>, </span>url) =&gt; builder.append(<span>s"</span><span>$</span>{text}<span> (</span><span>$</span>{url}<span>)"</span>).append(<span>line</span>)<br/>    }<br/><br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>document = <span>new </span>Document(<br/>      <span>List</span>(<br/>        <span>Title</span>(<span>"The Visitor Pattern Example"</span>)<span>,<br/></span><span>        </span><span>Text</span>(<span>"The visitor pattern helps us add extra functionality<br/>         without changing the classes."</span>)<span>,<br/></span><span>        </span><span>Hyperlink</span>(<span>"Go check it online!"</span><span>, </span><span>"https://www.google.com/"</span>)<span>,<br/></span><span>        </span><span>Text</span>(<span>"Thanks!"</span>)<br/>      )<br/>    )<br/>    <span>val </span>html = <span>new </span>StringBuilder<br/>    System.<span>out</span>.println(<span>s"Export to html:"</span>)<br/>    document.accept(<span>htmlExporterVisitor</span>(html))<br/>    System.<span>out</span>.println(html.toString())<br/>    <span>val </span>plain = <span>new </span>StringBuilder<br/>    System.<span>out</span>.println(<span>s"Export to plain:"</span>)<br/>    document.accept(<span>plainTextExporterVisitor</span>(plain))<br/>    System.<span>out</span>.println(plain.toString())<br/>  }<br/>}</pre>
<p>We have moved the visitor functionality inside the functions that are part of the <kbd>VisitorExample</kbd> object. In the initial examples, we had a <kbd>StringBuilder</kbd> as part of the visitor classes. We have used curried functions in order to be able to pass one here. Passing these functions to the <kbd>Document</kbd> structure is then straightforward. Again, the result here will be identical to the previous versions of the example. However, we can see how much code and boilerplate classes we have saved.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for</h1>
                </header>
            
            <article>
                
<p>The visitor design pattern is really good for applications that have large object hierarchies, where adding a new functionality will involve a lot of refactoring. Whenever we need to be able to do multiple different things with an object hierarchy and when changing the object classes could be problematic, the visitor design pattern is a useful alternative.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for</h1>
                </header>
            
            <article>
                
<p>As you saw in the initial version of our example, the visitor design pattern could be bulky and include quite a lot of boilerplate code. Moreover, if some component is not designed to support the pattern, we cannot really use it if we are not allowed to change the original code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we went through the second group of behavioral design patterns. You are now familiar with iterators, mediators, memento, observer, state, template method, and the visitor design pattern. You might feel that these are purely object-oriented design patterns that don't have much to do with functional programming, and you would be correct. However, they are still relevant to Scala due to its hybrid nature and it is important to be aware of them and to know when to use them.</p>
<p>Some of the design patterns in this chapter are quite commonly used and can be seen in many projects, while others are a bit more rare and specific to some use cases. These patterns, combined with all the other ones you learned about in the previous chapters, can be used together in order to build elegant and powerful solutions to real-world problems.</p>
<p>In the next chapter, we will dive deep into functional programming theory. We will cover some advanced concepts that will show us how powerful Scala and functional programming languages in general are.</p>


            </article>

            
        </section>
    </div>



  </body></html>