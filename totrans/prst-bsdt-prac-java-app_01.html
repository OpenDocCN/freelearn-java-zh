<html><head></head><body>
		<div id="_idContainer014">
			<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>The History of Data Storage – From the Caves to the Cloud</h1>
			<p>Data: a critical, life-changing, and fundamental asset that supports humanity’s existence and evolution. For thousands of years (yes, thousands!), data storage solutions have evolved and supported humans by allowing us to “remember” and share knowledge in easy, maintainable, and searchable manners. Data turns into information, which in turn turns into knowledge. The ability to learn from the past and plan for the future is highly influenced by how we manage data in our <span class="No-Break">systems today.</span></p>
			<p>Software engineers are the catalysts of this process: our responsibility is to define and deliver solutions to people’s problems through software engineering – solutions that mostly revolve around data manipulation at a large or small scale. Having understood the importance of persistence in software engineering, you’re ready to bring your solutions’ persistence to the <span class="No-Break">next level.</span></p>
			<p>In this chapter, we will explore the modern era, where databases have become the backbone of our applications and the entire planet. We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Why do databases exist? The history <span class="No-Break">of databases</span></li>
				<li>Characteristics of Java <span class="No-Break">persistence frameworks</span></li>
				<li>The cloud’s effect on <span class="No-Break">stateful solutions</span></li>
				<li>Exploring the trade-offs of distributed database systems – a look into the CAP theorem <span class="No-Break">and beyond</span></li>
			</ul>
			<p>This first chapter provides you with an understanding of the past and current states of data storage technologies, before moving on to more advanced topics. This will give you a better foundation to work from. You will learn how data storage technologies responded to the market’s cloud-shift mentality. Finally, you will become familiar with practices such as <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>), which perfectly ties in with good persistence development practices, and the challenges faced by distributed data systems that await us in a distributed world, such as the <span class="No-Break">CAP theorem.</span></p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Why do databases exist?</h1>
			<p>A comprehensive understanding of databases is impossible without delving into humanity’s history. The desire to preserve knowledge throughout time has made writing one of the <a id="_idIndexMarker000"/>most enduring technologies, and looking back, it was first used in temples and caves, which can be recognized as the first non-computational databases <span class="No-Break">of humankind.</span></p>
			<p>Today, the industry emphasizes accurate and well-recorded information. As a matter of fact, the result of an increasing number of people gaining access to technology and joining the global network of information is reflected in research that states that the amount of data doubles every <span class="No-Break">two years.</span></p>
			<p>The history of <a id="_idIndexMarker001"/>modern databases began in 1960, when Charles Bachman <a id="_idIndexMarker002"/>designed the first database for computers, the <strong class="bold">integrated data store</strong>, or <strong class="bold">IDS</strong>, a predecessor to IBM’s <strong class="bold">Information Management </strong><span class="No-Break"><strong class="bold">System</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IMS</strong></span><span class="No-Break">).</span></p>
			<p>A decade after that, around 1970,  one of the most significant events in the history of databases occurred when E. F. Codd published his paper <em class="italic">A Relational Model of Data for Large Shared Data Banks</em>, coining <a id="_idIndexMarker003"/>the term <span class="No-Break"><strong class="bold">relational database</strong></span><span class="No-Break">.</span></p>
			<p>Finally, as the next and probably most recent breakthrough in terms of data storage, came NoSQL, which <a id="_idIndexMarker004"/>refers to any non-relational database. Some say <strong class="bold">NoSQL</strong> stands for <em class="italic">Non-SQL</em>, while others say it stands for <em class="italic">Not </em><span class="No-Break"><em class="italic">Only SQL</em></span><span class="No-Break">.</span></p>
			<p>NoSQL databases power some of the most popular online applications. Here are <span class="No-Break">a few:</span></p>
			<ul>
				<li><strong class="bold">Google</strong>: Google uses NoSQL <a id="_idIndexMarker005"/>Bigtable for Google Mail, Google Maps, Google Earth, <a id="_idIndexMarker006"/>and <span class="No-Break">Google Finance</span></li>
				<li><strong class="bold">Netflix</strong>: Netflix likes the high <a id="_idIndexMarker007"/>availability of the NoSQL database <a id="_idIndexMarker008"/>and uses a combination of SimpleDB, HBase, <span class="No-Break">and Cassandra</span></li>
				<li><strong class="bold">Uber</strong>: Uber uses Riak, a<a id="_idIndexMarker009"/> distributed NoSQL database with <a id="_idIndexMarker010"/>a flexible key-value <span class="No-Break">store model</span></li>
				<li><strong class="bold">LinkedIn</strong>: LinkedIn built its <a id="_idIndexMarker011"/>own NoSQL database called <a id="_idIndexMarker012"/>Espresso, which is a document-orien<a id="_idTextAnchor017"/>ted database </li>
			</ul>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/>The challenges of handling data</h2>
			<p>The evolution of database systems has been marked by key milestones over the decades. In the <a id="_idIndexMarker013"/>early days, when storage was expensive, the challenge was finding ways to reduce information waste. A reduction of even one million dollars’ worth of information was a <span class="No-Break">significant achievement.</span></p>
			<p class="callout-heading">Did you know?</p>
			<p class="callout">At the dawn of the database era, a megabyte used to cost around 5 <span class="No-Break">million dollars!</span></p>
			<p class="callout"><a href="https://ourworldindata.org/grapher/historical-cost-of-computer-memory-and-storage"><span class="No-Break">https://ourworldindata.org/grapher/historical-cost-of-computer-memory-and-storage</span></a></p>
			<p>Today, megabyte cost isn’t the challenge anymore as we’re living at the cost of 0.001 $/MB. As time passed and storage became cheaper, the methods of reducing duplicate data started to negatively impact an application’s response time. Normalization and the attempts to reduce data duplication, multiple join queries, and massive amounts of data did not help <span class="No-Break">as much.</span></p>
			<p>It’s no surprise that challenges to this model would eventually emerge. As noted by the esteemed and respected authors of the book <em class="italic">Fundamentals of Software Architecture</em> (<a href="https://www.amazon.com/dp/1492043451/">https://www.amazon.com/dp/1492043451/</a>), definitive solutions don’t exist; instead, we are presented with many solutions where each is accompanied by its own set of benefits <span class="No-Break">and drawbacks.</span></p>
			<p>Obviously, the same applies <span class="No-Break">to databases.</span></p>
			<p><em class="italic">There is no one-size-fits-all solution when it comes to data </em><span class="No-Break"><em class="italic">storage solutions.</em></span></p>
			<p>In the 2000s, new storage solutions, such as NoSQL databases, began to gain popularity and architects had more options to choose from. This doesn’t mean that SQL stopped being relevant, but rather that architects must now navigate the complexities of choosing the right paradigm for <span class="No-Break">each problem.</span></p>
			<p>As the database landscape went through these phases, the application’s scenario also changed. Discussions moved toward the motivations and challenges of adopting a microservices architecture style, bringing us back to the multiple persistence strategies available. Traditionally, architectures included relational database solutions, with one or two instances (given its increased cost). Now, as new storage solutions mature, architectural solutions start to include persistence based on NoSQL databases, scaling up to multiple running instances. The possibility of storing data in multiple ways, throughout different services that compose a single broader solution, is a good environment for potential new solutions with <span class="No-Break">polyglot persistence.</span></p>
			<p><strong class="bold">Polyglot persistence</strong> is the idea that computer applications can use different database types to take advantage of the fact that various engine systems are better equipped to handle <a id="_idIndexMarker014"/>different problems. Complex applications often involve different types of problems, so choosing the right tool for each job can be more productive than trying to solve all aspects of the problem using a <span class="No-Break">single solution.</span></p>
			<p>When analyzing solutions in most recent times, the reality confronts us, developers and architects, with the complexity of choice. How do we handle data, having to consider a scenario <a id="_idIndexMarker015"/>with multiple data types? To make it clear, we’re talking about mixing and matching hundreds of possible solutions. The best path is to prepare by learning about persistence fundamentals, best practices, and paradigms. And finally, being aware that no matter how much we desire a fast, scalable, highly available, precise, <em class="italic">and </em>consistent solution – we now know that, according to the CAP theorem, a concept discussed later in this chapter, that may <span class="No-Break">be impossible.</span></p>
			<p>Next, we’ll narrow down our focus specifically to persistence within the context of <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Characteristics of Java persistence frameworks</h1>
			<p>Let’s grasp the idea of the differences between the Java language and the multiple databases available. Java, an <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) language, naturally offers <a id="_idIndexMarker016"/>features such as inheritance, <a id="_idIndexMarker017"/>encapsulation, and types, which supports the creation of well-designed code. Unfortunately, not all of these features are supported by <span class="No-Break">database systems.</span></p>
			<p>As a consequence, when integrating both language and database paradigms, some of their unique advantages might get lost. This complexity becomes clear when we observe that in all data manipulation between in-memory objects and the database schema, there should be some data mapping and conversion. It is critical to either define a preferred approach or provide an isolation layer. In Java, the most systematic way <a id="_idIndexMarker018"/>to integrate both worlds is through the usage <a id="_idIndexMarker019"/>of frameworks. Frameworks come in various types and categories shaped by their <strong class="bold">communication levels</strong> and the <strong class="bold">provided API dynamics</strong>. In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em>, observe the key aspects of <span class="No-Break">both concepts:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer012">
					<img alt="Figure 1.1 – Considerations about the different characteristics of a Java persistence framework" src="image/Figure_1.1_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Considerations about the different characteristics of a Java persistence framework</p>
			<ul>
				<li><strong class="bold">Communication levels</strong>: Define how unrelated the code is from either the database or OOP <a id="_idIndexMarker020"/>paradigm. The code <a id="_idIndexMarker021"/>can be designed to be more similar to one of the two domains. To clarify, take into consideration two common approaches for integrating a Java app with a database – using a database driver directly or relying on the <span class="No-Break">mapper pattern:</span><ul><li>Directly adopting a driver (e.g., JDBC Driver) means working closer to the database domain space. A database driver that is easy to work with is usually data-oriented. A downside is the need to have more boilerplate code to be able to map and convert all manipulated data between the database model and the Java <span class="No-Break">domain objects.</span></li><li>The mapper pattern provides the possibility to map a database structure to the Java objects using the completely opposite approach. In the context of mapping frameworks such as Hibernate and Panache, the primary objective is to align more closely with the OOP paradigm rather than focusing primarily on the database.  While offering the benefit of reduced boilerplate code, it has as a trade-off, to coexist with a constant object-relational impedance mismatch and its consequent performance impacts. This topic will be covered in more detail in <span class="No-Break">further chapters.</span></li></ul></li>
				<li><strong class="bold">API abstraction levels</strong>: To abstract some level of translation between Java and the database <a id="_idIndexMarker022"/>during data <a id="_idIndexMarker023"/>manipulation and other database interactions, developers rely on a given Java API. To clarify the abstraction level of an API, you can ask, for example, <em class="italic">“How many different database types does a given database API support?”</em> When using SQL as a standard for relational database integration, developers can use a <em class="italic">single API</em> and integrate it with <em class="italic">all</em> relational database flavors. There are two types <span class="No-Break">of APIs:</span><ul><li>A specific API may offer more accurate updates from the vendor, but it also means that any solution that relies on that API will need to be changed if you <a id="_idIndexMarker024"/>ever want to switch to a different database (e.g., Morphia or Neo4j-OGM – <strong class="bold">OGM</strong> stands for <strong class="bold">Object </strong><span class="No-Break"><strong class="bold">Graph Mapper</strong></span><span class="No-Break">)</span></li><li>An agnostic API is more flexible and can be used with many different types of <a id="_idIndexMarker025"/>databases, but it <a id="_idIndexMarker026"/>can be more challenging to manage updates or particular behaviors for <span class="No-Break">each one</span></li></ul></li>
			</ul>
			<p class="callout-heading">Code design– DDD versus data-oriented</p>
			<p class="callout">In the renowned book <em class="italic">Clean Code</em>, the author, known as Uncle Bob, states OOP languages have the benefit of hiding data in order to expose its behavior. In the same line of thought, we see DDD, which proposes the usage of a ubiquitous <a id="_idIndexMarker027"/>language throughout the domain’s code and <a id="_idIndexMarker028"/>related communication. The implementation of such a proposal can be achieved through the usage of OOP concepts. In <em class="italic">Data-Oriented Programming</em>, Yehonathan Sharvit suggests simplifying complexity by giving relevance to data and treating it as a “<span class="No-Break">first-class citizen.”</span></p>
			<p class="callout">Luckily, there are several frameworks to assist us in the challenges of delivering performant persistence layers. Although we understand that more options bring back the paradox of choice, there’s no need to worry – this book is a helpful resource that software engineers can use to learn how to evaluate multiple perspectives within software architecture, especially the details within the data storage integration a<a id="_idTextAnchor020"/>nd data <span class="No-Break">manipulation space.</span></p>
			<p>So far, we have explored the diverse methods that we humans have devised to address a fundamental issue: efficiently storing data in a manner that ensures longevity and <a id="_idIndexMarker029"/>serves as a knowledge base to support our evolution. As technology has advanced, multiple persistence strategies have been made available to software architects and developers, including relational and unstructured approaches such as NoSQL. The variety of persistence options has resulted in new challenges in software design; after all, retrieving, storing, and making data available also went through innovation at the application layer. Persistence frameworks, since then and still today, provide architects with <a id="_idIndexMarker030"/>different strategies, enabling designs where development is closely associated with the underlying database technology o<a id="_idTextAnchor021"/>r is more dynamic <span class="No-Break">and agnostic.</span></p>
			<p>Our next stop on this database historical journey is the cloud era. Let’s explore how cloud offerings have impacted applications and the ways and <em class="italic">locations</em> where data can now <span class="No-Break">be stored.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor022"/>The cloud’s effect on stateful solutions</h1>
			<p>When it comes to databases, professionals need to have an operational perspective in addition to <a id="_idIndexMarker031"/>an infrastructure and software architecture <a id="_idIndexMarker032"/>perspective. There are several factors to consider regarding a solution’s architecture and the required compliance, such as networking, security, cloud backup, <span class="No-Break">and upgrades.</span></p>
			<p>Fortunately, we can use the help of cloud services. The cloud, as a technology-related concept, has <a id="_idIndexMarker033"/>been defined by the <strong class="bold">National Institute of Standards and Technology</strong> (<strong class="bold">NIST</strong>) as a model that enables the consumption, on-demand and via a network, of a shared set of computing resources that are rapidly <span class="No-Break">made available.</span></p>
			<p>You might have heard a joke in tech communities that says that “the cloud is just somebody else’s computer.” However, we believe there’s more to the cloud than that; we prefer to look at the cloud <span class="No-Break">as follows:</span></p>
			<p class="author-quote">The cloud is somebody else’s problem.</p>
			<p>The main goal of adopting cloud services is to outsource non-core business functions to somebody else. This way, we can focus on our <span class="No-Break">core competencies.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As you read <a id="_idIndexMarker034"/>through the book, you’ll notice several <a id="_idIndexMarker035"/>acronyms are used. In this chapter, we mostly refer to the<a id="_idIndexMarker036"/> following cloud service offering types: <strong class="bold">Infrastructure as a Service</strong> (<strong class="bold">IaaS</strong>), <strong class="bold">Platform as a Service</strong> (<strong class="bold">PaaS</strong>), and <strong class="bold">Software as a </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SaaS</strong></span><span class="No-Break">).</span></p>
			<p>Even though you might feel like cloud services could finally be the solution to numerous technical problems you’ve gone through, remember that delegated responsibilities and tasks also have chances of going very differently from what you expected – for example, services crashing or costs skyrocketing. Since we’re discussing the action of “delegating a problem to somebody else,” here are three types of cloud services (three ways to “delegate”) and their respective <span class="No-Break">target audiences:</span></p>
			<ul>
				<li><strong class="bold">IaaS</strong>: <em class="italic">Infrastructure</em> is not your problem. The target audience <a id="_idIndexMarker037"/>is people who work on the operation side, such <span class="No-Break">as SREs.</span></li>
				<li><strong class="bold">PaaS</strong>: The <em class="italic">infrastructure</em> and <em class="italic">operation</em> are not your problems. The <a id="_idIndexMarker038"/>main target audience is <span class="No-Break">software engineers.</span></li>
				<li><strong class="bold">SaaS</strong>: The <em class="italic">infrastructure</em>, <em class="italic">operation</em>, and <em class="italic">software</em> are not your <a id="_idIndexMarker039"/>problem. In this case, the target audience is the end user, who doesn’t necessarily know how <span class="No-Break">to code.</span></li>
			</ul>
			<p>As we previously pointed out in this chapter, <em class="italic">every solution’s trade-offs must be considered</em>. Picking the PaaS cloud offering as an example: this model offers a higher level of abstraction in exchange for a bit of a higher <span class="No-Break">price tag.</span></p>
			<p>What about cloud offerings for data storage, then? As pointed out by Dan More in the book <em class="italic">97 Things Every Cloud Engineer Should Know</em> (<a href="https://www.amazon.com/dp/1492076732">https://www.amazon.com/dp/1492076732</a>), databases can also be used as managed cloud services. Looking at a managed database service, you could consider that someone else (a vendor) will provide a service to abstract most of (and in some cases, all of) the database infrastructure and <span class="No-Break">management tasks.</span></p>
			<p><strong class="bold">Database as a Service</strong> (<strong class="bold">DBaaS</strong>) is a popular <a id="_idIndexMarker040"/>type of cloud service that allows users to choose from <a id="_idIndexMarker041"/>a variety of database flavors, running <a id="_idIndexMarker042"/>in multiple regions and managed by different <span class="No-Break">cloud providers.</span></p>
			<p>Cloud services can be helpful when we need to explore various architectural persistence solutions and delegate complexity. They have been widely adopted and proven to be effective in serving <span class="No-Break">this purpose.</span></p>
			<p>With cloud <a id="_idIndexMarker043"/>offerings and microservices architecture adoption, <a id="_idIndexMarker044"/>distributed solutions are becoming more prevalent. Architects then have to handle new challenges related to data integrity and unexpected occurrences of inconsistency in data in app<a id="_idTextAnchor023"/>lications that must meet <span class="No-Break">such requirements.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor024"/>Exploring the trade-offs of distributed database 
systems – a look into the CAP theorem and beyond</h1>
			<p>If the perfect <strong class="bold">Distributed Database System</strong> (<strong class="bold">DDBS</strong>) were to be described, it would certainly <a id="_idIndexMarker045"/>be a database that was highly scalable, provided <a id="_idIndexMarker046"/>perfectly consistent data, and didn’t require too much attention in regard to management (tasks such as backup, migrations, and managing the network). Unfortunately, the CAP theorem, formulated by Eric Brewer, states that that’s <span class="No-Break">not possible.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To date, there is no database solution that can provide the ideal combination of features such as total data consistency, high availability, and scalability <span class="No-Break">all together.</span></p>
			<p class="callout">For details, check: <em class="italic">Towards robust distributed systems</em>. PODC. 7. 10.1145/343477.343502 (<span class="No-Break">https://www.researchgate.net/publication/221343719_Towards_robust_distributed_systems</span><span class="No-Break">).</span></p>
			<p>The <strong class="bold">CAP theorem</strong> is a way of understanding the trade-offs between different properties of <a id="_idIndexMarker047"/>a DDBS. Eric Brewer, at the 2000 Symposium on <strong class="bold">Principles of Distributed Computing </strong>(<strong class="bold">PODC</strong>), conjectured that when creating a DDBS, <em class="italic">“you can have at most two of these properties for any shared-data system,</em>” referring to the properties <strong class="bold">consistency</strong>, <strong class="bold">availability</strong>, and <strong class="bold">tolerance to </strong><span class="No-Break"><strong class="bold">network partitions</strong></span><span class="No-Break">.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer013">
					<img alt="Figure 1.2 – ﻿Representation inspired by Eric Brewer’s keynote presentation" src="image/Figure_1.2_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Representation inspired by Eric Brewer’s keynote presentation</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><em class="italic">Towards Robust Distributed Systems</em>. For more information on Eric Brewer’s work, refer to Brewer, Eric. (2000), <span class="No-Break">presentation: </span><a href="https://people.eecs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf"><span class="No-Break">https://people.eecs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf</span></a><span class="No-Break">.</span></p>
			<p>The three characteristics described in the CAP theorem can be described <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Consistency</strong>: The guarantee <a id="_idIndexMarker048"/>that every node in a distributed cluster returns the same, most recent, <span class="No-Break">successful write.</span></li>
				<li><strong class="bold">Availability</strong>: Every <a id="_idIndexMarker049"/>non-failing node returns a response for all read and write requests in a reasonable amount <span class="No-Break">of time.</span></li>
				<li><strong class="bold">Partition tolerance</strong>: The system continues to function and uphold its consistency guarantees despite network partitions. In other words, the service is running despite crashes, disk failures, database, software, and OS upgrades, power outages, and <span class="No-Break">other factors.</span></li>
			</ul>
			<p>In other words, the DDBSes we can pick and choose from would only be <strong class="bold">CA</strong> (consistent and highly available), <strong class="bold">CP</strong> (consistent and partition-tolerant), or <strong class="bold">AP</strong> (highly available <span class="No-Break">and partition-tolerant).</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As stressed in the book <em class="italic">Fundamentals of Software Architecture: An Engineering Approach</em>, good software architecture requires dealing with trade-offs. This is yet another trade-off to take into <span class="No-Break">consideration (</span><a href="https://www.amazon.com/Fundamentals-Software-Architecture-Engineering-Approach-ebook/dp/B0849MPK73/"><span class="No-Break">https://www.amazon.com/Fundamentals-Software-Architecture-Engineering-Approach-ebook/dp/B0849MPK73/</span></a><span class="No-Break">).</span></p>
			<p>By considering the CAP theorem, we can then apply this new knowledge to back us up in decision-making processes in regard to choosing between SQL and NoSQL. For example, traditional DBMSes thrive when (mostly) providing the <strong class="bold">Atomicity, Consistency, Isolation, and Durability</strong> (<strong class="bold">ACID</strong>) properties; however, in regard to distributed systems, it <a id="_idIndexMarker050"/>may be necessary to give up consistency and isolation in order to achieve higher availability and better performance. This is commonly known as sacrificing consistency <span class="No-Break">for availability.</span></p>
			<p>Almost 12 years after the idea of CAP was proposed, Seth Gilbert and Nancy Lynch at MIT published some research, a formal proof of Brewer’s conjecture. However, another expert on <a id="_idIndexMarker051"/>database system architecture and implementation has also done some research on scalable and distributed systems, adding, to the existing theorem, the consideration of the consistency and <span class="No-Break">latency trade-off.</span></p>
			<p>In 2012, Prof. Daniel Abadi published a study stating CAP has become <em class="italic">“increasingly misunderstood and misapplied, causing significant harm”</em> leading to unnecessarily limited <strong class="bold">Distributed Database Management System</strong> (<strong class="bold">DDBMS</strong>) creation, as CAP only presents <a id="_idIndexMarker052"/>limitations in the face of certain types of failures – not during <span class="No-Break">normal operations.</span></p>
			<p>Abadi’s paper <em class="italic">Consistency Tradeoffs in Modern Distributed Database System Design</em> proposes a new formulation, <strong class="bold">Performance and Consistency Elasticity Capabilities</strong> (<strong class="bold">PACELC</strong>), which argues that the trade-offs between consistency and performance <a id="_idIndexMarker053"/>can be managed through the use of elasticity. The following question quoted in the paper clarifies the main idea: <em class="italic">“If there is a partition (P), how does the system trade off availability and consistency (A and C); else (E), when the system is running normally in the absence of partitions, how does the system trade off latency (L) and </em><span class="No-Break"><em class="italic">consistency (C)?”</em></span></p>
			<p>According to Abadi, a distributed database could be both highly consistent and highly performant, but <a id="_idIndexMarker054"/>only under certain conditions – <em class="italic">only</em> when the system can adjust its consistency level based on network conditions through the use <span class="No-Break">of elasticity.</span></p>
			<p>At this point, the intricacies of building database systems, particularly distributed ones, have been made crystal clear. As professionals tasked with evaluating and selecting DDBSes and designing solutions on top of them, having a fundamental understanding of the concepts discussed in these studies serves as<a id="_idTextAnchor025"/> a valuable foundation for <span class="No-Break">informed decision-making.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor026"/>Summary</h1>
			<p>Any software application relies heavily on its database, so it’s important to give it the attention it deserves. In this chapter, we explored the interesting history of data storage, from its early days to the modern era of cloud computing. Throughout this journey, we witnessed the impacts of data storage evolution on the field of software engineering, and how Java frameworks have also evolved to be able to support polyglot solutions. As experienced software engineers, it is crucial for us to understand the importance of data and solutions that can manage and manipulate <span class="No-Break">it effectively.</span></p>
			<p>Adding to that, we discussed the challenges of relational databases, such as data redundancy and normalization, and how NoSQL databases emerged to handle unstructured data needs. We introduced the CAP theorem and mentioned additional studies, such as PACELC, to explain the challenges of implementing distributed data <span class="No-Break">storage solutions.</span></p>
			<p>As we continue through this book, we’ll delve deeper into the advanced architectural and development practices, challenges, and trade-offs you must know about in order to deliver the optimal persistence layer for each solution you get to work with from now on, related to data persistence. After taking a look at the history, motivation, and relationship between databases and Java, get ready to explore, in the next chapter, the different types of databases and their pros <span class="No-Break">and cons.</span></p>
		</div>
	</body></html>