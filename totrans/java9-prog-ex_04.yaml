- en: Mastermind - Creating a Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mastermind - 创建一个游戏
- en: 'In this chapter, we will start to develop a simple game. The game is the Mastermind
    game for two players. Player one selects four differently colored pins out of
    six possible colors and arranges them on a board in a row hidden from the other
    player. The other player tries to guess the colors of the pins and its positions.
    After each try, player one tells the number of matching colors and the pins matching
    both color and position. The program will act as both player one and player two.
    Our code will play alone. However, what remains for us to play with is the most
    important: the code.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始开发一个简单的游戏。这个游戏是两人玩的Mastermind游戏。玩家一从六种可能的颜色中选择四个不同颜色的针，并将它们按行排列在隐藏给另一个玩家的板上。另一个玩家试图猜测针的颜色和位置。每次尝试后，玩家一告诉匹配的颜色数量以及匹配颜色和位置的针的数量。程序将扮演玩家一和玩家二。我们的代码将独立运行。然而，我们最重要的任务是代码本身。
- en: This example is complex enough to deepen the OO principles and how we design
    classes and model the real world. We have already used classes provided in the
    Java runtime. This time, we will use collections and discuss this important area.
    These classes and interfaces are widely used and available in the JDK and as important
    for a professional Java developer as the language itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子足够复杂，可以加深我们对面向对象原则的理解以及如何设计类和模拟现实世界。我们已经使用了Java运行时提供的类。这次，我们将使用集合并讨论这个重要领域。这些类和接口在JDK中广泛使用，对于专业Java开发者来说，它们的重要性不亚于语言本身。
- en: The build tool this time is Gradle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的构建工具是Gradle。
- en: 'In this chapter we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Java collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java集合
- en: Dependency injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: How to comment our code and to create JavaDoc documentation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何注释我们的代码以及创建JavaDoc文档
- en: How to create integration tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建集成测试
- en: The Game
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: Mastermind ([https://en.wikipedia.org/wiki/Mastermind_(board_game)](https://en.wikipedia.org/wiki/Mastermind_(board_game)))
    is an old game. The plastic version that was ubiquitous in every house with children
    was invented in 1970\. I got a board around 1980 as a Christmas gift and solving
    the game puzzle in BASIC language was one of the first programs that I created
    around 1984.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Mastermind ([https://zh.wikipedia.org/wiki/Mastermind_(board_game)](https://zh.wikipedia.org/wiki/Mastermind_(board_game)))
    是一款老游戏。那个在每家每户都有孩子的家庭中无处不在的塑料版本是在1970年发明的。我大约在1980年收到了一个作为圣诞礼物的板子，用BASIC语言解决游戏谜题是我1984年左右编写的第一个程序之一。
- en: The game board contains holes in several rows in four columns. There are plastic
    pins of six different colors that can be inserted into the holes. Each pin has
    one color. They are usually red, green, blue, yellow, black, and white. There
    is a special row that is hidden from one of the players (the guesser).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏板在四列的几行中都有孔。有六种不同颜色的塑料针可以插入孔中。每个针都有一个颜色。它们通常是红色、绿色、蓝色、黄色、黑色和白色。有一行是隐藏给一个玩家（猜测者）的。
- en: To play the game, one of the players (hider) has to select four pins from a
    set of pins. The selected pins should have different colors. The pins are placed
    in the hidden row one by one, each into a position.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了玩游戏，一个玩家（隐藏者）必须从一组针中选择四个。所选的针应该有不同的颜色。针一个接一个地放置在隐藏行中，每个针都放在一个位置。
- en: The guesser tries to find out what colors are in which position guessing. Each
    guess takes place selecting four pins and placing them in a row. The hider tells
    the guesser how many pins are in correct position and how many have a color that
    is on the table, but are not in the position where that color is hidden.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测者试图通过猜测颜色和位置来找出颜色。每次猜测都涉及选择四个针并将它们放在一行中。隐藏者告诉猜测者有多少针在正确的位置，以及有多少针颜色在桌面上，但不在隐藏颜色的位置。
- en: '![](img/00039.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00039.jpeg)'
- en: 'A sample play may go like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一场典型的游戏可能如下进行：
- en: The hider hides four pins with color blue, yellow, white, and black.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏者用蓝色、黄色、白色和黑色的四个针进行隐藏。
- en: Guesser guesses yellow, blue, green, and red.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猜测者猜测黄色、蓝色、绿色和红色。
- en: The hider tells the guesser that there are two colors matching, but none of
    them is in the position in the hidden row. The hider says this because yellow
    and blue are in the hidden row but not in the positions as the guesser guessed.
    They are actually swapped, but this information the hider keeps a secret. All
    she says is that there are two colors matching, none in the correct position.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏者告诉猜测者有两个颜色匹配，但它们都不在隐藏行的位置。隐藏者之所以这么说，是因为黄色和蓝色在隐藏行，但不在猜测者猜测的位置。实际上它们是交换过的，但这个信息隐藏者保密。她只说有两个颜色匹配，没有颜色在正确的位置。
- en: The next guess is ...
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个猜测是 ...
- en: The game finishes when the guesser finds the correct colors in the correct order.
    The same game, as on the figure, can also be described with textual notation,
    `B` for blue, `Y` for yellow, `G` for green, `W` for white, `R` for red, and `b`
    for black (lucky we have upper and lower case letters on the computer).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当猜谜者找到正确的颜色并按正确顺序排列时，游戏结束。如图所示的相同游戏也可以用文本表示法来描述，`B`代表蓝色，`Y`代表黄色，`G`代表绿色，`W`代表白色，`R`代表红色，`b`代表黑色（幸运的是，我们在电脑上有大小写字母）。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Guess what! This is the actual output of the program that we develop in this
    chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看！这是我们在这个章节中开发的程序的真正输出。
- en: The model of the game
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏的模型
- en: When we develop a piece of code with an object-oriented mindset, we try to model
    the real world and map real-world objects to objects in the program. You certainly
    have heard of object orientation explained with the very typical examples of geometric
    objects, or the car and the motor thing to explain composition. Personally, I
    believe that these examples are too simple to get a good understanding. They may
    be good for starters, but we are already in the fourth chapter of the book. The
    Mastermind game is much better. It is a bit more complex than just rectangles
    and triangles, but not as complex as a telecom billing application or an atomic
    power plant control.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用面向对象的心态编写一段代码时，我们试图模拟现实世界，并将现实世界的对象映射到程序中的对象。你肯定听说过用非常典型的几何对象、汽车和发动机等例子来解释面向对象。我个人认为这些例子太简单了，无法获得良好的理解。它们可能适合初学者，但我们已经在书的第四章了。Mastermind游戏要好得多。它比简单的矩形和三角形复杂一些，但不如电信计费应用或原子能电站控制复杂。
- en: 'What are the real-world objects that we have in that game? We have a table
    and we have pins of different colors. There are two Java classes that we certainly
    will need. What is in a table? There are rows each having four positions. Perhaps
    we will need a class for a row. A table will have rows. We will also need something
    that hides the secret. This also may be a row and each row may also hold the information
    about how many positions and how many colors are matching. In case of the secret
    row, this information is obvious: 4 and 0.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个游戏中我们有哪些现实世界的对象呢？我们有一个台球桌，还有不同颜色的球。我们肯定需要两个Java类。台球桌里有什么呢？每一行有四个位置。也许我们需要一个代表行的类。台球桌将有行。我们还需要一些隐藏秘密的东西。这也可能是一个行，每一行也可能包含有关位置数和匹配颜色的信息。对于秘密行来说，这个信息是显而易见的：4和0。
- en: What is a pin? Each pin has a color and generally, that is it. There are no
    other features of a pin, except that it can be inserted into a hole on the table,
    but this is a real life feature we will not model. Essentially, a pin is a color
    and nothing else. This way, we can eliminate the pin class from our model early
    on, even before we created it in Java. Instead, we have colors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是球？每个球都有一个颜色，通常就是这样。球没有其他特征，除了它可以插入到台球桌上的一个洞里，但这是现实生活中我们不会模拟的特征。本质上，球就是一个颜色，没有其他。这样，我们可以在早期就消除球类从我们的模型中，甚至在Java创建它之前。相反，我们有颜色。
- en: 'What is a color? This is something that may be hard to immerse into the first
    time. We all know well what a color is. It is a mixture of different frequency
    of lights, as our eyes perceive it. We can have paints and prints in different
    colors, and so on. There are very many things that we do not model in this program.
    It is really hard to tell what we model about color in our code because these
    features are so obvious that we take it for granted in real life; we can tell
    about two colors that they are different. This is the only feature we need. To
    do this, the simplest class of Java can be used:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是颜色？这可能是第一次难以沉浸其中的东西。我们都知道颜色是什么。它是不同频率的光的混合，正如我们的眼睛所感知的那样。我们可以有不同颜色的油漆和印刷品，等等。在这个程序中，我们有很多东西没有模拟。在代码中很难说我们模拟了关于颜色的哪些内容，因为这些特征如此明显，我们在现实生活中都认为是理所当然的；我们可以描述两种颜色是不同的。这是我们唯一需要的特征。为此，我们可以使用Java中最简单的类：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you have two variables of the type `Color`, you can tell if they are the
    same or not. You can use object identity comparing `a` and `b` using the expression
    `a == b` or you can use the `equals` method inherited from the `Object` class,
    `a.equals(b)`. It is tempting to encode the colors with letters, or use `String`
    constants to denote them. It may be easier first, but there are serious drawbacks
    later. When the code becomes complex, it leads to bugs; it will be easy to pass
    something also encoded as String instead of a color and only unit tests may save
    the day. Better, the compiler already complains in the IDE when you type the wrong
    argument.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个**Color**类型的变量，你可以判断它们是否相同。你可以使用对象身份比较`a`和`b`的表达式`a == b`，或者你可以使用从`Object`类继承的`equals`方法，`a.equals(b)`。用字母编码颜色或使用`String`常量来表示它们可能更容易，但后来会有严重的缺点。当代码变得复杂时，它会导致错误；很容易传递也编码为String的东西而不是颜色，只有单元测试可能拯救这一天。更好的是，当你输入错误的参数时，编译器已经在IDE中抱怨了。
- en: When we play the game, the pins are in small boxes. We pull pins out of the
    boxes. How do we get the colors in the program? We need something from where we
    can fetch colors or looking at the other way something that can give us colors.
    We will call it `ColorManager`. `ColorManager` knows how many different colors
    we have and any time we need a color, we can ask for it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们玩游戏时，球针在小盒子里。我们从盒子里拔出球针。我们如何在程序中获取颜色？我们需要从我们可以获取颜色的地方，或者从另一个角度看，我们可以提供颜色的地方。我们将称之为`ColorManager`。`ColorManager`知道我们有多少种不同的颜色，任何我们需要颜色的时候，我们都可以要求它。
- en: Again, there is a temptation to design the `ColorManager` that it can serve
    a color by its serial number. If we have four colors, we could ask for color number
    0, 1, 2, or 3\. But then again, it would just implicitly encode the colors as
    integer numbers, which we agreed we will not. We should find the minimum feature
    that we will need to model the game.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有一种诱惑要设计一个**ColorManager**，它可以按照序列号提供颜色。如果我们有四种颜色，我们可以要求颜色编号0、1、2或3。但再次，它只是隐式地将颜色编码为整数，这是我们同意不会做的。我们应该找到我们需要的最小特征来模拟游戏。
- en: To describe the structure of the classes, professional developers usually use
    UML class diagrams. UML is a diagram notation that is standardized and is almost
    exclusively used to visualize software architecture. There are many diagram types
    in UML to describe the static structure and the dynamic behavior of a program.
    This time, we will look at a very simplified class diagram.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述类的结构，专业开发者通常使用UML类图。UML是一种标准化的图表符号，几乎专门用于可视化软件架构。UML中有许多图表类型来描述程序的静态结构和动态行为。这次，我们将查看一个非常简化的类图。
- en: '![](img/00040.gif)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.gif)'
- en: We have no room to get into the details of UML class diagrams. Rectangles denote
    the classes, normal arrows denote the relations when a class has field of the
    other class type, and triangle headed arrow means that a class extends another.
    The arrow points to the direction of the class being extended.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有空间深入了解UML类图。矩形表示类，普通箭头表示当类具有其他类类型的字段时的关系，三角形箭头表示一个类扩展了另一个类。箭头指向被扩展的类的方向。
- en: A **Game** contains a secret **Row** and a **Table**. The **Table** has a **ColorManager**
    and a **List<>** of **Row**. The **ColorManager** has a first color and has a
    **Map<>** of **Color**. We have not discussed why that is the design, we will
    get there and the diagram helps us walking that road. A **Row** is essentially
    an array of **Color**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**Game**包含一个秘密的**Row**和一个**Table**。**Table**有一个**ColorManager**和一个**Row**的**List<>**。**ColorManager**有一个第一个颜色和一个**Color**的**Map<>**。我们还没有讨论为什么是这种设计，我们将会到达那里，图表帮助我们走这条路。一个**Row**本质上是一个**Color**的数组。
- en: 'The one who plays the game has one function: it has to guess many times until
    it finds the hidden secret. To get to the model of the **ColorManager**, we will
    have to design the algorithm of the **Guesser**.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏的人有一个功能：它必须猜测很多次，直到找到隐藏的秘密。为了得到**ColorManager**的模型，我们不得不设计**Guesser**的算法。
- en: When the player makes the first guess, any combination of colors is just as
    good as any other. Later, the guesses should consider the responses that were
    given for previous guesses. It is a reasonable approach to try only color variations
    that can be the actual secret. The player selects a variation and looks at all
    previous guesses assuming that the selected variation is the secret. If the responses
    to the rows he has already made are the same for this variation as for the unknown
    secret in the game, then it is reasonable to try this variation. If there is any
    difference in the responses, then this variation is certainly not the variation
    that was hidden.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家第一次猜测时，任何颜色的组合都和其他任何组合一样好。后来，猜测应该考虑之前猜测得到的回应。尝试只有可能是实际秘密的颜色变化是一种合理的方法。玩家选择一个变化，并查看所有之前的猜测，假设所选的变化是秘密。如果他对已经做出的行回应与游戏中未知秘密的回应相同，那么尝试这个变化是合理的。如果有任何差异，那么这个变化肯定不是隐藏的变化。
- en: To follow this approach, the guesser has to generate all possible color variations
    one after the other and compare it against the table. The guesser code will not
    create and store all the possible variations ahead, but it has to know where it
    was and has to be able to calculate the next variation that comes. This assumes
    an order of the variations. For a short while, let's forget that no color may
    appear twice in a variation. A simple ordering can be made the same way as we
    sort decimal numbers. If we have a three-digit number, then the first one is 000,
    the next one is 001, and so on until 009, always fetching the next digit for the
    last position. After that, 010 comes. We increased a digit next to the last one
    and we set the last one to 0 again. Now, we have 011, 012, and so on. You know,
    how we count numbers. Now, replace the digits with colors and we have only six
    and not ten. Or, we have as many as we want when we instantiate a `ColorManager`
    object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循这种方法，猜测者必须一个接一个地生成所有可能的颜色变化，并将其与表格进行比较。猜测者的代码不会提前创建和存储所有可能的变化，但它必须知道它在哪里，并且必须能够计算出下一个变化。这假设了变化的顺序。暂时让我们忘记在一个变化中可能不会出现两次颜色。简单的排序可以像我们排序十进制数字一样进行。如果我们有一个三位数，那么第一个是000，下一个是001，以此类推，直到009，总是为最后一个位置获取下一个数字。之后，010出现。我们增加最后一个旁边的数字，并将最后一个数字设置为0。现在，我们有011，012，以此类推。你知道我们是如何数数的。现在，用颜色替换数字，我们只有六种颜色而不是十种。或者，当我们实例化一个`ColorManager`对象时，我们可以有我们想要的任何数量。
- en: 'This leads to the functionality of the `ColorManager`. It has to do the following
    two things:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了`ColorManager`的功能。它必须完成以下两件事：
- en: Give the first color to the caller
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第一种颜色分配给呼叫者
- en: Give the next color that follows a given color (we will name the method `nextColor`)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给给定颜色之后的下一个颜色（我们将该方法命名为`nextColor`）
- en: The latter functionality should also signal some way when there is no next color.
    This will be implemented using another method, named `thereIsNextColor`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 后者功能还应该以某种方式在没有任何下一个颜色时发出信号。这将通过另一个名为`thereIsNextColor`的方法来实现。
- en: 'It is a convention to start the method names that return a Boolean value with
    `is`. That would lead to the name following this convention `isThereNextColor`,
    or `isNextColor`. Either of these names explains the functionality of the method.
    If I ask the question `isThereNextColor`, the method will answer me `true` or
    `false`. But, this is not how we will use the method. We will talk in simple sentences.
    We will use short sentences. We will avoid unnecessary, gibberish expressions.
    We will also program that way. Most probably, the caller will use this method
    in an `if` statement. They will write the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以“is”开头是返回布尔值的方法名的惯例。这将导致遵循此惯例的名称为`isThereNextColor`或`isNextColor`。这两个名称中的任何一个都解释了该方法的功能。如果我提出问题`isThereNextColor`，该方法将回答我`true`或`false`。但是，我们不会这样使用该方法。我们将用简单的句子来交流。我们将使用简短的句子。我们将避免不必要的、混乱的表达。我们也将这样编程。很可能会在`if`语句中使用这个方法。他们将写下以下内容：
- en: '`If( thereIsNextColor(currentColor)){...}`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`If( thereIsNextColor(currentColor)){...}`'
- en: and not
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是
- en: '`if( isThereNextColor(currentColor)){...}`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`if( isThereNextColor(currentColor)){...}`'
- en: I think the first version is more readable and readability comes first. Last,
    but not least, nobody will blame you if you follow the old convention, and in
    case that is the company standard, you have to anyway.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为第一个版本更易于阅读，可读性是最重要的。最后但同样重要的是，如果你遵循旧惯例，没有人会责怪你，如果这是公司的标准，你无论如何都必须这样做。
- en: To do these, the `ColorManager` also has to create the color objects and should
    store them in a structure that helps the operations being performed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这些操作，`ColorManager` 还需要创建颜色对象，并且应该将它们存储在一个有助于执行操作的机构中。
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The structure we use is a `Map`. `Map` is an interface defined in the Java runtime
    and is available since the very early releases of Java. A `Map` has keys and value,
    and for any key, you can easily retrieve the value assigned to the key.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的结构是 `Map`。`Map` 是在 Java 运行时中定义的一个接口，并且从 Java 的早期版本开始就可用。`Map` 有键和值，对于任何键，你可以轻松地检索分配给该键的值。
- en: You can see on the line, where the variable `successor` is defined that we define
    the type of the variable as an interface, but the value is an instance of a class.
    Obviously, the value cannot be an instance of an interface because such beasts
    do not exist. But, why do we define the variable to be an interface? The reason
    is abstraction and coding practice. If we need to change the implementation we
    use for some reason, the variable type still may remain the same and there is
    no need to change the code elsewhere. It is also a good practice to declare the
    variable to be an interface so that we will not have the temptation to use some
    special API of the implementation that is not available in the interface just
    by convenience. When it is really needed, we can change the type of the variable
    and use the special API. After all, there is a reason that API is there, but the
    mere temptation to use some special thing just because it is there is hindered.
    This helps to write simpler and cleaner program.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在定义变量 `successor` 的那一行看到，我们定义了变量的类型为接口，但值是一个类的实例。显然，值不能是一个接口的实例，因为这样的生物是不存在的。但，我们为什么要把变量定义为接口呢？原因是抽象和编码实践。如果我们需要因为某种原因更改使用的实现，变量类型仍然可能保持不变，而且不需要在其他地方更改代码。将变量声明为接口也是一个好的实践，这样我们就不会因为方便而使用接口中不可用的某些特殊
    API。当真正需要时，我们可以更改变量的类型并使用特殊的 API。毕竟，API 存在是有原因的，但仅仅因为某些特殊的东西存在就使用它的诱惑被阻止了。这有助于编写更简单、更干净的程序。
- en: '`Map` is only one of the interfaces defined in the Java runtime belonging to
    the Java collections. There are many other interfaces and classes. Although, the
    JDK and all the classes are a vast amount and almost nobody knows all the classes
    that are there, collections is a special area that a professional developer should
    be knowledgeable about. Before getting into details on why `HashMap` is used in
    this code, we will have an overview of the collection classes and interfaces.
    This will help us also understand the other collections used in this program.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 只是 Java 运行时中定义的属于 Java 集合的接口之一。还有很多其他的接口和类。尽管 JDK 和所有类都非常庞大，几乎没有人知道所有存在的类，但集合是一个专业开发者应该了解的特殊领域。在深入探讨为什么在这段代码中使用
    `HashMap` 之前，我们将对集合类和接口有一个概述。这将帮助我们理解这个程序中使用的其他集合。'
- en: Java collections
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 集合
- en: Collections are interfaces and classes that help us store more than one object.
    We have already seen arrays that can do that, and also `ArrayList` in the previous
    chapters, but we did not discuss in detail what other possibilities there are
    in the JDK. Here, we will go into more detail, but leave the streams and the functional
    methods for later chapters, and we will also refrain to go into details that is
    rather the task of a reference book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是帮助我们存储多个对象的接口和类。我们已经在之前的章节中看到了可以做到这一点的数组，以及 `ArrayList`，但我们没有详细讨论 JDK 中还有哪些其他可能性。在这里，我们将更详细地探讨，但将流和函数式方法留到后面的章节，我们也将避免深入探讨，这更像是参考书的任务。
- en: Using implementation of the collection classes and interfaces reduces the programming
    effort. First of all, you do not need to program something that is already there.
    Secondly, these classes are highly optimized, both in implementation and in their
    features. They have very well designed API as well as the code is fast and uses
    small memory footprint. Sorry to say that their code was written long time ago
    and many times it is not a good style, hard to read, and understand.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合类和接口的实现可以减少编程工作量。首先，你不需要编写已经存在的东西。其次，这些类在实现和功能上都非常优化。它们有非常精心设计的 API，代码运行速度快，内存占用小。遗憾的是，它们的代码是多年前编写的，很多时候风格不佳，难以阅读和理解。
- en: When you use a collection from the JDK, it is more likely that you can interoperate
    with some library. If you cook your own version of linked lists, it is not likely
    that you will find a readymade solution that will sort your list. If you use the
    `LinkedList` class in the JDK's standard class library, you will get a readymade
    solution from the `Collections` class, right from the JDK. It is also worth mentioning
    that the Java language itself supports these classes, for example, you can easily
    iterate through the elements of a `Collection` with a shortened special syntax.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用JDK中的集合时，你更有可能与某些库进行交互。如果你自己编写版本的链表，你不太可能找到一个现成的解决方案来排序你的列表。如果你使用JDK标准类库中的`LinkedList`类，你将从`Collections`类中获得一个现成的解决方案，直接来自JDK。也值得提到的是，Java语言本身支持这些类，例如，你可以使用简化的特殊语法轻松遍历`Collection`的元素。
- en: The collections in JDK contain interfaces that define the behavior of the different
    collection types, implementation classes, and algorithms that perform certain
    actions such as sorting. Many times, these algorithms work on different implementation
    versions, getting the same result, but optimized for the implementation specific
    class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中的集合包含定义不同集合类型、实现类以及执行某些操作（如排序）的算法的接口。很多时候，这些算法在不同的实现版本上工作，得到相同的结果，但针对特定类进行了优化。
- en: You can use the API given by the interface, and if you change the implementation
    in your code, you will get an optimized version fitting the implementation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用接口提供的API，如果你在代码中更改实现，你将得到一个适合实现的优化版本。
- en: '![](img/00041.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.gif)'
- en: The collection interfaces can be categorized in two bags. One bag contains the
    interfaces that extend the `Collection` interface, and the other one contains
    `Map`, and a `SortedMap` extending `Map`. This way, `Map` is not really a collection,
    as it does not simply contain other objects but also pair values to keys.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 集合接口可以分为两类。一类包含扩展`Collection`接口的接口，另一类包含`Map`和扩展`Map`的`SortedMap`。这样，`Map`实际上不是一个集合，因为它不仅包含其他对象，还包含键值对。
- en: Interface collection
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 界面集合
- en: Collection is the top of the interface hierarchy. This interface defines the
    methods that all implementations should provide, no matter if they implement the
    `Set`, `SortedSet`, `List`, `Queue`, or `Deque` interface directly. As `Collection`
    simply says that an object that implements the `Collection` interface is only
    an object that collects other objects together, the methods it defines are like
    adding a new object to the collection, clearing all elements from there, checking
    that an object is already a member of the collection, and iterating through the
    elements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 收集是界面层次结构中的顶层。这个界面定义了所有实现应该提供的方法，无论它们是否直接实现了`Set`、`SortedSet`、`List`、`Queue`或`Deque`接口。正如`Collection`所简单说明的，实现`Collection`接口的对象只是一个收集其他对象的集合，它定义的方法就像向集合中添加一个新对象、从那里清除所有元素、检查一个对象是否已经是集合的成员以及遍历元素。
- en: For an up-to-date definition of the interface, consult the Java pi documentation
    ([http://download.java.net/java/jdk9/docs/api/overview-summary.html](http://download.java.net/java/jdk9/docs/api/overview-summary.html)).
    You can consult the online API any time, and it is recommended to do so.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接口的最新定义，请参阅Java pi文档([http://download.java.net/java/jdk9/docs/api/overview-summary.html](http://download.java.net/java/jdk9/docs/api/overview-summary.html))。你可以随时在线查看API，并且建议这样做。
- en: 'The Java language itself directly supports the interface. You can iterate through
    the elements of the `Collection` with the enhanced `for` loop syntax, the same
    way as you can iterate over the elements of an array where the collection should
    be an expression that results an object that implements the `Collection` interface:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言本身直接支持这个接口。你可以使用增强的`for`循环语法遍历`Collection`的元素，就像你可以遍历数组中的元素一样，其中集合应该是一个表达式，该表达式结果是一个实现`Collection`接口的对象：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `E` is either Object or the generic type of the elements
    of the `Collection`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`E`是Object或者是`Collection`元素的类型参数。
- en: The interface `Collection` is not directly implemented in the JDK. Classes implement
    one of the sub interfaces of `Collection`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`接口在JDK中不是直接实现的。类实现了`Collection`的一个子接口。'
- en: Set
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: The `Set` is a special collection that cannot contain duplicate elements. When
    you want to add an object into a set that already has an object that is the same
    or equal to the actual one, then the `add` method will not add the actual object.
    The `add` method will return `false` indicating the failure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 是一个特殊的集合，不能包含重复的元素。当你想要将一个对象添加到一个已经包含与实际对象相同或相等的对象的集合中时，`add` 方法将不会添加实际的对象。`add`
    方法将返回 `false` 表示失败。'
- en: You can use `Set` in your program when you need a collection of unique elements
    where you simply want to check that an element is a member of a set or not, whether
    an object belongs to a certain group or not.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个包含唯一元素的集合，你只需要检查一个元素是否是集合的成员或不是，一个对象是否属于某个特定组时，你可以在你的程序中使用 `Set`。
- en: 'As we will return to our program code, we will see that the `UniqueGuesser`
    class has to implement an algorithm that checks that a color in a guess is present
    only once. This algorithm is the ideal candidate for a `Set` to be used:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回到程序代码时，我们会看到 `UniqueGuesser` 类必须实现一个算法，该算法检查猜测中的颜色只出现一次。这个算法是用于 `Set` 的理想候选：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code creates a set, which is empty when the method starts. After that, it
    checks for each color (notice the enhanced `for` loop over the array elements)
    if it was already present before. To do that, the code checks if the color is
    already in the set. If it is there, the guess is not unique as we have found a
    color that is present at least twice. If the color was not in the set, then the
    guess can still be unique in colors. To be able to detect that later, the code
    puts the color into the set.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个集合，当方法开始时它是空的。之后，它检查每个颜色（注意对数组元素的增强型 `for` 循环）是否之前已经存在。为了做到这一点，代码检查颜色是否已经在集合中。如果它在其中，那么猜测就不唯一，因为我们已经发现了一个至少出现两次的颜色。如果颜色不在集合中，那么猜测在颜色上仍然可以是唯一的。为了能够稍后检测到这一点，代码将颜色放入集合中。
- en: The actual implementation of `Set` that we will use is `HashSet`. In the JDK,
    there are many classes implementing the `Set` interface. The most widely used
    is `HashSet`, and it is also worth mentioning `EnumSet`, `LinkedHashSet`, and
    `TreeSet`. The last one also implements the `SortedSet` interface, so we will
    detail it there.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的 `Set` 的实际实现是 `HashSet`。在 JDK 中，有许多类实现了 `Set` 接口。最广泛使用的是 `HashSet`，也值得提一下
    `EnumSet`、`LinkedHashSet` 和 `TreeSet`。最后一个也实现了 `SortedSet` 接口，所以我们将在那里详细说明。
- en: To understand what `HashSet` (and later `HashMap`) are and how they work, we
    will have to discuss what hashes are. They play very important and central role
    in many applications. They do their job under the hood in the JDK but there are
    some very important constraints that programmers have to follow or else really
    weird and extremely hard to find bugs will make their life miserable. I dare to
    say that violation of the hash contract in `HashSet` and `HashMap` are the cause
    of the second most difficult to find bugs next to multithread issues.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 `HashSet`（以及稍后的 `HashMap`）是什么以及它们是如何工作的，我们必须讨论哈希是什么。它们在许多应用中扮演着非常重要和核心的角色。它们在
    JDK 的底层执行其工作，但程序员必须遵循一些非常重要的约束，否则会出现非常奇怪且极其难以发现的错误，这将使他们的生活变得痛苦。我敢说，违反 `HashSet`
    和 `HashMap` 中的哈希契约是仅次于多线程问题的第二难以发现的错误的原因。
- en: Thus, before going on with the different collection implementations, we will
    visit this topic. We are already one level deep from our example in this detour
    discussing collections and now we will go one level deeper. I promise this is
    the last in-depth level of detours.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在继续不同的集合实现之前，我们将探讨这个主题。我们已经在这个关于集合的偏离中深入了一层，现在我们将再深入一层。我保证这是最后一个深入的偏离层次。
- en: Hash functions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希函数
- en: A hash is a mathematical function that assigns a number to an element. Say you
    work at a university administration and you have to tell if Wilkinson is a student
    at your class. You can store the names on small papers in envelopes one for each
    starting letter. Instead of searching through the 10 thousand students, you can
    look at the papers in the envelope titled W. This very simple hash function assigns
    the first letter of the name to the name (or the ordinal number of the letter,
    as we said that a hash function results a number). This is not really a good hash
    function because it puts only a few elements, if any, into the envelope denoted
    X and many to A for example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一种数学函数，它将一个数字分配给一个元素。比如说你在大学行政部门工作，你需要判断Wilkinson是否是你们班的学生。你可以将名字写在小纸条上，然后放入信封中，每个信封对应一个首字母。这样，你就不需要搜索一万名学生，只需查看标题为W的信封中的纸条。这个非常简单的哈希函数将名字的第一个字母分配给该名字（或者说是字母的序号，因为我们说过哈希函数的结果是一个数字）。这并不是一个好的哈希函数，因为它只将少数几个元素（如果有的话）放入标记为X的信封中，而将许多元素放入例如A的信封中。
- en: A good hash function results each possible ordinal number with similar probability.
    In hash tables, we usually have more buckets (envelopes in the previous example)
    than the number of elements to be stored. Therefore, when an element is searched
    for, it is likely that there is only one element there. At least that is what
    we would like to have. If there are multiple elements in a single bucket, it is
    called collision. A good hash function has as little collisions as possible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的哈希函数以相似的概率将每个可能的序号分配给每个元素。在哈希表中，我们通常有比要存储的元素数量更多的桶（如前例中的信封）。因此，当搜索一个元素时，很可能只有一个元素在那里。至少这是我们希望得到的。如果单个桶中有多个元素，这被称为冲突。一个好的哈希函数具有尽可能少的冲突。
- en: For backward compatibility, there is a `Hashtable` class in the JDK. This was
    one of the first hash table implementations in Java right in the very first version,
    and as Java is backward compatible, it was not thrown away. The `Map` interface
    was introduced in version 1.2 only. `Hashtable` has many drawbacks and its use
    is not recommended. (Even the name is violating the Java naming conventions.)
    We do not discuss this class in this book. Whenever we talk about hash tables,
    it is referring to the actual array that is inside the implementation of `HashSet`,
    `HashMap`, or any other collection that uses some hash indexed table.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持向后兼容性，JDK中有一个`Hashtable`类。这是Java中第一个哈希表实现之一，就在第一个版本中，由于Java具有向后兼容性，它没有被丢弃。`Map`接口是在版本1.2中引入的。`Hashtable`有很多缺点，并且不建议使用。（甚至它的名字也违反了Java的命名约定。）我们在这本书中不讨论这个类。当我们谈论哈希表时，它指的是`HashSet`、`HashMap`或任何使用某种哈希索引表的集合实现中的实际数组。
- en: Hash tables are arrays that use the result of the hash function to index the
    array. Usually, linked lists manage collisions. Hash table implementations also
    implement a strategy to resize the array when the number of elements to be stored
    becomes too high and the likelihood of collisions increase. This operation may
    take considerable time and, during this, the individual elements are moved between
    the buckets.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是使用哈希函数的结果来索引数组的数组。通常，链表管理冲突。哈希表实现还实现了一种策略，当要存储的元素数量变得过高且冲突的可能性增加时，调整数组的大小。这个操作可能需要相当长的时间，在此期间，各个元素会在桶之间移动。
- en: 'During this operation, the hash table cannot reliably be used and this may
    be some source of issues in a multithread environment. In single thread code,
    you do not meet this problem. When you call the `add` method, the hash table (set
    or map) decides that the table has to be resized. The `add` method calls the resizing
    method and does not return until it is finished. Single thread code has no possibility
    to use the hash table during this period: the one and single thread is executing
    the resizing itself. In a multithread environment, however...'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作过程中，哈希表无法可靠地使用，这可能是多线程环境中出现问题的来源之一。在单线程代码中，你不会遇到这个问题。当你调用`add`方法时，哈希表（集合或映射）决定表需要调整大小。`add`方法调用调整大小的方法，并且直到完成才返回。单线程代码在这个期间没有可能使用哈希表：唯一的一条线程正在执行调整大小操作。在多线程环境中，然而...
- en: '`HashSet` and `HashMap` use the hash function provided by the `Object` that
    is stored in the collection. The `Object` class implements the `hashCode` and
    `equals` methods. You can override them and if you do, you should override both
    in a consistent manner. First, we will see what they are and then how to override
    them consistently.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet` 和 `HashMap` 使用存储在集合中的 `Object` 提供的哈希函数。`Object` 类实现了 `hashCode` 和
    `equals` 方法。您可以覆盖它们，如果您这样做，应该以一致的方式覆盖它们。首先，我们将了解它们是什么，然后了解如何一致地覆盖它们。'
- en: Method equals
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`equals` 方法'
- en: The documentation of set says "sets contain no pair of elements `e1` and `e2`
    such that `e1.equals`(`e2`)". The `equals` method returns `true` if the `e1` and
    `e2` are in some way equal. It may be different from two objects being identical.
    There can be two distinct objects that are equal. For example, we could have a
    color implementation that has the name of the colors as an attribute and two color
    objects may return true calling the `equals` method on one of them and passing
    the argument as the other when the two strings are equal. The default implementation
    of the `equals` method is in the code of the `Object` class and this returns `true`
    if and only if `e1` and `e2` are exactly the same and single object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的文档说明“集合不包含任何元素对 `e1` 和 `e2`，使得 `e1.equals(e2)`”。`equals` 方法返回 `true` 如果 `e1`
    和 `e2` 以某种方式相等。它们可能不同于两个完全相同的对象。可能存在两个不同的对象相等。例如，我们可以有一个颜色实现，其中颜色的名称作为属性，当两个字符串相等时，两个颜色对象在其中一个上调用
    `equals` 方法并将另一个作为参数传递，它们会返回 `true`。`equals` 方法的默认实现位于 `Object` 类的代码中，并且仅在 `e1`
    和 `e2` 完全相同且是单个对象时返回 `true`。
- en: 'It seems to be obvious, but my experience shows that it cannot be stressed
    enough that the implementation of equals in an object has to be as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来很明显，但我的经验表明，强调对象中 `equals` 的实现必须如下所示是不够的：
- en: '**Reflexive**: This means that an object that always equals itself'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自反性**：这意味着一个始终等于自身的对象'
- en: '**Symmetric** (commutative): This means if `e1.equals(e2)` is `true`, then
    `e2.equals(e1)` should also be `true`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称性**（交换性）：这意味着如果 `e1.equals(e2)` 为 `true`，则 `e2.equals(e1)` 也应该是 `true`'
- en: '**Transitive**: This means if `e1.equals(e2)` and `e2.equals(e3)`, then `e1.equals(e3)`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传递性**：这意味着如果 `e1.equals(e2)` 和 `e2.equals(e3)`，则 `e1.equals(e3)`'
- en: '**Consistent**: This means that the return value should not change if the objects
    were not changed between the invocations'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这意味着如果对象在调用之间未被更改，则返回值不应改变'
- en: Method hashCode
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`hashCode` 方法'
- en: 'The `hashCode` method returns an `int`. The documentation says that any class
    redefining this method should provide the following implementation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashCode` 方法返回一个 `int`。文档说明，任何重新定义此方法的类都应该提供以下实现：'
- en: Consistently return the same value if the object was not modified
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象未被修改，则始终返回相同的值
- en: Result the same `int` value for two objects that are equal (the `equals` method
    returns `true`)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两个相等的对象返回相同的 `int` 值（`equals` 方法返回 `true`）
- en: The documentation also mentions that this is not a requirement to result different
    `int` values for objects that are not equal, but it is desirable to support the
    performance of the hash implementing collections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文档还提到，这不是为不相等的对象返回不同的 `int` 值的要求，但支持实现哈希集合的性能是可取的。
- en: If you violate any of these rules in the implementation of `equals` and `hashCode`,
    then the JDK classes using them will fail. As you can be sure that `HashSet`,
    `HashMap`, and similar classes were fully debugged, seeing that you added an object
    to a set and then the set reporting that it is not there will be a bewildering
    experience. However, only until you find out that the two objects being equal
    and stored in the set have different `hashCode` values, `HashSet` and `HashMap`
    will look for the object only in the bucket that is indexed by the `hashCode`
    value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `equals` 和 `hashCode` 的实现中违反了这些规则中的任何一个，那么使用它们的 JDK 类将失败。您可以确信 `HashSet`、`HashMap`
    和类似类已经完全调试过，看到您向集合中添加了一个对象，然后集合报告它不在那里将会是一个令人困惑的经历。然而，只有当您发现存储在集合中的两个相等的对象具有不同的
    `hashCode` 值时，`HashSet` 和 `HashMap` 才会在由 `hashCode` 值索引的桶中查找对象。
- en: It is also a common mistake to store an object in a `HashSet` or `HashMap` and
    then modify it. The object is in the collection but you cannot find it because
    the `hashCode` returns a different value. Objects stored in a collection should
    not be modified unless you know what you are doing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 也将是一个常见的错误，将对象存储在`HashSet`或`HashMap`中，然后修改它。对象在集合中，但你找不到它，因为`hashCode`返回不同的值。存储在集合中的对象不应该被修改，除非你知道你在做什么。
- en: Many times, objects contain fields that are not interesting from the equality
    point of view. The `hashCode` and `equals` methods should be idempotent to those
    fields and you can alter those fields even after storing the object in a `HashSet`
    or in `HashMap`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，对象包含从相等性角度来看不感兴趣的字段。`hashCode`和`equals`方法应该对这些字段是幂等的，你甚至可以在将对象存储在`HashSet`或`HashMap`之后修改这些字段。
- en: As an example, you may administer triangles in objects maintaining the coordinates
    of the vertices and the color of the triangle. However, you do not care about
    the color for equality, only that the two triangles are at the exact same location
    in the space. In that case, the `equals` and `hashCode` method should not take
    the field color into account. This way, we can paint our triangles; they will
    still be found in `HashSet` or `HashMap` no matter what the color field is.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能在对象中管理三角形的顶点坐标和三角形的颜色。然而，你并不关心颜色用于相等性，只关心两个三角形在空间中的位置是否完全相同。在这种情况下，`equals`和`hashCode`方法不应考虑字段颜色。这样，我们可以给我们的三角形上色；无论颜色字段是什么，它们仍然可以在`HashSet`或`HashMap`中找到。
- en: Implementing equals and hashCode
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`equals`和`hashCode`
- en: Implementing these methods is fairly simple. As this is a very common task,
    the IDEs support the generation of these methods. These methods are tied together
    so much that the menu items in the IDEs are not separate; they offer you to generate
    these methods at once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些方法相当简单。由于这是一个非常常见的任务，IDE支持生成这些方法。这些方法紧密相连，以至于IDE中的菜单项不是分开的；它们提供一次性生成这些方法。
- en: 'Asking the IDE to generate the `equals` method will result in something like
    the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要求IDE生成`equals`方法将产生如下代码：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For this sample, we have three `Object` fields named `field1`, `field2`, and
    `field3`. The code with any other types and fields will look very similar.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们有三个名为`field1`、`field2`和`field3`的`Object`字段。任何其他类型和字段的代码看起来非常相似。
- en: First, the method checks for object identity. One `Object` always `equals` itself.
    If the reference passed as argument is `null` and not an object, or they are of
    different class, then this generated method will return false. In other cases,
    the static method of the class `Objects` (note the plural) will be used to compare
    each of the fields.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该方法检查对象身份。一个`Object`总是`equals`自身。如果作为参数传递的引用是`null`且不是对象，或者它们属于不同的类，那么这个生成的方法将返回`false`。在其他情况下，将使用类的静态方法`Objects`（注意复数形式）来比较每个字段。
- en: The utility class `Objects` was introduced in Java 7, hence the name of the
    sample class. The static methods, `equals` and `hash`, support the override of
    the `Object equals` and `hashCode` methods. The `hashCode` creation before Java
    7 was fairly complex and required the implementation of modulo arithmetic with
    some magic numbers that is hard to explain just looking at the code without knowing
    the mathematics behind it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 实用类`Objects`是在Java 7中引入的，因此示例类的名称。静态方法`equals`和`hash`支持覆盖`Object equals`和`hashCode`方法。在Java
    7之前创建`hashCode`相当复杂，需要实现带有一些难以仅通过查看代码而不了解其背后的数学原理的魔数模运算。
- en: This complexity is now hidden behind the following `Objects.hash` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂性现在被隐藏在下面的`Objects.hash`方法之后。
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The generated method simply calls the `Objects.hash` method passing the important
    fields as arguments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的简单方法调用`Objects.hash`方法，并将重要字段作为参数传递。
- en: HashSet
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashSet
- en: Now, we know essentially a lot of things about hashes so we can bravely discuss
    the `HashSet` class. `HashSet` is an implementation of the `Set` interface that
    internally uses hash table. Generally, that is it. You store objects there and
    you can see if an object is already there or not. When there is a need for a `Set`
    implementation, almost always `HashSet` is the choice. Almost...
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们基本上对哈希了解很多，因此我们可以大胆地讨论`HashSet`类。`HashSet`是实现`Set`接口的类，内部使用哈希表。一般来说，就是这样。你将对象存储在那里，你可以看到对象是否已经存在。当需要`Set`实现时，几乎总是选择`HashSet`。几乎...
- en: EnumSet
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举集
- en: '`EnumSet` can contain elements from a certain enumeration. Recall that enumerations
    are classes that have fixed a number of instances declared inside the `enum` itself.
    As this limits the number of the different object instances, and this number is
    known during compilation time, the implementation of the `EnumSet` code is fairly
    optimized. Internally, `EnumSet` is implemented as a bit field and is a good choice
    where bit field manipulations can be used.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnumSet` 可以包含来自某个枚举的元素。回想一下，枚举是声明在 `enum` 内部的固定数量实例的类。由于这限制了不同对象实例的数量，并且这个数量在编译时是已知的，因此
    `EnumSet` 代码的实现相当优化。内部，`EnumSet` 被实现为一个位字段，并且当可以使用位字段操作时是一个很好的选择。'
- en: LinkedHashSet
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LinkedHashSet
- en: '`LinkedHashSet` is a `HashSet` that also maintains a doubly linked list of
    the elements it holds. When we iterate though a `HashSet`, there is no guaranteed
    order of the element. When the `HashSet` is modified, the new elements are inserted
    into one of the buckets and, possibly, the hash table gets resized. This means
    that the elements get rearranged and get into totally different buckets. Iteration
    over the elements in `HashSet` just takes the buckets and the elements in it in
    some order that is arbitrary from the caller point of view.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedHashSet` 是一个 `HashSet`，同时维护了一个包含其元素的循环链表。当我们遍历一个 `HashSet` 时，元素没有保证的顺序。当
    `HashSet` 被修改时，新元素会被插入到一个桶中，并且可能需要调整哈希表的大小。这意味着元素会被重新排列，并进入完全不同的桶中。在 `HashSet`
    中遍历元素只是按照某种任意顺序取桶及其中的元素。'
- en: '`LinkedHashSet`, however, iterates over the elements using the linked list
    it maintains and the iteration is guaranteed to happen in the order the elements
    were inserted.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`LinkedHashSet` 使用它维护的链表遍历元素，并且遍历保证按照元素插入的顺序进行。
- en: SortedSet
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SortedSet
- en: The `SortedSet` is an interface that guarantees that the classes implementing
    it will iterate over the set in a sorted order. The order may be the natural ordering
    of the objects if the objects implement the `Comparable` interface or a `Comparator`
    object may drive it. This object should be available when the instance of the
    class implementing the `SortedSet` is created; in other words, it has to be a
    constructor parameter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedSet` 是一个接口，它保证实现它的类将按排序顺序遍历集合。顺序可能是如果对象实现了 `Comparable` 接口，则为对象的自然排序；或者可能由一个
    `Comparator` 对象驱动。当创建实现 `SortedSet` 的类的实例时，应该提供这个对象；换句话说，它必须是构造函数的参数。'
- en: NavigableSet
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NavigableSet
- en: '`NavigableSet` extends the `SortedSet` interface with methods that let you
    do proximity search in the set. This essentially lets you search for an element
    that is in the search and is less than the searched object, less or equal to the
    searched element, greater or equal, or greater than the searched object.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigableSet` 扩展了 `SortedSet` 接口，提供了允许你在集合中进行邻近搜索的方法。这实际上允许你搜索一个在搜索中且小于被搜索对象的元素，小于或等于被搜索元素，大于或等于，或大于被搜索对象。'
- en: TreeSet
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TreeSet
- en: '`TreeSet` is an implementation of `NavigableSet` and, this way this is also
    a `SortedSet` and, as a matter of fact, is also a `Set.` As a `SortableSet` documentation
    implies there are two types of the constructors, each having multiple versions
    though. One requires some `Comparator`, the other one relies on the natural ordering
    of the elements.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeSet` 是 `NavigableSet` 的一个实现，因此它也是一个 `SortedSet`，实际上也是一个 `Set`。根据 `SortableSet`
    文档的说明，有两种类型的构造函数，尽管每种都有多个版本。一种需要一些 `Comparator`，另一种则依赖于元素的默认排序。'
- en: List
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: List
- en: '`List` is an interface that requires implementing class to keep track of the
    order of the elements. There are also methods that access an element by index
    and iteration defined by the `Collection` interface that guarantees the order
    of the elements. The interface also defines the `listIterator` method that returns
    an `Iterator` also implementing the `ListIterator` interface. This interface provides
    methods that let the caller insert elements to the list while iterating through
    it and also going back and forth in the iteration. It is also possible to search
    for a certain element in the `List` but most implementations of the interface
    provide poor performance while the searching is simply going through all elements
    until the element searched for is found. There are many classes implementing this
    interface in the JDK. Here, we will mention two.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`是一个接口，要求实现类跟踪元素的顺序。还有通过索引访问元素和由`Collection`接口定义的迭代定义的方法，该接口保证了元素的顺序。该接口还定义了`listIterator`方法，该方法返回一个实现`ListIterator`接口的`Iterator`。此接口提供了允许调用者在迭代列表的同时插入元素的方法，也可以在迭代中前后移动。在`List`中搜索特定元素也是可能的，但大多数实现接口的接口在搜索时提供较差的性能，因为搜索只是简单地遍历所有元素，直到找到要搜索的元素。在JDK中有许多实现此接口的类。在这里，我们将提到两个。'
- en: LinkedList
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LinkedList
- en: This is a doubly-linked list implementation of the List interface that has a
    reference to the previous, and also to the next element in the list for each element.
    The class also implements the `Deque` interface. It is fairly cheap to insert
    or delete an element from the list because it needs only the adjustment of few
    references. On the other hand, the access to an element by index will need iteration
    from the start of the list, or from the end of the list, whichever is closer to
    the specified indexed element.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个双向链表实现的List接口，每个元素都有一个指向列表中前一个元素和后一个元素的引用。该类还实现了Deque接口。从列表中插入或删除元素相对便宜，因为它只需要调整少数几个引用。另一方面，通过索引访问元素将需要从列表的开始迭代，或者从列表的末尾迭代，
    whichever is closer to the specified indexed element。
- en: ArrayList
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayList
- en: This class is an implementation of the `List` interface that keeps the references
    to the elements in an array. That way, this is fairly fast to access an element
    by index. On the other hand, inserting an element to `ArrayList` can be costly.
    It needs moving all references above the inserted element one index higher, and
    it may also require resizing the backing array in case there is no room in the
    original one to store the new element. Essentially, this means allocating a new
    array and copying all references to it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是实现`List`接口的类，它将元素的引用存储在数组中。这样，通过索引访问元素相对较快。另一方面，向`ArrayList`插入元素可能代价高昂。它需要将插入元素以上的所有引用向上移动一个索引，并且如果原始数组中没有空间存储新元素，可能还需要调整底层数组的大小。本质上，这意味着分配一个新的数组并将所有引用复制到它上面。
- en: The reallocation of the array may be optimized if we know how large the array
    will grow and call the `ensureCapacity` method. This will resize the array to
    the size provided as argument, even if the currently used slots are less numbered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道数组将如何增长，我们可以调用`ensureCapacity`方法来优化数组的重新分配。这将根据提供的参数大小调整数组的大小，即使当前使用的槽位数量较少。
- en: My experience is that novice programmers use `ArrayList` when they need a list
    without considering the algorithmic performance of the different implementations.
    I do not actually know why there is this popularity of `ArrayList`. The actual
    implementation used in a program should be based on proper decision and not habit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我的经验是，新手程序员在需要列表而不考虑不同实现算法性能的情况下使用`ArrayList`。我实际上不知道为什么`ArrayList`会有这种流行度。程序中实际使用的实现应该基于正确的决策，而不是习惯。
- en: Queue
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Queue
- en: Queue is a collection that usually stores element for later use. You can put
    elements into a queue and you can pull them out. An implementation may specify
    the given order, that may be **first in first out** (**FIFO**) or **last in first
    out** (**LIFO**) or some priority based ordering.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一个通常存储元素以供以后使用的集合。你可以将元素放入队列中，也可以将它们取出。实现可能指定给定的顺序，可能是**先进先出**（**FIFO**）或**后进先出**（**LIFO**）或基于优先级的排序。
- en: On a queue, you can invoke the `add` method to add an element, `remove` to remove
    the head element, and the `element` method to access the head element without
    removing it from the queue. The `add` method will throw an exception when there
    is a capacity problem and the element cannot be added to the queue. When the queue
    is empty, and there is no head element, the `element` and `remove` methods throw
    exception.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中，你可以调用 `add` 方法添加元素，`remove` 方法移除头元素，以及 `element` 方法访问头元素而不从队列中移除它。当存在容量问题时，`add`
    方法将抛出异常，并且元素无法添加到队列中。当队列空时，没有头元素，`element` 和 `remove` 方法将抛出异常。
- en: As exceptions can only be used in exceptional cases, and the calling program
    may handle these situations in the normal course of the code, thus all these methods
    have a version that just return some special value signaling the situation. Instead
    of `add`, a caller may call `offer` to offer an element for storage. If the queue
    cannot store the element, it will return `false`. Similarly, `peek` will try to
    get access to the head element or return `null` if there is none, and `poll` will
    remove and return the head element or just return `null` if there is none.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异常只能在异常情况下使用，并且调用程序可能在代码的正常流程中处理这些情况，因此所有这些方法都有一个只返回一些特殊值的版本，以表示这种情况。而不是 `add`，调用者可以调用
    `offer` 来存储元素。如果队列无法存储元素，它将返回 `false`。同样，`peek` 将尝试获取头元素或在没有头元素时返回 `null`，而 `poll`
    将移除并返回头元素，如果没有头元素则只返回 `null`。
- en: Note that these methods returning `null` just make the situation ambiguous when
    the implementation, such as `LinkedList`, allows `null` elements. Never store
    a `null` element in a queue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些返回 `null` 的方法在实现，例如 `LinkedList` 允许 `null` 元素时，只会使情况变得模糊不清。永远不要在队列中存储 `null`
    元素。
- en: Deque
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deque
- en: '`Deque` is an interface which is a double-ended queue. It extends the `Queue`
    interface with the methods that allow access to both ends of the queue to add,
    look at, and remove elements from both ends.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deque` 是一个双端队列的接口。它通过提供访问队列两端的方法扩展了 `Queue` 接口，这些方法允许从两端添加、查看和移除元素。'
- en: For the `Queue` interface we needed six methods. `Dequeue` having two manageable
    ends needs 12 methods. Instead of `add` we have `addFirst` and `addLast`. Similarly
    we can `offerFirst`, `offerLast` as well as `peekFirst`, `peekLast` and `pollFirst`,
    `pollLast`. For some reason the methods that implement the functionality of the
    `element` method on `Queue` are named `getFirst` and `getLast`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Queue` 接口，我们需要六个方法。具有两个可管理端点的 `Dequeue` 需要 12 个方法。我们不是 `add`，而是有 `addFirst`
    和 `addLast`。同样，我们还可以 `offerFirst`、`offerLast` 以及 `peekFirst`、`peekLast` 和 `pollFirst`、`pollLast`。由于某种原因，实现
    `Queue` 上 `element` 方法功能的方法被命名为 `getFirst` 和 `getLast`。
- en: Since this interface extends the `Queue` interface the methods defined there
    can also be used to access the head of the queue. In addition to these this interface
    also defines the methods `removeFirstOccurrence` and `removeLastOccurrence` that
    can be used to remove a specific element inside the queue. We cannot specify the
    index of the element to remove and we also cannot access an element based on index.
    The `removeFirst`/`LastOccurrence` methods' argument is the object that is to
    be removed. If we need this functionality we can use `Deque` even if we add and
    remove elements from the same end of the queue.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个接口扩展了 `Queue` 接口，因此也可以使用那里定义的方法来访问队列的头。除了这些，这个接口还定义了 `removeFirstOccurrence`
    和 `removeLastOccurrence` 方法，可以用来在队列内部移除特定元素。我们无法指定要移除元素的索引，也无法根据索引访问元素。`removeFirst`/`LastOccurrence`
    方法的参数是要移除的对象。如果我们需要这个功能，即使从队列的同一边添加和移除元素，我们也可以使用 `Deque`。
- en: Why are there these methods in `Deque` and not in `Queue`? These methods have
    nothing to do with double headedness of `Deque`. The reason is that methods cannot
    be added to interfaces after they were released. If we add a method to an interface
    we break the backward compatibility because all classes that implement that interface
    have to implement the new method. Java 8 introduced default methods that eased
    this constraint, but the `Queue` interface was defined in Java 1.5 and the `Deque`
    interface was defined in Java 1.6\. There was no way at that time to add the new
    methods to the already existing interfaces.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `Deque` 中有这些方法，而 `Queue` 中没有？这些方法与 `Deque` 的双头特性无关。原因是方法不能在接口发布后添加。如果我们向接口添加一个方法，就会破坏向后兼容性，因为所有实现该接口的类都必须实现新方法。Java
    8 引入了默认方法，这放宽了这一限制，但 `Queue` 接口是在 Java 1.5 中定义的，而 `Deque` 接口是在 Java 1.6 中定义的。当时没有方法可以将新方法添加到已经存在的接口中。
- en: Map
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map
- en: A `Map` pairs keys and values. If we want to approach a `Map` from the `Collection`
    point of view then a `Map` is a set of key/value pairs. You can put key value
    pairs into a `Map` and you can get a value based on a key. Keys are unique the
    same way as elements in a `Set`. If you look at the source code of the different
    implementations of the `Set` interface, you may see that some of them are implemented
    as a wrapper around a `Map` implementation where the values are simply discarded.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`将键和值配对。如果我们想从`Collection`的角度来接近`Map`，那么`Map`是一组键/值对。你可以将键值对放入`Map`中，并且可以根据键获取值。键是唯一的，就像`Set`中的元素一样。如果你查看`Set`接口的不同实现的源代码，你可能会看到其中一些是作为`Map`实现的包装实现的，其中值被简单地丢弃。'
- en: Using `Map`s is easy and alluring. Many languages, such as Python, Go, JavaScript,
    Perl, and so on, support this data structure on the language level. However, using
    a Map when an array would be sufficient is a bad practice that I have seen many
    times, especially in scripting languages. Java is not prone to that novice programmer
    error but you may still find yourself in a situation when you want to use a Map,
    and still there is a better solution. It is a general rule that the simplest data
    structure should be used that is sufficient for the implementation of the algorithm.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Map`既简单又吸引人。许多语言，如Python、Go、JavaScript、Perl等，在语言级别上支持这种数据结构。然而，当数组足以满足需求时使用`Map`是一种不良实践，我见过很多次，尤其是在脚本语言中。Java不太容易犯这种新手程序员的错误，但你可能仍然会遇到想要使用`Map`的情况，而且仍然有更好的解决方案。一个普遍的规则是，应该使用最简单的数据结构来实现算法。
- en: HashMap
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashMap
- en: '`HashMap` is a hash table based implementation of the `Map` interface. As the
    map is based on a hash table, the basic `put` and `get` methods are performed
    in constant time. Additionally, as Map is very important, and because the most
    frequently used implementation in the JDK is `HashMap`, the implementation is
    fairly configurable. You can instantiate `HashMap` using the default constructor
    without argument, but there is also a constructor that defines the initial capacity
    and the load factor.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap`是`Map`接口的基于哈希表的实现。由于映射基于哈希表，基本的`put`和`get`方法是在常数时间内执行的。此外，由于`Map`非常重要，并且因为JDK中最常用的实现是`HashMap`，所以实现相当可配置。你可以使用不带参数的默认构造函数来实例化`HashMap`，但还有一个构造函数可以定义初始容量和加载因子。'
- en: IdentityHashMap
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IdentityHashMap
- en: '`IdentityHashMap` is a special `Map` that implements the `Map` interface literally,
    but as a matter of fact, it violates the contract the `Map` interface documentation
    defines. It does it with good reason. The implementation uses a hash table just
    as `HashMap`, but to decide the equality of the key found in the bucket comparing
    with the key element provided as argument to the get method it uses `Object` reference
    (`==` operator) and not the method `equals`, which is required by documentation
    of `Map` interface.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdentityHashMap`是一个特殊的`Map`，它直接实现了`Map`接口，但实际上它违反了`Map`接口文档中定义的契约。它这样做是有充分理由的。该实现使用哈希表，就像`HashMap`一样，但在决定桶中找到的键与作为get方法参数提供的键元素是否相等时，它使用`Object`引用（`==`运算符）而不是`equals`方法，这是`Map`接口文档所要求的。'
- en: The use of this implementation is reasonable when we want to distinguish different
    `Object` instances as keys that otherwise equal to each other. Using this implementation
    for performance reasons is almost certainly a wrong decision. Also, note that
    there is no `IdentityHashSet` implementation in the JDK. Probably such collection
    is so rarely used that its existence in the JDK would cause more harm than good
    alluring novice programmers to misuse.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要区分不同`Object`实例作为键，而这些键在其他情况下是相等的，使用这种实现是合理的。出于性能原因使用这种实现几乎肯定是一个错误的决定。此外，请注意，JDK中没有`IdentityHashSet`实现。可能这样的集合很少使用，它的存在在JDK中可能会造成比好处更多的伤害，吸引新手程序员误用。
- en: Dependency injection
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In the previous chapter we briefly already discussed **dependency injection**
    (**DI**). Now we will dig into it a bit more detail.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要地讨论了**依赖注入**（**DI**）。现在我们将更深入地探讨它。
- en: Objects usually do not work on their own. Most of the time the implementation
    depends on the services of other classes. When we want to write something to the
    console we use the `System` class. When we manage the table of guesses we need
    `Color` objects and `ColorManager`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对象通常不会独立工作。大多数时候，实现依赖于其他类的服务。当我们想要向控制台写入内容时，我们使用`System`类。当我们管理猜测表时，我们需要`Color`对象和`ColorManager`。
- en: In case of writing to the console we may not realize the dependency because
    the class being part of the JDK class library is available all the time and all
    we need to do is to write `System.out.println`. In this case this dependency is
    wired into the code. We cannot send the output somewhere else unless we change
    the code. This is not too flexible and in many cases we need a solution that can
    work with different output, different color manager or different whatever service
    our code depends on. The first step to do that is to have a field that has a reference
    of the object that gives our class the service. In case of output the type of
    the field can be of type `OutputStream`. The next, more interesting step is how
    this field gets value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在向控制台写入的情况下，我们可能没有意识到这种依赖，因为作为JDK类库的一部分的类始终可用，我们只需要编写`System.out.println`。在这种情况下，这种依赖已经通过代码连接。除非我们更改代码，否则我们无法将输出发送到其他地方。这并不太灵活，在许多情况下，我们需要一个可以与不同输出、不同颜色管理器或不同服务（我们的代码依赖于这些服务）一起工作的解决方案。为此，第一步是有一个字段，该字段包含一个引用对象，该对象为我们类提供服务。在输出方面，该字段的类型可以是`OutputStream`类型。接下来，更有趣的一步是如何获取这个字段的值。
- en: One of the solution is to use DI. In this approach some external code prepares
    the dependencies and injects them into the object. When the first call to a method
    of the class is issued all the dependencies are already filled and ready to be
    used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种解决方案是使用DI。在这种方法中，一些外部代码准备依赖关系并将它们注入到对象中。当首次调用类的方法时，所有依赖关系都已填充并准备好使用。
- en: 'In this structure, we have four different players:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，我们有四个不同的参与者：
- en: The client object is the one that gets the injected service objects during the
    process
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端对象是在过程中获取注入服务对象的那个对象
- en: Service object or objects are injected into the client object
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务对象或对象被注入到客户端对象中
- en: Injector is the code that performs the injection
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入器是执行注入的代码
- en: Interfaces define the service that the client needs
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口定义了客户端需要的服务
- en: If we move the logic of the creation of the service objects from the client
    code the code becomes shorter and cleaner. The actual competency of the client
    class should hardly ever cover the creation of the service objects. For example
    a `Game` class contains a `Table` instance but a game is not responsible to create
    the `Table`. It is given to it to work with it, just as in real life that we model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将服务对象的创建逻辑从客户端代码中移除，代码就会变得更短、更干净。客户端类的实际能力几乎不应该包括服务对象的创建。例如，一个`Game`类包含一个`Table`实例，但游戏并不负责创建`Table`。它被赋予它来与之工作，就像我们在现实生活中所模拟的那样。
- en: The creation of service objects is sometimes as simple as issuing the `new`
    operator. Sometimes service objects also depend on other service objects and that
    way also act as clients in the process of dependency injection. In this case the
    creation of the service objects may be a lot of lines. The structure of the dependencies
    can be expressed in a declarative fashion that describes which service object
    needs which other service objects and also what implementation of the service
    interfaces are to be used. Dependency injection injectors work with such declarative
    descriptions. When there is a need for an object that needs service objects that
    themselves need again other service objects the injector creates the service instances
    in the appropriate order using the implementations that are matching the declarative
    descriptions. The injector discovers all the dependencies transitively and creates
    a transitive closure graph of the dependencies.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对象的创建有时就像使用`new`运算符一样简单。有时服务对象也依赖于其他服务对象，因此也在依赖注入过程中充当客户端。在这种情况下，服务对象的创建可能需要很多行代码。依赖的结构可以用声明式的方式表达，描述了哪些服务对象需要哪些其他服务对象，以及要使用哪些服务接口的实现。依赖注入注入器与这种声明性描述一起工作。当需要这样一个对象，该对象本身需要其他服务对象时，注入器会按照匹配声明性描述的实现顺序创建服务实例。注入器发现所有依赖关系，并创建依赖关系的传递闭包图。
- en: The declarative description of the needed dependencies can be XML, or a special
    language developed especially for the dependency injection or it can even be Java
    itself using specially designed fluent API ([https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/)).
    XML was first used in **DI** injectors. Later **Groovy** based **Domain Specific
    Language** ([https://martinfowler.com/books/dsl.html](https://martinfowler.com/books/dsl.html))
    came into picture and Java fluent API approach. We will use only the last one
    being the most modern and we will use **Spring** and **Guice****DI** containers
    since they are the most well-known injector implementations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的依赖项的声明性描述可以是XML，或者为依赖注入特别开发的语言，甚至可以使用特别设计的Java流畅API（[https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/))。XML最初用于**DI**注入器。后来，基于**Groovy**的**领域特定语言**（[https://martinfowler.com/books/dsl.html](https://martinfowler.com/books/dsl.html)）和Java流畅API方法出现。我们将只使用最后一种，因为它是最现代的，我们将使用**Spring**和**Guice****DI**容器，因为它们是最知名的注入器实现。
- en: Implementing the game
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏实现
- en: Collections without examples are boring. Fortunately, we have our game where
    we use a few collection classes and also other aspects that we will examine in
    this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 没有示例的集合是无聊的。幸运的是，我们有一个游戏，我们在其中使用了一些集合类，以及我们将在本章中检查的其他方面。
- en: ColorManager
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ColorManager
- en: 'We jumped into the pool filled with collection classes from the implementation
    of the `ColorManager` class. Let''s refresh the part of the class that is interesting
    for us now—the constructor:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`ColorManager`类的实现中跳入了充满集合类的泳池。现在让我们回顾一下对我们来说有趣的类部分——构造函数：
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will use `HashMap` to keep the colors in an ordered list. At first, the
    choice of `HashMap` seems to be strange. Very true, that during the coding of
    `ColorManager`, I also considered a `List`, which seemed to be a more obvious
    choice. When we have a `List<Color> colors` variable, then the `nextColor` method
    is something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`HashMap`来保持颜色的有序列表。起初，选择`HashMap`看起来很奇怪。确实如此，在编写`ColorManager`代码时，我也考虑了`List`，这似乎是一个更明显的选择。当我们有一个`List<Color>
    colors`变量时，那么`nextColor`方法就像这样：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The constructor will be much simpler, as shown in the following piece of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将非常简单，如下所示的一段代码：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Why did I choose the more complex solution and the unobvious data structure?
    The thing is performance. When the `nextColor` method is invoked, the list implementation
    first finds the element checking all the elements in the list and then fetches
    the next element. The time is proportional to the number of colors. When our number
    of colors increases, the time will also increase to just get the next color having
    one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么选择了更复杂且不明显的解决方案？原因在于性能。当调用`nextColor`方法时，列表实现首先找到元素，检查列表中的所有元素，然后获取下一个元素。所需时间是颜色数量的比例。当颜色数量增加时，获取下一个颜色所需的时间也会增加，仅仅是为了得到一个颜色。
- en: 'At the same time, if we focus on not the data structure that comes from the
    verbal expression of the task we want to solve (get the colors in a sorted order)
    but rather focus on the actual method that we want to implement, `nextColor(Color)`,
    then we will easily come to the conclusion that a `Map` is more reasonable. What
    we need is exactly a `Map` : having one element we want another related to the
    one we have. The key and the value is also `Color`. Getting the next element is
    constant time using `HashMap`. This implementation is probably faster than the
    one based on `ArrayList`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果我们关注的是不是来自我们想要解决的问题的口头表达的数据结构（按排序顺序获取颜色），而是关注我们想要实现的实际方法`nextColor(Color)`，那么我们很容易得出结论，`Map`更合理。我们需要的正是`Map`：有一个元素我们想要另一个与之相关的元素。键和值也是`Color`。使用`HashMap`获取下一个元素是常数时间。这种实现可能比基于`ArrayList`的实现更快。
- en: The problem is that it is only probably faster. When you consider refactoring
    a code to have better performance, your decision should always be based on measurements.
    If you implement a code that you only think is faster, practice shows, you will
    fail. In best case, you will optimize a code to be blazing fast and runs during
    the application server setup. At the same time, optimized code is usually less
    readable. Something for something.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于它可能只是更快一点。当你考虑重构代码以获得更好的性能时，你的决定应该始终基于测量。如果你实现了一个你认为更快的代码，实践表明，你会失败。在最好的情况下，你将优化代码以使其非常快，并在应用程序服务器设置期间运行。同时，优化后的代码通常可读性较差。有所得必有所失。
- en: Optimization should never be done prematurely. Code for readability first. Then,
    assess the performance, and in case there is problem with the performance, then
    profile the execution and optimize the code where it hurts the most of the overall
    performance. Micro-optimizations will not help.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 优化永远不应该过早进行。首先编写易于阅读的代码。然后，评估性能，如果性能存在问题，那么分析执行情况，并在对整体性能影响最大的地方优化代码。微优化不会有所帮助。
- en: Did I do premature optimization selecting the `HashMap` implementation instead
    of `List`? If I actually implemented the code using `List` and then refactored,
    then yes. If I was thinking about the `List` solution and then it came to me that
     `Map` solution is better without prior coding, then I did not. By years, such
    considerations will come easier, as you will also experience.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我在选择了`HashMap`实现而不是`List`时是否过早进行了优化？如果我真的使用了`List`来实现代码然后进行了重构，那么是的。如果我在考虑`List`解决方案时，后来想到`Map`解决方案更好，而没有先进行编码，那么我没有。经过多年的经验，这样的考虑会更容易，因为你也会经历。
- en: The class color
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类颜色
- en: 'We have already looked at the code for the class code and it was the simplest
    class in the world. In reality, as it is in the GitHub repository ([https://github.com/j9be/chapter04](https://github.com/j9be/chapter04) or
    [https://github.com/PacktPublishing/Java-9-Programming-By-Example/tree/master/Chapter04](https://github.com/PacktPublishing/Java-9-Programming-By-Example/tree/master/Chapter04)),
    the code is a bit more complex:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看过类代码的代码，它是世界上最简单的类。实际上，正如GitHub仓库([https://github.com/j9be/chapter04](https://github.com/j9be/chapter04)或[https://github.com/PacktPublishing/Java-9-Programming-By-Example/tree/master/Chapter04](https://github.com/PacktPublishing/Java-9-Programming-By-Example/tree/master/Chapter04))中所示，代码要复杂一些：
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have a special color constant named `none` that we use to signal a reference
    that is of type `Color` but is not a valid `Color`. In professional development,
    we used the `null` value for a long time to signal invalid reference, and because
    we are backward compatible, we still use it. However, it is recommended to avoid
    the `null` reference wherever possible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`none`的特殊颜色常量，我们用它来表示一个类型为`Color`但不是有效`Color`的引用。在专业开发中，我们长期以来一直使用`null`值来表示无效引用，因为我们具有向后兼容性，所以我们仍然使用它。然而，建议尽可能避免使用`null`引用。
- en: Tony Hoare ([https://en.wikipedia.org/wiki/Tony_Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)),
    who invented the `null` reference in 1965, admitted one time that this was a mistake
    that cost billions of dollars in the IT industry.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 托尼·霍尔（[https://en.wikipedia.org/wiki/Tony_Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)），他在1965年发明了`null`引用，曾承认这是一个代价数十亿美元的IT行业的错误。
- en: The problem with the `null` value is that it takes the control away from the
    class, and thus, opens encapsulation. If a method returns `null` in some situation,
    the caller is strictly required to check the nullity and act according to that.
    For example, you cannot call a method on a `null` reference and you cannot access
    any field. If the method returns, a special instance of the object these problems
    are less serious. If the caller forgets to check the special return value and
    invokes methods on the special instance, the methods invoked still have the possibility
    to implement some exception or error handling. The class has the control encapsulated
    and can throw a special exception that may give more information about the error
    caused by the programmatic mistake by the caller not checking the special value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`值的问题在于它将控制权从类中移走，从而打开了封装。如果某个方法在某种情况下返回`null`，调用者必须严格检查其空值并根据该值采取行动。例如，你不能在`null`引用上调用方法，也不能访问任何字段。如果方法返回，一个特殊对象实例，这些问题就不那么严重了。如果调用者忘记检查特殊返回值并在特殊实例上调用方法，被调用的方法仍然有可能实现一些异常或错误处理。类具有封装控制权，可以抛出一个特殊异常，这可能提供更多关于由调用者未检查特殊值而导致的程序错误的信息。'
- en: JavaDoc and code comments
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaDoc 和代码注释
- en: There is also another difference between what we presented here earlier and
    the listing. This is the commenting of the code. Code comments are part of the
    program, which are ignored, filtered out by the compiler. These comments are solely
    for those who maintain or use the code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里之前展示的内容和列表之间还有一个区别。这是代码注释。代码注释是程序的一部分，被编译器忽略或过滤掉。这些注释仅针对维护或使用代码的人。
- en: In Java, there are two different comments. The code enclosed between `/*` and
    `*/` are comments. The start and the end of the comment do not need to be on the
    same line. The other type of comment starts with the `//` characters and ends
    at the end of the line.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，有两种不同的注释。在 `/*` 和 `*/` 之间的代码是注释。注释的开始和结束不需要在同一行上。另一种类型的注释以 `//` 字符开始，并在行尾结束。
- en: To document the code, the JavaDoc tool can be used. JavaDoc is a special tool
    that reads the source code and extracts HTML documentation about the classes,
    methods, fields, and other entities that have a comment starting with the `/**`
    characters. The documentation will contain the JavaDoc comments in a formatted
    way and also the information that is extracted from the program code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要对代码进行文档化，可以使用 JavaDoc 工具。JavaDoc 是一种特殊的工具，它读取源代码并提取有关类、方法、字段和其他实体的 HTML 文档，这些实体的注释以
    `/**` 字符开始。文档将以格式化的方式包含 JavaDoc 注释，以及从程序代码中提取的信息。
- en: The documentation also appears as online help in the IDE when you move the mouse
    over a method call or class name, if there is any. The JavaDoc comment can contain
    HTML codes, but it generally should not. If really needed, you can use `<p>` to
    start a new paragraph or the `<pre>` tags to include some preformatted code sample
    into the documentation, but nothing more gives real benefit. Documentation should
    be as short as possible and contain as few formatting as possible.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 文档还以在线帮助的形式出现在 IDE 中，当你将鼠标移至方法调用或类名上时，如果存在的话。JavaDoc 注释可以包含 HTML 代码，但通常不应这样做。如果确实需要，你可以使用
    `<p>` 标签来开始一个新段落，或者使用 `<pre>` 标签将一些预格式化的代码示例包含到文档中，但不要添加更多内容。文档应尽可能简短，并包含尽可能少的格式。
- en: 'There are special tags that appear in the JavaDoc documentation. These are
    prefilled by the IDEs when you start to type a JavaDoc as `/**` and then press
    *Enter*. These are inside the comment and start with the `@` character. There
    are a predefined set of tags: `@author`, `@version`, `@param`, `@return`, `@exception`,
    `@see`, `@since`, `@serial`, and `@deprecated`. The most important tags are `@param`
    and `@return`. They are used to describe the method arguments and the return value.
    Although we are not there yet, let''s peek ahead to the `guessMatch` method from
    the `Guesser` class.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: JavaDoc 文档中会出现特殊的标签。当你开始以 `/**` 输入 JavaDoc 并按下 *Enter* 键时，IDE 会预先填充这些标签。这些标签位于注释中，并以
    `@` 字符开始。有一组预定义的标签：`@author`、`@version`、`@param`、`@return`、`@exception`、`@see`、`@since`、`@serial`
    和 `@deprecated`。最重要的标签是 `@param` 和 `@return`。它们用于描述方法参数和返回值。虽然我们还没有到达那里，但让我们提前看看
    `Guesser` 类中的 `guessMatch` 方法。
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The name of the parameter is automatically generated by the IDE. When you create
    the documentation, write something that is meaningful and not tautology. Many
    times, novice programmers feel the urge to write JavaDoc, and that something has
    to be written about the parameters. They create documentations like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的名称由 IDE 自动生成。当你创建文档时，写一些有意义的、非同义反复的内容。很多时候，新手程序员会迫切地想要编写 JavaDoc，并认为必须对参数进行说明。他们创建的文档如下：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Really? I would never have guessed. If you do not know what to write there
    to document the parameter, it may happen that you were choosing the name of the
    parameter excellent. The documentation of our preceding example will look as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 真的吗？我绝不会猜到。如果你不知道在那里写什么来文档化参数，可能发生的情况是你选择了参数的名称非常优秀。我们前面示例的文档将如下所示：
- en: '![](img/00042.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00042.jpeg)'
- en: Focus on what the method, class, and interface does and how it can be used.
    Do not explain how it works internally. JavaDoc is not the place for the explanation
    of the algorithm or the coding. It is used to help use the code. However, if somebody
    happens to explain how a method works, it is not a disaster. Comments can easily
    be deleted.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于方法、类和接口的功能以及如何使用它们。不要解释其内部工作原理。JavaDoc 不是解释算法或编码的地方。它用于帮助使用代码。然而，如果有人偶然解释了方法的工作原理，这并不是灾难。注释可以很容易地被删除。
- en: 'There is, however, a comment that is worse than nothing: outdated documentation
    that is not valid anymore. When the contract of the element has changed, but the
    documentation does not follow the change and is misleading the user who wants
    to call the method, interface, or class whatever will face serious bugs and will
    be clueless.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个注释比没有还糟糕：过时的文档，它已经不再有效。当元素的合约发生变化时，但文档没有跟随变化，并且误导了想要调用方法、接口或类的用户，那么他们将会遇到严重的错误，并且会毫无头绪。
- en: From now on, JavaDoc comments will not be listed in print to save trees, and
    electrons in the eBook version, but they are there in the repository and can be
    examined.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，JavaDoc注释将不会在打印中列出以节省树木，以及电子书版本中的电子，但它们在存储库中，并且可以被检查。
- en: Row
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Row
- en: Now, we have `Color`s and even instances if we need having a `ColorManager`.
    This is the time to store `Color`s in `Row`s. The `Row` class is a bit longer,
    but not too complex.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要有一个`ColorManager`，我们就有`Color`s和实例。这是在`Row`s中存储`Color`s的时候。`Row`类稍微长一点，但并不复杂。
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A `Row` contains three fields. One is the `positions` array. Each element of
    the array is a `Color`. The `matchedPositions` is the number of positions that
    are matched and `matchedColors` is the number of colors that match a color in
    the hidden row but is not on the position as in the hidden row.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row`包含三个字段。一个是`positions`数组。数组的每个元素都是一个`Color`。`matchedPositions`是匹配的位置数，`matchedColors`是匹配隐藏行中的颜色但不在位置上的颜色数。'
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `none` is a constant that contains a special `Row` instance that we will
    use wherever we would use `null`. The constructor gets the colors in an array
    that should be in the row.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`none`是一个包含特殊`Row`实例的常量，我们将在需要使用`null`的地方使用它。构造函数获取一个数组，该数组应该位于行中。'
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The constructor makes a copy of the original array. This is an important code
    that we will examine a bit. Let's reiterate that Java passes arguments by value.
    It means that when you pass an array to a method, you will pass the value of the
    variable that holds the array. However, an array in Java is an Object just as
    well as anything else (except primitives like `int`). Therefore, what the variable
    contains is a reference to an object that happens to be an array. If you change
    the elements of the array, you actually change the elements of the original array.
    The array reference is copied when the argument passes, but the array itself,
    and the elements, are not.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数会复制原始数组。这是一段重要的代码，我们将稍作探讨。让我们再次强调，Java通过值传递参数。这意味着当你将一个数组传递给一个方法时，你传递的是包含该数组的变量的值。然而，在Java中，数组就像任何其他东西一样是一个对象（除了像`int`这样的原始类型）。因此，变量包含的是指向一个恰好是数组的对象的引用。如果你更改数组的元素，实际上你更改的是原始数组的元素。当参数传递时，数组引用被复制，但数组本身及其元素则不是。
- en: The `java.util.Arrays` utility class provides a lot of useful tools. We can
    easily code the array copying in Java but why to reinvent the wheel? In addition
    to that, arrays are continuous area of memory that can very effectively be copied
    from one place to another using low-level machine code. The `copyOf` method that
    we invoke calls the method `System.arraycopy` which is a native method and as
    such executes native code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Arrays`实用工具类提供了许多有用的工具。我们可以在Java中轻松地编码数组复制，但为什么要重新发明轮子呢？除此之外，数组是内存中的连续区域，可以非常有效地使用低级机器代码从一个地方复制到另一个地方。我们调用的`copyOf`方法调用`System.arraycopy`方法，这是一个本地方法，因此执行本地代码。'
- en: Note that there is no guarantee that `Arrays.copyOf` invokes the native implementations
    and that this will be extremely fast in case of large arrays. The very version
    I was testing and debugging was doing it that way, and we can assume that a good
    JDK does something similar, effective and fast.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有保证`Arrays.copyOf`调用本地实现，并且在大数组的情况下这将非常快。我正在测试和调试的版本就是这样做的，我们可以假设一个好的JDK会做类似的事情，既有效又快。
- en: After we copied the array, it is not a problem if the caller modifies the array
    that was passed to the constructor. The class will have a reference to a copy
    that will contain the same elements. However, note that if the caller changes
    any of the objects that are stored in the array (not the reference in the array,
    but the object itself that is referenced by an array element), then the same object
    is modified. `Arrays.copyOf` does not copy the objects that are referenced by
    the array, only the array elements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们复制数组之后，如果调用者修改了传递给构造函数的数组，这不会成为问题。类将有一个指向包含相同元素的副本的引用。然而，请注意，如果调用者更改数组中存储的任何对象（不是数组中的引用，而是被数组元素引用的对象），则相同的对象将被修改。`Arrays.copyOf`不会复制数组引用的对象，只会复制数组元素。
- en: The row is created along with the colors and thus, we used a `final` field for
    the `Color` array. The matches, however, cannot be known when a Row is created.
    One of the players creates the `Row` and after that, the other player will tell
    the two `int` values. We do not create two setters for the two values, however,
    because they are always defined at the same time in the game together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 行与颜色一起创建，因此我们为`Color`数组使用了`final`字段。然而，当行被创建时，无法知道匹配项。一位玩家创建`Row`，之后另一位玩家会告知两个`int`值。但我们没有为这两个值创建两个setter，因为在游戏中它们总是同时定义的。
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `setMatch` method does not only set the values, but also checks that the
    values are consistent. The sum of the two values cannot be more than the number
    of the columns. This check ensures that the caller, who uses the API of the `Row`
    class, does not use it inconsistently. If this API is used only from inside our
    code, this assertion should not be part of the code. A good coding style, in that
    case, will ensure that the method is never invoked inconsistently using unit tests.
    When we create API to use out of our control, we should check that the use is
    consistent. Failing to do so, our code may behave just weird when used inconsistently.
    When the caller sets matches to values that do not match any possible guess, the
    game may never finish and the caller may have a hard time figuring out what is
    going on. This figuring out probably will need the debug execution of our code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`setMatch`方法不仅设置值，还检查这些值是否一致。这两个值的和不能超过列数。这个检查确保调用者，即使用`Row`类API的人，不会不一致地使用它。如果这个API只从我们的代码内部使用，这个断言不应该成为代码的一部分。在这种情况下，良好的编码风格将确保该方法在单元测试中不会被不一致地调用。当我们创建超出我们控制的API时，我们应该检查使用是否一致。如果不这样做，我们的代码在不一致使用时可能会表现得非常奇怪。当调用者设置的匹配值与任何可能的猜测都不匹配时，游戏可能永远无法结束，调用者可能很难弄清楚发生了什么。这种弄清楚可能需要调试我们的代码执行。'
- en: If we throw an exception in this case, the program stops where the bug is. There
    is no need to debug the library.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这种情况下抛出异常，程序将在出现错误的地方停止。没有必要调试库。
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next method decides if a guess, given as an argument, matches the actual
    row. This method checks that the answers to the guess in the row can be valid
    if the current guess was in the hidden row. The implementation is fairly short
    and simple. A guess matches a row if the number of the colors matching and the
    number of positions matching are the same as the number given in the row. Do not
    be shy to write short methods. Do not think that a one-line method that essentially
    contains one statement is useless. Wherever we use this method, we could also
    write the expression, which is right after the return statement, but we do not
    for two reasons. The first and most important reason is that the algorithm, which
    decides that a row matches a guess belongs to the implementation of the class
    `Row`. If ever the implementation changes, the only location where the code is
    to be changed is here. The other reason is also important, and that is readability.
    In our codebase, we call this method from `abstract class Guesser`. It contains
    an `if` statement with the following expression:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法决定给定的猜测是否与实际行匹配。此方法检查行中猜测的答案是否在当前猜测是隐藏行的情况下有效。实现相当简短且简单。如果猜测匹配的颜色数量和位置匹配的数量与行中给出的数量相同，则猜测匹配行。不要害羞地编写简短的方法。不要认为本质上只包含一个语句的一行方法是没用的。无论我们在哪里使用这个方法，我们也可以写出紧随返回语句之后的表达式，但我们没有这样做，原因有两个。第一个也是最重要的原因是，决定一行是否匹配猜测的算法属于`Row`类的实现。如果实现发生变化，代码需要更改的唯一位置就是这里。另一个原因也很重要，那就是可读性。在我们的代码库中，我们从`abstract
    class Guesser`调用这个方法。它包含一个`if`语句，其中包含以下表达式：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Would it be more readable in the following way:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方式是否更易于阅读：
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I am certain that the majority of the programmers understand the intention of
    the first version easier. I would even recommend implementing the `doesNotMatchGuess`
    method to improve the readability of the code even more.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信大多数程序员更容易理解第一个版本的目的。我甚至建议实现`doesNotMatchGuess`方法来进一步提高代码的可读性。
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The number of matching colors is that which appears both in the row and the
    guess, but not in the same position. The definition, and how we calculate it,
    is fairly simple and unambiguous in case no color can appear twice in the hidden
    row. In case a color may appear multiple times in the hidden row, this implementation
    will count all occurrences of that color in the guess as many times as it appears
    in the hidden row. If we, for example, have a hidden `RRGB` row and the guess
    is `bYRR`, the calculation will say 4\. It is a matter of agreement between the
    players how they count in this case. The important aspect is that they use the
    same algorithm, which should be true in our case, because we will ask the program
    to play both players. As we will program the code ourselves, we can trust that
    it will not cheat.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的颜色数量是同时出现在行和猜测中，但不在同一位置的颜色数量。在隐藏行中，颜色不能重复出现的情况下，这个定义以及我们如何计算它是相当简单和明确的。如果隐藏行中可能重复出现颜色，此实现将计算猜测中该颜色的所有出现次数，就像它在隐藏行中出现的次数一样。例如，如果我们有一个隐藏的`RRGB`行，猜测是`bYRR`，计算将得出4。玩家如何计数的问题取决于玩家之间的协议。重要的是他们使用相同的算法，在我们的情况下应该是真实的，因为我们将会让程序为两个玩家进行游戏。由于我们将自己编写代码，我们可以相信它不会作弊。
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Counting the colors that are OK, and also on the position where they are supposed
    to be, is even simpler.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 计算颜色数量是否正确，以及它们所在的位置是否正确，甚至更加简单。
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method tells the number of columns in the `Row`. This method is needed
    in the `Game` class that controls the flow of a whole game. As this class is in
    the same package as `Row`, it can access the field positions. I created the code
    to get the number of columns as `row.positions.length`. But then, I was reading
    the code next day and told myself: This is ugly and unreadable! What I am interested
    in here is not some mysterious positions'' length; it is the number of columns.
    And the number of columns is the responsibility of the `Row` class and not the
    business of any other class. If I start to store the positions in a `List`, which
    does not have `length` (it has method `size`), it is the sole responsibility of
    `Row` and should not affect any other code. So, I created the `nrOfColumns` method
    to improve the code.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法告诉`Row`中的列数。这个方法在控制整个游戏流程的`Game`类中是必需的。由于这个类与`Row`位于同一个包中，它可以访问字段位置。我创建了代码来获取列数作为`row.positions.length`。但是，第二天我阅读代码时告诉自己：这太难看了，难以阅读！我这里感兴趣的不是一些神秘的位置长度；而是列数。列数是`Row`类的责任，而不是其他任何类的业务。如果我开始将位置存储在一个没有`length`（它有`size`方法）的`List`中，那么这将是`Row`的唯一责任，不应该影响任何其他代码。因此，我创建了`nrOfColumns`方法来改进代码。
- en: 'The rest of the class contains some more very simple methods that are needed
    only to display the game and not for the algorithm to play:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的类包含一些更简单的方法，这些方法仅用于显示游戏，而不是用于算法进行游戏：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you are a purist, you can encapsulate these methods into an inner class named
    `Output` or `Print` and call them through a final instance of it created as a
    field in the `Row` class. It is also possible to change the visibility of these
    fields from `private` to `protected` and implement these methods in a `PrintableRow`
    that can be instantiated from an already existing `Row` and implement these methods.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个纯粹主义者，你可以将这些方法封装在一个名为`Output`或`Print`的内部类中，并通过在`Row`类中创建的该类的最终实例来调用它们。也有可能将这些字段的可见性从`private`改为`protected`，并在一个可以由现有的`Row`实例化并实现这些方法的`PrintableRow`中实现这些方法。
- en: 'The first version of `PrintableRow` will look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintableRow`的第一个版本将如下所示：'
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The methods are exactly the same as in the preceding print; they are cut and
    pasted, or rather moved, using the IDE refactoring support from one class to the
    other.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与前面的打印方法完全相同；它们是通过IDE重构支持从一类剪切粘贴，或者更确切地说，是从一个类移动到另一个类。
- en: When you write a code, please never use copy and paste. However you can use
    cut and paste to move code fragments around. The danger is in the copy paste use.
    Many developers claim that their use of actual copy and paste is not copy paste
    programming. Their reasoning is that they change the pasted code so much that
    it has practically nothing to do with the original code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码时，请永远不要使用复制粘贴。然而，你可以使用剪切粘贴来移动代码片段。危险在于复制粘贴的使用。许多开发者声称他们实际使用的复制粘贴并不是复制粘贴编程。他们的理由是，他们修改了粘贴的代码，以至于它与原始代码几乎没有关系。
- en: Really? In that case why did you need the copied code when you started the modification
    of it? Why not start from scratch? That is because if you use the IDE's copy and
    paste functionality then, no matter what, you do copy paste programming.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 真的吗？在这种情况下，为什么你在修改代码时需要复制的代码？为什么不从头开始呢？那是因为如果你使用IDE的复制粘贴功能，那么无论如何，你都会进行复制粘贴编程。
- en: 'Class `PrintableRow` is pretty neat and separates the output concern from the
    core functionality. When you need an instance, it is not a problem that you have
    a `Row` instance already in hand. The constructor will essentially clone the original
    class and return a printable version. What bothers me is the implementation of
    the cloning. The code in the constructor calls the super constructor and then
    a method and all these work with the original functionality of the `Row` class.
    They have nothing to do with the printability that `PrintableRow` implements.
    This functionality actually belongs to the `Row` class. We should create a protected
    constructor that does the cloning:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintableRow`类相当整洁，将输出关注点与核心功能分离。当你需要一个实例时，如果你已经手头有一个`Row`实例，这并不是问题。构造函数本质上会克隆原始类并返回一个可打印版本。让我烦恼的是克隆的实现。构造函数中的代码调用父构造函数，然后是一个方法，所有这些都与`Row`类的原始功能有关。它们与`PrintableRow`实现的打印功能无关。这个功能实际上属于`Row`类。我们应该创建一个受保护的构造函数来完成克隆：'
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The constructor of `PrintableRow` should simply call `super(row)` and that is
    it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintableRow`的构造函数应该简单地调用`super(row)`，然后就是它了。'
- en: 'Code is never finished and never perfect. In a professional environment, programmers
    many times tend to finish polishing the code when it is good enough. There is
    no code that cannot be made better, but there is a deadline. The software has
    to be passed on to the testers and users and has to be used to help economy. After
    all, that is the final goal of a professional developer: have a code that supports
    the business. A code that never runs is worth nothing.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 代码永远不会完成，也永远不会完美。在专业环境中，程序员很多时候会在代码足够好时停止对代码的打磨。没有不能变得更好的代码，但是有截止日期。软件必须传递给测试人员和用户，并用于帮助经济发展。毕竟，这是专业开发者的最终目标：拥有支持业务的代码。一个永远不会运行的代码毫无价值。
- en: I do not want you to think that the examples that I provided here were created
    perfect upfront. The reason for that is (did you read carefully?) because they
    are not perfect. As I said, code is never perfect.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我不希望你认为我提供的示例一开始就是完美的。原因是（你仔细阅读了吗？）因为它们并不完美。正如我所说，代码永远不会完美。
- en: When I first created Row, it contained the printing methods in an inner class.
    I did not like it. The code was smelly. So, I decided to move the functionality
    to the `Row` class. However, I still did not like the solution. Then, I went to
    bed, slept, worked, and returned to it a few days later. What I could not create
    the day before now seemed obvious—these methods have to be moved to a subclass.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次创建Row时，它在一个内部类中包含了打印方法。我不喜欢这样。代码很糟糕。所以，我决定将功能移动到`Row`类。然而，我仍然不喜欢这个解决方案。然后，我上床睡觉，工作，几天后再次回到它。我前一天无法创造的东西现在看起来很明显——这些方法必须移动到子类。
- en: Now comes another dilemma. Should I present this final solution or should I
    have here the different versions? In some cases, I will just present the final
    version. In other cases, like this, there are things to learn from the development
    step. In these cases, I present not only the code, but part of its evolution on
    how it was created. If you want to see those that I did not dare publishing, look
    at the Git history. I admit, sometimes, I create code that even makes me facepalm
    a day later.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在又遇到了另一个困境。我应该展示这个最终解决方案，还是应该展示不同的版本？在某些情况下，我只会展示最终版本。在其他情况下，比如这个，我们可以从开发步骤中学到东西。在这些情况下，我不仅展示代码，还展示其如何创建的部分演变。如果你想看到那些我不敢发布的，看看Git历史。我承认，有时我创建的代码甚至让我第二天都感到尴尬。
- en: Table
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: Table is a simple class that has only one very simple functionality.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`是一个只有一个非常简单功能的简单类。'
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There is one thing to mention, which is nothing new, but worth repeating. The
    `rows` variable is declared as final and it gets the value in the constructor.
    This is a `List<Row>` type variable. The fact that it is `final` means that it
    will hold the same list object during its lifetime. The length, members, and other
    features of the list may and will change. We will add new rows to this list. Final
    object variables reference an object, but it does not guarantee that the object
    itself is immutable. It is only the variable that does not change.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要提及，这并不是什么新内容，但值得重复。`rows` 变量被声明为`final`，并在构造函数中获取其值。这是一个`List<Row>`类型的变量。它是`final`的事实意味着在其生命周期内将保持相同的列表对象。列表的长度、成员和其他特性可能会改变，也可能改变。我们将向这个列表中添加新的行。`final`对象变量引用一个对象，但这并不保证对象本身是不可变的。只有变量本身是不变的。
- en: When you do code review and explain to your colleagues what a class does, and
    you find yourself starting the explanation "this class is very simple" many times,
    it means the code is good.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行代码审查并向你的同事解释一个类的作用时，如果你发现自己多次以“这个类非常简单”开始解释，这意味着代码是好的。
- en: Well, it may be wrong in other aspects, but the class' granularity seems to
    be okay.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在其他方面可能不正确，但这个类的粒度看起来是合适的。
- en: Guesser
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Guesser
- en: Guesser and the `UniqueGuesser` and `GeneralGuesser` subclasses are the most
    interesting classes of the program. They actually perform the task that is the
    core of the game. Given a `Table` with a hidden row, the guesser has to create
    newer and newer guesses.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guesser`及其子类`UniqueGuesser`和`GeneralGuesser`是程序中最有趣的类。它们实际上执行了游戏核心的任务。给定一个带有隐藏行的`Table`，猜测器必须创建越来越新的猜测。'
- en: To do this, a `Guesser` needs to get a `Table` when it is created. This is passed
    as a constructor argument. The only method it should implement is `guess`, which
    returns a new guess based on the table and on its actual state.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，`Guesser`需要在创建时获取一个`Table`。这作为构造函数参数传递。它应该实现的方法只有一个，即`guess`，它根据表格和其实际状态返回一个新的猜测。
- en: 'As we want to implement a guesser that assumes that all colors in the hidden
    row are different, and also one that does not make this assumption, we will implement
    three classes. `Guesser` is an abstract class that implements only the logic that
    is independent from the assumptions. These methods will be inherited by both actual
    implementations: `UniqueGuesser` and `GeneralGuesser`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要实现一个假设隐藏行中所有颜色都不同的猜测器，以及一个不做出这种假设的猜测器，我们将实现三个类。`Guesser`是一个抽象类，它只实现了与假设无关的逻辑。这些方法将由实际的实现继承：`UniqueGuesser`和`GeneralGuesser`。
- en: 'Let''s go through the actual code of the class:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个类的实际代码：
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The state of the guesser is the last guess it made. Although this is on the
    last row of the table, it is more of an internal matter of the guesser. The guesser
    has all the possible guesses, one after the other; `lastGuess` is the one where
    it left off last time and it should continue from there when it is invoked again.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测器的状态是它最后做出的猜测。尽管这位于表格的最后一行，但它更多的是猜测器的一个内部问题。猜测器拥有所有可能的猜测，一个接一个；`lastGuess`是它上次停止的地方，当它再次被调用时，它应该从那里继续。
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Setting the first guess very much depends on the assumption of color uniqueness.
    The first guess should not contain duplicated colors in case the hidden row does
    not (at least in our implementation), while `GeneralGuesser` is free to guess
    any time, even as `firstGuess` all colors to be the same.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 设置第一个猜测很大程度上取决于颜色唯一性的假设。如果隐藏行中没有重复的颜色（至少在我们的实现中是这样），第一个猜测不应该包含重复的颜色，而`GeneralGuesser`可以随时猜测，甚至可以将所有颜色都猜测为相同的`firstGuess`。
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, `none` in this class is just an object that we try to use instead of
    `null`, whenever we need to return something that is a reference to a `Guess`
    but is not really a guess.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个类中的`none`只是一个我们试图在需要返回一个指向`Guess`的引用但不是真正的猜测时使用的对象。
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `nextGuess` method is an internal method that generates the next guess,
    which just comes as we order the possible guesses. It does not check anything
    against the `Table`; it only generates the next guess almost without thinking.
    The implementation on how we do the first guess and how we do the consecutive
    guesses are different. Thus, we will implement these algorithms in different methods
    and invoke them from here.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextGuess`方法是一个内部方法，它生成下一个猜测，就像我们按顺序排列可能的猜测一样。它不对`Table`进行检查；它只是几乎不加思考地生成下一个猜测。我们如何进行第一次猜测以及如何进行连续猜测的实现方式不同。因此，我们将这些算法实现为不同的方法，并从这里调用它们。'
- en: 'The `nextNonFirstGuess` method represents the next guess in the special case
    when the guess is not the first one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextNonFirstGuess`方法代表在猜测不是第一个的特殊情况下的下一个猜测：'
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Look back a few pages where we detailed how the algorithm works. We made the
    statement that this way of working is very much like the way we count with decimal
    numbers. By now, you have enough Java knowledge and programming skill to understand
    what the method does. It is more interesting to know why it is coded that way.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下几页之前我们详细说明算法是如何工作的。我们做出了这样的陈述：这种工作方式非常类似于我们用十进制数计数的方式。到现在为止，你已经有了足够的Java知识和编程技能来理解这个方法做了什么。更有趣的是知道为什么它被这样编码。
- en: 'Hint: as always, to be readable.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：像往常一样，为了可读性。
- en: There is the temptation to eliminate the `guessFound` variable. Would it not
    be simpler to return from the middle of the method when we find the blessed guesses?
    If we did, there would be no need to check the `guessFound` value before returning
    `none` value. The code would not get there if we returned from the middle of the
    loop.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种诱惑要消除`guessFound`变量。当我们找到幸运的猜测时，从方法中间返回不是更简单吗？如果我们这样做，我们就不需要在返回`none`值之前检查`guessFound`的值。如果我们从循环中间返回，代码就不会到达那里。
- en: Yes, it would be simpler to write. But, we create code to be readable and not
    writable. Yes, but less code is more readable. Not in this case! Returning from
    a loop degrades the readability. Not to mention, the `return` statements are scattered
    around in the method at different stages of execution.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，写起来会更简单。但是，我们编写代码是为了可读性，而不是为了可写性。是的，但代码越少，可读性越好。但在这个情况下不是这样！从循环中返回会降低可读性。更不用说，`return`语句在方法的不同执行阶段散布开来。
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When somebody writes a code optimized in that way, it is similar to a toddler
    who makes his first steps and then looks proudly at the mother. Okay boy/girl,
    you are great. Now go on and start walking. When you are the postman, walking
    will be boring. That will be your profession. So, slide aside the pride and write
    boring code. Professionals write boring code. Won't it be slow?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人以这种方式编写优化过的代码时，它就像一个蹒跚学步的孩子第一次走路后自豪地看着妈妈。好吧，男孩/女孩，你很棒。现在继续走吧。当你成为邮递员时，走路就会变得无聊。那将是你的职业。所以，放下骄傲，写些无聊的代码。专业人士写无聊的代码。难道不会慢吗？
- en: No! It will not be slow. First of all, it is not slow until the profiler proves
    that the code does not meet the business requirements. If it does, it is fast
    enough, no matter how slow it is. Slow is good as long as it is okay for the business.
    After all, JIT should have some task optimizing the code to run.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不！它不会慢。首先，只有在性能分析器证明代码不符合业务需求之前，它才不慢。如果它符合要求，那么它就足够快，不管它有多慢。只要对业务来说没问题，慢就是好的。毕竟，即时编译器应该有一些任务来优化代码的运行。
- en: 'The next method checks if the guess matches the previous guesses and their
    results on the `Table`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法检查猜测是否与之前的猜测及其在`Table`上的结果匹配：
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we have the guess matching already implemented in the class `Row`, all we
    have to do is invoke that method for each row in the table. If all rows match,
    then the guess can be good for the table. If any of the former guesses do not
    match, then this guess goes down the drain.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`Row`类中已经实现了猜测匹配，我们只需要对表中的每一行调用该方法。如果所有行都匹配，那么这个猜测对表来说就是好的。如果之前的任何猜测不匹配，那么这个猜测就失败了。
- en: As we check the negated expression of matching, we created an English version
    of the method.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查匹配的否定表达式时，我们创建了一个方法的方法的英文版本。
- en: In situations like this, it could be enough to create the `guessDoesNotMatch`
    version of the method. However, the logical execution of the code is more readable
    if the method is not negated. Therefore, it is more error prone to write the `guessDoesNotMatch`
    method alone. Instead, we will implement the original, readable version and the
    aux method to be nothing more than a negation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建`guessDoesNotMatch`版本的方法可能就足够了。然而，如果方法没有被否定，代码的逻辑执行会更易读。因此，单独编写`guessDoesNotMatch`方法更容易出错。因此，我们将实现原始的、易读的版本，并将辅助方法仅仅作为一个否定。
- en: After all the aux methods, here we are implementing the public method of the
    `Guesser`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有辅助方法之后，我们现在正在实现`Guesser`的公共方法。
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It just takes the `nextGuess` and again and again until it finds one that matches
    the hidden row, or there is no more guess. If it finds a proper guess, it encapsulate
    it to a `Row` object and return it so that it can later be added to the `Table`
    by the `Game` objects.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是重复地取`nextGuess`，直到找到一个与隐藏行匹配的，或者没有更多的猜测。如果找到一个合适的猜测，它将封装成一个`Row`对象并返回它，以便稍后可以被`Game`对象添加到`Table`中。
- en: UniqueGuesser
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`UniqueGuesser`'
- en: 'Class `UniqueGuesser` has to implement `setFirstGuess` (all concrete classes
    extending an abstract class should implement the abstract method of the parent)
    and it can and will override the protected `nextGuess` method:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`UniqueGuesser`类必须实现`setFirstGuess`（所有扩展抽象类的具体类都应该实现父类的抽象方法）并且它可以并且会覆盖受保护的`nextGuess`方法：'
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `setFirstGuess` method selects the first guess in such a way that any possible
    color variations that come after the first one create the guesses one after the
    other if we follow the algorithm.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFirstGuess`方法选择第一个猜测，以便任何可能的颜色变化在第一个之后按照算法依次创建猜测。'
- en: The aux `isNotUnique` method returns true if the guess contains duplicate colors.
    It is not interesting to see how many. If all colors are the same, or only one
    color appears twice, it does not matter. The guess is not unique and does not
    fit our guesser. This method judges that.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助的`isNotUnique`方法如果猜测包含重复的颜色则返回true。看到有多少并不有趣。如果所有颜色都相同，或者只有一种颜色出现两次，那就没关系。猜测不是唯一的，也不适合我们的猜测器。这个方法就是这样的判断。
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To do this, it uses a `Set`, and any time a new color is found in the `guess`
    array, the color is stored in the set. If the set contains the color when we find
    it in the array, it means that the color was already used before; the guess is
    not unique.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，它使用了一个`Set`，并且每次在`guess`数组中找到新的颜色时，颜色都会被存储在集合中。如果我们找到集合中已经包含的颜色，这意味着颜色之前已经被使用过；猜测不是唯一的。
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The overriding `nextGuess` method is simple. It asks the super `nextGuess` implementation
    to make guesses but throws away those that it does not like.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重写的`nextGuess`方法很简单。它要求super `nextGuess`实现进行猜测，但丢弃它不喜欢的那些猜测。
- en: GeneralGuesser
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GeneralGuesser`'
- en: Class `GeneralGuesser` also has to implement the constructor and `setFirstGuess`,
    but generally, that is it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeneralGuesser`类也必须实现构造函数和`setFirstGuess`，但通常就是这样。'
- en: '[PRE38]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Setting the `lastGuess` it just puts the first color on all columns. Guess could
    not be simpler. Everything else is inherited from the `abstract class Guesser`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`lastGuess`只是将第一个颜色放在所有列上。猜测再简单不过了。其他所有内容都是继承自`abstract class Guesser`。
- en: The Game class
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏类
- en: An instance of the `Game` class contains a `Row` holding the secret color values
    and also contains a `Table`. When there is a new guess the `Game` instance stores
    the guess into the `Table` and also sets the number of positions and colors matching
    the secret row.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`类的一个实例包含一个`Row`，它持有秘密颜色值，并且还包含一个`Table`。当有新的猜测时，`Game`实例将猜测存储到`Table`中，并设置与秘密行匹配的位置和颜色数。'
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Think about what I wrote earlier about short methods, and when you download
    the code from GitHub to play with it, try to make it look more readable. You can,
    perhaps, create and use a method named `boolean itWasAWinningGuess(int positionMatch)`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我之前写的关于简短方法的内容，当你从GitHub下载代码来玩的时候，尽量让它看起来更易读。也许，你可以创建并使用一个名为`boolean itWasAWinningGuess(int
    positionMatch)`的方法。
- en: Creating an integration test
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建集成测试
- en: We have created unit tests in the previous chapter and there are unit tests
    for the functionalities implemented in the classes of this chapter as well. We
    will just not print these unit tests here. Instead of listing the unit tests,
    we will look at an integration test.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中创建了单元测试，并且本章中类的实现功能也有单元测试。我们只是不会在这里打印这些单元测试。而不是列出单元测试，我们将查看一个集成测试。
- en: Integration tests need the invocation of many classes working together. They
    check that the functionality can be delivered by the whole application, or at
    least a larger part of the application, and do not focus on a single unit. They
    are called integration tests because they test the integration between classes.
    The classes alone are all OK. They should not have any problem as it was already
    verified by the unit tests. Integration focuses on how they work together.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试需要调用许多协同工作的类。它们检查整个应用程序或至少是应用程序的更大部分是否能够提供功能，而不是关注单个单元。它们被称为集成测试，因为它们测试了类之间的集成。单独的类都是好的。它们不应该有任何问题，因为它们已经被单元测试验证过了。集成关注的是它们如何协同工作。
- en: If we want to test the `Game` class, we will either have to create mocks that
    mimic the behavior of the other `Game` classes, or we will just write an integration
    test. Technically, an integration test is very similar to a unit test. Many times,
    the very same JUnit framework is used to execute the integration tests. This is
    the case for the integration test of this game.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要测试`Game`类，我们可能必须创建模拟其他`Game`类行为的模拟，或者我们只需编写一个集成测试。技术上，集成测试与单元测试非常相似。很多时候，完全相同的JUnit框架被用来执行集成测试。这个游戏的集成测试就是这样做的。
- en: The build tool, however, needs to be configured to execute the integration tests
    only when it is required. Usually, integration test executions need more time,
    and sometimes resources, such as external database that may not be available at
    each and every developer desktop. Unit tests run every time the application is
    compiled so they have to be fast. To separate the unit and integration tests,
    there are different techniques and configuration options, but there is no such
    more or less de-facto standard like the directory structure introduced by Maven
    (later adapted by Gradle).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，构建工具需要配置为仅在需要时执行集成测试。通常，集成测试的执行需要更多的时间，有时还需要资源，例如可能不在每个开发者的桌面上都可用的外部数据库。单元测试每次编译应用程序时都会运行，因此它们必须很快。为了区分单元测试和集成测试，有不同的技术和配置选项，但没有像Maven（后来被Gradle采用）引入的目录结构那样更或更实际的规范。
- en: In our case, the integration test does not need any extra resource and does
    not take enormous time to run. It plays a game from the start to the end and plays
    the role of both the players. It is very much like somebody playing chess with
    themselves, making a step and then turning the table.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，集成测试不需要任何额外的资源，并且运行时间也不会很长。它从头到尾玩一整局游戏，并且扮演着两个玩家的角色。这非常像某个人和自己下棋，走一步然后翻转棋盘。
- en: The aim of this code is twofold. On one hand, we want to see that the code runs
    and plays a whole game. If the game finishes, then it is just OK. This is a very
    weak assertion and real integration tests perform lots of assertions (one test
    tests only one assertion though). We will focus on the other aim—deliver some
    joy and visualize the game on the console in text format so that the reader does
    not get bored.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目标有两个。一方面，我们想看看代码能否运行并玩一整局游戏。如果游戏结束，那就足够了。这是一个非常弱的断言，而真正的集成测试会执行很多断言（尽管一个测试只测试一个断言）。我们将关注另一个目标——带来一些乐趣，并在控制台上以文本格式可视化游戏，这样读者就不会感到无聊。
- en: To do that, we will create a utility class that prints out a color and assigns
    letters to the `Color` instances on the fly. This is the `PrettyPrintRow` class.
    There are several limitations in this class that we have to talk about after we
    look at the code. I'd say that this code is here only to demonstrate what not
    to do, to establish some reasoning for the next chapter, and why we need to refactor
    the code we created in this one.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将创建一个实用工具类，它会在运行时打印颜色并给`Color`实例分配字母。这就是`PrettyPrintRow`类。在这个类中存在一些限制，我们将在查看代码后讨论。可以说，这段代码在这里只是为了演示不应该做什么，为下一章建立一些推理，以及为什么我们需要重构在这一章中创建的代码。
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is the heart of this class. When a color is to be printed, it gets a letter
    assigned unless it already has one. As the `Map` containing the assignments in
    each and every game that is running in the JVM will use the same mapping, a new
    `Game` is started. It allocates new `Color`s and will soon run out of the six
    characters that we allocated here in the `String` constant.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个类的心脏。当要打印颜色时，它会分配一个字母，除非它已经有一个了。由于包含每个正在JVM中运行的游戏的分配的`Map`将使用相同的映射，因此会启动一个新的`Game`。它分配新的`Color`，很快就会用完我们在`String`常量中分配的六个字符。
- en: If the `Game` instances are run parallel, then we are in even more trouble.
    The class is not thread safe at all. If two threads concurrently call the `colorToChar`
    method for the same `Color` instance, (which is not likely because each `Game`
    uses its own color, but note that *not likely* in programming is very much like
    a famous last words quote on a tombstone) then both threads may see at the same
    time that there is no letter assigned to the color and both will assign the letter
    (the same letter or two different letters, based on luck) and increase the counter
    once or twice. At least, what we can say is that the execution is nondeterministic.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Game`实例是并行运行的，那么我们遇到的麻烦就更大了。这个类根本不是线程安全的。如果有两个线程同时调用同一个`Color`实例的`colorToChar`方法（这不太可能，因为每个`Game`都使用自己的颜色，但请注意，编程中的“不太可能”非常类似于墓碑上著名的最后遗言引用），那么两个线程可能会同时看到没有字母分配给颜色，并且两者都会分配字母（根据运气可能是相同的字母或两个不同的字母）并增加计数器一次或两次。至少，我们可以说的是，执行是非确定性的。
- en: 'You may recall that I said violating the hash contract is the second most difficult
    to find bug after multithread issues. Such a nondeterministic code is exactly
    that: a multithread issue. There is no prize to find the most difficult bug. When
    the application does not run, and a bug affects the production system for hours
    or days, no businessperson will be happy, and they will not be amazed after you
    find the bug. It may be an intellectual challenge, but the real value is not creating
    the bugs in the first place.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我说违反哈希契约是继多线程问题之后最难找到的第二个bug。这样的非确定性代码正是这样的：一个多线程问题。找到最难的bug没有奖励。当应用程序无法运行，并且一个bug影响了生产系统数小时或数天时，任何商人都会不高兴，而且在你找到bug后，他们也不会感到惊讶。这可能是一个智力挑战，但真正的价值不是最初就创建bug。
- en: As a summary, this code can only be used once in a JVM by a single thread. For
    this chapter, it is good, though a smelly and shameful code, but it will be a
    good example for the next chapter, in which we will see, how to refactor the application
    so that it will not need such a hacking to print out the colors.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这段代码在JVM中只能由一个线程使用一次。对于本章来说，虽然它是一个有异味且令人羞愧的代码，但它将是下一章的好例子，在下一章中，我们将看到如何重构应用程序，使其不需要这样的黑客手段来打印颜色。
- en: Code smell is a term minted by Kent Back, according to Martin Fowler ([http://martinfowler.com/bliki/CodeSmell.html](http://martinfowler.com/bliki/CodeSmell.html)).
    It means that some code looks not good, nor apparently bad, but some constructs
    make the feeling in the developer that it may not be good. As it is defined on
    the web page, *"A code smell is a surface indication that usually corresponds
    to a deeper problem in the system."* The term is widely accepted and used in software
    development for the last 10 years.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味是由Kent Back提出的术语，根据Martin Fowler（[http://martinfowler.com/bliki/CodeSmell.html](http://martinfowler.com/bliki/CodeSmell.html)）。这意味着某些代码看起来不好，也不明显不好，但某些结构会让开发者感觉到它可能不是好的。正如网页上定义的那样，“代码异味是通常对应于系统中更深层次问题的表面迹象。”这个术语被广泛接受并在过去10年的软件开发中被使用。
- en: 'The rest of the code is plain and simple:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分是简单明了的：
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The integration test, or rather the demonstration code (as it does not contain
    any assertions other than it runs without exception), defines six colors and four
    columns. This is the size of the original game. It creates a color manager, and
    then it creates a table and a secret. The secret could be just any random color
    selection from the six colors that is available (there are 360 different possibilities
    tested in the `UniqueGuesserTest` unit test available from GitHub). As we know
    that the `Guesser` implementation starts from one end of the color set and creates
    the new guesses systematically, we want to set a secret that it will guess the
    last. This is not because we are evil, but rather because we want to see that
    our code really works.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试，或者更确切地说，演示代码（因为它除了运行不抛出异常之外不包含任何断言），定义了六种颜色和四列。这是原始游戏的大小。它创建了一个颜色管理器，然后创建了一个表格和一个秘密。秘密可以是六种可用颜色中的任何一种随机颜色选择（在GitHub上可用的`UniqueGuesserTest`单元测试中测试了360种不同的可能性）。正如我们所知，`Guesser`实现从颜色集的一端开始，并系统地创建新的猜测，我们希望设置一个秘密，这样它就能猜到最后一个。这并不是因为我们邪恶，而是因为我们想看到我们的代码真的能工作。
- en: 'The directory structure of the code is very similar to the one we used in case
    of the Maven build tool, as can be seen on the following screenshot created on
    a Windows machine:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的目录结构与我们在使用Maven构建工具时的结构非常相似，如下面的屏幕截图所示，该截图是在Windows机器上创建的：
- en: '![](img/00043.gif)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00043.gif)'
- en: 'The source code is under the directory `src` and the `main` and `test` source
    code files are separated into two subdirectory structures. The compiled files
    will be generated in the directory `build` when we use Gradle. The code of the
    integration test class is the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码位于`src`目录下，`main`和`test`源代码文件被分别放置在两个子目录结构中。当我们使用Gradle时，编译文件将在`build`目录下生成。集成测试类的代码如下：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The easiest way to run the test is start it from inside the IDE. When the IDE
    imports the project based on the build file, be it a Maven `pom.xml` or Gradle
    `build.gradle`. IDE usually provides a run button or menu to start the code. Running
    the game will print out the following piece of code that we worked so hard on
    in this chapter:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的最简单方法是直接在IDE中启动它。当IDE根据构建文件导入项目时，无论是Maven的`pom.xml`还是Gradle的`build.gradle`，IDE通常会提供一个运行按钮或菜单来启动代码。运行游戏将打印出我们在本章中辛苦编写的一段代码：
- en: '[PRE43]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we programmed a table game: Mastermind. We not only programmed
    the model of the game, but also created an algorithm that can guess. We revisited
    some OO principles and discussed why the model was created the way it was. While
    we created the model of the game, which we will refine in the next chapter, you
    have learned about Java collections, what an integration test is, and how to create
    JavaDoc.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们编写了一个桌游：Mastermind。我们不仅编写了游戏模型，还创建了一个可以猜测的算法。我们回顾了一些面向对象的原则，并讨论了为什么模型被创建成这样。在我们创建的游戏模型中，我们将在下一章对其进行完善，同时你学习了Java集合、什么是集成测试以及如何创建JavaDoc。
