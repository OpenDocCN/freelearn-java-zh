- en: Mastermind - Creating a Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start to develop a simple game. The game is the Mastermind
    game for two players. Player one selects four differently colored pins out of
    six possible colors and arranges them on a board in a row hidden from the other
    player. The other player tries to guess the colors of the pins and its positions.
    After each try, player one tells the number of matching colors and the pins matching
    both color and position. The program will act as both player one and player two.
    Our code will play alone. However, what remains for us to play with is the most
    important: the code.'
  prefs: []
  type: TYPE_NORMAL
- en: This example is complex enough to deepen the OO principles and how we design
    classes and model the real world. We have already used classes provided in the
    Java runtime. This time, we will use collections and discuss this important area.
    These classes and interfaces are widely used and available in the JDK and as important
    for a professional Java developer as the language itself.
  prefs: []
  type: TYPE_NORMAL
- en: The build tool this time is Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Java collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to comment our code and to create JavaDoc documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastermind ([https://en.wikipedia.org/wiki/Mastermind_(board_game)](https://en.wikipedia.org/wiki/Mastermind_(board_game)))
    is an old game. The plastic version that was ubiquitous in every house with children
    was invented in 1970\. I got a board around 1980 as a Christmas gift and solving
    the game puzzle in BASIC language was one of the first programs that I created
    around 1984.
  prefs: []
  type: TYPE_NORMAL
- en: The game board contains holes in several rows in four columns. There are plastic
    pins of six different colors that can be inserted into the holes. Each pin has
    one color. They are usually red, green, blue, yellow, black, and white. There
    is a special row that is hidden from one of the players (the guesser).
  prefs: []
  type: TYPE_NORMAL
- en: To play the game, one of the players (hider) has to select four pins from a
    set of pins. The selected pins should have different colors. The pins are placed
    in the hidden row one by one, each into a position.
  prefs: []
  type: TYPE_NORMAL
- en: The guesser tries to find out what colors are in which position guessing. Each
    guess takes place selecting four pins and placing them in a row. The hider tells
    the guesser how many pins are in correct position and how many have a color that
    is on the table, but are not in the position where that color is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A sample play may go like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The hider hides four pins with color blue, yellow, white, and black.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guesser guesses yellow, blue, green, and red.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hider tells the guesser that there are two colors matching, but none of
    them is in the position in the hidden row. The hider says this because yellow
    and blue are in the hidden row but not in the positions as the guesser guessed.
    They are actually swapped, but this information the hider keeps a secret. All
    she says is that there are two colors matching, none in the correct position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next guess is ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game finishes when the guesser finds the correct colors in the correct order.
    The same game, as on the figure, can also be described with textual notation,
    `B` for blue, `Y` for yellow, `G` for green, `W` for white, `R` for red, and `b`
    for black (lucky we have upper and lower case letters on the computer).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Guess what! This is the actual output of the program that we develop in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The model of the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we develop a piece of code with an object-oriented mindset, we try to model
    the real world and map real-world objects to objects in the program. You certainly
    have heard of object orientation explained with the very typical examples of geometric
    objects, or the car and the motor thing to explain composition. Personally, I
    believe that these examples are too simple to get a good understanding. They may
    be good for starters, but we are already in the fourth chapter of the book. The
    Mastermind game is much better. It is a bit more complex than just rectangles
    and triangles, but not as complex as a telecom billing application or an atomic
    power plant control.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the real-world objects that we have in that game? We have a table
    and we have pins of different colors. There are two Java classes that we certainly
    will need. What is in a table? There are rows each having four positions. Perhaps
    we will need a class for a row. A table will have rows. We will also need something
    that hides the secret. This also may be a row and each row may also hold the information
    about how many positions and how many colors are matching. In case of the secret
    row, this information is obvious: 4 and 0.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a pin? Each pin has a color and generally, that is it. There are no
    other features of a pin, except that it can be inserted into a hole on the table,
    but this is a real life feature we will not model. Essentially, a pin is a color
    and nothing else. This way, we can eliminate the pin class from our model early
    on, even before we created it in Java. Instead, we have colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a color? This is something that may be hard to immerse into the first
    time. We all know well what a color is. It is a mixture of different frequency
    of lights, as our eyes perceive it. We can have paints and prints in different
    colors, and so on. There are very many things that we do not model in this program.
    It is really hard to tell what we model about color in our code because these
    features are so obvious that we take it for granted in real life; we can tell
    about two colors that they are different. This is the only feature we need. To
    do this, the simplest class of Java can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you have two variables of the type `Color`, you can tell if they are the
    same or not. You can use object identity comparing `a` and `b` using the expression
    `a == b` or you can use the `equals` method inherited from the `Object` class,
    `a.equals(b)`. It is tempting to encode the colors with letters, or use `String`
    constants to denote them. It may be easier first, but there are serious drawbacks
    later. When the code becomes complex, it leads to bugs; it will be easy to pass
    something also encoded as String instead of a color and only unit tests may save
    the day. Better, the compiler already complains in the IDE when you type the wrong
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: When we play the game, the pins are in small boxes. We pull pins out of the
    boxes. How do we get the colors in the program? We need something from where we
    can fetch colors or looking at the other way something that can give us colors.
    We will call it `ColorManager`. `ColorManager` knows how many different colors
    we have and any time we need a color, we can ask for it.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there is a temptation to design the `ColorManager` that it can serve
    a color by its serial number. If we have four colors, we could ask for color number
    0, 1, 2, or 3\. But then again, it would just implicitly encode the colors as
    integer numbers, which we agreed we will not. We should find the minimum feature
    that we will need to model the game.
  prefs: []
  type: TYPE_NORMAL
- en: To describe the structure of the classes, professional developers usually use
    UML class diagrams. UML is a diagram notation that is standardized and is almost
    exclusively used to visualize software architecture. There are many diagram types
    in UML to describe the static structure and the dynamic behavior of a program.
    This time, we will look at a very simplified class diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.gif)'
  prefs: []
  type: TYPE_IMG
- en: We have no room to get into the details of UML class diagrams. Rectangles denote
    the classes, normal arrows denote the relations when a class has field of the
    other class type, and triangleÂ headed arrow means that a class extends another.
    The arrow points to the direction of the class being extended.
  prefs: []
  type: TYPE_NORMAL
- en: A **Game** contains a secret **Row** and a **Table**. The **Table** has a **ColorManager**
    and a **List<>** of **Row**. The **ColorManager** has a first color and has a
    **Map<>** of **Color**. We have not discussed why that is the design, we will
    get there and the diagram helps us walking that road. A **Row** is essentially
    an array of **Color**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one who plays the game has one function: it has to guess many times until
    it finds the hidden secret. To get to the model of the **ColorManager**, we will
    have to design the algorithm of the **Guesser**.'
  prefs: []
  type: TYPE_NORMAL
- en: When the player makes the first guess, any combination of colors is just as
    good as any other. Later, the guesses should consider the responses that were
    given for previous guesses. It is a reasonable approach to try only color variations
    that can be the actual secret. The player selects a variation and looks at all
    previous guesses assuming that the selected variation is the secret. If the responses
    to the rows he has already made are the same for this variation as for the unknown
    secret in the game, then it is reasonable to try this variation. If there is any
    difference in the responses, then this variation is certainly not the variation
    that was hidden.
  prefs: []
  type: TYPE_NORMAL
- en: To follow this approach, the guesser has to generate all possible color variations
    one after the other and compare it against the table. The guesser code will not
    create and store all the possible variations ahead, but it has to know where it
    was and has to be able to calculate the next variation that comes. This assumes
    an order of the variations. For a short while, let's forget that no color may
    appear twice in a variation. A simple ordering can be made the same way as we
    sort decimal numbers. If we have a three-digit number, then the first one is 000,
    the next one is 001, and so on until 009, always fetching the next digit for the
    last position. After that, 010 comes. We increased a digit next to the last one
    and we set the last one to 0 again. Now, we have 011, 012, and so on. You know,
    how we count numbers. Now, replace the digits with colors and we have only six
    and not ten. Or, we have as many as we want when we instantiate a `ColorManager`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the functionality of the `ColorManager`. It has to do the following
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Give the first color to the caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give the next color that follows a given color (we will name the method `nextColor`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter functionality should also signal some way when there is no next color.
    This will be implemented using another method, named `thereIsNextColor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a convention to start the method names that return a Boolean value with
    `is`. That would lead to the name following this convention `isThereNextColor`,
    or `isNextColor`. Either of these names explains the functionality of the method.
    If I ask the question `isThereNextColor`, the method will answer me `true` or
    `false`. But, this is not how we will use the method. We will talk in simple sentences.
    We will use short sentences. We will avoid unnecessary, gibberish expressions.
    We will also program that way. Most probably, the caller will use this method
    in an `if` statement. They will write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`If( thereIsNextColor(currentColor)){...}`'
  prefs: []
  type: TYPE_NORMAL
- en: and not
  prefs: []
  type: TYPE_NORMAL
- en: '`if( isThereNextColor(currentColor)){...}`'
  prefs: []
  type: TYPE_NORMAL
- en: I think the first version is more readable and readability comes first. Last,
    but not least, nobody will blame you if you follow the old convention, and in
    case that is the company standard, you have to anyway.
  prefs: []
  type: TYPE_NORMAL
- en: To do these, the `ColorManager` also has to create the color objects and should
    store them in a structure that helps the operations being performed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The structure we use is a `Map`. `Map` is an interface defined in the Java runtime
    and is available since the very early releases of Java. A `Map` has keys and value,
    and for any key, you can easily retrieve the value assigned to the key.
  prefs: []
  type: TYPE_NORMAL
- en: You can see on the line, where the variable `successor` is defined that we define
    the type of the variable as an interface, but the value is an instance of a class.
    Obviously, the value cannot be an instance of an interface because such beasts
    do not exist. But, why do we define the variable to be an interface? The reason
    is abstraction and coding practice. If we need to change the implementation we
    use for some reason, the variable type still may remain the same and there is
    no need to change the code elsewhere. It is also a good practice to declare the
    variable to be an interface so that we will not have the temptation to use some
    special API of the implementation that is not available in the interface just
    by convenience. When it is really needed, we can change the type of the variable
    and use the special API. After all, there is a reason that API is there, but the
    mere temptation to use some special thing just because it is there is hindered.
    This helps to write simpler and cleaner program.
  prefs: []
  type: TYPE_NORMAL
- en: '`Map` is only one of theÂ interfacesÂ defined in the Java runtime belonging to
    the Java collections. There are many other interfaces and classes. Although, the
    JDK and all the classes are a vast amount and almost nobody knows all the classes
    that are there, collections is a special area that a professional developer should
    be knowledgeable about. Before getting into details on why `HashMap` is used in
    this code, we will have an overview of the collection classes and interfaces.
    This will help us also understand the other collections used in this program.'
  prefs: []
  type: TYPE_NORMAL
- en: Java collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections are interfaces and classes that help us store more than one object.
    We have already seen arrays that can do that, and also `ArrayList` in the previous
    chapters, but we did not discuss in detail what other possibilities there are
    in the JDK. Here, we will go into more detail, but leave the streams and the functional
    methods for later chapters, and we will also refrain to go into details that is
    rather the task of a reference book.
  prefs: []
  type: TYPE_NORMAL
- en: Using implementation of the collection classes and interfaces reduces the programming
    effort. First of all, you do not need to program something that is already there.
    Secondly, these classes are highly optimized, both in implementation and in their
    features. They have very well designed API as well as the code is fast and uses
    small memory footprint. Sorry to say that their code was written long time ago
    and many times it is not a good style, hard to read, and understand.
  prefs: []
  type: TYPE_NORMAL
- en: When you use a collection from the JDK, it is more likely that you can interoperate
    with some library. If you cook your own version of linked lists, it is not likely
    that you will find a readymade solution that will sort your list. If you use the
    `LinkedList` class in the JDK's standard class library, you will get a readymade
    solution from the `Collections` class, right from the JDK. It is also worth mentioning
    that the Java language itself supports these classes, for example, you can easily
    iterate through the elements of a `Collection` with a shortened special syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The collections in JDK contain interfaces that define the behavior of the different
    collection types, implementation classes, and algorithms that perform certain
    actions such as sorting. Many times, these algorithms work on different implementation
    versions, getting the same result, but optimized for the implementation specific
    class.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the API given by the interface, and if you change the implementation
    in your code, you will get an optimized version fitting the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.gif)'
  prefs: []
  type: TYPE_IMG
- en: The collection interfaces can be categorized in two bags. One bag contains the
    interfaces that extend the `Collection` interface, and the other one contains
    `Map`, and a `SortedMap` extending `Map`. This way, `Map` is not really a collection,
    as it does not simply contain other objects but also pair values to keys.
  prefs: []
  type: TYPE_NORMAL
- en: Interface collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collection is the top of the interface hierarchy. This interface defines the
    methods that all implementations should provide, no matter if they implement the
    `Set`, `SortedSet`, `List`, `Queue`, or `Deque` interface directly. As `Collection`
    simply says that an object that implements the `Collection` interface is only
    an object that collects other objects together, the methods it defines are like
    adding a new object to the collection, clearing all elements from there, checking
    that an object is already a member of the collection, and iterating through the
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: For an up-to-date definition of the interface, consult the Java pi documentation
    ([http://download.java.net/java/jdk9/docs/api/overview-summary.html](http://download.java.net/java/jdk9/docs/api/overview-summary.html)).
    You can consult the online API any time, and it is recommended to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java language itself directly supports the interface. You can iterate through
    the elements of the `Collection` with the enhanced `for` loop syntax, the same
    way as you can iterate over the elements of an array where the collection should
    be an expression that results an object that implements the `Collection` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `E` is either Object or the generic type of the elements
    of the `Collection`.
  prefs: []
  type: TYPE_NORMAL
- en: The interface `Collection` is not directly implemented in the JDK. Classes implement
    one of the sub interfaces of `Collection`.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Set` is a special collection that cannot contain duplicate elements. When
    you want to add an object into a set that already has an object that is the same
    or equal to the actual one, then the `add` method will not add the actual object.
    The `add` method will return `false` indicating the failure.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `Set` in your program when you need a collection of unique elements
    where you simply want to check that an element is a member of a set or not, whether
    an object belongs to a certain group or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will return to our program code, we will see that the `UniqueGuesser`
    class has to implement an algorithm that checks that a color in a guess is present
    only once. This algorithm is the ideal candidate for a `Set` to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code creates a set, which is empty when the method starts. After that, it
    checks for each color (notice the enhanced `for` loop over the array elements)
    if it was already present before. To do that, the code checks if the color is
    already in the set. If it is there, the guess is not unique as we have found a
    color that is present at least twice. If the color was not in the set, then the
    guess can still be unique in colors. To be able to detect that later, the code
    puts the color into the set.
  prefs: []
  type: TYPE_NORMAL
- en: The actual implementation of `Set` that we will use is `HashSet`. In the JDK,
    there are many classes implementing the `Set` interface. The most widely used
    is `HashSet`, and it is also worth mentioning `EnumSet`, `LinkedHashSet`, and
    `TreeSet`. The last one also implements the `SortedSet` interface, so we will
    detail it there.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what `HashSet`Â (and later `HashMap`) are and how they work, we
    will have to discuss what hashes are. They play very important and central role
    in many applications. They do their job under the hood in the JDK but there are
    some very important constraints that programmers have to follow or else really
    weird and extremely hard to find bugs will make their life miserable. I dare to
    say that violation of the hash contract in `HashSet` and `HashMap` are the cause
    of the second most difficult to find bugs next to multithread issues.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, before going on with the different collection implementations, we will
    visit this topic. We are already one level deep from our example in this detour
    discussing collections and now we will go one level deeper. I promise this is
    the last in-depth level of detours.
  prefs: []
  type: TYPE_NORMAL
- en: Hash functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A hash is a mathematical function that assigns a number to an element. Say you
    work at a university administration and you have to tell if Wilkinson is a student
    at your class. You can store the names on small papers in envelopes one for each
    starting letter. Instead of searching through the 10 thousand students, you can
    look at the papers in the envelope titled W. This very simple hash function assigns
    the first letter of the name to the name (or the ordinal number of the letter,
    as we said that a hash function results a number). This is not really a good hash
    function because it puts only a few elements, if any, into the envelope denoted
    X and many to A for example.
  prefs: []
  type: TYPE_NORMAL
- en: A good hash function results each possible ordinal number with similar probability.
    In hash tables, we usually have more buckets (envelopes in the previous example)
    than the number of elements to be stored. Therefore, when an element is searched
    for, it is likely that there is only one element there. At least that is what
    we would like to have. If there are multiple elements in a single bucket, it is
    called collision. A good hash function has as little collisions as possible.
  prefs: []
  type: TYPE_NORMAL
- en: For backward compatibility, there is a `Hashtable` class in the JDK. This was
    one of the first hash table implementations in Java right in the very first version,
    and as Java is backward compatible, it was not thrown away. The `Map` interface
    was introduced in version 1.2 only. `Hashtable` has many drawbacks and its use
    is not recommended. (Even the name is violating the Java naming conventions.)
    We do not discuss this class in this book. Whenever we talk about hash tables,
    it is referring to the actual array that is inside the implementation of `HashSet`,
    `HashMap`, or any other collection that uses some hash indexed table.
  prefs: []
  type: TYPE_NORMAL
- en: Hash tables are arrays that use the result of the hash function to index the
    array. Usually, linked lists manage collisions. Hash table implementations also
    implement a strategy to resize the array when the number of elements to be stored
    becomes too high and the likelihood of collisions increase. This operation may
    take considerable time and, during this, the individual elements are moved between
    the buckets.
  prefs: []
  type: TYPE_NORMAL
- en: 'During this operation, the hash table cannot reliably be used and this may
    be some source of issues in a multithread environment. In single thread code,
    you do not meet this problem. When you call the `add` method, the hash table (set
    or map) decides that the table has to be resized. The `add` method calls the resizing
    method and does not return until it is finished. Single thread code has no possibility
    to use the hash table during this period: the one and single thread is executing
    the resizing itself. In a multithread environment, however...'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashSet` and `HashMap` use the hash function provided by the `Object` that
    is stored in the collection. The `Object` class implements the `hashCode` and
    `equals` methods. You can override them and if you do, you should override both
    in a consistent manner. First, we will see what they are and then how to override
    them consistently.'
  prefs: []
  type: TYPE_NORMAL
- en: Method equals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation of set says "sets contain no pair of elements `e1` and `e2`
    such that `e1.equals`(`e2`)". The `equals` method returns `true` if the `e1` and
    `e2` are in some way equal. It may be different from two objects being identical.
    There can be two distinct objects that are equal. For example, we could have a
    color implementation that has the name of the colors as an attribute and two color
    objects may return true calling the `equals` method on one of them and passing
    the argument as the other when the two strings are equal. The default implementation
    of the `equals` method is in the code of the `Object` class and this returns `true`
    if and only if `e1` and `e2` are exactly the same and single object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems to be obvious, but my experience shows that it cannot be stressed
    enough that the implementation of equals in an object has to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reflexive**: This means that an objectÂ that always equals itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Symmetric** (commutative): This means if `e1.equals(e2)` is `true`, then
    `e2.equals(e1)` should also be `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitive**: This means if `e1.equals(e2)` and `e2.equals(e3)`, then `e1.equals(e3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent**: This means that the return value should not change if the objects
    were not changed between the invocations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method hashCode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hashCode` method returns an `int`. The documentation says that any class
    redefining this method should provide the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Consistently return the same value if the object was not modified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result the same `int` value for two objects that are equal (the `equals` method
    returns `true`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation also mentions that this is not a requirement to result different
    `int` values for objects that are not equal, but it is desirable to support the
    performance of the hash implementing collections.
  prefs: []
  type: TYPE_NORMAL
- en: If you violate any of these rules in the implementation of `equals` and `hashCode`,
    then the JDK classes using them will fail. As you can be sure that `HashSet`,
    `HashMap`, and similar classes were fully debugged, seeing that you added an object
    to a set and then the set reporting that it is not there will be a bewildering
    experience. However, only until you find out that the two objects being equal
    and stored in the set have different `hashCode` values, `HashSet` and `HashMap`
    will look for the object only in the bucket that is indexed by the `hashCode`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: It is also a common mistake to store an object in a `HashSet` or `HashMap` and
    then modify it. The object is in the collection but you cannot find it because
    the `hashCode` returns a different value. Objects stored in a collection should
    not be modified unless you know what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, objects contain fields that are not interesting from the equality
    point of view. The `hashCode` and `equals` methods should be idempotent to those
    fields and you can alter those fields even after storing the object in a `HashSet`
    or in `HashMap`.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, you may administer triangles in objects maintaining the coordinates
    of the vertices and the color of the triangle. However, you do not care about
    the color for equality, only that the two triangles are at the exact same location
    in the space. In that case, the `equals` and `hashCode` method should not take
    the field color into account. This way, we can paint our triangles; they will
    still be found in `HashSet` or `HashMap` no matter what the color field is.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing equals and hashCode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing these methods is fairly simple. As this is a very common task,
    the IDEs support the generation of these methods. These methods are tied together
    so much that the menu items in the IDEs are not separate; they offer you to generate
    these methods at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asking the IDE to generate the `equals` method will result in something like
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For this sample, we have three `Object` fields named `field1`, `field2`, and
    `field3`. The code with any other types and fields will look very similar.
  prefs: []
  type: TYPE_NORMAL
- en: First, the method checks for object identity. One `Object` always `equals` itself.
    If the reference passed as argument is `null` and not an object, or they are of
    different class, then this generated method will return false. In other cases,
    the static method of the class `Objects` (note the plural) will be used to compare
    each of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: The utility class `Objects` was introduced in Java 7, hence the name of the
    sample class. The static methods, `equals` and `hash`, support the override of
    the `Object equals`Â and `hashCode` methods. The `hashCode` creation before Java
    7 was fairly complex and required the implementation of modulo arithmetic with
    some magic numbers that is hard to explain just looking at the code without knowing
    the mathematics behind it.
  prefs: []
  type: TYPE_NORMAL
- en: This complexity is now hidden behind the following `Objects.hash` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The generated method simply calls the `Objects.hash` method passing the important
    fields as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: HashSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we know essentially a lot of things about hashes so we can bravely discuss
    the `HashSet` class. `HashSet` is an implementation of the `Set` interface that
    internally uses hash table. Generally, that is it. You store objects there and
    you can see if an object is already there or not. When there is a need for a `Set`
    implementation, almost always `HashSet` is the choice. Almost...
  prefs: []
  type: TYPE_NORMAL
- en: EnumSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`EnumSet` can contain elements from a certain enumeration. Recall that enumerations
    are classes that have fixed a number of instances declared inside the `enum` itself.
    As this limits the number of the different object instances, and this number is
    known during compilation time, the implementation of the `EnumSet` code is fairly
    optimized. Internally, `EnumSet` is implemented as a bit field and is a good choice
    where bit field manipulations can be used.'
  prefs: []
  type: TYPE_NORMAL
- en: LinkedHashSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LinkedHashSet` is a `HashSet` that also maintains a doubly linked list of
    the elements it holds. When we iterate though a `HashSet`, there is no guaranteed
    order of the element. When the `HashSet` is modified, the new elements are inserted
    into one of the buckets and, possibly, the hash table gets resized. This means
    that the elements get rearranged and get into totally different buckets. Iteration
    over the elements in `HashSet` just takes the buckets and the elements in it in
    some order that is arbitrary from the caller point of view.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkedHashSet`, however, iterates over the elements using the linked list
    it maintains and the iteration is guaranteed to happen in the order the elements
    were inserted.'
  prefs: []
  type: TYPE_NORMAL
- en: SortedSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SortedSet` is an interface that guarantees that the classes implementing
    it will iterate over the set in a sorted order. The order may be the natural ordering
    of the objects if the objects implement the `Comparable` interface or a `Comparator`
    object may drive it. This object should be available when the instance of the
    class implementing the `SortedSet` is created; in other words, it has to be a
    constructor parameter.
  prefs: []
  type: TYPE_NORMAL
- en: NavigableSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`NavigableSet` extends the `SortedSet` interface with methods that let you
    do proximity search in the set. This essentially lets you search for an element
    that is in the search and is less than the searched object, less or equal to the
    searched element, greater or equal, or greater than the searched object.'
  prefs: []
  type: TYPE_NORMAL
- en: TreeSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TreeSet` is an implementation of `NavigableSet` and, this way this is also
    a `SortedSet` and, as a matter of fact, is also a `Set.` As a `SortableSet` documentation
    implies there are two types of the constructors, each having multiple versions
    though. One requires some `Comparator`, the other one relies on the natural ordering
    of the elements.'
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`List` is an interface that requires implementing class to keep track of the
    order of the elements. There are also methods that access an element by index
    and iteration defined by the `Collection` interface that guarantees the order
    of the elements. The interface also defines the `listIterator` method that returns
    an `Iterator` also implementing the `ListIterator` interface. This interface provides
    methods that let the caller insert elements to the list while iterating through
    it and also going back and forth in the iteration. It is also possible to search
    for a certain element in the `List` but most implementations of the interface
    provide poor performance while the searching is simply going through all elements
    until the element searched for is found. There are many classes implementing this
    interface in the JDK. Here, we will mention two.'
  prefs: []
  type: TYPE_NORMAL
- en: LinkedList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a doubly-linked list implementation of the List interface that has a
    reference to the previous, and also to the next element in the list for each element.
    The class also implements the `Deque` interface. It is fairly cheap to insert
    or delete an element from the list because it needs only the adjustment of few
    references. On the other hand, the access to an element by index will need iteration
    from the start of the list, or from the end of the list, whichever is closer to
    the specified indexed element.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This class is an implementation of the `List` interface that keeps the references
    to the elements in an array. That way, this is fairly fast to access an element
    by index. On the other hand, inserting an element to `ArrayList` can be costly.
    It needs moving all references above the inserted element one index higher, and
    it may also require resizing the backing array in case there is no room in the
    original one to store the new element. Essentially, this means allocating a new
    array and copying all references to it.
  prefs: []
  type: TYPE_NORMAL
- en: The reallocation of the array may be optimized if we know how large the array
    will grow and call the `ensureCapacity` method. This will resize the array to
    the size provided as argument, even if the currently used slots are less numbered.
  prefs: []
  type: TYPE_NORMAL
- en: My experience is that novice programmers use `ArrayList` when they need a list
    without considering the algorithmic performance of the different implementations.
    I do not actually know why there is this popularity of `ArrayList`. The actual
    implementation used in a program should be based on proper decision and not habit.
  prefs: []
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queue is a collection that usually stores element for later use. You can put
    elements into a queue and you can pull them out. An implementation may specify
    the given order, that may be **first in first out** (**FIFO**) or **last in first
    out** (**LIFO**) or some priority based ordering.
  prefs: []
  type: TYPE_NORMAL
- en: On a queue, you can invoke the `add` method to add an element, `remove` to remove
    the head element, and the `element` method to access the head element without
    removing it from the queue. The `add` method will throw an exception when there
    is a capacity problem and the element cannot be added to the queue. When the queue
    is empty, and there is no head element, the `element` and `remove` methods throw
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: As exceptions can only be used in exceptional cases, and the calling program
    may handle these situations in the normal course of the code, thus all these methods
    have a version that just return some special value signaling the situation. Instead
    of `add`, a caller may call `offer` to offer an element for storage. If the queue
    cannot store the element, it will return `false`. Similarly, `peek` will try to
    get access to the head element or return `null` if there is none, and `poll` will
    remove and return the head element or just return `null` if there is none.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these methods returning `null` just make the situation ambiguous when
    the implementation, such as `LinkedList`, allows `null` elements. Never store
    a `null` element in a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Deque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Deque` is an interface which is a double-ended queue. It extends the `Queue`
    interface with the methods that allow access to both ends of the queue to add,
    look at, and remove elements from both ends.'
  prefs: []
  type: TYPE_NORMAL
- en: For the `Queue` interface we needed six methods. `Dequeue` having two manageable
    ends needs 12 methods. Instead of `add` we have `addFirst` and `addLast`. Similarly
    we can `offerFirst`, `offerLast` as well as `peekFirst`, `peekLast` and `pollFirst`,
    `pollLast`. For some reason the methods that implement the functionality of the
    `element` method on `Queue` are named `getFirst` and `getLast`.
  prefs: []
  type: TYPE_NORMAL
- en: Since this interface extends the `Queue` interface the methods defined there
    can also be used to access the head of the queue. In addition to these this interface
    also defines the methods `removeFirstOccurrence` and `removeLastOccurrence` that
    can be used to remove a specific element inside the queue. We cannot specify the
    index of the element to remove and we also cannot access an element based on index.
    The `removeFirst`/`LastOccurrence` methods' argument is the object that is to
    be removed. If we need this functionality we can use `Deque` even if we add and
    remove elements from the same end of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Why are there these methods in `Deque` and not in `Queue`? These methods have
    nothing to do with double headedness of `Deque`. The reason is that methods cannot
    be added to interfaces after they were released. If we add a method to an interface
    we break the backward compatibility because all classes that implement that interface
    have to implement the new method. Java 8 introduced default methods that eased
    this constraint, but the `Queue` interface was defined in Java 1.5 and the `Deque`
    interface was defined in Java 1.6\. There was no way at that time to add the new
    methods to the already existing interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `Map` pairs keys and values. If we want to approach a `Map` from the `Collection`
    point of view then a `Map` is a set of key/value pairs. You can put key value
    pairs into a `Map` and you can get a value based on a key. Keys are unique the
    same way as elements in a `Set`. If you look at the source code of the different
    implementations of the `Set` interface, you may see that some of them are implemented
    as a wrapper around a `Map` implementation where the values are simply discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Map`s is easy and alluring. Many languages, such as Python, Go, JavaScript,
    Perl, and so on, support this data structure on the language level. However, using
    a Map when an array would be sufficient is a bad practice that I have seen many
    times, especially in scripting languages. Java is not prone to that novice programmer
    error but you may still find yourself in a situation when you want to use a Map,
    and still there is a better solution. It is a general rule that the simplest data
    structure should be used that is sufficient for the implementation of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: HashMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`HashMap` is a hash table based implementation of the `Map` interface. As the
    map is based on a hash table, the basic `put` and `get` methods are performed
    in constant time. Additionally, as Map is very important, and because the most
    frequently used implementation in the JDK is `HashMap`, the implementation is
    fairly configurable. You can instantiate `HashMap` using the default constructor
    without argument, but there is also a constructor that defines the initial capacity
    and the load factor.'
  prefs: []
  type: TYPE_NORMAL
- en: IdentityHashMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IdentityHashMap` is a special `Map` that implements the `Map` interface literally,
    but as a matter of fact, it violates the contract the `Map` interface documentation
    defines. It does it with good reason. The implementation uses a hash table just
    as `HashMap`, but to decide the equality of the key found in the bucket comparing
    with the key element provided as argument to the get method it uses `Object` reference
    (`==` operator) and not the method `equals`, which is required by documentation
    of `Map` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of this implementation is reasonable when we want to distinguish different
    `Object` instances as keys that otherwise equal to each other. Using this implementation
    for performance reasons is almost certainly a wrong decision. Also, note that
    there is no `IdentityHashSet` implementation in the JDK. Probably such collection
    is so rarely used that its existence in the JDK would cause more harm than good
    alluring novice programmers to misuse.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we brieflyÂ already discussedÂ **dependency injection**
    (**DI**). Now we will dig into it a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Objects usually do not work on their own. Most of the time the implementation
    depends on the services of other classes. When we want to write something to the
    console we use the `System` class. When we manage the table of guesses we need
    `Color` objects and `ColorManager`.
  prefs: []
  type: TYPE_NORMAL
- en: In case of writing to the console we may not realize the dependency because
    the class being part of the JDK class library is available all the time and all
    we need to do is to write `System.out.println`. In this case this dependency is
    wired into the code. We cannot send the output somewhere else unless we change
    the code. This is not too flexible and in many cases we need a solution that can
    work with different output, different color manager or different whatever service
    our code depends on. The first step to do that is to have a field that has a reference
    of the object that gives our class the service. In case of output the type of
    the field can be of type `OutputStream`. The next, more interesting step is how
    this field gets value.
  prefs: []
  type: TYPE_NORMAL
- en: One of the solution is to use DI. In this approach some external code prepares
    the dependencies and injects them into the object. When the first call to a method
    of the class is issued all the dependencies are already filled and ready to be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this structure, we have four different players:'
  prefs: []
  type: TYPE_NORMAL
- en: The client object is the one that gets the injected service objects during the
    process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service object or objects are injected into the client object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injector is the code that performs the injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces define the service that the client needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we move the logic of the creation of the service objects from the client
    code the code becomes shorter and cleaner. The actual competency of the client
    class should hardly ever cover the creation of the service objects. For example
    a `Game` class contains a `Table` instance but a game is not responsible to create
    the `Table`. It is given to it to work with it, just as in real life that we model.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of service objects is sometimes as simple as issuing the `new`
    operator. Sometimes service objects also depend on other service objects and that
    way also act as clients in the process of dependency injection. In this case the
    creation of the service objects may be a lot of lines. The structure of the dependencies
    can be expressed in a declarative fashion that describes which service object
    needs which other service objects and also what implementation of the service
    interfaces are to be used. Dependency injection injectors work with such declarative
    descriptions. When there is a need for an object that needs service objects that
    themselves need again other service objects the injector creates the service instances
    in the appropriate order using the implementations that are matching the declarative
    descriptions. The injector discovers all the dependencies transitively and creates
    a transitive closure graph of the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The declarative description of the needed dependencies can be XML, or a special
    language developed especially for the dependency injection or it can even be Java
    itself using specially designed fluent API ([https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/](https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/)).
    XML was first used in **DI** injectors. Later **Groovy** based **Domain Specific
    Language** ([https://martinfowler.com/books/dsl.html](https://martinfowler.com/books/dsl.html))
    came into picture and Java fluent API approach. We will use only the last one
    being the most modern and we will use **Spring** and **Guice****DI** containers
    since they are the most well-known injector implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections without examples are boring. Fortunately, we have our game where
    we use a few collection classes and also other aspects that we will examine in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ColorManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We jumped into the pool filled with collection classes from the implementation
    of the `ColorManager` class. Let''s refresh the part of the class that is interesting
    for us nowâthe constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `HashMap` to keep the colors in an ordered list. At first, the
    choice of `HashMap` seems to be strange. Very true, that during the coding of
    `ColorManager`, I also considered a `List`, which seemed to be a more obvious
    choice. When we have a `List<Color> colors` variable, then the `nextColor` method
    is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor will be much simpler, as shown in the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Why did I choose the more complex solution and the unobvious data structure?
    The thing is performance. When the `nextColor` method is invoked, the list implementation
    first finds the element checking all the elements in the list and then fetches
    the next element. The time is proportional to the number of colors. When our number
    of colors increases, the time will also increase to just get the next color having
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, if we focus on not the data structure that comes from the
    verbal expression of the task we want to solve (get the colors in a sorted order)
    but rather focus on the actual method that we want to implement, `nextColor(Color)`,
    then we will easily come to the conclusion that a `Map` is more reasonable. What
    we need is exactly a `Map`Â : having one element we want another related to the
    one we have. The key and the value is also `Color`. Getting the next element is
    constant time using `HashMap`. This implementation is probably faster than the
    one based on `ArrayList`.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that it is only probably faster. When you consider refactoring
    a code to have better performance, your decision should always be based on measurements.
    If you implement a code that you only think is faster, practice shows, you will
    fail. In best case, you will optimize a code to be blazing fast and runs during
    the application server setup. At the same time, optimized code is usually less
    readable. Something for something.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization should never be done prematurely. Code for readability first. Then,
    assess the performance, and in case there is problem with the performance, then
    profile the execution and optimize the code where it hurts the most of the overall
    performance. Micro-optimizations will not help.
  prefs: []
  type: TYPE_NORMAL
- en: Did I do premature optimization selecting the `HashMap` implementation instead
    of `List`? If I actually implemented the code using `List` and then refactored,
    then yes. If I was thinking about the `List` solution and then it came to me that
    Â `Map` solution is better without prior coding, then I did not. By years, such
    considerations will come easier, as you will also experience.
  prefs: []
  type: TYPE_NORMAL
- en: The class color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already looked at the code for the class code and it was the simplest
    class in the world. In reality, as it is in the GitHub repository ([https://github.com/j9be/chapter04](https://github.com/j9be/chapter04)Â or
    [https://github.com/PacktPublishing/Java-9-Programming-By-Example/tree/master/Chapter04](https://github.com/PacktPublishing/Java-9-Programming-By-Example/tree/master/Chapter04)),
    the code is a bit more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have a special color constant named `none` that we use to signal a reference
    that is of type `Color` but is not a valid `Color`. In professional development,
    we used the `null` value for a long time to signal invalid reference, and because
    we are backward compatible, we still use it. However, it is recommended to avoid
    the `null` reference wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Tony Hoare ([https://en.wikipedia.org/wiki/Tony_Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)),
    who invented the `null` reference in 1965, admitted one time that this was a mistake
    that cost billions of dollars in the IT industry.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the `null` value is that it takes the control away from the
    class, and thus, opens encapsulation. If a method returns `null` in some situation,
    the caller is strictly required to check the nullity and act according to that.
    For example, you cannot call a method on a `null` reference and you cannot access
    any field. If the method returns, a special instance of the object these problems
    are less serious. If the caller forgets to check the special return value and
    invokes methods on the special instance, the methods invoked still have the possibility
    to implement some exception or error handling. The class has the control encapsulated
    and can throw a special exception that may give more information about the error
    caused by the programmatic mistake by the caller not checking the special value.
  prefs: []
  type: TYPE_NORMAL
- en: JavaDoc and code comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is also another difference between what we presented here earlier and
    the listing. This is the commenting of the code. Code comments are part of the
    program, which are ignored, filtered out by the compiler. These comments are solely
    for those who maintain or use the code.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there are two different comments. The code enclosed between `/*` and
    `*/` are comments. The start and the end of the comment do not need to be on the
    same line. The other type of comment starts with the `//` characters and ends
    at the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: To document the code, the JavaDoc tool can be used. JavaDoc is a special tool
    that reads the source code and extracts HTML documentation about the classes,
    methods, fields, and other entities that have a comment starting with the `/**`
    characters. The documentation will contain the JavaDoc comments in a formatted
    way and also the information that is extracted from the program code.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation also appears as online help in the IDE when you move the mouse
    over a method call or class name, if there is any. The JavaDoc comment can contain
    HTML codes, but it generally should not. If really needed, you can use `<p>` to
    start a new paragraph or the `<pre>` tags to include some preformatted code sample
    into the documentation, but nothing more gives real benefit. Documentation should
    be as short as possible and contain as few formatting as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are special tags that appear in the JavaDoc documentation. These are
    prefilled by the IDEs when you start to type a JavaDoc as `/**` and then press
    *Enter*. These are inside the comment and start with the `@` character. There
    are a predefined set of tags: `@author`, `@version`, `@param`, `@return`, `@exception`,
    `@see`, `@since`, `@serial`, and `@deprecated`. The most important tags are `@param`
    and `@return`. They are used to describe the method arguments and the return value.
    Although we are not there yet, let''s peek ahead to the `guessMatch` method from
    the `Guesser` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the parameter is automatically generated by the IDE. When you create
    the documentation, write something that is meaningful and not tautology. Many
    times, novice programmers feel the urge to write JavaDoc, and that something has
    to be written about the parameters. They create documentations like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Really? I would never haveÂ guessed. If you do not know what to write there
    to document the parameter, it may happen that you were choosing the name of the
    parameter excellent. The documentation of our preceding example will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Focus on what the method, class, and interface does and how it can be used.
    Do not explain how it works internally. JavaDoc is not the place for the explanation
    of the algorithm or the coding. It is used to help use the code. However, if somebody
    happens to explain how a method works, it is not a disaster. Comments can easily
    be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, a comment that is worse than nothing: outdated documentation
    that is not valid anymore. When the contract of the element has changed, but the
    documentation does not follow the change and is misleading the user who wants
    to call the method, interface, or class whatever will face serious bugs and will
    be clueless.'
  prefs: []
  type: TYPE_NORMAL
- en: From now on, JavaDoc comments will not be listed in print to save trees, and
    electrons in the eBook version, but they are there in the repository and can be
    examined.
  prefs: []
  type: TYPE_NORMAL
- en: Row
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have `Color`s and even instances if we need having a `ColorManager`.
    This is the time to store `Color`s in `Row`s. The `Row` class is a bit longer,
    but not too complex.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A `Row` contains three fields. One is the `positions` array. Each element of
    the array is a `Color`. The `matchedPositions` is the number of positions that
    are matched and `matchedColors` is the number of colors that match a color in
    the hidden row but is not on the position as in the hidden row.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `none` is a constant that contains a special `Row` instance that we will
    use wherever we would use `null`. The constructor gets the colors in an array
    that should be in the row.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The constructor makes a copy of the original array. This is an important code
    that we will examine a bit. Let's reiterate that Java passes arguments by value.
    It means that when you pass an array to a method, you will pass the value of the
    variable that holds the array. However, an array in Java is an Object just as
    well as anything else (except primitives like `int`). Therefore, what the variable
    contains is a reference to an object that happens to be an array. If you change
    the elements of the array, you actually change the elements of the original array.
    The array reference is copied when the argument passes, but the array itself,
    and the elements, are not.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.Arrays` utility class provides a lot of useful tools. We can
    easily code the array copying in Java but why to reinvent the wheel? In addition
    to that, arrays are continuous area of memory that can very effectively be copied
    from one place to another using low-level machine code. The `copyOf` method that
    we invoke calls the method `System.arraycopy`Â which is a native method and as
    such executes native code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no guarantee that `Arrays.copyOf` invokes the native implementations
    and that this will be extremely fast in case of large arrays. The very version
    I was testing and debugging was doing it that way, and we can assume that a good
    JDK does something similar, effective and fast.
  prefs: []
  type: TYPE_NORMAL
- en: After we copied the array, it is not a problem if the caller modifies the array
    that was passed to the constructor. The class will have a reference to a copy
    that will contain the same elements. However, note that if the caller changes
    any of the objects that are stored in the array (not the reference in the array,
    but the object itself that is referenced by an array element), then the same object
    is modified. `Arrays.copyOf` does not copy the objects that are referenced by
    the array, only the array elements.
  prefs: []
  type: TYPE_NORMAL
- en: The row is created along with the colors and thus, we used a `final` field for
    the `Color` array. The matches, however, cannot be known when a Row is created.
    One of the players creates the `Row` and after that, the other player will tell
    the two `int` values. We do not create two setters for the two values, however,
    because they are always defined at the same time in the game together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `setMatch` method does not only set the values, but also checks that the
    values are consistent. The sum of the two values cannot be more than the number
    of the columns. This check ensures that the caller, who uses the API of the `Row`
    class, does not use it inconsistently. If this API is used only from inside our
    code, this assertion should not be part of the code. A good coding style, in that
    case, will ensure that the method is never invoked inconsistently using unit tests.
    When we create API to use out of our control, we should check that the use is
    consistent. Failing to do so, our code may behave just weird when used inconsistently.
    When the caller sets matches to values that do not match any possible guess, the
    game may never finish and the caller may have a hard time figuring out what is
    going on. This figuring out probably will need the debug execution of our code.
  prefs: []
  type: TYPE_NORMAL
- en: If we throw an exception in this case, the program stops where the bug is. There
    is no need to debug the library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method decides if a guess, given as an argument, matches the actual
    row. This method checks that the answers to the guess in the row can be valid
    if the current guess was in the hidden row. The implementation is fairly short
    and simple. A guess matches a row if the number of the colors matching and the
    number of positions matching are the same as the number given in the row. Do not
    be shy to write short methods. Do not think that a one-line method that essentially
    contains one statement is useless. Wherever we use this method, we could also
    write the expression, which is right after the return statement, but we do not
    for two reasons. The first and most important reason is that the algorithm, which
    decides that a row matches a guess belongs to the implementation of the class
    `Row`. If ever the implementation changes, the only location where the code is
    to be changed is here. The other reason is also important, and that is readability.
    In our codebase, we call this method from `abstract class Guesser`. It contains
    an `if` statement with the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Would it be more readable in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I am certain that the majority of the programmers understand the intention of
    the first version easier. I would even recommend implementing the `doesNotMatchGuess`
    method to improve the readability of the code even more.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The number of matching colors is that which appears both in the row and the
    guess, but not in the same position. The definition, and how we calculate it,
    is fairly simple and unambiguous in case no color can appear twice in the hidden
    row. In case a color may appear multiple times in the hidden row, this implementation
    will count all occurrences of that color in the guess as many times as it appears
    in the hidden row. If we, for example, have a hidden `RRGB` row and the guess
    is `bYRR`, the calculation will say 4\. It is a matter of agreement between the
    players how they count in this case. The important aspect is that they use the
    same algorithm, which should be true in our case, because we will ask the program
    to play both players. As we will program the code ourselves, we can trust that
    it will not cheat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Counting the colors that are OK, and also on the position where they are supposed
    to be, is even simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This method tells the number of columns in the `Row`. This method is needed
    in the `Game` class that controls the flow of a whole game. As this class is in
    the same package as `Row`, it can access the field positions. I created the code
    to get the number of columns as `row.positions.length`. But then, I was reading
    the code next day and told myself: This is ugly and unreadable! What I am interested
    in here is not some mysterious positions'' length; it is the number of columns.
    And the number of columns is the responsibility of the `Row` class and not the
    business of any other class. If I start to store the positions in a `List`, which
    does not have `length` (it has method `size`), it is the sole responsibility of
    `Row` and should not affect any other code. So, I created the `nrOfColumns` method
    to improve the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the class contains some more very simple methods that are needed
    only to display the game and not for the algorithm to play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you are a purist, you can encapsulate these methods into an inner class named
    `Output` or `Print` and call them through a final instance of it created as a
    field in the `Row` class. It is also possible to change the visibility of these
    fields from `private` to `protected` and implement these methods in a `PrintableRow`
    that can be instantiated from an already existing `Row` and implement these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version of `PrintableRow` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The methods are exactly the same as in the preceding print; they are cut and
    pasted, or rather moved, using the IDE refactoring support from one class to the
    other.
  prefs: []
  type: TYPE_NORMAL
- en: When you write a code, please never use copy and paste. However you can use
    cut and paste to move code fragments around. The danger is in the copy paste use.
    Many developers claim that their use of actual copy and paste is not copy paste
    programming. Their reasoning is that they change the pasted code so much that
    it has practically nothing to do with the original code.
  prefs: []
  type: TYPE_NORMAL
- en: Really? In that case why did you need the copied code when you started the modification
    of it? Why not start from scratch? That is because if you use the IDE's copy and
    paste functionality then, no matter what, you do copy paste programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class `PrintableRow` is pretty neat and separates the output concern from the
    core functionality. When you need an instance, it is not a problem that you have
    a `Row` instance already in hand. The constructor will essentially clone the original
    class and return a printable version. What bothers me is the implementation of
    the cloning. The code in the constructor calls the super constructor and then
    a method and all these work with the original functionality of the `Row` class.
    They have nothing to do with the printability that `PrintableRow` implements.
    This functionality actually belongs to the `Row` class. We should create a protected
    constructor that does the cloning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of `PrintableRow` should simply call `super(row)` and that is
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code is never finished and never perfect. In a professional environment, programmers
    many times tend to finish polishing the code when it is good enough. There is
    no code that cannot be made better, but there is a deadline. The software has
    to be passed on to the testers and users and has to be used to help economy. After
    all, that is the final goal of a professional developer: have a code that supports
    the business. A code that never runs is worth nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: I do not want you to think that the examples that I provided here were created
    perfect upfront. The reason for that is (did you read carefully?) because they
    are not perfect. As I said, code is never perfect.
  prefs: []
  type: TYPE_NORMAL
- en: When I first created Row, it contained the printing methods in an inner class.
    I did not like it. The code was smelly. So, I decided to move the functionality
    to the `Row` class. However, I still did not like the solution. Then, I went to
    bed, slept, worked, and returned to it a few days later. What I could not create
    the day before now seemed obviousâthese methods have to be moved to a subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Now comes another dilemma. Should I present this final solution or should I
    have here the different versions? In some cases, I will just present the final
    version. In other cases, like this, there are things to learn from the development
    step. In these cases, I present not only the code, but part of its evolution on
    how it was created. If you want to see those that I did not dare publishing, look
    at the Git history. I admit, sometimes, I create code that even makes me facepalm
    a day later.
  prefs: []
  type: TYPE_NORMAL
- en: Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Table is a simple class that has only one very simple functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There is one thing to mention, which is nothing new, but worth repeating. The
    `rows` variable is declared as final and it gets the value in the constructor.
    This is a `List<Row>` type variable. The fact that it is `final` means that it
    will hold the same list object during its lifetime. The length, members, and other
    features of the list may and will change. We will add new rows to this list. Final
    object variables reference an object, but it does not guarantee that the object
    itself is immutable. It is only the variable that does not change.
  prefs: []
  type: TYPE_NORMAL
- en: When you do code review and explain to your colleagues what a class does, and
    you find yourself starting the explanation "this class is very simple" many times,
    it means the code is good.
  prefs: []
  type: TYPE_NORMAL
- en: Well, it may be wrong in other aspects, but the class' granularity seems to
    be okay.
  prefs: []
  type: TYPE_NORMAL
- en: Guesser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Guesser and the `UniqueGuesser` and `GeneralGuesser` subclasses are the most
    interesting classes of the program. They actually perform the task that is the
    core of the game. Given a `Table` with a hidden row, the guesser has to create
    newer and newer guesses.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, a `Guesser` needs to get a `Table` when it is created. This is passed
    as a constructor argument. The only method it should implement is `guess`, which
    returns a new guess based on the table and on its actual state.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we want to implement a guesser that assumes that all colors in the hidden
    row are different, and also one that does not make this assumption, we will implement
    three classes. `Guesser` is an abstract class that implements only the logic that
    is independent from the assumptions. These methods will be inherited by both actual
    implementations: `UniqueGuesser` and `GeneralGuesser`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the actual code of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The state of the guesser is the last guess it made. Although this is on the
    last row of the table, it is more of an internal matter of the guesser. The guesser
    has all the possible guesses, one after the other; `lastGuess` is the one where
    it left off last time and it should continue from there when it is invoked again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Setting the first guess very much depends on the assumption of color uniqueness.
    The first guess should not contain duplicated colors in case the hidden row does
    not (at least in our implementation), while `GeneralGuesser` is free to guess
    any time, even as `firstGuess` all colors to be the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Again, `none` in this class is just an object that we try to use instead of
    `null`, whenever we need to return something that is a reference to a `Guess`
    but is not really a guess.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `nextGuess` method is an internal method that generates the next guess,
    which just comes as we order the possible guesses. It does not check anything
    against the `Table`; it only generates the next guess almost without thinking.
    The implementation on how we do the first guess and how we do the consecutive
    guesses are different. Thus, we will implement these algorithms in different methods
    and invoke them from here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nextNonFirstGuess` method represents the next guess in the special case
    when the guess is not the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Look back a few pages where we detailed how the algorithm works. We made the
    statement that this way of working is very much like the way we count with decimal
    numbers. By now, you have enough Java knowledge and programming skill to understand
    what the method does. It is more interesting to know why it is coded that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: as always, to be readable.'
  prefs: []
  type: TYPE_NORMAL
- en: There is the temptation to eliminate the `guessFound` variable. Would it not
    be simpler to return from the middle of the method when we find the blessed guesses?
    If we did, there would be no need to check the `guessFound` value before returning
    `none` value. The code would not get there if we returned from the middle of the
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, it would be simpler to write. But, we create code to be readable and not
    writable. Yes, but less code is more readable. Not in this case! Returning from
    a loop degrades the readability. Not to mention, the `return` statements are scattered
    around in the method at different stages of execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When somebody writes a code optimized in that way, it is similar to a toddler
    who makes his first steps and then looks proudly at the mother. Okay boy/girl,
    you are great. Now go on and start walking. When you are the postman, walking
    will be boring. That will be your profession. So, slide aside the pride and write
    boring code. Professionals write boring code. Won't it be slow?
  prefs: []
  type: TYPE_NORMAL
- en: No! It will not be slow. First of all, it is not slow until the profiler proves
    that the code does not meet the business requirements. If it does, it is fast
    enough, no matter how slow it is. Slow is good asÂ long as it is okay for the business.
    After all, JIT should have some task optimizing the code to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method checks if the guess matches the previous guesses and their
    results on the `Table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we have the guess matching already implemented in the class `Row`, all we
    have to do is invoke that method for each row in the table. If all rows match,
    then the guess can be good for the table. If any of the former guesses do not
    match, then this guess goes down the drain.
  prefs: []
  type: TYPE_NORMAL
- en: As we check the negated expression of matching, we created an English version
    of the method.
  prefs: []
  type: TYPE_NORMAL
- en: In situations like this, it could be enough to create the `guessDoesNotMatch`
    version of the method. However, the logical execution of the code is more readable
    if the method is not negated. Therefore, it is more error prone to write the `guessDoesNotMatch`
    method alone. Instead, we will implement the original, readable version and the
    aux method to be nothing more than a negation.
  prefs: []
  type: TYPE_NORMAL
- en: After all the aux methods, here we are implementing the public method of the
    `Guesser`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It just takes the `nextGuess` and again and again until it finds one that matches
    the hidden row, or there is no more guess. If it finds a proper guess, it encapsulate
    it to a `Row` object and return it so that it can later be added to the `Table`
    by the `Game` objects.
  prefs: []
  type: TYPE_NORMAL
- en: UniqueGuesser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class `UniqueGuesser` has to implement `setFirstGuess` (all concrete classes
    extending an abstract class should implement the abstract method of the parent)
    and it can and will override the protected `nextGuess` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `setFirstGuess` method selects the first guess in such a way that any possible
    color variations that come after the first one create the guesses one after the
    other if we follow the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The aux `isNotUnique` method returns true if the guess contains duplicate colors.
    It is not interesting to see how many. If all colors are the same, or only one
    color appears twice, it does not matter. The guess is not unique and does not
    fit our guesser. This method judges that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To do this, it uses a `Set`, and any time a new color is found in the `guess`
    array, the color is stored in the set. If the set contains the color when we find
    it in the array, it means that the color was already used before; the guess is
    not unique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The overriding `nextGuess` method is simple. It asks the super `nextGuess` implementation
    to make guesses but throws away those that it does not like.
  prefs: []
  type: TYPE_NORMAL
- en: GeneralGuesser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class `GeneralGuesser` also has to implement the constructor and `setFirstGuess`,
    but generally, that is it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `lastGuess` it just puts the first color on all columns. Guess could
    not be simpler. Everything else is inherited from the `abstract class Guesser`.
  prefs: []
  type: TYPE_NORMAL
- en: The Game class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An instance of the `Game` class contains a `Row` holding the secret color values
    and also contains a `Table`. When there is a new guess the `Game` instance stores
    the guess into the `Table` and also sets the number of positions and colors matching
    the secret row.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Think about what I wrote earlier about short methods, and when you download
    the code from GitHub to play with it, try to make it look more readable. You can,
    perhaps, create and use a method named `boolean itWasAWinningGuess(int positionMatch)`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an integration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created unit tests in the previous chapter and there are unit tests
    for the functionalities implemented in the classes of this chapter as well. We
    will just not print these unit tests here. Instead of listing the unit tests,
    we will look at an integration test.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests need the invocation of many classes working together. They
    check that the functionality can be delivered by the whole application, or at
    least a larger part of the application, and do not focus on a single unit. They
    are called integration tests because they test the integration between classes.
    The classes alone are all OK. They should not have any problem as it was already
    verified by the unit tests. Integration focuses on how they work together.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to test the `Game` class, we will either have to create mocks that
    mimic the behavior of the other `Game` classes, or we will just write an integration
    test. Technically, an integration test is very similar to a unit test. Many times,
    the very same JUnit framework is used to execute the integration tests. This is
    the case for the integration test of this game.
  prefs: []
  type: TYPE_NORMAL
- en: The build tool, however, needs to be configured to execute the integration tests
    only when it is required. Usually, integration test executions need more time,
    and sometimes resources, such as external database that may not be available at
    each and every developer desktop. Unit tests run every time the application is
    compiled so they have to be fast. To separate the unit and integration tests,
    there are different techniques and configuration options, but there is no such
    more or less de-facto standard like the directory structure introduced by Maven
    (later adapted by Gradle).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the integration test does not need any extra resource and does
    not take enormous time to run. It plays a game from the start to the end and plays
    the role of both the players. It is very much like somebody playing chess with
    themselves, making a step and then turning the table.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this code is twofold. On one hand, we want to see that the code runs
    and plays a whole game. If the game finishes, then it is just OK. This is a very
    weak assertion and real integration tests perform lots of assertions (one test
    tests only one assertion though). We will focus on the other aimâdeliver some
    joy and visualize the game on the console in text format so that the reader does
    not get bored.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we will create a utility class that prints out a color and assigns
    letters to the `Color` instances on the fly. This is the `PrettyPrintRow` class.
    There are several limitations in this class that we have to talk about after we
    look at the code. I'd say that this code is here only to demonstrate what not
    to do, to establish some reasoning for the next chapter, and why we need to refactor
    the code we created in this one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is the heart of this class. When a color is to be printed, it gets a letter
    assigned unless it already has one. As the `Map` containing the assignments in
    each and every game that is running in the JVM will use the same mapping, a new
    `Game` is started. It allocates new `Color`s and will soon run out of the six
    characters that we allocated here in the `String` constant.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Game` instances are run parallel, then we are in even more trouble.
    The class is not thread safe at all. If two threads concurrently call the `colorToChar`
    method for the same `Color` instance, (which is not likely because each `Game`
    uses its own color, but note that *not likely* in programming is very much like
    a famous last words quote on a tombstone) then both threads may see at the same
    time that there is no letter assigned to the color and both will assign the letter
    (the same letter or two different letters, based on luck) and increase the counter
    once or twice. At least, what we can say is that the execution is nondeterministic.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that I said violating the hash contract is the second most difficult
    to find bug after multithread issues. Such a nondeterministic code is exactly
    that: a multithread issue. There is no prize to find the most difficult bug. When
    the application does not run, and a bug affects the production system for hours
    or days, no businessperson will be happy, and they will not be amazed after you
    find the bug. It may be an intellectual challenge, but the real value is not creating
    the bugs in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: As a summary, this code can only be used once in a JVM by a single thread. For
    this chapter, it is good, though a smelly and shameful code, but it will be a
    good example for the next chapter, in which we will see, how to refactor the application
    so that it will not need such a hacking to print out the colors.
  prefs: []
  type: TYPE_NORMAL
- en: Code smell is a term minted by Kent Back, according to Martin Fowler ([http://martinfowler.com/bliki/CodeSmell.html](http://martinfowler.com/bliki/CodeSmell.html)).
    It means that some code looks not good, nor apparently bad, but some constructs
    make the feeling in the developer that it may not be good. As it is defined on
    the web page, *"A code smell is a surface indication that usually corresponds
    to a deeper problem in the system."* The term is widely accepted and used in software
    development for the last 10 years.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the code is plain and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The integration test, or rather the demonstration code (as it does not contain
    any assertions other than it runs without exception), defines six colors and four
    columns. This is the size of the original game. It creates a color manager, and
    then it creates a table and a secret. The secret could be just any random color
    selection from the six colors that is available (there are 360 different possibilities
    tested in the `UniqueGuesserTest` unit test available from GitHub). As we know
    that the `Guesser` implementation starts from one end of the color set and creates
    the new guesses systematically, we want to set a secret that it will guess the
    last. This is not because we are evil, but rather because we want to see that
    our code really works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory structure of the code is very similar to the one we used in case
    of the Maven build tool, as can be seen on the following screenshot created on
    a Windows machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The source code is under the directory `src` and the `main` and `test` source
    code files are separated into two subdirectory structures. The compiled files
    will be generated in the directory `build` when we use Gradle. The code of the
    integration test class is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to run the test is start it from inside the IDE. When the IDE
    imports the project based on the build file, be it a Maven `pom.xml` or Gradle
    `build.gradle`. IDE usually provides a run button or menu to start the code. Running
    the game will print out the following piece of code that we worked so hard on
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we programmed a table game: Mastermind. We not only programmed
    the model of the game, but also created an algorithm that can guess. We revisited
    some OO principles and discussed why the model was created the way it was. While
    we created the model of the game, which we will refine in the next chapter, you
    have learned about Java collections, what an integration test is, and how to create
    JavaDoc.'
  prefs: []
  type: TYPE_NORMAL
