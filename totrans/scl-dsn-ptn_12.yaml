- en: Real-Life Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的应用
- en: We have come a long way in the world of design patterns in Scala. We saw some
    classical *Gang of Four* design patterns from the point of view of Scala, as well
    as features that are applicable specifically to this programming language. By
    now, you should have enough knowledge in order to build high-quality, extendible,
    efficient, and elegant applications. Everything we have covered until now, if
    taken into consideration, should have a really positive impact on any application
    you will create.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala的设计模式世界中，我们已经走了很长的路。我们从Scala的角度看到了一些经典的*四人帮*设计模式，以及适用于这种编程语言的具体特性。到现在为止，你应该已经拥有了足够的知识来构建高质量、可扩展、高效和优雅的应用程序。到目前为止我们所涵盖的一切，如果综合考虑，应该会对你创建的任何应用程序产生真正积极的影响。
- en: 'Many of the things you saw in this book we wrote from scratch. This is really
    helpful in terms of understanding a given concept, but it takes time, and in real-world
    applications, using a library that gives us some functionalities is usually preferred.
    There are a number of different libraries available that are accessible through
    a simple Google search and address just about anything you can think of. Apart
    from the fact that this could save a lot of time, it also means that we integrate
    into our code thoroughly tested components that are trusted by many others. This,
    of course, depends on the library we are trying to incorporate, but as long as
    it brings something useful to the community, it will most likely be reliable.
    Having said all that, our main focus of this chapter will include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们看到的大部分内容都是从头开始编写的。这有助于理解给定的概念，但需要时间，而在现实世界的应用程序中，使用提供某些功能的库通常更受欢迎。通过简单的谷歌搜索就可以找到许多不同的库，它们几乎可以解决你所能想到的任何问题。除了可以节省大量时间之外，这也意味着我们将彻底测试过的、被许多人信任的组件整合到我们的代码中。当然，这取决于我们试图整合的库，但只要它为社区带来有用的东西，它很可能就是可靠的。话虽如此，我们本章的主要焦点将包括以下内容：
- en: The Scalaz library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scalaz库
- en: Writing a complete application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写完整的应用程序
- en: Summarizing what we have learned so far
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结到目前为止我们所学的
- en: There are a lot of libraries for Scala out there and some might consider other
    libraries to be much more important to the language than Scalaz is. There are
    alternatives as well, which have spun up due to various reasons. We will, however,
    focus on Scalaz here, as it is generally used when someone wants to implement
    concepts such as monoids, functors, and monads in their application. And these
    concepts are really important in functional programming, as we saw earlier. We
    will also write a complete application that uses some of the techniques and design
    patterns we became familiar with in the previous chapters. This chapter will give
    some insights into how applications should be structured and how to understand
    our requirements and then build the solutions for them properly. Finally, we will
    summarize everything we have learned here.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多Scala库，有些人可能认为其他库比Scalaz对语言更重要。由于各种原因，也有一些替代品被创造出来。然而，我们将在这里关注Scalaz，因为它通常被用来在应用程序中实现诸如单子、函子、和单子等概念。正如我们之前所看到的，这些概念在函数式编程中非常重要。我们还将编写一个完整的应用程序，使用我们在前几章中熟悉的一些技术和设计模式。这一章将提供一些关于应用程序应该如何构建、如何理解我们的需求以及如何正确构建解决方案的见解。最后，我们将总结在这里所学的所有内容。
- en: Reasons to use libraries
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库的原因
- en: Writing software applications will inevitably bring developers to the point
    where they will have to implement something that already exists. Reinventing the
    wheel is generally a bad idea unless we have some extremely specific and strict
    requirements that no library in the world satisfies, or if there is good reason
    not to include a specific dependency in our project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编写完整的软件应用程序不可避免地会将开发者带到需要实现已经存在的东西的地步。除非我们有极其具体和严格的要求，世界上没有任何库能满足这些要求，或者有很好的理由不将特定的依赖项包含在我们的项目中，否则重新发明轮子通常是一个坏主意。
- en: People write libraries to deal with all kinds of problems in software. In a
    community such as the open source community, libraries are shared and everyone
    can use or contribute to them. This brings a lot of benefits, and the main benefit
    is that code becomes more mature, better tested, and more reliable. However, sometimes
    this also makes things harder—many people will create the same library and it
    becomes difficult to understand which one is the most suitable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 人们编写库来处理软件中的各种问题。在一个像开源社区这样的社区中，库是共享的，每个人都可以使用或为其做出贡献。这带来了很多好处，主要的好处是代码变得更加成熟、经过更好的测试和更可靠。然而，有时这也使得事情变得更难——许多人会创建相同的库，这使得理解哪个是最合适的变得困难。
- en: Despite the fact that there could be multiple implementations of the same library,
    using one is the way to go when we write enterprise applications. Filtering out
    the bad ones from the good ones is easy nowadays—if a library is good, many people
    will use it. If it's bad, people will avoid it. If there are multiple good ones,
    developers will have to spend some time investigating which one is the most suitable
    for their use case.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能存在多个相同库的实现，但在编写企业应用程序时，使用一个库是最佳选择。现在从好的库中筛选出不好的库变得容易——如果一个库是好的，许多人会使用它。如果它不好，人们会避免它。如果有多个好的库，开发者将不得不花一些时间调查哪个最适合他们的用例。
- en: The Scalaz library
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scalaz 库
- en: Scala is a functional programming language and, as such, it supports design
    patterns based on concepts such as monoids, monads, and others. We already saw
    these in [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml), *Functional
    Design Patterns - the Deep Theory*, and we know the rules they follow and the
    structure they have. We wrote everything ourselves, but a library already exists
    that does this for us—Scalaz ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz)).
    This library is used when we need purely functional data structures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是一种函数式编程语言，因此它支持基于诸如幺半群、单子等概念的编程模式。我们已经在第 10 章 [功能设计模式 - 深度理论](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml)中看到了这些模式，并且我们知道它们遵循的规则和结构。我们都是自己编写的，但已经存在一个库可以为我们完成这项工作——Scalaz
    ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz))。当我们需要纯函数式数据结构时，我们会使用这个库。
- en: Another library that has a similar popularity to Scalaz in the community is
    Cats ([https://github.com/typelevel/cats](https://github.com/typelevel/cats)).
    They should both be able to help developers achieve the same functional programming
    concepts. In most cases, the choice between the two is based on personal preference,
    local community culture or company policies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在社区中与 Scalaz 具有相似知名度的另一个库是 Cats ([https://github.com/typelevel/cats](https://github.com/typelevel/cats))。它们都应该能够帮助开发者实现相同的函数式编程概念。在大多数情况下，两者之间的选择基于个人偏好、本地社区文化或公司政策。
- en: We have already encountered Scalaz in the previous chapter when we talked about
    lenses. In the following subsections, we will look at the library from the point
    of view of monoids, functors, and monads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章我们讨论透镜时，我们已经遇到了 Scalaz。在接下来的小节中，我们将从幺半群、函子、单子的角度来审视这个库。
- en: Monoids in Scalaz
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scalaz 中的幺半群
- en: 'One of the concepts we looked at in [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml),
    *Functional Design Patterns - the Deep Theory*, was monoids. We defined a trait
    and some rules for them and then showed examples of how to use them and what they
    are good for. In these examples, we defined monoids for integer addition and multiplication
    as well as string concatenation. Scalaz already has a `Monoid` trait that we can
    use to write our own monoids. Also, this trait has a few monoids that we have
    defined before already implemented:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 10 章 [功能设计模式 - 深度理论](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml)中探讨的一个概念是幺半群。我们为它们定义了一个特质和一些规则，然后展示了如何使用它们以及它们的好处。在这些示例中，我们为整数加法和乘法以及字符串连接定义了幺半群。Scalaz
    已经有一个 `Monoid` 特质，我们可以用它来编写自己的幺半群。此外，这个特质已经实现了我们之前定义的一些幺半群：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we just showed how you can implement a custom monoid.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们展示了如何实现一个自定义的幺半群。
- en: The `stringConcatenation` monoid is defined in a package object. This means
    that it will be available to any code in the same package without the need to
    import anything. We take advantage of this in some of the following examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringConcatenation` 幺半群是在一个包对象中定义的。这意味着它将无需导入任何内容即可在同一个包中的任何代码中使用。我们在以下一些示例中利用了这一点。'
- en: There also exists a string concatenation monoid, but here we just showed how
    you can opt for implementing the custom monoid if it doesn't exist. It is quite
    similar to what we had earlier. The difference is only in the name for the operation
    method (`append`) and its signature. However, this is just a minor difference.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也存在一个字符串连接单子，但在这里我们只是展示了如果不存在，你可以选择实现自定义单子的方法。它与之前的方法非常相似。区别仅在于操作方法（`append`）及其签名。然而，这只是微小的差异。
- en: Using monoids
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单子
- en: 'Using Scalaz monoids is pretty straightforward. Here is an example program:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Scalaz 单子非常直接。以下是一个示例程序：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The imports in our code make sure that we can call `foldMap` on our list of
    numbers. If we run this example, we will get the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中的导入确保我们可以对我们的数字列表调用 `foldMap`。如果我们运行这个示例，我们将得到以下输出：
- en: '![](img/6df0dd37-2053-4937-aaca-79153cf7100f.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6df0dd37-2053-4937-aaca-79153cf7100f.png)'
- en: Looking at the output and the code, you can see that for integer addition and
    multiplication, we have used the built-in monoids of Scalaz. The `sum` monoid
    takes precedence and is actually passed to `foldMap` implicitly. For the multiplication
    to work, we have to pass `Tags.Multiplication.apply` in order to make things work
    as expected. We have explicitly passed our string concatenation monoid to make
    the last statement work correctly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看输出和代码，你可以看到对于整数加法和乘法，我们使用了 Scalaz 的内置单子。`sum` 单子具有优先级，并且实际上是以隐式方式传递给 `foldMap`
    的。为了使乘法正常工作，我们必须传递 `Tags.Multiplication.apply` 以使事情按预期工作。我们显式地传递了我们的字符串连接单子，以便使最后一个语句正确工作。
- en: Testing monoids
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试单子
- en: 'We know that monoids have to satisfy some specific laws. Our examples are simple
    enough to see that the laws are actually in place, but sometimes it might not
    be that obvious. In Scalaz, you can actually test your monoids:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道单子必须满足一些特定的定律。我们的示例足够简单，可以清楚地看到定律实际上已经到位，但有时可能并不那么明显。在 Scalaz 中，你可以实际测试你的单子：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to be able to compile and run the preceding example, we will need
    to have the following dependencies added to our `pom.xml` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够编译和运行前面的示例，我们需要将以下依赖项添加到我们的 `pom.xml` 文件中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The equivalent `build.sbt` file will need to have the following dependencies
    added:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 `build.sbt` 文件需要添加以下依赖项：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code sections are just fragments of the code examples coming with
    this book. These dependencies add bindings to ScalaCheck ([https://www.scalacheck.org/](https://www.scalacheck.org/))—a
    property-based testing framework. The preceding code will test our custom monoid
    for all the laws and fail if it doesn't satisfy them. Writing tests for our custom
    classes will require us to have an `Arbitrary` implementation as well as have
    our monoid implicitly available in the test scope.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码部分只是本书附带代码示例的片段。这些依赖项将 ScalaCheck ([https://www.scalacheck.org/](https://www.scalacheck.org/))—一个基于属性的测试框架的绑定添加到我们的代码中。前面的代码将测试我们的自定义单子是否满足所有定律，如果不满足则失败。为我们的自定义类编写测试需要我们有一个
    `Arbitrary` 实现以及在我们的测试作用域中隐式提供我们的单子。
- en: Monads in Scalaz
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scalaz 中的单子
- en: In [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml), *Functional Design
    Patterns - the Deep Theory*, we also looked at monads. If you remember, we had
    to define a functor trait first and then extend it in the monad trait. Similar
    to monoids, monads also follow some specific rules that have to be in place.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 章](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml)，*函数式设计模式 - 深入理论*中，我们也探讨了单子。如果你还记得，我们首先必须定义一个函子特质，然后在单子特质中扩展它。与单子类似，单子也遵循一些特定的规则，这些规则必须到位。
- en: Using monads
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单子
- en: Scalaz defines quite a lot of different methods that can be applied directly
    to any monad we have. There are multiple examples that show lists and options.
    The library also has a `Monad` trait that can be extended. It is similar to the
    `Monoid` trait.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Scalaz 定义了相当多的不同方法，可以直接应用于我们拥有的任何单子。有多个示例展示了列表和选项。该库还有一个可以扩展的 `Monad` 特质，它与
    `Monoid` 特质类似。
- en: 'We don''t want to dig into list examples that show how to use monads, though.
    To make things interesting, let''s look at the `IO` monad in Scalaz that can be
    used to perform I/O in a monadic way. What this basically means is that we can
    describe and compose those actions without actually performing them. This will
    lead to better code reuse as well. Let''s see an example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想深入探讨展示如何使用单子的列表示例。为了使事情更有趣，让我们看看 Scalaz 中的 `IO` 单子，它可以以单子的方式执行 I/O。这基本上意味着我们可以描述和组合这些动作，而不必实际执行它们。这将导致更好的代码重用。让我们看一个示例：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First of all, we defined some methods in a package object that can manipulate
    files. There is absolutely nothing special about them. They seem pretty similar
    to what we did in [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml), *Functional
    Design Patterns - the Deep Theory*, when we showed our custom `IO` monad. In the
    `readFile` and the `writeFile`, we added prints to help in debugging and show
    exactly what is going on. This will be really useful later.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在一个包对象中定义了一些可以操作文件的方法。它们绝对没有什么特别之处。它们看起来和我们在第10章中做的很相似，*功能设计模式 - 深入理论*，当我们展示了我们的自定义`IO`单调子。在`readFile`和`writeFile`中，我们添加了打印语句以帮助调试并显示正在发生的事情。这将会非常有用。
- en: 'We will make our application read a tab-separated file of data of people, parse
    it, and write it either to a file or the console. The example file will have the
    following content:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使我们的应用程序读取一个包含人员数据的制表符分隔文件，解析它，并将其写入文件或控制台。示例文件将包含以下内容：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Of course, we have a model that will reflect this file and it will be as simple
    as this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们有一个模型可以反映这个文件，它将和这样一样简单：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Together with the model, we've shown its companion object. It has one method
    that returns an optional `Person` object given an array of strings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与模型一起，我们还展示了它的伴生对象。它有一个方法，根据一个字符串数组返回一个可选的`Person`对象。
- en: 'Now it''s time to see our application and explain what is going on:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们的应用程序并解释正在发生的事情了：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's now see what exactly is going on in the previous listing. The actual code
    is in the first pattern matching case. The rest is some validation to run a console
    application and the parameters passed to it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看前面的列表中到底发生了什么。实际的代码在第一个模式匹配情况中。其余的是一些用于运行控制台应用程序及其参数的验证。
- en: The first thing to pay attention to is the calls to `.pure[IO]`, which is there
    for the `people` variable and when we write to the file. This method takes the
    value given to it and lifts it into a monad. Another important thing is that the
    value passed to the method is lazily evaluated. In our example, the monad is the
    `IO` monad.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是对`.pure[IO]`的调用，这是针对`people`变量以及我们写入文件时的。这个方法接受它给出的值并将其提升到单调子中。另一件重要的事情是传递给方法的值是惰性评估的。在我们的例子中，单调子是`IO`单调子。
- en: 'Secondly, we can see some references to the `putStrLn` and `readLn` methods.
    Their names should be enough to explain what they do. They come from the `scalaz.effect.IO`
    object, that we have imported into our application. And this import requires another
    dependency in our `pom.xml` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以看到一些对`putStrLn`和`readLn`方法的引用。它们的名字应该足以解释它们的功能。它们来自我们导入到应用程序中的`scalaz.effect.IO`对象。这个导入需要在我们的`pom.xml`文件中添加另一个依赖项：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The equivalent dependency in the `build.sbt` file will be the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sbt`文件中的等效依赖项将是以下内容：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `putStrLn` and `readLn` methods also return an instance of the `IO` monad
    and they are just helpers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`putStrLn`和`readLn`方法也返回`IO`单调子实例，它们只是辅助工具。'
- en: Now, because our application is monadic and we use the `IO` monad, nothing will
    happen unless we do something about it. To trigger the actual actions, we must
    call `unsafePerformIO` on an `IO` instance. We've added some `print` statements
    that will prove that the code works as we expected it to.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们的应用程序是单调的，我们使用了`IO`单调子，除非我们采取行动，否则什么都不会发生。要触发实际的操作，我们必须在`IO`实例上调用`unsafePerformIO`。我们已经添加了一些`print`语句，以证明代码按预期工作。
- en: 'Since we have two branches for our application, we will make two runs here.
    One that prints and another one that writes to a file. The example outputs are
    in the following screenshots:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序有两个分支，我们在这里将进行两次运行。一个是打印，另一个是写入文件。示例输出在以下屏幕截图中：
- en: '![](img/01468d76-d143-47db-a3c8-efa72c9a068d.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01468d76-d143-47db-a3c8-efa72c9a068d.png)'
- en: The preceding screenshot shows the run that prints to the console. We can see
    that the reading from the file log comes after the initial logs from our application,
    even though we called the method earlier. This proves that indeed the `.pure[IO]`
    call lifts our function without evaluating it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了打印到控制台的运行。我们可以看到，尽管我们较早调用了该方法，但文件日志的读取发生在我们应用程序的初始日志之后。这证明了`.pure[IO]`调用确实提升了我们的函数而没有评估它。
- en: 'Similarly to the previous output, the following output shows that nothing happens
    until the very last moment when we write the output filename and hit *Enter*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于前面的输出，下面的输出显示，直到我们写入输出文件名并按*Enter*键，什么都不会发生：
- en: '![](img/24765bef-4f21-4e81-9cc8-1c0e845c7ddc.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24765bef-4f21-4e81-9cc8-1c0e845c7ddc.png)'
- en: 'Our example shows that the `IO` monad helps us to build a computation and execute
    it at the very last moment. Here, we''ve decided to surround it with a for comprehension
    and call `pure[IO]` on it so that we can actually use the read and write methods
    without monads if we want to. In other cases, you can make sure to return an `IO`
    monad from the read and write methods and then define mapping methods, which also
    return the `IO` monads and use them inside the for comprehensions. This would
    look like something similar to this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例表明，`IO`单子帮助我们构建计算并在最后一刻执行它。在这里，我们决定用for推导包围它，并在其上调用`pure[IO]`，这样我们就可以在不使用单子的情况下实际使用读取和写入方法。在其他情况下，你可以确保从读取和写入方法返回一个`IO`单子，然后定义映射方法，这些方法也返回`IO`单子，并在for推导中使用它们。这看起来可能像这样：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This version actually looks more monadical. We have enclosed smaller entities
    in the `IO` monad that we have combined and probably there will be more examples
    available online that follow this approach. This version actually also leaves
    the `read` method intact. The only thing in this case is that the for comprehension
    behaves differently than usual.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本实际上看起来更像是单子。我们用`IO`单子封装了较小的实体，并将它们组合起来，可能在网上会有更多遵循这种方法的示例。这个版本实际上也保留了`read`方法不变。在这种情况下，唯一不同的是for推导的行为与通常不同。
- en: Which approach is used will probably depend on personal preferences and what
    someone wants to achieve.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 采用哪种方法可能取决于个人偏好以及某人想要实现的目标。
- en: The preceding example is similar to what we did in [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml),
    *Functional Design Patterns - the Deep Theory*, with our custom I/O monad. Here,
    however, we can see that there is much less extra code than before.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子类似于我们在第10章中做的，即我们的自定义I/O单子，*功能设计模式 - 深度理论*。然而，在这里，我们可以看到比以前少得多的额外代码。
- en: Testing monads
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试单子
- en: Scalaz provides facilities to test monads as well. The tests look no different
    than what we saw for monoids, but here we simply have to use `monad.laws` instead.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Scalaz还提供了测试单子的设施。测试看起来和我们所看到的单子测试没有太大区别，但在这里我们只需要使用`monad.laws`即可。
- en: The possibilities of Scalaz
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scalaz的可能性
- en: We only looked at a handful of concepts covered by the Scalaz library. It contains
    much more than just that. You can think of Scalaz as an addition to Scala that
    makes it even more functional. It provides various type classes, data types, pimp
    my library instances for standard collections, out-of-the-box functionality for
    various standard types, and so on. The purposes also vary—from writing purely
    functional applications to making your code more readable. Scalaz is so vast that
    we can write a separate book about it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只看了Scalaz库涵盖的一些概念。它包含的远不止这些。你可以把Scalaz看作是Scala的一个补充，使其更加函数式。它提供了各种类型类、数据类型、为标准集合的库实例添加功能、为各种标准类型提供开箱即用的功能等等。目的也各不相同——从编写纯函数式应用程序到使代码更易读。Scalaz如此庞大，以至于我们可以为它写一本书。
- en: It seems that people find it difficult to use Scalaz at first and only later
    do they get to know the possibilities it provides. We would like to encourage
    you to become familiar with the documentation and everything the library provides.
    There are also various blog posts for all levels of difficulty, which can be a
    real eye-opener for the first time user of Scalaz.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎人们一开始觉得Scalaz很难用，只有后来才了解到它提供的可能性。我们鼓励你熟悉文档和库提供的所有内容。还有各种不同难度的博客文章，对于Scalaz的新用户来说，这些文章可能是一扇真正的启蒙之门。
- en: Writing a complete application
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写完整的应用程序
- en: So far in the book, we've seen a lot of examples. Some of them were quite complete,
    while others were meant to demonstrate only a specific part of what we were looking
    at. In real applications, it is most likely that you will have to combine multiple
    design patterns that we went through. In order to do so properly, it is important
    that the requirements are well understood. In the following subsections, we will
    provide the application specifications and then we will go step by step through
    actually writing the application. The amount of code we write will be a lot, so
    we will focus on the more important parts of our application and we might skip
    others.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在书中我们已经看到了很多例子。其中一些相当完整，而另一些只是用来展示我们所观察到的特定部分。在实际应用中，你很可能会需要结合我们所学过的多个设计模式。为了正确地做到这一点，理解需求是非常重要的。在接下来的子节中，我们将提供应用程序规范，然后我们将一步一步地通过实际编写应用程序。我们将编写的代码量会很多，所以我们将关注我们应用程序中更重要的部分，我们可能会跳过其他部分。
- en: Application specifications
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序规范
- en: Before doing anything, we must always have some specifications. Sometimes, these
    specifications are not entirely clear and it is our responsibility to make sure
    everything is detailed enough for us to understand and achieve them. However,
    in an actual software engineering process, it will likely be the case that we
    start doing something when the requirements are not 100% clear and things change
    halfway through the project. It could be frustrating at times, but that is life
    and we have to deal with it. It also makes things interesting and dynamic and
    makes developers think of even more possibilities and problems that could arise
    when users use a given application. Some developers might refuse to even start
    working on an application that is not completely defined. They might have a valid
    point and this depends on how critical the tasks are, but generally, this kind
    of attitude doesn't take projects far.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，我们必须始终有一些规范。有时，这些规范并不完全清楚，我们的责任是确保一切足够详细，以便我们理解和实现它们。然而，在实际的软件开发过程中，我们可能会在需求不是100%明确的情况下开始做某件事，而且事情会在项目进行中发生变化。有时可能会很沮丧，但这就是生活，我们必须应对。这也使得事情变得有趣和动态，并促使开发者思考在使用给定应用程序时可能出现的更多可能性和问题。一些开发者甚至可能拒绝开始开发一个定义不完整的应用程序。他们可能有一个合理的观点，这取决于任务的紧急程度，但通常，这种态度并不能使项目走得很远。
- en: Luckily, here we can come up with our own tasks, so everything will be well
    defined and we will not change requirements halfway through. So let's do this
    and get our hands dirty.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在这里我们可以提出自己的任务，所以一切都将被明确定义，我们不会在过程中改变要求。所以让我们动手做吧。
- en: Create a scheduler application that can run console commands or SQL queries
    against a database. The user should be able to schedule any command or query using
    configuration files, and they should be able to choose a granularity—hourly or
    daily, at a specific time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个调度应用程序，可以运行针对数据库的控制台命令或SQL查询。用户应该能够使用配置文件调度任何命令或查询，并且他们应该能够选择粒度——每小时或每天，在特定时间。
- en: So far, we have only given a top-level explanation of what we want to achieve.
    As we said earlier, some people might even refuse to go further until they have
    a complete definition with every single detail mentioned. This is a valid point;
    however, it is interesting to get your head around different use cases, edge cases,
    and possible improvements. It is the job of product managers to actually come
    up with all these specifications; but here, we are not learning how to be one.
    We are learning how to write nice code. So let's take what we have and try to
    come up with something usable, efficient, testable, and extendable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只给出了我们想要实现的高级解释。正如我们之前所说的，有些人甚至可能拒绝进一步深入，直到他们有一个包含每个细节的完整定义。这是一个合理的观点；然而，了解不同的用例、边缘情况和可能的改进是很有趣的。产品经理的职责实际上是提出所有这些规范；但在这里，我们不是在学习如何成为一个产品经理。我们是在学习如何编写优秀的代码。所以让我们利用我们所拥有的，尝试提出一些可用、高效、可测试和可扩展的东西。
- en: Implementation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'Let''s start writing some code. No! This is wrong. Before we even start to
    write, we should answer all our questions and be clear with where we are going.
    Some people like drawing diagrams, others like writing things down, and so on.
    Everyone has their own techniques. Let''s try and come up with a diagram first.
    It will show the top-level components that we will use, how they communicate with
    each other, and so on. A visual representation of our application will be extremely
    valuable to see any issues early and will also help us to implement the application
    easily:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写一些代码。不！这是错误的。在我们开始编写之前，我们应该回答所有问题，并清楚我们的目标在哪里。有些人喜欢画图，有些人喜欢写下东西，等等。每个人都有自己的技巧。让我们先尝试画出一个图。它将展示我们将使用的顶级组件，以及它们如何相互通信等等。我们的应用程序的视觉表示将非常有助于早期发现问题，并有助于我们轻松实现应用程序：
- en: '![](img/77f52399-4b26-4b67-a36b-2c8025c9f360.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77f52399-4b26-4b67-a36b-2c8025c9f360.png)'
- en: 'The preceding diagram shows our future application from a really high level.
    It is, however, enough to identify a few core components:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图从非常高的层面展示了我们的未来应用程序。然而，它足以识别几个核心组件：
- en: The main application
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主应用程序
- en: The scheduler
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: The router
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器
- en: The workers
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作者
- en: By looking at the connections between the components, we can also see what dependencies
    they will have and what functionalities they will support.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察组件之间的连接，我们还可以看到它们将有什么依赖关系以及它们将支持哪些功能。
- en: Now that we have this diagram and a view of what we should eventually end up
    with, we can start thinking of how to structure the application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这张图，以及我们最终应该达到的视图，我们可以开始思考如何构建应用程序的结构。
- en: The libraries to use
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要使用的库
- en: You can always take the approach of implementing everything from scratch on
    your own. This, however, would slow you down and would require some deep domain
    knowledge in a lot of other parallel disciplines. We have always encouraged the
    use of libraries in the examples in this book, and this is the case here too.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以采取从头开始自己实现一切的方法。然而，这会减慢你的速度，并且需要大量其他并行学科的深入领域知识。我们一直在本书的示例中鼓励使用库，这里也是如此。
- en: 'Looking at the preceding diagram, we can see that we will need to do the following
    operations:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的图，我们可以看到我们需要执行以下操作：
- en: Read an application configuration
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取应用程序配置
- en: Read scheduler configuration files
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取调度器配置文件
- en: Schedule tasks
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度任务
- en: Exchange messages
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换消息
- en: Access a database
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数据库
- en: Execute console commands
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行控制台命令
- en: Sometimes, while coming up with which libraries to use, it requires testing
    of the different alternatives and seeing which one is useful for our purposes.
    We won't be doing this here, and we will just use the libraries we have already
    seen or know about.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在确定要使用哪些库时，需要测试不同的替代方案，并查看哪一个对我们来说是有用的。我们在这里不会这样做，我们只会使用我们已经看到或了解的库。
- en: Reading the application configuration
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取应用程序配置
- en: 'To read the application configuration files, we have decided to use Typesafe
    config: [https://github.com/typesafehub/config](https://github.com/typesafehub/config).
    It is a mature and well-maintained library, supports various configuration formats,
    and is quite easy to use. We have included it in our `pom.xml` file using the
    following statement:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '为了读取应用程序配置文件，我们决定使用 Typesafe config: [https://github.com/typesafehub/config](https://github.com/typesafehub/config)。这是一个成熟且维护良好的库，支持各种配置格式，并且相当容易使用。我们已经在
    `pom.xml` 文件中使用了以下语句：'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The same dependency is added to `build.sbt` using the following line:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的依赖关系通过以下行添加到 `build.sbt` 中：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reading the scheduler configuration
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取调度器配置
- en: 'Our application will be reading configuration files for schedulers. There are
    different formats we can force our users to use. We''ve decided our format of
    choice to be JSON. It is easy to write our models based on it and we have already
    used libraries to parse the JSON format in the previous chapters of this book.
    We will be using json4s: [https://github.com/json4s/json4s](https://github.com/json4s/json4s).
    We have included it using the following lines in our `pom.xml` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的应用程序将读取调度器的配置文件。我们可以强制用户使用不同的格式。我们决定选择的格式是 JSON。基于它编写我们的模型很容易，我们已经在本书的前几章中使用了解析
    JSON 格式的库。我们将使用 json4s: [https://github.com/json4s/json4s](https://github.com/json4s/json4s)。我们已经在
    `pom.xml` 文件中包含了以下行：'
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The same dependencies if you decide to use `build.sbt` will be added as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用 `build.sbt`，相同的依赖关系将按以下方式添加：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Scheduling tasks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度任务
- en: 'There are various scheduling libraries and programs. Some are more mature,
    others less. In this application, we decided to use Akka: [https://akka.io/](https://akka.io/).
    First of all, it is a good library to be familiar with. Secondly, we have already
    talked about it in the earlier chapters of this book. Using Akka can be useful
    to you to see how to write applications using reactive programming. Akka can be
    included in our project by adding the following lines to our `pom.xml` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种调度库和程序。有些更成熟，有些则不那么成熟。在这个应用程序中，我们决定使用 Akka：[https://akka.io/](https://akka.io/)。首先，它是一个值得熟悉的良好库。其次，我们已经在本书的早期章节中讨论过它。使用
    Akka 可以帮助你了解如何使用响应式编程编写应用程序。我们可以通过将以下行添加到我们的 `pom.xml` 文件中来将 Akka 包含到我们的项目中：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same dependency, but in your `build.sbt` file, will look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的依赖项，但在你的 `build.sbt` 文件中，将看起来像这样：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Akka uses messages to send tasks to workers, and we will see how this entire
    procedure is handled elegantly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 使用消息将任务发送给工作者，我们将看到整个流程是如何优雅地处理的。
- en: Accessing a database
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问数据库
- en: 'In the previous chapter, we already saw how to write the code to access databases.
    Here, we will be using the H2 database engine again, as it doesn''t require you
    to do anything extra in order to execute the example. The related `pom.xml` entry
    is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经看到了如何编写代码来访问数据库。在这里，我们将再次使用 H2 数据库引擎，因为它不需要你执行任何额外的操作来运行示例。相关的 `pom.xml`
    条目如下：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For `sbt`, the `build.sbt` file will need to have the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `sbt`，`build.sbt` 文件需要包含以下内容：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Executing console commands
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行控制台命令
- en: To execute console commands, we will be using the built-in functionalities of
    Scala. We will also use some extra dependencies that we have used in the other
    projects as well—a logging library (slf4j) and test dependencies—ScalaTest and
    Mockito.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行控制台命令，我们将使用 Scala 的内置功能。我们还将使用在其他项目中已经使用过的额外依赖项——一个日志库（slf4j）和测试依赖项——ScalaTest
    和 Mockito。
- en: Writing some code
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一些代码
- en: Now that we know what we will be doing and what libraries we will be relying
    on, it's time to write some code. It is logical to start with things that don't
    have other internal dependencies.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了我们将要做什么以及我们将依赖哪些库，是时候编写一些代码了。从没有其他内部依赖项的事情开始是合理的。
- en: 'One of these things is the application configuration. It is something that
    doesn''t depend on anything, but many things depend on it. We decided to use the
    `.conf` files because they are simple, hierarchical, and similar to JSON. An example
    configuration file looks like the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是应用程序配置。这是不依赖于任何东西的东西，但许多东西都依赖于它。我们决定使用 `.conf` 文件，因为它们简单、分层，类似于 JSON。一个示例配置文件如下所示：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The options are clear and anyone can easily provide a new config that suits
    their needs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 选项清晰，任何人都可以轻松提供适合他们需求的新的配置。
- en: Coming up with our configuration options
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提出我们的配置选项
- en: Of course, we didn't come up with this file straight away. It evolved as we
    kept adding functionalities to our application. Start small and don't try to think
    about everything at once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并没有一开始就想到这个文件。它是随着我们不断向应用程序添加功能而演变的。从小处着手，不要试图一次性考虑所有事情。
- en: 'With this expected format, we can now write a component:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种预期的格式，我们现在可以编写一个组件：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The highlighted line in the preceding code shows how easy it is to read our
    configuration file. It gets the `application.conf` from our `resources` folder.
    The user can easily override it by passing a `-Dconfig.resource=path.conf` when
    starting our application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中高亮显示的行显示了读取我们的配置文件是多么简单。它从我们的 `resources` 文件夹中获取 `application.conf`。用户可以通过在启动我们的应用程序时传递
    `-Dconfig.resource=path.conf` 来轻松地覆盖它。
- en: 'Our configuration file specifies a number of properties. Two of them are `config-path`
    and `config-extension`. We have basically taken the decision to provide a folder
    and an extension, and our program will read all the files with the given extension
    and use them as job configuration files. We have written a component that supports
    reading from a folder and returns all the files with the given extension:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置文件指定了多个属性。其中两个是 `config-path` 和 `config-extension`。我们基本上已经决定提供一个文件夹和一个扩展名，我们的程序将读取所有给定扩展名的文件，并将它们用作作业配置文件。我们已经编写了一个支持从文件夹中读取并返回所有给定扩展名文件的组件：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This component doesn't do anything special. We haven't used monads or anything
    fancy for the I/O here because we actually want to eagerly evaluate things in
    this case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件没有做任何特别的事情。我们没有在这里使用 monads 或其他花哨的 I/O，因为我们实际上希望在这种情况下积极评估事物。
- en: 'Now that we know how to find all the job configuration files, we need to read
    them and parse them. We said that they will be JSON files and this means that
    we will have to define a model. Let''s first see an example of a job configuration
    and then define the model:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何找到所有的作业配置文件，我们需要读取它们并解析它们。我们说过它们将是JSON文件，这意味着我们必须定义一个模型。让我们先看看一个作业配置的例子，然后定义模型：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is quite easy to start with a file that has everything we need and then
    define the models, rather than the other way around. According to the preceding
    code, we can define the following model for our job configuration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个包含我们所需一切内容的文件开始，然后定义模型，而不是反过来，这相当容易。根据前面的代码，我们可以为我们的作业配置定义以下模型：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `JobType` and `JobFrequency` will be defined as ADTs. When we use json4s,
    some special care needs to be taken while serializing and deserializing these
    types, so we have defined some extra `CustomSerializer` implementations along
    with them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobType`和`JobFrequency`将被定义为ADT。当我们使用json4s时，在序列化和反序列化这些类型时需要特别注意，所以我们定义了一些额外的`CustomSerializer`实现：'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `JobFrequency` is quite similar to the preceding code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobFrequency`与前面的代码相当相似：'
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our `JobConfig` class needs one more model to be defined, and it is shown as
    follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`JobConfig`类还需要定义一个模型，如下所示：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `TimeOptions` class has some validation during creation and a `getInitialDelay`
    method. The purpose of this method is to get the initial delay while scheduling
    a task, depending on its options.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeOptions`类在创建时有一些验证，以及一个`getInitialDelay`方法。这个方法的目的是在安排任务时获取初始延迟，这取决于它的选项。'
- en: 'After we have defined our models for the job configuration, we can write a
    service that reads and parses the configurations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为作业配置定义了模型之后，我们可以编写一个服务来读取和解析配置：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It depends on the two components we already showed in the preceding code. There
    is nothing special about this component, except the highlighted part. The first
    statement takes the custom serializers we have for the frequency and job type.
    The second statement adds them to the default formats so that json4s knows how
    to handle them. If you observe carefully, you will notice the `JobConfig.jobConfigFieldSerializer`
    call as well. Let''s see what it looks like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于我们在前面的代码中已经展示的两个组件。这个组件没有什么特别之处，除了高亮显示的部分。第一条语句取了我们为频率和职位类型定义的自定义序列化器。第二条语句将它们添加到默认格式中，这样json4s就知道如何处理它们。如果你仔细观察，你会注意到`JobConfig.jobConfigFieldSerializer`的调用。让我们看看它是什么样子：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We need it because the Scala field names that we have used are different from
    what is in our JSON files, and json4s needs to know how to translate them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要它，因为我们使用的Scala字段名与我们的JSON文件中的不同，json4s需要知道如何翻译它们。
- en: 'Now that we have all the required mechanisms to read the job configurations,
    we can go deeper and see how they will be used to execute our jobs. We already
    said that we will be implementing our scheduler and workers using Akka. One thing
    about Akka is that it communicates using messages. We had to come up with some
    messages that our application will need:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了读取作业配置所需的所有机制，我们可以更深入地了解它们将如何用于执行我们的作业。我们之前说过，我们将使用Akka来实现我们的调度器和工作者。关于Akka有一件事是它通过消息进行通信。我们必须想出一些我们的应用程序将需要的消息：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These messages are quite descriptive, so let''s not waste time on them. Let''s
    go straight to the point and see what our scheduler will look like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息相当详细，所以我们不要在这些上面浪费时间。让我们直接进入正题，看看我们的调度器会是什么样子：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have called our scheduler `Master`, as it is the master actor in the actor
    system we will implement. We have skipped the imports in favor of saving some
    space. There are two places that deserve more attention in this actor—the `receive`
    method and the `router`. The former is essentially how actors work—the developer
    implements this method, which is simply a partially defined function, and if a
    message that we know about is received, it is handled. Our master actor can schedule
    a list of jobs by creating work items and sending them to the router. The router,
    on the other hand, is just a round-robin pool of workers, so every task we schedule
    will go to a different worker.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的调度器命名为`Master`，因为它是我们将要实现的演员系统中的主演员。我们跳过了导入以节省一些空间。在这个演员中有两个地方值得更多关注——`receive`方法和`router`。前者基本上是演员的工作方式——开发者实现这个方法，它只是一个部分定义的函数，如果我们收到了我们知道的任何消息，它就会被处理。我们的主演员可以通过创建工作项并将它们发送到路由器来安排一系列作业。另一方面，路由器只是一个轮询的工人池，所以我们将安排的每个任务都会分配给不同的工人。
- en: 'All workers will be running the same code, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: They can only accept one message type (`Work`) and process it accordingly. For
    example, to run console tasks, we have used the built-in Scala functionality.
    Then the highlighted line makes sure a message is sent back to the sender (`Master`
    in our case) and, as you can see, it will handle it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen a bunch of components that look a lot like how you would
    implement dependency injection using Scala—the cake design pattern. However, the
    general pattern that is followed with our actors isn''t the way the cake design
    pattern is set up. That''s why we''ve created a factory—`ActorFactory`,which can
    inject objects into our actors:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see how the preceding factory is passed (using the `this` reference)
    and used in the `Master` actor for creating `Worker` instances.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen everything we need in order to run console jobs with our
    scheduler. Now we have to implement things in order to support database access.
    We will skip the database code here, as it is pretty much the same as the one
    we saw in [Chapter 11](e1484517-e8e3-4083-8617-04a17922b9f4.xhtml), *Applying
    What We Have Learned*, it is based on the cake design pattern. We have only skipped
    some convenience methods that we don''t need here. However, the database our scheduler
    can query still has the same schema:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have also added some extra database statements to aid us in unit testing
    but they are minor, and not putting them here will not affect anything.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Wiring it all up
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It seems like we already have all the components our application will be using.
    Now we just need to wire things together and fire it up. We are using the cake
    design pattern for dependency injection; so, as you have already seen, we can
    create one component registry with everything we need:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we have a component registry, we can use it and write the main application
    class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Our application has some very simple Akka wiring up and then everything is triggered
    when we execute the highlighted line. We send a `Schedule` message to the master
    with all the job configurations and then it will schedule them to run periodically
    according to their definitions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The end result
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After all this code is written, we will end up with the following tree in our
    IDE:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd2cb2a1-6bcf-4b8c-8dae-24c0a5f5f9cd.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: You can see that our code also contains unit tests. We will spend some time
    on them in the next subsection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a really important part of every application. Using TDD is really
    good, as we can write and test our applications simultaneously instead of coming
    back to something that is already done. We used this approach while writing the
    application, but separated the code and the tests in favor of explaining things
    better and not mixing them up.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have already seen earlier, testing applications that rely on the cake
    design pattern is simple. We have defined the following test environment:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When we do testing, we use an actual application configuration file instead
    of working with mocks and can use any file inside our test resources folder. We
    have written quite extensive tests for the `TimeOptions` class, more specifically
    the part that calculates the initial delay. There are tests to read job configuration
    files as well as database access tests. They can all be seen in the projects provided
    with this book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行测试时，我们使用实际的应用程序配置文件，而不是使用模拟，并且可以使用测试资源文件夹中的任何文件。我们已经为`TimeOptions`类编写了相当广泛的测试，特别是计算初始延迟的部分。还有读取作业配置文件的测试以及数据库访问测试。所有这些都可以在本书提供的项目中看到。
- en: Application testing
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序测试
- en: 'No doubt, the part that everyone wanted to see the most is where we actually
    give our application an actual spin. However, because it is a scheduler, we first
    need to prepare some configurations. We will use the following application configuration
    file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，大家最想看到的部分是我们真正启动应用程序的地方。然而，因为它是一个调度器，我们首先需要准备一些配置。我们将使用以下应用程序配置文件：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will name our file `production.conf` and we will put it in `/etc/scheduler/conf.d`.
    Now we need to create some actual job configurations. We will have to put them
    where the `config-path` property is pointing to:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名我们的文件为`production.conf`，并将其放置在`/etc/scheduler/conf.d`目录下。现在我们需要创建一些实际的作业配置。我们必须将它们放在`config-path`属性指向的位置：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The last job should have no issues running on any operating system. You may
    need to change the commands in the first two jobs if you are using Windows, for
    example. Also, time options might need to be changed, depending on when the application
    is being run and if you don't want to wait for hours before you see proof that
    it actually works.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个作业应该没有问题在任何操作系统上运行。例如，如果你使用Windows，可能需要更改前两个作业中的命令。此外，时间选项可能需要根据应用程序运行的时间和是否希望立即看到实际工作的证据而进行更改。
- en: 'If we run our application now with these configurations, we will get the following
    output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在用这些配置运行应用程序，我们将得到以下输出：
- en: '![](img/a8b4e47a-f607-405e-9723-4ac53004c274.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8b4e47a-f607-405e-9723-4ac53004c274.png)'
- en: We can leave the application and it will keep executing the tasks we had every
    one hour or day, depending on how the tasks are scheduled. Of course, we could
    add more meaningful jobs, allocate more workers, change other configurations,
    and so on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以离开应用程序，它将根据任务的调度方式，每小时或每天持续执行我们设定的任务。当然，我们还可以添加更多有意义的作业，分配更多工作者，更改其他配置等等。
- en: The future of our application
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们应用程序的未来
- en: We have used a number of techniques and concepts that we have learned throughout
    this book—dependency injection, factory design pattern, ADTs, and the Akka library,
    which can be used to implement the observer design pattern. This was a complete
    application that was designed to be testable and extendible.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中学到了许多技术和概念——依赖注入、工厂设计模式、ADTs以及Akka库，这些都可以用来实现观察者设计模式。这是一个完全设计的应用程序，旨在可测试和可扩展。
- en: We can easily add more granularity to the execution schedule of the jobs, the
    different types of tasks, and also have tasks trigger each other, different routing
    mechanisms, and so on. We showed that we have learned about a great number of
    useful concepts in this book, and now we can put everything to use in order to
    create great programs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地为作业的执行计划添加更多粒度，包括不同类型的任务，还可以让任务相互触发，不同的路由机制等等。我们展示了在这本书中我们学到了许多有用的概念，现在我们可以将这些知识应用到实践中，以创建出优秀的程序。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Here, we are at the end of our journey through the Scala design patterns. As
    you already know, design patterns exist in order to cope with a certain limitation
    of a language. They also help us to structure our code in a way that makes it
    easy to change, use, test, and maintain. Scala is an extremely rich language,
    and we focused on some of its features that make it capable of achieving things
    that other languages might not be able to do without any extra effort and knowledge.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经完成了Scala设计模式的旅程。正如你所知，设计模式的存在是为了应对语言的某些限制。它们还帮助我们以易于更改、使用、测试和维护的方式组织代码。Scala是一种极其丰富的语言，我们关注了一些使其能够实现其他语言可能需要额外努力和知识才能完成的事情的功能。
- en: We looked at the different *Gang of Four* design patterns from the point of
    view of Scala—creational, structural, and behavioral design patterns. We saw that
    some of them are not even applicable in functional languages and that others can
    be approached differently. We also saw that some design patterns still remain
    valid and knowing them is really important for any developer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Scala的角度审视了不同的“四人帮”（Gang of Four）设计模式——创建型、结构型和行为型设计模式。我们看到了其中一些在函数式语言中甚至不适用，而另一些则可以有不同的处理方式。我们还看到，一些设计模式仍然有效，并且了解它们对于任何开发者来说都至关重要。
- en: We can't talk about Scala without dealing with concepts such as monoids and
    monads. At first, they could be pretty scary and abstract and manage to put people
    off. So, we spent some time with them and showed their value. They can be used
    to write powerful applications in a purely functional way. They can be used to
    abstract and reuse functionality. By minimizing the dry theory and focusing on
    understandable examples, we hopefully made them much more approachable and usable
    for those of you who don't have a deep mathematical background.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论Scala时，不可避免地要处理诸如单子（monoids）和单态（monads）这样的概念。起初，它们可能显得相当可怕和抽象，以至于让人望而却步。因此，我们花了一些时间来了解它们，并展示了它们的价值。它们可以用来以纯函数式方式编写强大的应用程序。它们可以用来抽象和重用功能。通过最小化枯燥的理论，并专注于可理解的例子，我们希望使它们对那些没有深厚数学背景的你们来说更加易于接近和使用。
- en: Using the rich features of Scala opens up another large group of design patterns.
    We spent some time on design patterns that are possible just because of the way
    Scala works and the different features it provides.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Scala的丰富特性，打开了另一组大量设计模式的大门。我们花了一些时间研究那些仅仅因为Scala的工作方式和它提供的不同特性才可能实现的设计模式。
- en: Throughout the book, we have tried to provide meaningful examples that can be
    used as a reference to find specific patterns and applications of the techniques
    we learned here. In this last chapter, we even implemented a complete application.
    On many occasions, we have tried to showcase how different design patterns can
    be combined. Of course, in some cases, the concepts could be pretty complicated
    by themselves, so we simplified the examples.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们试图提供有意义的例子，这些例子可以作为参考，以找到我们在这里学到的技术的特定模式和应用程序。在本章的最后，我们甚至实现了一个完整的应用程序。在许多场合，我们试图展示不同的设计模式如何结合使用。当然，在某些情况下，概念本身可能相当复杂，因此我们简化了例子。
- en: We've given some advice about when to use certain design patterns and when to
    avoid them. These points should be extremely helpful to you in terms of what details
    to focus on.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一些关于何时使用某些设计模式以及何时避免它们的建议。这些观点在关注哪些细节方面应该对你非常有帮助。
- en: The use of libraries has been encouraged throughout the book. Especially in
    the last few chapters, you have been exposed to quite a large number of interesting
    libraries that can be easily added to your arsenal. We have hopefully also sparked
    an interest and a habit to always do checks before trying something *new*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们鼓励使用库。特别是在最后几章，你们已经接触到了相当多的有趣库，这些库可以轻松地添加到你们的工具箱中。我们也希望激发了对在尝试新事物之前总是进行检查的兴趣和习惯。
- en: Finally, all the examples found in this book can also be found online at [https://github.com/nikolovivan/scala-design-patterns](https://github.com/nikolovivan/scala-design-patterns-v2).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本书中找到的所有示例也可以在[https://github.com/nikolovivan/scala-design-patterns](https://github.com/nikolovivan/scala-design-patterns-v2)上找到。
