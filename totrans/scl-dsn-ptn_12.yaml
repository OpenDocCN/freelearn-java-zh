- en: Real-Life Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come a long way in the world of design patterns in Scala. We saw some
    classical *Gang of Four* design patterns from the point of view of Scala, as well
    as features that are applicable specifically to this programming language. By
    now, you should have enough knowledge in order to build high-quality, extendible,
    efficient, and elegant applications. Everything we have covered until now, if
    taken into consideration, should have a really positive impact on any application
    you will create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the things you saw in this book we wrote from scratch. This is really
    helpful in terms of understanding a given concept, but it takes time, and in real-world
    applications, using a library that gives us some functionalities is usually preferred.
    There are a number of different libraries available that are accessible through
    a simple Google search and address just about anything you can think of. Apart
    from the fact that this could save a lot of time, it also means that we integrate
    into our code thoroughly tested components that are trusted by many others. This,
    of course, depends on the library we are trying to incorporate, but as long as
    it brings something useful to the community, it will most likely be reliable.
    Having said all that, our main focus of this chapter will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Scalaz library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a complete application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing what we have learned so far
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of libraries for Scala out there and some might consider other
    libraries to be much more important to the language than Scalaz is. There are
    alternatives as well, which have spun up due to various reasons. We will, however,
    focus on Scalaz here, as it is generally used when someone wants to implement
    concepts such as monoids, functors, and monads in their application. And these
    concepts are really important in functional programming, as we saw earlier. We
    will also write a complete application that uses some of the techniques and design
    patterns we became familiar with in the previous chapters. This chapter will give
    some insights into how applications should be structured and how to understand
    our requirements and then build the solutions for them properly. Finally, we will
    summarize everything we have learned here.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons to use libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing software applications will inevitably bring developers to the point
    where they will have to implement something that already exists. Reinventing the
    wheel is generally a bad idea unless we have some extremely specific and strict
    requirements that no library in the world satisfies, or if there is good reason
    not to include a specific dependency in our project.
  prefs: []
  type: TYPE_NORMAL
- en: People write libraries to deal with all kinds of problems in software. In a
    community such as the open source community, libraries are shared and everyone
    can use or contribute to them. This brings a lot of benefits, and the main benefit
    is that code becomes more mature, better tested, and more reliable. However, sometimes
    this also makes things harder—many people will create the same library and it
    becomes difficult to understand which one is the most suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that there could be multiple implementations of the same library,
    using one is the way to go when we write enterprise applications. Filtering out
    the bad ones from the good ones is easy nowadays—if a library is good, many people
    will use it. If it's bad, people will avoid it. If there are multiple good ones,
    developers will have to spend some time investigating which one is the most suitable
    for their use case.
  prefs: []
  type: TYPE_NORMAL
- en: The Scalaz library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala is a functional programming language and, as such, it supports design
    patterns based on concepts such as monoids, monads, and others. We already saw
    these in [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml), *Functional
    Design Patterns - the Deep Theory*, and we know the rules they follow and the
    structure they have. We wrote everything ourselves, but a library already exists
    that does this for us—Scalaz ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz)).
    This library is used when we need purely functional data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Another library that has a similar popularity to Scalaz in the community is
    Cats ([https://github.com/typelevel/cats](https://github.com/typelevel/cats)).
    They should both be able to help developers achieve the same functional programming
    concepts. In most cases, the choice between the two is based on personal preference,
    local community culture or company policies.
  prefs: []
  type: TYPE_NORMAL
- en: We have already encountered Scalaz in the previous chapter when we talked about
    lenses. In the following subsections, we will look at the library from the point
    of view of monoids, functors, and monads.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids in Scalaz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the concepts we looked at in [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml),
    *Functional Design Patterns - the Deep Theory*, was monoids. We defined a trait
    and some rules for them and then showed examples of how to use them and what they
    are good for. In these examples, we defined monoids for integer addition and multiplication
    as well as string concatenation. Scalaz already has a `Monoid` trait that we can
    use to write our own monoids. Also, this trait has a few monoids that we have
    defined before already implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we just showed how you can implement a custom monoid.
  prefs: []
  type: TYPE_NORMAL
- en: The `stringConcatenation` monoid is defined in a package object. This means
    that it will be available to any code in the same package without the need to
    import anything. We take advantage of this in some of the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: There also exists a string concatenation monoid, but here we just showed how
    you can opt for implementing the custom monoid if it doesn't exist. It is quite
    similar to what we had earlier. The difference is only in the name for the operation
    method (`append`) and its signature. However, this is just a minor difference.
  prefs: []
  type: TYPE_NORMAL
- en: Using monoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using Scalaz monoids is pretty straightforward. Here is an example program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The imports in our code make sure that we can call `foldMap` on our list of
    numbers. If we run this example, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6df0dd37-2053-4937-aaca-79153cf7100f.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the output and the code, you can see that for integer addition and
    multiplication, we have used the built-in monoids of Scalaz. The `sum` monoid
    takes precedence and is actually passed to `foldMap` implicitly. For the multiplication
    to work, we have to pass `Tags.Multiplication.apply` in order to make things work
    as expected. We have explicitly passed our string concatenation monoid to make
    the last statement work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing monoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that monoids have to satisfy some specific laws. Our examples are simple
    enough to see that the laws are actually in place, but sometimes it might not
    be that obvious. In Scalaz, you can actually test your monoids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to compile and run the preceding example, we will need
    to have the following dependencies added to our `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent `build.sbt` file will need to have the following dependencies
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sections are just fragments of the code examples coming with
    this book. These dependencies add bindings to ScalaCheck ([https://www.scalacheck.org/](https://www.scalacheck.org/))—a
    property-based testing framework. The preceding code will test our custom monoid
    for all the laws and fail if it doesn't satisfy them. Writing tests for our custom
    classes will require us to have an `Arbitrary` implementation as well as have
    our monoid implicitly available in the test scope.
  prefs: []
  type: TYPE_NORMAL
- en: Monads in Scalaz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml), *Functional Design
    Patterns - the Deep Theory*, we also looked at monads. If you remember, we had
    to define a functor trait first and then extend it in the monad trait. Similar
    to monoids, monads also follow some specific rules that have to be in place.
  prefs: []
  type: TYPE_NORMAL
- en: Using monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalaz defines quite a lot of different methods that can be applied directly
    to any monad we have. There are multiple examples that show lists and options.
    The library also has a `Monad` trait that can be extended. It is similar to the
    `Monoid` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t want to dig into list examples that show how to use monads, though.
    To make things interesting, let''s look at the `IO` monad in Scalaz that can be
    used to perform I/O in a monadic way. What this basically means is that we can
    describe and compose those actions without actually performing them. This will
    lead to better code reuse as well. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we defined some methods in a package object that can manipulate
    files. There is absolutely nothing special about them. They seem pretty similar
    to what we did in [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml), *Functional
    Design Patterns - the Deep Theory*, when we showed our custom `IO` monad. In the
    `readFile` and the `writeFile`, we added prints to help in debugging and show
    exactly what is going on. This will be really useful later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make our application read a tab-separated file of data of people, parse
    it, and write it either to a file or the console. The example file will have the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we have a model that will reflect this file and it will be as simple
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Together with the model, we've shown its companion object. It has one method
    that returns an optional `Person` object given an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to see our application and explain what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's now see what exactly is going on in the previous listing. The actual code
    is in the first pattern matching case. The rest is some validation to run a console
    application and the parameters passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to pay attention to is the calls to `.pure[IO]`, which is there
    for the `people` variable and when we write to the file. This method takes the
    value given to it and lifts it into a monad. Another important thing is that the
    value passed to the method is lazily evaluated. In our example, the monad is the
    `IO` monad.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we can see some references to the `putStrLn` and `readLn` methods.
    Their names should be enough to explain what they do. They come from the `scalaz.effect.IO`
    object, that we have imported into our application. And this import requires another
    dependency in our `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent dependency in the `build.sbt` file will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `putStrLn` and `readLn` methods also return an instance of the `IO` monad
    and they are just helpers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, because our application is monadic and we use the `IO` monad, nothing will
    happen unless we do something about it. To trigger the actual actions, we must
    call `unsafePerformIO` on an `IO` instance. We've added some `print` statements
    that will prove that the code works as we expected it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have two branches for our application, we will make two runs here.
    One that prints and another one that writes to a file. The example outputs are
    in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01468d76-d143-47db-a3c8-efa72c9a068d.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the run that prints to the console. We can see
    that the reading from the file log comes after the initial logs from our application,
    even though we called the method earlier. This proves that indeed the `.pure[IO]`
    call lifts our function without evaluating it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to the previous output, the following output shows that nothing happens
    until the very last moment when we write the output filename and hit *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24765bef-4f21-4e81-9cc8-1c0e845c7ddc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our example shows that the `IO` monad helps us to build a computation and execute
    it at the very last moment. Here, we''ve decided to surround it with a for comprehension
    and call `pure[IO]` on it so that we can actually use the read and write methods
    without monads if we want to. In other cases, you can make sure to return an `IO`
    monad from the read and write methods and then define mapping methods, which also
    return the `IO` monads and use them inside the for comprehensions. This would
    look like something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This version actually looks more monadical. We have enclosed smaller entities
    in the `IO` monad that we have combined and probably there will be more examples
    available online that follow this approach. This version actually also leaves
    the `read` method intact. The only thing in this case is that the for comprehension
    behaves differently than usual.
  prefs: []
  type: TYPE_NORMAL
- en: Which approach is used will probably depend on personal preferences and what
    someone wants to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is similar to what we did in [Chapter 10](1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml),
    *Functional Design Patterns - the Deep Theory*, with our custom I/O monad. Here,
    however, we can see that there is much less extra code than before.
  prefs: []
  type: TYPE_NORMAL
- en: Testing monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalaz provides facilities to test monads as well. The tests look no different
    than what we saw for monoids, but here we simply have to use `monad.laws` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The possibilities of Scalaz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We only looked at a handful of concepts covered by the Scalaz library. It contains
    much more than just that. You can think of Scalaz as an addition to Scala that
    makes it even more functional. It provides various type classes, data types, pimp
    my library instances for standard collections, out-of-the-box functionality for
    various standard types, and so on. The purposes also vary—from writing purely
    functional applications to making your code more readable. Scalaz is so vast that
    we can write a separate book about it.
  prefs: []
  type: TYPE_NORMAL
- en: It seems that people find it difficult to use Scalaz at first and only later
    do they get to know the possibilities it provides. We would like to encourage
    you to become familiar with the documentation and everything the library provides.
    There are also various blog posts for all levels of difficulty, which can be a
    real eye-opener for the first time user of Scalaz.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a complete application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, we've seen a lot of examples. Some of them were quite complete,
    while others were meant to demonstrate only a specific part of what we were looking
    at. In real applications, it is most likely that you will have to combine multiple
    design patterns that we went through. In order to do so properly, it is important
    that the requirements are well understood. In the following subsections, we will
    provide the application specifications and then we will go step by step through
    actually writing the application. The amount of code we write will be a lot, so
    we will focus on the more important parts of our application and we might skip
    others.
  prefs: []
  type: TYPE_NORMAL
- en: Application specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before doing anything, we must always have some specifications. Sometimes, these
    specifications are not entirely clear and it is our responsibility to make sure
    everything is detailed enough for us to understand and achieve them. However,
    in an actual software engineering process, it will likely be the case that we
    start doing something when the requirements are not 100% clear and things change
    halfway through the project. It could be frustrating at times, but that is life
    and we have to deal with it. It also makes things interesting and dynamic and
    makes developers think of even more possibilities and problems that could arise
    when users use a given application. Some developers might refuse to even start
    working on an application that is not completely defined. They might have a valid
    point and this depends on how critical the tasks are, but generally, this kind
    of attitude doesn't take projects far.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, here we can come up with our own tasks, so everything will be well
    defined and we will not change requirements halfway through. So let's do this
    and get our hands dirty.
  prefs: []
  type: TYPE_NORMAL
- en: Create a scheduler application that can run console commands or SQL queries
    against a database. The user should be able to schedule any command or query using
    configuration files, and they should be able to choose a granularity—hourly or
    daily, at a specific time.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only given a top-level explanation of what we want to achieve.
    As we said earlier, some people might even refuse to go further until they have
    a complete definition with every single detail mentioned. This is a valid point;
    however, it is interesting to get your head around different use cases, edge cases,
    and possible improvements. It is the job of product managers to actually come
    up with all these specifications; but here, we are not learning how to be one.
    We are learning how to write nice code. So let's take what we have and try to
    come up with something usable, efficient, testable, and extendable.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start writing some code. No! This is wrong. Before we even start to
    write, we should answer all our questions and be clear with where we are going.
    Some people like drawing diagrams, others like writing things down, and so on.
    Everyone has their own techniques. Let''s try and come up with a diagram first.
    It will show the top-level components that we will use, how they communicate with
    each other, and so on. A visual representation of our application will be extremely
    valuable to see any issues early and will also help us to implement the application
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77f52399-4b26-4b67-a36b-2c8025c9f360.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows our future application from a really high level.
    It is, however, enough to identify a few core components:'
  prefs: []
  type: TYPE_NORMAL
- en: The main application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By looking at the connections between the components, we can also see what dependencies
    they will have and what functionalities they will support.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this diagram and a view of what we should eventually end up
    with, we can start thinking of how to structure the application.
  prefs: []
  type: TYPE_NORMAL
- en: The libraries to use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can always take the approach of implementing everything from scratch on
    your own. This, however, would slow you down and would require some deep domain
    knowledge in a lot of other parallel disciplines. We have always encouraged the
    use of libraries in the examples in this book, and this is the case here too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the preceding diagram, we can see that we will need to do the following
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Read an application configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read scheduler configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchange messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute console commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, while coming up with which libraries to use, it requires testing
    of the different alternatives and seeing which one is useful for our purposes.
    We won't be doing this here, and we will just use the libraries we have already
    seen or know about.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the application configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To read the application configuration files, we have decided to use Typesafe
    config: [https://github.com/typesafehub/config](https://github.com/typesafehub/config).
    It is a mature and well-maintained library, supports various configuration formats,
    and is quite easy to use. We have included it in our `pom.xml` file using the
    following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The same dependency is added to `build.sbt` using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Reading the scheduler configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application will be reading configuration files for schedulers. There are
    different formats we can force our users to use. We''ve decided our format of
    choice to be JSON. It is easy to write our models based on it and we have already
    used libraries to parse the JSON format in the previous chapters of this book.
    We will be using json4s: [https://github.com/json4s/json4s](https://github.com/json4s/json4s).
    We have included it using the following lines in our `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The same dependencies if you decide to use `build.sbt` will be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are various scheduling libraries and programs. Some are more mature,
    others less. In this application, we decided to use Akka: [https://akka.io/](https://akka.io/).
    First of all, it is a good library to be familiar with. Secondly, we have already
    talked about it in the earlier chapters of this book. Using Akka can be useful
    to you to see how to write applications using reactive programming. Akka can be
    included in our project by adding the following lines to our `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The same dependency, but in your `build.sbt` file, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Akka uses messages to send tasks to workers, and we will see how this entire
    procedure is handled elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we already saw how to write the code to access databases.
    Here, we will be using the H2 database engine again, as it doesn''t require you
    to do anything extra in order to execute the example. The related `pom.xml` entry
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For `sbt`, the `build.sbt` file will need to have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Executing console commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To execute console commands, we will be using the built-in functionalities of
    Scala. We will also use some extra dependencies that we have used in the other
    projects as well—a logging library (slf4j) and test dependencies—ScalaTest and
    Mockito.
  prefs: []
  type: TYPE_NORMAL
- en: Writing some code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what we will be doing and what libraries we will be relying
    on, it's time to write some code. It is logical to start with things that don't
    have other internal dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these things is the application configuration. It is something that
    doesn''t depend on anything, but many things depend on it. We decided to use the
    `.conf` files because they are simple, hierarchical, and similar to JSON. An example
    configuration file looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The options are clear and anyone can easily provide a new config that suits
    their needs.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up with our configuration options
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we didn't come up with this file straight away. It evolved as we
    kept adding functionalities to our application. Start small and don't try to think
    about everything at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this expected format, we can now write a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line in the preceding code shows how easy it is to read our
    configuration file. It gets the `application.conf` from our `resources` folder.
    The user can easily override it by passing a `-Dconfig.resource=path.conf` when
    starting our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our configuration file specifies a number of properties. Two of them are `config-path`
    and `config-extension`. We have basically taken the decision to provide a folder
    and an extension, and our program will read all the files with the given extension
    and use them as job configuration files. We have written a component that supports
    reading from a folder and returns all the files with the given extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This component doesn't do anything special. We haven't used monads or anything
    fancy for the I/O here because we actually want to eagerly evaluate things in
    this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to find all the job configuration files, we need to read
    them and parse them. We said that they will be JSON files and this means that
    we will have to define a model. Let''s first see an example of a job configuration
    and then define the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is quite easy to start with a file that has everything we need and then
    define the models, rather than the other way around. According to the preceding
    code, we can define the following model for our job configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JobType` and `JobFrequency` will be defined as ADTs. When we use json4s,
    some special care needs to be taken while serializing and deserializing these
    types, so we have defined some extra `CustomSerializer` implementations along
    with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JobFrequency` is quite similar to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `JobConfig` class needs one more model to be defined, and it is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `TimeOptions` class has some validation during creation and a `getInitialDelay`
    method. The purpose of this method is to get the initial delay while scheduling
    a task, depending on its options.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have defined our models for the job configuration, we can write a
    service that reads and parses the configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It depends on the two components we already showed in the preceding code. There
    is nothing special about this component, except the highlighted part. The first
    statement takes the custom serializers we have for the frequency and job type.
    The second statement adds them to the default formats so that json4s knows how
    to handle them. If you observe carefully, you will notice the `JobConfig.jobConfigFieldSerializer`
    call as well. Let''s see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We need it because the Scala field names that we have used are different from
    what is in our JSON files, and json4s needs to know how to translate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all the required mechanisms to read the job configurations,
    we can go deeper and see how they will be used to execute our jobs. We already
    said that we will be implementing our scheduler and workers using Akka. One thing
    about Akka is that it communicates using messages. We had to come up with some
    messages that our application will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'These messages are quite descriptive, so let''s not waste time on them. Let''s
    go straight to the point and see what our scheduler will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have called our scheduler `Master`, as it is the master actor in the actor
    system we will implement. We have skipped the imports in favor of saving some
    space. There are two places that deserve more attention in this actor—the `receive`
    method and the `router`. The former is essentially how actors work—the developer
    implements this method, which is simply a partially defined function, and if a
    message that we know about is received, it is handled. Our master actor can schedule
    a list of jobs by creating work items and sending them to the router. The router,
    on the other hand, is just a round-robin pool of workers, so every task we schedule
    will go to a different worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'All workers will be running the same code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: They can only accept one message type (`Work`) and process it accordingly. For
    example, to run console tasks, we have used the built-in Scala functionality.
    Then the highlighted line makes sure a message is sent back to the sender (`Master`
    in our case) and, as you can see, it will handle it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen a bunch of components that look a lot like how you would
    implement dependency injection using Scala—the cake design pattern. However, the
    general pattern that is followed with our actors isn''t the way the cake design
    pattern is set up. That''s why we''ve created a factory—`ActorFactory`,which can
    inject objects into our actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see how the preceding factory is passed (using the `this` reference)
    and used in the `Master` actor for creating `Worker` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen everything we need in order to run console jobs with our
    scheduler. Now we have to implement things in order to support database access.
    We will skip the database code here, as it is pretty much the same as the one
    we saw in [Chapter 11](e1484517-e8e3-4083-8617-04a17922b9f4.xhtml), *Applying
    What We Have Learned*, it is based on the cake design pattern. We have only skipped
    some convenience methods that we don''t need here. However, the database our scheduler
    can query still has the same schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have also added some extra database statements to aid us in unit testing
    but they are minor, and not putting them here will not affect anything.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring it all up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It seems like we already have all the components our application will be using.
    Now we just need to wire things together and fire it up. We are using the cake
    design pattern for dependency injection; so, as you have already seen, we can
    create one component registry with everything we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a component registry, we can use it and write the main application
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Our application has some very simple Akka wiring up and then everything is triggered
    when we execute the highlighted line. We send a `Schedule` message to the master
    with all the job configurations and then it will schedule them to run periodically
    according to their definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The end result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After all this code is written, we will end up with the following tree in our
    IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd2cb2a1-6bcf-4b8c-8dae-24c0a5f5f9cd.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that our code also contains unit tests. We will spend some time
    on them in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a really important part of every application. Using TDD is really
    good, as we can write and test our applications simultaneously instead of coming
    back to something that is already done. We used this approach while writing the
    application, but separated the code and the tests in favor of explaining things
    better and not mixing them up.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have already seen earlier, testing applications that rely on the cake
    design pattern is simple. We have defined the following test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When we do testing, we use an actual application configuration file instead
    of working with mocks and can use any file inside our test resources folder. We
    have written quite extensive tests for the `TimeOptions` class, more specifically
    the part that calculates the initial delay. There are tests to read job configuration
    files as well as database access tests. They can all be seen in the projects provided
    with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Application testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No doubt, the part that everyone wanted to see the most is where we actually
    give our application an actual spin. However, because it is a scheduler, we first
    need to prepare some configurations. We will use the following application configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will name our file `production.conf` and we will put it in `/etc/scheduler/conf.d`.
    Now we need to create some actual job configurations. We will have to put them
    where the `config-path` property is pointing to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The last job should have no issues running on any operating system. You may
    need to change the commands in the first two jobs if you are using Windows, for
    example. Also, time options might need to be changed, depending on when the application
    is being run and if you don't want to wait for hours before you see proof that
    it actually works.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our application now with these configurations, we will get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8b4e47a-f607-405e-9723-4ac53004c274.png)'
  prefs: []
  type: TYPE_IMG
- en: We can leave the application and it will keep executing the tasks we had every
    one hour or day, depending on how the tasks are scheduled. Of course, we could
    add more meaningful jobs, allocate more workers, change other configurations,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The future of our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used a number of techniques and concepts that we have learned throughout
    this book—dependency injection, factory design pattern, ADTs, and the Akka library,
    which can be used to implement the observer design pattern. This was a complete
    application that was designed to be testable and extendible.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily add more granularity to the execution schedule of the jobs, the
    different types of tasks, and also have tasks trigger each other, different routing
    mechanisms, and so on. We showed that we have learned about a great number of
    useful concepts in this book, and now we can put everything to use in order to
    create great programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we are at the end of our journey through the Scala design patterns. As
    you already know, design patterns exist in order to cope with a certain limitation
    of a language. They also help us to structure our code in a way that makes it
    easy to change, use, test, and maintain. Scala is an extremely rich language,
    and we focused on some of its features that make it capable of achieving things
    that other languages might not be able to do without any extra effort and knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the different *Gang of Four* design patterns from the point of
    view of Scala—creational, structural, and behavioral design patterns. We saw that
    some of them are not even applicable in functional languages and that others can
    be approached differently. We also saw that some design patterns still remain
    valid and knowing them is really important for any developer.
  prefs: []
  type: TYPE_NORMAL
- en: We can't talk about Scala without dealing with concepts such as monoids and
    monads. At first, they could be pretty scary and abstract and manage to put people
    off. So, we spent some time with them and showed their value. They can be used
    to write powerful applications in a purely functional way. They can be used to
    abstract and reuse functionality. By minimizing the dry theory and focusing on
    understandable examples, we hopefully made them much more approachable and usable
    for those of you who don't have a deep mathematical background.
  prefs: []
  type: TYPE_NORMAL
- en: Using the rich features of Scala opens up another large group of design patterns.
    We spent some time on design patterns that are possible just because of the way
    Scala works and the different features it provides.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we have tried to provide meaningful examples that can be
    used as a reference to find specific patterns and applications of the techniques
    we learned here. In this last chapter, we even implemented a complete application.
    On many occasions, we have tried to showcase how different design patterns can
    be combined. Of course, in some cases, the concepts could be pretty complicated
    by themselves, so we simplified the examples.
  prefs: []
  type: TYPE_NORMAL
- en: We've given some advice about when to use certain design patterns and when to
    avoid them. These points should be extremely helpful to you in terms of what details
    to focus on.
  prefs: []
  type: TYPE_NORMAL
- en: The use of libraries has been encouraged throughout the book. Especially in
    the last few chapters, you have been exposed to quite a large number of interesting
    libraries that can be easily added to your arsenal. We have hopefully also sparked
    an interest and a habit to always do checks before trying something *new*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all the examples found in this book can also be found online at [https://github.com/nikolovivan/scala-design-patterns](https://github.com/nikolovivan/scala-design-patterns-v2).
  prefs: []
  type: TYPE_NORMAL
