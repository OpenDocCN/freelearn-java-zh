<html><head></head><body>
<div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.2.1">Why Hexagonal Architecture?</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Software that’s not well organized and lacks sound software architecture principles may work just fine but develop technical debt over time. </span><span class="koboSpan" id="kobo.3.2">As new features are added, the software may become more complex to maintain because there is no common ground to guide code changes. </span><span class="koboSpan" id="kobo.3.3">Based on that problem, this chapter explains how hexagonal architecture helps to build software prepared to accommodate changes from unexpected requirements and, by doing so, allows us to increase software maintainability and keep technical debt </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">under control.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We tackle the technical debt problem that arises when shortcuts are taken to overcome the difficulty of introducing changes caused by an inflexible software architecture. </span><span class="koboSpan" id="kobo.5.2">We will see how hexagonal architecture helps us improve maintainability by providing the principles to decouple the business logic (code that should purely represent a business problem) from the technology code (code that integrates the system with different technologies such as databases, messaging queues, and external APIs to support the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">business logic).</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">I have seen systems developed with business logic closely related to the technology code. </span><span class="koboSpan" id="kobo.7.2">Some of those systems would rarely change, so the coupling between business logic and technology code would never be a problem. </span><span class="koboSpan" id="kobo.7.3">However, significant refactorings would be necessary for other systems where the requirements would change often and substantially. </span><span class="koboSpan" id="kobo.7.4">That was because the business logic was so tightly coupled with the technology code that rewriting the business logic was the only </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">plausible solution.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Using hexagonal architecture may help you to save time and effort due to the software rewrites caused by such scenarios where requirements change often </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and significantly.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Reviewing </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">software architecture</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">hexagonal architecture</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">By the end of this chapter, you will have learned about the main concepts of hexagonal architecture: entities, use cases, ports, and adapters. </span><span class="koboSpan" id="kobo.17.2">Also, you’ll know the basic techniques to start applying hexagonal principles in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">your projects.</span></span></p>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To compile and run the code examples presented in this chapter, you need the latest Java SE Development Kit and Maven 3.8 installed on your computer. </span><span class="koboSpan" id="kobo.20.2">They are both available for Linux, macOS, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter01"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter01</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.26.1">Reviewing software architecture</span></h1>
<p><span class="koboSpan" id="kobo.27.1">The word architecture is old. </span><span class="koboSpan" id="kobo.27.2">Its origin traces back to times when people used to build things with rudimentary tools, often with their own hands. </span><span class="koboSpan" id="kobo.27.3">Yet, each generation repeatedly overcame the </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.28.1">limitations of its era and constructed magnificent buildings that stand to this day. </span><span class="koboSpan" id="kobo.28.2">Take a look at the Florence Cathedral and its dome designed by Filippo Brunelleschi – what an excellent example </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">of architecture!</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Architects are more than just ordinary builders who build things without much thinking. </span><span class="koboSpan" id="kobo.30.2">Quite the opposite; they are the ones who care the most about aesthetics, underlying structures, and design principles. </span><span class="koboSpan" id="kobo.30.3">Sometimes, they play a fundamental role by pushing the limits of what is possible to do with the resources at hand. </span><span class="koboSpan" id="kobo.30.4">The Florence Cathedral, as has already been mentioned, proves </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">that point.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">I’ll not take this analogy too far because software is not like a physical building. </span><span class="koboSpan" id="kobo.32.2">And although there are some similarities between building and software architects, the latter differs considerably because of the living and evolving nature of their software craft. </span><span class="koboSpan" id="kobo.32.3">But we can agree that both share the same goal: to build </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">things right.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">This goal helps us understand what software architecture is. </span><span class="koboSpan" id="kobo.34.2">If we’re aiming to build not just working but also easily maintainable and well-structured software, it can even be considered to a certain degree as a piece of art because of the care and attention to detail we employ to build it. </span><span class="koboSpan" id="kobo.34.3">So, we can take this activity of building easily maintainable and well-structured software as a noble definition of </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">software architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">It’s also important to state that a software architect’s role should not only be constrained to deciding how things should be made. </span><span class="koboSpan" id="kobo.36.2">As in the Florence Cathedral example, where Filippo Brunelleschi himself helped to afix bricks to the building to prove his ideas were sound, a software architect, in the same vein, should soil their hands to prove their architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">is good.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Software architecture should not be the fruit of one person’s mind. </span><span class="koboSpan" id="kobo.38.2">Although there are a few who urge </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.39.1">others to pursue a path of technical excellence by providing guidance and establishing the foundations, for an architecture to evolve and mature, it’s necessary to utilize the collaboration and experience of everyone involved in the effort to improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">software quality.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">What follows is a discussion around the technical and organizational challenges we may encounter in our journey to create and evolve a software architecture to help us tackle the threat of chaos and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">indomitable complexity.</span></span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.43.1">Making decisions</span></h2>
<p><span class="koboSpan" id="kobo.44.1">All this discussion around software architecture concerns is relevant because we may undermine our </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.45.1">capability to maintain and evolve software in the long run if we ignore those concerns. </span><span class="koboSpan" id="kobo.45.2">Of course, there are situations where we’re not so ambitious about how sophisticated, maintainable, and feature-rich our software will be. </span><span class="koboSpan" id="kobo.45.3">It may not be worth all the time and effort to build things in the right way for such situations because what’s needed is working software delivered as fast as possible. </span><span class="koboSpan" id="kobo.45.4">In the end, it’s a matter of priorities. </span><span class="koboSpan" id="kobo.45.5">But we should be cautious not to fall into the trap that we can fix things later. </span><span class="koboSpan" id="kobo.45.6">Sometimes we may have the money to do so but sometimes we may not. </span><span class="koboSpan" id="kobo.45.7">Bad decisions at the beginning of a project can cost us a high price in </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The decisions we take regarding code structure and software architecture lead us to what is called internal quality. </span><span class="koboSpan" id="kobo.47.2">The degree to which software code is well organized and maintainable corresponds to the internal quality. </span><span class="koboSpan" id="kobo.47.3">On the other hand, the value perception about how valuable and good software can be from a user’s perspective corresponds to the external quality. </span><span class="koboSpan" id="kobo.47.4">Internal and external quality are not directly connected. </span><span class="koboSpan" id="kobo.47.5">It’s not difficult to find useful software with a messy </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">The effort spent on internal quality should be seen as an investment where the return is not immediate and visible to the user. </span><span class="koboSpan" id="kobo.49.2">The investment return comes as the software evolves. </span><span class="koboSpan" id="kobo.49.3">The value is perceived by constantly adding changes to the software without increasing the time and money required to add such changes, as the following </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">pseudo-graph depicts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 1.1 – Pseudo-graph showing the impact of changes" src="image/B19777_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 1.1 – Pseudo-graph showing the impact of changes</span></p>
<p><span class="koboSpan" id="kobo.53.1">But how can we make the right decisions? </span><span class="koboSpan" id="kobo.53.2">That’s a trick question because we often don’t have enough information to assist in a decision-making process that will lead to software architecture that best meets the business needs. </span><span class="koboSpan" id="kobo.53.3">Sometimes, even the users don’t know </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.54.1">completely what they want, leading to new or changed requirements as the project evolves. </span><span class="koboSpan" id="kobo.54.2">We tackle such unpredictability by using a software architecture that helps us add changes in a sustainable way to ensure the code base grows without increased complexity and </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">decreased maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">The ability to quickly introduce changes is a major concern in software design, but we should be cautious about how much time we spend thinking about it. </span><span class="koboSpan" id="kobo.56.2">If we spend too much time designing, we may end up with an overengineered and possibly overpriced solution. </span><span class="koboSpan" id="kobo.56.3">On the other hand, if we ignore or do not reflect enough on design concerns, we may end up with a complex and hard-to-maintain solution. </span><span class="koboSpan" id="kobo.56.4">As pointed out by </span><em class="italic"><span class="koboSpan" id="kobo.57.1">Extreme Programming Explained: Embrace Change</span></em><span class="koboSpan" id="kobo.58.1">, the resources spent on design efforts should match a system’s need to handle changes at an acceptable pace </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">and cost.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">In the end, we want the flexibility of adding new stuff while keeping complexity under control. </span><span class="koboSpan" id="kobo.60.2">With that in mind, this book is concerned with software architecture ideas that allow us to handle software design decisions to meet changing business needs. </span><span class="koboSpan" id="kobo.60.3">The hexagonal architecture helps us to build change-tolerant systems to support </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">those needs.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.62.1">The invisible things</span></h2>
<p><span class="koboSpan" id="kobo.63.1">Software development is not a trivial activity. </span><span class="koboSpan" id="kobo.63.2">It demands considerable effort to become competent in any programming language, and even greater effort to use that skill to build software that generates profit. </span><span class="koboSpan" id="kobo.63.3">Surprisingly, sometimes it may not be enough to just make </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">profitable software.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">When we talk </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.66.1">about profitable software, we’re talking about software that solves real-world problems. </span><span class="koboSpan" id="kobo.66.2">Or, in the context of large enterprises, to speak more precisely, we mean software that meets business needs. </span><span class="koboSpan" id="kobo.66.3">Anyone who has worked in a large enterprise will know that the client generally doesn’t want to know how the software is built. </span><span class="koboSpan" id="kobo.66.4">They are interested in what they can see: working software meeting business expectations. </span><span class="koboSpan" id="kobo.66.5">After all, that’s what pays the bills at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">the day.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">But the things that clients cannot see also have some importance. </span><span class="koboSpan" id="kobo.68.2">Such things are known as </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.69.1">non-functional requirements. </span><span class="koboSpan" id="kobo.69.2">They are things related to security, maintainability, operability, scalability, reliability and other capabilities. </span><span class="koboSpan" id="kobo.69.3">If adequate care is not taken, those things unseen from the client’s perspective can compromise the whole purpose of the software. </span><span class="koboSpan" id="kobo.69.4">That compromise can occur subtly and gradually, giving origin to several problems, including </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">technical debt.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">I’ve mentioned previously that software architecture is about doing things right. </span><span class="koboSpan" id="kobo.71.2">So, it means that among its concerns, we should include both unseen and seen things. </span><span class="koboSpan" id="kobo.71.3">For things that are seen by the client, it’s essential to deeply understand the problem domain. </span><span class="koboSpan" id="kobo.71.4">That’s where techniques such as domain-driven design can help us approach the problem in a way that allows us to structure the software in a form that makes sense not only for programmers but also for everyone involved in the problem domain. </span><span class="koboSpan" id="kobo.71.5">Domain-driven design also plays a key role in shaping the unseen part by cohesively defining the underlying structures that will allow us to solve client needs and doing that in a well-structured and </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">maintainable manner.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.73.1">Technical debt</span></h2>
<p><span class="koboSpan" id="kobo.74.1">Coined by </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.75.1">Ward Cunningham, technical debt is a term used to describe how much unnecessary complexity exists in software code. </span><span class="koboSpan" id="kobo.75.2">Such unnecessary complexity may also be referred to as cruft – that is, the difference between the current code and how it would ideally be. </span><span class="koboSpan" id="kobo.75.3">We’ll see next how technical debt can appear in a </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">software project.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Developing software that just works is one thing. </span><span class="koboSpan" id="kobo.77.2">You assemble code in a way you think is adequate to meet business needs, and then package and deploy it to production. </span><span class="koboSpan" id="kobo.77.3">In production, your software meets clients’ expectations, so everything is fine and life goes on. </span><span class="koboSpan" id="kobo.77.4">Sometime later, another developer comes in to add new features to that software you created. </span><span class="koboSpan" id="kobo.77.5">Like you, this developer assembles code in a way they think is adequate to meet business needs, but there are things in your code this developer doesn’t clearly understand. </span><span class="koboSpan" id="kobo.77.6">Hence, they add elements to the software in a slightly different manner than you would. </span><span class="koboSpan" id="kobo.77.7">The software makes its way into production, and the customer is satisfied. </span><span class="koboSpan" id="kobo.77.8">So, the </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">cycle repeats.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Software working </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.80.1">as expected is what we can clearly see in the previous scenario. </span><span class="koboSpan" id="kobo.80.2">But what we cannot see so clearly is that the lack of common ground defining how features should be added or modified leaves a gap that every developer will try to fill whenever they do not know how to handle such changes. </span><span class="koboSpan" id="kobo.80.3">This very gap leaves space for the growth of things such as </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">technical debt.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Reality very often pushes us to situations where we just cannot avoid technical debt. </span><span class="koboSpan" id="kobo.82.2">Tight schedules, poor planning, unskilled people, and, of course, a lack of software architecture are some of the factors that can contribute to the creation of technical debt. </span><span class="koboSpan" id="kobo.82.3">Needless to say, we should not believe that the enforcement of software architecture will magically solve all our technical debt problems. </span><span class="koboSpan" id="kobo.82.4">Far from that; here, we’re just tackling one facet of the problem. </span><span class="koboSpan" id="kobo.82.5">All other technical debt factors will remain and can actually undermine our efforts to build </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">maintainable software.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.84.1">Vicious cycle</span></h2>
<p><span class="koboSpan" id="kobo.85.1">Financial debts tend to continue to grow regardless if you don’t pay them. </span><span class="koboSpan" id="kobo.85.2">Also, the bank and </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.86.1">authorities can come after you and your assets if you don’t pay those debts in time. </span><span class="koboSpan" id="kobo.86.2">Contrary to its financial counterpart, technical debt doesn’t necessarily grow if you don’t pay it. </span><span class="koboSpan" id="kobo.86.3">What determines its growth, though, is the rate and nature of software changes. </span><span class="koboSpan" id="kobo.86.4">Based on that, we can assume that frequent and complex changes have a higher potential to increase </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">technical debt.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">You always have the prerogative not to pay technical debt – sometimes that’s the best choice depending on the circumstance – but you diminish your capacity to change the software as you do so. </span><span class="koboSpan" id="kobo.88.2">With higher technical debt rates, the code becomes more and more unmanageable, causing developers to either avoid touching the code at all or find awkward workarounds to solve </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">the issues.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">I believe most of us will have had at least once the unpleasant experience of maintaining brittle, insanely complex systems. </span><span class="koboSpan" id="kobo.90.2">In such scenarios, instead of spending time working on things that are valuable to the software, we spend more time fighting technical debt to open space </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.91.1">to introduce new features. </span><span class="koboSpan" id="kobo.91.2">If we don’t keep the technical debt under control, one day, it will not be worth adding new features to the technical debt-overloaded system. </span><span class="koboSpan" id="kobo.91.3">That’s when people decide to abandon applications, start a new one, and repeat the cycle. </span><span class="koboSpan" id="kobo.91.4">So, the effort required to tackle technical debt should be considered worth it to break </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">that cycle.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.93.1">It’s not for everyone</span></h2>
<p><span class="koboSpan" id="kobo.94.1">This zest for quality and correctness that emerges from any serious architectural undertaking is not </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.95.1">always present, There are scenarios where the most profit-driving software in a company is an absolute big ball of mud. </span><span class="koboSpan" id="kobo.95.2">It’s software that has grown without any sense of order and is complicated to understand and maintain. </span><span class="koboSpan" id="kobo.95.3">Developers who dare to tackle the complexity posed by this kind of system are like warriors fighting a hydra. </span><span class="koboSpan" id="kobo.95.4">The refactoring effort required to impose any order in such complexity is sometimes not </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">worth it.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">The big ball of mud is not the only problem. </span><span class="koboSpan" id="kobo.97.2">There are also cultural and organizational factors that can undermine any software architecture effort. </span><span class="koboSpan" id="kobo.97.3">Very often, I’ve stumbled upon teammates who simply didn’t care about architectural principles. </span><span class="koboSpan" id="kobo.97.4">The least-effort path to deliver code into production is the norm to be followed in their minds. </span><span class="koboSpan" id="kobo.97.5">It’s not hard to find this kind of person in projects with a high turnaround of developers. </span><span class="koboSpan" id="kobo.97.6">Because there is no sense of ownership in terms of quality and high standards, there is no incentive to produce </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">high-quality code.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Pushing the discipline to follow a software architecture is hard. </span><span class="koboSpan" id="kobo.99.2">Both the technical team and management should be aligned on the advantages and implications of following such discipline. </span><span class="koboSpan" id="kobo.99.3">It’s important to understand that spending more time upfront on dealing with technical aspects that don’t add much value in terms of customer features may pay dividends in the long term. </span><span class="koboSpan" id="kobo.99.4">All the effort is paid back with more maintainable software, relieving developers who no longer need to fight hydras and managers who are now better positioned to meet </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">business deadlines.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Before trying to promote, let alone enforce, any software architecture principle, it is advisable to assess the circumstances to make sure there are neither cultural nor organizational factors </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.102.1">playing against the attitude of a few trying to meet or raise the bar to </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">better-developed systems.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.104.1">Monolithic or distributed</span></h2>
<p><span class="koboSpan" id="kobo.105.1">There is a recurring discussion in the software community about the organization of a system’s components and responsibilities. </span><span class="koboSpan" id="kobo.105.2">In the past, where expensive computing resources and </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.106.1">network bandwidth were the problems that influenced the software architecture, developers tended to group plenty of responsibilities in a single software unit to optimize resource usage and avoid the network overhead that would occur in a distributed environment. </span><span class="koboSpan" id="kobo.106.2">But there is a tenuous line separating a maintainable and cohesive monolith from an entangled and </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">hard-to-maintain one.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">The crossing of such a line is a red flag showing the system has accumulated so many responsibilities and has become so complex to maintain that any change poses a severe risk of breaking down the entire software. </span><span class="koboSpan" id="kobo.108.2">I’m not saying that every monolithic that grows becomes a mess. </span><span class="koboSpan" id="kobo.108.3">I’m trying to convey that the accumulation of responsibilities can cause serious problems in a monolithic system when such responsibility aggregation is not handled with care. </span><span class="koboSpan" id="kobo.108.4">Apart from this responsibility issue, it’s also equally important to make sure the software is easy to develop, test, and deploy. </span><span class="koboSpan" id="kobo.108.5">If the software is too large, developers may have difficulty trying to run and test it locally. </span><span class="koboSpan" id="kobo.108.6">It can also have a serious impact on continuous integration pipelines, impacting the compiling, testing, and deployment stages of such pipelines, ultimately compromising the feedback loop that is so crucial in a </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">DevOps context.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">On the other hand, if we know when a system accumulates sufficient responsibility, we can rethink the overall software architecture and break down the large monolithic into smaller and more manageable, sometimes autonomous, software components that are often isolated </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.111.1">in their own runtime environments. </span><span class="koboSpan" id="kobo.111.2">This approach got strong adoption with </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Service-Oriented Architecture </span></strong><span class="koboSpan" id="kobo.113.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.114.1">SOA</span></strong><span class="koboSpan" id="kobo.115.1">) and then </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.116.1">with what can be considered its evolution: the </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">microservice architecture</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">Both SOA and microservices can be considered different flavors of distributed systems. </span><span class="koboSpan" id="kobo.118.3">Microservice architecture, in particular, is made possible mainly because computing and network resources are not as expensive as they used to be, bringing lots of benefits related to strong decoupling and faster software delivery. </span><span class="koboSpan" id="kobo.118.4">However, this comes with costs because earlier we had to deal with complexity in just one place, whereas now the challenge is dealing with complexity scattered around multiple services in </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">the network.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">This book proposes hexagonal architecture ideas that you can apply to monolithic and distributed systems. </span><span class="koboSpan" id="kobo.120.2">With monolithic, you may have the application being consumed by a frontend and, at the same time, consuming data from a database or other data sources. </span><span class="koboSpan" id="kobo.120.3">The hexagonal approach can help us develop a more change-tolerant monolithic system, testable </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.121.1">even without the frontend and the database. </span><span class="koboSpan" id="kobo.121.2">The following diagram illustrates a common </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">monolithic system:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.123.1"><img alt="Figure 1.2 – Hexagonal architecture with a monolithic system" src="image/B19777_01_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.124.1">Figure 1.2 – Hexagonal architecture with a monolithic system</span></p>
<p><span class="koboSpan" id="kobo.125.1">In distributed systems, we may be dealing with lots of different technologies. </span><span class="koboSpan" id="kobo.125.2">The hexagonal architecture shines in these scenarios because its ports and adapters allow the software to deal with constant technology changes. </span><span class="koboSpan" id="kobo.125.3">The following diagram shows a typical microservice architecture where we could apply </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">hexagonal principles:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.127.1"><img alt="Figure 1.3 – Hexagonal architecture with a microservices system" src="image/B19777_01_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.128.1">Figure 1.3 – Hexagonal architecture with a microservices system</span></p>
<p><span class="koboSpan" id="kobo.129.1">One of the </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.130.1">great advantages of microservice architecture is that we can use different technologies and programming languages to compose the whole system. </span><span class="koboSpan" id="kobo.130.2">We can develop a frontend application using JavaScript, some APIs with Java, and a data processing application with Python. </span><span class="koboSpan" id="kobo.130.3">Hexagonal architecture can help us in this kind of heterogeneous </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">technological scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Now that we’re aware of some of the problems related to software architecture, we’re in a better position to explore possible solutions to mitigate those issues. </span><span class="koboSpan" id="kobo.132.2">To help us in that effort, let’s start by looking into the fundamentals of </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">hexagonal architecture.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.134.1">Understanding hexagonal architecture</span></h1>
<p><span class="koboSpan" id="kobo.135.1">“</span><em class="italic"><span class="koboSpan" id="kobo.136.1">Create your </span></em><em class="italic"><a id="_idIndexMarker017"/></em><em class="italic"><span class="koboSpan" id="kobo.137.1">application to work without either a UI or a database so you can run automated regression-tests against the application, work when the database becomes unavailable, and link applications together without any </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.138.1">user involvement.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">– </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">Alistair Cockburn.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">That quote lays the ground for understanding hexagonal architecture. </span><span class="koboSpan" id="kobo.142.2">We can go even further with Cockburn’s idea and make our application work without any technology, not just the ones related to the UI </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">or database.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">One of the main ideas of hexagonal architecture is to separate business code from technology code.Not just that, we must also make sure the technology side depends on the business one so that the latter can evolve without any concerns regarding which technology is used to fulfill business goals. </span><span class="koboSpan" id="kobo.144.2">Having the business logic independent of any technology details gives a system the flexibility to change technologies without disrupting its business logic. </span><span class="koboSpan" id="kobo.144.3">In that sense, the business logic represents the foundation through which the application is developed and from which all other system components </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">will derive.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">We must be </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.147.1">able to change technology code without causing harm to its business counterpart. </span><span class="koboSpan" id="kobo.147.2">To achieve this, we must determine a place where the business code will exist, isolated and protected from any technology concerns. </span><span class="koboSpan" id="kobo.147.3">It’ll give rise to the creation of our first hexagon: the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">Domain hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">In the Domain hexagon, we assemble the elements responsible for describing the core problems we want our software to solve. </span><span class="koboSpan" id="kobo.149.2">Entities and value objects are the main elements utilized in the Domain hexagon. </span><span class="koboSpan" id="kobo.149.3">Entities represent things we can assign an identity to, and value objects are immutable components that we can use to compose our entities. </span><span class="koboSpan" id="kobo.149.4">The meaning this book uses for entities and value objects comes from domain-driven </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">design principles.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">We also need ways to use, process, and orchestrate the business rules coming from the Domain hexagon. </span><span class="koboSpan" id="kobo.151.2">That’s what the Application hexagon does. </span><span class="koboSpan" id="kobo.151.3">It sits between the business and technology sides, serving as a middleman to interact with both parts. </span><span class="koboSpan" id="kobo.151.4">The Application hexagon utilizes ports and use cases to perform its functions. </span><span class="koboSpan" id="kobo.151.5">We will explore those things in more detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">The Framework hexagon provides the outside-world interface. </span><span class="koboSpan" id="kobo.153.2">That’s the place where we have the opportunity to determine how to expose application features – this is where we define REST or gRPC endpoints, for example. </span><span class="koboSpan" id="kobo.153.3">To consume things from external sources, we use the Framework hexagon to specify the mechanisms to fetch data from databases, message brokers, or any other system. </span><span class="koboSpan" id="kobo.153.4">In the hexagonal architecture, we materialize technology decisions through adapters. </span><span class="koboSpan" id="kobo.153.5">The following diagram provides a high-level view of </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">the architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.155.1"><img alt="Figure 1.4 – The hexagonal architecture" src="image/B19777_01_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.156.1">Figure 1.4 – The hexagonal architecture</span></p>
<p><span class="koboSpan" id="kobo.157.1">Next, we’ll go </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.158.1">deeper into the components, roles, and structures of </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">each hexagon.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.160.1">Domain hexagon</span></h2>
<p><span class="koboSpan" id="kobo.161.1">The Domain hexagon represents an effort to understand and model a real-world problem. </span><span class="koboSpan" id="kobo.161.2">Suppose you’re </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.162.1">working on a project that </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.163.1">requires creating a network and topology inventory for a telecom company. </span><span class="koboSpan" id="kobo.163.2">This inventory’s main purpose is to provide a comprehensive view of all resources that comprise the network. </span><span class="koboSpan" id="kobo.163.3">Among those resources, we have routers, switches, racks, shelves, and other equipment types. </span><span class="koboSpan" id="kobo.163.4">Our goal here is to use the Domain hexagon to model into code the knowledge required to identify, categorize, and correlate those network and topology elements and provide a lucid and organized view of the desired inventory. </span><span class="koboSpan" id="kobo.163.5">That knowledge should be, as much as possible, represented in a </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">technology-agnostic form.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">This quest is not a trivial one. </span><span class="koboSpan" id="kobo.165.2">Developers involved in such an undertaking may not know much about the telecom business, set aside this inventory thing. </span><span class="koboSpan" id="kobo.165.3">As recommended by </span><em class="italic"><span class="koboSpan" id="kobo.166.1">Domain-Driven Design: Tackling Complexity in the Heart of Software</span></em><span class="koboSpan" id="kobo.167.1">, domain experts or other developers who already know the problem domain should be consulted. </span><span class="koboSpan" id="kobo.167.2">If none are available, you should try to fill the knowledge gap by searching in books or any other material that teaches about the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">problem domain.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Inside the Domain hexagon, we have entities corresponding to critical business data and rules. </span><span class="koboSpan" id="kobo.169.2">They are </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.170.1">critical because they represent a model of the real problem. </span><span class="koboSpan" id="kobo.170.2">That model may take some time to evolve and reflect consistently on the problem domain. </span><span class="koboSpan" id="kobo.170.3">That’s often the case with new software projects where neither developers nor </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.171.1">domain experts have a clear vision of the system’s purpose in its early stages. </span><span class="koboSpan" id="kobo.171.2">In such scenarios, particularly recurrent in start-up environments, it’s normal and predictable to have an initial awkward domain model that evolves only as business ideas also evolve and are validated by users and domain experts. </span><span class="koboSpan" id="kobo.171.3">It’s a curious situation where the domain model is unknown even to the so-called </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">domain experts.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">On the other hand, in scenarios where the problem domain exists and is clear in the minds of domain experts, if we fail to grasp that problem domain and how it translates into entities and other domain model elements, such as value objects, we risk building our software based on weak or </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">wrong assumptions.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">Weak assumptions can be one of the reasons why software may start simple but, as its code base grows, it accumulates technical debt and becomes harder to maintain. </span><span class="koboSpan" id="kobo.175.2">These weak assumptions may lead to fragile and unexpressive code that can initially solve business problems but is not ready to accommodate changes in a cohesive way. </span><span class="koboSpan" id="kobo.175.3">Bear in mind that the Domain hexagon is composed of whatever kind of object categories you feel are good for representing the problem domain. </span><span class="koboSpan" id="kobo.175.4">Here is a representation based just on entities and </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">value objects:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.177.1"><img alt="Figure 1.5 – Domain hexagon" src="image/B19777_01_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">Figure 1.5 – Domain hexagon</span></p>
<p><span class="koboSpan" id="kobo.179.1">Let’s now </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.180.1">talk about the components comprising </span><a id="_idIndexMarker025"/><span class="No-Break"><span class="koboSpan" id="kobo.181.1">this hexagon.</span></span></p>
<h3><span class="koboSpan" id="kobo.182.1">Entities</span></h3>
<p><span class="koboSpan" id="kobo.183.1">Entities help </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.184.1">us to build more expressive code. </span><span class="koboSpan" id="kobo.184.2">What characterizes an entity is its sense of continuity and identity, as described by </span><em class="italic"><span class="koboSpan" id="kobo.185.1">Domain-Driven Design: Tackling Complexity in the Heart of Software</span></em><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">That continuity is related to the life cycle and mutable characteristics of the object. </span><span class="koboSpan" id="kobo.186.3">For example, in our network and </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.187.1">topology inventory scenario, we mentioned the existence of routers. </span><span class="koboSpan" id="kobo.187.2">For a router, we can define whether its state is enabled </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">or disabled.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Also, we can assign some properties describing the relationship that a router has with different routers and other network equipment. </span><span class="koboSpan" id="kobo.189.2">All those properties may change over time, so we can see that the router is not a static thing and its characteristics inside the problem domain can change. </span><span class="koboSpan" id="kobo.189.3">Because of that, we can state that the router has a life cycle. </span><span class="koboSpan" id="kobo.189.4">Apart from that, every router should be unique in an inventory, so it must have an identity. </span><span class="koboSpan" id="kobo.189.5">So, continuity and identity are the elements that determine </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">an entity.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The following code shows a </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">Router</span></strong><span class="koboSpan" id="kobo.193.1"> entity class composed of </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">RouterType</span></strong><span class="koboSpan" id="kobo.195.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">RouterId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.197.1">value objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.198.1">
//Router entity class
public class Router {
    private final Type type;
    private final RouterId id;
    public Router(Type type, RouterId id) {
        this.type = type;
        this.id = id;
    }
    public static List&lt;Router&gt; checkRouter(
    Type type, List&lt;Router&gt; routers) {
    var routersList = new ArrayList&lt;Router&gt;();
        routers.forEach(router -&gt; {
        if(router.type == type ){
            routersList.add(router);
        }
    });
    return routersList;
    }
}</span></pre> <h3><span class="koboSpan" id="kobo.199.1">Value objects</span></h3>
<p><span class="koboSpan" id="kobo.200.1">Value objects </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.201.1">complement our code’s expressiveness when there is no need to identify something uniquely, as well as when we are more concerned about the object’s attributes than its identity. </span><span class="koboSpan" id="kobo.201.2">We can use value objects to compose an entity object, so we must make them immutable to avoid unforeseen inconsistencies across the domain. </span><span class="koboSpan" id="kobo.201.3">In the router example presented previously, we can represent the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Type</span></strong><span class="koboSpan" id="kobo.203.1"> router </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.204.1">as a value object attribute from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1"> entity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
public enum Type {
       EDGE,
    CORE;
}</span></pre> <h2 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.208.1">Application hexagon</span></h2>
<p><span class="koboSpan" id="kobo.209.1">So far, we’ve been discussing how the Domain hexagon encapsulates business rules with entities and </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.210.1">value objects. </span><span class="koboSpan" id="kobo.210.2">But there are situations where the software does not need to operate directly at the domain level. </span><em class="italic"><span class="koboSpan" id="kobo.211.1">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</span></em><span class="koboSpan" id="kobo.212.1"> states that some operations </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.213.1">exist solely to allow the automation provided by the software. </span><span class="koboSpan" id="kobo.213.2">These operations – although they support business rules – would not exist outside the context of the software. </span><span class="koboSpan" id="kobo.213.3">We’re talking about </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">application-specific operations.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">The Application hexagon is where we abstractly deal with application-specific tasks. </span><span class="koboSpan" id="kobo.215.2">I mean abstract because we’re not dealing directly with technology concerns yet. </span><span class="koboSpan" id="kobo.215.3">This hexagon expresses the software’s user intent and features based on the Domain hexagon’s </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">business rules.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Based on the same topology and inventory network scenario described previously, suppose you need a way to query routers of the same type. </span><span class="koboSpan" id="kobo.217.2">It would require some data handling to produce such results. </span><span class="koboSpan" id="kobo.217.3">Your software would need to capture some user input to query for router types. </span><span class="koboSpan" id="kobo.217.4">You may want to use a particular business rule to validate user input and another business rule to verify data fetched from external sources. </span><span class="koboSpan" id="kobo.217.5">If no constraints are violated, your software then provides the data showing a list of routers of the same type. </span><span class="koboSpan" id="kobo.217.6">We can group all those different tasks in a use case. </span><span class="koboSpan" id="kobo.217.7">The following diagram depicts the Application hexagon’s high-level structure based on use cases, input ports, and </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">output ports:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.219.1"><img alt="Figure 1.6 – Application hexagon" src="image/B19777_01_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.220.1">Figure 1.6 – Application hexagon</span></p>
<p><span class="koboSpan" id="kobo.221.1">The </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.222.1">following </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.223.1">sections will discuss the components of </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">this hexagon.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.225.1">Use cases</span></h2>
<p><span class="koboSpan" id="kobo.226.1">Use cases represent a system’s behavior through application-specific operations that exist within </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.227.1">the software realm to support the domain’s constraints. </span><span class="koboSpan" id="kobo.227.2">Use cases may interact directly with entities and other use cases, making them quite flexible components. </span><span class="koboSpan" id="kobo.227.3">In Java, we represent use cases as abstractions defined by interfaces expressing what the software can do. </span><span class="koboSpan" id="kobo.227.4">The following example shows a use case that provides an operation to get a filtered list </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">of routers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
public interface RouterViewUseCase {
    List&lt;Router&gt; getRouters(Predicate&lt;Router&gt; filter);
}</span></pre> <p><span class="koboSpan" id="kobo.230.1">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Predicate</span></strong><span class="koboSpan" id="kobo.232.1"> filter. </span><span class="koboSpan" id="kobo.232.2">We’re going to use it to filter the router list when implementing that use case with an </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">input port.</span></span></p>
<h3><span class="koboSpan" id="kobo.234.1">Input ports</span></h3>
<p><span class="koboSpan" id="kobo.235.1">If use cases are just interfaces describing what the software does, we still need to implement the use case interface. </span><span class="koboSpan" id="kobo.235.2">That’s the role of the input port. </span><span class="koboSpan" id="kobo.235.3">By being a component that’s directly </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.236.1">attached to use cases, at the </span><em class="italic"><span class="koboSpan" id="kobo.237.1">Application</span></em><span class="koboSpan" id="kobo.238.1"> level, input ports allow us to implement software intent on domain terms. </span><span class="koboSpan" id="kobo.238.2">Here is an input port providing an implementation that fulfills the software intent stated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">use case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.240.1">
public class RouterViewInputPort implements RouterViewUse
  Case {
    private RouterViewOutputPort routerListOutputPort;
    public RouterViewInput
      Port(RouterViewOutputPort  routerViewOutputPort) {
        this.routerListOutputPort = routerViewOutputPort;
    }
    @Override
    public List&lt;Router&gt; getRouters(Predicate&lt;Router&gt; fil
       ter) {
        var routers = routerListOutput
             Port.fetchRouters();
        return Router.retrieveRouter(routers, filter);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.241.1">This example shows us how we could use a domain constraint to make sure we’re filtering the routers we want to retrieve. </span><span class="koboSpan" id="kobo.241.2">From the input port’s implementation, we can also get things from outside the application. </span><span class="koboSpan" id="kobo.241.3">We can do that using </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">output ports.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.243.1">Output ports</span></h2>
<p><span class="koboSpan" id="kobo.244.1">There are situations in which a use case needs to fetch data from external resources to achieve its goals. </span><span class="koboSpan" id="kobo.244.2">That’s the role of output ports, which are represented as interfaces describing, in a technology-agnostic way, what kind of data a use case or input port would need </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.245.1">to get from outside to perform its operations. </span><span class="koboSpan" id="kobo.245.2">I say agnostic because output ports don’t care whether the data comes from a particular relational database technology or a filesystem, for example. </span><span class="koboSpan" id="kobo.245.3">We assign this responsibility to output adapters, which we’ll look </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">at shortly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
public interface RouterViewOutputPort {
    List&lt;Router&gt; fetchRouters();
}</span></pre> <p><span class="koboSpan" id="kobo.248.1">Now, let’s discuss the last type </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">of hexagon.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.250.1">Framework hexagon</span></h2>
<p><span class="koboSpan" id="kobo.251.1">Things seem well organized with our critical business rules constrained to the Domain hexagon, followed </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.252.1">by the Application hexagon </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.253.1">dealing with some application-specific operations through the means of use cases, input ports, and output ports. </span><span class="koboSpan" id="kobo.253.2">Now comes the moment when we need to decide which technologies should be allowed to communicate with our software. </span><span class="koboSpan" id="kobo.253.3">That communication can occur in two forms, one known as driving and the other as driven. </span><span class="koboSpan" id="kobo.253.4">For the driver side, we use input adapters, and for the driven side, we use output adapters, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.255.1"><img alt="Figure 1.7 – Framework hexagon" src="image/B19777_01_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.256.1">Figure 1.7 – Framework hexagon</span></p>
<p><span class="koboSpan" id="kobo.257.1">Let’s </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.258.1">look at </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.259.1">this in </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">more detail.</span></span></p>
<h3><span class="koboSpan" id="kobo.261.1">Driving operations and input adapters</span></h3>
<p><span class="koboSpan" id="kobo.262.1">Driving operations are the ones that request actions from the software. </span><span class="koboSpan" id="kobo.262.2">It can be a user with a </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.263.1">command-line client or a </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.264.1">frontend application on behalf of the user, for example. </span><span class="koboSpan" id="kobo.264.2">There may be some testing suites checking the correctness of things exposed by your software. </span><span class="koboSpan" id="kobo.264.3">Or it could just be other applications in a large ecosystem needing </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.265.1">to interact with some exposed software features. </span><span class="koboSpan" id="kobo.265.2">This communication occurs through an </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">Application Programming Interface (API</span></strong><span class="koboSpan" id="kobo.267.1">) built on top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">input adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">This API defines how external entities will interact with your system and then translate their request to your domain’s application. </span><span class="koboSpan" id="kobo.269.2">The term </span><em class="italic"><span class="koboSpan" id="kobo.270.1">driving</span></em><span class="koboSpan" id="kobo.271.1"> is used because those external entities are driving the behavior of the system. </span><span class="koboSpan" id="kobo.271.2">Input adapters can define the application’s supported communication protocols, as </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.273.1"><img alt="Figure 1.8 – Driver operations and input adapters" src="image/B19777_01_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">Figure 1.8 – Driver operations and input adapters</span></p>
<p><span class="koboSpan" id="kobo.275.1">Suppose </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.276.1">you need to expose some </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.277.1">software features to legacy applications that work just with SOAP over HTTP/1.1 and, at the same time, need to make those same features available to new clients who could leverage the advantages of using gRPC over HTTP/2. </span><span class="koboSpan" id="kobo.277.2">With the hexagonal architecture, you could create an input adapter for both scenarios, with each adapter attached to the same input port, which would, in turn, translate the request downstream to work in terms of the domain. </span><span class="koboSpan" id="kobo.277.3">Here is an input adapter using a use case reference to call one of the input </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">port operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
public class RouterViewCLIAdapter {
    private RouterViewUseCase routerViewUseCase;
    public RouterViewCLIAdapter(){
        setAdapters();
    }
    public List&lt;Router&gt; obtainRelatedRouters(String type) {
        RelatedRoutersCommand relatedRoutersCommand =
           new RelatedRoutersCommand(type);
        return routerViewUseCase.getRelatedRouters
             (relatedRoutersCommand);
    }
    private void setAdapters(){
        this.routerViewUseCase = new  RouterViewInputPort
          (RouterViewFileAdapter.getInstance());
    }
}</span></pre> <p><span class="koboSpan" id="kobo.280.1">This example </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.281.1">illustrates the </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.282.1">creation of an input adapter that gets data from STDIN. </span><span class="koboSpan" id="kobo.282.2">Note the use of the input port through its use case interface. </span><span class="koboSpan" id="kobo.282.3">Here, we passed the command that encapsulates input data that’s used on the Application hexagon to deal with the Domain hexagon’s constraints. </span><span class="koboSpan" id="kobo.282.4">If we want to enable other communication forms in our system, such as REST, we just have to create a new REST adapter containing the dependencies to expose a REST communication endpoint. </span><span class="koboSpan" id="kobo.282.5">We will do this in the following chapters as we add more features to our </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">hexagonal application.</span></span></p>
<h3><span class="koboSpan" id="kobo.284.1">Driven operations and output adapters</span></h3>
<p><span class="koboSpan" id="kobo.285.1">On the other side of the coin, we have driven operations. </span><span class="koboSpan" id="kobo.285.2">These operations are triggered from your </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.286.1">application and go into the outside world to get data to fulfill the software’s needs. </span><span class="koboSpan" id="kobo.286.2">A driven operation generally occurs in </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.287.1">response to some driving one. </span><span class="koboSpan" id="kobo.287.2">As you can guess, the way we define the driven side is through output adapters. </span><span class="koboSpan" id="kobo.287.3">These adapters must conform to our output ports by implementing them. </span><span class="koboSpan" id="kobo.287.4">Remember, an output port tells the system what kind of data it needs to perform some application-specific task. </span><span class="koboSpan" id="kobo.287.5">It’s up to the output adapter to describe how it will get the data. </span><span class="koboSpan" id="kobo.287.6">Here is a diagram of output adapters and </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">driven operations:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.289.1"><img alt="Figure 1.9 – Driven operations and output adapters" src="image/B19777_01_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.290.1">Figure 1.9 – Driven operations and output adapters</span></p>
<p><span class="koboSpan" id="kobo.291.1">Suppose your application started working with Oracle relational databases and, after a while, you decided to change technologies and move on to a NoSQL approach, embracing MongoDB instead as your data source. </span><span class="koboSpan" id="kobo.291.2">In the beginning, you’d have just one output adapter to allow persistence with Oracle databases. </span><span class="koboSpan" id="kobo.291.3">To enable communication with MongoDB, you’d have to create an output adapter on the Framework hexagon, leaving the Application and, most importantly, Domain hexagons untouched. </span><span class="koboSpan" id="kobo.291.4">Because both input and output adapters are pointing inside the hexagon, we’re making them depend on both Application and Domain hexagons, hence inverting </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the dependency.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">The term </span><em class="italic"><span class="koboSpan" id="kobo.294.1">driven</span></em> <a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.295.1">is used because those operations are driven and controlled by the hexagonal application itself, triggering </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.296.1">action in other external systems. </span><span class="koboSpan" id="kobo.296.2">Note, in the following example, how the output adapter implements the output port interface to specify how the app</span><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.297.1">lication is going to obtain </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">external data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
public class RouterViewFileAdapter implements Router
  ViewOutputPort {
    @Override
    public List&lt;Router&gt; fetchRouters() {</span><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.300.1">
        return readFileAsString();
    }
    private static List&lt;Router&gt; readFileAsString() {
        List&lt;Router&gt; routers = new ArrayList&lt;&gt;();
        try (Stream&lt;String&gt; stream = new BufferedReader(
                new InputStreamReader(
                  Objects.requireNonNull(
                  RouterViewFileAdapter.class
                    .getClassLoader().
</span><span class="koboSpan" id="kobo.300.2">                  getResourceAsStream
                    ("routers.txt")))).lines()) {
            stream.forEach(line -&gt;{
            String[] routerEntry = line.split(";");
            var id = routerEntry[0];
            var type = routerEntry[1];
            Router router = new Router
                   (RouterType.valueOf(type)
                      ,RouterId.of(id));
                routers.add(router);
            });
        } catch (Exception e){
           e.printStackTrace();
        }
        return routers;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.301.1">The output </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.302.1">port states what data the application needs from outside. </span><span class="koboSpan" id="kobo.302.2">The output adapter in the previous example provides a specific </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.303.1">way to get that data through a </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">local file.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Having discussed the various hexagons in this architecture, we will now look at the advantages that this </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">approach brings.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.307.1">Advantages of the hexagonal approach</span></h2>
<p><span class="koboSpan" id="kobo.308.1">If you’re looking for a pattern to help you standardize the way software is developed at your company </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.309.1">or even in personal projects, hexagonal architecture can be used as the basis to create such standardization by influencing how classes, packages, and the code structure as a whole </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">are organized.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">In my experience of working on large projects with multiple vendors and bringing lots of new developers to contribute to the same code base, the hexagonal architecture helps the organization establish the foundational principles on which the software is structured. </span><span class="koboSpan" id="kobo.311.2">Whenever a developer switched projects, they had a shallow learning curve to understand how the software was structured because they were already acquainted with hexagonal principles they’d learned about in previous projects. </span><span class="koboSpan" id="kobo.311.3">This factor, in particular, is directly </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.312.1">related to the long-term benefits of software with a minor degree of </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">technical debt.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Applications with a high degree of maintainability that are easy to change and test are always welcomed. </span><span class="koboSpan" id="kobo.314.2">Let’s see next how hexagonal architecture helps us to obtain </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">such advantages.</span></span></p>
<h3><span class="koboSpan" id="kobo.316.1">Change-tolerant</span></h3>
<p><span class="koboSpan" id="kobo.317.1">Technology changes are happening at a swift pace. </span><span class="koboSpan" id="kobo.317.2">New programming languages and a myriad of </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.318.1">sophisticated tools are emerging every day. </span><span class="koboSpan" id="kobo.318.2">To beat the competition, very often, it’s not enough to just stick with well-established and time-tested technologies. </span><span class="koboSpan" id="kobo.318.3">The use of cutting-edge technology becomes no longer a choice but a necessity, and if the software is not prepared to accommodate such changes, the company risks losing money and time on big refactoring because the software architecture is </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">not change-tolerant.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">So, the port and adapter features of hexagonal architecture give us a strong advantage by providing the architectural principles to create applications that are ready to incorporate technological changes with </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">less friction.</span></span></p>
<h3><span class="koboSpan" id="kobo.322.1">Maintainability</span></h3>
<p><span class="koboSpan" id="kobo.323.1">If it’s necessary to change some business rule, we know that the only thing that should be changed </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.324.1">is the Domain hexagon. </span><span class="koboSpan" id="kobo.324.2">On the other hand, if we need to allow an existing feature to be triggered by a client that uses particular technology or protocol that is not yet supported by the application, we just need to create a new adapter, performing this change only on the </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">Framework hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">This separation of concerns seems simple, but when enforced as an architectural principle, it grants a degree of predictability that’s enough to decrease the mental overload of grasping the basic software structures before deep diving into its complexities. </span><span class="koboSpan" id="kobo.326.2">Time has always been a scarce resource, and if there’s a chance to save it through an architectural approach that removes some men</span><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.327.1">tal barriers, I think we should at least </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">try it.</span></span></p>
<h3><span class="koboSpan" id="kobo.329.1">Testability</span></h3>
<p><span class="koboSpan" id="kobo.330.1">One of the hexagonal architecture’s ultimate goals is to allow developers to test the application </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.331.1">when its external dependencies are not present, such as its UI and databases, as Alistair Cockburn stated. </span><span class="koboSpan" id="kobo.331.2">This does not mean, however, that this architecture ignores integration tests. </span><span class="koboSpan" id="kobo.331.3">Far from it – instead, it allows a more loosely coupled approach by giving us the required flexibility to test the most critical part of the code, even in the absence of dependencies such </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">as databases.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">By assessing each of the elements comprising the hexagonal architecture and being aware of the advantages such an architecture can bring to our projects, we’re now equipped with the fundamentals to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">hexagonal applications.</span></span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.335.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.336.1">In this chapter, we learned how important software architecture is in establishing the foundations to develop robust and high-quality applications. </span><span class="koboSpan" id="kobo.336.2">We looked at the pernicious nature of technical debt and how we can tackle it with sound software architecture. </span><span class="koboSpan" id="kobo.336.3">Finally, we got an overview of the hexagonal architecture’s core components and how they enable us to develop more change-tolerant, maintainable, and </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">testable software.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">With that knowledge, we’re now able to apply these hexagonal principles to build applications based on the proposed Domain, Application, and Framework hexagons, which will help us establish boundaries between business code and technology code, laying the ground for the development of complete </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">hexagonal systems.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">In the next chapter, we’re going to explore how to start developing a hexagonal application by looking at its most important part: the </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">Domain hexagon.</span></span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.342.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.343.1">What are the three hexagons that comprise the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">hexagonal architecture?</span></span></li>
<li><span class="koboSpan" id="kobo.345.1">What’s the role of the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">Domain hexagon?</span></span></li>
<li><span class="koboSpan" id="kobo.347.1">When should we utilize </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">use cases?</span></span></li>
<li><span class="koboSpan" id="kobo.349.1">Input and output adapters are present in </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">which hexagon?</span></span></li>
<li><span class="koboSpan" id="kobo.351.1">What’s the difference between driving and </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">driven operations?</span></span></li>
</ol>
<h1 id="_idParaDest-34"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.353.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.354.1">Get Your Hands Dirty on Clean Architecture </span></em><span class="koboSpan" id="kobo.355.1">(Hombergs , </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">2019)</span></span></li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.357.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.358.1">Domain, Application, </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">and Framework.</span></span></li>
<li><span class="koboSpan" id="kobo.360.1">It provides the business rules and data in the form of entities, value objects, and any other suitable categories of objects that help model the problem domain. </span><span class="koboSpan" id="kobo.360.2">It does not depend on any other hexagon </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">above it.</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">When we want to represent a system’s behavior through </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">application-specific operations.</span></span></li>
<li><span class="koboSpan" id="kobo.364.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">Framework hexagon.</span></span></li>
<li><span class="koboSpan" id="kobo.366.1">Driving operations are the ones that request actions from the software. </span><span class="koboSpan" id="kobo.366.2">Driven operations are started by the hexagonal application itself. </span><span class="koboSpan" id="kobo.366.3">These operations go outside the hexagonal application to fetch data from </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">external sources.</span></span></li>
</ol>
</div>
</body></html>