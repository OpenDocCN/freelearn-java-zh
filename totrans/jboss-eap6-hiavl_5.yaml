- en: Chapter 5. Load Balancing with mod_cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will have a look at another load balancer solution. It is
    called **mod_cluster** ([http://www.jboss.org/mod_cluster](http://www.jboss.org/mod_cluster)).
  prefs: []
  type: TYPE_NORMAL
- en: In comparison with JK, mod_cluster is more powerful and complex in design. Nevertheless,
    the added complexity in design doesn't mean it's harder to use; mod_cluster is
    designed to be scalable and can dynamically find the worker nodes so as to form
    a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Such kinds of flexibilities usually create confusion among newcomers and give
    them the impression that mod_cluster is harder to use. Thus, to appreciate the
    power of mod_cluster and its simplicity of usage, we must understand its design
    first.
  prefs: []
  type: TYPE_NORMAL
- en: The design of mod_cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the previous chapter, we know that JK uses a TCP port to communicate with
    the JBoss EAP6 server via AJP13 protocols. When compared with JK, mod_cluster
    uses the following three channels to serve its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: A **connector channel** supports the multiple protocols for the load balancer
    to proxy user requests to worker nodes. This part is almost synonymous with JK.
    The difference here is that besides the AJP13 protocol, mod_cluster also supports
    the HTTP/HTTPS protocols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **advertising channel** discovers worker nodes. This channel uses IP multicasting
    to transfer UDP datagrams. The load balancer will advertise itself in a multicast
    group, and the worker nodes will find it automatically by subscribing to this
    group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **management channel** is used to transfer status and management messages
    between the load balancer and the worker nodes. The protocol used by the management
    channel is an extension of the HTTP/1.1 protocol. The name of the protocol is
    **MCMP**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When compared with JK, mod_cluster can collect many runtime factors of a worker
    node to judge its "busy-ness", and it calculates a number that indicates the "busy-ness"
    of each worker node. This number is called a **load factor**, and the factors
    are called **metrics**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'mod_cluster provides us with multiple metrics to use, such as `SystemMemoryUsageLoadMetric`
    and `AverageSystemLoadMetric`. A complete list of metrics can be found here: [http://docs.jboss.org/mod_cluster/1.2.0/html/java.load.html](http://docs.jboss.org/mod_cluster/1.2.0/html/java.load.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The deployment of mod_cluster is divided into two parts: the first part is
    the load balancer, and the other part is the worker node. In our scenario, the
    load balancer is **httpd**, and mod_cluster provides a native component for it.
    On the worker node side, we are using JBoss EAP6, and mod_cluster provides a subsystem
    for it. To sum up, let''s have an overview of its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The design of mod_cluster](img/2432OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As per the preceding diagram, mod_cluster is divided into two parts: the load
    balancer side and the worker node side. In addition, it has the following three
    channels that form its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The **advertise** channel allows the load balancer to advertise itself, and
    the worker nodes can dynamically join or exit a cluster at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the **mod_manager** channel, the load balancer can get the load factor
    information from the worker node. The MCPM protocol is used in this channel, and
    the load factor, along with the rest of the information of the worker nodes, is
    sent at regular intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **mod_proxy_cluster** channel will forward user requests to the worker nodes
    from behind. It supports the AJP13 protocol similar to JK, and it supports HTTP/HTTPS
    additionally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this overview of the design of mod_cluster, we will learn how to install
    mod_cluster in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing mod_cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to compile mod_cluster from the source code
    and install it on our load balancer machine. The machine I'm using to install
    mod_cluster and httpd is called *lb*, which is the same machine used in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have learned how to compile and install httpd in the previous chapter, and
    we have put a lot of JK-related configurations in our httpd installation. To make
    the instructions in this chapter clearer, let''s archive the following httpd installation
    from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll need to use it in the next chapter, so please back it up properly. Our
    next step is to repeat the httpd compiling and installing processes as we have
    done in the previous chapter. We actually just need to rerun `make install` in
    the httpd source directory because we have already configured and compiled it
    properly, and we will get a fresh httpd installation by running this command.
    Now let's move on with the mod_cluster installation.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading mod_cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to download mod_cluster. The source code of mod_cluster is hosted
    at GitHub. We will use Version 1.2.6.Final in this book: [https://github.com/modcluster/mod_cluster/archive/1.2.6.Final.zip](https://github.com/modcluster/mod_cluster/archive/1.2.6.Final.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download it and extract the zip file, and you will get the source directory
    `mod_cluster-1.2.6.Final`. The following are its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading mod_cluster](img/2432OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the source directory, we can see that mod_cluster contains several components,
    but we only need to care about the components in the `native` directory. The other
    Java modules are for the worker node. Since EAP6 already contains the mod_cluster
    subsystem out of the box, we don''t need to compile them. Now let''s have a look
    at the `native` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading mod_cluster](img/2432OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may have guessed the purposes of some components by their names; let''s
    still check them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '| advertise | The advertising module for the supporting autodiscovery worker
    node |'
  prefs: []
  type: TYPE_TB
- en: '| mod_proxy_cluster | The proxy module that supports the AJP/HTTP/HTTPS proxy
    requests. |'
  prefs: []
  type: TYPE_TB
- en: '| mod_manager | The mod_cluster manager module that controls the worker node
    and gets load factors from the worker node. |'
  prefs: []
  type: TYPE_TB
- en: '| mod_slotmem | The shared memory module used by mod_cluster internally. |'
  prefs: []
  type: TYPE_TB
- en: '| selinux | The SElinux policy files. We won''t cover this topic in the book.
    |'
  prefs: []
  type: TYPE_TB
- en: '| include | Common header files. |'
  prefs: []
  type: TYPE_TB
- en: '| scripts | Some installation scripts we won''t use. |'
  prefs: []
  type: TYPE_TB
- en: As we have understood the meaning of these components, it's now time to build
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and installing mod_cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The modules that we need to build are advertise, mod_proxy_cluster, mod_manager,
    and mod_slotmem. It doesn''t matter which module you build first; let''s start
    with `advertise`. We need to find a script called `buildconf` in the directory
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It will create a script called `configure`. Then we need to run the this script
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used the `--with-apxs` option to tell mod_cluster the position of httpd.
    After the configuring process is complete, please run the `make` command, and
    we will get the following shared library named `mod_advertise.so`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling and installing mod_cluster](img/2432OS_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the preceding library is built, let''s move it to the httpd `modules`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is all that we need to do for compiling and installing `advertise`. Go
    to the directories of the other three modules, and use the same procedure to build
    them one by one. We'll get `mod_proxy_cluster.so`, `mod_manager.so`, and `mod_slotmem.so`.
    Please move all of them to the httpd `modules` directory.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the mod_cluster components we need to install. In the following
    section, we will configure httpd to use these modules.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring mod_cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After installing the necessary mod_cluster components in httpd, we will configure
    them properly in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring httpd.conf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start to configure mod_cluster, we need to do some preparations in
    `httpd.conf`. The first thing to do is to change the `Listen` directive from `Listen
    80` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, *lb* has two IP addresses: one is the public address 172.16.123.1,
    and the other is 10.0.1.33, which is the internal IP address of the load balancer
    used to communicate with the two EAP6 servers. Now let''s learn the purpose of
    the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10.0.1.33:80` will be used for a mod_cluster management console. We don''t
    want public access of this management console, so we just bind it to the local
    IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10.0.1.33:6666` will be used by mod_manager to communicate with the EAP6 servers,
    and the message encapsulated in the MCPM protocol will be transferred through
    this channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`172.16.123.1:80` is the public address that serves user requests. If you don''t
    have a separate public IP address, you can just use your local IP address to serve
    all the requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After configuring the listening addresses, the next step is to configure the
    `LogLevel`. We need to change the log level to `debug`; the following is the configuration
    for doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We need the debug log output later. We will now go to the `ServerName` section
    and add the hostname of our load balancer. We are using `lb` as the hostname,
    so the configuration is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And please don''t forget to bind this server name to the public IP address
    in `/etc/hosts`. Next, we need to add an `Include` directive at the bottom of
    `httpd.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to do in `httpd.conf`. In the next section, we'll create
    a separate configuration file for mod_cluster in the `conf.d` directory
  prefs: []
  type: TYPE_NORMAL
- en: Configuring mod_cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s create a directory named `conf.d` in httpd:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to create a file called `mod-cluster.conf` in the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Due to the `Include conf.d/*.conf` directive in `httpd.conf`, the created configuration
    file will be loaded during httpd startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the contents to this file. First, we need to load the following
    modules of mod_cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that mod_cluster relies on some of the already configured modules in `httpd.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding modules have already been loaded in `httpd.conf`. Please note
    that the `proxy-balancer` module is disabled in httpd because it conflicts with
    mod_cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to define two virtual hosts: one is for the web management console,
    and the other is for the management module to send/receive MCPM messages. Let''s
    go through them one at a time. Here''s the configuration for the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous virtual host definition, we have defined a location called
    `/mc` and bound it to `mod_cluster-manager`. This handler will provide us with
    a web-based management console, which we''ll use in the later sections. Now let''s
    check the second virtual host definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important directives in the preceding settings. One is the `ServerAdvertise`
    directive. The address set in this directive will be advertised by mod_cluster
    in the multicast group. For example, our setting is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, mod_cluster will broadcast it in a multicast group by saying something
    to this effect: "My MCPM management channel is located at http://10.0.1.32:6666,
    come and join me!". The worker nodes that are subscribed to the multicast group
    will receive this information and can then join the cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that we don''t need to configure the multicast address for advertising.
    This is because the default address for advertising is 224.0.1.105:23364, which
    matches the default settings in EAP6\. We''ll see this in the next section. If
    you want to change this setting, you can use the `AdvertiseGroup` directive by
    placing it under the `ServerAdvertise` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can always check the online document for mod_cluster to learn about these
    detail configurations: ([http://docs.jboss.org/mod_cluster/1.2.0/html/native.config.html](http://docs.jboss.org/mod_cluster/1.2.0/html/native.config.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the following directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding directive, the virtual host 10.0.1.32:6666 is used as a management
    channel, and MCPM is used as the communication protocol for this channel. This
    is all we need to do in `mod-cluster.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring EAP6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now, we haven't looked at the `modcluster` subsystem configuration in
    EAP6\. Since the default configuration provided by the EAP6 domain mode is good
    to use, we don't need to change anything. Let's have a look at the configuration
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the configuration in `domain.xml`, we can see the following default settings
    of the `modcluster` subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `modcluster` subsystem is bound to the advertising socket
    named `modcluster` by the `advertising-socket` directive. Then we see that the
    `modcluster` subsystem is using the `busyness` metric by default. It is a metric
    that judges the server "busy-ness" from the working threads. Now let''s see the
    settings of the socket-binding `modcluster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding configuration, we can see that `224.0.1.1.105:23364` is the
    default multicast group address for advertising. This matches the settings on
    the httpd side.
  prefs: []
  type: TYPE_NORMAL
- en: These settings are of the `modcluster` subsystem in EAP6\. As we have gone through
    the settings of mod_cluster from both sides, in the following section we will
    test the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we'll test our cluster, so we need to start our load balancer
    and EAP6 servers. Before we start httpd on `lb`, we need to start the two EAP6
    servers. After the two EAP6 servers have been started, start httpd. In the following
    section, we'll examine the process of starting up httpd.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up httpd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to start the httpd server. If everything goes fine, mod_cluster
    in httpd will begin to advertise itself in a multicast group, and the `modcluster`
    subsystem in the two EAP6 servers will be able to find mod_cluster in httpd by
    fetching its address in the advertising channel. We will investigate this process
    in the following sections; let''s first start httpd. The command to start httpd
    on `lb` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After httpd has been started, mod_cluster will advertise itself to the multicast
    group 224.0.1.105:23364, and the `modcluster` subsystem on the two EAP6 servers
    will fetch the address of the management channel from the group, which is 10.0.1.32:6666\.
    Then the load balancers and the two EAP6 worker nodes will form a cluster by communicating
    in the management channel with the MCPM protocol. This process is shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting up httpd](img/2432OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To understand these steps, we need to analyze the packets sent across the network.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use Wireshark to capture the IP datagrams from one of the worker nodes.
    In my example I'll run Wireshark on `master`. We can verify the advertising message
    sent by the load balancer on this machine.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a small Java program that allows us to join the multicast group
    and receive the httpd advertisement. See this program at [https://github.com/mod_cluster/mod_cluster/blob/master/test/java/Advertize.java](https://github.com/mod_cluster/mod_cluster/blob/master/test/java/Advertize.java).
  prefs: []
  type: TYPE_NORMAL
- en: The advertising channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I have started Wireshark on `master` to capture the IP datagrams. I set it
    to catch all the datagrams on 224.0.1.105:23364, and the following are my findings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The advertising channel](img/2432OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that `master` is receiving the advertising
    messages periodically. From the **Time** column, we can see that the advertising
    message is sent at 10-second intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can change this by placing the `AdvertiseFrequency` directive into `conf.d/mod-cluster.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the advertising message is in HTTP format. The following are
    the details of the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the previous code, the advertising message places the load balancer
    information in the HTTP headers. Among these headers, we should note the value
    of `X-Manager-Address`. It tells the worker nodes where to find the load balancer.
    The other headers provide additional information to the worker nodes; this information
    describes the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: The management channel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the worker node comes to know the management address of the load balancer,
    it will communicate with the load balancer and register itself on it. To see this
    process, we need to look into the httpd log. As we have set the `LogLevel` to
    `debug` in `httpd.conf`, we can get many useful details. mod_cluster has outputted
    a lot of useful log information in the debug level, so we can check `logs/error_log`
    to see the sequence clearly. Here is the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`INFO` is the first MCMP command we''ve seen till now. This is the command
    that the worker node uses to request more details of the load balancer. As mod_cluster
    forms the cluster dynamically, it doesn''t know the details of the cluster in
    advance. The load balancer and worker node just discover each other in the multicast
    channel, so the worker node needs to know more detailed information about the
    load balancer. That''s why the worker node will send the `INFO` request to the
    load balancer, and the load balancer will reply with an `INFO-RSP` response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After the worker node gets the details of the load balancer, it will send to
    the load balancer a `CONFIG` message that tells the load balancer the previous
    worker node details. The `JVMRoute` is the worker node's name; this is automatically
    generated by the mod_cluster subsystem in EAP6\. Now we know the server `14a0af8b-59dd-33f9-8233-1f2584fefa67`
    corresponds to the server `10.0.1.19`, which is our slave EAP6 server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The worker node sends `ENABLE-APP` to the load balancer. This is used by the
    worker node to ask the load balancer to route the request corresponding to the
    context and the `Alias` value to the node defined by `JVMRoute`. In addition,
    we see the enabled application is `cluster-demo1`. So if we access the load balancer
    URL with the route `/cluster-demo1`, the request will be forwarded to the EAP6
    servers. Now let''s see the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The worker node sends the `STATUS` message, which contains its current load
    factor. From line two of the previous log, we can see that the load factor of
    the slave EAP6 server is `100` (the smaller the factor number, the busier the
    server is). This message is sent periodically, and the load factor is refreshed
    to reflect the real-time status of the worker node. So the load balancer could
    know which server is busier and send this request to the worker nodes that have
    a lighter load.
  prefs: []
  type: TYPE_NORMAL
- en: With the previous process, the worker node and load balancer have gathered enough
    information about each other and established communication. Then the `mod_proxy_cluster.so`
    cluster will start to do the real proxy job. In the following section, we will
    check this part.
  prefs: []
  type: TYPE_NORMAL
- en: The connector channel analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how the load balancer advertises itself and
    how the worker node discovers it and registers itself into the cluster. Now let''s
    go on to check the `error_log` and see what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As per the preceding log, mod_cluster has established a connection with `ajp://10.0.1.19:8259`.
    This is the AJP connector of the EAP6 server on the slave host. We can see that
    mod_cluster has set a name for our cluster, which is `mycluster`. We can check
    the status of this cluster from the management console. Let's access the management
    console through its URL, `http://10.0.1.32/mc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The connector channel analysis](img/2432OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we can see that the two EAP6 servers form a
    cluster, and they all belong to `mycluster`. If you want to change the name of
    the balancer name, you can use the `ManagerBalancerName` directive in `mod-cluster.conf`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the previous configuration, the balancer name is set to `packtlb`. Now
    if we save the changes and restart httpd, we can see the balancer name change
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is useful when there are multiple load balancers running at the same time.
    With the balancer name, we can easily see which worker node belongs to which load
    balancer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s come back to the debug log; here is the last part we need to look
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After the AJP channels are established, mod_cluster from the httpd side will
    send `ajp_cping_cpong` messages to the EAP6 worker nodes periodically to check
    whether the nodes are still alive.
  prefs: []
  type: TYPE_NORMAL
- en: As we have done the protocol analysis, in the following section we'll access
    the cluster to see if it works properly.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can access the load balancer using its URL: `http://lb/cluster-demo1/index.jsp`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By checking the two EAP6 servers output, we can see that the request is dispatched
    to `master`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we check the mod_cluster management console, we can see that the master
    server has been elected once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the cluster](img/2432OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, the **Elected** count becomes **1**
    for the master server.
  prefs: []
  type: TYPE_NORMAL
- en: Failover
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s kill the master server by pressing the *Ctrl* + *C* keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'From the slave server, we can see that it starts to throw the following exception
    because it cannot connect to the master server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is expected because we have killed the master server. But it can still
    function as a server. Now let''s access the load balancer again; we can see that
    the following request is dispatched to the slave server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s access the mod_cluster management console, and we can see that the
    master server is removed automatically. In addition, the **Elected** count of
    the slave server becomes **1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Failover](img/2432OS_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s restart the EAP6 server on the master server, and it will rejoin
    the cluster. From the httpd debug log output, we can confirm this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'From the slave server output, we can see that it also restores the connection
    to the domain controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Stress testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s try to use the Apache HTTP server benchmarking tool (called **ab**)
    to load test our cluster. Here is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used `15` threads to request our cluster `1500` times. Here are the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that ab created some load on mod_cluster. Here are the statuses
    of the two worker nodes during testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stress testing](img/2432OS_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot depicts the status of the master server, and the status
    of the slave server is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stress testing](img/2432OS_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that both the worker nodes are elected (the elected counts are more
    than 1,500 because I've run the preceding tests many times). We can also see that
    the **Load** factor on slave became **99**. This means the slave server is busier
    than the master server, so the load balancer will dispatch more requests to the
    master server later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have looked at the design of mod_cluster and its usages.
    This chapter is just an introductory text to mod_cluster. If you want to check
    the more advanced usage, please refer to its constantly improving online document:
    [http://docs.jboss.org/mod_cluster/1.2.0/html_single/](http://docs.jboss.org/mod_cluster/1.2.0/html_single/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have any questions about using mod_cluster, you can always ask questions
    on the JBoss forum: [https://community.jboss.org/en/mod_cluster/content](https://community.jboss.org/en/mod_cluster/content).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see how to apply **Secure Sockets Layer** (**SSL**)
    in a clustering environment.
  prefs: []
  type: TYPE_NORMAL
