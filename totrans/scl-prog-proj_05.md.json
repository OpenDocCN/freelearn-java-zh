["```java\ntrait Combine[A] {\n  def combine(x: A, y: A): A\n}\n```", "```java\nobject Combine {\n  def apply[A](implicit combineA: Combine[A]): Combine[A] = combineA\n\n  implicit val combineInt: Combine[Int] = new Combine[Int] {\n    override def combine(x: Int, y: Int): Int = x + y\n  }\n\n  implicit val combineString: Combine[String] = new Combine[String] {\n    override def combine(x: String, y: String) = x + y\n  }\n}\n```", "```java\nCombine[Int].combine(1, 2)\n// res0: Int = 3\nCombine[String].combine(\"Hello\", \" type class\")\n// res1: String = Hello type class\n\n```", "```java\nobject Combine {\n...\n  implicit class CombineOps[A](val x: A)(implicit combineA: Combine[A]) {\n    def combine(y: A): A = combineA.combine(x, y)\n  }\n}\n```", "```java\n2.combine(3)\n// res2: Int = 5\n\"abc\" combine \"def\"\n// res3: String = abcdef\n```", "```java\nobject Combine {\n...\n  implicit def combineOption[A](implicit combineA: Combine[A])\n  : Combine[Option[A]] = new Combine[Option[A]] {\n    override def combine(optX: Option[A], optY: Option[A]): Option[A] =\n      for {\n        x <- optX\n        y <- optY\n      } yield combineA.combine(x, y)\n  }\n}\n```", "```java\nimplicit def combineOption[A: Combine]: Combine[Option[A]] = new Combine[Option[A]] {\n  override def combine(optX: Option[A], optY: Option[A]): Option[A] =\n    for {\n      x <- optX\n      y <- optY\n    } yield Combine[A].combine(x, y)\n}\n```", "```java\nOption(3).combine(Option(4))\n// res4: Option[Int] = Some(7)\nOption(3) combine Option.empty\n// res5: Option[Int] = None\nOption(\"Hello \") combine Option(\" world\")\n// res6: Option[String] = Some(Hello  world)\n```", "```java\nVector(1,3,2).sorted\n// res0: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)\n```", "```java\ndef sorted[B >: A](implicit ord: Ordering[B]): Repr\n```", "```java\nimport java.time.LocalDate\nimplicit val dateOrdering: Ordering[LocalDate] =   \n  Ordering.fromLessThan[LocalDate](_ isBefore _)\nimport Ordering.Implicits._\nLocalDate.of(2018, 5, 18) < LocalDate.of(2017, 1, 1)\n// res1: Boolean = false\nVector(\n  LocalDate.of(2018, 5, 18), \n  LocalDate.of(2018, 6, 1)\n).sorted(dateOrdering.reverse)\n// res2: Vector[LocalDate] = Vector(2018-06-01, 2018-05-18)\n```", "```java\nactual shouldBe expected\nactual should === (expected)\n```", "```java\nclass EqualitySpec extends WordSpec with Matchers with TypeCheckedTripleEquals{\n  \"Equality\" should {\n    \"allow to compare two Doubles with a tolerance\" in {\n      1.6 + 1.8 should === (3.4)\n    }\n  }\n}\n```", "```java\n3.4000000000000004 did not equal 3.4\n```", "```java\nclass EqualitySpec extends WordSpec with Matchers with \n TypeCheckedTripleEquals{\n  implicit val doubleEquality: Equality[Double] = \n  TolerantNumerics.tolerantDoubleEquality(0.0001)\n  \"Equality\" should {...}\n```", "```java\nclass EqualitySpec extends WordSpec with Matchers with TypeCheckedTripleEquals{\n  implicit val doubleEquality: Equality[Double] = \n  TolerantNumerics.tolerantDoubleEquality(0.0001)\n  implicit def vectorEquality[A](implicit eqA: Equality[A]):   \n  Equality[Vector[A]] = ???\n```", "```java\n\"Equality\" should {\n  (...)\n  \"allow to compare two Vector[Double] with a tolerance\" in {\n    Vector(1.6 + 1.8, 0.0051) should === (Vector(3.4, 0.0052))\n  }\n}\n```", "```java\n/**\n * A semigroup is any set `A` with an associative operation (`combine`).\n */\ntrait Semigroup[@sp(Int, Long, Float, Double) A] extends Any with Serializable {\n  /**\n   * Associative operation taking which combines two values.\n   */\n  def combine(x: A, y: A): A\n(...)\n}\n```", "```java\na combine (b combine c) = (a combine b) combine c\n```", "```java\nimport cats.implicits._\n1 |+| 2\n// res0: Int = 3\n\"Hello \" |+| \"World !\"\n// res1: String = Hello World !\n(1, 2, \"Hello \") |+| (2, 4, \"World !\")\n// res2: (Int, Int, String) = (3,6,Hello World !)\n```", "```java\nVector(1, 2) |+| Vector(3, 4)\n// res3: Vector[Int] = Vector(1, 2, 3, 4)\nOption(1) |+| Option(2)\n// res4: Option[Int] = Some(3)\nOption(1) |+|  None |+| Option(2)\n// res5: Option[Int] = Some(3)\n```", "```java\n1.asRight |+| 2.asRight\n// res6: Either[B,Int] = Right(3)\n1.asRight[String] |+| 2.asRight |+| \"error\".asLeft\n// res7: Either[String,Int] = Left(error)\n\"error1\".asLeft[Int] |+| \"error2\".asLeft\n// res8: Either[String,Int] = Left(error1)\n```", "```java\ntrait Monoid[@sp(Int, Long, Float, Double) A] extends Any with Semigroup[A] {\n  /**\n   * Return the identity element for this monoid.\n   */\n  def empty: A\n```", "```java\nimport cats.implicits._\nimport cats.kernel.Monoid\nMonoid[Int].empty\n// res0: Int = 0\nMonoid[String].empty\n// res1: String = \nMonoid[Option[Double]].empty\n// res2: Option[Double] = None\nMonoid[Vector[Int]].empty\n// res2: Vector[Int] = Vector()\nMonoid[Either[String, Int]].empty\n// res4: Either[String,Int] = Right(0)\n```", "```java\n(3 |+| Monoid[Int].empty) == 3\n(\"Hello identity\" |+| Monoid[String].empty) == \"Hello identity\"\n(Option(3) |+| Monoid[Option[Int]].empty) == Option(3)\n```", "```java\nVector(1,2,3).combineAll\n// res8: Int = 6\n```", "```java\nVector(1, 2, 3).foldLeft(0) { case (acc, i) => acc + i }\n```", "```java\nVector(\"1\", \"2\", \"3\").foldMap(s => (s, s.toInt))\n// res10: (String, Int) = (123,6)\n```", "```java\ndef map: Vector[Int] => (Int => Int) => Vector[Int] = \n                                        xs => f => xs.map(f)\n```", "```java\ntrait Functor[F[_]] {\n  def map[A, B](fa: F[A])(f: A => B): F[B]\n```", "```java\nimport cats.Functor\nimport cats.implicits._\ndef addOne[F[_] : Functor](fa: F[Int]): F[Int] = fa.map(_ + 1)\n```", "```java\naddOne(Vector(1, 2, 3))\n// res0: Vector[Int] = Vector(2, 3, 4)\naddOne(Option(1))\n// res1: Option[Int] = Some(2)\naddOne(1.asRight)\n// res2: Either[Nothing,Int] = Right(2)\n```", "```java\ndef square(x: Double): Double = x * x\ndef squareVector: Vector[Double] => Vector[Double] =\n  Functor[Vector].lift(square)\n  squareVector(Vector(1, 2, 3))\n// res0: Vector[Double] = Vector(1.0, 4.0, 9.0)\ndef squareOption: Option[Double] => Option[Double] =\n  Functor[Option].lift(square)\n  squareOption(Some(3))\n// res1: Option[Double] = Some(9.0)\n```", "```java\nVector(\"Functors\", \"are\", \"great\").fproduct(_.length).toMap \n//res2: Map[String,Int] = Map(Functors -> 8, are -> 3, great -> 5)\n```", "```java\ntrait Apply[F[_]] extends Functor[F] {\n  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]\n  /** Alias for [[ap]]. */\n  @inline final def <*>[A, B](ff: F[A => B])(fa: F[A]): F[B] =\n  ap(ff)(fa)\n```", "```java\nimport cats.implicits._\n\nOption[String => String](\"Hello \" + _).ap(Some(\"Apply\"))\n// res0: Option[String] = Some(Hello Apply)\nOption[String => String](\"Hello \" + _) <*> None\n// res1: Option[String] = None\nOption.empty[String => String] <*> Some(\"Apply\")\n// res2: Option[String] = None\n```", "```java\ndef addOne: Int => Int = _ + 1 \ndef multByTwo: Int => Int = _ * 2 \nVector(addOne, multByTwo) <*> Vector(1, 2, 3) \n// res3: Vector[Int] = Vector(2, 3, 4, 2, 4, 6)\n```", "```java\n(fa product (fb product fc)) ==\n  ((fa product fb) product fc).map { \n     case ((a, b), c) => (a, (b,c))\n    }\n```", "```java\n(fbc <*> (fab <*> fa)) == ((fbc.map(_.compose[A] _) <*> fab) <*> fa)\n```", "```java\ntrait Apply[F[_]] extends Functor[F] â€¦ {\n  (...)\n  def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) => Z): F[Z] =\n    map(product(fa, fb))(f.tupled)\n    override def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =\n    ap(map(fa)(a => (b: B) => (a, b)))(fb)\n```", "```java\ndef parseIntO(s: String): Option[Int] = Either.catchNonFatal(s.toInt).toOption\nparseIntO(\"6\").map2(parseIntO(\"2\"))(_ / _)\n// res4: Option[Int] = Some(3)\nparseIntO(\"abc\").map2(parseIntO(\"def\"))(_ / _)\n// res5: Option[Int] = None\n```", "```java\ndef parseIntE(s: String): Either[Throwable, Int] = Either.catchNonFatal(s.toInt)\nparseIntE(\"6\").map2(parseIntE(\"2\"))(_ / _)\n// res6: Either[Throwable,Int] = Right(3)\nparseIntE(\"abc\").map2(parseIntE(\"3\"))(_ / _)\n// res7: Either[Throwable,Int] = Left(java.lang.NumberFormatException: For input string: \"abc\")\n```", "```java\n(parseIntE(\"1\"), parseIntE(\"2\"), parseIntE(\"3\")).mapN( (a,b,c) => a + b + c)\n// res8: Either[Throwable,Int] = Right(6)\n```", "```java\nimport cats.data.ValidatedNel\ndef parseIntV(s: String): ValidatedNel[Throwable, Int] = Validated.catchNonFatal(s.toInt).toValidatedNel\n(parseIntV(\"abc\"), parseIntV(\"def\"), parseIntV(\"3\")).mapN( (a,b,c) => a + b + c)\n// res9: ValidatedNel[Throwable,Int] = Invalid(NonEmptyList(\n// java.lang.NumberFormatException: For input string: \"abc\", \n// java.lang.NumberFormatException: For input string: \"def\")\n```", "```java\n@typeclass trait Applicative[F[_]] extends Apply[F] { \n  def pure[A](x: A): F[A]\n}\n```", "```java\nimport cats.Applicative\nimport cats.data.{Validated, ValidatedNel}\nimport cats.implicits._\n\nApplicative[Option].pure(1)\n// res0: Option[Int] = Some(1)\n3.pure[Option]\n// res1: Option[Int] = Some(3)\ntype Result[A] = ValidatedNel[Throwable, A]\nApplicative[Result].pure(\"hi pure\")\n// res2: Result[String] = Valid(hi pure)\n\"hi pure\".pure[Result]\n// res3: Result[String] = Valid(hi pure)\n```", "```java\n    ((identity[A] _).pure[F] <*> fa)  ==  fa\n    ```", "```java\n    (fbc <*> (fab <*> fa)) == ((fbc.map(_.compose[A] _) <*> fab) <*> fa)\n    ```", "```java\n    Applicative[F].pure(f) <*> Applicative[F].pure(a) == Applicative[F].pure(f(a))\n    ```", "```java\n    fab <*> Applicative[F].pure(a) == \n      Applicative[F].pure((f: A => B) => f(a)) <*> fab\n    ```", "```java\n@typeclass trait Traverse[F[_]] extends Functor[F] with Foldable[F] with UnorderedTraverse[F] { self =>\n  def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): \n  G[F[B]]\n  (...)\n}\n```", "```java\nimport cats.implicits._\ndef parseIntO(s: String): Option[Int] =\n  Either.catchNonFatal(s.toInt).toOption\nVector(\"1\", \"2\" , \"3\").traverse(parseIntO)\n// res5: Option[Vector[Int]] = Some(Vector(1, 2, 3))\nVector(\"1\", \"boom\" , \"3\").traverse(parseIntO)\n// res6: Option[Vector[Int]] = None\n```", "```java\nimport cats.data.{Validated, ValidatedNel}\ndef parseIntV(s: String): ValidatedNel[Throwable, Int] = Validated.catchNonFatal(s.toInt).toValidatedNel\n\nVector(\"1\", \"2\" , \"3\").traverse(parseIntV)\n// res7: ValidatedNel[Throwable, Vector[Int]] = Valid(Vector(1, 2, 3))\nVector(\"1\", \"boom\" , \"crash\").traverse(parseIntV)\n// res8: ValidatedNel[Throwable, Vector[Int]] = \n// Invalid(NonEmptyList(\n//   NumberFormatException: For input string: \"boom\", \n//   NumberFormatException: For input string: \"crash\"))\n```", "```java\ndef sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]] =\n  traverse(fga)(ga => ga)\n```", "```java\nval vecOpt: Vector[Option[Int]] = Vector(Option(1), Option(2), Option(3))\nval optVec: Option[Vector[Int]] = vecOpt.sequence\n// optVec: Option[Vector[Int]] = Some(Vector(1, 2, 3))\n```", "```java\nimport scala.concurrent._\nimport ExecutionContext.Implicits.global\nimport duration.Duration\n\nval vecFut: Vector[Future[Int]] = Vector(Future(1), Future(2), Future(3))\nval futVec: Future[Vector[Int]] = vecFut.sequence\n\nAwait.result(futVec, Duration.Inf)\n// res9: Vector[Int] = Vector(1, 2, 3)\n```", "```java\n@typeclass trait Monad[F[_]] extends FlatMap[F] with Applicative[F]@typeclass trait FlatMap[F[_]] extends Apply[F] {\n  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]\n}\n```", "```java\n((fa flatMap f) flatMap g) == (fa flatMap(f(_) flatMap g))\n```", "```java\nMonad[F].pure(a).flatMap(f) == f(a)\n```", "```java\nfa.flatMap(Monad[F].pure) == fa\n```", "```java\nimport cats.{Id, Monad}\nimport cats.implicits._\n\ncase class Item(id: Int, label: String, price: Double, category: String)\n\ntrait ItemApi[F[_]] {\n def findAllItems: F[Vector[Item]]\n def saveItem(item: Item): F[Unit]\n}\n```", "```java\ndef startSalesSeason[F[_] : Monad](api: ItemApi[F]): F[Unit] = {\n  for {\n    items <- api.findAllItems\n    _ <- items.traverse { item =>\n      val discount = if (item.category == \"shoes\") 0.80 else 0.70\n      val discountedItem = item.copy(price = item.price * discount)\n      api.saveItem(discountedItem)\n    }\n  } yield ()\n}\n```", "```java\nOption(1) &#124;+&#124;  None &#124;+&#124; Option(2)\n// res5: Option[Int] = Some(3)\n```", "```java\nVector(1,2,3).combineAll\n// res8: Int = 6\n```", "```java\nVector(\"1\", \"2\", \"3\").foldMap(s => (s,s.toInt))\n// res10: (String, Int) = (123,6)\n```", "```java\ndef square(x: Double): Double = x * x\ndef squareVector: \n  Vector[Double] => Vector[Double] =\n    Functor[Vector].lift(square)\nsquareVector(Vector(1, 2, 3))\n// res0: Vector[Double] = Vector(1.0, 4.0, 9.0)\n```", "```java\nVector(\"Functors\", \"are\", \"great\")\n  .fproduct(_.length)\n  .toMap\n// res2: Map[String,Int] = Map(Functors -> 8, //are -> 3, great -> 5)\n```", "```java\nOption[String => String]\n    (\"Hello \" + _).ap(Some(\"Apply\"))\n// res0: Option[String] = Some(Hello Apply)\nOption[String => String](\"Hello \" + _) <*> None\n// res1: Option[String] = None\n```", "```java\ndef addOne: Int => Int = _ + 1\ndef multByTwo: Int => Int = _ * 2\nVector(addOne, multByTwo) <*> Vector(1, 2, 3)\n// res3: Vector[Int] = Vector(2, 3, 4, 2, 4, 6)\n```", "```java\nimport cats.data.{Validated, ValidatedNel}\ndef parseIntV(s: String): ValidatedNel[Throwable, Int] = Validated.catchNonFatal(s.toInt).toValidatedNel\n\nVector(\"1\", \"2\" , \"3\").traverse(parseIntV)\n// res7: ValidatedNel[Throwable, Vector[Int]] = Valid(Vector(1, 2, 3))\nVector(\"1\", \"boom\" , \"crash\")\n  .traverse(parseIntV)\n// res8: ValidatedNel[Throwable, Vector[Int]] = \n// Invalid(NonEmptyList(\n//   NumberFormatException: For input string: \"boom\", \n//   NumberFormatException: For input string: \"crash\"))\n```", "```java\nimport cats.{Id, Monad}\nimport cats.implicits._\ncase class Item(id: Int,\n  label: String,\n  price: Double,\n  category: String)\ntrait ItemApi[F[_]] {\n  def findAllItems: F[Vector[Item]]\n  def saveItem(item: Item): F[Unit]\n}\ndef startSalesSeason[F[_] : Monad](\n  api: ItemApi[F]): F[Unit] = {\n  for {\n    items <- api.findAllItems\n    _ <- items.traverse { item =>\n    val discount = if (item.category ==\n      \"shoes\") 0.80 else 0.70\n    val discountedItem = item.copy(price =\n      item.price * discount)\n    api.saveItem(discountedItem)\n  }} yield ()\n}\n```"]