- en: Chapter 2. Cameras and Game Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable character control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching an input AppState object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing in FPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing non-instant bullets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an RTS camera AppState object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting units in RTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the camera follow units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following a character with ChaseCamera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a game controller and joystick input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leaning around corners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting cover automatically in a third-person game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about controlling avatars and cameras for various game types.
    Whether your game is a **first person shooter** (**FPS**), **role playing game**
    (**RPG**), or **real-time strategy** (**RTS**) game, you'll learn some tricks
    that will help you get past tricky obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter will rely heavily on the `ActionListener` and `AnalogListener` interfaces.
    These are essential when listening for the player input in jMonkeyEngine. The
    `ActionListener` interface will pick up any binary input such as keyboard keys
    or mouse buttons. The `AnalogListener` interface listens for mouse and joystick
    movements and other input that is either on or off.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable character control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start off the chapter, we will create a class that we can use for various
    character-controlled purposes. The example describes an FPS character, but the
    method is the same for any player-controlled character.
  prefs: []
  type: TYPE_NORMAL
- en: The `Control` class we'll build will be based on `BetterCharacterControl`. It
    might be a good idea to have a look at the class or the `TestBetterCharacter`
    example from the jMonkeyEngine test package if you want to find out how this works.
    Another good starting point would be the input examples from the same package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BetterCharacterControl` class is based on physics and requires a `BulletAppState`
    class to be set up in the application. The steps required to do this are described
    in the *The ImageGenerator class* section in [Appendix](apa.html "Appendix A. Information
    Fragments"), *Information Fragments*. To find out more about bullet and physics,
    refer to [Chapter 8](ch08.html "Chapter 8. Physics with Bullet"), *Physics with
    Bullet*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following set of steps to create a reusable character control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new class called `GameCharacterControl`, which extends
    `BetterCharacterControl`. This class also needs to implement `ActionListener`
    and `AnalogListener`. The idea here is to feed this class with actions that it
    can handle. To control the movement of a character, use a series of Booleans as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, define a float field called `moveSpeed`, which will help you control how
    much the character will move in each update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The control Booleans you added are set in the implemented `onAction` method.
    Note that a key will always trigger !isPressed when released (note that a key
    always triggers `isPressed == false` when released):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you have handled the key input, put the control Booleans to be used
    in the `update` method. You might recognize the code if you''ve looked at `TestBetterCharacter`.
    The first thing it does is get the current direction the `spatial` object is facing
    in order to move forward and backwards. It also checks which direction is left
    for strafing, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Depending on your Booleans, the following code modifies `walkDirection`. Normally,
    you would multiply the result by `tpf` as well, but this is already handled in
    the `BetterCharacterControl` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in the `setWalkDirection` method, apply `walkDirection` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code handles moving forward, backward, and to the side. The turning
    and looking up and down actions of a character is normally handled by moving the
    mouse (or game controller), which is instead an analog input. This is handled
    by the `onAnalog` method. From here, we take the name of the input and apply its
    value to two new methods, `rotate` and `lookUpDown`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start by handling the process of turning the character left and right.
    The `BetterCharacterControl` class already has nice support for turning the character
    (which, in this case, is the same thing as looking left or right), and you can
    access its `viewDirection` field directly. You should only modify the *y* axis,
    which is the axis that goes from head to toe, by a small amount as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to handle looking up and down, you have to do some more work. The
    idea is to let the `spatial` object handle this. For this, you need to step back
    to the top of the class and add two more fields: a `Node` field called `head`
    and a float field called `yaw`. The `yaw` field will be the value with which you
    will control the rotation of the head up and down.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, set the location of the `head` node. The location is relative
    to the `spatial` object to an appropriate amount. In a normally scaled world,
    `1.8f` would correspond to `1.8` m (or about 6 feet):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you need to attach the `head` node to `spatial`. You can do this in the
    `setSpatial` method. When a `spatial` is supplied, first check whether it is a
    `Node` (or you wouldn''t be able to add the head). If it is, attach the head as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you have a head that can rotate freely, you can implement the method
    that handles looking up and down. Modify the `yaw` field with the supplied value.
    Then, clamp it so that it can''t be rotated more than 90 degrees up or down. Not
    doing this might lead to weird results. Then, set the rotation for the head around
    the *x* axis (think ear-to-ear) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have a character that can move and rotate like a standard FPS character.
    It still doesn''t have a camera tied to it. To solve this, we''re going to use
    the `CameraNode` class and hijack the application''s camera. `CameraNode` gives
    you the ability to control the camera as if it were a node. With `setControlDir`,
    we instruct it to use the location and rotation of `spatial` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Cameras are logical objects and are not part of the scene graph. The `CameraNode`
    keeps an instance of Camera. It is a `Node` and propagates its own location to
    the Camera. It can also do the opposite and apply the Camera's location to `CameraNode`
    (and thus, any other `spatial` object attached to it).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use `GameCharacterControl` in an application, add the following lines of
    code in the `simpleInit` method of an application. Instantiate a new (invisible)
    `Node` instance that you can add to the `GameCharacterControl` class. Set the
    application''s camera to be used as a character, and add it to `physicsSpace`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BetterCharacterControl` class of jMonkeyEngine already has a lot of the
    functionalities to handle the movement of a character. By extending it, we get
    access to it and we can implement the additional functionality on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we use Booleans to control movement is that the events in `onAction`
    and `onAnalog` are not fired continuously; they are fired only when they're changed.
    So, pressing a key wouldn't generate more than two actions, one on pressing it
    and one on releasing it. With the Boolean, we ensure that the action will keep
    getting performed until the player releases the key.
  prefs: []
  type: TYPE_NORMAL
- en: This method waits for an action to happen, and depending on the binding parameter,
    it will set or unset one of our Booleans. By listening for actions rather than
    inputs (the actual key strokes), we can reuse this class for **non-player characters**
    (**NPCs**).
  prefs: []
  type: TYPE_NORMAL
- en: We can't handle looking up and down in the same way as we perform sideways rotations.
    The reason is that the latter changes the actual direction of the movement. When
    looking up or down, we just want the camera to look that way. The character is
    usually locked to the ground (it would be different in a flight simulator, though!).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `BetterCharacterControl` class already has ways to handle
    jumping and ducking. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we would rather have a third-person game. How difficult would it
    be to modify this class to support that? In a later recipe, we will look at jMonkeyEngine''s
    `ChaseCamera` class, but by inserting the following two lines of code at the end
    of our `setCamera` method, we will get a basic camera that follows the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's all handled by `CamNode`, which offsets the camera's location in relation
    to its own (which follows the `head` node). After moving `CamNode`, we make sure
    that the camera also looks at the head (rather than the default forward).
  prefs: []
  type: TYPE_NORMAL
- en: Attaching an input AppState object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will make an `AppState` object, which will handle the player
    input for a character. It's a great way to add functionality to the application
    in a modular way. The `AppState` object we create here could easily be added during
    the game and removed or disabled during cut scenes or while in the game menu.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We won't require any special assets for this recipe, but it will be beneficial
    to have a basic understanding of how AppState works and its purpose in jMonkeyEngine.
    This particular implementation of the recipe will use the character-control class
    created in the previous example. It can still be used to manipulate a `spatial`
    object directly without the `GameCharacterControl` class. This recipe will provide
    pointers on where to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To attach an input `AppState` object, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start off by creating a class called `InputAppState`, extending `AbstractAppState`,
    and implementing `ActionListener` and `AnalogListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `InputAppState` class needs a couple of fields to be functional. First of
    all, we're going to keep a reference to the application's `InputManager` in a
    field called `inputManager`. We're also adding a `GameCharacterControl` field
    called `character`. This can be replaced by any `spatial`. Lastly, we're going
    to have a value that controls the sensitivity of the analog controls. We do this
    with a float called sensitivity. Add getters and setters for character and sensitivity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll set up the kinds of input we''re going to handle. Strings are
    used by jMonkeyEngine for the mappings, but enums can be easier to manage across
    classes. Here, we''ll use an `enum` and supply the name of the value as the mapping.
    We use it to create some basic FPS controls as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a method called `addInputMappings` to add these to `inputManager`
    and make sure it listens to them. To do this, we supply the name of the `enum`
    value as the mapping and bind it to a certain input as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It's okay to assign several keys to the same mapping. For example, this recipe
    assigns both the arrow keys and the classical WASD pattern to the movement keys.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, in the same method, we tell `InputManager` to listen to the commands,
    or it won''t actually fire on any of the inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, once `AppState` is attached, it runs the `initialize` method (in a thread-safe
    way). Here, we get the reference to the application''s `InputManager` object and
    run the `addMappings` method we just created, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once `InputManager` detects any of the actions and sends them our way, we will
    just forward them to the `GameCharacterControl` object by applying the sensitivity
    value to the analog input as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re actually almost done with this recipe. We just need to make sure that
    we reset everything when `AppState` is not to be used anymore. We do this by overriding
    the cleanup method. Here, we remove all the mappings and remove this instance
    from listeners of `inputManager` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AppState` object works with the application in a way that is similar to
    how `Control` works with `spatial`. They give extended functionalities in a modular
    way. Once it has been attached to `stateManager`, its `update` method will be
    called every cycle. This gives us access to the application's thread as well.
    It also has the `stateAttached` and `stateDetached` methods, which can be used
    to turn functionality on and off easily.
  prefs: []
  type: TYPE_NORMAL
- en: Firing in FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to perform firing, and the requirements depend heavily
    on the type of game. This recipe will start off with the basics, which can then
    be extended to support the different forms of firing. We'll create the necessary
    functionalities to fire instant bullets; they are performance-friendly and suitable
    for a fairly close-quarters FPS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example will be based on `GameCharacterControl` and `InputAppState` from
    the *Creating a reusable character control* and *Attaching an input AppState*
    *object* recipes of this chapter, respectively. Familiarity with the recipes is
    beneficial. Further, we'll use the `Ray` class in combination with `CollisionResults`
    to check whether the bullet has hit anything or not.
  prefs: []
  type: TYPE_NORMAL
- en: Rays can be imagined as infinite lines and are very common in game development.
    This is a fast way of detecting intersections with game objects and is thus suitable
    for instant firing. The targets might consist of any kind of `spatial`. In this
    case, it's a bunch of spheres generated by the recipe's test class.
  prefs: []
  type: TYPE_NORMAL
- en: We will let the `InputAppState` class handle the firing logic, and the `GameCharacterControl`
    class will keep track of cool down time of the weapon, or how long it takes between
    each shot. The reason we don't keep everything in `AppState` is that this way,
    the class can be used for things other than the player's character.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by making some updates to the `GameCharacterControl` class. For
    the `GameCharacterControl` class, we introduce two new variables, `cooldownTime`
    and `cooldown`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is the time between shots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second is the current countdown until the character can fire again. We
    need to add a getter for `cooldown` and the value itself is set in the following
    `onFire` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, in the update method, we need to subtract `cooldown` by `tpf` if it's
    more than zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `InputAppState`, we also have to make some changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by introducing a `List<Geometry>` called `targets`. This is the list
    of things the fired rays will check for collisions against. In the `addInputMapping`
    method, add another mapping for `Fire`. A suitable button is the left mouse button.
    This is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onAction` method, change the logic slightly. We add a new check for
    the fire action and we put the existing logic inside the `else` clause. We''re
    telling `character` to handle all actions, except when we fire. This is implemented
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new method called `fire`. This is where we''re going to add most
    of the new functionalities. Inside this, we first define a new `Ray` class that
    we place at the camera''s location (if it is an FPS), and we set the direction
    to be the same as the camera''s direction, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a new `CollisionResults` instance, which we will use to keep track
    of collisions. We parse through the target list to see whether `Ray` collides
    with any of them. All collisions are stored in the `CollisionResults` instance
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, check whether there have been any collisions. If so, get the nearest
    one and display the location as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, call the character's `onFire` method, `character.onFire();`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this implementation, we handle most of the actual logic that happens when
    firing inside `InputAppState`. The `GameCharacterControl` class is left to keep
    control of whether firing is possible or not. Some further work on this could
    have the character play an animation and keep track of the ammunition.
  prefs: []
  type: TYPE_NORMAL
- en: The `Ray` object we're using is being fired out of the camera. This makes it
    easy to set both the location and direction. This would be the case for a game
    in iron sights or sniper mode. If you want to fire from the hip, for example,
    it would be slightly more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Rays are normally very fast. Using them can, however, become performance-demanding
    in large game worlds with complex collision shapes. This is one reason for keeping
    track of the items to be checked against in a list rather than using the whole
    `rootNode`. In other cases, it's good to first filter down the list, maybe based
    on the distance from the player.
  prefs: []
  type: TYPE_NORMAL
- en: The `CollisionResults` class stores collisions between `spatial` or `ray`. It
    contains a list of `CollisionResult` objects, which in turn has a number of useful
    methods for determining where a collision has occurred and between what.
  prefs: []
  type: TYPE_NORMAL
- en: Firing non-instant bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we implemented a basic form of firing that will work
    for many cases. The exit velocity for a bullet is usually around 300 m/s (or close
    to 1000 feet/s) and might seem near-instant at close range. For ranges over 30
    m (approximately 90 feet), the delay starts to get noticeable though, and more
    realistic games might need another model. In this recipe, we'll look into a type
    of bullet that travels in the game world. It's still an invisible bullet, but
    it can easily be visualized if required.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe can be seen as a more advanced version of the previous recipe and
    won't require many changes to what we did there but will mainly contain additions.
    Almost all of the functionalities will be implemented in a new class, called `Bullet`
    (not to be confused with the physics engine with the same name that we use in
    a [Chapter 8](ch08.html "Chapter 8. Physics with Bullet"), *Physics with Bullet*).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to fire non-instant bullets:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by defining our `Bullet` class. The `worldPosition` and `direction`
    variables are used by the `Ray` class as a starting position each step it takes.
    The `RANGE` field is a static field that defines the maximum range, inside which
    the bullet will be effective. The `distance` variable is the distance the bullet
    has traveled since it was instanced. It also needs to keep track of whether it's
    alive or not, for cleanup reasons. It should be said that this particular bullet
    is rather slow and short lived.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To avoid unnecessary object creation, we instance `Ray` in the constructor
    as follows, which we''ll reuse throughout the lifespan of the bullet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s in the `update` method that most of the work is done. At the beginning,
    we set the ray''s origin to be the current position of the bullet. The direction
    will stay the same, so no need to change that. We do, however, need to set limit
    factorized by the time passed for the update (`tpf`). The limit is also the distance
    the bullet has traveled since the last update, so we use this to update the current
    position of the bullet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the total distance is longer than the range, the bullet can be considered
    beyond its effective range. We set `alive` to `false` as follows so that it can
    be removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Bullet` class also has a `checkCollision` method. It takes a list of targets
    as input and tries a collision between each of them and the ray. If any collision
    is detected, `alive` will be set to `false` and the closest `CollisionResult`
    will be returned to the calling method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we'll add some code to the application class. It needs to keep track of
    `List<Collidable>`, called `targets` and `List<Bullet>`, called `bullets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `simpleUpdate` method updates the movement of all bullets by calling their
    update method before seeing whether any collisions have occurred or not. Any depleted
    bullets are removed in a way that avoids `ArrayIndexOutOfBounds` exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `fire()` method that creates a new bullet by using the camera''s location
    and direction as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method is called from the InputAppState''s `onAction` method, which is
    similar to how it looked in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Bullet` class can almost be seen as a slow ray. The `Ray` instance we have
    in `Bullet` is mostly out of convenience, since it's already prepared to collide
    with targets. By incrementing the position of the ray and having a short limit
    for it, we have a `Ray` instance that takes little steps forward in the game world,
    checking for collisions in each update.
  prefs: []
  type: TYPE_NORMAL
- en: If a collision has occurred, the returned `CollisionResult` contains information
    about where the collision has occurred, with what, and whether it can be used
    to build further functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RTS camera AppState object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll try to mimic the camera and controls that are common in
    RTS games. The camera will mostly look down on the scene, and aside from basic
    movement and rotation of the camera, there will also be automatic scrolling when
    the mouse reaches the edges of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to set up the camera and camera handling in this recipe. Loading
    a scene to make sure the camera works as expected would be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an RTS camera `AppState` object, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a class that implements the `AnalogListener` and `ActionListener`
    interfaces so that we can receive user input from the mouse and keyboard. We''ll
    use these to control the camera as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll define what controls we''ll handle. Using an `enum` will keep
    things tidy, so type the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows you the difference between the camera''s position
    above the ground (half circle) and the camera''s focus point (at the center):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/6478OS_02_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We then set up some things in the `initialize` method. Rather than having a
    completely top-down perspective, we give the camera a little tilt with `lookAtDirection`
    and a unit vector. Then, we move the camera further away from the ground with
    the `camDistance` variable. There is a reason we do this and don''t simply set
    the camera''s location. By doing it this way, we can more easily get the location
    the camera is looking at. This will come in handy if we want to add more advanced
    features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, add the keys that we''ll listen to `inputManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now to the `onAction` method, where any calls to these mappings will end up.
    Since we have an `enum`, we can use a switch to see what kind of input it is and
    set our Booleans accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s have a look at the `update` method, where we will put these Booleans
    to use. An `update` method is called automatically every frame, and we also get
    to know how much time (in seconds) has passed since the last update, in `tpf`.
    We start by storing the camera''s current location and initialize a `Vector3f`
    object, which we''ll use for our movement delta as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we look to see if any of our `movement` Booleans are `true` and apply
    this to `tempVector` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To keep the movement speed constant, regardless of the frame rate, we multiply
    `tempVector` by the `tpf`, and then we also multiply it by our `moveSpeed` variable.
    Then, we add it to `camLocation` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the method, we set the camera''s location to the modified stored
    location as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we try `AppState` now, we would be able to scroll across the scene with our
    keys. We still have mouse controls and rotation to take care of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s begin with rotation. We will handle it through a method called `rotate`.
    The supplied value is our `rotateSpeed` variable, from which we''ll extract a
    `Quaternion` rotated around the *y* axis. We then multiply the Quaternion with
    the camera''s rotation as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Furthermore, we need to make a few alterations to the `update` method. First,
    we look to see whether the user has pressed any of the rotation keys and call
    the `rotate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next piece is a bit trickier, and we perform it just above the line where
    we multiply `tempVector` by `moveSpeed` (highlighted). We multiply `tempVector`
    by the camera''s rotation to make sure that we get the movement across the correct
    axes. Then, since the camera is slightly tilted, we negate any movement along
    the *y* axis. The best way to understand what would happen is to probably remove
    this line and try it out as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s rotation taken care of! It''s pretty common in RTS or top-down games
    to scroll by moving the mouse to the extremes of the screen. So, let''s add functionalities
    for that. The following code snippet should be added in the `update` method above
    the rotation checks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AppState` object listens for the input from the player via `InputManager`
    and applies it to the application's camera. In just one short class, we've produced
    an RTS-like camera behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in this recipe, we added functionalities to pan the camera if the mouse
    cursor was near the edges of the screen. We used `InputManager.getCursorPosition()`,
    which is a very convenient method that returns the position of the mouse in the
    screen space. The bottom-left part of the screen has an x,y coordinate of 0,0\.
    The top-left part of the screen has an *x*, *y* coordinate that is the same as
    the height and width of the screen in pixels. The next `if` statements check whether
    the cursor is in the 10 percent of the outermost portion of the camera (which
    in this case is the same as the screen) and modify `tempVector` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'That''s nice and all, but if we have terrain in our scene, which is not flat,
    the camera might very well end up below the ground level. How can we remedy this?
    An easy way is to use ray casting to check for the height of the terrain where
    the camera is looking. This can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make sure the terrain has `CollisionShape`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By supplying `0` to `RigidBodyControl`, we say that it doesn't have any mass
    (and it won't be affected by gravity, if there were any). Since we're not supplying
    `CollisionShape`, `MeshCollisionShape` will be created. Since the terrain is of
    an irregular shape, a primitive (such as a box) isn't usable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create a field for the terrain in `AppState` and a setter as
    well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To actually find out the height of the terrain, we create a method called `checkHeight`,
    which returns the height as float.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `checkHeight`, we shoot `Ray`, which originates from the camera''s location
    in the direction the camera is facing. An alternative could be to shoot it down
    to get the height directly below the camera, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we get a result from our ray, we get the `y` value from the collision point
    and return it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `update` method, just above the line where we set the location,
    we call the `checkHeight` method. Be sure to apply the `camDistance` variable
    in order to get the correct offset! This is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Selecting units in RTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll show you how the selection of units in an RTS can work
    and also implement functionalities to show you when a unit has been selected.
    We'll use `AppState`, which handles mouse selection and we will also create a
    new `Control` class to be used by any `spatial` we want to be made selectable.
    In the recipe, Control will display a marker at the feet of the selected `spatial`,
    but it can easily be extended to do other things as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will work fine if you have already started creating a game where
    you would like to select things by clicking on them or if you've completed the
    previous recipe. The least you will need for this recipe is a scene with something
    to click on. In the text, we will refer to `TestScene`, which was created in [Chapter
    1](ch01.html "Chapter 1. SDK Game Development Hub"), *SDK Game Development Hub*,
    and the Jaime model which is used in it. It is assumed that you have some experience
    in action handling. If not, it's recommended that you refer to the *Attaching
    an input AppState object* recipe of this chapter to get an introduction to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to select units in RTS:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating the Control class and name it `SelectableControl`. It
    should extend `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class only has two fields: selected, which keeps track of whether the `spatial`
    field is selected or not (duh), and marker, which is another `spatial` field to
    show when selected is true.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only logic in the class is in the `setSelected` method; we let it handle
    attaching or detaching the marker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The method assumes that the `spatial` is actually a `Node`. If it is not a `Node`,
    the class can do other things, such as changing the color parameter of `Material`
    to indicate that it is selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We might want to display different markers for different types of selections,
    so let's make it flexible by adding a setter method for the marker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we create a new `AppState` class called `SelectAppState`. It should extend
    `AbstractAppState` and implement `ActionListener` to receive mouse click events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll add two fields, one static string to represent the mouse click, and
    a `List<Spatial>` called `selectables` where it will store anything that is selectable,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `initialize` method should look familiar if you've read any of the other
    game control recipes. We add a mapping for `LEFT_CLICK` and register it with the
    application's `InputManager` to ensure it listens for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only thing the `onAction` method will currently do is to trigger the `onClick`
    method when the left mouse button is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mouse selection (or picking) works by shooting `Ray` from the position of the
    mouse cursor into the screen. We begin by getting the position of the mouse cursor
    on the screen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we get the position this represents in the game world as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can see what direction this would be by extending the position deeper
    into the camera''s projection, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following figure shows you how `BoundingVolume`, in the shape of a box,
    can enclose the character:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/6478OS_02_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We define `Ray` using `mousePos3D` as the origin and `clickDir` as the direction
    and a `CollisionResults` instance to store any collisions that will occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can define a `for` loop that goes through our `selectables` list and
    checks whether `Ray` intersects with any of `BoundingVolumes`. The `CollisionResults`
    instance adds them to a list, and we can then retrieve the closest collision which,
    for most cases, is the most relevant one, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a good idea to have a look at the `CollisionResults` class as well as `CollisionResult`,
    as these classes already keep track of many useful things that will save valuable
    coding time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After this, we can parse through our `selectable` list to see whether the `spatial`
    that was clicked on has any of the items in the list. If it is, we call the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on the requirements, we might want to deselect all other spatials
    at this point. If we're using nodes, we might also need to see whether it is any
    of the spatial's children that were hit by the ray as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test this, we can use the same class used in the previous recipe, with a
    few additional lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First of all, we need to create and attach `SelectAppState` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create `SelectableControl` and something that can be used as a marker (in this
    case, it will be a simple Quad).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, we need to add `SelectableControl` to our Jaime model, and then add
    Jaime as a selectable to `AppState` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we now run the example and click on Jaime, the Quad should be rendered near
    his feet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example shows you one of the strengths of using `Control` and `AppState`,
    as it's easy to add functionalities to a `spatial` object as long as the logic
    is kept modular. Another (although possibly less effective) way of performing
    the selection would be to run a collision check against all `spatial` objects
    in a scene and use `Spatial.getControl (SelectableControl.class)` to see whether
    any of the spatials should be possible to select.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the items in the `selectables` list extend the `Spatial` class,
    but the only actual requirement is that the objects implement the `Collidable`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: When shooting the ray, we get the position of the mouse cursor from `InputManager`.
    It's a `Vector2f` object, where `0,0` is the bottom-left corner, and the top-right
    corner equals the height and width of the screen (in units). After this, we use
    `Camera.getWorldCoordinates` to give us a 3D position of the mouse click (or any
    position on the screen). To do this, we must supply a depth value. This is between
    0, which is closest to the screen, and 1f, into infinity. The direction would
    then be the difference between the nearest and farthest value, and it would be
    normalized.
  prefs: []
  type: TYPE_NORMAL
- en: Making the camera follow units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will cover some principles on how to make the camera follow something
    in the game world. While it might seem like an easy task at first, there are some
    tricky bits too.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe will build upon the *Creating an RTS camera AppState object* recipe
    of this chapter. All of the steps described in this recipe will be applied to
    `AppState`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make the camera follow units, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by adding two new variables, which we'll use for the new functionality.
    A Vector3f variable, called `targetLocation`, will be used to track the target,
    and a Boolean variable called `follow`, will be used to declare whether the camera
    should track the target or not. These are set from external classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Out of convenience, we also define a final Vector3f variable, called `UNIT_XZ`,
    which we set to`(1f, 0, 1f)`. We'll use this to convert 3D positions to 2D.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need to add some functionality in the `update` method just before `cam.setLocation(camLocation);`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we add a check to see whether the camera has been moved by the player.
    If so, we turn off the tracking as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the camera is up in the air and the target is (most likely) on the ground,
    we transform the camera''s location to a position on the same horizontal plane
    as the target. The `targetLocation` vector is pretty simple to handle. We just
    flatten it by zeroing on the `Y` value as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The camera is a bit trickier; since we''re interested in the target''s position
    in relation to the point the camera is looking at, we need to first find out where
    it is looking. First, we get the relative position of the point the camera is
    looking at by multiplying the height with the direction as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add it to the camera''s location (you can say that we project it on
    the ground) to get its world position. Finally, we flatten this as well with `UNIT_XZ`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re using a linear interpolation that moves the camera''s focus point 30
    percent closer to the target location each cycle. Then, we reverse the addition
    we did earlier (or unproject) to get a new 3D position for the camera. The distance
    check is optional, but since we''re going to use interpolation, we might save
    a few calculations by only interpolating if the distance is above a certain threshold
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To show that these changes work, we need to change a few things in our test
    application. We can grab Jaime from our scene and use his translation as the target
    location. We use `worldTranslation` and not `localTranslation` in this case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the `update` method of the test case, we make him slowly move along
    the *x* axis as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While running the application, we should see the camera follow Jaime until we
    move it manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way of handling it would be not to move the camera during the input
    but the actual point it looks at, and have the camera troll along. No matter which
    way you choose to do it though, practicing and thus getting a better understanding
    of these trigonometric problems is always a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're using linear interpolation here, `camLocation2D` will never actually
    reach `targetLocation`; it'll just get infinitely closer. This is why an `if`
    statement can be useful in these cases to see whether it's worth actually changing
    the distance or not. Finding the right threshold to break off is empiric and varies
    from case to case.
  prefs: []
  type: TYPE_NORMAL
- en: Following a character with ChaseCamera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll explore jMonkeyEngine's `ChaseCamera` class. This camera
    is a bit different from the previous cameras we've explored since we don't have
    direct control over its position. It is not like the camera-on-a-stick method
    we tried in the *Creating a reusable character control* recipe. While it still
    follows and looks at the character, it can float around the character more freely
    and also be controlled by the player.
  prefs: []
  type: TYPE_NORMAL
- en: The default control for the camera is to hold down the left mouse button and
    drag it to rotate the camera around the character. This is a very common control
    pattern in third-person games on consoles, where you rotate the camera with the
    left stick and control the character with the right.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement a behavior where the character moves in the direction the
    camera is facing rather than the direction the character is facing when you press
    the forward key. This is common in console games.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Out of convenience, we'll extend, or modify, the `GameCharacterControl` class
    from earlier. This way, we'll get some of the basic functionality and save some
    time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off, we can create a new `SimpleApplication` class in which we''ll
    apply the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the camera, you supply the application''s camera, `spatial`,
    to be followed, and the input manager, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ChaseCamera` class has lots of settings to suit different kinds of games.
    To start off, we turn off the need to hold down the left mouse button to rotate
    the camera. It''s not something we want for this recipe. This is implemented as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We do, however, want smooth movement for the camera. For this, type the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, the camera will focus on the origin point of `spatial`, which in
    this case, would be Jaime's feet. We can easily make it look at a higher-up point,
    such as `waist.chaseCam.setLookAtOffset(new Vector3f(0, 1f, 0));`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we set some distance restrictions for the camera. There is no guarantee
    that it will stay within those boundaries though. It especially seems to violate
    `minDistance`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ChasingSensitivity` method defines how quickly the camera will follow
    `spatial`. If it''s `1`, it will follow slowly and if it''s `5`, it will follow
    quickly. We want the camera to be pretty responsive in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following `RotationSpeed` method defines how quickly the camera moves when
    moving it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have a basic setup for `ChaseCamera`. Let's see what we need to do to
    the `GameCharacterControl` class to suit this kind of game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can easily apply the behavior where forward is the direction of the camera
    by replacing the two lines, and setting `modelForwardDir` and `modelLeftDir` in
    the `update` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we don''t directly control the characters'' view direction anymore, we
    can set it to always be the last direction the character faced (when moving) as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the method, we mustn''t forget to apply it to `PhysicsCharacter`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ChaseCamera` class is a convenient class that offloads a lot of camera
    handling from the coder. It has a lot of settings that can be tweaked to get the
    desired behavior. Camera tweaking is a delicate and time-consuming matter, and
    if you're working in a team, this is something a designer might do if the properties
    would be exposed in a text file and loaded during startup.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you press forward and then rotate the camera, the character will move in
    that direction, instead. In many games of this type, however, the character would
    keep running in the direction it had before the player rotated the camera. We
    can apply this behavior to our character with a few tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to change `modelForwardDir` and `modelLeftDir` into private
    fields in the class. Then, we make sure we only update these when the character
    isn''t receiving any input from the player. In this recipe, this would mean an
    `if` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Adding a game controller or joystick input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've used the mouse and keyboard for input. It's the most common way
    to handle controls on a PC, but let's explore the game controller and joystick
    support in jMonkeyEngine a bit. Writing code for a game controller is not very
    difficult. The tricky part is being agnostic enough to support the wide range
    of devices out there. Gone are the days when a joystick only had four directions
    and a fire button.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like in many recipes in this chapter, we'll use `InputAppState` from the *Attaching
    an input AppState object* recipe. This recipe will be fine to apply to any input
    handling class. Naturally, some kind of input device is necessary as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a game controller or joystick input, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, any controllers that the system recognizes will be available through
    `inputManager.getJoysticks()`. We'll create a new method called `assignJoysticks()`
    where we apply this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These controllers might turn up differently, in no particular order. It also
    seems as if they can sometimes show duplicate axes or some axes as separate controls.
    How can we handle this? The safest way might just be to have a `for` loop, parsing
    all controllers and trying to map them to the controls as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A difference between keyboard and mouse mapping is that we don''t actually
    need to add new mappings to `InputManager`. Instead, we tell the joystick what
    actions to emit. In this case, it''s the *x* axis on the left stick that is assigned
    the strafing action as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The *x* and *y* axes are often simple to map, usually on the left stick on the
    controller. The right one might not be as obvious. In this example, it's mapped
    to the rotation-X and rotation-Y axes, but might be mapped to the *z* axis, or
    rotation-Z as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same way, we can assign buttons to emit specific actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A joystick is an input device, just like the mouse or keyboard. While there
    is a way to map the actions in the same way, with `InputManager.addMapping()`,
    the recommended way is to do the reverse and assign actions to the joystick instead.
    Remember that `InputManager` still needs to listen to the mappings.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping buttons is even trickier than axes. First of all, there are two types
    of buttons, analog and digital. On a controller, usually the lower-right and left
    buttons controlled by the index fingers are analog, whereas all other buttons
    usually are digital. In jMonkeyEngine, everything analog is an axis. So, you will
    find that most likely, these will be reported as an axis.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On my controller, a Razer Hydra, left and right triggers are reported as the
    *z* axis.
  prefs: []
  type: TYPE_NORMAL
- en: As if that's not enough, all you have to work with is a button index. Fortunately,
    with most game controllers emulating one of the big brands of console makers,
    some kind of standard can be expected. However, there are exceptions, and for
    any serious game, an interface where the user can remap their device is a must.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a good, visual test example in the jMonkeyEngine project called `TestJoystick`,
    where you can instantly see the mapping of the attached controller and the corresponding
    action of each input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows you a view in the TestJoystick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/6478OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Leaning around corners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're making a sneaker or tactical shooter game, a common feature is to
    be able to lean around corners. This is used to scout without being seen or shooting
    without exposing yourself too much. In this recipe, we'll develop a way to do
    this with our `GameCharacterControl` class. We will implement functionalities
    to both handle leaning with keys (such as the shoulder buttons on a gamepad) and
    freeform leaning with the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will expand on the `GameCharacterControl` and `InputAppState` classes
    from the beginning of the chapter, but it should be easy to adapt to your own
    project. It is mostly used in FPS games, and this is what we will build it for.
  prefs: []
  type: TYPE_NORMAL
- en: Leaning in this example will emulate the player character moving the upper body.
    To achieve this and to save us some calculations on how much the camera should
    be offset when leaning, we will use the built-in behavior of spatials and how
    translation and rotation is propagated through in a node.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need a new `Node` instance called `centerPoint` in our `GameCharacterControl`.
    This will be the origin of our leaning, so to speak:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set the translation to be pretty much in the center of the character''s
    body (half the distance to the camera). We also attach the head node to `centerPoint`.
    In the `setSpatial` method, we add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following figure shows you the relation between the `head` and `centerPoint`
    nodes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/6478OS_02_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We continue to follow the pattern we have used in `GameCharacterControl` and
    use Booleans to define whether an action should happen and then handle any changes
    in the `update` method. So, let''s start by adding three new Booleans to handle
    leaning as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, before we add the actual leaning functionality, we need to introduce two
    more fields. The `leanValue` field stores the current amount of leaning for the
    character. We use the `maxLean` field to have some kind of limit to how much the
    player can lean. This is in radians and is set to corresponding 22.5 degrees.
    Sounds too little? Feel free to experiment using the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `onAction` method, we make sure that we handle the corresponding input.
    Again, after setting the Booleans like this, make sure our actions stay on until
    the key is released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Applying the leaning value is pretty straightforward. We do this in a method
    called `lean`, which takes a float value as the input. First, we clamp `leanValue`
    to make sure we don''t exceed our `maxLean` value. Then, we set the rotation along
    the *z* axis to the negative value as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One bit left now, and that''s where to call this method from. In the `update`
    method, we add two blocks of code. This reads as: if the button for leaning left
    is pressed and the leaning value is less than the maximum leaning value, lean
    more. Otherwise, if the button for free leaning is not pressed and the lean value
    is more than 0, lean less:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code block then needs to be mirrored to lean in the other direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s it for controlling leaning with buttons only. To add leaning using
    the mouse when `leanFree` is pressed, the `onAnalog` method needs a bit of work
    as well. We need to hijack the `RotateLeft` and `RotateRight` inputs when `leanFree`
    is set to `true`. The character shouldn''t turn then, but it should lean instead.
    This is easily done with an `if` statement. We apply the lean value instantly
    in this case. The code we added previously in the `update` method will take care
    of returning the leaning to zero when the button is released:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We already have `InputAppState`, which handles our input, so let's add a few
    more buttons to it. Three more values to our `InputMapping` enum are `LeanLeft`,
    `LeanRight`, and `LeanFree`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we assign those to *Q* and *E* keys to lean left and right, and V for
    free, or analog leaning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an easy way to handle leaning since we have very few calculations to
    do. The scene graph takes care of that for us. This works for the same reason;
    the turning of the `head` node in the *Creating a reusable character control*
    recipe could control the camera, which is normally not available in the scene
    graph. By attaching the `head` node to the center point (which, in turn, is attached
    to the main player node), any rotation or movement that the node does will be
    propagated to the `head` node, and thus, the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting cover automatically in a third-person game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cover shooters is an ever-popular genre in today's console games. How does one
    code a system that recognizes and allows players to take cover? There are several
    ways to do this, but basically, there are two main branches, each with their benefits
    and drawbacks. The first branch is one where a level designer places logical cover
    items around the environments or where they are baked into models by an artist.
    This could be as simple as a bounding volume, or it could be complex with directional
    data as well. This has a benefit for the programmer in that it's easy to recognize
    when a player is inside them by comparing bounding volumes. Another benefit is
    that the designer has full control over where there is cover and where there isn't.
    A drawback is that it is labor-intensive for the designer or artist and might
    be inconsistent to the player.
  prefs: []
  type: TYPE_NORMAL
- en: The method we'll implement is one where there is no pregenerated cover, and
    it's checked in runtime. No additional work is required for a designer or artist,
    except that the models that are used need to be of a certain height to be recognized
    as cover (and work with animations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, there are two different kinds of cover: a low cover that characters
    can crouch behind and shoot over. The other one is full height cover, where characters
    stand next to the edge of it and shoot around the corner. In some games, it''s
    only possible to use full height covers where it''s also possible to shoot from
    them, such as corners.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the character is in cover, certain movement restrictions usually apply.
    In most games, the player can move sideways along the cover. In some games, moving
    backwards will release the character from the cover, while in others, you have
    to toggle the cover button. We'll implement the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's define in more detail what we'll implement and how. We'll use `Rays` to
    detect whether the player is covered or not and `KeyTrigger` to toggle the entering
    or exiting cover. If you're not familiar with the concept of Rays, you can, for
    example, have a look at the *Firing in FPS* or *Selecting units in RTS* recipes
    in this chapter. Cover can be anything in the scene above a certain height. All
    of the action in this recipe will be handled by `GameCharacterControl` from the
    *Following a character with ChaseCamera* recipe. There are two separate areas
    we need to look at. One is the cover detection itself, and the other is related
    to how the character should behave when in cover.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement automatic cover detection, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few new fields we need to introduce to keep track of things. It''s
    not enough to simply send one ray from the center to detect the cover, so we''ll
    need to cast from the edges or near edges of the player model as well. We call
    this offset `playerWidth`. The `inCover` variable is used to keep track of whether
    the player is in cover mode or not (toggled). The `hasLowCover` and `hasHighCover`
    variables are set in the cover-detection method and are a way for us to know whether
    the player is currently within limits of a cover (but not necessarily in the cover
    mode). The `lowHeight` and `highHeight` variables are the heights where we''ll
    cast `Ray` from in order to check for cover. The `structures` variable is everything
    we should check for cover against. Don''t supply `rootNode` here or we''ll end
    up colliding with ourselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's move to the fun part, which is detecting cover. A new method called
    `checkCover` needs to be created. It takes `Vector3f` as the input and is the
    position from where the rays originate need to be originated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we define a new `Ray` instance. We don''t set the origin yet; we just
    set the direction to be the same as the character''s `viewDirection` and a maximum
    length for it (and this may vary depending on the context and game) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define two integer fields called `lowCollisions` and `highCollisions` to
    keep a track of how many collisions we've had.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we populate a new field called `leftDir`. This is the direction that
    is to the left of the character. We multiply this by `playerWidth` to get the
    left extreme to look for cover in, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll start by checking for low covers and set `y` to `lowHeight` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a `for` loop that sends three Rays: one at the left extreme
    of the player, one in the center, and one to the right. This is done by multiplying
    `leftDir` with `i`. The loop must then be duplicated for the upper Rays as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to be considered to be inside range of a cover, all three (left, middle,
    and right) Rays must hit something. A high cover always has a low cover as well,
    so we can check to see whether we''ve hit the low cover first. If we did, we do
    one more Ray check to find out the normal of the actual triangle hit. This will
    help us align the model with the cover:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The opposite of the triangle''s normal should be the character''s new `viewDirection`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we check whether we also have high cover and set the `hasLowCover`
    and `hasHighCover` fields accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To restrict movement, the `onAction` method needs some modifications. The first
    criterion we check is whether the toggle cover button is pressed. If we''re already
    in cover, we''ll release the character from the cover. If we''re not in cover,
    we check whether it''s possible to go into cover:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the following bracket, we limit movement to left and right if we're inside
    cover. If neither of the preceding statements applies, movement should be handled
    as usual. If we didn't want the player to be able to move inside cover, we'd be
    done by now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we want to mimic popular cover-based games though, we have some more work
    ahead of us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the update method, we have code to set the direction of the character
    based on the camera's rotation. We need to change this a bit, since once the character
    is inside cover, it should move based on the direction of the cover rather than
    the camera. To achieve this, we add a `!inCover` criterion to the original `if`
    statement, since outside cover, this should work like it worked previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, if we are in cover, we base `modelForwardDir` and `modelLeftDir` on the
    rotation of the spatial, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the movement has been applied to the `walkDirection` vector but before
    it is applied it to the character, we check whether the character will still be
    inside cover after moving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add the current `walkDirection` vector to the position of the player and
    check for cover at that position. If there is none, the movement is not allowed
    and we set `walkDirection` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now all that''s needed is a new mapping for `ToggleCover`, which is added to
    `InputAppState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time the player presses the `ToggleCover` key or button, a check will be
    run to see whether there is cover within range. Three rays are cast forward from
    a low height, one at the left edge of the model, one from the center, and one
    from the right. Since `leftDir` is multiplied by -1, 0, and 1 on the *x* and *z*
    axes, we get the offset to the left- and right-hand side of the center position.
    To be considered inside cover, all three must have collided with something. This
    ensures that the player model is wholly covered.
  prefs: []
  type: TYPE_NORMAL
- en: The Ray won't stop just because it collides with something, and if the cover
    is thin, it might continue through the back side of it, generating additional
    collisions. We only want to count one collision per ray, though (the closest),
    which is why we only increase `lowCollisions` by one.
  prefs: []
  type: TYPE_NORMAL
- en: The high cover is checked after the low cover, because in general, there is
    never any cover that only covers the upper body.
  prefs: []
  type: TYPE_NORMAL
- en: Once it's decided that the character is inside cover and the player wants to
    move, we need to check whether the player will still be inside cover at the new
    position. This is so that the player doesn't accidentally exit cover and end up
    getting killed. To avoid unnecessary performance hits, we don't want to do this
    every frame. We do this only if there has actually been some movement happening.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get the most out of this, we will need suitable animations. Refer to [Chapter
    4](ch04.html "Chapter 4. Mastering Character Animations"), *Mastering Character
    Animations*, to get a few ideas on how to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
