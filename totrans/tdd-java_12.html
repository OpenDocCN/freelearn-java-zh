<html><head></head><body>
<div id="_idContainer098">
<h1 class="chapter-number" id="_idParaDest-240"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-241"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.2.1">Test First, Test Later, Test Never</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to review some of the nuances of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">TDD</span></strong><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">We’ve already covered the broad techniques of writing unit tests as part of an overall test strategy. </span><span class="koboSpan" id="kobo.7.3">We can use the test pyramid and hexagonal architecture to guide the scope of our tests in terms of what specifically they need </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">to cover.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We have two more dimensions we need to decide on: when and where to start testing. </span><span class="koboSpan" id="kobo.9.2">The first question is one of timing. </span><span class="koboSpan" id="kobo.9.3">Should we always write our tests before the code? </span><span class="koboSpan" id="kobo.9.4">What difference would it make to write tests after the code? </span><span class="koboSpan" id="kobo.9.5">In fact, what about not testing at all – does that ever make sense? </span><span class="koboSpan" id="kobo.9.6">Where to start testing is another variable to decide. </span><span class="koboSpan" id="kobo.9.7">There are two schools of thought when it comes to TDD – testing from the inside out or the outside in. </span><span class="koboSpan" id="kobo.9.8">We will review what these terms mean and what impact each has on our work. </span><span class="koboSpan" id="kobo.9.9">Finally, we will consider how these approaches work with a hexagonal architecture to form a natural </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">testing boundary.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Adding </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">tests first</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">We can always test it </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">later, right?</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Tests? </span><span class="koboSpan" id="kobo.17.2">They’re for people who can’t </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">write code!</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Testing from the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">inside out</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Testing from the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">outside in</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Defining test boundaries with </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">hexagonal architecture</span></span></li>
</ul>
<h1 id="_idParaDest-242"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.25.1">Adding tests first</span></h1>
<p><span class="koboSpan" id="kobo.26.1">In this section, we will review the </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.27.1">trade-offs of adding a test first before writing the production code to make </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">it pass.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">Previous chapters have followed a test-first approach to writing code. </span><span class="koboSpan" id="kobo.29.2">We write a test before writing production code to make that test pass. </span><span class="koboSpan" id="kobo.29.3">This is a recommended approach, but it is important to understand some of the difficulties associated with it as well as considering </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">its </span></span><span class="No-Break"><a id="_idIndexMarker652"/></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">benefits.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.32.1">Test-first is a design tool</span></h2>
<p><span class="koboSpan" id="kobo.33.1">The most important benefit of writing tests first is that a test acts as a </span><em class="italic"><span class="koboSpan" id="kobo.34.1">design aid</span></em><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">As we decide what to write in our test, we </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.36.1">are designing the interface to our code. </span><span class="koboSpan" id="kobo.36.2">Each of the test stages helps us consider an aspect of software design, as illustrated by the </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.38.1"><img alt="Figure 12.1 – Test-first aids design" src="image/Figure_12.1_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.39.1">Figure 12.1 – Test-first aids design</span></p>
<p><span class="koboSpan" id="kobo.40.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">Arrange</span></strong><span class="koboSpan" id="kobo.42.1"> step</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.43.1"> helps us think about how the code under test relates to the bigger picture of the whole code base. </span><span class="koboSpan" id="kobo.43.2">This step helps us design how the code will fit into the whole code base. </span><span class="koboSpan" id="kobo.43.3">It gives us an </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.44.1">opportunity to make the following </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">design decisions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.46.1">What configuration data will </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">be needed?</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">What connections to other objects or functions will </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">be needed?</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">What behavior should this </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">code provide?</span></span></li>
<li><span class="koboSpan" id="kobo.52.1">What extra inputs are needed to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">that behavior?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.54.1">Coding the Act step allows us to</span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.55.1"> think about how easy our code will be to use. </span><span class="koboSpan" id="kobo.55.2">We reflect on what we would like the method signature of the code we are designing to be. </span><span class="koboSpan" id="kobo.55.3">Ideally, it should be simple </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.56.1">and unambiguous. </span><span class="koboSpan" id="kobo.56.2">Some general recommendations are </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.58.1">The method name should describe the outcome of calling </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the method.</span></span></li>
<li><span class="koboSpan" id="kobo.60.1">Pass in as few parameters as possible. </span><span class="koboSpan" id="kobo.60.2">Possibly group parameters into their </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">own object.</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">Avoid Boolean flags that modify the behavior of the code. </span><span class="koboSpan" id="kobo.62.2">Use separate methods with </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">appropriate names.</span></span></li>
<li><span class="koboSpan" id="kobo.64.1">Avoid requiring multiple method calls to do one thing. </span><span class="koboSpan" id="kobo.64.2">It is too easy to miss out on an important call in the sequence if we are unfamiliar with </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">the code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.66.1">Writing the Act step allows us to see what the call to our code will look like everywhere it is used for the first time. </span><span class="koboSpan" id="kobo.66.2">This provides the opportunity to simplify and clarify before our code gets </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">widely used.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">The code in our Assert step</span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.69.1"> is the first consumer of the results of our code. </span><span class="koboSpan" id="kobo.69.2">We can judge from this step whether those results are easy to obtain. </span><span class="koboSpan" id="kobo.69.3">If we are unhappy with how the Assert code looks, this is a chance to review how our object provides </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">its output.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">Every test we write provides this opportunity for a design review. </span><span class="koboSpan" id="kobo.71.2">TDD is all about helping us uncover better designs, even more than it is about </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">testing correctness.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">In other industries, such as designing cars, it is common to have dedicated design tools. </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">AutoCAD 3D Studio</span></strong><span class="koboSpan" id="kobo.75.1"> is used to create 3D models for the chassis of a car on a computer. </span><span class="koboSpan" id="kobo.75.2">Before we manufacture the car, we can use the tool to pre-visualize the end result, rotating it through space and viewing it from </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">several angles.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Mainstream commercial software engineering lags far behind in terms of design tool support. </span><span class="koboSpan" id="kobo.77.2">We don’t have an</span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.78.1"> equivalent to 3D Studio for designing code. </span><span class="koboSpan" id="kobo.78.2">The 1980s to 2000s saw the rise of </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">Computer-Aided Software Engineering</span></strong><span class="koboSpan" id="kobo.80.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.81.1">CASE</span></strong><span class="koboSpan" id="kobo.82.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">tools</span></strong><span class="koboSpan" id="kobo.84.1"> but these appear to have fallen into disuse. </span><span class="koboSpan" id="kobo.84.2">CASE tools purported to simplify software engineering by allowing their users to enter various graphical forms of software structures, then generate code that implemented those structures. </span><span class="koboSpan" id="kobo.84.3">Today, writing TDD tests prior to writing the production code seems to be the closest thing we have to computer-aided design for software </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">at present.</span></span></p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.86.1">Tests form executable specifications</span></h2>
<p><span class="koboSpan" id="kobo.87.1">Another advantage of test code is that it can form a highly accurate, repeatable form of documentation. </span><span class="koboSpan" id="kobo.87.2">Simplicity and </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.88.1">clarity in the test code are required to achieve that. </span><span class="koboSpan" id="kobo.88.2">Instead of writing a test planning document, we write TDD tests as code, which can be run by a computer. </span><span class="koboSpan" id="kobo.88.3">This has the benefit of being more immediate for developers. </span><span class="koboSpan" id="kobo.88.4">These executable specifications are captured alongside the production code they test, stored in source control, and made continuously available to the </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">whole team.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">Further documentation</span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.91.1"> is useful. </span><span class="koboSpan" id="kobo.91.2">Documents such as </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">RAID logs</span></strong><span class="koboSpan" id="kobo.93.1"> – documenting risks, actions, issues, and </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.94.1">decisions – and </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">KDDs</span></strong><span class="koboSpan" id="kobo.96.1"> – documenting key design decisions – are often required. </span><span class="koboSpan" id="kobo.96.2">These are non-executable documents. </span><span class="koboSpan" id="kobo.96.3">They serve the purpose of capturing who, when, and critically </span><em class="italic"><span class="koboSpan" id="kobo.97.1">why</span></em><span class="koboSpan" id="kobo.98.1"> an important decision was made. </span><span class="koboSpan" id="kobo.98.2">Information of this kind cannot be captured using test code, meaning that these kinds of documents </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">have value.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.100.1">Test-first provides meaningful code coverage metrics</span></h2>
<p><span class="koboSpan" id="kobo.101.1">Writing a test before we write</span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.102.1"> production code gives each test a specific purpose. </span><span class="koboSpan" id="kobo.102.2">The test exists to drive out a specific behavior in our code. </span><span class="koboSpan" id="kobo.102.3">Once we get this test to pass, we can run the test suite using a code coverage tool, which will output a report similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.104.1"><img alt="Figure 12.2 – Code coverage report" src="image/Figure_12.2_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.105.1">Figure 12.2 – Code coverage report</span></p>
<p><span class="koboSpan" id="kobo.106.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">code coverage</span></strong><span class="koboSpan" id="kobo.108.1"> tool instruments our</span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.109.1"> production code as we run the tests. </span><span class="koboSpan" id="kobo.109.2">This instrumentation captures which lines of code were executed during running the tests. </span><span class="koboSpan" id="kobo.109.3">This report can suggest we have missing tests, by flagging up lines of code that were never executed during the </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">test run.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">The code coverage report in</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.112.1"> the image shows we have executed 100% of the code in the domain model by our test run. </span><span class="koboSpan" id="kobo.112.2">Having 100% coverage is entirely down to us writing a TDD test before we write code to make it pass. </span><span class="koboSpan" id="kobo.112.3">We do not add untested code with a test-first </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">TDD workflow.</span></span></p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.114.1">Beware of making a code coverage metric a target</span></h2>
<p><span class="koboSpan" id="kobo.115.1">A high code coverage metric doesn’t always indicate high code quality. </span><span class="koboSpan" id="kobo.115.2">If we are writing tests for generated code or tests </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.116.1">for code we’ve pulled from a library, that coverage does not tell us anything new. </span><span class="koboSpan" id="kobo.116.2">We may assume – generally – that our code generators and libraries have already been tested by </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">their developers.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">However, a real problem with code coverage numbers happens when we mandate them as a metric. </span><span class="koboSpan" id="kobo.118.2">As soon as we </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.119.1">impose a minimum coverage target on developers, then </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Goodhart’s law</span></strong><span class="koboSpan" id="kobo.121.1"> applies – </span><em class="italic"><span class="koboSpan" id="kobo.122.1">when a measure becomes a target, it ceases to be a good measure</span></em><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">Humans will sometimes cheat the system to achieve a target when under pressure. </span><span class="koboSpan" id="kobo.123.3">When that happens, you see code such </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">as this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
public class WordTest {
    @Test
    public void oneCorrectLetter() {
        var word = new Word("A");
        var score = word.guess("A");
        </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">// </span></strong><span class="koboSpan" id="kobo.127.1">assertThat(score).isEqualTo(CORRECT);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.128.1">Notice those comment symbols – </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">//</span></strong><span class="koboSpan" id="kobo.130.1"> – just before </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">assertThat()</span></strong><span class="koboSpan" id="kobo.132.1">? </span><span class="koboSpan" id="kobo.132.2">That’s the hallmark of a test case that was failing and could not be made to pass by a certain deadline. </span><span class="koboSpan" id="kobo.132.3">By retaining the</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.133.1"> test, we keep our number of test cases up, and we keep our code coverage percentage up. </span><span class="koboSpan" id="kobo.133.2">A test such as this will execute lines of production code, but it will not </span><em class="italic"><span class="koboSpan" id="kobo.134.1">validate</span></em><span class="koboSpan" id="kobo.135.1"> that they work. </span><span class="koboSpan" id="kobo.135.2">The code coverage target will be hit – even though the code itself does </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">not work.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">Now, I know what you’re thinking – no developer would ever cheat the test code like this. </span><span class="koboSpan" id="kobo.137.2">It is, however, an example from a project I worked on for a major international client. </span><span class="koboSpan" id="kobo.137.3">The client had engaged both the company I work for and another development team to work on some microservices. </span><span class="koboSpan" id="kobo.137.4">Due to a time zone difference, the other team would check in their code changes while our team </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">was asleep.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">We came in one morning to see our test results dashboards lit up red. </span><span class="koboSpan" id="kobo.139.2">The overnight code change had caused large numbers of our tests to fail. </span><span class="koboSpan" id="kobo.139.3">We checked the pipelines of the other team and were astonished to see all their tests passing. </span><span class="koboSpan" id="kobo.139.4">This made no sense. </span><span class="koboSpan" id="kobo.139.5">Our tests clearly revealed a defect in that nightly code drop. </span><span class="koboSpan" id="kobo.139.6">We could even localize it from our test failures. </span><span class="koboSpan" id="kobo.139.7">This defect would have shown up in the unit tests around that code, but those unit tests were passing. </span><span class="koboSpan" id="kobo.139.8">The reason? </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">Commented-out asserts.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">The other team was under pressure to deliver. </span><span class="koboSpan" id="kobo.141.2">They obeyed their instructions to get that code change checked in on that day. </span><span class="koboSpan" id="kobo.141.3">Those changes, in fact, had broken their unit tests. </span><span class="koboSpan" id="kobo.141.4">When they could not fix them in the time available, they chose to cheat the system and defer the problem to another day. </span><span class="koboSpan" id="kobo.141.5">I’m not sure I blame them. </span><span class="koboSpan" id="kobo.141.6">Sometimes, 100% code coverage and all tests passing mean nothing </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">at all.</span></span></p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.143.1">Beware of writing all tests upfront</span></h2>
<p><span class="koboSpan" id="kobo.144.1">One of the strengths of TDD is that it allows for </span><em class="italic"><span class="koboSpan" id="kobo.145.1">emergent design</span></em><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">We do a small piece of design work, captured in a test. </span><span class="koboSpan" id="kobo.146.3">We</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.147.1"> then do the next small piece of design, captured in a new test. </span><span class="koboSpan" id="kobo.147.2">We perform varying depths of refactoring as we go. </span><span class="koboSpan" id="kobo.147.3">In this way, we learn about what is and is not working in our approach. </span><span class="koboSpan" id="kobo.147.4">The tests provide fast feedback on </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">our design.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">This can only happen if we write tests one at a time. </span><span class="koboSpan" id="kobo.149.2">A temptation for those familiar with waterfall project approaches can be to treat the test code as one giant requirements document, to be completed before development starts. </span><span class="koboSpan" id="kobo.149.3">While this seems more promising than simply writing a requirements document in a word processor, it also means that developers cannot learn from test feedback. </span><span class="koboSpan" id="kobo.149.4">There is no feedback cycle. </span><span class="koboSpan" id="kobo.149.5">This approach to testing should be avoided. </span><span class="koboSpan" id="kobo.149.6">Better results are obtained by taking an incremental approach. </span><span class="koboSpan" id="kobo.149.7">We write one test at a time, together with the production code to make that </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">test pass.</span></span></p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.151.1">Writing tests first helps with continuous delivery</span></h2>
<p><span class="koboSpan" id="kobo.152.1">Perhaps the biggest benefit of writing tests </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.153.1">first lies in continuous delivery situations. </span><span class="koboSpan" id="kobo.153.2">Continuous delivery relies on a highly automated pipeline. </span><span class="koboSpan" id="kobo.153.3">Once a code change is pushed to source control, the build pipeline is started, all tests run, and finally, a </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">deployment occurs.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">The only reason for code not to deploy in this system – assuming the code compiles – is if the tests fail. </span><span class="koboSpan" id="kobo.155.2">This implies that the automated tests we have in place are necessary and sufficient to create the level of </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">confidence required.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Writing tests first cannot guarantee this – we may still have missing tests – but out of all the ways of working with tests, it is perhaps the most likely to result in one meaningful test for each piece of application behavior that we </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">care about.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">This section has presented the case that writing tests first – before production code is written, to make them pass – helps create confidence in our code, as well as useful executable specifications. </span><span class="koboSpan" id="kobo.159.2">However, that’s not the only way to code. </span><span class="koboSpan" id="kobo.159.3">Indeed, a common approach we will see is to write a chunk of code first and then write tests </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">shortly after.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">The next section looks at the advantages and limitations of the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">test-later approach.</span></span></p>
<h1 id="_idParaDest-249"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.163.1">We can always test it later, right?</span></h1>
<p><span class="koboSpan" id="kobo.164.1">An alternative approach to writing tests before code is to write code first, then write tests. </span><span class="koboSpan" id="kobo.164.2">This section compares and contrasts writing tests after the code with writing tests before </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">One approach to writing tests involves </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.167.1">writing chunks of code and then retrofitting tests to those pieces of code. </span><span class="koboSpan" id="kobo.167.2">It’s an approach that is used in commercial programming, and the workflow can be illustrated </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.169.1"><img alt="Figure 12.3 – Test-after workflow" src="image/Figure_12.3_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.170.1">Figure 12.3 – Test-after workflow</span></p>
<p><span class="koboSpan" id="kobo.171.1">Upon selecting a user story to develop, one or more pieces of production code are written. </span><span class="koboSpan" id="kobo.171.2">Tests follow! </span><span class="koboSpan" id="kobo.171.3">Academic research seems mixed, to say the least, on whether or not test-after differs from test-first. </span><span class="koboSpan" id="kobo.171.4">From one 2014 study by the ACM, an extract from the conclusion </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">was this:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.173.1">“</span><em class="italic"><span class="koboSpan" id="kobo.174.1">…static code analysis results were found statistically significant in the favor of TDD. </span><span class="koboSpan" id="kobo.174.2">Moreover, the results of the survey revealed that the majority of developers in the experiment prefer TLD over TDD, given the lesser required level of learning curve.</span></em><span class="koboSpan" id="kobo.175.1">”</span></p>
<p><span class="koboSpan" id="kobo.176.1">(</span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">Source: </span></span><a href="https://dl.acm.org/doi/10.1145/2601248.2601267"><span class="No-Break"><span class="koboSpan" id="kobo.178.1">https://dl.acm.org/doi/10.1145/2601248.2601267</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.179.1">)</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">However, a commenter pointed out that in this research, the </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">following applied:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.182.1">“</span><em class="italic"><span class="koboSpan" id="kobo.183.1">…usable data was obtained from only 13 out of 31 developers. </span><span class="koboSpan" id="kobo.183.2">This meant the statistical analysis was undertaken using groups of seven (TDD) and six (TLD). </span><span class="koboSpan" id="kobo.183.3">There is no real surprise that the experiment was found to lack statistical power and that the findings were inconclusive.</span></em><span class="koboSpan" id="kobo.184.1">”</span></p>
<p><span class="koboSpan" id="kobo.185.1">Other research papers seem to show similar lackluster results. </span><span class="koboSpan" id="kobo.185.2">Practically then, what should we take away from this? </span><span class="koboSpan" id="kobo.185.3">Let’s consider some practical details of </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">test-later development.</span></span></p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.187.1">Test-later is easier for a beginner to TDD</span></h2>
<p><span class="koboSpan" id="kobo.188.1">One finding of the research was that beginners to TDD found test-later to be easier to get started with. </span><span class="koboSpan" id="kobo.188.2">This seems reasonable. </span><span class="koboSpan" id="kobo.188.3">Before we attempt TDD, we may consider coding and testing as different </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.189.1">activities. </span><span class="koboSpan" id="kobo.189.2">We write code according to some set of heuristics, and then we figure out how to test that code. </span><span class="koboSpan" id="kobo.189.3">Adopting a test-later approach means that the coding phase is essentially unchanged by the demands of testing. </span><span class="koboSpan" id="kobo.189.4">We can continue coding as we always did. </span><span class="koboSpan" id="kobo.189.5">There is no impact from having to consider the impacts of testing on the design of that code. </span><span class="koboSpan" id="kobo.189.6">This seeming advantage is short-lived, as we discover the need to add access points for testing, but we can at least get </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">started easily.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">Adding tests later works reasonably well if we keep writing tests in lockstep with the production code: write a little code, and write a few tests for that code – but not having tests for every code path remains </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">a risk.</span></span></p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.193.1">Test-later makes it harder to test every code path</span></h2>
<p><span class="koboSpan" id="kobo.194.1">A plausible argument </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.195.1">against using a test-later approach is that it becomes harder to keep track of having all the tests we need. </span><span class="koboSpan" id="kobo.195.2">On the face of it, this claim cannot be completely true. </span><span class="koboSpan" id="kobo.195.3">We can always find some way to keep track of the tests we need. </span><span class="koboSpan" id="kobo.195.4">A test is a test, no matter when it </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">is written.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">The problem comes as the time between adding tests increases. </span><span class="koboSpan" id="kobo.197.2">We are adding more code, which means adding more execution paths throughout the code. </span><span class="koboSpan" id="kobo.197.3">For example, every </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">if</span></strong><span class="koboSpan" id="kobo.199.1"> statement we write represents two execution paths. </span><span class="koboSpan" id="kobo.199.2">Ideally, every execution path through our code will have a test. </span><span class="koboSpan" id="kobo.199.3">Every untested execution path we add places us one test below this ideal number. </span><span class="koboSpan" id="kobo.199.4">This is illustrated directly </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">in flowcharts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.201.1"><img alt="Figure 12.4 – Illustrating execution paths" src="image/Figure_12.4_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.202.1">Figure 12.4 – Illustrating execution paths</span></p>
<p><span class="koboSpan" id="kobo.203.1">This flowchart depicts </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.204.1">a process with nested decision points – the diamond shapes – which result in three possible execution paths, labeled </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">A</span></strong><span class="koboSpan" id="kobo.206.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">B</span></strong><span class="koboSpan" id="kobo.208.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">C</span></strong><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">The technical measure of the number of execution paths is called </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">cyclomatic complexity</span></strong><span class="koboSpan" id="kobo.212.1">. </span><span class="koboSpan" id="kobo.212.2">The complexity score is the </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.213.1">number calculated on how many linearly independent execution paths exist in a piece of code. </span><span class="koboSpan" id="kobo.213.2">The code in the flowchart has a cyclomatic complexity </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">of three.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">As we increase the cyclomatic complexity of our code, we increase our </span><em class="italic"><span class="koboSpan" id="kobo.216.1">cognitive load</span></em><span class="koboSpan" id="kobo.217.1"> with the need to remember all those tests that we need to write later. </span><span class="koboSpan" id="kobo.217.2">At some point, we might even find ourselves periodically stopping coding and writing down notes for what tests to add later. </span><span class="koboSpan" id="kobo.217.3">This sounds like a more arduous version of simply writing the tests as </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">we go.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">The issue of keeping track of tests we are yet to write is avoided when using </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">test-first development.</span></span></p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.221.1">Test-later makes it harder to influence the software design</span></h2>
<p><span class="koboSpan" id="kobo.222.1">One of the benefits of test-first </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.223.1">development is that the feedback loop is very short. </span><span class="koboSpan" id="kobo.223.2">We write one test and then complete a small amount of production code. </span><span class="koboSpan" id="kobo.223.3">We then refactor as required. </span><span class="koboSpan" id="kobo.223.4">This moves away from a waterfall-style pre-planned design to an emergent design. </span><span class="koboSpan" id="kobo.223.5">We change our design in response to learning more about the problem we are solving as we incrementally solve more </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">When writing tests after a chunk of code has already been written, it gets harder to incorporate feedback. </span><span class="koboSpan" id="kobo.225.2">We </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.226.1">may find that the code we have created proves difficult to integrate into the rest of the code base. </span><span class="koboSpan" id="kobo.226.2">Perhaps this code is confusing to use due to having unclear interfaces. </span><span class="koboSpan" id="kobo.226.3">Given all the effort we have spent creating the messy code, it can be tempting to just live with the awkward design and its equally awkward </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">test code.</span></span></p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.228.1">Test-later may never happen</span></h2>
<p><span class="koboSpan" id="kobo.229.1">Development tends to be a </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.230.1">busy activity, especially when deadlines are involved. </span><span class="koboSpan" id="kobo.230.2">Time pressures may mean that the time we hoped to get to write our tests simply never comes. </span><span class="koboSpan" id="kobo.230.3">It’s not uncommon for project managers to be more impressed with new features than with tests. </span><span class="koboSpan" id="kobo.230.4">This seems a false economy – as users only care about features that </span><em class="italic"><span class="koboSpan" id="kobo.231.1">work</span></em><span class="koboSpan" id="kobo.232.1"> – but it’s a pressure that developers </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">sometimes face.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">This section has shown that writing tests shortly after writing code can work as well as writing tests first if care is exercised. </span><span class="koboSpan" id="kobo.234.2">It also seems preferable to some developers at the start of their TDD journey – but what about the ultimate extreme of </span><em class="italic"><span class="koboSpan" id="kobo.235.1">never</span></em><span class="koboSpan" id="kobo.236.1"> testing our code? </span><span class="koboSpan" id="kobo.236.2">Let’s quickly review the consequences of </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">that approach.</span></span></p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.238.1">Tests? </span><span class="koboSpan" id="kobo.238.2">They’re for people who can’t write code!</span></h1>
<p><span class="koboSpan" id="kobo.239.1">This section discusses another obvious possibility when it comes to automated testing – simply not writing automated tests at all. </span><span class="koboSpan" id="kobo.239.2">Perhaps </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.240.1">not even testing at all. </span><span class="koboSpan" id="kobo.240.2">Is </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">this viable?</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Not testing at all is a choice we could make, and this might not be as silly as it sounds. </span><span class="koboSpan" id="kobo.242.2">If we define testing as </span><em class="italic"><span class="koboSpan" id="kobo.243.1">verifying some outcome is achieved in its target environment</span></em><span class="koboSpan" id="kobo.244.1">, then things such as deep-space probes cannot truly be tested on Earth. </span><span class="koboSpan" id="kobo.244.2">At best, we are simulating the target environment during our testing. </span><span class="koboSpan" id="kobo.244.3">Giant-scale web applications can rarely be tested with realistic load profiles. </span><span class="koboSpan" id="kobo.244.4">Take any large web application, launch a hundred million users at it – all doing invalid things – and see how most applications hold up. </span><span class="koboSpan" id="kobo.244.5">It’s probably not as well as developer </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">testing suggested.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">There are areas of development where we might expect to see fewer </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">automated tests:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.248.1">Extract, Transform, and Load</span></strong><span class="koboSpan" id="kobo.249.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.250.1">ETL</span></strong><span class="koboSpan" id="kobo.251.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">scripts for </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.253.1">data migrations</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">:</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.255.1">ETL scripts are often one-off affairs, written to solve a specific migration problem with some data. </span><span class="koboSpan" id="kobo.255.2">It’s not always worth writing automated tests for these, performing manual verification on a similar set of source </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">data instead.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.257.1">Front-end user </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.258.1">interface work</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">:</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.260.1">Depending on the programming approach, it may be challenging to write unit tests for the frontend code. </span><span class="koboSpan" id="kobo.260.2">Whatever approach we take, assessing the visual look and feel cannot currently be automated. </span><span class="koboSpan" id="kobo.260.3">As a result, manual testing is often used against a candidate release of a </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">user interface.</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.262.1">Infrastructure-as-code scripts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">:</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.264.1">Our applications need to be deployed somewhere for them to run. </span><span class="koboSpan" id="kobo.264.2">A recent approach to deployment is to use languages such as Terraform to configure servers using code. </span><span class="koboSpan" id="kobo.264.3">This is an area that’s not yet simple to automate </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">tests for.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">So what actually happens when we abandon test automation, possibly not even testing </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">at all?</span></span></p>
<h2 id="_idParaDest-255"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.268.1">What happens if we do not test during development?</span></h2>
<p><span class="koboSpan" id="kobo.269.1">We might think that </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.270.1">not testing at all is an option, but in reality, testing will always happen at some point. </span><span class="koboSpan" id="kobo.270.2">We can illustrate this with a timeline of the possible points at which testing </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.271.1">can</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1"> occur:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.273.1"><img alt="Figure 12.5 – Testing timeline" src="image/Figure_12.5_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">Figure 12.5 – Testing timeline</span></p>
<p><span class="koboSpan" id="kobo.275.1">Test-first approaches shift the testing to be as early as possible – an approach called </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">shift-left</span></strong><span class="koboSpan" id="kobo.277.1"> – where defects can be </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.278.1">corrected cheaply and easily. </span><span class="koboSpan" id="kobo.278.2">Thinking that we won’t test merely pushes testing all the way to the right – after users start using </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">features live.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">Ultimately, </span><em class="italic"><span class="koboSpan" id="kobo.281.1">all code that users care about gets tested eventually</span></em><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">Maybe developers don’t test it. </span><span class="koboSpan" id="kobo.282.3">Maybe testing will fall to another specialist testing team, who will write defect reports. </span><span class="koboSpan" id="kobo.282.4">Maybe defects will be found during the operation of the software. </span><span class="koboSpan" id="kobo.282.5">Most commonly of all, we end up outsourcing testing to the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">users themselves.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Having users test our code for us is generally a bad idea. </span><span class="koboSpan" id="kobo.284.2">Users trust us to give them software that solves their problems. </span><span class="koboSpan" id="kobo.284.3">Whenever a defect in our code prevents that from happening, we lose that trust. </span><span class="koboSpan" id="kobo.284.4">A loss of trust damages the 3 Rs of a business: revenue, reputation, and retention. </span><span class="koboSpan" id="kobo.284.5">Users may well switch to another supplier, whose better-tested code actually solves the </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">user’s problem.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">If there is any possibility at all to</span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.287.1"> test our work before we ship it, we should take that opportunity. </span><span class="koboSpan" id="kobo.287.2">The sooner we build test-driven feedback loops into our work, the easier it will be to improve the quality of </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">that work.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">Having looked at </span><em class="italic"><span class="koboSpan" id="kobo.290.1">when</span></em><span class="koboSpan" id="kobo.291.1"> we test our software, let’s turn to </span><em class="italic"><span class="koboSpan" id="kobo.292.1">where</span></em><span class="koboSpan" id="kobo.293.1"> we test it. </span><span class="koboSpan" id="kobo.293.2">Given the overall design of a piece of software, where should we start testing? </span><span class="koboSpan" id="kobo.293.3">The next section reviews a test approach that starts from the inside of a design and works its </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">way out.</span></span></p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.295.1">Testing from the inside out</span></h1>
<p><span class="koboSpan" id="kobo.296.1">In this section, we’re going</span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.297.1"> to review our choice of starting point for our TDD activities. </span><span class="koboSpan" id="kobo.297.2">The first place to look at is inside our software system, starting </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">with details.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">When starting to build software, we obviously need some place to start from. </span><span class="koboSpan" id="kobo.299.2">One place to start is with some of the details. </span><span class="koboSpan" id="kobo.299.3">Software is made up of small interconnecting components, each of which performs a portion of the whole task. </span><span class="koboSpan" id="kobo.299.4">Some components come from library code. </span><span class="koboSpan" id="kobo.299.5">Many components are custom-made to provide the functionality our </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">application needs.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">One place to start building, then, is on the </span><em class="italic"><span class="koboSpan" id="kobo.302.1">inside</span></em><span class="koboSpan" id="kobo.303.1"> of this software system. </span><span class="koboSpan" id="kobo.303.2">Starting with an overall user story, we can imagine a small component that is likely to be of use to us. </span><span class="koboSpan" id="kobo.303.3">We can begin our TDD efforts around this component and see where that leads us. </span><span class="koboSpan" id="kobo.303.4">This is a bottom-up approach to the design, composing the whole from </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">smaller parts.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">If we consider a simplified version of our Wordz application structure, we can illustrate the inside-out approach </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.307.1"><img alt="Figure 12.6 – Inside-out development" src="image/Figure_12.6_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.308.1">Figure 12.6 – Inside-out development</span></p>
<p><span class="koboSpan" id="kobo.309.1">The diagram shows the </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">Score</span></strong><span class="koboSpan" id="kobo.311.1"> component highlighted, as that is where we will start development using an inside-out approach. </span><span class="koboSpan" id="kobo.311.2">The other software components are grayed-out. </span><span class="koboSpan" id="kobo.311.3">We are not</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.312.1"> designing those pieces yet. </span><span class="koboSpan" id="kobo.312.2">We would start with a test for some behavior we wanted the </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">Score</span></strong><span class="koboSpan" id="kobo.314.1"> component to have. </span><span class="koboSpan" id="kobo.314.2">We would work our way outward from that </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">starting point.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">This style of inside-out TDD is also</span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.317.1"> known as </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">Classicist TDD</span></strong><span class="koboSpan" id="kobo.319.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">Chicago TDD</span></strong><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">It is the approach originally </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.322.1">described by Kent Beck in his book </span><em class="italic"><span class="koboSpan" id="kobo.323.1">Test-Driven Development by Example</span></em><span class="koboSpan" id="kobo.324.1">. </span><span class="koboSpan" id="kobo.324.2">The basic idea is to start anywhere to create any useful building block for our code. </span><span class="koboSpan" id="kobo.324.3">We then develop a progressively larger unit that incorporates the earlier </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">building blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">The inside-out approach</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.327.1"> has a </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">few advantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.329.1">Quick start to development</span></strong><span class="koboSpan" id="kobo.330.1">: We test pure Java code first in this approach, using the familiar tools of JUnit and AssertJ. </span><span class="koboSpan" id="kobo.330.2">There is no setup for user interfaces, web service stubs, or databases. </span><span class="koboSpan" id="kobo.330.3">There is no setup of user interface testing tools. </span><span class="koboSpan" id="kobo.330.4">We just dive right in and code </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">using Java.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.332.1">Good for known designs</span></strong><span class="koboSpan" id="kobo.333.1">: As we gain experience, we recognize some problems as having known solutions. </span><span class="koboSpan" id="kobo.333.2">Perhaps we have written something similar before. </span><span class="koboSpan" id="kobo.333.3">Maybe we know </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.334.1">a useful collection of design patterns that will work. </span><span class="koboSpan" id="kobo.334.2">In these cases, starting from the interior structure of our code </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">makes sense.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.336.1">Works well with hexagonal architecture</span></strong><span class="koboSpan" id="kobo.337.1">: Inside-out TDD starts work inside the inner hexagon, the domain model of our application. </span><span class="koboSpan" id="kobo.337.2">The adapter layer forms a natural boundary. </span><span class="koboSpan" id="kobo.337.3">An inside-out design is a good fit for this </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">design approach.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.339.1">Naturally, nothing is perfect and inside-out TDD is no exception. </span><span class="koboSpan" id="kobo.339.2">Some challenges include </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.341.1">Possibility of waste</span></strong><span class="koboSpan" id="kobo.342.1">: We begin</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.343.1"> inside-out TDD with our best guess of some components that will be needed. </span><span class="koboSpan" id="kobo.343.2">Sometimes, it emerges later that either we don’t need these components, or we should refactor the features somewhere else. </span><span class="koboSpan" id="kobo.343.3">Our initial effort is in some sense wasted – although it will have helped us progress to </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">this point.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.345.1">Risk of implementation lock-in</span></strong><span class="koboSpan" id="kobo.346.1">: Related to the previous point, sometimes we move on from an initial design having learned more about the problem we’re solving, but we don’t always recognize a sunk cost. </span><span class="koboSpan" id="kobo.346.2">There is always a temptation to keep using a component we wrote earlier even if it no longer fits as well, just because we invested that time and money into </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">creating it.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.348.1">Inside-out TDD is a useful approach and was first popularized by Kent Beck’s book. </span><span class="koboSpan" id="kobo.348.2">However, if we can start inside-out, what about turning that around? </span><span class="koboSpan" id="kobo.348.3">What if we started from the outside of the system and worked our way in? </span><span class="koboSpan" id="kobo.348.4">The next section reviews this </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">alternative approach.</span></span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.350.1">Testing from the outside in</span></h1>
<p><span class="koboSpan" id="kobo.351.1">Given that inside-out TDD has some challenges as well as strengths, what difference does outside-in TDD make? </span><span class="koboSpan" id="kobo.351.2">This section reviews the alternative approach of starting from outside </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">Outside-in TDD begins </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.354.1">with the external users of the system. </span><span class="koboSpan" id="kobo.354.2">They may be human users or machines, consuming some API offered by our software. </span><span class="koboSpan" id="kobo.354.3">This approach to TDD begins by simulating some external input, such as the submission of a </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">web form.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">The test will typically use some kind of test framework – such as Selenium or Cypress for web applications – that allows the test to call up a specific web view, and simulate typing text into fields, then clicking a submit button. </span><span class="koboSpan" id="kobo.356.2">We can then make this test pass in the normal way, only we will have written some code that directly deals with the input from a user this time. </span><span class="koboSpan" id="kobo.356.3">In our hexagonal architecture model, we will end up writing the user input </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">adapter first.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">We can illustrate the outside-in approach </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.360.1"><img alt="Figure 12.7 – Outside-in view" src="image/Figure_12.7_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.361.1">Figure 12.7 – Outside-in view</span></p>
<p><span class="koboSpan" id="kobo.362.1">We can see that a component called </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">Web API</span></strong><span class="koboSpan" id="kobo.364.1"> is the focus of our attention here. </span><span class="koboSpan" id="kobo.364.2">We will write a test that sets up enough of our application to run a component that handles web requests. </span><span class="koboSpan" id="kobo.364.3">The test will form a web request, send it to our software, and then assert that the correct web response is sent. </span><span class="koboSpan" id="kobo.364.4">The test may also instrument the software itself to verify it takes the expected actions internally. </span><span class="koboSpan" id="kobo.364.5">We start testing from the outside, and as development progresses, we </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">move inwards.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">This approach to TDD is described in the book, </span><em class="italic"><span class="koboSpan" id="kobo.367.1">Growing Object-Oriented Software, Guided by Tests</span></em><span class="koboSpan" id="kobo.368.1">, by Steve Freeman and Nat Pryce. </span><span class="koboSpan" id="kobo.368.2">The technique is also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">London</span></strong><span class="koboSpan" id="kobo.370.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">Mockist</span></strong><span class="koboSpan" id="kobo.372.1"> school of TDD. </span><span class="koboSpan" id="kobo.372.2">The reasons for that are the location where it was first popularized and its use of </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.373.1">mock objects, respectively. </span><span class="koboSpan" id="kobo.373.2">To test drive the user input adapter as the first component we tackle, we need a test double in place of the rest of the software. </span><span class="koboSpan" id="kobo.373.3">Mocks and stubs are an inherent part of </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">outside-in TDD.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">Outside-in TDD, predictably enough, has </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.376.1">some strengths and weaknesses. </span><span class="koboSpan" id="kobo.376.2">Let’s take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">strengths first:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.378.1">Less waste</span></strong><span class="koboSpan" id="kobo.379.1">: Outside-in TDD encourages a quite minimal approach to satisfying external behavior. </span><span class="koboSpan" id="kobo.379.2">The code produced tends to be highly customized to the application at hand. </span><span class="koboSpan" id="kobo.379.3">In contrast, inside-out TDD focuses on building a robust domain model, perhaps providing more functionality than will end up in use </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">by users.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.381.1">Delivers user value quickly</span></strong><span class="koboSpan" id="kobo.382.1">: Because we start from a test that simulates a user request, the code we write will satisfy a user request. </span><span class="koboSpan" id="kobo.382.2">We can deliver value to users </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">almost immediately.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.384.1">Outside-in TDD also has</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.385.1"> some weaknesses, or at </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">least limitations:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.387.1">Fewest abstractions</span></strong><span class="koboSpan" id="kobo.388.1">: On a related note, when writing the minimum code necessary to make a test pass, outside-in TDD may lead to application logic being present in the adapter layer. </span><span class="koboSpan" id="kobo.388.2">This can be refactored later but can lead to a less organized </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">code base.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.390.1">Inverted test pyramid</span></strong><span class="koboSpan" id="kobo.391.1">: If all our TDD test efforts focus on the external responses, they are, in fact, end-to-end tests. </span><span class="koboSpan" id="kobo.391.2">This opposes the recommended pattern of the test pyramid, which prefers faster unit tests inside the code base. </span><span class="koboSpan" id="kobo.391.3">Having only slower, less repeatable end-to-end tests can </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">slow development.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.393.1">The two traditional schools of TDD both offer certain advantages in terms of how they affect the software design we will produce. </span><span class="koboSpan" id="kobo.393.2">The next section looks at the impact of hexagonal architecture. </span><span class="koboSpan" id="kobo.393.3">By starting from the idea that we will use a hexagonal approach, we can combine the advantages of both schools of TDD. </span><span class="koboSpan" id="kobo.393.4">We end up defining a natural test boundary between the inside-out and outside-in approaches </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">to TDD.</span></span></p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.395.1">Defining test boundaries with hexagonal architecture</span></h1>
<p><span class="koboSpan" id="kobo.396.1">The topic for this section is how </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.397.1">using a hexagonal architecture impacts TDD. </span><span class="koboSpan" id="kobo.397.2">Knowing that we are using hexagonal architecture presents useful boundaries for the different kinds of tests in the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">test pyramid.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">In one sense, how </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.400.1">we organize our code base does not affect our use of TDD. </span><span class="koboSpan" id="kobo.400.2">The internal structure of the code is simply an implementation detail, one of many possibilities that will make our tests pass. </span><span class="koboSpan" id="kobo.400.3">That being said, some ways of structuring our code are easier to work with than others. </span><span class="koboSpan" id="kobo.400.4">Using hexagonal architecture as a foundational structure does offer TDD some advantages. </span><span class="koboSpan" id="kobo.400.5">The reason why lies with the use of ports </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">and adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">We’ve learned from previous chapters that it is easier to write tests for code where we can control the environment in which the code runs. </span><span class="koboSpan" id="kobo.402.2">We’ve seen how the test pyramid gives a structure to the</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.403.1"> different kinds of tests we write. </span><span class="koboSpan" id="kobo.403.2">Using the ports and adapters approach provides clean boundaries for each kind of test in the code. </span><span class="koboSpan" id="kobo.403.3">Better yet, it provides us with an opportunity to bring even more tests to the unit </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">test level.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Let’s review what kinds of tests best fit each layer of software written using </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">hexagonal architecture.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.407.1">Inside-out works well with the domain model</span></h2>
<p><span class="koboSpan" id="kobo.408.1">Classic TDD uses an inside-out development approach, where we choose a certain software component to test-drive. </span><span class="koboSpan" id="kobo.408.2">This component may be a single function, a single class, or a small cluster of classes that collaborate with each other. </span><span class="koboSpan" id="kobo.408.3">We use TDD to test this component as a whole given the </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.409.1">behaviors it offers to </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">its consumers.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">This kind of component resides in the domain model – the </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">inner hexagon:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.413.1"><img alt="Figure 12.8 – Testing the domain logic" src="image/Figure_12.8_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.414.1">Figure 12.8 – Testing the domain logic</span></p>
<p><span class="koboSpan" id="kobo.415.1">The key advantage is that these components are easy to write tests for and those tests run very quickly. </span><span class="koboSpan" id="kobo.415.2">Everything lives in computer memory and there are no external systems to </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">contend with.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">A further advantage is that complex behaviors can be unit-tested here at a very fine granularity. </span><span class="koboSpan" id="kobo.417.2">An example would be testing all the state transitions within a finite state machine used to control </span><a id="_idIndexMarker698"/><span class="No-Break"><span class="koboSpan" id="kobo.418.1">a workflow.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">One disadvantage is that these fine-grained domain logic tests can get lost if a larger refactoring takes place. </span><span class="koboSpan" id="kobo.419.2">If the component under fine-grained tests gets removed during refactoring, its corresponding test will be lost – but the behavior will still exist somewhere else as a result of that refactoring. </span><span class="koboSpan" id="kobo.419.3">One thing refactoring tools cannot do is figure out what test code relates to the production code being refactored, and automatically refactor the test code to fit the </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">new structure.</span></span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.421.1">Outside-in works well with adapters</span></h2>
<p><span class="koboSpan" id="kobo.422.1">Mockist-style TDD approaches development from an outside-in perspective. </span><span class="koboSpan" id="kobo.422.2">This is a great match for our adapter layer in a hexagonal architecture. </span><span class="koboSpan" id="kobo.422.3">We can assume that the core application logic resides in the domain model and has been tested there with fast unit tests. </span><span class="koboSpan" id="kobo.422.4">This leaves adapters in</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.423.1"> the outer hexagon to be tested by </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">These integration tests only need to cover the behavior provided by the adapter. </span><span class="koboSpan" id="kobo.425.2">This should be very limited in scope. </span><span class="koboSpan" id="kobo.425.3">The adapter code maps from the formats used by the external system only to what is required by the domain model. </span><span class="koboSpan" id="kobo.425.4">It has no </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">other function.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">This structure naturally follows the test pyramid guidelines. </span><span class="koboSpan" id="kobo.427.2">Fewer integration tests are required. </span><span class="koboSpan" id="kobo.427.3">Each integration test has only a small scope of behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">to test:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.429.1"><img alt="Figure 12.9 – Testing adapters" src="image/Figure_12.9_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.430.1">Figure 12.9 – Testing adapters</span></p>
<p><span class="koboSpan" id="kobo.431.1">This style of testing verifies the adapter in isolation. </span><span class="koboSpan" id="kobo.431.2">It will require some end-to-end happy-path testing to show that the system as a whole has used the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">correct adapters.</span></span></p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.433.1">User stories can be tested across the domain model</span></h2>
<p><span class="koboSpan" id="kobo.434.1">One benefit of having a </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.435.1">domain model containing all the application logic is that we can test the logic of complete user stories. </span><span class="koboSpan" id="kobo.435.2">We can replace the adapters with test doubles to simulate typical responses from the external systems. </span><span class="koboSpan" id="kobo.435.3">We can then use FIRST unit tests to exercise complete </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">user stories:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.437.1"><img alt="Figure 12.10 – Testing user stories" src="image/Figure_12.10_B18384.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.438.1">Figure 12.10 – Testing user stories</span></p>
<p><span class="koboSpan" id="kobo.439.1">The advantages are the speed and repeatability of FIRST unit tests. </span><span class="koboSpan" id="kobo.439.2">In other approaches to structuring our code, we might only be able to exercise a user story as an end-to-end test in a test environment, with all associated disadvantages. </span><span class="koboSpan" id="kobo.439.3">Having the ability to test user story logic at the unit level – across the whole domain model – gives us a high degree of confidence that our application will satisfy the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">users’ needs.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">To ensure this confidence, we need the integration tests of the adapter layer, plus some end-to-end tests across selected user stories, confirming the application is wired and configured correctly as a whole. </span><span class="koboSpan" id="kobo.441.2">These higher-level tests do not need to be as detailed as the user story tests performed around the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">domain model.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">Having a good set of user story tests around the domain model also enables large-scale refactoring within the domain model. </span><span class="koboSpan" id="kobo.443.2">We can have the confidence to restructure the inner hexagon guided by these broadly scoped user </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">story tests.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">This section has shown us</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.446.1"> how to relate the different kinds of tests in the test pyramid to the different layers in a </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">hexagonal architecture.</span></span></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.448.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.449.1">This chapter has discussed the various stages at which we can write tests – before we write code, after we write code, or possibly even never. </span><span class="koboSpan" id="kobo.449.2">It has made a case for writing tests before code as providing the most value in terms of valid execution path coverage and developer ease. </span><span class="koboSpan" id="kobo.449.3">We went on to review how hexagonal architecture interacts with both TDD and the test pyramid, leading to an opportunity to bring user story testing into the realm of FIRST unit tests. </span><span class="koboSpan" id="kobo.449.4">This allows the fast and repeatable validation of the core logic driving our </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">user stories.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">In the next chapter – and throughout the third part of the book – we will return to building our Wordz application. </span><span class="koboSpan" id="kobo.451.2">We will be making full use of all the techniques we’ve learned so far. </span><span class="koboSpan" id="kobo.451.3">We will begin inside-out with </span><a href="B18384_13.xhtml#_idTextAnchor275"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.452.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.453.1">, </span><em class="italic"><span class="koboSpan" id="kobo.454.1">Driving the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.455.1">Domain Layer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">.</span></span></p>
<h1 id="_idParaDest-263"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.457.1">Questions and answers</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.458.1">Is writing tests shortly after code just as good as writing </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">test-first TDD?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.460.1">Some research seems to suggest that, although it is very difficult to set up a controlled experiment with statistically significant results in this area. </span><span class="koboSpan" id="kobo.460.2">One factor we can consider concerns our own personal discipline. </span><span class="koboSpan" id="kobo.460.3">If we write tests later, are we sure we will cover everything necessary? </span><span class="koboSpan" id="kobo.460.4">I personally have concluded that I would not remember all I needed to cover and would need to make notes. </span><span class="koboSpan" id="kobo.460.5">Those notes are perhaps best captured in the form of test code, leading to a preference for </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">test-first TDD.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.462.1">How does hexagonal architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">affect TDD?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.464.1">Hexagonal architecture provides a clean separation between a pure, inner core of domain logic and the outside world. </span><span class="koboSpan" id="kobo.464.2">This allows us to mix and match the two schools of TDD knowing that there is a firm boundary in the design up to which we can code. </span><span class="koboSpan" id="kobo.464.3">The inner domain model supports entire use cases being unit-tested, as well as any fine-grained unit tests for detailed behavior we feel are necessary. </span><span class="koboSpan" id="kobo.464.4">External adapters naturally suit integration tests, but these tests don’t have to cover much, as the logic relates to our domain lives in the inner </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">domain model.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.466.1">What happens if we abandon </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">testing completely?</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.468.1">We export the responsibility to the end user who will test it for us. </span><span class="koboSpan" id="kobo.468.2">We risk loss in revenue, reputation, and user retention. </span><span class="koboSpan" id="kobo.468.3">Sometimes, we cannot perfectly recreate the final environment in which the system will be used. </span><span class="koboSpan" id="kobo.468.4">In this case, making sure we have fully characterized and tested our system as closely as we can seems wise. </span><span class="koboSpan" id="kobo.468.5">We can at least minimize the </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">known risks.</span></span></p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.470.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.471.1">An explanation of the Cyclomatic Complexity </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">metric: </span></span><a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity"><span class="No-Break"><span class="koboSpan" id="kobo.473.1">https://en.wikipedia.org/wiki/Cyclomatic_complexity</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.474.1">Continuous Delivery</span></em><span class="koboSpan" id="kobo.475.1">, Jez Humble and Dave Farley, </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">ISBN 978-0321601919</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.477.1">Working Effectively with Legacy Code</span></em><span class="koboSpan" id="kobo.478.1">, Michael Feathers, </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">ISBN 978-0131177055</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.480.1">Test-Driven Development by Example</span></em><span class="koboSpan" id="kobo.481.1">, Kent Beck, </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">ISBN 978-0321146533</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.483.1">Growing Object-Oriented Software, Guided by Tests</span></em><span class="koboSpan" id="kobo.484.1">, Steve Freeman and Nat Pryce, </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">ISBN 9780321503626</span></span></li>
<li><a href="https://arxiv.org/pdf/1611.05994.pdf"><span class="No-Break"><span class="koboSpan" id="kobo.486.1">https://arxiv.org/pdf/1611.05994.pdf</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.487.1">Why Research on Test-Driven Development is Inconclusive?</span></em><span class="koboSpan" id="kobo.488.1">, Ghafari, Gucci, Gross, and </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">Felderer: </span></span><a href="https://arxiv.org/pdf/2007.09863.pdf"><span class="No-Break"><span class="koboSpan" id="kobo.490.1">https://arxiv.org/pdf/2007.09863.pdf</span></span></a></li>
</ul>
</div>
<div>
<div class="IMG---Figure" id="_idContainer099">
</div>
</div>


<div class="Content" id="_idContainer100">
<h1 id="_idParaDest-265"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.1.1">Part 3: </span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2.1">Real-World TDD</span></span></h1>
</div>
<div id="_idContainer101">
<p><em class="italic"><span class="koboSpan" id="kobo.3.1">Part 3</span></em><span class="koboSpan" id="kobo.4.1"> is where we apply all the techniques we have learned to complete our application. </span><span class="koboSpan" id="kobo.4.2">Wordz is a web service that plays a word guessing game. </span><span class="koboSpan" id="kobo.4.3">We build on the core domain logic we have already built, adding storage via a Postgres database accessed using SQL and providing web access by implementing an HTTP REST API. </span></p>
<p><span class="koboSpan" id="kobo.5.1">We will use integration tests to test-drive our database and API implementations, making use of test frameworks that simplify these tasks. </span><span class="koboSpan" id="kobo.5.2">In the final chapter of the book, we will bring everything together to confidently run our test-driven </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Wordz application.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following chapters:</span></span></p>
<ul>
<li><a href="B18384_13.xhtml#_idTextAnchor275"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Driving the Domain Layer</span></em></li>
<li><a href="B18384_14.xhtml#_idTextAnchor293"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Driving the Database Layer</span></em></li>
<li><a href="B18384_15.xhtml#_idTextAnchor306"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 15</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Driving the Web Layer</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer102">
</div>
</div>
<div>
<div id="_idContainer103">
</div>
</div>
</body></html>