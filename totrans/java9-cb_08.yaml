- en: Better Management of the OS Process
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地管理操作系统进程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下菜谱：
- en: Spawning a new process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成新进程
- en: Redirecting the process output and error streams to file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将进程输出和错误流重定向到文件
- en: Changing the working directory of a subprocess
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改子进程的工作目录
- en: Setting the environment variable for a subprocess
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为子进程设置环境变量
- en: Running shell scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 shell 脚本
- en: Obtaining the process information of the current JVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前 JVM 的进程信息
- en: Obtaining the process information of the spawned process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取生成进程的进程信息
- en: Managing the spawned process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理生成的进程
- en: Enumerating live processes in the system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举系统中的活动进程
- en: Connecting multiple processes using pipe
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道连接多个进程
- en: Managing subprocesses
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理子进程
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: How often have you ended up writing code that spawns a new process? Not often.
    However, there would be situations that ask for writing such code. In such cases,
    you resort to using a third-party API such as Apache Commons Exec ([https://commons.apache.org/proper/commons-exec/](https://commons.apache.org/proper/commons-exec/))
    and the like. Why was this? Wasn't the Java API sufficient? No, it wasn't, at
    least until Java 9\. Now with Java 9, we have quite a few more features added
    to the process API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次最终编写了生成新进程的代码？不经常。然而，会有一些需要编写此类代码的情况。在这种情况下，你会求助于使用第三方 API，例如 Apache Commons
    Exec ([https://commons.apache.org/proper/commons-exec/](https://commons.apache.org/proper/commons-exec/))
    等。为什么会这样？Java API 不够用吗？不，它不够用，至少直到 Java 9。现在，随着 Java 9 的推出，我们为进程 API 添加了许多新特性。
- en: 'Until Java 7, redirecting the input, output, and error streams was not trivial.
    With Java 7, there were new APIs introduced, which allowed the redirecting of
    the input, output, and error to other processes (pipe), to a file, or to a standard
    input/output. Then in Java 8, there were a few more APIs introduced. In Java 9,
    there are new APIs for the following areas:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 7 之前，重定向输入、输出和错误流并不简单。Java 7 引入了一些新的 API，允许将输入、输出和错误重定向到其他进程（管道）、文件或标准输入/输出。然后在
    Java 8 中，又引入了一些新的 API。在 Java 9 中，为以下领域引入了新的 API：
- en: Get the process information, such as **process ID** (**PID**), the user who
    launched the process, the time it has been running for, and so on
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取进程信息，例如**进程 ID**（**PID**）、启动进程的用户、进程运行的时间等
- en: Enumerate the processes running in the system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举系统中运行的进程
- en: Manage the subprocesses and get access to the process tree by navigating up
    the process hierarchy
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在进程层次结构中向上导航来管理子进程并获取进程树访问权限
- en: In this chapter, we will look at a few recipes that will help you explore the
    new things in the process API, and you will also get to know the changes that
    have been introduced from the times of `Runtime.getRuntime().exec()`. And you
    all know that using that was a crime.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨一些菜谱，这些菜谱将帮助您探索进程 API 中的新特性，您还将了解从 `Runtime.getRuntime().exec()`
    时代引入的变化。你们都知道使用那个是犯罪。
- en: 'All the recipes can only be executed on the Linux platform because we will
    be using Linux-specific commands while spawning a new process from Java code. There
    are two ways to execute the script `run.sh` on Linux:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些菜谱只能在 Linux 平台上执行，因为我们将在从 Java 代码中生成新进程时使用 Linux 特定的命令。在 Linux 上执行 `run.sh`
    脚本有两种方式：
- en: '`sh run.sh`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sh run.sh`'
- en: '`chmod +x run.sh && ./run.sh`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod +x run.sh && ./run.sh`'
- en: Spawning a new process
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成新进程
- en: In this recipe, we will see how to spawn a new process using `ProcessBuilder`.
    We will also see how to make use of the input, output, and error streams. This
    should be a very straightforward and common recipe. However, the aim of introducing
    this is to make this chapter a bit more complete and not just to focus on Java
    9 features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用 `ProcessBuilder` 生成新进程。我们还将看到如何利用输入、输出和错误流。这应该是一个非常简单且常见的菜谱。然而，引入这个菜谱的目的是使这一章更加完整，而不仅仅是关注
    Java 9 的特性。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There is a command in Linux called `free`, which shows the amount of RAM free
    and used by the system. It accepts an option, `-m`, to show the output in megabytes.
    So, just running free `-m` gives us the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中有一个名为 `free` 的命令，它显示系统空闲和使用的 RAM 量。它接受一个选项 `-m`，以兆字节为单位显示输出。因此，只需运行 `free
    -m` 就会得到以下输出：
- en: '![](img/48b5277b-4cb0-4391-bab4-03fc949e5b9f.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48b5277b-4cb0-4391-bab4-03fc949e5b9f.png)'
- en: We will be running the preceding code from within the Java program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Java 程序内部运行前面的代码。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create an instance of `ProcessBuilder` by providing the required command and
    its options:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供所需的命令及其选项来创建`ProcessBuilder`的实例：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An alternate way to specify the command and options is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 指定命令和选项的另一种方法是：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Set up the input and output streams for the process builder and other properties,
    such as the directory of execution and environment variables. After that, invoke
    `start()` on the `ProcessBuilder` instance to spawn the process and get a reference
    to the `Process` object:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置进程构建器的输入和输出流以及其他属性，如执行目录和环境变量。之后，在`ProcessBuilder`实例上调用`start()`以启动进程并获取`Process`对象的引用：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `inheritIO()` function sets the standard I/O of the spawned subprocess to
    be the same as that of the current Java process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`inheritIO()`函数将产生的子进程的标准I/O设置为与当前Java进程相同。'
- en: 'We then wait for the completion of the process, or for 1 second, whichever
    is sooner, as shown in the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们等待进程完成，或者等待1秒，以先到者为准，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If it doesn't complete in the time specified, then we kill the process by invoking
    the `destroyForcibly()` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在指定的时间内没有完成，那么我们将通过调用`destroyForcibly()`方法来终止该过程。
- en: 'Compile and run the code by using the following commands:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行代码：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output we get is as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到的结果如下：
- en: '![](img/ceba2731-e3c6-47fc-9840-45df293995d7.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ceba2731-e3c6-47fc-9840-45df293995d7.png)'
- en: The code for this recipe can be found at `chp8/1_spawn_new_process`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的代码可以在`chp8/1_spawn_new_process`中找到。
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are two ways to let `ProcessBuilder` know which command to run:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法让`ProcessBuilder`知道要运行哪个命令：
- en: By passing the command and its options to the constructor while creating the
    `ProcessBuilder` object.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`ProcessBuilder`对象时，通过将命令及其选项传递给构造函数。
- en: By passing the command and its options as parameters to the `command()` method
    of the `ProcessBuilder` object.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将命令及其选项作为参数传递给`ProcessBuilder`对象的`command()`方法。
- en: 'Before spawning the process, we can do the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动进程之前，我们可以做以下操作：
- en: We can change the directory of execution by using the `directory()` method
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`directory()`方法更改执行目录
- en: We can redirect the input stream, output stream, and error streams to file or
    to another process
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将输入流、输出流和错误流重定向到文件或另一个进程
- en: We can provide the required environment variables for the subprocess
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为子进程提供所需的环境变量
- en: We will see all these activities in their respective recipes in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的相应菜谱中看到所有这些活动。
- en: 'A new process is spawned when the `start()` method is invoked and the caller
    gets a reference to this subprocess in the form of an instance of the `Process`
    class. Using this `Process` object, we can do a lot of things, such as the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`start()`方法时，会启动一个新的进程，调用者会以`Process`类实例的形式获得对这个子进程的引用。使用这个`Process`对象，我们可以做很多事情，例如以下内容：
- en: Get information about the process, including its PID
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取关于进程的信息，包括其PID
- en: Get the output and error streams
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取输出和错误流
- en: Check for the completion of the process
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查过程的完成情况
- en: Destroy the process
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止进程
- en: Associate the tasks to be performed once the process completes
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务与进程完成后要执行的操作关联起来
- en: Check for the subprocesses spawned by the process
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查由该进程产生的子进程
- en: Find the parent process of the process if it exists
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在，找到该过程的所有父过程
- en: In our recipe, we `waitFor` 1 second or the completion of the process (whichever
    occurs first). If the process has completed, then `waitFor` returns `true`; else,
    it returns `false`. If the process doesn't complete, we can kill the process by
    invoking the `destroyForcibly()` method on the `Process` object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的菜谱中，我们`waitFor` 1秒或等待进程完成（以先到者为准）。如果进程已经完成，则`waitFor`返回`true`；否则，返回`false`。如果进程没有完成，我们可以通过在`Process`对象上调用`destroyForcibly()`方法来终止进程。
- en: Redirecting the process output and error streams to file
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将进程的输出和错误流重定向到文件
- en: In this recipe, we will see how to deal with the output and error streams of
    a process spawned from the Java code. We will write the output or error produced
    by the spawned process to a file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何处理从Java代码中产生的过程的输出和错误流。我们将把产生的过程的输出或错误写入文件。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will make use of the `iostat` command. This command is used
    for reporting the CPU and I/O statistics for different devices and partitions.
    Let''s run the command and see what it reports:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`iostat`命令。这个命令用于报告不同设备和分区的CPU和I/O统计信息。让我们运行这个命令并看看它报告了什么：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In some Linux distributions, such as Ubuntu, `iostat` is not installed by default.
    You can install the utility by running `sudo apt-get install sysstat`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 Linux 发行版中，例如 Ubuntu，`iostat` 不是默认安装的。你可以通过运行 `sudo apt-get install sysstat`
    来安装这个实用工具。
- en: 'The output of the preceding command is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/693e431b-2fd6-4e5e-b98b-d5de51ea76d6.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/693e431b-2fd6-4e5e-b98b-d5de51ea76d6.png)'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new `ProcessBuilder` object by specifying the command to be executed:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定要执行的命令创建一个新的 `ProcessBuilder` 对象：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Redirect the output and error streams to the file''s output and error, respectively:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出和错误流分别重定向到文件的输出和错误：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Start the process, and wait for it to complete:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程，并等待其完成：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Read the content of the output file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输出文件的内容：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Read the content of the error file. This is created only if there is some error
    in the command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取错误文件的内容。这仅在命令中有错误时创建：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Step 4 and 5 are for our reference. This has nothing to do with `ProcessBuilder`
    or the process spawned. Using these two lines of code, we can inspect what was
    written to the output and error files by the process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 步和第 5 步仅供参考。这与 `ProcessBuilder` 或生成的进程无关。使用这两行代码，我们可以检查进程写入输出和错误文件的内容。
- en: The complete code can be found at `chp8/2_redirect_to_file`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在 `chp8/2_redirect_to_file` 找到。
- en: 'Compile the code by using the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译代码：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the code by using the following command:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行代码：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will get the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![](img/259d9294-e4d8-4e41-9e8b-f4e67b81c859.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/259d9294-e4d8-4e41-9e8b-f4e67b81c859.png)'
- en: We can see that as the command executed successfully; there is nothing in the
    error file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，命令执行成功时，错误文件中没有内容。
- en: There is more...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can provide an erroneous command to `ProcessBuilder` and then see the error
    get written to the error file and nothing in the output file. You could do this
    by changing the `ProcessBuilder` instance creation as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `ProcessBuilder` 提供一个错误的命令，然后看到错误被写入错误文件，而输出文件中没有任何内容。你可以通过以下方式更改 `ProcessBuilder`
    实例的创建：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compile and run by using the commands given earlier in the *How to do it...*
    section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *如何操作...* 部分中给出的命令编译和运行。
- en: 'You will see that there is an error reported in the error file but nothing
    in the output file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到错误文件中报告了一个错误，但输出文件中没有内容：
- en: '![](img/1f1fc4ab-0a88-4efd-ba11-2b29135604a8.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f1fc4ab-0a88-4efd-ba11-2b29135604a8.png)'
- en: Changing the working directory of a subprocess
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变子进程的工作目录
- en: 'Often, you would want a process to be executed in the context of some path,
    such as listing the files in some directory. In order to do so, we will have to
    tell `ProcessBuilder` to launch the process in the context of a given location.
    We can achieve this by using the `directory()` method. This method serves two
    purposes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能会希望在一个路径的上下文中执行一个进程，例如列出某个目录中的文件。为了做到这一点，我们必须告诉 `ProcessBuilder` 在给定位置启动进程。我们可以通过使用
    `directory()` 方法来实现这一点。此方法有两个目的：
- en: Returns the current directory of execution when we don't pass any parameter.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们不传递任何参数时，返回执行当前目录。
- en: Sets the current directory of execution to the passed value when we pass a parameter.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们传递一个参数时，将执行当前目录设置为传递的值。
- en: In this recipe, we will see how to execute the `tree` command to recursively
    traverse all the directories from the current directory and print it in the form
    of a tree.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将看到如何执行 `tree` 命令以递归遍历当前目录下的所有目录，并以树形结构打印出来。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Generally, the `tree` command doesn''t come preinstalled. So, you will have
    to install the package that contains the command. To install on an Ubuntu/Debian-based
    system, run the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`tree` 命令不是预安装的。因此，你必须安装包含该命令的软件包。在基于 Ubuntu/Debian 的系统上安装，运行以下命令：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To install on Linux, which supports the `yum` package manager, run the following
    command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持 `yum` 软件包管理器的 Linux 上安装，运行以下命令：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To verify your installation, just run the `tree` command, and you should be
    able to see the current directory structure printed. For me, it''s something like
    this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证你的安装，只需运行 `tree` 命令，你应该能够看到当前目录结构被打印出来。对我来说，它看起来像这样：
- en: '![](img/d78da25f-a88e-4949-8854-e0d13f107208.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d78da25f-a88e-4949-8854-e0d13f107208.png)'
- en: There are multiple options supported by the `tree` command. It's for you to
    explore.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree` 命令支持多个选项。这需要你自己去探索。'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new `ProcessBuilder` object:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `ProcessBuilder` 对象：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Set the command to `tree` and the output and error to the same as that of the
    current Java process:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令设置为 `tree`，并将输出和错误设置为与当前 Java 进程相同：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set the directory to whatever directory you want. I set it as the root folder:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录设置为任何你想要的目录。我将其设置为根文件夹：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start the process and wait for it to exit:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程并等待其退出：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compile and run using the following commands:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output will be the recursive contents of the directory, specified in the
    `directory()` method of the `ProcessBuilder` object, printed in a tree like format.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将是 `ProcessBuilder` 对象的 `directory()` 方法中指定的目录的递归内容，以树形格式打印。
- en: The complete code can be found at `chp8/2_redirect_to_file`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在 `chp8/2_redirect_to_file` 找到。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `directory()` method accepts the path of the working directory for `Process`.
    The path is specified as an instance of `File`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`directory()` 方法接受 `Process` 的工作目录路径。路径指定为一个 `File` 实例。'
- en: Setting the environment variable for a subprocess
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置子进程的环境变量
- en: Environment variables are just like any other variables that we have in our
    programming languages. They have a name and hold some value, which can be varied.
    These are used by the Linux/Windows commands or the shell/batch scripts to perform
    different operations. These are called environment variables because they are
    present in the environment of the process/command/script getting executed. Generally,
    the process inherits the environment variables from the parent process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量就像我们在编程语言中使用的任何其他变量一样。它们有一个名称并持有一些值，这些值可以变化。这些变量被 Linux/Windows 命令或 shell/batch
    脚本用来执行不同的操作。这些被称为环境变量，因为它们存在于正在执行的过程/命令/脚本的运行环境中。通常，进程会从父进程继承环境变量。
- en: They are accessed in different ways in different operating systems. In Windows,
    they are accessed as `%ENVIRONMENT_VARIABLE_NAME%`, and in Unix-based operating
    systems, they are accessed as `$ENVIRONMENT_VARIABLE_NAME`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的操作系统中，它们以不同的方式访问。在 Windows 中，它们以 `%ENVIRONMENT_VARIABLE_NAME%` 的形式访问，而在基于
    Unix 的操作系统中，它们以 `$ENVIRONMENT_VARIABLE_NAME` 的形式访问。
- en: In Unix-based systems, you can use the `printenv` command to print all the environment
    variables available for the process, and in Windows-based systems, you can use
    the `SET` command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Unix 的系统中，你可以使用 `printenv` 命令来打印进程可用的所有环境变量，而在基于 Windows 的系统中，你可以使用 `SET`
    命令。
- en: In this recipe, we will pass some environment variables to our subprocess and
    make use of the `printenv` command to print all the environment variables available.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将传递一些环境变量给我们的子进程，并使用 `printenv` 命令来打印所有可用的环境变量。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create an instance of `ProcessBuilder`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ProcessBuilder` 实例：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Set the command to `printenv` and the output and error streams to the same
    as that of the current Java process:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令设置为 `printenv`，并将输出和错误流设置为与当前 Java 进程相同：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Provide the environment variables, `COOKBOOK_VAR1` with the value, `First variable`, `COOKBOOK_VAR2` with
    the value, `Second variable`, and `COOKBOOK_VAR3` with the value, `Third variable`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供环境变量，`COOKBOOK_VAR1` 的值为 `First variable`，`COOKBOOK_VAR2` 的值为 `Second variable`，以及
    `COOKBOOK_VAR3` 的值为 `Third variable`：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Start the process and wait for it to complete:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程并等待其完成：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The complete code for this recipe can be found at `chp8/4_environment_variables`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整代码可以在 `chp8/4_environment_variables` 找到。
- en: 'Compile and run the code by using the following commands:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行代码：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output you get is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的输出如下：
- en: '![](img/d4b2d50e-1cc7-44d2-915b-5a94a0a93849.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4b2d50e-1cc7-44d2-915b-5a94a0a93849.png)'
- en: You can see the three variables printed among other variables.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在其他变量中看到打印出的三个变量。
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you invoke the `environment()` method on the instance of `ProcessBuilder`,
    it copies the environment variables of the current process, populates them in
    an instance of `HashMap`, and returns it to the caller code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `ProcessBuilder` 实例上调用 `environment()` 方法时，它会复制当前进程的环境变量，将它们填充到一个 `HashMap`
    实例中，并将其返回给调用代码。
- en: All the work of loading the environment variables is done by a package private
    final class, `ProcessEnvironment`, which actually extends `HashMap`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 加载环境变量的所有工作都由一个包私有的最终类 `ProcessEnvironment` 完成，它实际上扩展了 `HashMap`。
- en: We then make use of this map to populate our own environment variables, but
    we need not set the map back to `ProcessBuilder` because we will have a reference
    to the map object and not a copy. Any changes made to the map object will reflect
    in the actual map object held by the `ProcessBuilder` instance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用这个映射来填充我们自己的环境变量，但我们不需要将映射设置回`ProcessBuilder`，因为我们将有映射对象的引用而不是副本。对映射对象所做的任何更改都将反映在`ProcessBuilder`实例实际持有的映射对象中。
- en: Running shell scripts
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行shell脚本
- en: We generally collect a set of commands used in performing an operation in a
    file, called a shell script in the Unix world and batch file in Windows. The commands
    present in these files are executed sequentially, with the exceptions being when
    you have conditional blocks or loops in the scripts.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将执行操作时使用的命令集合保存在一个文件中，在Unix世界中称为shell脚本，在Windows中称为批处理文件。这些文件中存在的命令是按顺序执行的，除非脚本中有条件块或循环。
- en: These shell scripts are evaluated by the shell in which they get executed. Different
    types of shells available are `bash`, `csh`, `ksh`, and so on. The `bash` shell
    is the most commonly used shell.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些shell脚本由执行它们的shell进行评估。可用的shell类型有`bash`、`csh`、`ksh`等。`bash` shell是最常用的shell。
- en: In this recipe, we will write a simple shell script and then invoke the same
    from the Java code using the `ProcessBuilder` and `Process` objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将编写一个简单的shell脚本，然后使用`ProcessBuilder`和`Process`对象从Java代码中调用它。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'First, let''s write our shell script. This script does the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写我们的shell脚本。此脚本执行以下操作：
- en: Print the value of the environment variable, `MY_VARIABLE`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印环境变量`MY_VARIABLE`的值。
- en: Execute the `tree` command.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`tree`命令。
- en: Execute the `iostat` command.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`iostat`命令。
- en: 'Let''s create a shell script file by the name, `script.sh`, with the following
    commands in it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`script.sh`的shell脚本文件，其中包含以下命令：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can place the `script.sh` in your home folder that is, in the `/home/<username>`.
    Now let's see how we can execute this from Java.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`script.sh`放置在您的家目录中，即`/home/<username>`。现在让我们看看如何从Java中执行它。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new instance of `ProcessBuilder`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ProcessBuilder`实例：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Set the directory of execution to point to the directory of the shell script
    file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将执行目录设置为指向shell脚本文件的目录：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the above path passed while creating the `File` object will depend
    on where you have place your script `script.sh`. In our case we had it placed
    in `/root`. You might have copied the script in `/home/yourname` and accordingly
    the `File` object will be created as `new File("/home/yourname")`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在创建`File`对象时传递的上述路径将取决于您放置脚本`script.sh`的位置。在我们的案例中，我们将其放置在`/root`。您可能已经将脚本复制到`/home/yourname`，因此`File`对象将被创建为`new
    File("/home/yourname")`。
- en: 'Set an environment variable that would be used by the shell script:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个将被shell脚本使用的环境变量：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set the command to be executed and also the arguments to be passed to the command.
    Also, set the output and error streams for the process to same as that of the
    current Java process:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置要执行的命令以及传递给命令的参数。同时，设置进程的输出和错误流与当前Java进程相同：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Start the process, and wait for it to execute completely:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程，并等待其完全执行：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can get the complete code from `chp8/5_running_shell_script`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`chp8/5_running_shell_script`获取完整的代码。
- en: 'You can compile and run the code by using the following commands:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令编译和运行代码：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output we get is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/050b7cc9-3a85-4df5-a062-783dc95e78c4.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/050b7cc9-3a85-4df5-a062-783dc95e78c4.png)'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You must make note of two things in this recipe:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您必须注意两件事：
- en: Change the working directory of the process to the location of the shell script.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将进程的工作目录更改为shell脚本的位置。
- en: Use `/bin/bash` to execute the shell script.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`/bin/bash`来执行shell脚本。
- en: If you don't do step 1, then you'll have to use the absolute path for the shell
    script file. However, in the recipe, we did do step 1, and hence, we just use
    the shell script name for the `/bin/bash` command.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有执行步骤1，那么您将不得不使用shell脚本文件的绝对路径。然而，在我们的配方中，我们已经执行了步骤1，因此我们只需使用shell脚本名称来对`/bin/bash`命令进行操作。
- en: 'Step 2 is basically how you would want to execute the shell script. The way
    to do so is to pass the shell script to the interpreter, which will interpret
    and execute the script. That is what the following line of code does:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2基本上是您想要执行shell脚本的方式。这样做的方法是将shell脚本传递给解释器，解释器将解释并执行脚本。这就是以下代码行所做的事情：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Obtaining the process information of the current JVM
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前JVM的进程信息
- en: 'A running process has a set of attributes associated with it, such as the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的进程有一组与之关联的属性，例如以下内容：
- en: '**PID**: This uniquely identifies the process'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PID**：这是进程的唯一标识'
- en: '**Owner**: This is the name of the user who launched the process'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有者**：这是启动进程的用户名称'
- en: '**Command**: This is the command that runs under the process'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：这是在进程下运行的命令'
- en: '**CPU time**: This indicates the time for which the process has been active'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU时间**：这表示进程活跃的时间'
- en: '**Start time**: This indicates the time when the process was launched'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动时间**：这表示进程启动的时间'
- en: These are a few attributes that we are generally interested in. Perhaps, we
    would also be interested in CPU usage or memory usage. Now, getting this information
    from within Java was not possible prior to Java 9\. However, in Java 9, a new
    set of APIs have been introduced, which enables us to get the basic information
    about the process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们通常感兴趣的几个属性。也许，我们也会对CPU使用率或内存使用率感兴趣。现在，在Java 9之前，从Java内部获取这些信息是不可能的。然而，在Java
    9中，引入了一套新的API，使我们能够获取关于进程的基本信息。
- en: In this recipe, we will see how to get the process information for the current
    Java process, that is, the process that is executing your code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何获取当前Java进程的进程信息，即执行你代码的进程。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a simple class and use `ProcessHandle.current()` to get `ProcessHandle`
    for the current Java process:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的类并使用`ProcessHandle.current()`来获取当前Java进程的`ProcessHandle`：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have added some code, which will add some running time to the code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一些代码，这将增加代码的运行时间：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use the `info()` method on the instance of `ProcessHandle` to get an instance
    of `ProcessHandle.Info`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProcessHandle`实例上使用`info()`方法来获取`ProcessHandle.Info`实例：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the instance of `ProcessHandle.Info` to get all the information made available
    by the interface:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProcessHandle.Info`实例来获取接口提供的所有信息：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the `pid()` method of `ProcessHandle` to get the process ID of the current
    Java process:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProcessHandle`的`pid()`方法来获取当前Java进程的进程ID：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will also print the end time using the time at which the code is about to
    end. This will give us an idea of the execution time of the process:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将使用代码即将结束的时间来打印结束时间。这将给我们一个关于进程执行时间的概念：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can get the complete code from `chp8/6_current_process_info`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`chp8/6_current_process_info`获取完整的代码。
- en: 'Compile and run the code by using the following commands:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行代码：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output you see will be something like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的输出将类似于以下内容：
- en: '![](img/7ee17e84-3a52-4fc4-a9b3-20f425888b5d.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ee17e84-3a52-4fc4-a9b3-20f425888b5d.png)'
- en: It will take some time till the program completes execution.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 程序完成执行将需要一些时间。
- en: One observation to be made is that even if the program ran for around 2 minutes,
    the total CPU duration was 350ms. This is the time period during which the CPU
    was busy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个观察结果是，即使程序运行了大约2分钟，总的CPU持续时间也只有350毫秒。这是CPU忙碌的时间段。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To give more control to the native processes and get its information, a new
    interface called `ProcessHandle` has been added to the Java API. Using `ProcessHandle`,
    you can control the process execution as well as get some information about the
    process. The interface has another inner interface called `ProcessHandle.Info`.
    This interface provides APIs to get information about the process.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给本地进程更多的控制权并获取其信息，Java API中增加了一个名为`ProcessHandle`的新接口。使用`ProcessHandle`，你可以控制进程执行以及获取一些进程信息。该接口还有一个名为`ProcessHandle.Info`的内部接口。该接口提供API来获取关于进程的信息。
- en: 'There are multiple ways to get hold of the `ProcessHandle` object for a process.
    Some of the ways are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以获取进程的`ProcessHandle`对象。以下是一些方法：
- en: '`ProcessHandle.current()`: This is used to get the `ProcessHandle` instance
    for the current Java process'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessHandle.current()`: 这用于获取当前Java进程的`ProcessHandle`实例'
- en: '`Process.toHandle()`: This is used to get `ProcessHandle` for a given `Process`
    object'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Process.toHandle()`: 这用于获取给定`Process`对象的`ProcessHandle`'
- en: '`ProcessHandle.of(pid)`: This is used to get `ProcessHandle` for a process
    identified by the given PID'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessHandle.of(pid)`: 这用于获取由给定PID标识的进程的`ProcessHandle`'
- en: In our recipe, we make use of the first approach, that is, we use `ProcessHandle.current()`.
    This gives us a handle on the current Java process. Invoking the `info()` method
    on the `ProcessHandle` instance will give us an instance of the implementation
    of the `ProcessHandle.Info` interface, which we can make use of to get the process
    information, as shown in the recipe code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们使用第一种方法，即我们使用 `ProcessHandle.current()`。这使我们能够掌握当前Java进程。在 `ProcessHandle`
    实例上调用 `info()` 方法将给我们一个 `ProcessHandle.Info` 接口的实现实例，我们可以利用它来获取进程信息，如配方代码所示。
- en: '`ProcessHandle` and `ProcessHandle.Info` are interfaces. The JDK provider,
    that is, Oracle JDK or Open JDK, will provide implementations for these interfaces.
    Oracle JDK has a class called `ProcessHandleImpl`, which implements `ProcessHandle`
    and another inner class within `ProcessHandleImpl` called `Info`, which implements
    the `ProcessHandle.Info` interface. So, whenever you call one of the aforementioned
    methods to get a `ProcessHandle` object, an instance of `ProcessHandleImpl` is
    returned.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessHandle` 和 `ProcessHandle.Info` 是接口。JDK提供者，即Oracle JDK或Open JDK，将为这些接口提供实现。Oracle
    JDK有一个名为 `ProcessHandleImpl` 的类，它实现了 `ProcessHandle`，并在 `ProcessHandleImpl` 内部还有一个名为
    `Info` 的内部类，它实现了 `ProcessHandle.Info` 接口。因此，每次您调用上述方法之一来获取 `ProcessHandle` 对象时，都会返回一个
    `ProcessHandleImpl` 实例。'
- en: The same goes with the `Process` class as well. It is an abstract class and
    Oracle JDK provides an implementation called `ProcessImpl`, which implements the
    abstract methods in the `Process` class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于 `Process` 类。它是一个抽象类，Oracle JDK提供了一个名为 `ProcessImpl` 的实现，它实现了 `Process`
    类中的抽象方法。
- en: In all the recipes in this chapter, any mention of the instance of `ProcessHandle`
    or the `ProcessHandle` object will refer to the instance or object of `ProcessHandleImpl`
    or any other implementation class provided by the JDK you are using.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有配方中，任何关于 `ProcessHandle` 实例或 `ProcessHandle` 对象的提及都将指代 `ProcessHandleImpl`
    实例或对象或您所使用的JDK提供的任何其他实现类。
- en: Also, any mention of the instance of `ProcessHandle.Info` or the `ProcessHandle.Info`
    object will refer to the instance or object of `ProcessHandleImpl.Info` or any
    other implementation class provided by the JDK you are using.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何关于 `ProcessHandle.Info` 实例或 `ProcessHandle.Info` 对象的提及都将指代 `ProcessHandleImpl.Info`
    实例或对象或您所使用的JDK提供的任何其他实现类。
- en: Obtaining the process information of the spawned process
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取生成的进程的进程信息
- en: In our previous recipe, we saw how to get the process information for the current
    Java process. In this recipe, we will look at how to get the process information
    for a process spawned by the Java code, that is, by the current Java process.
    The APIs used will be the same as we saw in the previous recipe, except for the
    way the instance of `ProcessHandle` is implemented.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的配方中，我们看到了如何获取当前Java进程的进程信息。在这个配方中，我们将探讨如何获取由Java代码生成的进程的进程信息，即由当前Java进程生成的进程。使用的API将与我们在之前的配方中看到的一样，只是
    `ProcessHandle` 实例的实现方式不同。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will make use of a Unix command, `sleep`, which is used to
    pause the execution for a period of time in seconds.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用一个Unix命令，`sleep`，它用于在秒内暂停执行一段时间。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Spawn a new process from the Java code, which runs the `sleep` command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Java代码中生成一个新的进程，该进程运行 `sleep` 命令：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Get the `ProcessHandle` instance for this spawned process:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取此生成的进程的 `ProcessHandle` 实例：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Wait for the spawned process to complete execution:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待生成的进程完成执行：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Use `ProcessHandle` to get the `ProcessHandle.Info` instance and use its APIs
    to get the required information. Alternatively, we can even use the `Process`
    object directly to get `ProcessHandle.Info` by using the `info()` method in the
    `Process` class:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ProcessHandle` 获取 `ProcessHandle.Info` 实例，并使用其API获取所需信息。或者，我们甚至可以直接使用 `Process`
    对象，通过在 `Process` 类中使用 `info()` 方法来获取 `ProcessHandle.Info`：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can get the complete code from `chp8/7_spawned_process_info`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 `chp8/7_spawned_process_info` 获取完整的代码。
- en: 'Compile and run the code by using the following commands:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行代码：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Alternatively, there is a `run.sh` script in `chp8\7_spawned_process_info`,
    which you can run from any Unix-based system as `/bin/bash run.sh`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 `chp8\7_spawned_process_info` 中有一个名为 `run.sh` 的脚本，您可以从任何基于Unix的系统作为 `/bin/bash
    run.sh` 运行它。
- en: 'The output you see will be something like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的输出将类似于以下内容：
- en: '![](img/be482dc1-a8b5-4687-ae4e-b449b96f6d99.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be482dc1-a8b5-4687-ae4e-b449b96f6d99.png)'
- en: Managing the spawned process
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理生成的进程
- en: There are a few methods, such as `destroy()`, `destroyForcibly()` (added in
    Java 8), `isAlive()` (added in Java 8), and `supportsNormalTermination()` (added
    in Java 9), which can be used to control the process spawned. These methods are
    available on the `Process` object as well as on the `ProcessHandle` object. Here,
    controlling would be just to check if the process is alive and if yes, then destroy
    the process.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法，例如`destroy()`、`destroyForcibly()`（在Java 8中添加）、`isAlive()`（在Java 8中添加）和`supportsNormalTermination()`（在Java
    9中添加），可以用来控制生成的进程。这些方法在`Process`对象以及`ProcessHandle`对象上都是可用的。在这里，控制只是检查进程是否处于活动状态，如果是，则销毁进程。
- en: 'In this recipe, we will spawn a long running process and do the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将生成一个长时间运行的进程，并执行以下操作：
- en: Check for its liveliness
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查其活动性
- en: Check if it can be stopped normally, that is, depending on the platform, the
    process has to be stopped by just using destroy or by using force destroy
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查它是否可以正常停止，也就是说，根据平台，进程可以通过仅使用销毁或使用强制销毁来停止
- en: Stop the process
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止进程
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Spawn a new process from the Java code, which runs the `sleep` command for
    say 1 minute, that is, 60 seconds:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Java代码中生成一个新的进程，运行`sleep`命令，例如1分钟，即60秒：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Wait for, say, 10 seconds:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待，比如说，10秒：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Check whether the process is alive:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查进程是否处于活动状态：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Check whether the process can be stopped normally:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查进程是否可以正常停止：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Stop the process and check for its liveliness:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止进程并检查其活动性：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can get the complete code from `chp8\8_manage_spawned_process`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`chp8\8_manage_spawned_process`获取完整的代码。
- en: 'We have provided a utility script called `run.sh`, which you can use to compile
    and run the code: `sh run.sh`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`run.sh`的实用脚本，您可以使用它来编译和运行代码：`sh run.sh`。
- en: 'The output we get is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/067f50c7-4562-4d69-8d92-0c3374da1ab8.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/067f50c7-4562-4d69-8d92-0c3374da1ab8.png)'
- en: If we are running the program on Windows, `supportsNormalTermination()` returns
    `false`, but on Unix `supportsNormalTermination()` returns `true` (as seen in
    the preceding output as well).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Windows上运行程序，`supportsNormalTermination()`返回`false`，但在Unix上`supportsNormalTermination()`返回`true`（如前面的输出所示）。
- en: Enumerating live processes in the system
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列举系统中的活动进程
- en: In Windows, you open up the Windows Task Manger to view the processes currently
    active, and in Linux, you use the `ps` command with its varied options to view
    the processes along with other details, such as user, time spent, command, and
    so on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您打开Windows任务管理器来查看当前活动的进程，而在Linux中，您使用带有各种选项的`ps`命令来查看进程以及其他详细信息，如用户、耗时、命令等。
- en: In Java 9, a new API has been added, called `ProcessHandle`, which deals with
    controlling and getting information about the processes. One of the methods of
    the API is `allProcesses()`, which returns a snapshot of all the processes visible
    to the current process. In this recipe, we will look at how the method works and
    what information we can extract from the API.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，添加了一个新的API，称为`ProcessHandle`，用于处理进程的控制和获取信息。API的一个方法是`allProcesses()`，它返回当前进程可见的所有进程的快照。在这个菜谱中，我们将查看该方法的工作方式以及我们可以从API中提取哪些信息。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the `allProcesses()` method on the `ProcessHandle` interface to get a stream
    of the currently active processes:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProcessHandle`接口上的`allProcesses()`方法获取当前活动进程的流：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Iterate over the stream using `forEach()` and pass a lambda expression to print
    the details available:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach()`遍历流，并传递一个lambda表达式来打印可用的详细信息：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can get the complete code from `chp8/9_enumerate_all_processes`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`chp8/9_enumerate_all_processes`获取完整的代码。
- en: 'We have provided a utility script called `run.sh`, which you can use to compile
    and run the code: `sh run.sh`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`run.sh`的实用脚本，您可以使用它来编译和运行代码：`sh run.sh`。
- en: 'The output we get is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/5c0213b4-0cf2-4d1f-95b9-692d15e89fc2.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c0213b4-0cf2-4d1f-95b9-692d15e89fc2.png)'
- en: In the preceding output, we are printing the command name as well as the user
    of the process. We have shown a small part of the output.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们打印了进程的命令名称以及用户。我们只展示了输出的一小部分。
- en: Connecting multiple processes using pipe
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道连接多个进程
- en: In Unix, it's common to pipe a set of commands together using the `|` symbol
    to create a pipeline of activities, where the input for the command is the output
    from the previous command. This way, we can process the input to get the desired
    output.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，使用`|`符号将一组命令连接起来是常见的，以创建一系列活动的管道，其中命令的输入是前一个命令的输出。这样，我们可以处理输入以获得所需的输出。
- en: 'A common scenario is when you want to search for something or some pattern
    in the log files or for an occurrence of some text in the log file. In such scenarios,
    you can create a pipeline, wherein you pass the required log file data via a series
    of commands, namely: `cat`, `grep`, `wc -l`, and so on.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的场景是当你想在日志文件中搜索某些内容或某些模式，或者在日志文件中查找某些文本的出现。在这种情况下，你可以创建一个管道，通过一系列命令（如`cat`、`grep`、`wc
    -l`等）传递所需的日志文件数据。
- en: In this recipe, we will make use of the Iris dataset from the UCI machine learning
    repository available at [https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris) to
    create a pipeline, wherein we will count the number of occurrences of each type
    of flower.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用来自UCI机器学习仓库的Iris数据集（可在[https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris)找到）来创建一个管道，其中我们将计算每种类型花的出现次数。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中...
- en: We have already downloaded the Iris flower dataset, which can be found at `chp8/10_connecting_process_pipe/iris.data`
    of the code download for this book.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经下载了Iris花数据集，可以在本书代码下载的`chp8/10_connecting_process_pipe/iris.data`中找到。
- en: 'If you happen to look at the `Iris` data, you will see there are 150 rows of
    the following format:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`Iris`数据，你会看到有150行以下格式的数据：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, there are multiple attributes separated by a comma (`,`) and the attributes
    are as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，有多个属性由逗号（`,`）分隔，属性如下：
- en: Sepal length in cm
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花萼长度（厘米）
- en: Sepal width in cm
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花萼宽度（厘米）
- en: Petal length in cm
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣长度（厘米）
- en: Petal width in cm
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣宽度（厘米）
- en: 'Class:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类：
- en: Iris Setosa
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iris Setosa
- en: Iris Versicolour
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iris Versicolour
- en: Iris Virginica
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iris Virginica
- en: In this recipe, we will find the total number of flowers in each class, namely Setosa, Versicolour,
    and Virginica.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将找到每个类（Setosa、Versicolour和Virginica）中花的总数。
- en: 'We will make use of a pipeline with the following commands (using a Unix-based
    operating system):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令的管道（使用基于Unix的操作系统）：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output we get is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如下：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The 1 at the end is for the new line available at the end of the file. So,
    there are 50 flowers of each class. Let us dissect the above shell command pipeline
    and understand the function of each of them:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 文件末尾的1表示文件末尾的新行。因此，每个类有50朵花。让我们分析上述shell命令管道，了解每个命令的功能：
- en: '`cat`: This command reads the file given as the argument'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat`：这个命令读取作为参数给出的文件'
- en: '`cut`: This splits each line by using the character given in the `-d` option
    and returns the value in the column identified by the `-f` option.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cut`：这个命令使用`-d`选项中给出的字符分割每一行，并返回由`-f`选项指定的列中的值。'
- en: '`uniq`: This returns a unique list from the given values, and when the `-c`
    option is used, it returns how many times each unique value is present in the
    list'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniq`：这个命令从给定的值中返回一个唯一的列表，当使用`-c`选项时，它返回每个唯一值在列表中出现的次数'
- en: How to do it...
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a list of `ProcessBuilder` objects, which will hold the `ProcessBuilder` instances
    participating in our pipeline. Also, redirect the output of the last process in
    the pipeline to the standard output of the current Java process:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ProcessBuilder`对象列表，它将包含参与我们管道的`ProcessBuilder`实例。同时，将管道中最后一个进程的输出重定向到当前Java进程的标准输出：
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use the `startPipeline()` method of `ProcessBuilder` and pass the list of `ProcessBuilder`
    objects to start the pipeline. It will return a list of `Process` objects, each
    representing a `ProcessBuilder` object in the list:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProcessBuilder`的`startPipeline()`方法，并将`ProcessBuilder`对象列表传递给它以启动管道。它将返回一个`Process`对象列表，每个对象代表列表中的一个`ProcessBuilder`对象：
- en: '[PRE57]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Get the last process in the list and `waitFor` it to complete:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取列表中的最后一个进程并`waitFor`它完成：
- en: '[PRE58]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can get the complete code from `chp8/10_connecting_process_pipe`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`chp8/10_connecting_process_pipe`获取完整的代码。
- en: 'We have provided a utility script called `run.sh`, which you can use to compile
    and run the code: `sh run.sh`.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`run.sh`的实用脚本，你可以使用它来编译和运行代码：`sh run.sh`。
- en: 'The output we get is as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如下：
- en: '![](img/ab389c1c-187d-4d9a-a794-bd65c5dd1b65.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ab389c1c-187d-4d9a-a794-bd65c5dd1b65.png)'
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `startPipeline()` method starts a `Process` for each `ProcessBuilder` object
    in the list. Except for the first and the last processes, it redirects the output
    of one process to the input of another process by using `ProcessBuilder.Redirect.PIPE`.
    If you have provided `redirectOutput` for any intermediate process as something
    other than `ProcessBuilder.Redirect.PIPE`, then there will be an error thrown,
    something similar to the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`startPipeline()`方法为列表中的每个`ProcessBuilder`对象启动一个`Process`。除了第一个和最后一个进程外，它通过使用`ProcessBuilder.Redirect.PIPE`将一个进程的输出重定向到另一个进程的输入。如果你为任何中间进程提供了除`ProcessBuilder.Redirect.PIPE`之外的其他`redirectOutput`，则会抛出错误，类似于以下内容：'
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It states that any builder except for the last should redirect its output to
    the next process. The same is applicable for `redirectInput`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 它指出除了最后一个构建器之外，任何构建器都应该将其输出重定向到下一个进程。对于`redirectInput`也是如此。
- en: Managing subprocesses
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理子进程
- en: When a process launches another process, the launched process becomes the subprocess
    of the launching process. The launched process, in turn, can launch another process
    and this chain can continue. This results in a process tree. Often, we would have
    to deal with a buggy subprocess and might want to kill that subprocess, or we
    might want to know the subprocesses that are launched and might want to get some
    information about it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程启动另一个进程时，被启动的进程成为启动进程的子进程。反过来，启动的进程也可以启动另一个进程，这个链可以继续下去。这导致了一个进程树。我们通常需要处理有问题的子进程，可能想要杀死该子进程，或者我们可能想知道启动的子进程并可能想要获取一些关于它的信息。
- en: 'In Java 9, two new APIs in the `Process` class have been added: `children()`
    and `descendants()`. The `children()` API allows you to get a list of the snapshot
    of processes that are the immediate children of the current process, and the `descendants()`
    API provides a snapshot of processes that are recursively `children()` of the
    current process, that is, they are invoking `children()` recursively on each child
    process.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，`Process`类中添加了两个新的API：`children()`和`descendants()`。`children()` API允许你获取当前进程的直接子进程的快照列表，而`descendants()`
    API提供了当前进程的递归`children()`的快照，即它们在每个子进程中递归调用`children()`。
- en: In this recipe, we will look at both the `children()` and `descendants()` APIs
    and see what information we can gather from the snapshot of the process.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看`children()`和`descendants()` API，并看看我们可以从进程快照中收集哪些信息。
- en: Getting ready
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create a simple shell script, which we will be using in the recipe.
    This script can be found at `chp8/11_managing_sub_process/script.sh`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的shell脚本，我们将在菜谱中使用它。这个脚本可以在`chp8/11_managing_sub_process/script.sh`找到：
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding script, we are running the commands, `tree` and `iostat`, separated
    by a sleep time of 1 minute. If you want to know about these commands, please
    refer to the *Running shell scripts* recipe of this chapter. The sleep command,
    when executed from within the bash shell, creates a new subprocess each time it
    is invoked.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，我们正在运行`tree`和`iostat`命令，它们之间有1分钟的睡眠时间。如果你想知道这些命令，请参阅本章的*运行shell脚本*菜谱。当从bash
    shell中执行睡眠命令时，每次调用都会创建一个新的子进程。
- en: We will create, say, 10 instances of `ProcessBuilder` to run the preceding shell
    script and launch them simultaneously.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建，比如说，10个`ProcessBuilder`实例来运行前面的shell脚本并将它们同时启动。
- en: How to do it...
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create 10 instances of `ProcessBuilder` to run our shell script (available
    at `chp8/11_managing_sub_process/script.sh`). We are not concerned with its output,
    so let''s discard the output of the commands by redirecting the output to a predefined
    redirect called `ProcessHandle.Redirect.DISCARD`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建10个`ProcessBuilder`实例来运行我们的shell脚本（位于`chp8/11_managing_sub_process/script.sh`）。我们对其输出不感兴趣，所以让我们通过将输出重定向到预定义的重定向`ProcessHandle.Redirect.DISCARD`来丢弃命令的输出：
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Get the handle for the current process:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前进程的句柄：
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use the current process to get its children using the `children()` API and
    iterate over each of its children to print their information. Once we have an
    instance of `ProcessHandle`, we can do multiple things, such as destroy the process,
    get its process information, and so on:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前进程通过`children()` API获取其子进程，并对每个子进程迭代以打印其信息。一旦我们有一个`ProcessHandle`实例，我们就可以做很多事情，比如销毁进程、获取进程信息等等：
- en: '[PRE63]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Use the current process to get all the subprocesses that are its descendants
    using the `descendants()` API and iterate over each of them to print their information:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前进程通过`descendants()` API获取所有其后代子进程，并对每个子进程迭代以打印它们的信息：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can get the complete code from `chp8/11_managing_sub_process`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`chp8/11_managing_sub_process`获取完整的代码。
- en: 'We have provided a utility script called `run.sh`, which you can use to compile
    and run the code: `sh run.sh`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`run.sh`的实用脚本，您可以使用它来编译和运行代码：`sh run.sh`。
- en: 'The output we get is as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果如下：
- en: '![](img/12b81bda-e9c9-4e50-9f1b-7655ebef5d7d.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12b81bda-e9c9-4e50-9f1b-7655ebef5d7d.png)'
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The APIs, `children()`, and `descendants()`, return `Stream` of `ProcessHandler`
    for each of the processes, which are either direct children or descendants of
    the current process. Using the instance of `ProcessHandler`, we can perform the
    following operations:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`children()`和`descendants()` API为每个进程返回`Stream`的`ProcessHandler`，这些进程是当前进程的直接子进程或后代。使用`ProcessHandler`的实例，我们可以执行以下操作：'
- en: Get the process information.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取进程信息。
- en: Check the status of the process.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查进程的状态。
- en: Stop the process.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止进程。
