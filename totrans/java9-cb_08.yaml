- en: Better Management of the OS Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a new process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting the process output and error streams to file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the working directory of a subprocess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the environment variable for a subprocess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running shell scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining the process information of the current JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining the process information of the spawned process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the spawned process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating live processes in the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting multiple processes using pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing subprocesses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How often have you ended up writing code that spawns a new process? Not often.
    However, there would be situations that ask for writing such code. In such cases,
    you resort to using a third-party API such as Apache Commons Exec ([https://commons.apache.org/proper/commons-exec/](https://commons.apache.org/proper/commons-exec/))
    and the like. Why was this? Wasn't the Java API sufficient? No, it wasn't, at
    least until Java 9\. Now with Java 9, we have quite a few more features added
    to the process API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until Java 7, redirecting the input, output, and error streams was not trivial.
    With Java 7, there were new APIs introduced, which allowed the redirecting of
    the input, output, and error to other processes (pipe), to a file, or to a standard
    input/output. Then in Java 8, there were a few more APIs introduced. In Java 9,
    there are new APIs for the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the process information, such as **process ID** (**PID**), the user who
    launched the process, the time it has been running for, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerate the processes running in the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the subprocesses and get access to the process tree by navigating up
    the process hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will look at a few recipes that will help you explore the
    new things in the process API, and you will also get to know the changes that
    have been introduced from the times of `Runtime.getRuntime().exec()`. And you
    all know that using that was a crime.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the recipes can only be executed on the Linux platform because we will
    be using Linux-specific commands while spawning a new process from Java code. There
    are two ways to execute the script `run.sh` on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sh run.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod +x run.sh && ./run.sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning a new process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to spawn a new process using `ProcessBuilder`.
    We will also see how to make use of the input, output, and error streams. This
    should be a very straightforward and common recipe. However, the aim of introducing
    this is to make this chapter a bit more complete and not just to focus on Java
    9 features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a command in Linux called `free`, which shows the amount of RAM free
    and used by the system. It accepts an option, `-m`, to show the output in megabytes.
    So, just running free `-m` gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48b5277b-4cb0-4391-bab4-03fc949e5b9f.png)'
  prefs: []
  type: TYPE_IMG
- en: We will be running the preceding code from within the Java program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an instance of `ProcessBuilder` by providing the required command and
    its options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternate way to specify the command and options is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the input and output streams for the process builder and other properties,
    such as the directory of execution and environment variables. After that, invoke
    `start()` on the `ProcessBuilder` instance to spawn the process and get a reference
    to the `Process` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `inheritIO()` function sets the standard I/O of the spawned subprocess to
    be the same as that of the current Java process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then wait for the completion of the process, or for 1 second, whichever
    is sooner, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If it doesn't complete in the time specified, then we kill the process by invoking
    the `destroyForcibly()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the code by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ceba2731-e3c6-47fc-9840-45df293995d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The code for this recipe can be found at `chp8/1_spawn_new_process`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to let `ProcessBuilder` know which command to run:'
  prefs: []
  type: TYPE_NORMAL
- en: By passing the command and its options to the constructor while creating the
    `ProcessBuilder` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By passing the command and its options as parameters to the `command()` method
    of the `ProcessBuilder` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before spawning the process, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We can change the directory of execution by using the `directory()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can redirect the input stream, output stream, and error streams to file or
    to another process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can provide the required environment variables for the subprocess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see all these activities in their respective recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new process is spawned when the `start()` method is invoked and the caller
    gets a reference to this subprocess in the form of an instance of the `Process`
    class. Using this `Process` object, we can do a lot of things, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get information about the process, including its PID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the output and error streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for the completion of the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroy the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associate the tasks to be performed once the process completes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for the subprocesses spawned by the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the parent process of the process if it exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our recipe, we `waitFor` 1 second or the completion of the process (whichever
    occurs first). If the process has completed, then `waitFor` returns `true`; else,
    it returns `false`. If the process doesn't complete, we can kill the process by
    invoking the `destroyForcibly()` method on the `Process` object.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting the process output and error streams to file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to deal with the output and error streams of
    a process spawned from the Java code. We will write the output or error produced
    by the spawned process to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will make use of the `iostat` command. This command is used
    for reporting the CPU and I/O statistics for different devices and partitions.
    Let''s run the command and see what it reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In some Linux distributions, such as Ubuntu, `iostat` is not installed by default.
    You can install the utility by running `sudo apt-get install sysstat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/693e431b-2fd6-4e5e-b98b-d5de51ea76d6.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `ProcessBuilder` object by specifying the command to be executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Redirect the output and error streams to the file''s output and error, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the process, and wait for it to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the content of the output file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the content of the error file. This is created only if there is some error
    in the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 and 5 are for our reference. This has nothing to do with `ProcessBuilder`
    or the process spawned. Using these two lines of code, we can inspect what was
    written to the output and error files by the process.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code can be found at `chp8/2_redirect_to_file`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the code by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/259d9294-e4d8-4e41-9e8b-f4e67b81c859.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that as the command executed successfully; there is nothing in the
    error file.
  prefs: []
  type: TYPE_NORMAL
- en: There is more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can provide an erroneous command to `ProcessBuilder` and then see the error
    get written to the error file and nothing in the output file. You could do this
    by changing the `ProcessBuilder` instance creation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run by using the commands given earlier in the *How to do it...*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that there is an error reported in the error file but nothing
    in the output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f1fc4ab-0a88-4efd-ba11-2b29135604a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Changing the working directory of a subprocess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, you would want a process to be executed in the context of some path,
    such as listing the files in some directory. In order to do so, we will have to
    tell `ProcessBuilder` to launch the process in the context of a given location.
    We can achieve this by using the `directory()` method. This method serves two
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the current directory of execution when we don't pass any parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the current directory of execution to the passed value when we pass a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe, we will see how to execute the `tree` command to recursively
    traverse all the directories from the current directory and print it in the form
    of a tree.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generally, the `tree` command doesn''t come preinstalled. So, you will have
    to install the package that contains the command. To install on an Ubuntu/Debian-based
    system, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To install on Linux, which supports the `yum` package manager, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify your installation, just run the `tree` command, and you should be
    able to see the current directory structure printed. For me, it''s something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d78da25f-a88e-4949-8854-e0d13f107208.png)'
  prefs: []
  type: TYPE_IMG
- en: There are multiple options supported by the `tree` command. It's for you to
    explore.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `ProcessBuilder` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the command to `tree` and the output and error to the same as that of the
    current Java process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the directory to whatever directory you want. I set it as the root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the process and wait for it to exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output will be the recursive contents of the directory, specified in the
    `directory()` method of the `ProcessBuilder` object, printed in a tree like format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete code can be found at `chp8/2_redirect_to_file`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `directory()` method accepts the path of the working directory for `Process`.
    The path is specified as an instance of `File`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the environment variable for a subprocess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Environment variables are just like any other variables that we have in our
    programming languages. They have a name and hold some value, which can be varied.
    These are used by the Linux/Windows commands or the shell/batch scripts to perform
    different operations. These are called environment variables because they are
    present in the environment of the process/command/script getting executed. Generally,
    the process inherits the environment variables from the parent process.
  prefs: []
  type: TYPE_NORMAL
- en: They are accessed in different ways in different operating systems. In Windows,
    they are accessed as `%ENVIRONMENT_VARIABLE_NAME%`, and in Unix-based operating
    systems, they are accessed as `$ENVIRONMENT_VARIABLE_NAME`.
  prefs: []
  type: TYPE_NORMAL
- en: In Unix-based systems, you can use the `printenv` command to print all the environment
    variables available for the process, and in Windows-based systems, you can use
    the `SET` command.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will pass some environment variables to our subprocess and
    make use of the `printenv` command to print all the environment variables available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an instance of `ProcessBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the command to `printenv` and the output and error streams to the same
    as that of the current Java process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide the environment variables, `COOKBOOK_VAR1` with the value, `First variable`, `COOKBOOK_VAR2` with
    the value, `Second variable`, and `COOKBOOK_VAR3` with the value, `Third variable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the process and wait for it to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this recipe can be found at `chp8/4_environment_variables`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the code by using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output you get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4b2d50e-1cc7-44d2-915b-5a94a0a93849.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the three variables printed among other variables.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you invoke the `environment()` method on the instance of `ProcessBuilder`,
    it copies the environment variables of the current process, populates them in
    an instance of `HashMap`, and returns it to the caller code.
  prefs: []
  type: TYPE_NORMAL
- en: All the work of loading the environment variables is done by a package private
    final class, `ProcessEnvironment`, which actually extends `HashMap`.
  prefs: []
  type: TYPE_NORMAL
- en: We then make use of this map to populate our own environment variables, but
    we need not set the map back to `ProcessBuilder` because we will have a reference
    to the map object and not a copy. Any changes made to the map object will reflect
    in the actual map object held by the `ProcessBuilder` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running shell scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We generally collect a set of commands used in performing an operation in a
    file, called a shell script in the Unix world and batch file in Windows. The commands
    present in these files are executed sequentially, with the exceptions being when
    you have conditional blocks or loops in the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: These shell scripts are evaluated by the shell in which they get executed. Different
    types of shells available are `bash`, `csh`, `ksh`, and so on. The `bash` shell
    is the most commonly used shell.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will write a simple shell script and then invoke the same
    from the Java code using the `ProcessBuilder` and `Process` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s write our shell script. This script does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Print the value of the environment variable, `MY_VARIABLE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `tree` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `iostat` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a shell script file by the name, `script.sh`, with the following
    commands in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can place the `script.sh` in your home folder that is, in the `/home/<username>`.
    Now let's see how we can execute this from Java.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new instance of `ProcessBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the directory of execution to point to the directory of the shell script
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that the above path passed while creating the `File` object will depend
    on where you have place your script `script.sh`. In our case we had it placed
    in `/root`. You might have copied the script in `/home/yourname` and accordingly
    the `File` object will be created as `new File("/home/yourname")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set an environment variable that would be used by the shell script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the command to be executed and also the arguments to be passed to the command.
    Also, set the output and error streams for the process to same as that of the
    current Java process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the process, and wait for it to execute completely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can get the complete code from `chp8/5_running_shell_script`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compile and run the code by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/050b7cc9-3a85-4df5-a062-783dc95e78c4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must make note of two things in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the working directory of the process to the location of the shell script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `/bin/bash` to execute the shell script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't do step 1, then you'll have to use the absolute path for the shell
    script file. However, in the recipe, we did do step 1, and hence, we just use
    the shell script name for the `/bin/bash` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2 is basically how you would want to execute the shell script. The way
    to do so is to pass the shell script to the interpreter, which will interpret
    and execute the script. That is what the following line of code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Obtaining the process information of the current JVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A running process has a set of attributes associated with it, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PID**: This uniquely identifies the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Owner**: This is the name of the user who launched the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: This is the command that runs under the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU time**: This indicates the time for which the process has been active'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start time**: This indicates the time when the process was launched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are a few attributes that we are generally interested in. Perhaps, we
    would also be interested in CPU usage or memory usage. Now, getting this information
    from within Java was not possible prior to Java 9\. However, in Java 9, a new
    set of APIs have been introduced, which enables us to get the basic information
    about the process.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to get the process information for the current
    Java process, that is, the process that is executing your code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a simple class and use `ProcessHandle.current()` to get `ProcessHandle`
    for the current Java process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added some code, which will add some running time to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `info()` method on the instance of `ProcessHandle` to get an instance
    of `ProcessHandle.Info`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the instance of `ProcessHandle.Info` to get all the information made available
    by the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `pid()` method of `ProcessHandle` to get the process ID of the current
    Java process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also print the end time using the time at which the code is about to
    end. This will give us an idea of the execution time of the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can get the complete code from `chp8/6_current_process_info`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the code by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output you see will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ee17e84-3a52-4fc4-a9b3-20f425888b5d.png)'
  prefs: []
  type: TYPE_IMG
- en: It will take some time till the program completes execution.
  prefs: []
  type: TYPE_NORMAL
- en: One observation to be made is that even if the program ran for around 2 minutes,
    the total CPU duration was 350ms. This is the time period during which the CPU
    was busy.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To give more control to the native processes and get its information, a new
    interface called `ProcessHandle` has been added to the Java API. Using `ProcessHandle`,
    you can control the process execution as well as get some information about the
    process. The interface has another inner interface called `ProcessHandle.Info`.
    This interface provides APIs to get information about the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to get hold of the `ProcessHandle` object for a process.
    Some of the ways are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProcessHandle.current()`: This is used to get the `ProcessHandle` instance
    for the current Java process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Process.toHandle()`: This is used to get `ProcessHandle` for a given `Process`
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessHandle.of(pid)`: This is used to get `ProcessHandle` for a process
    identified by the given PID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our recipe, we make use of the first approach, that is, we use `ProcessHandle.current()`.
    This gives us a handle on the current Java process. Invoking the `info()` method
    on the `ProcessHandle` instance will give us an instance of the implementation
    of the `ProcessHandle.Info` interface, which we can make use of to get the process
    information, as shown in the recipe code.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProcessHandle` and `ProcessHandle.Info` are interfaces. The JDK provider,
    that is, Oracle JDK or Open JDK, will provide implementations for these interfaces.
    Oracle JDK has a class called `ProcessHandleImpl`, which implements `ProcessHandle`
    and another inner class within `ProcessHandleImpl` called `Info`, which implements
    the `ProcessHandle.Info` interface. So, whenever you call one of the aforementioned
    methods to get a `ProcessHandle` object, an instance of `ProcessHandleImpl` is
    returned.'
  prefs: []
  type: TYPE_NORMAL
- en: The same goes with the `Process` class as well. It is an abstract class and
    Oracle JDK provides an implementation called `ProcessImpl`, which implements the
    abstract methods in the `Process` class.
  prefs: []
  type: TYPE_NORMAL
- en: In all the recipes in this chapter, any mention of the instance of `ProcessHandle`
    or the `ProcessHandle` object will refer to the instance or object of `ProcessHandleImpl`
    or any other implementation class provided by the JDK you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Also, any mention of the instance of `ProcessHandle.Info` or the `ProcessHandle.Info`
    object will refer to the instance or object of `ProcessHandleImpl.Info` or any
    other implementation class provided by the JDK you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the process information of the spawned process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, we saw how to get the process information for the current
    Java process. In this recipe, we will look at how to get the process information
    for a process spawned by the Java code, that is, by the current Java process.
    The APIs used will be the same as we saw in the previous recipe, except for the
    way the instance of `ProcessHandle` is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will make use of a Unix command, `sleep`, which is used to
    pause the execution for a period of time in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spawn a new process from the Java code, which runs the `sleep` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the `ProcessHandle` instance for this spawned process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the spawned process to complete execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `ProcessHandle` to get the `ProcessHandle.Info` instance and use its APIs
    to get the required information. Alternatively, we can even use the `Process`
    object directly to get `ProcessHandle.Info` by using the `info()` method in the
    `Process` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can get the complete code from `chp8/7_spawned_process_info`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the code by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, there is a `run.sh` script in `chp8\7_spawned_process_info`,
    which you can run from any Unix-based system as `/bin/bash run.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output you see will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be482dc1-a8b5-4687-ae4e-b449b96f6d99.png)'
  prefs: []
  type: TYPE_IMG
- en: Managing the spawned process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few methods, such as `destroy()`, `destroyForcibly()` (added in
    Java 8), `isAlive()` (added in Java 8), and `supportsNormalTermination()` (added
    in Java 9), which can be used to control the process spawned. These methods are
    available on the `Process` object as well as on the `ProcessHandle` object. Here,
    controlling would be just to check if the process is alive and if yes, then destroy
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will spawn a long running process and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for its liveliness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if it can be stopped normally, that is, depending on the platform, the
    process has to be stopped by just using destroy or by using force destroy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spawn a new process from the Java code, which runs the `sleep` command for
    say 1 minute, that is, 60 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for, say, 10 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the process is alive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the process can be stopped normally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop the process and check for its liveliness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can get the complete code from `chp8\8_manage_spawned_process`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided a utility script called `run.sh`, which you can use to compile
    and run the code: `sh run.sh`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/067f50c7-4562-4d69-8d92-0c3374da1ab8.png)'
  prefs: []
  type: TYPE_IMG
- en: If we are running the program on Windows, `supportsNormalTermination()` returns
    `false`, but on Unix `supportsNormalTermination()` returns `true` (as seen in
    the preceding output as well).
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating live processes in the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Windows, you open up the Windows Task Manger to view the processes currently
    active, and in Linux, you use the `ps` command with its varied options to view
    the processes along with other details, such as user, time spent, command, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 9, a new API has been added, called `ProcessHandle`, which deals with
    controlling and getting information about the processes. One of the methods of
    the API is `allProcesses()`, which returns a snapshot of all the processes visible
    to the current process. In this recipe, we will look at how the method works and
    what information we can extract from the API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the `allProcesses()` method on the `ProcessHandle` interface to get a stream
    of the currently active processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over the stream using `forEach()` and pass a lambda expression to print
    the details available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can get the complete code from `chp8/9_enumerate_all_processes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided a utility script called `run.sh`, which you can use to compile
    and run the code: `sh run.sh`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c0213b4-0cf2-4d1f-95b9-692d15e89fc2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, we are printing the command name as well as the user
    of the process. We have shown a small part of the output.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting multiple processes using pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unix, it's common to pipe a set of commands together using the `|` symbol
    to create a pipeline of activities, where the input for the command is the output
    from the previous command. This way, we can process the input to get the desired
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common scenario is when you want to search for something or some pattern
    in the log files or for an occurrence of some text in the log file. In such scenarios,
    you can create a pipeline, wherein you pass the required log file data via a series
    of commands, namely: `cat`, `grep`, `wc -l`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will make use of the Iris dataset from the UCI machine learning
    repository available at [https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris) to
    create a pipeline, wherein we will count the number of occurrences of each type
    of flower.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already downloaded the Iris flower dataset, which can be found at `chp8/10_connecting_process_pipe/iris.data`
    of the code download for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you happen to look at the `Iris` data, you will see there are 150 rows of
    the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are multiple attributes separated by a comma (`,`) and the attributes
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sepal length in cm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sepal width in cm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Petal length in cm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Petal width in cm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iris Setosa
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Iris Versicolour
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Iris Virginica
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will find the total number of flowers in each class, namely Setosa, Versicolour,
    and Virginica.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make use of a pipeline with the following commands (using a Unix-based
    operating system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The 1 at the end is for the new line available at the end of the file. So,
    there are 50 flowers of each class. Let us dissect the above shell command pipeline
    and understand the function of each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cat`: This command reads the file given as the argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cut`: This splits each line by using the character given in the `-d` option
    and returns the value in the column identified by the `-f` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uniq`: This returns a unique list from the given values, and when the `-c`
    option is used, it returns how many times each unique value is present in the
    list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a list of `ProcessBuilder` objects, which will hold the `ProcessBuilder` instances
    participating in our pipeline. Also, redirect the output of the last process in
    the pipeline to the standard output of the current Java process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `startPipeline()` method of `ProcessBuilder` and pass the list of `ProcessBuilder`
    objects to start the pipeline. It will return a list of `Process` objects, each
    representing a `ProcessBuilder` object in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the last process in the list and `waitFor` it to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You can get the complete code from `chp8/10_connecting_process_pipe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided a utility script called `run.sh`, which you can use to compile
    and run the code: `sh run.sh`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab389c1c-187d-4d9a-a794-bd65c5dd1b65.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `startPipeline()` method starts a `Process` for each `ProcessBuilder` object
    in the list. Except for the first and the last processes, it redirects the output
    of one process to the input of another process by using `ProcessBuilder.Redirect.PIPE`.
    If you have provided `redirectOutput` for any intermediate process as something
    other than `ProcessBuilder.Redirect.PIPE`, then there will be an error thrown,
    something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It states that any builder except for the last should redirect its output to
    the next process. The same is applicable for `redirectInput`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing subprocesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a process launches another process, the launched process becomes the subprocess
    of the launching process. The launched process, in turn, can launch another process
    and this chain can continue. This results in a process tree. Often, we would have
    to deal with a buggy subprocess and might want to kill that subprocess, or we
    might want to know the subprocesses that are launched and might want to get some
    information about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java 9, two new APIs in the `Process` class have been added: `children()`
    and `descendants()`. The `children()` API allows you to get a list of the snapshot
    of processes that are the immediate children of the current process, and the `descendants()`
    API provides a snapshot of processes that are recursively `children()` of the
    current process, that is, they are invoking `children()` recursively on each child
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at both the `children()` and `descendants()` APIs
    and see what information we can gather from the snapshot of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a simple shell script, which we will be using in the recipe.
    This script can be found at `chp8/11_managing_sub_process/script.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding script, we are running the commands, `tree` and `iostat`, separated
    by a sleep time of 1 minute. If you want to know about these commands, please
    refer to the *Running shell scripts* recipe of this chapter. The sleep command,
    when executed from within the bash shell, creates a new subprocess each time it
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: We will create, say, 10 instances of `ProcessBuilder` to run the preceding shell
    script and launch them simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create 10 instances of `ProcessBuilder` to run our shell script (available
    at `chp8/11_managing_sub_process/script.sh`). We are not concerned with its output,
    so let''s discard the output of the commands by redirecting the output to a predefined
    redirect called `ProcessHandle.Redirect.DISCARD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the handle for the current process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the current process to get its children using the `children()` API and
    iterate over each of its children to print their information. Once we have an
    instance of `ProcessHandle`, we can do multiple things, such as destroy the process,
    get its process information, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the current process to get all the subprocesses that are its descendants
    using the `descendants()` API and iterate over each of them to print their information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You can get the complete code from `chp8/11_managing_sub_process`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have provided a utility script called `run.sh`, which you can use to compile
    and run the code: `sh run.sh`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output we get is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12b81bda-e9c9-4e50-9f1b-7655ebef5d7d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The APIs, `children()`, and `descendants()`, return `Stream` of `ProcessHandler`
    for each of the processes, which are either direct children or descendants of
    the current process. Using the instance of `ProcessHandler`, we can perform the
    following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the process information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the status of the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
