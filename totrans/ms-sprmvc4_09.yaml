- en: Chapter 9. Deploying Your Web Application to the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll take a tour of the different cloud providers, understand
    the challenges and benefits of a distributed architecture, and see how to deploy
    your web application to Pivotal Web Services and to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many forms of cloud hosting. For developers, the choice will be mainly
    between a Platform as a Service (PaaS) and an Infrastructure as a Service (IaaS).
  prefs: []
  type: TYPE_NORMAL
- en: Using the latest, you will often have a bare metal machine that you can manage
    and on which you can install all the services required by your application.
  prefs: []
  type: TYPE_NORMAL
- en: If we leave aside technologies such as Docker (which is absolutely amazing,
    you should absolutely give it a try), this is really similar to traditional hosting
    where your operation team will have to set up and maintain an environment in which
    the application can run.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, PaaS makes it easy to deploy your application as you develop
    it with a simple push-to-deploy workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most well known providers are:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Foundry backed by Pivotal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenShift by Red Hat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heroku acquired by Salesforce in 2010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these three providers come with different pros and cons. I will try
    to give you an overview of these.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Foundry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backed by Pivotal, the company behind Spring, Pivotal Web Service runs on Cloud
    Foundry, an open source PaaS maintained by a foundation, and comes with an interesting
    package.
  prefs: []
  type: TYPE_NORMAL
- en: They offer a 60 day free trial and their pricing is a function of the memory
    allocated for your instances and the number of instances you own.
  prefs: []
  type: TYPE_NORMAL
- en: Their prices range from $2.70 per month for the smallest (128 Mb) instance to
    $43.20 per month for the 2 GB instance.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to give it a try, no credit card is required for the free trial.
    They have a market place to easily install services, such as Redis or Postgre
    SQL, with rather limited free options. They have a good command-line utility to
    manage your application from your console. You can either use buildpacks or push
    a JAR directly for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Build packs will try to guess the stack that you are using and build your application
    in the most standard way (`mvn package` for Maven, `./gradlew stage` for Gradle,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Refer to the tutorial available at the following URL to deploy your application
    to Cloud Foundry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.cloudfoundry.org/buildpacks/java/gsg-spring.html](http://docs.cloudfoundry.org/buildpacks/java/gsg-spring.html)'
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**OpenShift** is maintained by Red Hat and powered by OpenShift Origin, an
    open source facility running Docker containers on top of Google''s Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: It is priced well and offers a lot of freedom, as it is both a PaaS and an IaaS.
    Its pricing is based on gears, containers running an application, or a service
    such as Jenkins, or a database.
  prefs: []
  type: TYPE_NORMAL
- en: OpenShift has a free plan offering three small gears. Your application must
    be idle for 24 hours per month unless you enter your billing information.
  prefs: []
  type: TYPE_NORMAL
- en: Additional or bigger gears are billed at approximately $15 a month for the smallest,
    and $72 for the biggest.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy a Spring Boot application on OpenShift, you will have to use the Do
    It Yourself cartridge. It is a bit more work than other buildpack-based PaaS but
    it is also easier to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the blog post for a Spring Boot tutorial with OpenShift, which
    is available at [http://blog.codeleak.pl/2015/02/openshift-diy-build-spring-boot.html](http://blog.codeleak.pl/2015/02/openshift-diy-build-spring-boot.html).
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heroku is a well known PaaS with extensive documentation and a code-centric
    approach based on build packs. It can connect to a lot of services called add-ons,
    but using them requires your billing information.
  prefs: []
  type: TYPE_NORMAL
- en: It is really interesting for a free project and is very fast to get started
    with. The downside is that it directly costs more than $25 per month if you want
    to scale up. Free instances will go into the sleep mode after 30 minutes of inactivity,
    which means free Heroku apps will always take as much as 30 seconds to load.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku has a great administration dashboard and command-line tools. For this
    chapter, I chose Heroku because it is very straightforward. The concepts you will
    grasp here are applicable to most PaaS.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow most of the chapter and deploy your application without providing
    your credit card information as long as you do not use the Redis add-on. You won't
    be charged if you select the free plan.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your web application to Pivotal Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow this section if you want to deploy your application to Pivotal Web Services
    (PWS).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Cloud Foundry CLI tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do to create a Cloud Foundry application is to set
    up an account on PWS. This is documented at [http://docs.run.pivotal.io/starting/](http://docs.run.pivotal.io/starting/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be asked to create an organization and each new organization will
    have a default space (development) created within the organization. As shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Cloud Foundry CLI tools](img/2117_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the left-hand side navigation bar, you will see a link to **Tools** from
    which you download the CLI. It is also available from the developer console. Select
    the appropriate package for your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Cloud Foundry CLI tools](img/2117_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assembling the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application simply needs to be assembled for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing with PWS is that you don't have to push your sources to deploy.
    You can generate the JAR, push it, and everything will be autodetected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can package this for deployment with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a jar file in the `build/libs` directory. At this point, you
    can execute the following command. The following command targets your deployment
    to your space within PWS (`run.pivotal.io`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have successfully logged in, you can push your jar with the following
    command. You will need to come up with an available name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot that the platform is performing on your behalf. It provisions
    a container and detects which buildpack is needed, in this case, Java.
  prefs: []
  type: TYPE_NORMAL
- en: It then installs the required JDK and uploads the application we pointed it
    to. It creates a route to the application, which it reports to us, and then launches
    the application for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can view the application on the developer console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assembling the application](img/2117_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On selecting the highlighted route, the application will be available for use.
    Visit [http://msmvc4.cfapps.io](http://msmvc4.cfapps.io), then you will see the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assembling the application](img/2117_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bravo!
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that will not work yet is the file upload. However, we will fix
    that in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Activating Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your application services, you can choose between many services. One of them
    is Redis Cloud, which has a free plan with 30 MB of storage. Go ahead and select
    this plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the form, choose whatever name you fancy and bind the service to your application.
    By default, Cloud Foundry will inject some properties in relation to the service
    in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cloud.services.redis.connection.host`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud.services.redis.connection.port`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud.services.redis.connection.password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud.services.redis.connection.uri`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties will always follow the same convention, so it will be easy
    to keep track of your services as you add more.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Cloud Foundry launches Spring applications and activates the Cloud
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take advantage of this and create an `application-cloud.properties`
    file in `src/main/resources`, which will be used when our application is running
    on PWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will bind our Redis instance to our application and activate two additional
    profiles: `prod` and `redis`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also changed the path where the uploaded pictures will land. Note that using
    the file system on the cloud obeys different rules. Refer to the following link
    for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.run.pivotal.io/devguide/deploy-apps/prepare-to-deploy.html#filesystem](http://docs.run.pivotal.io/devguide/deploy-apps/prepare-to-deploy.html#filesystem)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is deactivate one Spring Session feature that
    will not be available on our hosted instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information, visit [http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent](http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent).
  prefs: []
  type: TYPE_NORMAL
- en: You will see that this configuration will also be applied on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. You can reassemble your web application and push it again. Now, your
    sessions and application cache will be stored on Redis!
  prefs: []
  type: TYPE_NORMAL
- en: You may want to explore the marketplace for other available features such as
    binding to data or messaging services, scaling the application, and managing the
    health of the applications that are beyond the scope of this introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Have fun and enjoy the productivity the platform provides!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your web application on Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will deploy your application on Heroku for free. We will
    even use the free Redis instance available to store our session and cache.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do to create a Heroku application is to download
    the command-line tools available at [https://toolbelt.heroku.com](https://toolbelt.heroku.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'On Mac, you can also install it with `brew` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an account on Heroku and use `heroku login` to link the toolbelt to
    your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go to your application root and type `heroku create appName --region
    eu`. Replace `appName` with a name of your choice. If you don''t provide a name,
    it will be generated automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you have already created an application with the UI, then go to your application
    root and simply add the remote `heroku git:remote -a yourapp`.
  prefs: []
  type: TYPE_NORMAL
- en: What these commands do is add a Git remote called `heroku` to our Git repository.
    The process of deploying on Heroku is just pushing one of your branches to Heroku.
    The Git hooks installed on the remote will take care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type `git remote -v` command, you should see the `heroku` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need two ingredients to run a Gradle application with Heroku: a task in
    our build file called `stage` and a tiny file that contains the command used to
    run our application, called `ProcFile`.'
  prefs: []
  type: TYPE_NORMAL
- en: Gradle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Gradle build pack will automatically try to run the `./gradlew stage` command
    on the root of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get more information on the Gradle build pack at [https://github.com/heroku/heroku-buildpack-gradle](https://github.com/heroku/heroku-buildpack-gradle).
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have a "stage" task yet. Add the following code to your `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will define a task called `stage`, which will copy the jar generated by
    Spring Boot at the root of the application and call it `app.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: The jar be much easier to find this way. The `stage` task depends on the `clean`
    task and the `build` task, which means that both of them will be executed before
    the stage task starts.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Gradle will try to optimize the task dependency graph. So, we must
    provide a hint and force the `clean` task to be run before `stage`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add a new instruction to the already existing `clean` task, which
    is to delete the generated `app.jar` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run `./gradlew stage`, it should run the tests and put the packaged
    app at the root of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Procfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Heroku detects a Gradle application, it will automatically run a container
    with Java 8 installed. So, we have very little configuration to take care of.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a file containing the shell command used to run our application.
    Create a file named `Procfile` at the root of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are several things to note here. First, we declare our application as
    a web application. We also redefine the port on which our application will run
    using an environment variable. This is very important as your app will cohabit
    with many others and only one port will be allocated to each one.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can see that our application will run using two profiles. The first
    is the `prod` profile, which we created in the previous chapter, to optimize the
    performance, and a new `heroku` profile that we will create in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: A Heroku profile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We do not want to put sensible information, such as our Twitter app keys, into
    source control. So, we have to create some properties that will read those from
    the application environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work, you have to configure the two environment variables, which
    we discussed earlier, on Heroku. You can do this with the toolbelt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can go to your dashboard and configure the environment in
    the settings tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Heroku profile](img/2117_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [https://devcenter.heroku.com/articles/config-vars](https://devcenter.heroku.com/articles/config-vars)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Running your application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is now time to run our application on Heroku!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already done so, commit all your changes to your master branch.
    Now, simply push your master branch to the `heroku` remote with `git push heroku
    master`. This will download all the dependencies and build your application from
    scratch, so it can take a little time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once the application has been built, it will automatically run. Type `heroku
    logs` to see the latest logs or `heroku logs -t` to tail them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see your application running in the console and if all goes as planned,
    you will be able to connect to [http://yourapp.herokuapp.com](http://yourapp.herokuapp.com).
    As shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running your application](img/2117_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are live! It's time to tell your friends!
  prefs: []
  type: TYPE_NORMAL
- en: Activating Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To activate Redis in our application, we can choose between a few alternatives.
    The Heroku Redis add-on is the beta version. It is entirely free with 20 MB of
    storage, analytics, and logs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [https://elements.heroku.com/addons/heroku-redis](https://elements.heroku.com/addons/heroku-redis)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you will have to provide your credit card details to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the Redis add-on for your application, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, that we have activated the add-on, an environment variable called `REDIS_URL`
    will be available when our application will be running on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check that the variable is defined with the `heroku config` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `RedisConnectionFactory` class does not understand URIs, we need
    to tweak it a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We now have two Heroku-specific beans in the `RedisConfig` class. These beans
    will only be active if both the `redis` and `heroku` profiles are active.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also deactivated some Spring Session configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Session will normally listen to events associated to destroyed session
    keys via the Redis Pub/Sub interface.
  prefs: []
  type: TYPE_NORMAL
- en: It will automatically try to configure the Redis environment to activate listeners
    on startup. In a secured environment like ours, adding listeners is not permitted
    unless you have an admin access.
  prefs: []
  type: TYPE_NORMAL
- en: These redis listeners are not really important in our case, so we can safely
    disable this behavior. For more information, visit [http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent](http://docs.spring.io/spring-session/docs/current/reference/html5/#api-redisoperationssessionrepository-sessiondestroyedevent).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to modify our `Procfile` file so that Heroku runs our application with
    the `redis` profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Commit your change and push the code to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Improving your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a pretty good application deployed online but it's not uber useful nor
    original until you make it so.
  prefs: []
  type: TYPE_NORMAL
- en: Try to make it better and more personal. Once you're proud of your achievement,
    tweet your application URL with the `#masterspringmvc` hashtag on Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to push the best application possible. There is so much that we didn''t
    do. Here are some ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete users' old pictures to avoid keeping unused pictures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Twitter authentication information to fill the user profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interact with the user's account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See real-time searches happening on your app with a web socket channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let your imagination fly!
  prefs: []
  type: TYPE_NORMAL
- en: My version of the application is deployed on [http://masterspringmvc.herokuapp.com](http://masterspringmvc.herokuapp.com).
    I will improve some details to make the application a little more reactive. Try
    to spot the differences!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying our application on a cloud provider is really straightforward as it
    is a runnable jar, thanks to Spring Boot. Cloud deployment is very affordable
    nowadays and deploying a Java application has become almost too easy.
  prefs: []
  type: TYPE_NORMAL
- en: With sessions backed by Redis, we laid the basics of a scalable application.
    Indeed, we can effortlessly add multiple servers behind a load balancer and absorb
    high traffic on demand.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that is not scalable is our WebSocket that will need additional
    work to run on top of a message broker, such as Rabbit MQ.
  prefs: []
  type: TYPE_NORMAL
- en: I can certainly remember a time where finding a host running a Tomcat was rare
    and pricey. Those days are long gone and the future belongs to web developers,
    so make it happen!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see what we can do to make our application even
    better, discuss the technologies we haven't covered, talk about the Spring ecosystem
    in general, and the challenges of modern web applications.
  prefs: []
  type: TYPE_NORMAL
