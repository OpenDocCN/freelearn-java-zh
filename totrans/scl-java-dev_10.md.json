["```java\nname := \"ch10samples\"\n\nversion := \"1.0-SNAPSHOT\"\n\nlibraryDependencies ++= Seq(\n  jdbc,\n  anorm,\n  cache,\n  \"org.mongodb\" %% \"casbah\" % \"2.7.0-RC1\"\n)     \n\nplay.Project.playScalaSettings\n```", "```java\nlibraryDependencies += \"org.slf4j\" % \"slf4j-simple\" % \"1.7.6\"\n```", "```java\nscala> import com.mongodb.casbah.Imports._\nimport com.mongodb.casbah.Imports._\n\n```", "```java\nscala> val mongoClient = MongoClient(\"localhost\", 27017)\nmongoClient: com.mongodb.casbah.MongoClient = com.mongodb.casbah.MongoClient@6fd10428\nscala> val db = mongoClient(\"test\")\ndb: com.mongodb.casbah.MongoDB = test\nscala> val coll = db(\"test\")\ncoll: com.mongodb.casbah.MongoCollection = test\n\n```", "```java\nscala> db.collectionNames\nres0: scala.collection.mutable.Set[String] = Set()\n\n```", "```java\nscala> val sales  = MongoDBObject(\"title\" -> \"sales\",\"amount\"->50)\nsales: com.mongodb.casbah.commons.Imports.DBObject = { \"title\" : \"sales\" , \"amount\" : 50}\nscala> val sweden  = MongoDBObject(\"country\" -> \"Sweden\")\nsweden: com.mongodb.casbah.commons.Imports.DBObject = { \"country\" : \"Sweden\"}\n\n```", "```java\nscala> coll.insert(sales)\nres1: com.mongodb.casbah.TypeImports.WriteResult = { \"serverUsed\" : \"localhost:27017\" , \"n\" : 0 , \"connectionId\" : 7 , \"err\" :  null  , \"ok\" : 1.0}\nscala> coll.insert(sweden)\nres2: com.mongodb.casbah.TypeImports.WriteResult = { \"serverUsed\" : \"localhost:27017\" , \"n\" : 0 , \"connectionId\" : 7 , \"err\" :  null  , \"ok\" : 1.0}\nscala> coll.count()\nres3: Int = 2\n\n```", "```java\nscala> val documents = coll.find() foreach println \n{ \"_id\" : { \"$oid\" : \"530fd91d03645ab9c17d9012\"} , \"title\" : \"sales\" , \"amount\" : 50}\n{ \"_id\" : { \"$oid\" : \"530fd92703645ab9c17d9013\"} , \"country\" : \"Sweden\"}\ndocuments: Unit = ()\n\n```", "```java\nscala> val searchedCountry  = MongoDBObject(\"country\" -> \"Sweden\")\nsearchedCountry: com.mongodb.casbah.commons.Imports.DBObject = { \"country\" : \"Sweden\"}\nscala> val result = coll.findOne(searchedCountry)\nresult: Option[coll.T] = Some({ \"_id\" : { \"$oid\" : \"530fd92703645ab9c17d9013\"} , \"country\" : \"Sweden\"})\n\n```", "```java\nscala> val emptyResult = coll.findOne(MongoDBObject(\"country\" -> \"France\"))\nemptyResult: Option[coll.T] = None\n\n```", "```java\nscala> val result = coll.remove(searchedCountry)\nresult: com.mongodb.casbah.TypeImports.WriteResult = { \"serverUsed\" : \"localhost:27017\" , \"n\" : 1 , \"connectionId\" : 9 , \"err\" :  null  , \"ok\" : 1.0}\nscala> val countryNoMore = coll.findOne(searchedCountry)\ncountryNoMore: Option[coll.T] = None\n\n```", "```java\nscala> sales\nres3: com.mongodb.casbah.commons.Imports.DBObject = { \"title\" : \"sales\" , \"amount\" : 50}\nscala> val newSales = MongoDBObject(\"title\" -> \"sales\",\"amount\"->100)\nnewSales: com.mongodb.casbah.commons.Imports.DBObject = { \"title\" : \"sales\" , \"amount\" : 100\nscala> val result = coll.update(sales,newSales)\nresult: com.mongodb.casbah.TypeImports.WriteResult = { \"serverUsed\" : \"localhost:27017\" , \"updatedExisting\" : true , \"n\" : 1 , \"connectionId\" : 9 , \"err\" :  null  , \"ok\" : 1.0}\nscala> coll.find foreach println\n{ \"_id\" : { \"$oid\" : \"530fd91d03645ab9c17d9012\"} , \"title\" : \"sales\" , \"amount\" : 100}\n\n```", "```java\n{\n  \"title\" : \"root\",\n  \"children\" : [\n    {\n      \"title\" : \"node 1\",\n      \"children\" : [\n        {\n          \"title\" : \"node 1.1\",\n          \"children\" : [\n            ...\n          ]\n        },\n        {\n          \"title\" : \"node 1.2\",\n          \"children\" : [\n            ...\n          ]\n        }\n      ]\n    },\n    {\n      \"title\" : \"node 2\",\n      \"children\" : [\n        ...\n      ]\n    }\n  ]\n}\n```", "```java\n{\n  \"title\" : \"sales\",\n  \"regions\" : [\n    {\n      \"title\" : \"nordic\",\n      \"regions\" : [\n        {\n          \"title\" : \"norway\",\n          \"amount\" : 150\n        },\n        {\n          \"title\" : \"sweden\",\n          \"amount\" : 200\n        }\n      ]\n    },\n    {\n      \"title\" : \"france\",\n      \"amount\" : 400\n    }\n  ]\n}\n```", "```java\nclass WordCount(args : Args) extends Job(args) {\n\n  // Tokenize into words by by splitting on non-characters. This\n  // is imperfect, as it splits hyphenated words, possessives\n  // (\"John's\"), etc.\n  val tokenizerRegex = \"\"\"\\W+\"\"\"\n\n  // Read the file specified by the --input argument and process\n  // each line by trimming the leading and trailing whitespace,\n  // converting to lower case,then tokenizing into words.\n  // The first argument list to flatMap specifies that we pass the\n  // 'line field to the anonymous function on each call and each\n  // word in the returned collection of words is given the name\n  // 'word. Note that TextLine automatically associates the name\n  // 'line with each line of text. It also tracks the line number\n  // and names that field 'offset. Here, we're dropping the\n  // offset.\n\n  TextLine(args(\"input\"))\n    .read\n    .flatMap('line -> 'word) {\n      line : String => line.trim.toLowerCase.split(tokenizerRegex) \n    }\n\n  // At this point we have a stream of words in the pipeline. To\n  // count occurrences of the same word, we need to group the\n  // words together. The groupBy operation does this. The first\n  // argument list to groupBy specifies the fields to group over\n  // as the key. In this case, we only use the 'word field. \n  // The anonymous function is passed an object of type\n  // com.twitter.scalding.GroupBuilder. All we need to do is\n  // compute the size of the group and we give it an optional\n  // name, 'count.\n    .groupBy('word){ group => group.size('count) }\n\n  // In many data flows, we would need to project out just the\n  // 'word and 'count, since we don't care about them any more,\n  // but groupBy has already eliminated everything but 'word and\n  // 'count. Hence, we'll just write them out as tab-delimited\n  // values.\n    .write(Tsv(args(\"output\")))\n}\n```", "```java\npackage parsercombinator\n\nimport scala.util.parsing.combinator._\nimport java.text.SimpleDateFormat\nimport java.util.Date\n\nobject FormulaCalculator {\n\n  abstract class Node\n\n  case class Transaction(amount: Int)\n  case class Account(name:String) extends Node {\n    var transactions: Iterable[Transaction] = List.empty\n  }\n\n  def addNewTransaction(startingBalance: Int, t: Transaction) = startingBalance + t.amount\n  def balance(account: Account) = account.transactions.foldLeft(0)(addNewTransaction)\n\n  case class NumberOfPeriods (value: Int) extends Node {\n    override def toString = value.toString\n  }\n  case class RelativePeriod (value:String) extends Node {\n    override def toString = value\n  }\n  case class Variable(name : String) extends Node\n  case class Number(value : Double) extends Node\n  case class UnaryOp(operator : String, arg : Node) extends Node\n  case class BinaryOp(operator : String, left : Node, right : Node) extends Node\n  case class Function(name:String,arguments:List[Node]) extends Node {\n    override def toString =\n      name+arguments.mkString(\"(\",\",\",\")\")\n  }…\n```", "```java\n…\n  def evaluate(e : Node) : Double = {\n    e match {\n      case Number(x) => x\n      case UnaryOp(\"-\", x) => -(evaluate(x))\n      case BinaryOp(\"+\", x1, x2) => (evaluate(x1) + evaluate(x2))\n      case BinaryOp(\"-\", x1, x2) => (evaluate(x1) - evaluate(x2))\n      case BinaryOp(\"*\", x1, x2) => (evaluate(x1) * evaluate(x2))\n      case BinaryOp(\"/\", x1, x2) => (evaluate(x1) / evaluate(x2))\n    }\n  }\n\n  object FormulaParser extends JavaTokenParsers {        \n\n    val identifier: Parser[String] = ident\n    val relative_period: Parser[RelativePeriod] = \"\"\"([N|P|\\+|\\-][0-9]+|CURRENT)\"\"\".r ^^ RelativePeriod\n    val number_of_periods: Parser[NumberOfPeriods] = \"\"\"\\d+\"\"\".r ^^ (i => NumberOfPeriods(i.toInt))\n    val account_name: Parser[String] = \"\"\"[A-Za-z0-9_]+\"\"\".r\n\n    def account: Parser[Account] = \"#\" ~> account_name <~ \"#\" ^^ { Account(_) }\n\n    def function: Parser[Function] =\n      identifier~\"(\"~account~\",\"~relative_period~\",\"~number_of_periods~\")\" ^^ {\n        case f~\"(\"~acc~\",\"~rp~\",\"~nbp~\")\" => Function(f,List(acc,rp,nbp))\n      } |\n      identifier~\"(\"~account~\",\"~relative_period~\")\" ^^ {\n        case f~\"(\"~acc~\",\"~rp~\")\" => Function(f,List(acc,rp))\n      }\n\n      def node: Parser[Node] =\n        (term ~ \"+\" ~ term) ^^ { case lhs~plus~rhs => BinaryOp(\"+\", lhs, rhs) } |\n        (term ~ \"-\" ~ term) ^^ { case lhs~minus~rhs => BinaryOp(\"-\", lhs, rhs) } |\n        term\n\n      def term: Parser[Node] =\n        (factor ~ \"*\" ~ factor) ^^ { case lhs~times~rhs => BinaryOp(\"*\", lhs, rhs) } |\n        (factor ~ \"/\" ~ factor) ^^ { case lhs~div~rhs => BinaryOp(\"/\", lhs, rhs) } |\n        (factor ~ \"^\" ~ factor) ^^ { case lhs~exp~rhs => BinaryOp(\"^\", lhs, rhs) } |\n        factor\n\n      def factor : Parser[Node] =\n        \"(\" ~> node <~ \")\" |\n        floatingPointNumber ^^ {x => Number(x.toFloat) } |\n        account |\n        function\n\n      def parse(text : String) =\n            parseAll(node, text)        \n    }\n\n    // Parses 3 formula that make computations on accounts\n    def main(args: Array[String]) {\n\n        val formulaList = List(\"3*#ACCOUNT1#\",\"#ACCOUNT1#- #ACCOUNT2#\",\"AVERAGE_UNDER_PERIOD(#ACCOUNT4#,+1,12)\")\n\n        formulaList.foreach { formula =>\n            val unspacedFormula = formula.replaceAll(\"[ ]+\",\"\")\n            println(s\"Parsing of $formula gives result:\\n ${FormulaParser.parse(unspacedFormula)}\")\n        }\n    }\n}\n```", "```java\nParsing of 3*#ACCOUNT1# gives result:\n [1.13] parsed: BinaryOp(*,Number(3.0),Account(ACCOUNT1))\nParsing of #ACCOUNT1#- #ACCOUNT2# gives result:\n [1.22] parsed: BinaryOp(-,Account(ACCOUNT1),Account(ACCOUNT2))\nParsing of AVERAGE_UNDER_PERIOD(#ACCOUNT4#,+1,12) gives result:\n [1.39] parsed: AVERAGE_UNDER_PERIOD(Account(ACCOUNT4),+1,12)\n\n```", "```java\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Example Scala.js application</title>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\n</head>\n<body>\n\n<h1>Example Scala.js application - development version</h1>\n\n<p>After having compiled and packaged properly the code for the application\n(using `sbt packageJS`), you should see \"It works\" here below.\nSee README.md for detailed explanations.</p>\n\n<div id=\"playground\">\n</div>\n\n<script type=\"text/javascript\" src=\"img/example-extdeps.js\"></script>\n<script type=\"text/javascript\" src=\"img/example-intdeps.js\"></script>\n<script type=\"text/javascript\" src=\"img/example.js\"></script>\n\n</body>\n</html>\n```", "```java\n<p>\n  <strong>It works!</strong>\n</p>\n```", "```java\npackage example\n\nimport scala.scalajs.js\nimport js.Dynamic.{ global => g }\n\nobject ScalaJSExample {\n  def main(): Unit = {\n    val paragraph = g.document.createElement(\"p\")\n    paragraph.innerHTML = \"<strong>It works!</strong>\"\n    g.document.getElementById(\"playground\").appendChild(paragraph)\n  }\n\n  /** Computes the square of an integer.\n   *  This demonstrates unit testing.\n   */\n  def square(x: Int): Int = x*x\n}\n```", "```java\nScalaJS.modules.example_ScalaJSExample().main();\n```", "```java\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\n[Copy a code block from somewhere with ctrl-C/ctrl-V]\n\n case class Person(name:String)\n\n val me = Person(\"Thomas\")\n val you = Person(\"Current Reader\")\n\n val we = List(you,me).map(_.name).reduceLeft(_+\" & \"+_)\n val status = s\"$we have fun with Scala\"\n\n[Once you are done with pasting the code block, press ctrl-D]\n\n// Exiting paste mode, now interpreting.\n\ndefined class Person\nme: Person = Person(Thomas)\nyou: Person = Person(Current Reader)\nwe: String = Current Reader & Thomas\nstatus: String = Current Reader & Thomas have fun with Scala\n\n```", "```java\nscala> def using[A <: {def close(): Unit},B](param: A)(f: A=>B): B =\n try { f(param) } finally { param.close() }\nusing: [A <: AnyRef{def close(): Unit}, B](param: A)(f: A => B)B\n\n```", "```java\nscala> def appendToFile(fileName:String, textData:String) =\n using (new java.io.FileWriter(fileName, true)){\n fileWriter => using (new java.io.PrintWriter(fileWriter)) {\n printWriter => printWriter.println(textData)\n }\n }\nappendToFile: (fileName: String, textData: String)Unit\n\n```", "```java\nscala> def timedAndLogged[T](body: => T): T = {\n val start = System.nanoTime\n try {\n val result = body\n appendToFile(\"/tmp/repl.log\",result.toString)\n result\n }\n finally println(\" \"+(System.nanoTime - start) + \" nanos elapsed. \")\n}\ntimedAndLogged: [T](body: => T)T\n\n```", "```java\nscala> timedAndLogged{ val input = 2014 ; println(input) ; Thread.sleep(2000) ; input }\n\n2014\n 2004778000 nanos elapsed. \nres0: Int = 2014\n\n```"]