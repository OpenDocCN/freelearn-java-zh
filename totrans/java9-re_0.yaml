- en: '![Image 1](img/index-1_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 2](img/index-2_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Java 9 Regular Expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Zero-length assertions, back-references, quantifiers, and more Anubhava Srivastava
  prefs: []
  type: TYPE_NORMAL
- en: '**BIRMINGHAM - MUMBAI**'
  prefs: []
  type: TYPE_NORMAL
- en: < html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
  prefs: []
  type: TYPE_NORMAL
- en: '"http://www.w3.org/TR/REC-html40/loose.dtd">'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java 9 Regular Expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright Â© 2017 Packt Publishing
  prefs: []
  type: TYPE_NORMAL
- en: All rights reserved. No part of this book may be reproduced, stored in a retrieval
    system, or transmitted in any form or by any means, without the prior written
    permission of the publisher, except in the case of brief quotations embedded in
    critical articles or reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Every effort has been made in the preparation of this book to ensure the accuracy
    of the information presented. However, the information contained in this book
    is sold without warranty, either express or implied. Neither the author, nor Packt
    Publishing, and its dealers and distributors will be held liable for any damages
    caused or alleged to be caused directly or indirectly by this book.
  prefs: []
  type: TYPE_NORMAL
- en: Packt Publishing has endeavored to provide trademark information about all of
    the companies and products mentioned in this book by the appropriate use of capitals.
  prefs: []
  type: TYPE_NORMAL
- en: However, Packt Publishing cannot guarantee the accuracy of this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'First published: July 2017'
  prefs: []
  type: TYPE_NORMAL
- en: 'Production reference: 1210717'
  prefs: []
  type: TYPE_NORMAL
- en: Published by Packt Publishing Ltd.
  prefs: []
  type: TYPE_NORMAL
- en: Livery Place
  prefs: []
  type: TYPE_NORMAL
- en: 35 Livery Street
  prefs: []
  type: TYPE_NORMAL
- en: Birmingham
  prefs: []
  type: TYPE_NORMAL
- en: B3 2PB, UK.
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-1-78728-870-6
  prefs: []
  type: TYPE_NORMAL
- en: '[www.packtpub.com](http://www.packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Credits**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Author**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copy Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: Anubhava Srivastava
  prefs: []
  type: TYPE_NORMAL
- en: Muktikant Garimella
  prefs: []
  type: TYPE_NORMAL
- en: '**Reviewer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project Coordinator**'
  prefs: []
  type: TYPE_NORMAL
- en: Peter Verhas
  prefs: []
  type: TYPE_NORMAL
- en: Ulhas Kambali
  prefs: []
  type: TYPE_NORMAL
- en: '**Commissioning Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proofreader**'
  prefs: []
  type: TYPE_NORMAL
- en: Merint Thomas Mathew
  prefs: []
  type: TYPE_NORMAL
- en: Safis Editing
  prefs: []
  type: TYPE_NORMAL
- en: '**Acquisition Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexer**'
  prefs: []
  type: TYPE_NORMAL
- en: Nitin Dasan
  prefs: []
  type: TYPE_NORMAL
- en: Francy Puthiry
  prefs: []
  type: TYPE_NORMAL
- en: '**Content Development Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphics**'
  prefs: []
  type: TYPE_NORMAL
- en: Vikas Tiwari
  prefs: []
  type: TYPE_NORMAL
- en: Abhinash Sahu
  prefs: []
  type: TYPE_NORMAL
- en: '**Technical Editor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Production Coordinator**'
  prefs: []
  type: TYPE_NORMAL
- en: Jijo Maliyekal
  prefs: []
  type: TYPE_NORMAL
- en: Melwyn Dsa
  prefs: []
  type: TYPE_NORMAL
- en: '**About the Author**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anubhava Srivastava** has more than 22 years of professional experience in
    architecture, design, and software development. He specializes mainly in the J2EE'
  prefs: []
  type: TYPE_NORMAL
- en: technology stack, web technologies, CICD, test-driven development, and AWS cloud-based
    development.
  prefs: []
  type: TYPE_NORMAL
- en: He is an active contributor to the Stack Overflow community. He currently stands
    in the top 35 users in terms of reputations out of the 7.5 million Stack Overflow
    users.
  prefs: []
  type: TYPE_NORMAL
- en: He is passionate about regular expressions and is always willing to sharpen
    his regex skills further. He has answered close to 10,000 regex questions on Stack
    Overflow.
  prefs: []
  type: TYPE_NORMAL
- en: He has authored and released a test-driven framework, called GenericFixture,
    for
  prefs: []
  type: TYPE_NORMAL
- en: '[FitNesse as an open source software. He maintains a technical blog at http://anubhava.wo](http://anubhava.wordpress.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '[rdpress.com](http://anubhava.wordpress.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Anubhava can be found on LinkedIn at [https://www.linkedin.com/in/anubhava/](https://www.linkedin.com/in/anubhava/)
  prefs: []
  type: TYPE_NORMAL
- en: You can follow him on Twitter at @anubhava.
  prefs: []
  type: TYPE_NORMAL
- en: '*First, I would like to express my gratitude toward the whole editing and publishing*
    *team at Packt Publishing for offering me an opportunity to write this book. Their*
    *support and guidance throughout this process encouraged me to explore more and
    dig* *deep.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This book would not have been possible without the support and encouragement
    of my* *wife and kids. I am really grateful to my family for trusting in my abilities
    and for* *understanding my long hours in front of the computer on weekends and
    holidays.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*I want to acknowledge the immensely knowledgeable Stack Overflow contributors
    and* *open source community for teaching me advanced regex concepts.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lastly, I want to say big thanks to my management team at AOL for allowing
    me to* *embark on this book writing journey in my off time.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**About the Reviewer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peter Verhas** is a senior software engineer and software architect with
    a background in electrical engineering and economics. He pursued his MSc from
    TU Budapest and MBA from PTE Hungary. He has also studied at TU Delft and TU Vienna.
    He created his first programs in 1979, and since then, he has been the author
    of several open source programs. He has worked in the telecommunication and finance
    industries in several positions and was the CIO of the Hungarian startup, index.hu,
    during its initial days.'
  prefs: []
  type: TYPE_NORMAL
- en: Peter works for EPAM Systems in Switzerland, participating in software development
    projects at various customer sites. He also supports talent acquisition by interviewing
    candidates and designs internal mentoring programs and training programs for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Peter is the author of *Java 9 Programming by Example* and the co-author of
    *Mastering Java 9* by Packt.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow Peter on Twitter at @verhas, LinkedIn, and GitHub. You can also
    read his technical blog, Java Deep, at [http://javax0.wordpress.com](http://javax0.wordpress.com).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 3](img/index-10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**www.PacktPub.com**'
  prefs: []
  type: TYPE_NORMAL
- en: For support files and downloads related to your book, please visit [www.PacktPub.com.](http://www.PacktPub.com)
  prefs: []
  type: TYPE_NORMAL
- en: Did you know that Packt offers eBook versions of every book published, with
    PDF
  prefs: []
  type: TYPE_NORMAL
- en: and ePub files available? You can upgrade to the eBook version at
  prefs: []
  type: TYPE_NORMAL
- en: '[www.PacktPub.coma](http://www.PacktPub.com)nd as a print book customer, you
    are entitled to a discount on the eBook copy. Get in touch with us at service@packtpub.com
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: At [www.PacktPub.com](http://www.PacktPub.com), you can also read a collection
    of free technical articles, sign up for a range of free newsletters and receive
    exclusive discounts and offers on Packt books and eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/mapt](https://www.packtpub.com/mapt)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the most in-demand software skills with Mapt. Mapt gives you full access
    to all Packt books and video courses, as well as industry-leading tools to help
    you plan your personal development and advance your career.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why subscribe?**'
  prefs: []
  type: TYPE_NORMAL
- en: Fully searchable across every book published by Packt
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  prefs: []
  type: TYPE_NORMAL
- en: On demand and accessible via a web browser
  prefs: []
  type: TYPE_NORMAL
- en: '**Customer Feedback**'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for purchasing this Packt book. At Packt, quality is at the heart of
    our editorial process. To help us improve, please leave us an honest review on
    this book's Amazon page at [https://www.amazon.com/dp/1787288706\.](https://www.amazon.com/dp/1787288706)
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to join our team of regular reviewers, you can e-mail us at customerreviews@packtpub.com.
    We award our regular reviewers with free eBooks and videos in exchange for their
    valuable feedback. Help us be relentless in improving our products!
  prefs: []
  type: TYPE_NORMAL
- en: '**Table of Contents**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Preface](#p16)'
  prefs: []
  type: TYPE_NORMAL
- en: '[What this book covers](#p17)'
  prefs: []
  type: TYPE_NORMAL
- en: '[What you need for this book](#p18)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Who this book is for](#p19)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Conventions](#p20)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Reader feedback](#p21)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Customer support](#p22)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Downloading the example code](#p23)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Errata](#p24)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Piracy](#p25)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Questions](#p26)'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. [Getting Started with Regular Expressions](#p27)
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction to regular expressions](#p28)'
  prefs: []
  type: TYPE_NORMAL
- en: '[A bit of history of regular expressions](#p29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Various flavors of regular expressions](#p30)'
  prefs: []
  type: TYPE_NORMAL
- en: '[What type of problems need regular expressions to solve](#p31)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The basic rules of regular expressions](#p32)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Constructs of the standard regular expression and meta characters](#p33)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Some basic regular expression examples](#p36)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Eager matching](#p38)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The effect of eager matching on regular expression alternation](#p39)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#p41)'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. [Understanding the Core Constructs of Java Regular Expressions](#p42)
  prefs: []
  type: TYPE_NORMAL
- en: '[Understanding the core constructs of regular expressions](#p43)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Quantifiers](#p44)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Basic quantifiers](#p45)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples using quantifiers](#p46)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Greedy versus reluctant (lazy) matching using quantifiers](#p47)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Possessive quantifiers](#p48)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Boundary constructs](#p50)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples using boundary constructs](#p51)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Character classes](#p52)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples of character classes](#p53)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Range inside a character class](#p54)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples of character range](#p55)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Escaping special regex metacharacters and escaping rules inside the character
    class](#p56)'
  prefs: []
  type: TYPE_NORMAL
- en: '[es](#p56)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Escaping inside a character class](#p57)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples of escaping rules inside the character class](#p58)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Literally matching a string that may contain special regex metacharacters](#p59)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Negated character classes](#p60)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples of negated character classes](#p61)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Predefined shorthand character classes](#p62)'
  prefs: []
  type: TYPE_NORMAL
- en: '[POSIX character classes](#p63)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Unicode support in Java regular expressions](#p64)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Commonly used Unicode character properties](#p65)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Negation of the preceding regex directives](#p66)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Unicode scripts support](#p67)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples of matching Unicode text in regular expressions](#p69)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Double escaping in a Java String when defining regular expressions](#p70)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Embedded regular expression mode modifiers](#p71)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The placement of embedded modes in a Java regular expression](#p73)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Disabling mode modifiers](#p74)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#p75)'
  prefs: []
  type: TYPE_NORMAL
- en: 3\. [Working with Groups, Capturing, and References](#p76)
  prefs: []
  type: TYPE_NORMAL
- en: '[Capturing groups](#p77)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Group numbering](#p78)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Named groups](#p80)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Non-capturing groups](#p81)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Advantages of non-capturing groups](#p82)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Back references](#p83)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Back reference of a named group](#p85)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Replacement reference of a named group](#p86)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Forward references](#p87)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Invalid (non-existing) backward or forward references](#p89)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#p90)'
  prefs: []
  type: TYPE_NORMAL
- en: 4\. [Regular Expression Programming Using Java String and Scanner APIs](#p91)
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction to the Java String API for regular expressions'' evaluation](#p92)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Method - boolean matches(String regex)](#p93)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example of the matches method](#p94)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Method - String replaceAll(String regex, String replacement)](#p96)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples of the replaceAll method](#p97)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Method - String replaceFirst(String regex, String replacement)](#p99)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples of the replaceFirst method](#p100)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Methods - String split methods](#p101)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The limit parameter rules](#p102)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples of the split method](#p103)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example of the split method using the limit parameter](#p104)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using regular expressions in Java Scanner API](#p106)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p110)'
  prefs: []
  type: TYPE_NORMAL
- en: 5\. [Introduction to Java Regular Expression APIs - Pattern and Matcher Classes](index_split_001.html#p111)
  prefs: []
  type: TYPE_NORMAL
- en: '[The MatchResult interface](index_split_001.html#p112)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Pattern class](index_split_001.html#p114)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples using the Pattern class](index_split_001.html#p116)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Filtering a list of tokens using the asPredicate() method](index_split_001.html#p119)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Matcher class](index_split_001.html#p120)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples using the Matcher class](index_split_001.html#p123)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Method Boolean lookingAt()](index_split_001.html#p124)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The matches() method](index_split_001.html#p125)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The find() and find(int start) methods](index_split_001.html#p126)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The appendReplacement(StringBuffer sb, String replacement) method](index_split_001.html#p128)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The appendTail(StringBuffer sb) method](index_split_001.html#p129)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example of the appendReplacement and appendTail methods](index_split_001.html#p130)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p132)'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. [Exploring Zero-Width Assertions, Lookarounds, and Atomic Groups](index_split_001.html#p133)
  prefs: []
  type: TYPE_NORMAL
- en: '[Zero-width assertions](index_split_001.html#p134)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Predefined zero-width assertions](index_split_001.html#p135)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Regex defined zero-width assertions](index_split_001.html#p136)'
  prefs: []
  type: TYPE_NORMAL
- en: '[\G boundary assertion](index_split_001.html#p137)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Atomic groups](index_split_001.html#p139)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lookahead assertions](index_split_001.html#p141)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Positive lookahead](index_split_001.html#p142)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Negative lookahead](index_split_001.html#p143)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lookbehind assertions](index_split_001.html#p144)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Positive lookbehind](index_split_001.html#p145)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Negative lookbehind](index_split_001.html#p146)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Capturing text from overlapping matches](index_split_001.html#p151)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Be careful with capturing groups inside a lookahead or lookbehind atomic group](index_split_001.html#p153)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lookbehind limitations in Java regular expressions](index_split_001.html#p154)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p155)'
  prefs: []
  type: TYPE_NORMAL
- en: 7\. [Understanding the Union, Intersection, and Subtraction of Character Classes](index_split_001.html#p156)
  prefs: []
  type: TYPE_NORMAL
- en: '[The union of character classes](index_split_001.html#p157)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The intersection of character classes](index_split_001.html#p159)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The subtraction of character classes](index_split_001.html#p162)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why should you use composite character classes?](index_split_001.html#p164)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p165)'
  prefs: []
  type: TYPE_NORMAL
- en: 8\. [Regular Expression Pitfalls, Optimization, and Performance Improvements](index_split_001.html#p166)
  prefs: []
  type: TYPE_NORMAL
- en: '[Common pitfalls and ways to avoid them while writing regular expressions](index_split_001.html#p167)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Do not forget to escape regex metacharacters outside a character class](index_split_001.html#p168)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Avoid escaping every non-word character](index_split_001.html#p169)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Avoid unnecessary capturing groups to reduce memory consumption](index_split_001.html#p170)'
  prefs: []
  type: TYPE_NORMAL
- en: '[However, don''t forget to use the required group around alternation](index_split_001.html#p171)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use predefined character classes instead of longer versions](index_split_001.html#p172)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the limiting quantifier instead of repeating a character or pattern multiple
    times](index_split_001.html#p173)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Do not use an unescaped hyphen in the middle of a character class](index_split_001.html#p174)'
  prefs: []
  type: TYPE_NORMAL
- en: '[The mistake of calling matcher.goup() without a prior call to matcher.find(),
    match](index_split_001.html#p175)'
  prefs: []
  type: TYPE_NORMAL
- en: '[er.matches(), or matcher.lookingAt()](index_split_001.html#p175)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Do not use regular expressions to parse XML / HTML data](index_split_001.html#p177)'
  prefs: []
  type: TYPE_NORMAL
- en: '[How to test and benchmark your regular expression performance](index_split_001.html#p178)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Catastrophic or exponential backtracking](index_split_001.html#p179)'
  prefs: []
  type: TYPE_NORMAL
- en: '[How to avoid catastrophic backtracking](index_split_001.html#p182)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Optimization and performance enhancement tips](index_split_001.html#p185)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use a compiled form of regular expressions](index_split_001.html#p186)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use a negated character class instead of the greedy and slow .* or .+](index_split_001.html#p187)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Avoid unnecessary grouping](index_split_001.html#p188)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use lazy quantifiers strategically instead of greedy quantifiers that cause
    excessive](index_split_001.html#p189)'
  prefs: []
  type: TYPE_NORMAL
- en: '[backtracking](index_split_001.html#p189)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Make use of possessive quantifiers to avoid backtracking](index_split_001.html#p190)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Extract common repeating substrings out of alternation](index_split_001.html#p191)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use atomic group to avoid backtracking and fail fast](index_split_001.html#p192)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](index_split_001.html#p193)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preface**'
  prefs: []
  type: TYPE_NORMAL
- en: In today's information technology world, the size of data is growing by leaps
    and bounds. IT organizations are processing and storing huge amounts of textual
    data collected from various sources, such as user actions, leads, searches, shopping
    data, page views, page hits, and various other forms of user interactions. Search
    algorithms are used for parsing large texts to extract meaningful pertinent information.
    Regular expressions are the backbone of many such search algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions (or regex in short) are everywhere these days. All the modern
    programming languages are shipped with a regex module or library to allow programmers
    to write regex-based programs. Regular expressions are a powerful tool in the
    programmer's toolbox and allow pattern matching. They are also used for manipulating
    text and data. This book will provide you with the know-how (and practical examples)
    to solve real-world problems using regex in Java.
  prefs: []
  type: TYPE_NORMAL
- en: This easy-to-follow regex book is a great place for you to familiarize yourself
    with the core concepts of regular expressions and to master their implementation
    with the new features of Java 9\. You will learn to match, extract, and transform
    text by matching specific words, characters, and patterns. Readers will learn
    how to write efficient regular expressions for solving day-to-day problems involving
    text-based data.
  prefs: []
  type: TYPE_NORMAL
- en: '**What this book covers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](#p27), *Getting Started with Regular Expressions*, teaches what
    regular expressions are, what problems are best solved using regular expressions,
    and the rules to follow while writing them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](#p42), *Understanding the Core Constructs of Java Regular Expressions*,
    covers quantifiers, anchors, boundary matchers, and all the available character
    classes and properties in Java. We will also learn Unicode text matching using
    regex in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](#p76), *Working with Groups, Capturing, and References*, explores
    how to match and capture text in regex, the various types of groups available
    to us, the naming and numbering of a captured group, and how we should use back-reference
    for the captured groups.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](#p91), *Regular Expression Programming Using Java String and Scanner
    APIs*, introduces Java regex using Java String methods, and we will move on to
    regex capabilities in the Java Scanner API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](index_split_001.html#p111), *Introduction to Java Regular Expression
    APIs - Pattern and Matcher* *Classes*, discusses the dedicated Java APIs, java.util.regex.Pattern
    and java.util.regex.Matcher, for complete regex capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](index_split_001.html#p133), *Exploring Zero-width Assertions, Lookarounds,
    and Atomic Groups*, focuses on zero-width assertions in regex. The chapter covers
    various zero-width assertions and their usages. We will then move on to learn
    the important topic of lookarounds in regex.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](index_split_001.html#p156), *Understanding the Union, Intersection,
    and Subtraction of Character* *Classes*, says that the Java language has added
    the features of using the intersection and union of character classes in regex.
    This chapter covers these features.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](index_split_001.html#p166), *Regular Expression Pitfalls, Optimization,
    and Performance Improvements*, explains how to test and optimize a poorly performing
    regex and various other performance tips.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What you need for this book**'
  prefs: []
  type: TYPE_NORMAL
- en: The software in this book was tested on Java version 9 on Ubuntu version 16.10\.
  prefs: []
  type: TYPE_NORMAL
- en: However, all the examples can also be run on the Windows and macOS X operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Who this book is for**'
  prefs: []
  type: TYPE_NORMAL
- en: This book is for Java developers who would like to understand and use regular
    expressions. If you are dealing with text processing problems, such as text validation,
    searching, and text manipulation, then learning regex is very important for you
    to make your job easier. This book does not expect readers to have any prior regex
    knowledge, since the book will cover every aspect of regex, starting from the
    absolute basics of regex. However, a basic knowledge of Java is assumed in order
    to be able to write and execute the example programs provided in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 4](img/index-20_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 5](img/index-20_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Conventions**'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you will find a number of text styles that distinguish between
    different kinds of information. Here are some examples of these styles and an
    explanation of their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code words in text, database table names, folder names, filenames, file extensions,
    pathnames, dummy URLs, user input, and Twitter handles are shown as follows: "The
    next lines of code read the link and assign it to the to the BeautifulSoup function."'
  prefs: []
  type: TYPE_NORMAL
- en: 'A block of code is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: public class StringMatches
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we wish to draw your attention to a particular part of a code block, the
    relevant lines or items are set in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[default]'
  prefs: []
  type: TYPE_NORMAL
- en: exten => s,1,Dial(Zap/1|30)
  prefs: []
  type: TYPE_NORMAL
- en: '**exten => s,2,Voicemail(u100)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**exten => s,102,Voicemail(b100)**'
  prefs: []
  type: TYPE_NORMAL
- en: exten => i,1,Voicemail(s0)
  prefs: []
  type: TYPE_NORMAL
- en: 'Any command-line input or output is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\Python34\Scripts> pip install -upgrade pip**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\Python34\Scripts> pip install pandas**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New terms** and **important words** are shown in bold. Words that you see
    on the screen, for example, in menus or dialog boxes, appear in the text like
    this: "In order to download new modules, we will go to Files | Settings | Project
    Name | Project Interpreter."'
  prefs: []
  type: TYPE_NORMAL
- en: '*Warnings or important notes appear like this.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tips and tricks appear like this.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reader feedback**'
  prefs: []
  type: TYPE_NORMAL
- en: Feedback from our readers is always welcome. Let us know what you think about
    this book-what you liked or disliked. Reader feedback is important for us as it
    helps us develop titles that you will really get the most out of.
  prefs: []
  type: TYPE_NORMAL
- en: To send us general feedback, simply e-mail feedback@packtpub.com, and mention
    the book's title in the subject of your message. If there is a topic that you
    have expertise in and you are interested in either writing or contributing to
    a book, see our author guide at [www.packtpub.com/authors.](http://www.packtpub.com/authors)
  prefs: []
  type: TYPE_NORMAL
- en: '**Customer support**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are the proud owner of a Packt book, we have a number of things
    to help you to get the most from your purchase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloading the example**'
  prefs: []
  type: TYPE_NORMAL
- en: '**code**'
  prefs: []
  type: TYPE_NORMAL
- en: '[You can download the example code files for this book from your account at
    http://ww](http://www.packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '[w.packtpub.com. If you purchased this book elsewhere, you can visit http://www.packtpub.c](http://www.packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '[om/support and register to have the files e-mailed directly to you.](http://www.packtpub.com/support)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code files by following these steps: 1\. Log in or register
    to our website using your e-mail address and password.'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Hover the mouse pointer on the SUPPORT tab at the top.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Click on Code Downloads & Errata.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Enter the name of the book in the Search box.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Select the book for which you're looking to download the code files.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Choose from the drop-down menu where you purchased this book from.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Click on Code Download.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  prefs: []
  type: TYPE_NORMAL
- en: WinRAR / 7-Zip for Windows
  prefs: []
  type: TYPE_NORMAL
- en: Zipeg / iZip / UnRarX for Mac
  prefs: []
  type: TYPE_NORMAL
- en: 7-Zip / PeaZip for Linux
  prefs: []
  type: TYPE_NORMAL
- en: '[The code bundle for the book is also hosted on GitHub at https://github.com/PacktPublishin](https://github.com/PacktPublishing/Java-9-Regular-Expressions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[g/Java-9-Regular-Expressions. We also have other code bundles from our rich
    catalog of](https://github.com/PacktPublishing/Java-9-Regular-Expressions)'
  prefs: []
  type: TYPE_NORMAL
- en: books and videos available at [https://github.com/PacktPublishing/.](https://github.com/PacktPublishing/)
    Check them out!
  prefs: []
  type: TYPE_NORMAL
- en: '**Errata**'
  prefs: []
  type: TYPE_NORMAL
- en: Although we have taken every care to ensure the accuracy of our content, mistakes
    do happen. If you find a mistake in one of our books-maybe a mistake in the text
    or the code-we would be grateful if you could report this to us. By doing so,
    you can save other readers from frustration and help us improve subsequent versions
    of this book. If you find any errata, please report them by visiting [http://www.packtpub.com/submit-errata,](http://www.packtpub.com/submit-errata)
  prefs: []
  type: TYPE_NORMAL
- en: selecting your book, clicking on the Errata Submission Form link, and entering
    the details of your errata. Once your errata are verified, your submission will
    be accepted and the errata will be uploaded to our website or added to any list
    of existing errata under the Errata section of that title.
  prefs: []
  type: TYPE_NORMAL
- en: '[To view the previously submitted errata, go to https://www.packtpub.com/books/content/supp](https://www.packtpub.com/books/content/support)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ort and enter the name of the book in the search field. The required information
    will](https://www.packtpub.com/books/content/support)'
  prefs: []
  type: TYPE_NORMAL
- en: appear under the Errata section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Piracy**'
  prefs: []
  type: TYPE_NORMAL
- en: Piracy of copyrighted material on the Internet is an ongoing problem across
    all media.
  prefs: []
  type: TYPE_NORMAL
- en: At Packt, we take the protection of our copyright and licenses very seriously.
    If you come across any illegal copies of our works in any form on the Internet,
    please provide us with the location address or website name immediately so that
    we can pursue a remedy.
  prefs: []
  type: TYPE_NORMAL
- en: Please contact us at copyright@packtpub.com with a link to the suspected pirated
    material.
  prefs: []
  type: TYPE_NORMAL
- en: We appreciate your help in protecting our authors and our ability to bring you
    valuable content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Questions**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a problem with any aspect of this book, you can contact us at questions@packtpub.com,
    and we will do our best to address the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting Started with Regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to regular expressions (or regex in
    short). You will learn about some real-world problems that can be solved by using
    regular expressions and the basic building blocks of regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter: Introduction to regular
    expressions'
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: The various flavors of regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: What type of problems need regular expressions to solve
  prefs: []
  type: TYPE_NORMAL
- en: The basic rules of writing regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: Standard regular expression meta characters
  prefs: []
  type: TYPE_NORMAL
- en: Basic regular expression examples
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression (or in short regex) is a very useful tool that is used to
    describe a search pattern for matching the text. Regex is nothing but a sequence
    of some characters that defines a search pattern. Regex is used for parsing, filtering,
    validating, and extracting meaningful information from large text, such as logs
    and output generated from other programs.
  prefs: []
  type: TYPE_NORMAL
- en: We find regular expressions in day-to-day use on many websites. For example,
    while searching for your favorite recipe on search engines, while filling up forms
    and entering data such as username and passwords, and so on. While setting up
    a password on many sites, we encounter password validation errors, such as password
    must contain one digit or at least one uppercase letter or at least one special
    character, and so on. All these checks can be done using regular expressions.
    A few more typical examples of regular expressions are validating phone numbers
    or validating postal/zip/pin codes.
  prefs: []
  type: TYPE_NORMAL
- en: '**A bit of history of regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Renowned mathematician Stephen Kleene built a model in the year 1956 using finite
    automata for simple algebra. He described regular languages using his mathematical
    notation called *regular sets*. Computer programmers started using regular expressions
    in the 1970s when the Unix operating system and some of its text editors and text
    processing utilities such as ed, sed, emacs, lex, vi, grep, awk, and so on were
    built.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions gained more popularity with the arrival of Perl and Tcl
    scripting languages in the 1980s and 1990s. Since then, all the popular programming
    languages, such as Java, Python, Ruby, R, PHP, and .NET have built very good support
    of regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Various flavors of regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: All the programming and scripting languages have built-in support for regular
    expressions these days. The basic rules to define and execute regular expressions
    are pretty much the same across all the languages. However, these regex implementations
    have their own flavors that differ from each other at the advanced level. We will
    cover regular expressions using Java in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the popular flavors of regular expressions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET
  prefs: []
  type: TYPE_NORMAL
- en: Java
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs: []
  type: TYPE_NORMAL
- en: PCRE (PHP)
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: VBScript
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: R
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs: []
  type: TYPE_NORMAL
- en: std::regex
  prefs: []
  type: TYPE_NORMAL
- en: boost::regex
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Regular Expressions** (**BRE**) - used by Unix utilities ed, vi, sed,
    grep, and so on'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extended Regular Expressions** (**ERE**) - used by Unix utilities sed, grep,
    awk, and so on'
  prefs: []
  type: TYPE_NORMAL
- en: '**What type of problems need**'
  prefs: []
  type: TYPE_NORMAL
- en: '**regular expressions to solve**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some programmers wonder why they even need to learn regular expressions. Here
    are some use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: While searching for some text at times, there are cases where we don't know
    the value of the text upfront. We just know some rules or patterns of the text.
    For example, searching for a MAC address in a log message, searching for IP
  prefs: []
  type: TYPE_NORMAL
- en: address in a web server access log, or searching for a 10-digit mobile number
    that may be optionally preceded by *0* or *+<2 digit country code>.*
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the length of the text we are trying to extract is unknown, for example,
    searching URLs that start with http:// or https:// in a CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to split a given text on delimiters of a variable type and
    length and generate tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to extract text that falls between two or more search patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we need to validate the various forms of user inputs, such as bank account
    number, passwords, usernames, credit card info, phone number, date of birth, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations where you only want to capture all the repeated words from
    a line.
  prefs: []
  type: TYPE_NORMAL
- en: To convert input text into certain predefined formats, such as inserting a comma
    after every three digits or removing commas inside parentheses only.
  prefs: []
  type: TYPE_NORMAL
- en: To do a global search replace while skipping all the escaped characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**The basic rules of regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of you are familiar with wild cards (in the Unix world, it is called **glob
    pattern**) matching of text. Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**?** matches any single character'
  prefs: []
  type: TYPE_NORMAL
- en: '***** matches any sequence of characters'
  prefs: []
  type: TYPE_NORMAL
- en: '**[abc]** matches any one character inside square brackets, so it will match
    a, b, or c The regular expression pattern goes many steps farther than wild cards,
    where one can set many rules in a regex pattern, such as the following: Match
    a character or a group of characters optionally (0 or 1 times) Use quantifiers
    in regex patterns to match variable length text Use a character class to match
    one of the listed characters or match a range of characters'
  prefs: []
  type: TYPE_NORMAL
- en: Use a negated character class to match any character except those matched by
    the character class
  prefs: []
  type: TYPE_NORMAL
- en: Match only certain character categories, such as match only digits, only upper
    case letters, or only punctuation characters
  prefs: []
  type: TYPE_NORMAL
- en: Match a character or a group of characters for a specific length.
  prefs: []
  type: TYPE_NORMAL
- en: Match a length range, such as allow only six to 10 digits in the input or match
    an input of a minimum of eight characters
  prefs: []
  type: TYPE_NORMAL
- en: Use Boolean "OR" in an alternation to match one of the few alternative options
    Use groups in regex patterns and capture substrings that we want to extract or
    replace from a given input
  prefs: []
  type: TYPE_NORMAL
- en: Alter the behavior of matching by keeping it greedy (eager), lazy (reluctant),
    or possessive
  prefs: []
  type: TYPE_NORMAL
- en: 'Use back references and forward references of groups that we capture Use zero-width
    assertions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start and end anchors
  prefs: []
  type: TYPE_NORMAL
- en: Word boundary
  prefs: []
  type: TYPE_NORMAL
- en: Lookahead and lookbehind assertions
  prefs: []
  type: TYPE_NORMAL
- en: Start a match from the end of a previous match
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a regex to match a or b we can use the following alternation:
    a|b'
  prefs: []
  type: TYPE_NORMAL
- en: 'To match one or more instances of the digit 5, we can use the following: 5+'
  prefs: []
  type: TYPE_NORMAL
- en: 'To match any substring that starts with p and ends with w, we can use the following:
    p.*w'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructs of the standard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**regular expression and meta**'
  prefs: []
  type: TYPE_NORMAL
- en: '**characters**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get familiar with core constructs of regular expressions and some reserve
    meta characters that have a special meaning in regular expressions. We shall cover
    these constructs in detail in the coming chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbol**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.** (dot or'
  prefs: []
  type: TYPE_NORMAL
- en: Matches any character other
  prefs: []
  type: TYPE_NORMAL
- en: Matches **#**, **@**, **A**, **f**, **5**, or **.**
  prefs: []
  type: TYPE_NORMAL
- en: period)
  prefs: []
  type: TYPE_NORMAL
- en: than newline.
  prefs: []
  type: TYPE_NORMAL
- en: '***** matches zero or more'
  prefs: []
  type: TYPE_NORMAL
- en: occurrences of the
  prefs: []
  type: TYPE_NORMAL
- en: m* matches 0 or more
  prefs: []
  type: TYPE_NORMAL
- en: '***** (asterisk)'
  prefs: []
  type: TYPE_NORMAL
- en: preceding character or
  prefs: []
  type: TYPE_NORMAL
- en: occurrences of the letter **m.**
  prefs: []
  type: TYPE_NORMAL
- en: group.
  prefs: []
  type: TYPE_NORMAL
- en: '**+** matches one or more'
  prefs: []
  type: TYPE_NORMAL
- en: '**m+** matches one or more'
  prefs: []
  type: TYPE_NORMAL
- en: '**+** (plus)'
  prefs: []
  type: TYPE_NORMAL
- en: occurrences of the
  prefs: []
  type: TYPE_NORMAL
- en: occurrences of the letter **m.**
  prefs: []
  type: TYPE_NORMAL
- en: preceding element.
  prefs: []
  type: TYPE_NORMAL
- en: '**?** means optional match. It'
  prefs: []
  type: TYPE_NORMAL
- en: is used to match zero or one
  prefs: []
  type: TYPE_NORMAL
- en: occurrence of the preceding
  prefs: []
  type: TYPE_NORMAL
- en: '**?** (question'
  prefs: []
  type: TYPE_NORMAL
- en: '**nm?** means match **n** or **nm**, as'
  prefs: []
  type: TYPE_NORMAL
- en: element. It is also used for
  prefs: []
  type: TYPE_NORMAL
- en: mark)
  prefs: []
  type: TYPE_NORMAL
- en: '**m** is an **optional** match here.'
  prefs: []
  type: TYPE_NORMAL
- en: lazy matching (which will
  prefs: []
  type: TYPE_NORMAL
- en: be covered in the coming
  prefs: []
  type: TYPE_NORMAL
- en: chapters).
  prefs: []
  type: TYPE_NORMAL
- en: '**|** means alternation. It is'
  prefs: []
  type: TYPE_NORMAL
- en: '**m|n|p** means match either the'
  prefs: []
  type: TYPE_NORMAL
- en: '**|** (pipe)'
  prefs: []
  type: TYPE_NORMAL
- en: used to match one of the
  prefs: []
  type: TYPE_NORMAL
- en: letter **m** or the letter **n** or the
  prefs: []
  type: TYPE_NORMAL
- en: elements separated by |
  prefs: []
  type: TYPE_NORMAL
- en: letter p
  prefs: []
  type: TYPE_NORMAL
- en: ^m matches m only when it is
  prefs: []
  type: TYPE_NORMAL
- en: the first character of the
  prefs: []
  type: TYPE_NORMAL
- en: string that we are testing
  prefs: []
  type: TYPE_NORMAL
- en: '**^** is called anchor, that'
  prefs: []
  type: TYPE_NORMAL
- en: against the regular
  prefs: []
  type: TYPE_NORMAL
- en: '**^** (cap)'
  prefs: []
  type: TYPE_NORMAL
- en: matches start of the line
  prefs: []
  type: TYPE_NORMAL
- en: expression. Also, note that
  prefs: []
  type: TYPE_NORMAL
- en: you do not use ^ in the
  prefs: []
  type: TYPE_NORMAL
- en: middle of a regular
  prefs: []
  type: TYPE_NORMAL
- en: expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**$** is called anchor that'
  prefs: []
  type: TYPE_NORMAL
- en: '**$** (dollar)'
  prefs: []
  type: TYPE_NORMAL
- en: '**m$** matches m only at line end.'
  prefs: []
  type: TYPE_NORMAL
- en: matches line end.
  prefs: []
  type: TYPE_NORMAL
- en: '**\b**'
  prefs: []
  type: TYPE_NORMAL
- en: Alphabets, numbers, and
  prefs: []
  type: TYPE_NORMAL
- en: '**\bjava\b** matches the word, java .'
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  prefs: []
  type: TYPE_NORMAL
- en: underscore are considered
  prefs: []
  type: TYPE_NORMAL
- en: So, it will not match javascript
  prefs: []
  type: TYPE_NORMAL
- en: followed
  prefs: []
  type: TYPE_NORMAL
- en: word characters. **\b** asserts
  prefs: []
  type: TYPE_NORMAL
- en: since the word, javascript, will
  prefs: []
  type: TYPE_NORMAL
- en: by the
  prefs: []
  type: TYPE_NORMAL
- en: word boundary, which is the
  prefs: []
  type: TYPE_NORMAL
- en: fail to assert \b after java in the
  prefs: []
  type: TYPE_NORMAL
- en: letter b)
  prefs: []
  type: TYPE_NORMAL
- en: position just before and
  prefs: []
  type: TYPE_NORMAL
- en: regex.
  prefs: []
  type: TYPE_NORMAL
- en: after a word.
  prefs: []
  type: TYPE_NORMAL
- en: '**\B**'
  prefs: []
  type: TYPE_NORMAL
- en: For the input text, *abc*,
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  prefs: []
  type: TYPE_NORMAL
- en: '**\B** asserts true where **\b**'
  prefs: []
  type: TYPE_NORMAL
- en: followed
  prefs: []
  type: TYPE_NORMAL
- en: doesn't, that is, between two
  prefs: []
  type: TYPE_NORMAL
- en: '**\B** will be asserted at two places:'
  prefs: []
  type: TYPE_NORMAL
- en: by
  prefs: []
  type: TYPE_NORMAL
- en: word characters.
  prefs: []
  type: TYPE_NORMAL
- en: uppercase
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Between *a* and *b*.
  prefs: []
  type: TYPE_NORMAL
- en: B)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Between *b* and *c*.
  prefs: []
  type: TYPE_NORMAL
- en: '**(...)** a sub-'
  prefs: []
  type: TYPE_NORMAL
- en: This is for grouping a part
  prefs: []
  type: TYPE_NORMAL
- en: '**m(ab)*t** matches m, followed'
  prefs: []
  type: TYPE_NORMAL
- en: pattern
  prefs: []
  type: TYPE_NORMAL
- en: of text that can be used to
  prefs: []
  type: TYPE_NORMAL
- en: by zero or more occurrences
  prefs: []
  type: TYPE_NORMAL
- en: inside
  prefs: []
  type: TYPE_NORMAL
- en: capture a certain substring
  prefs: []
  type: TYPE_NORMAL
- en: of the substring, **ab**, followed
  prefs: []
  type: TYPE_NORMAL
- en: round
  prefs: []
  type: TYPE_NORMAL
- en: or for setting precedence.
  prefs: []
  type: TYPE_NORMAL
- en: by **t**.
  prefs: []
  type: TYPE_NORMAL
- en: parentheses
  prefs: []
  type: TYPE_NORMAL
- en: A quantifier range to match
  prefs: []
  type: TYPE_NORMAL
- en: '**mp{2,4}** matches m followed **2**'
  prefs: []
  type: TYPE_NORMAL
- en: the preceding element
  prefs: []
  type: TYPE_NORMAL
- en: '{min,max}'
  prefs: []
  type: TYPE_NORMAL
- en: to **4** occurrences of the letter
  prefs: []
  type: TYPE_NORMAL
- en: between the minimum and
  prefs: []
  type: TYPE_NORMAL
- en: p.
  prefs: []
  type: TYPE_NORMAL
- en: the maximum number.
  prefs: []
  type: TYPE_NORMAL
- en: This is called a character
  prefs: []
  type: TYPE_NORMAL
- en: '**[A-Z]** matches any uppercase'
  prefs: []
  type: TYPE_NORMAL
- en: '**[...]**'
  prefs: []
  type: TYPE_NORMAL
- en: class.
  prefs: []
  type: TYPE_NORMAL
- en: English alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '**\d**'
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  prefs: []
  type: TYPE_NORMAL
- en: '**\d** matches any digit in the 0-'
  prefs: []
  type: TYPE_NORMAL
- en: followed
  prefs: []
  type: TYPE_NORMAL
- en: This will match any digit.
  prefs: []
  type: TYPE_NORMAL
- en: 9 range.
  prefs: []
  type: TYPE_NORMAL
- en: by the
  prefs: []
  type: TYPE_NORMAL
- en: letter d)
  prefs: []
  type: TYPE_NORMAL
- en: '**\D**'
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  prefs: []
  type: TYPE_NORMAL
- en: followed
  prefs: []
  type: TYPE_NORMAL
- en: This matches any character
  prefs: []
  type: TYPE_NORMAL
- en: '**\D** matches a, $, or _.'
  prefs: []
  type: TYPE_NORMAL
- en: by
  prefs: []
  type: TYPE_NORMAL
- en: that is not a digit.
  prefs: []
  type: TYPE_NORMAL
- en: uppercase
  prefs: []
  type: TYPE_NORMAL
- en: D)
  prefs: []
  type: TYPE_NORMAL
- en: '**\s**'
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  prefs: []
  type: TYPE_NORMAL
- en: Matches any whitespace,
  prefs: []
  type: TYPE_NORMAL
- en: followed
  prefs: []
  type: TYPE_NORMAL
- en: including tab, space, or
  prefs: []
  type: TYPE_NORMAL
- en: '**\s** matches **[ \t\n]**.'
  prefs: []
  type: TYPE_NORMAL
- en: by the
  prefs: []
  type: TYPE_NORMAL
- en: newline.
  prefs: []
  type: TYPE_NORMAL
- en: letter s)
  prefs: []
  type: TYPE_NORMAL
- en: '**\S**'
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  prefs: []
  type: TYPE_NORMAL
- en: followed
  prefs: []
  type: TYPE_NORMAL
- en: Matches any non-
  prefs: []
  type: TYPE_NORMAL
- en: '**\S** matches the opposite of \s'
  prefs: []
  type: TYPE_NORMAL
- en: by
  prefs: []
  type: TYPE_NORMAL
- en: whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: uppercase
  prefs: []
  type: TYPE_NORMAL
- en: S)
  prefs: []
  type: TYPE_NORMAL
- en: '**\w**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\w** will match [a-zA-Z0-9_], so'
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  prefs: []
  type: TYPE_NORMAL
- en: Matches any word character
  prefs: []
  type: TYPE_NORMAL
- en: it will match any of these
  prefs: []
  type: TYPE_NORMAL
- en: followed
  prefs: []
  type: TYPE_NORMAL
- en: that means all alphanumeric
  prefs: []
  type: TYPE_NORMAL
- en: 'strings: " *abc*", " *a123*", or by the'
  prefs: []
  type: TYPE_NORMAL
- en: characters or underscore.
  prefs: []
  type: TYPE_NORMAL
- en: '" *pq_12_ABC*"'
  prefs: []
  type: TYPE_NORMAL
- en: letter w)
  prefs: []
  type: TYPE_NORMAL
- en: Matches any non-word
  prefs: []
  type: TYPE_NORMAL
- en: '**\W**'
  prefs: []
  type: TYPE_NORMAL
- en: character, including
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  prefs: []
  type: TYPE_NORMAL
- en: whitespaces. In regex, any
  prefs: []
  type: TYPE_NORMAL
- en: It will match any of these
  prefs: []
  type: TYPE_NORMAL
- en: followed
  prefs: []
  type: TYPE_NORMAL
- en: character that is not
  prefs: []
  type: TYPE_NORMAL
- en: 'strings: " *+/=*", " *$*", or " *!~*"'
  prefs: []
  type: TYPE_NORMAL
- en: by the
  prefs: []
  type: TYPE_NORMAL
- en: matched by \w can be
  prefs: []
  type: TYPE_NORMAL
- en: letter W)
  prefs: []
  type: TYPE_NORMAL
- en: matched using \W.
  prefs: []
  type: TYPE_NORMAL
- en: '**Some basic regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expression examples**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some basic examples of regular expressions: ab*c'
  prefs: []
  type: TYPE_NORMAL
- en: This will match a, followed by zero or more b, followed by c.
  prefs: []
  type: TYPE_NORMAL
- en: ab+c
  prefs: []
  type: TYPE_NORMAL
- en: This will match a followed by one or more b, followed by c.
  prefs: []
  type: TYPE_NORMAL
- en: ab?c
  prefs: []
  type: TYPE_NORMAL
- en: This will match a followed by zero or one b, followed by c. Thus, it will match
    both abc or ac.
  prefs: []
  type: TYPE_NORMAL
- en: ^abc$
  prefs: []
  type: TYPE_NORMAL
- en: This will match abc in a line, and the line must not have anything other than
    the string abc due to the use of the start and end anchors on either side of the
    regex.
  prefs: []
  type: TYPE_NORMAL
- en: a(bc)*z
  prefs: []
  type: TYPE_NORMAL
- en: 'This will match a, followed by zero or more occurrences of the string bc, followed
    by z. Thus, it will match the following strings: az, abcz, abcbcz, abcbcbcz, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: ab{1,3}c
  prefs: []
  type: TYPE_NORMAL
- en: 'This will match a, followed by one to three occurrences of b, followed by c.
    Thus, it will match following strings: abc, abbc, and abbbc.'
  prefs: []
  type: TYPE_NORMAL
- en: red|blue
  prefs: []
  type: TYPE_NORMAL
- en: This will match either the string red or the string blue.
  prefs: []
  type: TYPE_NORMAL
- en: \b(cat|dog)\b
  prefs: []
  type: TYPE_NORMAL
- en: This will match either the string cat or the string dog, ensuring both cat and
    dog must be complete words; thus, it will **fail** the match if the input is cats
    or dogs.
  prefs: []
  type: TYPE_NORMAL
- en: '[0-9]'
  prefs: []
  type: TYPE_NORMAL
- en: This is a character class with a character range. The preceding example will
    match a digit between 0 and 9\.
  prefs: []
  type: TYPE_NORMAL
- en: '[a-zA-Z0-9]'
  prefs: []
  type: TYPE_NORMAL
- en: This is a character class with a character range. The preceding example will
    match any alpha-numeric character.
  prefs: []
  type: TYPE_NORMAL
- en: ^\d+$
  prefs: []
  type: TYPE_NORMAL
- en: This regex will match an input containing only one or more digits.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 6](img/index-37_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ^\d{4,8}$
  prefs: []
  type: TYPE_NORMAL
- en: This regex will allow an input containing four to eight digits only. For example,
    1234, 12345, 123456, and 12345678 are valid inputs.
  prefs: []
  type: TYPE_NORMAL
- en: ^\d\D\d$
  prefs: []
  type: TYPE_NORMAL
- en: This regex not only allows only one digit at the start and end but also enforces
    that between these two digits there must be one non-digit character. For example,
    1-5, 3:8, 8X2, and so on are valid inputs.
  prefs: []
  type: TYPE_NORMAL
- en: ^\d+\.\d+$
  prefs: []
  type: TYPE_NORMAL
- en: This regex matches a floating point number. For example, 1.23, 1548.567, and
    7876554.344 are valid inputs.
  prefs: []
  type: TYPE_NORMAL
- en: .+
  prefs: []
  type: TYPE_NORMAL
- en: 'This matches any character one or more times. For example, qwqewe, 12233, or
    f5^h_=!bg are all valid inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: ^\w+\s+\w+$
  prefs: []
  type: TYPE_NORMAL
- en: This matches a word, followed by one or more whitespaces, followed by another
    word in an input. For example, hello word, John Smith, and United Kingdom will
    be matched using this regex.
  prefs: []
  type: TYPE_NORMAL
- en: '***Engine** is a term often used for an underlying module that evaluates* *the
    provided regular expression and matches the input string.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eager matching**'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it is important to understand one important behavior of regular
    expression engines, called eagerness. A regular expression engine performs a match
    operation from left to right in an input string. While matching a regex pattern
    against the input string, the regex engine moves from left to right and is always
    eager to complete a match, even though there are other alternative ways in the
    regular expression to complete the match. Once a substring is matched, it stops
    proceeding further and returns the match. Only when a character position fails
    to match all the possible permutations of the regular expression, then the regex
    engine moves character by character to attempt a match at the next position in
    the input string. While evaluating a regex pattern, the regex engine may move
    backwards (backtrack) one position at a time to attempt matching.
  prefs: []
  type: TYPE_NORMAL
- en: '**The effect of eager matching**'
  prefs: []
  type: TYPE_NORMAL
- en: '**on regular expression**'
  prefs: []
  type: TYPE_NORMAL
- en: '**alternation**'
  prefs: []
  type: TYPE_NORMAL
- en: This regular expression engine behavior may return unexpected matches in alternation
    if alternations are not ordered carefully in the regex pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an example of this regex pattern, which matches the strings white or whitewash:
    white|whitewash'
  prefs: []
  type: TYPE_NORMAL
- en: While applying this regex against an input of *whitewash*, the regex engine
    finds that the first alternative white matches the *white* substring of the input
    string *whitewash*, hence, the regex engine stops proceeding further and returns
    the match as white.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our regex pattern has a better second alternative as whitewash, but
    due to the regex engine's eagerness to complete and return the match, the first
    alternative is returned as a match and the second alternative is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, consider swapping the positions of the third and fourth alternatives
    in our regex pattern to make it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: whitewash|white
  prefs: []
  type: TYPE_NORMAL
- en: If we apply this against the same input, *whitewash*, then the regex engine
    correctly returns the match as whitewash.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use anchors or boundary matchers in our regular expressions to
    make it match a complete word. Any of the following two patterns will match and
    return whitewash as a match:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(white|whitewash)$
  prefs: []
  type: TYPE_NORMAL
- en: \b(white|whitewash)\b
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a more interesting example, which attempts to match a
    known literal string " *cat & rat"* or a complete word in the input, using the
    following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: \b(\w+|cat & rat)\b
  prefs: []
  type: TYPE_NORMAL
- en: 'If the input string is *story of cat & rat*, and we apply our regex pattern
    repeatedly, then the following four matched substrings will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. story
  prefs: []
  type: TYPE_NORMAL
- en: 2\. of
  prefs: []
  type: TYPE_NORMAL
- en: 3\. cat
  prefs: []
  type: TYPE_NORMAL
- en: 4\. rat
  prefs: []
  type: TYPE_NORMAL
- en: It is because the regex engine is eagerly using the first alternative pattern
    \w+ to match a complete word and is returning all the matched words. The engine
    never attempts a second alternative of the literal string, cat & rat, because
    a successful match is always found using the first alternative. However, let's
    change the regex pattern to the
  prefs: []
  type: TYPE_NORMAL
- en: 'following:'
  prefs: []
  type: TYPE_NORMAL
- en: \b(cat & rat|\w+)\b
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply this regex on the same sting, *story of cat & rat*, and we apply
    our regex pattern repeatedly, then the following three matched substrings will
    be returned: 1\. story'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. of
  prefs: []
  type: TYPE_NORMAL
- en: 3\. cat & rat
  prefs: []
  type: TYPE_NORMAL
- en: This is because now cat & rat is the first alternative and when the regex engine
    moves to a position before the letter c in the input, it is able to match and
    return a successful match using the first alternative.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to regular expressions with a bit of history
    and their flavors. You learnt some use cases where regex are needed. Finally,
    we covered the basic rules and building blocks of writing regex, with a few examples.
    You also learnt the eager-matching behavior of the regex engine and how it may
    impact matching in alternations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go a level deeper and cover the core concepts of
    regex in detail, such as quantifiers, lazy vs greedy matching, anchors, negated
    character classes, Unicode and predefined character classes, special escape sequences,
    and the rules of escaping inside a character class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the Core**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructs of Java Regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Using Java as a regular expression flavor, in this chapter, we will go a bit
    deeper and learn in detail about anchors, quantifiers, boundary matchers, all
    the available character classes, negated character classes, predefined character
    classes, and character classes escaping rules, using Java as a reference point.
    You will also learn Unicode text matching, using *regular expressions* in Java.
    We will also cover greedy versus non-greedy (lazy matching) and the change of
    regular expression behavior with lazy matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Anchors and quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: Boundary matchers
  prefs: []
  type: TYPE_NORMAL
- en: Character classes
  prefs: []
  type: TYPE_NORMAL
- en: Regex escaping rules
  prefs: []
  type: TYPE_NORMAL
- en: Escaping inside character classes
  prefs: []
  type: TYPE_NORMAL
- en: Negated character classes
  prefs: []
  type: TYPE_NORMAL
- en: Predefined character classes
  prefs: []
  type: TYPE_NORMAL
- en: Unicode characters matching
  prefs: []
  type: TYPE_NORMAL
- en: Greedy quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: Lazy quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: Possessive quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: Various embedded modes in regular expressions and their meaning Enabling/disabling
    regular expression modes inside the regex
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the core**'
  prefs: []
  type: TYPE_NORMAL
- en: '**constructs of regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Certain special character constructs are allowed literally in Java regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Special**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\0c**'
  prefs: []
  type: TYPE_NORMAL
- en: A character with the octal value c
  prefs: []
  type: TYPE_NORMAL
- en: '**\0cc**'
  prefs: []
  type: TYPE_NORMAL
- en: A character with the octal value cc
  prefs: []
  type: TYPE_NORMAL
- en: A character with the octal value ncc, where n cannot be
  prefs: []
  type: TYPE_NORMAL
- en: '**\0ncc**'
  prefs: []
  type: TYPE_NORMAL
- en: more than 3
  prefs: []
  type: TYPE_NORMAL
- en: '**\xhh**'
  prefs: []
  type: TYPE_NORMAL
- en: A character with the hexadecimal value 0xhh
  prefs: []
  type: TYPE_NORMAL
- en: '**\uhhhh**'
  prefs: []
  type: TYPE_NORMAL
- en: A character with the hexadecimal value 0xhhhh
  prefs: []
  type: TYPE_NORMAL
- en: A character with the hexadecimal value 0xh...h, where h
  prefs: []
  type: TYPE_NORMAL
- en: '**\x{h...h}**'
  prefs: []
  type: TYPE_NORMAL
- en: must be a valid CODE_POINT
  prefs: []
  type: TYPE_NORMAL
- en: '**\n**'
  prefs: []
  type: TYPE_NORMAL
- en: Newline character or u000A
  prefs: []
  type: TYPE_NORMAL
- en: '**\t**'
  prefs: []
  type: TYPE_NORMAL
- en: Tab character or u0009
  prefs: []
  type: TYPE_NORMAL
- en: '**\r**'
  prefs: []
  type: TYPE_NORMAL
- en: Carriage return character or u000D
  prefs: []
  type: TYPE_NORMAL
- en: '**\f**'
  prefs: []
  type: TYPE_NORMAL
- en: Form feed character or u000C
  prefs: []
  type: TYPE_NORMAL
- en: '**\e**'
  prefs: []
  type: TYPE_NORMAL
- en: Escape character or u\u001B
  prefs: []
  type: TYPE_NORMAL
- en: '**\a**'
  prefs: []
  type: TYPE_NORMAL
- en: Bell character or \u0007
  prefs: []
  type: TYPE_NORMAL
- en: '**\cn**'
  prefs: []
  type: TYPE_NORMAL
- en: A control character represented by n
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: We briefly looked at quantifiers in the first chapter. Quantifiers allow us
    to quantify the occurrences of our matches. We can match the input in various
    ways, such as an optional match, an open-ended range, a closed range, and by using
    a fixed number.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at them, as quantifiers are integral to most of the
    regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 7](img/index-45_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Basic quantifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all the quantifiers available in Java regular expressions:
    **Quantifier**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m***'
  prefs: []
  type: TYPE_NORMAL
- en: Match **m** zero or more times
  prefs: []
  type: TYPE_NORMAL
- en: '**m+**'
  prefs: []
  type: TYPE_NORMAL
- en: Match **m** one or more times
  prefs: []
  type: TYPE_NORMAL
- en: '**m?**'
  prefs: []
  type: TYPE_NORMAL
- en: Match **m** one or zero times (also called an optional match) **m{X}**
  prefs: []
  type: TYPE_NORMAL
- en: Match **m** exactly *X* times
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match **m** *X* or more times
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,Y}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match **m** at least *X* and at most *Y* times *In all the aforementioned cases,
    **m** can be a single character or a* *group of characters. We will discuss grouping
    in more detail later.*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 8](img/index-46_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Examples using quantifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at few examples to understand these basic quantifiers better.
  prefs: []
  type: TYPE_NORMAL
- en: Which regex pattern should be used to match a two-digit year or a four-digit
    year?
  prefs: []
  type: TYPE_NORMAL
- en: \d{2}|\d{4}
  prefs: []
  type: TYPE_NORMAL
- en: 'Which regex pattern should be used to match a signed decimal number? The pattern
    should also match a signed integer number:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[+-]?\d*\.?\d+$
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the breakup of the preceding regex pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The ^ and $ symbols are the start/end anchors
  prefs: []
  type: TYPE_NORMAL
- en: The [+-]? pattern makes either the + sign or the - sign (optional because of
    ?) at the start
  prefs: []
  type: TYPE_NORMAL
- en: The \d* pattern matches zero or more digits
  prefs: []
  type: TYPE_NORMAL
- en: The \.? pattern matches an optional dot (.) literally
  prefs: []
  type: TYPE_NORMAL
- en: The \d+ pattern matches one or more digits
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding regex will match all of these inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '.45'
  prefs: []
  type: TYPE_NORMAL
- en: '123789'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '123.45'
  prefs: []
  type: TYPE_NORMAL
- en: '+67.66'
  prefs: []
  type: TYPE_NORMAL
- en: '-987.34'
  prefs: []
  type: TYPE_NORMAL
- en: What would be the regex to match a number that is at least 10 but not more than
    9999?
  prefs: []
  type: TYPE_NORMAL
- en: ^\d{2,4}$
  prefs: []
  type: TYPE_NORMAL
- en: Since we have a minimum of two digits, 10 is the smallest match, whereas the
    maximum number of digits allowed is four, and hence, 9999 is the highest match.
  prefs: []
  type: TYPE_NORMAL
- en: What is the regex for an input that has seven digits and that can have + or
    - at the start?
  prefs: []
  type: TYPE_NORMAL
- en: ^[+-]?\d{7}$
  prefs: []
  type: TYPE_NORMAL
- en: The [+-]? pattern makes it an optional match at the start before we match the
    seven digits using \d{7}.
  prefs: []
  type: TYPE_NORMAL
- en: '*The preceding regex can also be written as ^[+-]?[0-9]{7}$, as \d is a* *shorthand
    property to match [0-9]*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Greedy versus reluctant**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(lazy) matching using**'
  prefs: []
  type: TYPE_NORMAL
- en: '**quantifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed all the quantifiers available to us in a regular expression
    to match fixed-size or variable-length text. These quantifiers are, by default,
    **greedy** in nature. Greediness is in terms of their matching. In a regex, quantifiers
    attempt to match the longest possible text, from left to right. Only when the
    regex engine fails to complete a match, it moves back in the input text one character
    at a time, as required, to complete the match. Sometimes, the regex engine moves
    back and forth multiple times in attempts to complete a match in a complex (nested)
    regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, if the input is pqrstmprt and our regular expression is p.+r,
    then our match will be from p at the start to the last r, that is, pqrstmpr**,**
    not pqr. It is due to the same greediness that was stated earlier, where the regex
    engine attempts to match the longest possible match when using quantifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions also provide a way to change this greedy behavior of the
    regex engine. If we place a ? ( *called the lazy or reluctant quantifier*) in
    front of any of the quantifiers, then the behavior of the regex engine changes
    from **greedy** to **lazy**. With the lazy quantifier in place, the regex engine
    attempts to match the shortest match, only expanding further as required to complete
    the match with the remainder of the regex pattern next to the lazy quantifier.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the preceding example, if we use the regex as p.+?r, then our matched
    text will be pqr, because *pqr* is the smallest possible match between p and r.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of all the greedy quantifiers and their corresponding lazy quantifiers:
    **Greedy Quantifier**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy Quantifier**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m***'
  prefs: []
  type: TYPE_NORMAL
- en: '**m*?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m+**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m+?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m??**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X}?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,}?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,Y}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,Y}?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Possessive quantifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: Possessive quantifiers are quantifiers that are greedy when matching text like
    greedy quantifiers do. Both greedy and possessive quantifiers try to match as
    many characters as possible. The important difference, however, is that the possessive
    quantifiers do not backtrack (go back) unlike greedy quantifiers; therefore, it
    is possible that the regex match fails if the possessive quantifiers go too far.
  prefs: []
  type: TYPE_NORMAL
- en: 'This table shows all the three types of quantifiers, side by side: **Greedy
    Quantifier**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy Quantifier**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Possessive** **Quantifier**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m***'
  prefs: []
  type: TYPE_NORMAL
- en: '**m*?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m*+**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m+**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m+?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m++**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m??**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m?+**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X}?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X}+**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,}?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,}+**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,Y}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,Y}?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m{X,Y}+**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example input string, a1b5, and see the behavior of the greedy,
    lazy, and possessive quantifiers.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply a regex using the greedy quantifier, \w+\d, then it will match a1b
    (the longest match before backtracking starts) using \w+, and 5 will be matched
    using \d; thus, the full match will be a1b5\.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we apply a regex using the non-greedy quantifier, \w+?\d, then it will
    match a (the shortest match before expanding starts) using \w+?, and then the
    adjacent digit 1
  prefs: []
  type: TYPE_NORMAL
- en: will be matched using \d. Thus, the first full match will be a1\. If we let
    the regex execute again, then it will find another match, b5\.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we apply a regex using the possessive quantifier, \w++\d, then it
    will match all the characters a1b5 (the longest possible match without giving
    back) using \w++ .
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, \d remains unmatched, and hence the regex fails to find any match.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take another example. The requirement is to match a string that starts
    with lowercase English alphabets or hyphen. The string can have any character
    after the alphabets/hyphens, except a colon. There can be any number of any characters
    of any length after the colon until the end.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a valid input is as-df999 and that of an invalid input is asdf-:123\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try solving this regex problem using a greedy quantifier regex:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[a-z-]+[^:].*$
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is not the right regex pattern because this regex will match
    both
  prefs: []
  type: TYPE_NORMAL
- en: the aforementioned valid and invalid inputs. This is because of the backtracking
    behavior of the regex engine in greedy quantifiers. The [a-z-]+ pattern will find
    the longest possible match in the form of asdf-, but due to the negated character
    class pattern [^:] , the regex engine will backtrack one position to asdf and
    will match the next *hyphen* for [^:]. All the remaining text, that is, :123,
    will be matched using .*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to solve this regex problem using the following possessive quantifier
    regex:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[a-z-]++[^:].*$
  prefs: []
  type: TYPE_NORMAL
- en: This regex pattern will still match our valid input, but it will fail to match
    an invalid input because there is no backtracking in possessive quantifiers; hence,
    the regex engine will not go back any position after matching asdf- in the second
    example string. Since the next character is a colon and our regex sub-pattern
    is [^:], the regex engine will stop matching and correctly declare our invalid
    input a failed match.
  prefs: []
  type: TYPE_NORMAL
- en: Possessive quantifiers are good for the performance of the underlying regex
    engine because the engine does not have to keep any backtracking information in
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: The performance increase is even more when a regex fails to match because possessive
    quantifiers fail faster. So, remember that the benefit of possessive quantifiers
    is to improve the regex performance, especially when using nested quantifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 9](img/index-50_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Boundary constructs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boundary constructs allow us to specify where our matches should start or stop
    by restricting our matches to certain boundaries. We avoid matching unwanted text
    by adding restrictions to the start and stop positions of the matching text using
    boundary matchers. Here are all the boundary constructs available in Java regular
    expressions: **Boundary**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Matcher**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  prefs: []
  type: TYPE_NORMAL
- en: Word boundary; position between a word and a non-word
  prefs: []
  type: TYPE_NORMAL
- en: '**\b**'
  prefs: []
  type: TYPE_NORMAL
- en: character
  prefs: []
  type: TYPE_NORMAL
- en: Non-word boundary; it compliments **\b** and asserts true
  prefs: []
  type: TYPE_NORMAL
- en: '**\B**'
  prefs: []
  type: TYPE_NORMAL
- en: wherever **\b** asserts false
  prefs: []
  type: TYPE_NORMAL
- en: '**^**'
  prefs: []
  type: TYPE_NORMAL
- en: Line-start anchor, which matches the start of a line
  prefs: []
  type: TYPE_NORMAL
- en: Line-end anchor, which matches just before the optional line **$**
  prefs: []
  type: TYPE_NORMAL
- en: break at the end of a line
  prefs: []
  type: TYPE_NORMAL
- en: Permanent start of input; in a multiline input using
  prefs: []
  type: TYPE_NORMAL
- en: '**\A**'
  prefs: []
  type: TYPE_NORMAL
- en: MULTILINE mode, **\A** matches only at the very beginning, while **^** is matched
    at every line start position
  prefs: []
  type: TYPE_NORMAL
- en: Permanent end of input; in a multiline input using
  prefs: []
  type: TYPE_NORMAL
- en: '**\z**'
  prefs: []
  type: TYPE_NORMAL
- en: MULTILINE mode, **\z** matches only at the very end while **$**
  prefs: []
  type: TYPE_NORMAL
- en: is matched at every line end position
  prefs: []
  type: TYPE_NORMAL
- en: Similar to **\z** with the only difference being that it matches
  prefs: []
  type: TYPE_NORMAL
- en: '**\Z**'
  prefs: []
  type: TYPE_NORMAL
- en: just before the optional line break at the very end of the input.
  prefs: []
  type: TYPE_NORMAL
- en: End of the previous match; we will discuss it in advanced
  prefs: []
  type: TYPE_NORMAL
- en: '**\G**'
  prefs: []
  type: TYPE_NORMAL
- en: sections of the book in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '*Let''s recall from the first chapter that [a-zA-Z0-9_] are called word* *characters.
    All other characters are considered non-word characters.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 10](img/index-51_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Examples using boundary**'
  prefs: []
  type: TYPE_NORMAL
- en: '**constructs**'
  prefs: []
  type: TYPE_NORMAL
- en: Which regex should be used to match "at" when the input is 'Hat at work"?
  prefs: []
  type: TYPE_NORMAL
- en: \bat\b
  prefs: []
  type: TYPE_NORMAL
- en: The preceding regex should be used because \b (word boundary) stops the regex
    engine to match at in Hat, because \bat\b can match full words only.
  prefs: []
  type: TYPE_NORMAL
- en: What should be regex if we only want to match at in Hat but not the one that
    was matched in the preceding regex?
  prefs: []
  type: TYPE_NORMAL
- en: \Bat\b
  prefs: []
  type: TYPE_NORMAL
- en: Now, this regex will match at that is a part of Hat because \B asserts a position
    that is between two word characters or a position between two non-word characters.
    Because of the presence of \B in the regex, it matches at only in Hat but not
    the word at.
  prefs: []
  type: TYPE_NORMAL
- en: If the input is suppress expression press depression, what will be the matches
    if the regex is \Bpress\B?
  prefs: []
  type: TYPE_NORMAL
- en: suppress ex**press**ion press de**press**ion
  prefs: []
  type: TYPE_NORMAL
- en: This is because \B matches the position between word characters, and the other
    instances, suppress and press, have non-word characters after press.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the input is ppp\n555\n, then show the matched text using the following
    two regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: \Ap+\n5{3}\Z
  prefs: []
  type: TYPE_NORMAL
- en: \Ap+\n5{3}\z
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A)** ppp\n555'
  prefs: []
  type: TYPE_NORMAL
- en: '**B)** No match'
  prefs: []
  type: TYPE_NORMAL
- en: The starting part, \Ap+\n5{3}, is common in both the regex patterns and matches
    ppp\n555 both the times. However, we are getting no match in the second case because
    of the subtle difference between the \Z and \z assertions. \Z asserts the position
    at the end or just before the last line terminator whereas \z always asserts the
    position at the very end. Due to the presence of \n at the end of the file, our
    second regex does not match. If we change the second regex to \Ap+\n5{3}\n\z,
    then it will match the entire input.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that the end anchor $ also behaves like \Z if the MULTILINE flag* *(will
    be discussed later) is not enabled in an input text with multiple* *lines. Thus,
    the preceding input string can also be matched using*'
  prefs: []
  type: TYPE_NORMAL
- en: '*^p+\n5{3}$.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Character classes**'
  prefs: []
  type: TYPE_NORMAL
- en: We briefly looked at character classes in the first chapter. Character classes
    (or character sets) let us match one out of the many characters defined inside
    a class.
  prefs: []
  type: TYPE_NORMAL
- en: Character classes are enclosed inside a square bracket. The order of the characters
    inside a character class does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples of character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Which regex will match the letters *p*, *m*, or *z*?
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution 1:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[pmz]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution 2:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[zmp]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution 3:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[mzp]'
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding three regular expressions will behave in exactly the same
    manner because the order of the characters inside the character class does not
    matter.
  prefs: []
  type: TYPE_NORMAL
- en: Which regex will match English language vowels *a*, *e*, *i*, *o*, and *u*?
  prefs: []
  type: TYPE_NORMAL
- en: '[aeiou]'
  prefs: []
  type: TYPE_NORMAL
- en: Which regex will match the field extensions .mp3 or .mp3?
  prefs: []
  type: TYPE_NORMAL
- en: \.mp[34]
  prefs: []
  type: TYPE_NORMAL
- en: Which regex will match the letters **@**, **#**, or **=**?
  prefs: []
  type: TYPE_NORMAL
- en: '[@#=]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Range inside a character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**class**'
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify a **character range** inside a character class by using
    a hyphen ( - ) between two characters. You just have to make sure that the left-hand
    side character of a range is lower in the ASCII table than the right-hand side
    character. We can match all the digits using the regex patterns, [0123456789],
    or a shorter [0-9].
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples of character range**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a regex that matches any uppercase or lowercase alphabet in
    the English language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[a-zA-Z]'
  prefs: []
  type: TYPE_NORMAL
- en: The a-z pattern is for the lowercase character range and A-Z is for the uppercase
    character range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches any alphanumeric characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[a-zA-Z0-9]'
  prefs: []
  type: TYPE_NORMAL
- en: Alpha numeric characters consist of any English alphabets and digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches any hexadecimal character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[a-fA-F0-9]'
  prefs: []
  type: TYPE_NORMAL
- en: We know that hexadecimal characters consist of digits, 0 to 9, and letters,
    A to F
  prefs: []
  type: TYPE_NORMAL
- en: (ignore casing). The preceding regex pattern shows a character class that includes
    these two character ranges. We use a-f and A-F ranges to make it match uppercase
    or lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Escaping special regex**'
  prefs: []
  type: TYPE_NORMAL
- en: '**metacharacters and escaping**'
  prefs: []
  type: TYPE_NORMAL
- en: '**rules inside the character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**classes**'
  prefs: []
  type: TYPE_NORMAL
- en: We know that . matches any character, [ and ] are used for character classes,
    { and }
  prefs: []
  type: TYPE_NORMAL
- en: are used for limiting quantifiers, and ? , *, and + are used for various quantifiers.
    To match any of the metacharacters *literally*, one needs to *escape* these characters
    using a *backslash (*\ ) to suppress their special meaning. Similarly, ^ and $
    are anchors that are also considered regex metacharacters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some examples of escaping metacharacters in regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches the string, a.b?:'
  prefs: []
  type: TYPE_NORMAL
- en: a\.b\?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches the string, {food}:'
  prefs: []
  type: TYPE_NORMAL
- en: \{food\}
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches the string, abc:][}{:'
  prefs: []
  type: TYPE_NORMAL
- en: abc:\]\[\}\{
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches the string, $25.50:'
  prefs: []
  type: TYPE_NORMAL
- en: \$\d+\.\d+
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches the string, ^*+.:'
  prefs: []
  type: TYPE_NORMAL
- en: \^\*\+\.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 11](img/index-57_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Escaping inside a character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**class**'
  prefs: []
  type: TYPE_NORMAL
- en: In the Java regex engine, all the special regex metacharacters lose their special
    meaning inside a character class except the ^ (**carrot**), - (**hyphen**), ]
    (**right square** **bracket**), and \ (**backslash**) characters.
  prefs: []
  type: TYPE_NORMAL
- en: '*Inside a character class, the hyphen also does not need to be escaped* *when
    used as the first or last character, since a character range* *requires both the
    left-hand side and the right-hand side characters.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Similarly, ^ (carrot) needs to escaped only when used as the first* *character
    inside a character class.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples of escaping rules**'
  prefs: []
  type: TYPE_NORMAL
- en: '**inside the character class**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches a string containing one or more of the ap.9 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[ap9.]+$
  prefs: []
  type: TYPE_NORMAL
- en: The dot (.) doesn't need to be escaped inside the character class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches a string containing one or more of the @#$%.* characters:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[$#@%.*]+$
  prefs: []
  type: TYPE_NORMAL
- en: None of the preceding special characters require escaping inside the character
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches a string containing one or more of the ?*+. characters:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[*+?.]+$
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches an input that allows any digit, ], or ^ in the
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[\^\]0-9]+$
  prefs: []
  type: TYPE_NORMAL
- en: We can also write our regex as ^[\]0-9^]+$ by moving ^ away from the first position
    and avoiding the escaping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches an input that allows any alphanumeric character,
    hyphen, dot, or backslash, such as xyzTR-4.5\00:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[a-zA-Z0-9.\-\\]+$
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write our regex as follows by moving - to the last position inside
    the character class, thus avoiding the escaping:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[a-zA-Z0-9.\\-]+$
  prefs: []
  type: TYPE_NORMAL
- en: '**Literally matching a string**'
  prefs: []
  type: TYPE_NORMAL
- en: '**that may contain special**'
  prefs: []
  type: TYPE_NORMAL
- en: '**regex metacharacters**'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how we need to escape all the special regex metacharacters to be
    able to match them literally.
  prefs: []
  type: TYPE_NORMAL
- en: The Java regex engine provides special escape sequences, \Q and \E, for this
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Any string that is wrapped between \Q and \E looses interpretation of all the
    regex metacharacters in the wrapped string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to write a regex that matches a string ^*+., we can avoid all
    escaping and use this regex:'
  prefs: []
  type: TYPE_NORMAL
- en: \Q^*+.\E
  prefs: []
  type: TYPE_NORMAL
- en: Note that there must not be any character escaping between \Q and \E sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'To match an input string, "[a-z0-9]", we can write our regex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \Q[a-z0-9]\E
  prefs: []
  type: TYPE_NORMAL
- en: Java provides a convenient method to return a literal pattern sting for the
    given string called Pattern.quote(String). We will learn about this method in
    [Chapter 5,](index_split_001.html#p111) *Introduction* *to Java Regular Expressions
    APIs - Pattern and Matcher Classes*, of the book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 12](img/index-60_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Negated character classes**'
  prefs: []
  type: TYPE_NORMAL
- en: By placing the carrot character (^) in the first position inside a character
    class (just next to [) **negates** the matching of the character class. A negated
    character class matches any character that is not included in the class. A negated
    character class also negates a character range by matching any character not matched
    by the character range.
  prefs: []
  type: TYPE_NORMAL
- en: '*You learned in [Chapter 1](#p27)* *, Getting Started with Regular Expressions,
    that* *dot (.) matches any character except the newline character. However,* *note
    that the negated character class also matches newline characters* *such as \r,
    \n, and so on.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples of negated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**character classes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches any character except a forward slash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[^/]'
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember the fact that a negated character such as [^/] must match a single
    character. It doesn't match zero-width assertions such as ^, $, \Z, \z, \b, \B,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches any character but a and A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[^aA]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches all the *consonants* of the English language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[^aeiou]'
  prefs: []
  type: TYPE_NORMAL
- en: All non-vowels are considered *consonants***;** hence, we just need to negate
    the vowel character class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex matches all the characters except digits, dots, and line
    breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[^0-9.\r\n]'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this regex, we could also use the predefined property \d for [0-9]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[^\d.\r\n]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This regex matches http followed by any character except s: http[^s]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predefined shorthand**'
  prefs: []
  type: TYPE_NORMAL
- en: '**character classes**'
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen from the preceding examples, certain character classes, such
    as digits
  prefs: []
  type: TYPE_NORMAL
- en: '[0-9] or word characters [0-9A-Za-z_], are used in most regex patterns. The
    Java language, like all regular expression flavors, provides convenient predefined
    character classes for these character classes. Here is the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shorthand**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Character Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\d**'
  prefs: []
  type: TYPE_NORMAL
- en: A digit 0-9
  prefs: []
  type: TYPE_NORMAL
- en: '[0-9]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\D**'
  prefs: []
  type: TYPE_NORMAL
- en: A non-digit
  prefs: []
  type: TYPE_NORMAL
- en: '[^\d]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\w**'
  prefs: []
  type: TYPE_NORMAL
- en: A word character
  prefs: []
  type: TYPE_NORMAL
- en: '[a-zA-Z0-9_]'
  prefs: []
  type: TYPE_NORMAL
- en: '**W**'
  prefs: []
  type: TYPE_NORMAL
- en: A non-word character
  prefs: []
  type: TYPE_NORMAL
- en: '[^\w]'
  prefs: []
  type: TYPE_NORMAL
- en: A whitespace character,
  prefs: []
  type: TYPE_NORMAL
- en: '**\s**'
  prefs: []
  type: TYPE_NORMAL
- en: '[ \t\r\n\f\x0B]'
  prefs: []
  type: TYPE_NORMAL
- en: including line break
  prefs: []
  type: TYPE_NORMAL
- en: A non-whitespace
  prefs: []
  type: TYPE_NORMAL
- en: '**\S**'
  prefs: []
  type: TYPE_NORMAL
- en: '[^\s]'
  prefs: []
  type: TYPE_NORMAL
- en: chacracter
  prefs: []
  type: TYPE_NORMAL
- en: A horizontal whitespace
  prefs: []
  type: TYPE_NORMAL
- en: '**\h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[ \t\xA0\u1680\u180e\u2000-'
  prefs: []
  type: TYPE_NORMAL
- en: character
  prefs: []
  type: TYPE_NORMAL
- en: \u200a\u202f\u205f\u3000]
  prefs: []
  type: TYPE_NORMAL
- en: A non-horizontal
  prefs: []
  type: TYPE_NORMAL
- en: '**\H**'
  prefs: []
  type: TYPE_NORMAL
- en: '[^\h]'
  prefs: []
  type: TYPE_NORMAL
- en: whitespace character
  prefs: []
  type: TYPE_NORMAL
- en: A vertical whitespace
  prefs: []
  type: TYPE_NORMAL
- en: '**\v**'
  prefs: []
  type: TYPE_NORMAL
- en: '[\n\x0B\f\r\x85\u2028\u2029]'
  prefs: []
  type: TYPE_NORMAL
- en: character
  prefs: []
  type: TYPE_NORMAL
- en: A non-vertical whitespace
  prefs: []
  type: TYPE_NORMAL
- en: '**\V**'
  prefs: []
  type: TYPE_NORMAL
- en: '[^\v]'
  prefs: []
  type: TYPE_NORMAL
- en: character
  prefs: []
  type: TYPE_NORMAL
- en: '**POSIX character classes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also supports many POSIX character classes for matching ASCII text. Here
    is the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**POSIX Character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Character Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{ASCII}**'
  prefs: []
  type: TYPE_NORMAL
- en: All ASCII characters
  prefs: []
  type: TYPE_NORMAL
- en: '[\x00-\x7F]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Digit}**'
  prefs: []
  type: TYPE_NORMAL
- en: Any digit
  prefs: []
  type: TYPE_NORMAL
- en: '[0-9]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Lower}**'
  prefs: []
  type: TYPE_NORMAL
- en: Lowercase alphabets
  prefs: []
  type: TYPE_NORMAL
- en: '[a-z]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Upper}**'
  prefs: []
  type: TYPE_NORMAL
- en: Uppercase alphabets
  prefs: []
  type: TYPE_NORMAL
- en: '[A-Z]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Alpha}**'
  prefs: []
  type: TYPE_NORMAL
- en: Any alphabet
  prefs: []
  type: TYPE_NORMAL
- en: '[\p{Lower}\p{Upper}]'
  prefs: []
  type: TYPE_NORMAL
- en: Any alpha-numeric
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Alnum}**'
  prefs: []
  type: TYPE_NORMAL
- en: '[\p{Lower}p{Upper}\p{Digit}]'
  prefs: []
  type: TYPE_NORMAL
- en: character
  prefs: []
  type: TYPE_NORMAL
- en: A punctuation
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Punct}**'
  prefs: []
  type: TYPE_NORMAL
- en: '[!"\#$%&''()*+,-./:;<=>?@\'
  prefs: []
  type: TYPE_NORMAL
- en: character
  prefs: []
  type: TYPE_NORMAL
- en: '[\\\]^_`{|}~]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Blank}**'
  prefs: []
  type: TYPE_NORMAL
- en: Space or tab
  prefs: []
  type: TYPE_NORMAL
- en: '[ \t]'
  prefs: []
  type: TYPE_NORMAL
- en: A whitespace
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Space}**'
  prefs: []
  type: TYPE_NORMAL
- en: '[ \t\n\x0B\f\r]'
  prefs: []
  type: TYPE_NORMAL
- en: character
  prefs: []
  type: TYPE_NORMAL
- en: A visible ASCII
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Graph}**'
  prefs: []
  type: TYPE_NORMAL
- en: '[\p{Alnum}\p{Punct}]'
  prefs: []
  type: TYPE_NORMAL
- en: character
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Print}**'
  prefs: []
  type: TYPE_NORMAL
- en: A printable character
  prefs: []
  type: TYPE_NORMAL
- en: '[\p{Graph}\x20]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Cntrl}**'
  prefs: []
  type: TYPE_NORMAL
- en: A control character
  prefs: []
  type: TYPE_NORMAL
- en: '[\x00-\x1F\x7F]'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{XDigit}**'
  prefs: []
  type: TYPE_NORMAL
- en: A hexadecimal digit
  prefs: []
  type: TYPE_NORMAL
- en: '[0-9a-fA-F]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also supports four additional predefined character classes based on the
    java.lang.Character methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing Method**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{javaLowerCase}**'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to java.lang.Character.isLowerCase()
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{javaUpperCase}**'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to java.lang.Character.isUpperCase()
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{javaWhitespace}**'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to java.lang.Character.isWhitespace()
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{javaMirrored}**'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to java.lang.Character.isMirrored()
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode support in Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '**regular expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: So far, all the examples that we have seen in the first two chapters are for
    the English language only. However, a regular expression needs to have full support
    for all the languages using Unicode characters. Java has a Unicode-based regex
    engine and has extensive support for various Unicode scripts, blocks, and categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'A specific Unicode character can be matched in two different ways in Java:
    1\. **Unicode escape sequence** **or the** \u **notation**: This can be written
    as "\u1234" or'
  prefs: []
  type: TYPE_NORMAL
- en: '"\\u1234".'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. **Hex notation**: This can be written as "\x{1234}".'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commonly used Unicode**'
  prefs: []
  type: TYPE_NORMAL
- en: '**character properties**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of commonly used Unicode character properties in regular expressions
    that require to match Unicode texts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode**'
  prefs: []
  type: TYPE_NORMAL
- en: '**character**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Meaning**'
  prefs: []
  type: TYPE_NORMAL
- en: '**class**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{L}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match any letter from any language
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Lu}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match any uppercase letter from any language
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Ll}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match any lowercase letter from any language
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{N}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match any digit from any language
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{P}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match any punctuation letter from any language
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Z}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match any kind of whitespace or invisible separator
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{C}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match any invisible control letter
  prefs: []
  type: TYPE_NORMAL
- en: '**\p{Sc}**'
  prefs: []
  type: TYPE_NORMAL
- en: Match any currency symbol
  prefs: []
  type: TYPE_NORMAL
- en: Any Unicode linebreak sequence; is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]
  prefs: []
  type: TYPE_NORMAL
- en: '**\R**'
  prefs: []
  type: TYPE_NORMAL
- en: '***It is recommended to use** \R **to match any newline character***'
  prefs: []
  type: TYPE_NORMAL
- en: '***even if dealing with ASCII text.***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Negation of the preceding**'
  prefs: []
  type: TYPE_NORMAL
- en: '**regex directives**'
  prefs: []
  type: TYPE_NORMAL
- en: To match a single character belonging to a particular *category*, we use the
  prefs: []
  type: TYPE_NORMAL
- en: \p{propertyName} directive.
  prefs: []
  type: TYPE_NORMAL
- en: To match a single character **not** belonging to a particular *category*, we
    use the
  prefs: []
  type: TYPE_NORMAL
- en: \P{propertyName} directive (note the uppercase **P** instead of the lowercase
    **p**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode scripts support**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java supports all the Unicode scripts as defined by the Unicode standard. Here
    is a list of all the supported Unicode scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsCommon}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsArabic}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsArmenian}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsBengali}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsBopomofo}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsBraille}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsBuhid}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsCanadian_Aboriginal}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsCherokee}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsCyrillic}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsDevanagari}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsEthiopic}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsGeorgian}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsGreek}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsGujarati}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsGurmukhi}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsHan}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsHangul}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsHanunoo}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsHebrew}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsHiragana}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsInherited}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsKannada}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsKatakana}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsKhmer}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsLao}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsLatin}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsLimbu}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsMalayalam}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsMongolian}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsMyanmar}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsOgham}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsOriya}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsRunic}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsSinhala}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsSyriac}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsTagalog}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsTagbanwa}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsTaiLe}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsTamil}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsTelugu}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsThaana}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsThai}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsTibetan}
  prefs: []
  type: TYPE_NORMAL
- en: \p{IsYi}
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode blocks**: Java supports all the previously listed script for matching
    Unicode blocks. We just need to replace Is with In in the preceding expressions.
    For example, to check for a **Thai** code block, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: \p{InThai}
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples of matching**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode text in regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex will match accented characters, such as " **Ã **":'
  prefs: []
  type: TYPE_NORMAL
- en: ^\p{L}+$
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex will match a text consisting of Latin characters and Unicode
    whitespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: ^[\p{IsLatin}\p{Zs}]+$
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex should be used to detect the presence of a **Hebrew** character
    in input:'
  prefs: []
  type: TYPE_NORMAL
- en: \p{InHebrew}
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex should be used to detect an input that contains only **Arabic**
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: ^\p{InArabic}+$
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we match Urdu text? Since Urdu is not a script, we will need to match
    certain Unicode code ranges. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: U+0600 to U+06FF
  prefs: []
  type: TYPE_NORMAL
- en: U+0750 to U+077F
  prefs: []
  type: TYPE_NORMAL
- en: U+FB50 to U+FDFF
  prefs: []
  type: TYPE_NORMAL
- en: U+FE70 to U+FEFF
  prefs: []
  type: TYPE_NORMAL
- en: 'A Java regex to detect the presence of any Urdu character will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Double escaping in a Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '**String when defining regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, all the regular expressions are entered as a String type, where \ acts
    as an escape character and is used to interpret certain special characters such
    as \t, \n, and so on. So, it is necessary to double-escape all the predefined
    classes, such as \w, \d, \s, using two backslashes and while escaping metacharacters,
    such as \[, \(, \+, and so on, in string literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have to use the preceding regex for a dollar amount in Java, then it
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: final String re = "\\$\\d+\\.\\d+";
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example that matches a signed decimal number has to be written
    as follows in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: final String re = "^[+-]?\\d*\\.?\\d+$";
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reasons, if we have to match a single backslash character, then
    it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \\\\
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we write a regex string that matches an input that allows any alphanumeric
    character, hyphen, dot, or backslash, such as xyzTR-4.5\00? Here is how: final
    String re = "^[a-zA-Z0-9.\-\\\\]+$";'
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we write a regular expression in Java that will accept any Latin character,
    Unicode whitespaces, or Unicode digits? Refer to the following regex: final String
    re = "^[\\p{IsLatin}\\p{Zs}\\p{N}]+$"; How to write a regular expression in Java
    that will accept any Unicde character, Unicode whitespaces, Unicode digits, or
    Unicode punctuation characters? Check out the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: 'final String re = "^[\\p{L}\\p{Z}\\p{N}\\p{P}]+$"; The following Java regex
    matches the string, " **abc:][}[**": final String re = "abc:\\]\\[\\}\\{";'
  prefs: []
  type: TYPE_NORMAL
- en: '**Embedded regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expression mode modifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all other regular expression flavors, Java also allows the **embedding**
    of some standard modes in the regular expression itself. These mode modifiers
    are used to change regular expression behavior in a certain manner. In the following
    table, we will list all these modes and their meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: Mode
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs: []
  type: TYPE_NORMAL
- en: Meaning
  prefs: []
  type: TYPE_NORMAL
- en: Ignore case
  prefs: []
  type: TYPE_NORMAL
- en: Enables case-insensitive matching for US-ASCII
  prefs: []
  type: TYPE_NORMAL
- en: '**(?i)**'
  prefs: []
  type: TYPE_NORMAL
- en: mode
  prefs: []
  type: TYPE_NORMAL
- en: text
  prefs: []
  type: TYPE_NORMAL
- en: DOTALL
  prefs: []
  type: TYPE_NORMAL
- en: Makes DOT match all the characters, including
  prefs: []
  type: TYPE_NORMAL
- en: '**(?s)**'
  prefs: []
  type: TYPE_NORMAL
- en: mode
  prefs: []
  type: TYPE_NORMAL
- en: line breaks
  prefs: []
  type: TYPE_NORMAL
- en: Multiline
  prefs: []
  type: TYPE_NORMAL
- en: Makes the carrot and dollar match the start and
  prefs: []
  type: TYPE_NORMAL
- en: '**(?m)**'
  prefs: []
  type: TYPE_NORMAL
- en: mode
  prefs: []
  type: TYPE_NORMAL
- en: end of each line in a multiline input
  prefs: []
  type: TYPE_NORMAL
- en: Unicode-
  prefs: []
  type: TYPE_NORMAL
- en: '**(?u)**'
  prefs: []
  type: TYPE_NORMAL
- en: aware case
  prefs: []
  type: TYPE_NORMAL
- en: Enables Unicode-aware case folding
  prefs: []
  type: TYPE_NORMAL
- en: folding
  prefs: []
  type: TYPE_NORMAL
- en: Unicode
  prefs: []
  type: TYPE_NORMAL
- en: Enables the Unicode version of predefined
  prefs: []
  type: TYPE_NORMAL
- en: '**(?U)**'
  prefs: []
  type: TYPE_NORMAL
- en: matching
  prefs: []
  type: TYPE_NORMAL
- en: character classes and POSIX character classes.
  prefs: []
  type: TYPE_NORMAL
- en: Unix line
  prefs: []
  type: TYPE_NORMAL
- en: '**(?d)**'
  prefs: []
  type: TYPE_NORMAL
- en: Enables Unix lines mode
  prefs: []
  type: TYPE_NORMAL
- en: mode
  prefs: []
  type: TYPE_NORMAL
- en: Comment
  prefs: []
  type: TYPE_NORMAL
- en: Allows for the presence of whitespace and
  prefs: []
  type: TYPE_NORMAL
- en: '**(?x)**'
  prefs: []
  type: TYPE_NORMAL
- en: mode
  prefs: []
  type: TYPE_NORMAL
- en: comments in the regex pattern
  prefs: []
  type: TYPE_NORMAL
- en: Let's check some examples to understand these modes better.
  prefs: []
  type: TYPE_NORMAL
- en: How to match an input in which the starting word is **Java** and the ending
    word is **Mode**, and we don't know what is in between these two words? Also,
    the input may contain line breaks as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example input text, which is in two lines: Java regex'
  prefs: []
  type: TYPE_NORMAL
- en: Embedded Mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: \AJava.*Mode\z
  prefs: []
  type: TYPE_NORMAL
- en: If we use the preceding regex, then the match will fail because we know that
    DOT
  prefs: []
  type: TYPE_NORMAL
- en: 'matches all the characters except line breaks by default. Hence, we need to
    enable the DOTALL mode here using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: (?s)\AJava.*Mode\z
  prefs: []
  type: TYPE_NORMAL
- en: Our regex will match the input because (?s) will enable the **DOTALL** mode
    and then
  prefs: []
  type: TYPE_NORMAL
- en: .* will match the text between **Java** and **Mode**.
  prefs: []
  type: TYPE_NORMAL
- en: It is considered good practice to insert comments and line breaks in a complex
    and lengthy regular expression. In order to allow that, we will need to enable
    the comment mode using (?x).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a regex with comments and extra whitespaces using multiple
    modifiers, including (?x):'
  prefs: []
  type: TYPE_NORMAL
- en: 'String regex = "(?ixs)\\A # assert start of the string\n"'
  prefs: []
  type: TYPE_NORMAL
- en: + "java\n"
  prefs: []
  type: TYPE_NORMAL
- en: + "\\s\n"
  prefs: []
  type: TYPE_NORMAL
- en: + "regex\n"
  prefs: []
  type: TYPE_NORMAL
- en: '+ ".* # match 0 or more of any character including line breaks\n"'
  prefs: []
  type: TYPE_NORMAL
- en: + "Mode\n"
  prefs: []
  type: TYPE_NORMAL
- en: '+ "\\z # assert end of the string";'
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that this regular expression will still match the
    input text that we used in the previous example. You can clearly see how the use
    of (?x) allows us to use arbitrary white-spaces and inline comments in our regex.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the use of the **MULTILINE** mode. In the same input text, that
    is, Java regex\nEmbedded Mode, what would be the regular expression that validates
    the first line only, which contains the text, *Java regex*?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use anchors (caret and dollar) and write the regex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^Java regex$
  prefs: []
  type: TYPE_NORMAL
- en: This regex will **fail** to match our input because the input contains two lines
    and $ will not assert the position at the end of every line without enabling the
    **MULTILINE**
  prefs: []
  type: TYPE_NORMAL
- en: mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change your regex to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: (?m)^Java regex$
  prefs: []
  type: TYPE_NORMAL
- en: And bingo! Our regex works now because we enabled the **MULTILINE** mode using
    (?m) at the start of the regex.
  prefs: []
  type: TYPE_NORMAL
- en: '**The placement of embedded**'
  prefs: []
  type: TYPE_NORMAL
- en: '**modes in a Java regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expression**'
  prefs: []
  type: TYPE_NORMAL
- en: All the aforementioned embedded modes can be placed at the start of a regular
    expression to enable one or more modes for the complete regular expression. We
    can also place these modes in the middle of a regex to enable it for a specific
    group or a remainder of the regex pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also **combine** multiple mode modifiers into a single expression like
    this: (?is)'
  prefs: []
  type: TYPE_NORMAL
- en: This enables the DOTALL and ignore case modes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disabling mode modifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: To disable a previously enabled mode, we can place a hyphen (-) before the modifier
    symbol anywhere in your regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable DOTALL, we can use the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: (?-s)
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable ignore case matching, we can use the following regex: (?-i)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the MULTILINE mode, we can use the following regex: (?-m)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable both ignore case and MULTILINE mode, we can use the following regex:
    (?-im)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the ignore case, DOTALL, and MULTILINE modes, we can use the following
    regex:'
  prefs: []
  type: TYPE_NORMAL
- en: (?-ism)
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the core constructs of regular expressions in depth.
    You learned anchors, quantifiers, boundary matchers, various character classes,
    negated character classes, and predefined character classes. We found out that
    escaped characters need to be escaped twice in the Java language. You also learned
    Unicode text matching using regular expressions in Java. We covered greedy, non-greedy,
    and possessive quantifiers. You learned embedded mode modifiers in Java regular
    expressions and how they can change the interpretation of a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover another very important feature of regular
    expressions, called grouping. You will learn the various types of grouping available
    in Java regular expressions and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Groups,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capturing, and References**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to match, capture, and reference substrings
    from a given input text using regular expressions. We will cover various types
    of groups available in Java, and the naming and numbering of captured groups.
    Readers will also learn how to use back reference or forward reference of the
    capturing groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter: Grouping'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing groups
  prefs: []
  type: TYPE_NORMAL
- en: Group numbering
  prefs: []
  type: TYPE_NORMAL
- en: Non-capturing groups
  prefs: []
  type: TYPE_NORMAL
- en: Back references
  prefs: []
  type: TYPE_NORMAL
- en: Named groups
  prefs: []
  type: TYPE_NORMAL
- en: Forward references
  prefs: []
  type: TYPE_NORMAL
- en: Invalid references
  prefs: []
  type: TYPE_NORMAL
- en: '**Capturing groups**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Groups are a very useful feature of regular expressions, which are supported
    in all the flavors of regular expressions. Groups are used to combine multiple
    characters or multiple smaller components of regular expressions into a single
    unit. We create groups by placing a series of characters or subpatterns inside
    round brackets or parentheses, ( and ). For example, consider the following regex
    pattern: (blue|red)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It means a capturing group that uses alternation. It either matches the letters
    b, l, u, and e or it matches the letters r, e, and d. In other words, it matches
    the strings blue or red, and more importantly, it creates a capturing group with
    either of the two matched strings. Each group becomes a single unit that can be
    used to apply certain constructs to the entire group. For example, anchors, boundary
    assertion, quantifiers, or alternation can be restricted to a part of the regular
    expression represented by the group. For example, look at the following regex
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: ^Regular(Expression)?$
  prefs: []
  type: TYPE_NORMAL
- en: This regular expression will match the string, Regular, at the start. After
    that, there is one capturing group with the string, Expression; however, due to
    the placement of the ?
  prefs: []
  type: TYPE_NORMAL
- en: quantifier after the group, it will match the 0 or 1 occurrence of the preceding
    group, making it an **optional capturing group**. Hence, this regex will either
    match the string, Regular, with an **empty** first capturing group or it will
    match the string RegularExpression, with the substring, Expression, in the first
    capturing group.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are given a problem to write a regular expression that matches only an
    even number of digits in the input, then we can use this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: ^([0-9]{2})+$
  prefs: []
  type: TYPE_NORMAL
- en: Since the + quantifier (one or more) is used next to the group that matches
    a pair of digits, this quantifier is applied to the entire group. Hence, this
    regular expression will match one or more pairs of digits (2, 4, 6, 8, 10, ...),
    or in simple words, it matches an even number of digits.
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression can have multiple capturing groups, which can be nested
    inside each other as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following regular expression, there are three capturing
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: ^((\d+)-([a-zA-Z]+))$
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding expression will match the input string, that is, 1234-aBc with
    the following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. Group 1: 1234-aBc'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Group 2: 1234'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Group 3: aBc'
  prefs: []
  type: TYPE_NORMAL
- en: '**Group numbering**'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing groups are numbered in increasing numbers, starting with number one.
    Java regular expressions support up to 99 capturing groups. Group zero always
    stands for the entire matched text.
  prefs: []
  type: TYPE_NORMAL
- en: For nested capturing groups, group numbers are incremented with the appearance
    of the opening parenthesis from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s consider the following regular expression
    with nested multiple capturing groups:'
  prefs: []
  type: TYPE_NORMAL
- en: (((a|b)-(c|d))/(\d+))
  prefs: []
  type: TYPE_NORMAL
- en: 'It will match the input string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: a-c/15
  prefs: []
  type: TYPE_NORMAL
- en: a-d/99
  prefs: []
  type: TYPE_NORMAL
- en: b-c/567
  prefs: []
  type: TYPE_NORMAL
- en: b-d/1000
  prefs: []
  type: TYPE_NORMAL
- en: 'For the input string, a-c/15, we will get the following captured groups: **Group
    Num**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Captured Text**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 0**'
  prefs: []
  type: TYPE_NORMAL
- en: a-c/15
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 1**'
  prefs: []
  type: TYPE_NORMAL
- en: a-c/15
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 2**'
  prefs: []
  type: TYPE_NORMAL
- en: a-c
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 3**'
  prefs: []
  type: TYPE_NORMAL
- en: a
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 4**'
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '15'
  prefs: []
  type: TYPE_NORMAL
- en: Also note that in the case of repeated matches in a capturing group using a
    quantifier, it will capture the last matched text in the given group.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: (\w+\s+){3}
  prefs: []
  type: TYPE_NORMAL
- en: If the input text is around the word, then the captured group number one will
    contain word after the regex execution, even though it also matches around and
    the before completing the match with the last word.
  prefs: []
  type: TYPE_NORMAL
- en: '**Named groups**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java regular expressions, capturing groups can be defined in two ways: 1\.
    Using numbers that get incremented automatically (as we discussed earlier).'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Using names.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Java 7, the regular expressions API offers support for named capturing
    groups. Named capturing groups are especially useful where there are lots of capturing
    groups. If we have to insert a new group or remove an existing group, then the
    numerical order changes for every capturing group that comes after the new or
    removed group, thus requiring the updating of all those references.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for defining a capturing group is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (?<name>RE)
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding line, RE is the pattern we are using for capturing a group.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain rules to specify a named group in Java: 1\. Names are case
    sensitive, so these are four different named capturing groups: (?<name>RE)'
  prefs: []
  type: TYPE_NORMAL
- en: (?<Name>RE)
  prefs: []
  type: TYPE_NORMAL
- en: (?<NAME>RE)
  prefs: []
  type: TYPE_NORMAL
- en: (?<naME>RE)
  prefs: []
  type: TYPE_NORMAL
- en: '2\. A name must satisfy the following regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[a-zA-Z][a-zA-Z0-9]*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the name must start with a letter and may contain letters or
    digits after the first position.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Names cannot be duplicate in Java regex.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that even when we use a name to define groups, the groups are still
    numbered as \1, \2, \3, and so on, and that these numbers can also be used in
    references.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following regular expression, we are specifying four named
    groups, id, subject, score, and term, all separated by a colon: (?<id>\d+):(?<subject>[a-zA-Z]+):(?<score>\d+):(?<term>[A-Z]+)
    If matched with 123456:Science:97:II, then the following groups will be captured:
    Group " **id**": "123456"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group " **subject**": "Science"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group " **score**": "97"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group " **term**": "II"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group **1**: "123456"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group **2**: "Science"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group **3**: "97"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Group **4**: "II"'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-capturing groups**'
  prefs: []
  type: TYPE_NORMAL
- en: There are cases while building regular expressions when we don't really want
    to capture any text but just want to group a subpattern to apply a boundary assertion
    or quantifier. This is the case for using non-capturing groups. We can mark a
    group as a non-capturing group by *adding a question mark and a colon* right after
    the opening parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can also place one or more mode modifiers between the question
    mark and the colon. The scope of the modifier used in this manner is only effective
    for that group.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use a non-capturing group in our regex to match an even
    number of digits:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?:\d{2})+$
  prefs: []
  type: TYPE_NORMAL
- en: Since we are not really interested in capturing any text from a matched string,
    it is a good choice to use a non-capturing group here.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a non-capturing group with the ignore case modifier is as follows:
    (?i:red|green|blue|white)'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the presence of the i modifier, this capturing group will match all the
    alternations by ignoring the case. Thus, it may match red, RED, White, blue, Green,
    BluE, greeN, WHITE, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are major differences between the following three regular expression
    patterns: (?:abc)'
  prefs: []
  type: TYPE_NORMAL
- en: (?mi:abc)
  prefs: []
  type: TYPE_NORMAL
- en: ((?:abc)?)
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, we define a non-capturing group with a pattern as abc.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we define a non-capturing group with the m ( *multiline*)
    and i ( *ignore case*) modifiers. This allows the regex to match abc, ABC, Abc,
    or aBC.
  prefs: []
  type: TYPE_NORMAL
- en: In the third case, we define an optional non-capturing group inside the capturing
    group that matches abc or an empty string in the captured group.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages of non-capturing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**groups**'
  prefs: []
  type: TYPE_NORMAL
- en: A non-capturing group lets us use the grouping inside a regular expression without
    changing the numbers assigned to the back references (explained in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: This can be very useful in building large and complex regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Non-capturing groups also give us the flexibility to add or remove groups from
    a long regular expression with multiple groups. If we have to insert a new group
    or remove an existing group, then the numerical order changes for every group
    on the right-hand side of the new or removed group.
  prefs: []
  type: TYPE_NORMAL
- en: Using a non-capturing group instead of a capturing group saves memory, as the
    regular expression engine doesn't need to store groups in buffers, thus optimizing
    the overall regex execution. It is recommended to mark each group as non-capturing
    when we do not want to extract a grouped substring or refer to them anywhere in
    the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Back references**'
  prefs: []
  type: TYPE_NORMAL
- en: Back references provide a convenient way of matching a repeated character or
    repeated tokens in the input text. By using back references, the regular expression
    engine can match the **exact same text** as previously matched by a capturing
    group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a back reference is a backslash followed by a capturing group
    number, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: \3
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is a back reference of the third capturing group.
  prefs: []
  type: TYPE_NORMAL
- en: In Java regular expressions, there can be up to 99 back references, each number
    referencing a captured group number.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we need to match a two-digit number with the restriction that
    both digits must be the same, then we need to capture the first digit and then
    use a back reference for the first captured group, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\d)\1$
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this regex will match any of these strings: 11, 22, 55, and 88\.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use quantifiers after back references as we use them with capturing
    or non-capturing groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have to match a five-digit number with all the same digits,
    then we can use the following regex:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\d)\1{4}$
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we want to create a regex that matches four pairs of digits,
    separated by the colon (:), dash (-), or slash (/) characters. We also require
    the digit pairs to be the same on the first and third positions, and likewise,
    they must also be the same on the second and fourth positions. For example, 12-45:12-45
    and 56/00:56-00 will be a matching string, but 57-13-58:13 will not, because 57
    in the first pair of digits is not the same as 58, which is the third pair of
    digits. We can write our regex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\d{2})[:/-](\d{2})[:/-]\1[:/-]\2$
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some more useful regular expressions using capturing groups
    and back references. Suppose we need to write a regular expression for two repeated
    words, separated by one or more non-word characters in between. We can write our
    regular expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\w+)\W+\1$
  prefs: []
  type: TYPE_NORMAL
- en: The back reference, \1, will make sure we match the exact same word as matched
    by the first capturing group in this regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to write a regular expression for quoted words. Words can be
    wrapped using single quotes or double quotes, but the mixing of quotes is not
    allowed. We can then write our regex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(['"])\w+\1$
  prefs: []
  type: TYPE_NORMAL
- en: Here, this regex pattern matches and captures the opening single or double quote
    using a character class. On the other side of the word, we use the \1 back reference
    to ensure that the same quote is matched in the end.
  prefs: []
  type: TYPE_NORMAL
- en: Back references cannot be used inside a character class, as we learned earlier.
    There is no grouping inside a character class, and most of the special meta characters
    become just literals inside a character class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Back reference of a named**'
  prefs: []
  type: TYPE_NORMAL
- en: '**group**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the back reference of a named group is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \k<group1>
  prefs: []
  type: TYPE_NORMAL
- en: Here, group1 is the name of the named capturing group.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can write our regular expression of repeating numbers, using
    a named group and named back reference, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?<matchedDigits>\d+)\s+\k<matchedDigits>$
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are defining a captured group called num to capture a number using
    the first, and then, we are using a back reference of the named group using \k<num>.
  prefs: []
  type: TYPE_NORMAL
- en: This will match inputs such as 1234 1234 or 989 989\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the named capturing groups are numbered automatically as well, we can
    write the same regular expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?<num>\d+)\s+\1$
  prefs: []
  type: TYPE_NORMAL
- en: '**Replacement reference of a**'
  prefs: []
  type: TYPE_NORMAL
- en: '**named group**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t yet discussed the Java API for regular expression replacement,
    but just for reference, it will be pertinent to discuss the syntax of a named
    group reference in a replacement string:'
  prefs: []
  type: TYPE_NORMAL
- en: '${group1}: This will be replaced in the resulting string by the matched content
    of the named captured group, group1'
  prefs: []
  type: TYPE_NORMAL
- en: '$1: This will be replaced in the resulting string by the matched content of
    the captured group number 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the double escaping of String while defining a Java regular expression
    should be applied here in defining named groups, named back references, and numbered
    back references. Thus, repeating the previous regular expressions used in Java
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'final String regex = "^(?<num>\\d+)\\s+\\k<num>$"; or using numbered back references:'
  prefs: []
  type: TYPE_NORMAL
- en: final String regex = "^(\\d+)\\s+\\1$";
  prefs: []
  type: TYPE_NORMAL
- en: '**Forward references**'
  prefs: []
  type: TYPE_NORMAL
- en: Back reference is the term used when a capturing group is referenced after we
    capture it. Likewise, a forward reference is the term for referencing a group
    before capturing the text using a captured group. In other words, the forward
    reference refers to a capturing group that appears later in the regular expression
    pattern. Forward references are only useful if we use them inside a repeated group,
    since the regex engine will be able to resolve captured groups and populate the
    forward reference while repeating a match using quantifiers.
  prefs: []
  type: TYPE_NORMAL
- en: As with most modern languages, Java allows us to use the forward reference of
    the captured group. Forward reference is a fairly complex concept to understand
    in regex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example regex to understand better:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(\d+)-(?:\2[\dA-Fa-f]{4}|(\d*\.?\d+:))+$
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, in this pattern, you can see that we are using the group reference, \2,
    before defining the captured group number, 2, which comes later in the regex pattern
    as: (\d*\.?\d+:). For this reason, \2 is a forward reference instead of a backward
    reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding regex, the following string matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '666-6.6:6.6:abcd3.3:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The string matches because in the first repetition of the non-captured group,
    the second captured group becomes 6.6: and this can be referenced later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following string also matches because the second captured group is overwritten
    each time it is matched:'
  prefs: []
  type: TYPE_NORMAL
- en: 666-3.3:5.5:5.5:abcd
  prefs: []
  type: TYPE_NORMAL
- en: 'The first value that the second captured group captures is 3.3:, but it is
    overwritten by 5.5: later, and this is matched the third time when the first part
    of the alternatives matches in the non-capturing group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following string, however, does not match, although the first capture of
    the second group will be the string, 3.3:, by the time it is required by the forward
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '666-3.3:abcd3.3:'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, as it is undefined, it does not match anything, not even the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the first part of the alternative group does not match, and at this
    point, the second half also does not match, thereby leading to a failed matching.
    This way, the captured group, in this case, never captures the string, 3.3:.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this behavior, the forward reference does reference something that
    is defined in the regular expression later, but only when the expression has already
    been matched at least once.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, there is no point in using a forward reference outside some
    repeated
  prefs: []
  type: TYPE_NORMAL
- en: construct as a part of one member of an alternative matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in the following example, the regex pattern uses a forward reference:'
  prefs: []
  type: TYPE_NORMAL
- en: ^(?:\1#color|(red|blue|white))+$
  prefs: []
  type: TYPE_NORMAL
- en: This anchored regex uses the **forward reference**, \1, before matching the
    literal text,
  prefs: []
  type: TYPE_NORMAL
- en: '#color, on the left-hand side of the alternation. On the right-hand side of
    the alternation, it matches one of the given colors and captures it in the first
    capturing group. The entire alternation has the + quantifier after to make repeated
    matches.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first attempt, \1 fails the match and forces the regex engine to attempt
    the right-hand side of the alternation and match a color to populate \1 with the
    matching color.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is any text left to be matched in the input, the regex engine, in
    the second attempt, matches the now populated reference, \1, followed by #color
    as the first alternation or an allowed color as the second alternation. This process
    is repeated until the regex engine either matches the complete string or fails
    the match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will match any of the following strings:'
  prefs: []
  type: TYPE_NORMAL
- en: blue
  prefs: []
  type: TYPE_NORMAL
- en: redblue
  prefs: []
  type: TYPE_NORMAL
- en: blueblueblue
  prefs: []
  type: TYPE_NORMAL
- en: redbluewhite
  prefs: []
  type: TYPE_NORMAL
- en: redred#color
  prefs: []
  type: TYPE_NORMAL
- en: whitewhite#color
  prefs: []
  type: TYPE_NORMAL
- en: blueredred#color
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it won''t match the following strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '#color'
  prefs: []
  type: TYPE_NORMAL
- en: red#color
  prefs: []
  type: TYPE_NORMAL
- en: bluered#color
  prefs: []
  type: TYPE_NORMAL
- en: redbluefruit
  prefs: []
  type: TYPE_NORMAL
- en: redbluered#color
  prefs: []
  type: TYPE_NORMAL
- en: '**Invalid (non-existing)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**backward or forward**'
  prefs: []
  type: TYPE_NORMAL
- en: '**references**'
  prefs: []
  type: TYPE_NORMAL
- en: The Java regular expression engine handles back references to non-existing groups
    in the same manner as back references to existing groups. Invalid or non-existing
    back references do not participate in the match. This means that a regular expression
    with an invalid back reference always fails, although it does not cause any exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following regex example:'
  prefs: []
  type: TYPE_NORMAL
- en: (apple|orange|banana)\2
  prefs: []
  type: TYPE_NORMAL
- en: The \2 back reference will be invalid because there is only one capturing group
    in this regular expression. Hence, the back reference of \2 always makes it a
    failed match against any input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same happens even when we have a regex pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \1
  prefs: []
  type: TYPE_NORMAL
- en: Due to a similar rule, it will fail to match an empty string as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to capture and reference substrings from an
    input text using regular expressions. Using non-capturing groups, we discussed
    how to optimize our regex patterns. We discussed the various types of groups available
    in Java regular expressions, the numbering of captured groups, and named groups.
    You also learned how to use back reference and forward reference of the capturing
    groups using numbered and named references. In the next chapter, you will get
    to writing code in Java to evaluate regular expressions. You will also be introduced
    to Java regular expressions using the Java String API, and then, we will move
    on to regex capabilities in the Java Scanner API.
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular Expression**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Using Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '**String and Scanner APIs**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to Java regular expressions using Java
    String methods and we will move on to regular expression capabilities in Java
    Scanner API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java String methods that use regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: What these methods are used for and how to use them
  prefs: []
  type: TYPE_NORMAL
- en: The use of regular expressions in Java Scanner
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered many theoretical concepts of writing regular expressions
    in depth. The time has now come to see some of these regular expressions in action.
    We are going to introduce you to Java programs evaluating these regular expressions
    using the java.lang.String and java.util.Scanner APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to the Java**'
  prefs: []
  type: TYPE_NORMAL
- en: '**String API for regular**'
  prefs: []
  type: TYPE_NORMAL
- en: '**expressions'' evaluation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java String API provides some useful methods to evaluate regular expressions
    against a text represented by the String object. Let''s list those methods from
    the String class:'
  prefs: []
  type: TYPE_NORMAL
- en: Method Signature
  prefs: []
  type: TYPE_NORMAL
- en: Purpose
  prefs: []
  type: TYPE_NORMAL
- en: boolean
  prefs: []
  type: TYPE_NORMAL
- en: Matches the given regular expression against the string that matches(String
  prefs: []
  type: TYPE_NORMAL
- en: the method is invoked on and returns true/false, indicating regex)
  prefs: []
  type: TYPE_NORMAL
- en: whether the match is successful (true) or not (false).
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: Replaces each substring of the subject string that matches the replaceAll(String
  prefs: []
  type: TYPE_NORMAL
- en: given regular expression with the replacement string and
  prefs: []
  type: TYPE_NORMAL
- en: regex, String
  prefs: []
  type: TYPE_NORMAL
- en: returns the new string with the replaced content.
  prefs: []
  type: TYPE_NORMAL
- en: replacement)
  prefs: []
  type: TYPE_NORMAL
- en: This method does the same as the previous one with the
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: exception that it replaces only the first substring of the replaceFirst(String
  prefs: []
  type: TYPE_NORMAL
- en: subject string that matches the given regular expression with regex, String
  prefs: []
  type: TYPE_NORMAL
- en: the replacement string and returns the new string with the replacement)
  prefs: []
  type: TYPE_NORMAL
- en: replaced content.
  prefs: []
  type: TYPE_NORMAL
- en: String[]
  prefs: []
  type: TYPE_NORMAL
- en: Splits the subject string using the given regular expression split(String regex)
  prefs: []
  type: TYPE_NORMAL
- en: into an array of substrings (example given ahead).
  prefs: []
  type: TYPE_NORMAL
- en: This overloaded method does the same as the previous one
  prefs: []
  type: TYPE_NORMAL
- en: String[]
  prefs: []
  type: TYPE_NORMAL
- en: split(String regex,
  prefs: []
  type: TYPE_NORMAL
- en: but there is an additional second parameter. The limit
  prefs: []
  type: TYPE_NORMAL
- en: int limit)
  prefs: []
  type: TYPE_NORMAL
- en: parameter controls the number of times regular expressions are applied for splitting.
  prefs: []
  type: TYPE_NORMAL
- en: '[For the complete reference of the String class, refer to https://docs.oracle.com/javase/8/docs/](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[api/java/lang/String.html.](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method - boolean**'
  prefs: []
  type: TYPE_NORMAL
- en: '**matches(String regex)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method attempts to match a given regular expression against the complete
    subject String and returns **true**/**false**, indicating whether the match is
    successful or not. The following are a few important points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression is applied against the entire String; there is no partial
    matching
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression does not need to be anchored using ^ and $, since it is matched
    against the entire input
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent of Pattern.matches(**String regex**, CharSequence**input**) method
    (will be covered later)
  prefs: []
  type: TYPE_NORMAL
- en: '**Example of the matches**'
  prefs: []
  type: TYPE_NORMAL
- en: '**method**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few examples to understand this method better.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet using the matches method will return false:'
  prefs: []
  type: TYPE_NORMAL
- en: '"1234".matches("\\d");'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is because the matches method attempts to apply a given regex against the
    entire input and effectively runs this code as:'
  prefs: []
  type: TYPE_NORMAL
- en: '"1234".matches("^\\d$");'
  prefs: []
  type: TYPE_NORMAL
- en: This will obviously fail as we have three digits in the input, not just one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that matches the string "1234" and the call to the matches()method
    that returns true will use the quantifier + or * after \\d. Therefore, the following
    two method calls will return true:'
  prefs: []
  type: TYPE_NORMAL
- en: '"1234".matches("\\d+");'
  prefs: []
  type: TYPE_NORMAL
- en: '"1234".matches("\\d+");'
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate a given string that contains the colors **red**, **blue,** or **green**,
    we shall use this code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: public class StringMatches
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: boolean result;
  prefs: []
  type: TYPE_NORMAL
- en: String regex;
  prefs: []
  type: TYPE_NORMAL
- en: String input = "Sky is blue"; // First regex regex = "\\b(red|blue|green)\\b";
  prefs: []
  type: TYPE_NORMAL
- en: result = input.matches(regex);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("Match result: %s%n", result);'
  prefs: []
  type: TYPE_NORMAL
- en: // prints false
  prefs: []
  type: TYPE_NORMAL
- en: // Second regex
  prefs: []
  type: TYPE_NORMAL
- en: regex = ".*\\b(red|blue|green)\\b.*";
  prefs: []
  type: TYPE_NORMAL
- en: result = input.matches(regex);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("Match result: %s%n", result);'
  prefs: []
  type: TYPE_NORMAL
- en: // prints true
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few points about this regex are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Alternation (**red**|**blue**|**green**) is being used to match any of the allowed
    colors The first regex fails to match because we are only matching the allowed
    colors using alternation but are not matching the text on either side of the alternation
    The second regex succeeds as we are using . ***** on both sides of the alternation
    to match any text before and after the allowed colors in the input text We are
    also using the word, **boundary assertions**, around our alternation expression
    to ensure that we match complete words only
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the given input starts and ends with an English letter while
    allowing digits, letters, underscores, and hyphens in the middle, we can use the
    following regular expression in the matches() method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'input.matches("[a-zA-Z][a-zA-Z0-9_-]*[a-zA-Z]"); Else, we can also use the
    predefined class, \w:'
  prefs: []
  type: TYPE_NORMAL
- en: input.matches("[a-zA-Z][\w-]*[a-zA-Z]");
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we can use the modifier, (?i):'
  prefs: []
  type: TYPE_NORMAL
- en: input.matches("(?i)[a-z][\w-]*[a-z]");
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the input contains six to nine digits, use the following: input.matches("\\d{6,9}");'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 13](img/index-96_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Method - String**'
  prefs: []
  type: TYPE_NORMAL
- en: '**replaceAll(String regex,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**String replacement)**'
  prefs: []
  type: TYPE_NORMAL
- en: This method replaces each substring of the subject string that matches the given
    regular expression with the replacement String. As the name implies, replaceAll
    replaces all the matching occurrences of the input String. Note that we can also
    supply a simple String containing no regex meta character in the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling this method is equivalent to a call to the following: Pattern.compile(regex).matcher(input).replaceAll(replacement);'
  prefs: []
  type: TYPE_NORMAL
- en: '***Note**: We will cover Pattern and Matcher APIs in [Chapter 5](index_split_001.html#p111)*
    *,* *Introduction to Java Regular Expression APIs - Pattern and Matcher* *Classes.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The replacement string allows the use of references to substrings, represented
    by the captured groups used in the regular expression. These references can be
    of two types: **Numbered references**: These are written as $n, where n is a number,
    such as $1, $2, and $3, which represent a reference to each of the captured groups
    in the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**Named references**: These are written as ${groupName}, where groupName is
    the name of the captured group in the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: To place a literal dollar or literal backslash in the replacement string, we
    need to escape these characters using double backslash (\\).
  prefs: []
  type: TYPE_NORMAL
- en: Here, at this point, you should understand the difference between back-reference
    and replacement reference. Back-reference is used in the regular expression pattern
    itself and is written as **\1,\2,\3**, and so on for a numbered group's back-reference
    and
  prefs: []
  type: TYPE_NORMAL
- en: '**\k<groupName>** for a named group''s back-reference. However, replacement
    reference is either written as **$1, $2, $3**, for a numbered group''s reference
    or **${groupName}** for a named group''s reference.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples of the replaceAll**'
  prefs: []
  type: TYPE_NORMAL
- en: '**method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace all the semi-colons with hyphens, we can use the following: input
    = input.replaceAll(";", "-");'
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove all the non-digits from the input, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: input = input.replace("\\D+", "");
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace all the leading and trailing commas from an input, we can use an
    alternation regex:'
  prefs: []
  type: TYPE_NORMAL
- en: 'input = input.replaceAll("^,+|,+$", ""); To replace all the occurrences of
    two or more white spaces with a single space, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: input = input.replaceAll("\\s{2,}, " ");
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we escape all the dollar signs that are just before the % character?
    In other words, to replace all the occurrences of $% with \$%, we can use: input
    = input.replaceAll("\\$%", "\\\\\\$%"); Note that we are using \\\\ (four backslashes)
    to enter a single \, and we''re using \\$'
  prefs: []
  type: TYPE_NORMAL
- en: to enter a single $ in the replacement, whereas % will just be a literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: $200 $%apple% $%banana% $%orange%
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be converted into this:'
  prefs: []
  type: TYPE_NORMAL
- en: $200 \$%apple% \$%banana} \${orange}
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also leverage the group reference $0 here, which is populated with the
    entire matched text using a regex. So, our code can be simplified to this as $0
    will refer to the matched text $% by our regex:'
  prefs: []
  type: TYPE_NORMAL
- en: 'input = input.replaceAll("\\$%", "\\\\$0"); Another nice trick we can use here
    is to use the static method, Matcher.quoteReplacement that is in the Matcher API.
    This method handles all the special characters in a replacement string and escapes
    them appropriately. Now, our code can become this: input = input.replaceAll("\\$%",
    Matcher.quoteReplacement("\\") + "$0"); Let''s solve an interesting problem. We
    need to replace all the multiple occurrences of non-word characters with a single
    instance of the same character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following input text:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''''''''''''s learn::: how to write cool regex...'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn: how to write cool regex.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are replacing multiple occurrences of non-word characters only
    and not replacing multiple occurrences of word characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code listing to solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: public class StringReplaceAll
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // our input string
  prefs: []
  type: TYPE_NORMAL
- en: 'String input = "Let''''''''''''s learn::: how to write cool regex...";'
  prefs: []
  type: TYPE_NORMAL
- en: // call replaceAll and assign replaced string to same variable input = input.replaceAll("(\\W)\\1+",
    "$1");
  prefs: []
  type: TYPE_NORMAL
- en: // print the result
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.printf("Replaced result: %s%n", input);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few points about this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: We are using the predefined class, \W, to match a non-word character We are
    using a capturing group around the non-word character to be able to use a back-reference
    later in the regex and in the replacement The pattern, (\\W)\\1+, is used to match
    two or more occurrences of the same non-word character
  prefs: []
  type: TYPE_NORMAL
- en: \1 represents the back-reference to the first captured group In the replacement,
    we are using the reference, $1, to place the captured non-word character back
    in the replaced string
  prefs: []
  type: TYPE_NORMAL
- en: $1 represents the reference to the first captured group
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the named group directives that you learnt in the previous chapter, we
    can also write the replaceAll method call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: input = input.replaceAll("(?<nwchar>\\W)\\k<nwchar>+", "${nwchar}");
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 14](img/index-99_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Method - String**'
  prefs: []
  type: TYPE_NORMAL
- en: '**replaceFirst(String regex,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**String replacement)**'
  prefs: []
  type: TYPE_NORMAL
- en: This method replaces the first substring of the subject string, which matches
    the given regular expression with the replacement String. As the name implies,
    replaceFirst replaces only the first matching occurrence of the input String.
    Note that we can also supply a simple String containing no regex meta character
    in the first argument as regex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling this method is equivalent to the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pattern.compile(regex).matcher(input).replaceFirst(replacement); *Note: We
    will cover the Pattern and Matcher APIs in later chapters.*'
  prefs: []
  type: TYPE_NORMAL
- en: A replacement string allows the use of group references, such as $1, $2, $3,
    and so on, for numbered references or ${groupName} for named references, which
    represent each of the captured groups in the regular expressions. To place a literal
    dollar or a literal backslash in the replacement, we need to escape these characters
    using the double backslash.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples of the replaceFirst**'
  prefs: []
  type: TYPE_NORMAL
- en: '**method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace *only the first* semi-colon with a hyphen, we can use the following:
    input = input.replaceFirst(";", "-"); What will be the output if we have to use
    the replaceFirst method instead of replaceAll in the input text of "$%apple% $%banana%
    $%orange%" for escaping the dollar signs?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will become as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'input = input.replaceFirst("\\$", "\\\\\\$"); It will replace only the first
    $ sign; hence, the output will only have the first $ escaped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \$%apple% $%banana% $%orange%
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the first dot of an IPV4 IP address with a colon, we can use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: String newip = ipaddress.replaceFirst("\\.", ":"); Only the first dot will be
    replaced by a colon; hence, an IP value of 10.11.22.123 will become 10:11.22.123\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods - String split**'
  prefs: []
  type: TYPE_NORMAL
- en: '**methods**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The String class has two split methods with the following signatures: String[]
    split(String regex, int limit)'
  prefs: []
  type: TYPE_NORMAL
- en: String[] split(String regex)
  prefs: []
  type: TYPE_NORMAL
- en: These split methods split the subject string into an array around the matches
    of the given regular expression, also called delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: When there is a *positive width* match at the beginning of an input string,
    then an empty string is included at the beginning of the resulting array. However,
    a match of *zero width* by regular expression does not include any empty string
    at the beginning of the resulting array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The array returned by this method contains a combination of the following elements:
    Token substrings that are split by the delimiter, matched using the given regular
    expression'
  prefs: []
  type: TYPE_NORMAL
- en: Input substring beyond the last match of the delimiter, using the given regular
    expression
  prefs: []
  type: TYPE_NORMAL
- en: A leading empty string when there is a *positive width* delimiter Trailing empty
    strings (see the next subsection on the limit parameter) When splitting regular
    a expression does not match any part of the input, the resulting array will just
    have a single element, that is, the complete input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'split(String regex) is just an overloaded method with the same functionality
    that calls the two-argument split method with the limit parameter as zero, thus
    making a call as: split(regex, 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '**The limit parameter rules**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The limit parameter controls the number of times the regular expression pattern
    is applied for splitting the subject string. It affects the length of the resulting
    array with the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. If the limit is greater than 0, then the pattern will be applied at most
    one time, the resulting array's length will not be greater than the limit, and
    the array's last entry will contain all input substrings beyond the last matched
    delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. If the limit is negative, then the pattern will be applied as many times
    as possible, and the resulting array can have any length.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. If the limit is zero (as in the single parameter split method call), then
    the pattern will be applied as many times as possible, the array can have any
    length, and **trailing empty strings will be discarded**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Examples of the split method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code listing, which splits the subject string
    on each occurrence of a hyphen:'
  prefs: []
  type: TYPE_NORMAL
- en: package example.regex;
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.*;
  prefs: []
  type: TYPE_NORMAL
- en: class StringSplit
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main (String[] args)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: final String input = "green-red-blue-yellow";
  prefs: []
  type: TYPE_NORMAL
- en: Arrays.stream(input.split("-"))
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '"green"'
  prefs: []
  type: TYPE_NORMAL
- en: '"red"'
  prefs: []
  type: TYPE_NORMAL
- en: '"blue"'
  prefs: []
  type: TYPE_NORMAL
- en: '"yellow"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change our code to the following by splitting on each occurrence
    of the letter e:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays.stream(input.split("e"))
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '"gr"'
  prefs: []
  type: TYPE_NORMAL
- en: '""'
  prefs: []
  type: TYPE_NORMAL
- en: '"n-r"'
  prefs: []
  type: TYPE_NORMAL
- en: '"d-blu"'
  prefs: []
  type: TYPE_NORMAL
- en: '"-y"'
  prefs: []
  type: TYPE_NORMAL
- en: '"llow"'
  prefs: []
  type: TYPE_NORMAL
- en: We got one empty result because we split on each e and there are two e letters
    in green, thus giving us an empty string between the two e letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change our code to the following by splitting on one or more occurrences
    of e:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays.stream(input.split("e+"))
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '"gr"'
  prefs: []
  type: TYPE_NORMAL
- en: '"n-r"'
  prefs: []
  type: TYPE_NORMAL
- en: '"d-blu"'
  prefs: []
  type: TYPE_NORMAL
- en: '"-y"'
  prefs: []
  type: TYPE_NORMAL
- en: '"llow"'
  prefs: []
  type: TYPE_NORMAL
- en: We did not get any empty results now because we split on each e+ and the two
    e letters in green are matched in a single match.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example of the split method**'
  prefs: []
  type: TYPE_NORMAL
- en: '**using the limit parameter**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the impact of the limit parameter, let''s take a comma-separated
    input string with two trailing commas:'
  prefs: []
  type: TYPE_NORMAL
- en: fox,tiger,wolf,,
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the split method in two ways. We can call the split method with
    limit=0: String[] arr = input.split(",", 0);'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also call the single parameter split method call as: String[] arr =
    input.split(",");'
  prefs: []
  type: TYPE_NORMAL
- en: 'It splits the input string around a comma and the trailing empty strings are
    discarded, with the following values being returned by the split method:'
  prefs: []
  type: TYPE_NORMAL
- en: '"fox"'
  prefs: []
  type: TYPE_NORMAL
- en: '"tiger"'
  prefs: []
  type: TYPE_NORMAL
- en: '"wolf"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s call the split method with limit=1:'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr = input.split(",", 1);
  prefs: []
  type: TYPE_NORMAL
- en: 'It splits the input string around a comma and then gets a single element in
    the resulting array, that is, the input string itself. The following value is
    returned by the split method:'
  prefs: []
  type: TYPE_NORMAL
- en: '"fox,tiger,wolf,,"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call the split method with limit=2:'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr = input.split(",", 2);
  prefs: []
  type: TYPE_NORMAL
- en: 'It splits the input string around a comma and then gets exactly two elements
    in the resulting array. The following two values are returned by the split method:'
  prefs: []
  type: TYPE_NORMAL
- en: '"fox"'
  prefs: []
  type: TYPE_NORMAL
- en: '"tiger,wolf,,"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call the split method with limit=3:'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr = input.split(",", 3);
  prefs: []
  type: TYPE_NORMAL
- en: 'It splits the input string around a comma, and then we get exactly three elements
    in the resulting array. The following three values are returned by the split method:'
  prefs: []
  type: TYPE_NORMAL
- en: '"fox"'
  prefs: []
  type: TYPE_NORMAL
- en: '"tiger"'
  prefs: []
  type: TYPE_NORMAL
- en: '"wolf,,"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call the split method with a negative limit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String[] arr = input.split(",", -1); It splits the input string around a comma
    **as many times as possible, with the trailing** **empty strings included in the
    split array**, and we get these elements in the resulting array. The following
    values are returned by the split method. Note the two empty strings at the end
    of the split array:'
  prefs: []
  type: TYPE_NORMAL
- en: '"fox"'
  prefs: []
  type: TYPE_NORMAL
- en: '"tiger"'
  prefs: []
  type: TYPE_NORMAL
- en: '"wolf"'
  prefs: []
  type: TYPE_NORMAL
- en: '""'
  prefs: []
  type: TYPE_NORMAL
- en: '""'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 15](img/index-106_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Using regular expressions in**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Scanner API**'
  prefs: []
  type: TYPE_NORMAL
- en: A scanner is a utility class used for parsing the input text and breaking the
    input into tokens of various types, such as Boolean, int, float, double, long,
    and so on. It generates tokens of various types using regular expression-based
    delimiters. The default delimiter is a whitespace. Using the Scanner API, we can
    generate tokens of all the primitive types in addition to string tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The String, Pattern, and Matcher classes are able to parse the input and generate
    tokens of the String type only, but the Scanner class is very useful for checking
    and generating tokens of different types from the input source. The Scanner instance
    can be constructed using the File, InputStream, Path, Readable, ReadableByteChannel,
    and String arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '*Pattern and Matcher will be covered in detail in [Chapter 5](index_split_001.html#p111)*
    *, Introduction to* *Java Regular Expression APIs - Pattern and Matcher Classes.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many methods in the scanner that support regular expressions. Let''s
    list those methods down and understand them better:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method Signature**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Purpose**'
  prefs: []
  type: TYPE_NORMAL
- en: Scanner
  prefs: []
  type: TYPE_NORMAL
- en: Sets this scanner's delimiter regex pattern to a String
  prefs: []
  type: TYPE_NORMAL
- en: useDelimiter(String
  prefs: []
  type: TYPE_NORMAL
- en: regex argument.
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  prefs: []
  type: TYPE_NORMAL
- en: but gets a Pattern as an argument instead of a String.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can pass a regular expression
  prefs: []
  type: TYPE_NORMAL
- en: already compiled. If we are forced to use the version
  prefs: []
  type: TYPE_NORMAL
- en: Scanner
  prefs: []
  type: TYPE_NORMAL
- en: with the
  prefs: []
  type: TYPE_NORMAL
- en: useDelimiter(Pattern
  prefs: []
  type: TYPE_NORMAL
- en: String argument, the scanner would compile
  prefs: []
  type: TYPE_NORMAL
- en: the string to a
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  prefs: []
  type: TYPE_NORMAL
- en: Pattern object even if we have already
  prefs: []
  type: TYPE_NORMAL
- en: executed that compilation in other parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the Pattern and Matcher class in the
  prefs: []
  type: TYPE_NORMAL
- en: next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the pattern being used by this scanner to
  prefs: []
  type: TYPE_NORMAL
- en: Pattern delimiter()
  prefs: []
  type: TYPE_NORMAL
- en: match delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: MatchResult match()
  prefs: []
  type: TYPE_NORMAL
- en: Returns the match result of the latest scan operation
  prefs: []
  type: TYPE_NORMAL
- en: performed by this scanner.
  prefs: []
  type: TYPE_NORMAL
- en: boolean hasNext(String
  prefs: []
  type: TYPE_NORMAL
- en: Returns true if the next token matches the pattern
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  prefs: []
  type: TYPE_NORMAL
- en: constructed from the specified string.
  prefs: []
  type: TYPE_NORMAL
- en: boolean hasNext(Pattern
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  prefs: []
  type: TYPE_NORMAL
- en: but gets Pattern as an argument instead of String.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the next token if it matches the pattern
  prefs: []
  type: TYPE_NORMAL
- en: String next(String pattern)
  prefs: []
  type: TYPE_NORMAL
- en: constructed from the specified string.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  prefs: []
  type: TYPE_NORMAL
- en: next(Pattern pattern)
  prefs: []
  type: TYPE_NORMAL
- en: but gets Pattern as an argument instead of String.
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to find the next occurrence of a pattern
  prefs: []
  type: TYPE_NORMAL
- en: String findInLine(String
  prefs: []
  type: TYPE_NORMAL
- en: constructed from the specified string, ignoring
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  prefs: []
  type: TYPE_NORMAL
- en: delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: String findInLine(Pattern
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  prefs: []
  type: TYPE_NORMAL
- en: but gets Pattern as an argument instead of String.
  prefs: []
  type: TYPE_NORMAL
- en: Scanner skip(String
  prefs: []
  type: TYPE_NORMAL
- en: Skips the input that matches a pattern constructed
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  prefs: []
  type: TYPE_NORMAL
