- en: '![Image 1](img/index-1_1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![图像1](img/index-1_1.jpg)'
- en: '![Image 2](img/index-2_1.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图像2](img/index-2_1.jpg)'
- en: '**Java 9 Regular Expressions**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 9 正则表达式**'
- en: Zero-length assertions, back-references, quantifiers, and more Anubhava Srivastava
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 零长度断言、后向引用、量词等，安布哈瓦·斯里瓦斯塔瓦
- en: '**BIRMINGHAM - MUMBAI**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**伯明翰 - 孟买**'
- en: < html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: < html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
- en: '"http://www.w3.org/TR/REC-html40/loose.dtd">'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '"http://www.w3.org/TR/REC-html40/loose.dtd">'
- en: '**Java 9 Regular Expressions**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 9 正则表达式**'
- en: Copyright © 2017 Packt Publishing
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 © 2017 Packt Publishing
- en: All rights reserved. No part of this book may be reproduced, stored in a retrieval
    system, or transmitted in any form or by any means, without the prior written
    permission of the publisher, except in the case of brief quotations embedded in
    critical articles or reviews.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权利保留。未经出版者事先书面许可，本书的任何部分不得以任何形式或通过任何手段进行复制、存储在检索系统中或以任何方式传输，但简要引用包含在评论或评论文章中的情况除外。
- en: Every effort has been made in the preparation of this book to ensure the accuracy
    of the information presented. However, the information contained in this book
    is sold without warranty, either express or implied. Neither the author, nor Packt
    Publishing, and its dealers and distributors will be held liable for any damages
    caused or alleged to be caused directly or indirectly by this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备本书的过程中，已尽一切努力确保所提供信息的准确性。然而，本书中的信息销售时不附带任何明示或暗示的保证。作者、Packt Publishing及其经销商和分销商不对由此书直接或间接造成的任何损害承担责任。
- en: Packt Publishing has endeavored to provide trademark information about all of
    the companies and products mentioned in this book by the appropriate use of capitals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Packt Publishing已努力通过适当使用大写字母提供本书中提到的所有公司和产品的商标信息。
- en: However, Packt Publishing cannot guarantee the accuracy of this information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Packt Publishing无法保证此信息的准确性。
- en: 'First published: July 2017'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首次出版：2017年7月
- en: 'Production reference: 1210717'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 生产参考：1210717
- en: Published by Packt Publishing Ltd.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由Packt Publishing Ltd.出版
- en: Livery Place
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 利弗里广场
- en: 35 Livery Street
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 35利弗里街
- en: Birmingham
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 伯明翰
- en: B3 2PB, UK.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 英国B3 2PB。
- en: ISBN 978-1-78728-870-6
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ISBN 978-1-78728-870-6
- en: '[www.packtpub.com](http://www.packtpub.com)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.packtpub.com](http://www.packtpub.com)'
- en: '**Credits**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**致谢**'
- en: '**Author**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**作者**'
- en: '**Copy Editor**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制编辑**'
- en: Anubhava Srivastava
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安布哈瓦·斯里瓦斯塔瓦
- en: Muktikant Garimella
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 毛蒂坎特·加里梅拉
- en: '**Reviewer**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**审稿人**'
- en: '**Project Coordinator**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目协调员**'
- en: Peter Verhas
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 彼得·韦哈斯
- en: Ulhas Kambali
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 乌尔哈斯·坎巴利
- en: '**Commissioning Editor**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**委托编辑**'
- en: '**Proofreader**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**校对者**'
- en: Merint Thomas Mathew
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 梅林特·托马斯·马修
- en: Safis Editing
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Safis 编辑
- en: '**Acquisition Editor**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**采购编辑**'
- en: '**Indexer**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引者**'
- en: Nitin Dasan
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尼廷·达桑
- en: Francy Puthiry
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 弗兰西·普蒂里
- en: '**Content Development Editor**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容开发编辑**'
- en: '**Graphics**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形**'
- en: Vikas Tiwari
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 维卡斯·提瓦里
- en: Abhinash Sahu
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 阿比纳什·萨胡
- en: '**Technical Editor**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术编辑**'
- en: '**Production Coordinator**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产协调员**'
- en: Jijo Maliyekal
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 吉约·马里亚卡尔
- en: Melwyn Dsa
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 梅尔温·达萨
- en: '**About the Author**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于作者**'
- en: '**Anubhava Srivastava** has more than 22 years of professional experience in
    architecture, design, and software development. He specializes mainly in the J2EE'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**安布哈瓦·斯里瓦斯塔瓦**在架构、设计和软件开发方面拥有超过22年的专业经验。他主要专长于J2EE。'
- en: technology stack, web technologies, CICD, test-driven development, and AWS cloud-based
    development.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 技术堆栈、网络技术、CICD、测试驱动开发和基于AWS云的开发。
- en: He is an active contributor to the Stack Overflow community. He currently stands
    in the top 35 users in terms of reputations out of the 7.5 million Stack Overflow
    users.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 他积极为Stack Overflow社区做出贡献。他目前在750万Stack Overflow用户中，以声誉排名前35位。
- en: He is passionate about regular expressions and is always willing to sharpen
    his regex skills further. He has answered close to 10,000 regex questions on Stack
    Overflow.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 他对正则表达式充满热情，并总是愿意进一步提高自己的正则表达式技能。他在Stack Overflow上回答了近10,000个正则表达式问题。
- en: He has authored and released a test-driven framework, called GenericFixture,
    for
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 他编写并发布了一个名为GenericFixture的测试驱动框架。
- en: '[FitNesse as an open source software. He maintains a technical blog at http://anubhava.wo](http://anubhava.wordpress.com)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[FitNesse 作为开源软件。他在 http://anubhava.wo](http://anubhava.wordpress.com) 维护一个技术博客。'
- en: '[rdpress.com](http://anubhava.wordpress.com)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[rdpress.com](http://anubhava.wordpress.com)'
- en: Anubhava can be found on LinkedIn at [https://www.linkedin.com/in/anubhava/](https://www.linkedin.com/in/anubhava/)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安布哈瓦可在LinkedIn上找到 [https://www.linkedin.com/in/anubhava/](https://www.linkedin.com/in/anubhava/)
- en: You can follow him on Twitter at @anubhava.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Twitter上关注他 @anubhava。
- en: '*First, I would like to express my gratitude toward the whole editing and publishing*
    *team at Packt Publishing for offering me an opportunity to write this book. Their*
    *support and guidance throughout this process encouraged me to explore more and
    dig* *deep.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*首先，我想对 Packt 出版公司整个编辑和出版团队表示衷心的感谢，因为他们给我提供了撰写这本书的机会。在整个过程中，他们的支持和指导鼓励我探索更多，深入研究。*'
- en: '*This book would not have been possible without the support and encouragement
    of my* *wife and kids. I am really grateful to my family for trusting in my abilities
    and for* *understanding my long hours in front of the computer on weekends and
    holidays.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*这本书的完成离不开我妻子和孩子的支持和鼓励。我非常感激我的家人对我的能力充满信任，并理解我在周末和节假日长时间面对电脑。*'
- en: '*I want to acknowledge the immensely knowledgeable Stack Overflow contributors
    and* *open source community for teaching me advanced regex concepts.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*我想感谢 Stack Overflow 的知识渊博的贡献者和开源社区，他们教会了我高级正则表达式概念。*'
- en: '*Lastly, I want to say big thanks to my management team at AOL for allowing
    me to* *embark on this book writing journey in my off time.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后，我想对我的管理团队 AOL 表示衷心的感谢，因为他们允许我在业余时间开始这本书的写作之旅。*'
- en: '**About the Reviewer**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于审稿人**'
- en: '**Peter Verhas** is a senior software engineer and software architect with
    a background in electrical engineering and economics. He pursued his MSc from
    TU Budapest and MBA from PTE Hungary. He has also studied at TU Delft and TU Vienna.
    He created his first programs in 1979, and since then, he has been the author
    of several open source programs. He has worked in the telecommunication and finance
    industries in several positions and was the CIO of the Hungarian startup, index.hu,
    during its initial days.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**彼得·韦哈斯**是一位具有电气工程和经济背景的高级软件工程师和软件架构师。他在布达佩斯技术大学获得了硕士学位，在匈牙利佩奇技术经济大学获得了MBA学位。他还曾在代尔夫特技术大学和维也纳技术大学学习。他在1979年创建了第一个程序，从那时起，他一直是几个开源项目的作者。他在电信和金融行业担任过多个职位，并在
    index.hu 这个匈牙利初创公司的初期担任了首席信息官。'
- en: Peter works for EPAM Systems in Switzerland, participating in software development
    projects at various customer sites. He also supports talent acquisition by interviewing
    candidates and designs internal mentoring programs and training programs for developers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 彼得在瑞士为 EPAM Systems 工作，参与各种客户站点的软件开发项目。他还通过面试候选人支持人才招聘，并为开发者设计内部辅导计划和培训计划。
- en: Peter is the author of *Java 9 Programming by Example* and the co-author of
    *Mastering Java 9* by Packt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 彼得是《Java 9 编程实例》的作者，也是 Packt 出版的《精通 Java 9》的合著者。
- en: You can follow Peter on Twitter at @verhas, LinkedIn, and GitHub. You can also
    read his technical blog, Java Deep, at [http://javax0.wordpress.com](http://javax0.wordpress.com).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Twitter 上关注彼得 @verhas，LinkedIn 和 GitHub。您还可以阅读他的技术博客 Java Deep，网址为 [http://javax0.wordpress.com](http://javax0.wordpress.com)。
- en: '![Image 3](img/index-10_1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3](img/index-10_1.jpg)'
- en: '**www.PacktPub.com**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**www.PacktPub.com**'
- en: For support files and downloads related to your book, please visit [www.PacktPub.com.](http://www.PacktPub.com)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有关您书籍的支持文件和下载，请访问 [www.PacktPub.com.](http://www.PacktPub.com)
- en: Did you know that Packt offers eBook versions of every book published, with
    PDF
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道 Packt 为每本书提供电子书版本，包括 PDF
- en: and ePub files available? You can upgrade to the eBook version at
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否想知道是否提供 ePub 文件？您可以通过升级到电子书版本来获取。
- en: '[www.PacktPub.coma](http://www.PacktPub.com)nd as a print book customer, you
    are entitled to a discount on the eBook copy. Get in touch with us at service@packtpub.com
    for more details.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.PacktPub.coma](http://www.PacktPub.com)以及作为印刷版书籍的客户，您有权获得电子书副本的折扣。有关更多详情，请联系我们
    service@packtpub.com。'
- en: At [www.PacktPub.com](http://www.PacktPub.com), you can also read a collection
    of free technical articles, sign up for a range of free newsletters and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [www.PacktPub.com](http://www.PacktPub.com)，您还可以阅读一系列免费的技术文章，订阅各种免费通讯，并享受
    Packt 书籍和电子书的独家折扣和优惠。
- en: '[https://www.packtpub.com/mapt](https://www.packtpub.com/mapt)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/mapt](https://www.packtpub.com/mapt)'
- en: Get the most in-demand software skills with Mapt. Mapt gives you full access
    to all Packt books and video courses, as well as industry-leading tools to help
    you plan your personal development and advance your career.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mapt 获得最热门的软件技能。Mapt 为您提供对所有 Packt 书籍和视频课程的全面访问权限，以及领先的行业工具，帮助您规划个人发展并提升职业生涯。
- en: '**Why subscribe?**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么要订阅？**'
- en: Fully searchable across every book published by Packt
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 全文可搜索 Packt 出版的每一本书
- en: Copy and paste, print, and bookmark content
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 复制粘贴、打印和收藏内容
- en: On demand and accessible via a web browser
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按需通过网页浏览器访问
- en: '**Customer Feedback**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户反馈**'
- en: Thanks for purchasing this Packt book. At Packt, quality is at the heart of
    our editorial process. To help us improve, please leave us an honest review on
    this book's Amazon page at [https://www.amazon.com/dp/1787288706\.](https://www.amazon.com/dp/1787288706)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您购买Packt这本书。在Packt，质量是我们编辑过程的核心。为了帮助我们改进，请在亚马逊上这本书的页面[https://www.amazon.com/dp/1787288706](https://www.amazon.com/dp/1787288706)上留下一个诚实的评价。
- en: If you'd like to join our team of regular reviewers, you can e-mail us at customerreviews@packtpub.com.
    We award our regular reviewers with free eBooks and videos in exchange for their
    valuable feedback. Help us be relentless in improving our products!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想加入我们团队的常规审稿人，你可以通过customerreviews@packtpub.com给我们发邮件。我们以免费电子书和视频作为回报，以换取他们宝贵的反馈。帮助我们不懈地改进我们的产品！
- en: '**Table of Contents**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录**'
- en: '[Preface](#p16)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[前言](#p16)'
- en: '[What this book covers](#p17)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[本书涵盖的内容](#p17)'
- en: '[What you need for this book](#p18)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[您需要为此书准备什么](#p18)'
- en: '[Who this book is for](#p19)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[本书面向的对象](#p19)'
- en: '[Conventions](#p20)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[约定](#p20)'
- en: '[Reader feedback](#p21)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[读者反馈](#p21)'
- en: '[Customer support](#p22)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[客户支持](#p22)'
- en: '[Downloading the example code](#p23)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[下载示例代码](#p23)'
- en: '[Errata](#p24)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[勘误表](#p24)'
- en: '[Piracy](#p25)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[盗版](#p25)'
- en: '[Questions](#p26)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[问题](#p26)'
- en: 1\. [Getting Started with Regular Expressions](#p27)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. [正则表达式入门](#p27)
- en: '[Introduction to regular expressions](#p28)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式简介](#p28)'
- en: '[A bit of history of regular expressions](#p29)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式的一些历史](#p29)'
- en: '[Various flavors of regular expressions](#p30)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式的各种风味](#p30)'
- en: '[What type of problems need regular expressions to solve](#p31)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[需要正则表达式解决的问题类型](#p31)'
- en: '[The basic rules of regular expressions](#p32)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式的基本规则](#p32)'
- en: '[Constructs of the standard regular expression and meta characters](#p33)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[标准正则表达式和元字符的构造](#p33)'
- en: '[Some basic regular expression examples](#p36)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[一些基本的正则表达式示例](#p36)'
- en: '[Eager matching](#p38)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[贪婪匹配](#p38)'
- en: '[The effect of eager matching on regular expression alternation](#p39)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[贪婪匹配对正则表达式交替的影响](#p39)'
- en: '[Summary](#p41)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](#p41)'
- en: 2\. [Understanding the Core Constructs of Java Regular Expressions](#p42)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. [理解Java正则表达式的核心构造](#p42)
- en: '[Understanding the core constructs of regular expressions](#p43)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[理解正则表达式的核心构造](#p43)'
- en: '[Quantifiers](#p44)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[量词](#p44)'
- en: '[Basic quantifiers](#p45)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[基本量词](#p45)'
- en: '[Examples using quantifiers](#p46)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用量词的示例](#p46)'
- en: '[Greedy versus reluctant (lazy) matching using quantifiers](#p47)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用量词的贪婪匹配与懒惰匹配](#p47)'
- en: '[Possessive quantifiers](#p48)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[占有量词](#p48)'
- en: '[Boundary constructs](#p50)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[边界构造](#p50)'
- en: '[Examples using boundary constructs](#p51)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用边界构造的示例](#p51)'
- en: '[Character classes](#p52)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符类](#p52)'
- en: '[Examples of character classes](#p53)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符类示例](#p53)'
- en: '[Range inside a character class](#p54)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符类内的范围](#p54)'
- en: '[Examples of character range](#p55)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符范围的示例](#p55)'
- en: '[Escaping special regex metacharacters and escaping rules inside the character
    class](#p56)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[转义特殊正则表达式元字符和字符类内的转义规则](#p56)'
- en: '[es](#p56)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[es](#p56)'
- en: '[Escaping inside a character class](#p57)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符类内的转义](#p57)'
- en: '[Examples of escaping rules inside the character class](#p58)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符类内转义规则的示例](#p58)'
- en: '[Literally matching a string that may contain special regex metacharacters](#p59)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[字面匹配可能包含特殊正则表达式元字符的字符串](#p59)'
- en: '[Negated character classes](#p60)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[否定字符类](#p60)'
- en: '[Examples of negated character classes](#p61)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[否定字符类的示例](#p61)'
- en: '[Predefined shorthand character classes](#p62)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[预定义的简写字符类](#p62)'
- en: '[POSIX character classes](#p63)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[POSIX字符类](#p63)'
- en: '[Unicode support in Java regular expressions](#p64)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[Java正则表达式中的Unicode支持](#p64)'
- en: '[Commonly used Unicode character properties](#p65)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[常用的Unicode字符属性](#p65)'
- en: '[Negation of the preceding regex directives](#p66)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[否定前面的正则表达式指令](#p66)'
- en: '[Unicode scripts support](#p67)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[Unicode脚本支持](#p67)'
- en: '[Examples of matching Unicode text in regular expressions](#p69)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式中匹配Unicode文本的示例](#p69)'
- en: '[Double escaping in a Java String when defining regular expressions](#p70)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[在定义正则表达式时Java字符串中的双重转义](#p70)'
- en: '[Embedded regular expression mode modifiers](#p71)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[内嵌正则表达式模式修饰符](#p71)'
- en: '[The placement of embedded modes in a Java regular expression](#p73)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[Java正则表达式内嵌模式的放置](#p73)'
- en: '[Disabling mode modifiers](#p74)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[禁用模式修饰符](#p74)'
- en: '[Summary](#p75)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](#p75)'
- en: 3\. [Working with Groups, Capturing, and References](#p76)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. [使用组、捕获和引用](#p76)
- en: '[Capturing groups](#p77)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[捕获组](#p77)'
- en: '[Group numbering](#p78)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[组编号](#p78)'
- en: '[Named groups](#p80)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[命名组](#p80)'
- en: '[Non-capturing groups](#p81)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[非捕获组](#p81)'
- en: '[Advantages of non-capturing groups](#p82)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[非捕获组的优势](#p82)'
- en: '[Back references](#p83)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[向后引用](#p83)'
- en: '[Back reference of a named group](#p85)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[命名组的向后引用](#p85)'
- en: '[Replacement reference of a named group](#p86)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[命名组的替换引用](#p86)'
- en: '[Forward references](#p87)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[向前引用](#p87)'
- en: '[Invalid (non-existing) backward or forward references](#p89)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[无效（不存在）的向后或向前引用](#p89)'
- en: '[Summary](#p90)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](#p90)'
- en: 4\. [Regular Expression Programming Using Java String and Scanner APIs](#p91)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. [使用Java String和Scanner API进行正则表达式编程](#p91)
- en: '[Introduction to the Java String API for regular expressions'' evaluation](#p92)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[Java字符串API中正则表达式评估的介绍](#p92)'
- en: '[Method - boolean matches(String regex)](#p93)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[方法 - boolean matches(String regex)](#p93)'
- en: '[Example of the matches method](#p94)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[matches方法的示例](#p94)'
- en: '[Method - String replaceAll(String regex, String replacement)](#p96)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[方法 - String replaceAll(String regex, String replacement)](#p96)'
- en: '[Examples of the replaceAll method](#p97)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[replaceAll方法的示例](#p97)'
- en: '[Method - String replaceFirst(String regex, String replacement)](#p99)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[方法 - String replaceFirst(String regex, String replacement)](#p99)'
- en: '[Examples of the replaceFirst method](#p100)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[replaceFirst方法的示例](#p100)'
- en: '[Methods - String split methods](#p101)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[方法 - String split方法](#p101)'
- en: '[The limit parameter rules](#p102)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[限制参数规则](#p102)'
- en: '[Examples of the split method](#p103)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[split方法的示例](#p103)'
- en: '[Example of the split method using the limit parameter](#p104)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用限制参数的split方法示例](#p104)'
- en: '[Using regular expressions in Java Scanner API](#p106)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[在Java Scanner API中使用正则表达式](#p106)'
- en: '[Summary](index_split_001.html#p110)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_001.html#p110)'
- en: 5\. [Introduction to Java Regular Expression APIs - Pattern and Matcher Classes](index_split_001.html#p111)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. [Java正则表达式API简介 - Pattern和Matcher类](index_split_001.html#p111)
- en: '[The MatchResult interface](index_split_001.html#p112)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[MatchResult接口](index_split_001.html#p112)'
- en: '[The Pattern class](index_split_001.html#p114)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pattern类](index_split_001.html#p114)'
- en: '[Examples using the Pattern class](index_split_001.html#p116)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用Pattern类的示例](index_split_001.html#p116)'
- en: '[Filtering a list of tokens using the asPredicate() method](index_split_001.html#p119)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用asPredicate()方法过滤令牌列表](index_split_001.html#p119)'
- en: '[The Matcher class](index_split_001.html#p120)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[Matcher类](index_split_001.html#p120)'
- en: '[Examples using the Matcher class](index_split_001.html#p123)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用Matcher类的示例](index_split_001.html#p123)'
- en: '[Method Boolean lookingAt()](index_split_001.html#p124)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[方法 Boolean lookingAt()](index_split_001.html#p124)'
- en: '[The matches() method](index_split_001.html#p125)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[matches()方法](index_split_001.html#p125)'
- en: '[The find() and find(int start) methods](index_split_001.html#p126)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[find()和find(int start)方法](index_split_001.html#p126)'
- en: '[The appendReplacement(StringBuffer sb, String replacement) method](index_split_001.html#p128)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[appendReplacement(StringBuffer sb, String replacement)方法](index_split_001.html#p128)'
- en: '[The appendTail(StringBuffer sb) method](index_split_001.html#p129)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[appendTail(StringBuffer sb)方法](index_split_001.html#p129)'
- en: '[Example of the appendReplacement and appendTail methods](index_split_001.html#p130)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[appendReplacement和appendTail方法的示例](index_split_001.html#p130)'
- en: '[Summary](index_split_001.html#p132)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_001.html#p132)'
- en: 6\. [Exploring Zero-Width Assertions, Lookarounds, and Atomic Groups](index_split_001.html#p133)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. [探索零宽断言、向前查看和原子组](index_split_001.html#p133)
- en: '[Zero-width assertions](index_split_001.html#p134)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[零宽断言](index_split_001.html#p134)'
- en: '[Predefined zero-width assertions](index_split_001.html#p135)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[预定义的零宽断言](index_split_001.html#p135)'
- en: '[Regex defined zero-width assertions](index_split_001.html#p136)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式定义的零宽断言](index_split_001.html#p136)'
- en: '[\G boundary assertion](index_split_001.html#p137)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[\G边界断言](index_split_001.html#p137)'
- en: '[Atomic groups](index_split_001.html#p139)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[原子组](index_split_001.html#p139)'
- en: '[Lookahead assertions](index_split_001.html#p141)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[向前断言](index_split_001.html#p141)'
- en: '[Positive lookahead](index_split_001.html#p142)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[正向向前断言](index_split_001.html#p142)'
- en: '[Negative lookahead](index_split_001.html#p143)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[负向前断言](index_split_001.html#p143)'
- en: '[Lookbehind assertions](index_split_001.html#p144)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[向后断言](index_split_001.html#p144)'
- en: '[Positive lookbehind](index_split_001.html#p145)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[正向向后断言](index_split_001.html#p145)'
- en: '[Negative lookbehind](index_split_001.html#p146)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[负向后断言](index_split_001.html#p146)'
- en: '[Capturing text from overlapping matches](index_split_001.html#p151)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[从重叠匹配中捕获文本](index_split_001.html#p151)'
- en: '[Be careful with capturing groups inside a lookahead or lookbehind atomic group](index_split_001.html#p153)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[注意在向前或向后原子组内部使用捕获组](index_split_001.html#p153)'
- en: '[Lookbehind limitations in Java regular expressions](index_split_001.html#p154)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[Java正则表达式中的向后断言限制](index_split_001.html#p154)'
- en: '[Summary](index_split_001.html#p155)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[总结](index_split_001.html#p155)'
- en: 7\. [Understanding the Union, Intersection, and Subtraction of Character Classes](index_split_001.html#p156)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 7. [理解字符类的并集、交集和减法](index_split_001.html#p156)
- en: '[The union of character classes](index_split_001.html#p157)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符类并集](index_split_001.html#p157)'
- en: '[The intersection of character classes](index_split_001.html#p159)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符类交集](index_split_001.html#p159)'
- en: '[The subtraction of character classes](index_split_001.html#p162)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[字符类减法](index_split_001.html#p162)'
- en: '[Why should you use composite character classes?](index_split_001.html#p164)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[为什么你应该使用复合字符类？](index_split_001.html#p164)'
- en: '[Summary](index_split_001.html#p165)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[摘要](index_split_001.html#p165)'
- en: 8\. [Regular Expression Pitfalls, Optimization, and Performance Improvements](index_split_001.html#p166)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 8. [正则表达式陷阱、优化和性能改进](index_split_001.html#p166)
- en: '[Common pitfalls and ways to avoid them while writing regular expressions](index_split_001.html#p167)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[编写正则表达式时常见的陷阱和避免方法](index_split_001.html#p167)'
- en: '[Do not forget to escape regex metacharacters outside a character class](index_split_001.html#p168)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[不要忘记在字符类外转义正则表达式元字符](index_split_001.html#p168)'
- en: '[Avoid escaping every non-word character](index_split_001.html#p169)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[避免对每个非单词字符进行转义](index_split_001.html#p169)'
- en: '[Avoid unnecessary capturing groups to reduce memory consumption](index_split_001.html#p170)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[避免不必要的捕获组以减少内存消耗](index_split_001.html#p170)'
- en: '[However, don''t forget to use the required group around alternation](index_split_001.html#p171)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[然而，不要忘记在交替周围使用所需的组](index_split_001.html#p171)'
- en: '[Use predefined character classes instead of longer versions](index_split_001.html#p172)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用预定义的字符类而不是较长的版本](index_split_001.html#p172)'
- en: '[Use the limiting quantifier instead of repeating a character or pattern multiple
    times](index_split_001.html#p173)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用限制量词而不是重复字符或模式多次](index_split_001.html#p173)'
- en: '[Do not use an unescaped hyphen in the middle of a character class](index_split_001.html#p174)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[不要在字符类中间使用未转义的破折号](index_split_001.html#p174)'
- en: '[The mistake of calling matcher.goup() without a prior call to matcher.find(),
    match](index_split_001.html#p175)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[在调用 matcher.group() 之前没有先调用 matcher.find() 或 match 的错误](index_split_001.html#p175)'
- en: '[er.matches(), or matcher.lookingAt()](index_split_001.html#p175)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[er.matches() 或 matcher.lookingAt()](index_split_001.html#p175)'
- en: '[Do not use regular expressions to parse XML / HTML data](index_split_001.html#p177)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[不要使用正则表达式解析 XML / HTML 数据](index_split_001.html#p177)'
- en: '[How to test and benchmark your regular expression performance](index_split_001.html#p178)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何测试和基准测试你的正则表达式性能](index_split_001.html#p178)'
- en: '[Catastrophic or exponential backtracking](index_split_001.html#p179)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[灾难性或指数回溯](index_split_001.html#p179)'
- en: '[How to avoid catastrophic backtracking](index_split_001.html#p182)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何避免灾难性回溯](index_split_001.html#p182)'
- en: '[Optimization and performance enhancement tips](index_split_001.html#p185)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[优化和性能提升技巧](index_split_001.html#p185)'
- en: '[Use a compiled form of regular expressions](index_split_001.html#p186)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用正则表达式的编译形式](index_split_001.html#p186)'
- en: '[Use a negated character class instead of the greedy and slow .* or .+](index_split_001.html#p187)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用否定字符类代替贪婪且缓慢的 .* 或 .+](index_split_001.html#p187)'
- en: '[Avoid unnecessary grouping](index_split_001.html#p188)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[避免不必要的分组](index_split_001.html#p188)'
- en: '[Use lazy quantifiers strategically instead of greedy quantifiers that cause
    excessive](index_split_001.html#p189)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[有策略地使用懒惰量词而不是导致过度贪婪的量词](index_split_001.html#p189)'
- en: '[backtracking](index_split_001.html#p189)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[回溯](index_split_001.html#p189)'
- en: '[Make use of possessive quantifiers to avoid backtracking](index_split_001.html#p190)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[利用所有格量词避免回溯](index_split_001.html#p190)'
- en: '[Extract common repeating substrings out of alternation](index_split_001.html#p191)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[从交替中提取常见的重复子串](index_split_001.html#p191)'
- en: '[Use atomic group to avoid backtracking and fail fast](index_split_001.html#p192)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用原子组避免回溯并快速失败](index_split_001.html#p192)'
- en: '[Summary](index_split_001.html#p193)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[摘要](index_split_001.html#p193)'
- en: '**Preface**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**前言**'
- en: In today's information technology world, the size of data is growing by leaps
    and bounds. IT organizations are processing and storing huge amounts of textual
    data collected from various sources, such as user actions, leads, searches, shopping
    data, page views, page hits, and various other forms of user interactions. Search
    algorithms are used for parsing large texts to extract meaningful pertinent information.
    Regular expressions are the backbone of many such search algorithms.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的信息技术世界中，数据的大小正在飞速增长。IT组织正在处理和存储来自各种来源的大量文本数据，例如用户行为、线索、搜索、购物数据、页面浏览量、页面点击量以及各种其他用户交互形式。搜索算法用于解析大量文本以提取有意义的相关信息。正则表达式是许多此类搜索算法的基础。
- en: Regular expressions (or regex in short) are everywhere these days. All the modern
    programming languages are shipped with a regex module or library to allow programmers
    to write regex-based programs. Regular expressions are a powerful tool in the
    programmer's toolbox and allow pattern matching. They are also used for manipulating
    text and data. This book will provide you with the know-how (and practical examples)
    to solve real-world problems using regex in Java.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（或简称regex）如今无处不在。所有现代编程语言都附带了一个正则表达式模块或库，以便程序员可以编写基于正则表达式的程序。正则表达式是程序员工具箱中的强大工具，允许进行模式匹配。它们也用于操作文本和数据。本书将为您提供必要的知识（以及实际示例），以使用Java中的正则表达式解决现实世界的问题。
- en: This easy-to-follow regex book is a great place for you to familiarize yourself
    with the core concepts of regular expressions and to master their implementation
    with the new features of Java 9\. You will learn to match, extract, and transform
    text by matching specific words, characters, and patterns. Readers will learn
    how to write efficient regular expressions for solving day-to-day problems involving
    text-based data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这本易于理解的正则表达式书籍是您熟悉正则表达式核心概念并掌握其使用Java 9新特性的实现的好地方。您将学习如何通过匹配特定单词、字符和模式来匹配、提取和转换文本。读者将学习如何编写高效的正则表达式来解决涉及文本数据的日常问题。
- en: '**What this book covers**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**本书涵盖内容**'
- en: '[Chapter 1](#p27), *Getting Started with Regular Expressions*, teaches what
    regular expressions are, what problems are best solved using regular expressions,
    and the rules to follow while writing them.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](#p27)，*正则表达式入门*，介绍了正则表达式是什么，哪些问题最适合使用正则表达式解决，以及编写正则表达式时应遵循的规则。'
- en: '[Chapter 2](#p42), *Understanding the Core Constructs of Java Regular Expressions*,
    covers quantifiers, anchors, boundary matchers, and all the available character
    classes and properties in Java. We will also learn Unicode text matching using
    regex in Java.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](#p42)，*理解Java正则表达式的核心构造*，涵盖了量词、锚点、边界匹配器和Java中所有可用的字符类和属性。我们还将学习使用Java中的正则表达式进行Unicode文本匹配。'
- en: '[Chapter 3](#p76), *Working with Groups, Capturing, and References*, explores
    how to match and capture text in regex, the various types of groups available
    to us, the naming and numbering of a captured group, and how we should use back-reference
    for the captured groups.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](#p76)，*使用组、捕获和引用进行操作*，探讨了如何在正则表达式中匹配和捕获文本，我们可用的各种组类型，捕获组的命名和编号，以及我们应如何使用反向引用来引用捕获的组。'
- en: '[Chapter 4](#p91), *Regular Expression Programming Using Java String and Scanner
    APIs*, introduces Java regex using Java String methods, and we will move on to
    regex capabilities in the Java Scanner API.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](#p91)，*使用Java String和Scanner API进行正则表达式编程*，介绍了Java正则表达式使用Java String方法，然后我们将继续学习Java
    Scanner API中的正则表达式功能。'
- en: '[Chapter 5](index_split_001.html#p111), *Introduction to Java Regular Expression
    APIs - Pattern and Matcher* *Classes*, discusses the dedicated Java APIs, java.util.regex.Pattern
    and java.util.regex.Matcher, for complete regex capabilities.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](index_split_001.html#p111)，*Java正则表达式API简介 - Pattern和Matcher类*，讨论了用于完整正则表达式功能的专用Java
    API，即java.util.regex.Pattern和java.util.regex.Matcher。'
- en: '[Chapter 6](index_split_001.html#p133), *Exploring Zero-width Assertions, Lookarounds,
    and Atomic Groups*, focuses on zero-width assertions in regex. The chapter covers
    various zero-width assertions and their usages. We will then move on to learn
    the important topic of lookarounds in regex.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](index_split_001.html#p133)，*探索零宽断言、前瞻和原子组*，专注于正则表达式中的零宽断言。本章涵盖了各种零宽断言及其用法。然后我们将继续学习正则表达式中的前瞻这一重要主题。'
- en: '[Chapter 7](index_split_001.html#p156), *Understanding the Union, Intersection,
    and Subtraction of Character* *Classes*, says that the Java language has added
    the features of using the intersection and union of character classes in regex.
    This chapter covers these features.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](index_split_001.html#p156)，*理解字符类交集、并集和差集*，说明Java语言增加了在正则表达式中使用字符类交集和并集的功能。本章涵盖了这些功能。'
- en: '[Chapter 8](index_split_001.html#p166), *Regular Expression Pitfalls, Optimization,
    and Performance Improvements*, explains how to test and optimize a poorly performing
    regex and various other performance tips.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](index_split_001.html#p166)，*正则表达式陷阱、优化和性能改进*，解释了如何测试和优化性能不佳的正则表达式以及各种其他性能提示。'
- en: '**What you need for this book**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**本书所需内容**'
- en: The software in this book was tested on Java version 9 on Ubuntu version 16.10\.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的软件在Java 9版本和Ubuntu 16.10版本上进行了测试。
- en: However, all the examples can also be run on the Windows and macOS X operating
    systems.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有示例也可以在Windows和macOS X操作系统上运行。
- en: '**Who this book is for**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**本书面向对象**'
- en: This book is for Java developers who would like to understand and use regular
    expressions. If you are dealing with text processing problems, such as text validation,
    searching, and text manipulation, then learning regex is very important for you
    to make your job easier. This book does not expect readers to have any prior regex
    knowledge, since the book will cover every aspect of regex, starting from the
    absolute basics of regex. However, a basic knowledge of Java is assumed in order
    to be able to write and execute the example programs provided in the book.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是为希望理解和使用正则表达式的Java开发者所写。如果你正在处理文本处理问题，如文本验证、搜索和文本操作，那么学习正则表达式对你来说非常重要，因为它可以使你的工作更加容易。本书不期望读者有任何先前的正则表达式知识，因为本书将涵盖正则表达式的各个方面，从正则表达式的绝对基础开始。然而，为了能够编写和执行本书中提供的示例程序，假设读者具备Java的基本知识。
- en: '![Image 4](img/index-20_1.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image 4](img/index-20_1.jpg)'
- en: '![Image 5](img/index-20_2.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Image 5](img/index-20_2.jpg)'
- en: '**Conventions**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**约定**'
- en: In this book, you will find a number of text styles that distinguish between
    different kinds of information. Here are some examples of these styles and an
    explanation of their meaning.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你会发现许多不同的文本样式，用于区分不同类型的信息。以下是一些这些样式的示例及其含义的解释。
- en: 'Code words in text, database table names, folder names, filenames, file extensions,
    pathnames, dummy URLs, user input, and Twitter handles are shown as follows: "The
    next lines of code read the link and assign it to the to the BeautifulSoup function."'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟URL、用户输入和Twitter昵称如下所示："接下来的代码行读取链接并将其分配给BeautifulSoup函数。"。
- en: 'A block of code is set as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块设置如下：
- en: package example.regex;
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: public class StringMatches
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: public class StringMatches
- en: '{'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '}'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'When we wish to draw your attention to a particular part of a code block, the
    relevant lines or items are set in bold:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望将你的注意力引到代码块的一个特定部分时，相关的行或项目将以粗体显示：
- en: '[default]'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[默认]'
- en: exten => s,1,Dial(Zap/1|30)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: exten => s,1,Dial(Zap/1|30)
- en: '**exten => s,2,Voicemail(u100)**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**exten => s,2,Voicemail(u100)**'
- en: '**exten => s,102,Voicemail(b100)**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**exten => s,102,Voicemail(b100)**'
- en: exten => i,1,Voicemail(s0)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: exten => i,1,Voicemail(s0)
- en: 'Any command-line input or output is written as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 任何命令行输入或输出都如下所示：
- en: '**C:\Python34\Scripts> pip install -upgrade pip**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**C:\Python34\Scripts> pip install -upgrade pip**'
- en: '**C:\Python34\Scripts> pip install pandas**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**C:\Python34\Scripts> pip install pandas**'
- en: '**New terms** and **important words** are shown in bold. Words that you see
    on the screen, for example, in menus or dialog boxes, appear in the text like
    this: "In order to download new modules, we will go to Files | Settings | Project
    Name | Project Interpreter."'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**新术语**和**重要词汇**以粗体显示。屏幕上看到的单词，例如在菜单或对话框中，在文本中如下所示："为了下载新模块，我们将转到文件 | 设置 |
    项目名称 | 项目解释器。"'
- en: '*Warnings or important notes appear like this.*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告或重要提示如下所示。*'
- en: '*Tips and tricks appear like this.*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*技巧和窍门如下所示。*'
- en: '**Reader feedback**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**读者反馈**'
- en: Feedback from our readers is always welcome. Let us know what you think about
    this book-what you liked or disliked. Reader feedback is important for us as it
    helps us develop titles that you will really get the most out of.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们欢迎读者的反馈。告诉我们你对这本书的看法——你喜欢什么或不喜欢什么。读者反馈对我们来说很重要，因为它帮助我们开发出你真正能从中获得最大收益的标题。
- en: To send us general feedback, simply e-mail feedback@packtpub.com, and mention
    the book's title in the subject of your message. If there is a topic that you
    have expertise in and you are interested in either writing or contributing to
    a book, see our author guide at [www.packtpub.com/authors.](http://www.packtpub.com/authors)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们发送一般反馈，请简单地发送电子邮件至 feedback@packtpub.com，并在邮件主题中提及书籍标题。如果您在某个主题领域有专业知识，并且对撰写或为书籍做出贡献感兴趣，请参阅我们的作者指南
    [www.packtpub.com/authors](http://www.packtpub.com/authors)。
- en: '**Customer support**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户支持**'
- en: Now that you are the proud owner of a Packt book, we have a number of things
    to help you to get the most from your purchase.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您是Packt图书的骄傲拥有者，我们有一些事情可以帮助您从您的购买中获得最大收益。
- en: '**Downloading the example**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例**'
- en: '**code**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '[You can download the example code files for this book from your account at
    http://ww](http://www.packtpub.com)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 http://ww [下载本书的示例代码文件](http://www.packtpub.com)
- en: '[w.packtpub.com. If you purchased this book elsewhere, you can visit http://www.packtpub.c](http://www.packtpub.com)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[如果您在其他地方购买了本书，您可以访问 http://www.packtpub.c](http://www.packtpub.com)'
- en: '[om/support and register to have the files e-mailed directly to you.](http://www.packtpub.com/support)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过注册并支持，我们将直接将文件通过电子邮件发送给您](http://www.packtpub.com/support)'
- en: 'You can download the code files by following these steps: 1\. Log in or register
    to our website using your e-mail address and password.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤下载代码文件：1. 使用您的电子邮件地址和密码登录或注册我们的网站。
- en: 2\. Hover the mouse pointer on the SUPPORT tab at the top.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将鼠标指针悬停在顶部的“支持”标签上。
- en: 3\. Click on Code Downloads & Errata.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 点击“代码下载与勘误”。
- en: 4\. Enter the name of the book in the Search box.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 在搜索框中输入书籍名称。
- en: 5\. Select the book for which you're looking to download the code files.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 选择您想要下载代码文件的书籍。
- en: 6\. Choose from the drop-down menu where you purchased this book from.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 从下拉菜单中选择您购买本书的来源。
- en: 7\. Click on Code Download.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 点击“代码下载”。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 文件下载完成后，请确保使用最新版本的软件解压缩或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的WinRAR / 7-Zip
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Mac上的Zipeg / iZip / UnRarX
- en: 7-Zip / PeaZip for Linux
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上的7-Zip / PeaZip
- en: '[The code bundle for the book is also hosted on GitHub at https://github.com/PacktPublishin](https://github.com/PacktPublishing/Java-9-Regular-Expressions)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[本书的代码包也托管在GitHub上，网址为 https://github.com/PacktPublishing/Java-9-Regular-Expressions](https://github.com/PacktPublishing/Java-9-Regular-Expressions)'
- en: '[g/Java-9-Regular-Expressions. We also have other code bundles from our rich
    catalog of](https://github.com/PacktPublishing/Java-9-Regular-Expressions)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[我们还有来自我们丰富目录的其他代码包](https://github.com/PacktPublishing/Java-9-Regular-Expressions)'
- en: books and videos available at [https://github.com/PacktPublishing/.](https://github.com/PacktPublishing/)
    Check them out!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)
    上可找到本书的书籍和视频资源。查看它们！
- en: '**Errata**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**勘误表**'
- en: Although we have taken every care to ensure the accuracy of our content, mistakes
    do happen. If you find a mistake in one of our books-maybe a mistake in the text
    or the code-we would be grateful if you could report this to us. By doing so,
    you can save other readers from frustration and help us improve subsequent versions
    of this book. If you find any errata, please report them by visiting [http://www.packtpub.com/submit-errata,](http://www.packtpub.com/submit-errata)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在我们的书中发现错误——可能是文本或代码中的错误——如果您能向我们报告，我们将不胜感激。这样做可以帮助其他读者避免挫败感，并帮助我们改进本书的后续版本。如果您发现任何勘误，请通过访问
    [http://www.packtpub.com/submit-errata](http://www.packtpub.com/submit-errata)
    来报告它们。
- en: selecting your book, clicking on the Errata Submission Form link, and entering
    the details of your errata. Once your errata are verified, your submission will
    be accepted and the errata will be uploaded to our website or added to any list
    of existing errata under the Errata section of that title.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 选择您的书籍，点击勘误提交表单链接，并输入您的勘误详情。一旦您的勘误得到验证，您的提交将被接受，勘误将被上传到我们的网站或添加到该标题的勘误部分下的现有勘误列表中。
- en: '[To view the previously submitted errata, go to https://www.packtpub.com/books/content/supp](https://www.packtpub.com/books/content/support)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[要查看之前提交的勘误表，请访问 https://www.packtpub.com/books/content/supp](https://www.packtpub.com/books/content/support)'
- en: '[ort and enter the name of the book in the search field. The required information
    will](https://www.packtpub.com/books/content/support)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[在搜索字段中输入书籍名称，以获取所需信息](https://www.packtpub.com/books/content/support)'
- en: appear under the Errata section.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在勘误表部分。
- en: '**Piracy**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**盗版**'
- en: Piracy of copyrighted material on the Internet is an ongoing problem across
    all media.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上对版权材料的盗版是一个跨所有媒体的持续问题。
- en: At Packt, we take the protection of our copyright and licenses very seriously.
    If you come across any illegal copies of our works in any form on the Internet,
    please provide us with the location address or website name immediately so that
    we can pursue a remedy.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Packt，我们非常重视我们版权和许可证的保护。如果您在互联网上以任何形式遇到我们作品的非法副本，请立即提供位置地址或网站名称，以便我们可以寻求补救措施。
- en: Please contact us at copyright@packtpub.com with a link to the suspected pirated
    material.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 请通过 copyright@packtpub.com 联系我们，并提供涉嫌盗版材料的链接。
- en: We appreciate your help in protecting our authors and our ability to bring you
    valuable content.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感谢您的帮助，保护我们的作者和为您提供有价值内容的能力。
- en: '**Questions**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: If you have a problem with any aspect of this book, you can contact us at questions@packtpub.com,
    and we will do our best to address the problem.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在这本书的任何方面遇到问题，您可以联系我们在 questions@packtpub.com，我们将尽力解决问题。
- en: '**Getting Started with Regular**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式入门**'
- en: '**Expressions**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: In this chapter, you will be introduced to regular expressions (or regex in
    short). You will learn about some real-world problems that can be solved by using
    regular expressions and the basic building blocks of regular expressions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解正则表达式（或简称regex）。您将了解一些可以使用正则表达式解决的问题以及正则表达式的基本构建块。
- en: 'We will be covering the following topics in this chapter: Introduction to regular
    expressions'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：正则表达式简介
- en: A brief history of regular expressions
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式简史
- en: The various flavors of regular expressions
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的各种版本
- en: What type of problems need regular expressions to solve
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 需要正则表达式解决的问题类型
- en: The basic rules of writing regular expressions
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 编写正则表达式的基本规则
- en: Standard regular expression meta characters
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 标准正则表达式元字符
- en: Basic regular expression examples
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 基本正则表达式示例
- en: '**Introduction to regular**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式简介**'
- en: '**expressions**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: Regular expression (or in short regex) is a very useful tool that is used to
    describe a search pattern for matching the text. Regex is nothing but a sequence
    of some characters that defines a search pattern. Regex is used for parsing, filtering,
    validating, and extracting meaningful information from large text, such as logs
    and output generated from other programs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（简称regex）是一个非常有用的工具，用于描述用于匹配文本的搜索模式。正则表达式不过是定义搜索模式的一些字符序列。正则表达式用于解析、过滤、验证和从大量文本（如日志和其他程序生成的输出）中提取有意义的信息。
- en: We find regular expressions in day-to-day use on many websites. For example,
    while searching for your favorite recipe on search engines, while filling up forms
    and entering data such as username and passwords, and so on. While setting up
    a password on many sites, we encounter password validation errors, such as password
    must contain one digit or at least one uppercase letter or at least one special
    character, and so on. All these checks can be done using regular expressions.
    A few more typical examples of regular expressions are validating phone numbers
    or validating postal/zip/pin codes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在许多网站上日常使用正则表达式。例如，在搜索引擎上搜索您最喜欢的食谱时，在填写表格并输入用户名和密码等数据时，等等。在许多网站上设置密码时，我们会遇到密码验证错误，例如密码必须包含一个数字或至少一个大写字母或至少一个特殊字符，等等。所有这些检查都可以使用正则表达式完成。一些更典型的正则表达式示例包括验证电话号码或验证邮政/邮编/PIN码。
- en: '**A bit of history of regular**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式的简史**'
- en: '**expressions**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: Renowned mathematician Stephen Kleene built a model in the year 1956 using finite
    automata for simple algebra. He described regular languages using his mathematical
    notation called *regular sets*. Computer programmers started using regular expressions
    in the 1970s when the Unix operating system and some of its text editors and text
    processing utilities such as ed, sed, emacs, lex, vi, grep, awk, and so on were
    built.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 著名数学家斯蒂芬·克莱尼在1956年使用有限自动机为简单代数构建了一个模型。他使用他称为“正则集”的数学符号描述了正则语言。计算机程序员在20世纪70年代开始使用正则表达式，当时Unix操作系统及其一些文本编辑器和文本处理实用程序（如ed、sed、emacs、lex、vi、grep、awk等）被构建。
- en: Regular expressions gained more popularity with the arrival of Perl and Tcl
    scripting languages in the 1980s and 1990s. Since then, all the popular programming
    languages, such as Java, Python, Ruby, R, PHP, and .NET have built very good support
    of regular expressions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式在20世纪80年代和90年代Perl和Tcl脚本语言的到来后变得更加流行。从那时起，所有流行的编程语言，如Java、Python、Ruby、R、PHP和.NET都构建了非常好的正则表达式支持。
- en: '**Various flavors of regular**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式的各种版本**'
- en: '**expressions**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: All the programming and scripting languages have built-in support for regular
    expressions these days. The basic rules to define and execute regular expressions
    are pretty much the same across all the languages. However, these regex implementations
    have their own flavors that differ from each other at the advanced level. We will
    cover regular expressions using Java in this book.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有编程和脚本语言都内置了对正则表达式的支持。定义和执行正则表达式的基本规则在所有语言中几乎相同。然而，这些正则表达式实现在其高级水平上各有特色。本书我们将使用Java来介绍正则表达式。
- en: 'Some of the popular flavors of regular expressions are as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的正则表达式版本如下：
- en: .NET
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: .NET
- en: Java
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Java
- en: Perl
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Perl
- en: PCRE (PHP)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: PCRE（PHP）
- en: JavaScript
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: VBScript
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: VBScript
- en: Python
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Python
- en: R
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: R
- en: Ruby
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby
- en: std::regex
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: std::regex
- en: boost::regex
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: boost::regex
- en: '**Basic Regular Expressions** (**BRE**) - used by Unix utilities ed, vi, sed,
    grep, and so on'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本正则表达式**（**BRE**）- 由Unix工具ed、vi、sed、grep等使用'
- en: '**Extended Regular Expressions** (**ERE**) - used by Unix utilities sed, grep,
    awk, and so on'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展正则表达式**（**ERE**）- 由Unix工具sed、grep、awk等使用'
- en: '**What type of problems need**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要解决什么类型的问题**'
- en: '**regular expressions to solve**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式用于解决**'
- en: 'Some programmers wonder why they even need to learn regular expressions. Here
    are some use cases:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员想知道为什么他们甚至需要学习正则表达式。以下是一些用例：
- en: While searching for some text at times, there are cases where we don't know
    the value of the text upfront. We just know some rules or patterns of the text.
    For example, searching for a MAC address in a log message, searching for IP
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索某些文本时，有时我们事先不知道文本的值。我们只知道一些文本的规则或模式。例如，在日志消息中搜索MAC地址，或者在IP地址中搜索。
- en: address in a web server access log, or searching for a 10-digit mobile number
    that may be optionally preceded by *0* or *+<2 digit country code>.*
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web服务器访问日志中搜索地址，或者搜索可能以*0*或*+<2位国家代码>.*为前缀的10位手机号码。
- en: Sometimes, the length of the text we are trying to extract is unknown, for example,
    searching URLs that start with http:// or https:// in a CSV file.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们试图提取的文本长度是未知的，例如，在CSV文件中搜索以http://或https://开始的URL。
- en: Sometimes, we need to split a given text on delimiters of a variable type and
    length and generate tokens.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要根据变量类型和长度将给定文本分割成分隔符，并生成标记。
- en: Sometimes, we need to extract text that falls between two or more search patterns.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要提取位于两个或更多搜索模式之间的文本。
- en: Often, we need to validate the various forms of user inputs, such as bank account
    number, passwords, usernames, credit card info, phone number, date of birth, and
    so on.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，我们需要验证各种用户输入的形式，例如银行账户号码、密码、用户名、信用卡信息、电话号码、出生日期等。
- en: There are situations where you only want to capture all the repeated words from
    a line.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只想从一行中捕获所有重复的单词。
- en: To convert input text into certain predefined formats, such as inserting a comma
    after every three digits or removing commas inside parentheses only.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入文本转换为某些预定义格式，例如在每三位数字后插入逗号或仅从括号内删除逗号。
- en: To do a global search replace while skipping all the escaped characters.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局搜索替换时跳过所有转义字符。
- en: '**The basic rules of regular**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式的规则**'
- en: '**expressions**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: 'Many of you are familiar with wild cards (in the Unix world, it is called **glob
    pattern**) matching of text. Here:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人都熟悉文本的通配符匹配（在Unix世界中，它被称为**全局模式**）。在这里：
- en: '**?** matches any single character'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**?** 匹配任意单个字符'
- en: '***** matches any sequence of characters'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '***** 匹配任意字符序列'
- en: '**[abc]** matches any one character inside square brackets, so it will match
    a, b, or c The regular expression pattern goes many steps farther than wild cards,
    where one can set many rules in a regex pattern, such as the following: Match
    a character or a group of characters optionally (0 or 1 times) Use quantifiers
    in regex patterns to match variable length text Use a character class to match
    one of the listed characters or match a range of characters'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个元素。
- en: Use a negated character class to match any character except those matched by
    the character class
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何除
- en: Match only certain character categories, such as match only digits, only upper
    case letters, or only punctuation characters
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个字符的
- en: Match a character or a group of characters for a specific length.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 将在接下来的章节中介绍
- en: Match a length range, such as allow only six to 10 digits in the input or match
    an input of a minimum of eight characters
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 章节）。
- en: Use Boolean "OR" in an alternation to match one of the few alternative options
    Use groups in regex patterns and capture substrings that we want to extract or
    replace from a given input
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用否定字符类来匹配除字符类匹配之外的任何字符
- en: Alter the behavior of matching by keeping it greedy (eager), lazy (reluctant),
    or possessive
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持贪婪（急切）、懒惰（犹豫）或占有性来改变匹配的行为
- en: 'Use back references and forward references of groups that we capture Use zero-width
    assertions such as the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下零宽断言：
- en: Start and end anchors
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和结束锚点
- en: Word boundary
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 单词边界
- en: Lookahead and lookbehind assertions
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们捕获的组的回溯和前溯
- en: Start a match from the end of a previous match
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个匹配的末尾开始匹配
- en: 'For example, in a regex to match a or b we can use the following alternation:
    a|b'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在匹配a或b的正则表达式中，我们可以使用以下交替：a|b
- en: 'To match one or more instances of the digit 5, we can use the following: 5+'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**m** 是这里的**可选**匹配。'
- en: 'To match any substring that starts with p and ends with w, we can use the following:
    p.*w'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在交替中使用布尔“或”以匹配少数几个可选选项。在正则表达式模式中使用组来捕获我们想要从给定输入中提取或替换的子串
- en: '**Constructs of the standard**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准**'
- en: '**regular expression and meta**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式和元**'
- en: '**characters**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符**'
- en: 'Let''s get familiar with core constructs of regular expressions and some reserve
    meta characters that have a special meaning in regular expressions. We shall cover
    these constructs in detail in the coming chapters:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 字母 **m.**
- en: '**Symbol**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配一个或多个数字5的实例，我们可以使用以下格式：5+
- en: '**Meaning**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**.** (点或'
- en: '**Example**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '**.** (dot or'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 组。
- en: Matches any character other
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由|分隔的
- en: Matches **#**, **@**, **A**, **f**, **5**, or **.**
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 **#**, **@**, **A**, **f**, **5**, 或 **.**
- en: period)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 期)
- en: than newline.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 比换行符。
- en: '***** matches zero or more'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号**'
- en: occurrences of the
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 发生次数
- en: m* matches 0 or more
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: m* 匹配前一个字符的0个或多个
- en: '***** (asterisk)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**+** (加号)'
- en: preceding character or
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 字母 **m.**
- en: occurrences of the letter **m.**
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**m|n|p** 表示匹配以下任一'
- en: group.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**m+** 匹配一个或多个'
- en: '**+** matches one or more'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**nm?** 表示匹配 **n** 或 **nm**，即'
- en: '**m+** matches one or more'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 仅匹配某些字符类别，例如仅匹配数字、仅匹配大写字母或仅匹配标点符号
- en: '**+** (plus)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 用于匹配零个或一个
- en: occurrences of the
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 发生次数
- en: occurrences of the letter **m.**
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配长度范围，例如只允许输入中包含6到10位数字或匹配至少8个字符的输入
- en: preceding element.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '***** (星号)'
- en: '**?** means optional match. It'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**?** 表示可选匹配。它'
- en: is used to match zero or one
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 字母 **m** 或字母 **n** 或
- en: occurrence of the preceding
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**+** 匹配一个或多个'
- en: '**?** (question'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**?** (问题'
- en: '**nm?** means match **n** or **nm**, as'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 的字母或字母 **n**。
- en: element. It is also used for
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 元素。它也用于
- en: mark)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 标记)
- en: '**m** is an **optional** match here.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**意义**'
- en: lazy matching (which will
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配行的开始
- en: be covered in the coming
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉正则表达式的核心结构和一些在正则表达式中具有特殊意义的保留元字符。我们将在接下来的章节中详细讨论这些结构：
- en: chapters).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配以p开头并以w结尾的任何子串，我们可以使用以下格式：p.*w
- en: '**|** means alternation. It is'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**|** 表示交替。它是'
- en: '**m|n|p** means match either the'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 与正则
- en: '**|** (pipe)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**|** (管道)'
- en: used to match one of the
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 用于匹配以下
- en: letter **m** or the letter **n** or the
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配特定长度的字符或字符组。
- en: elements separated by |
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**[abc]** 匹配方括号内的任何单个字符，因此它将匹配a、b或c。正则表达式模式比通配符更复杂，可以在正则表达式模式中设置许多规则，例如以下内容：可选地匹配一个或一组字符（0或1次）使用量词在正则表达式模式中匹配可变长度的文本使用字符类来匹配列表中的字符或匹配字符范围'
- en: letter p
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 字母p
- en: ^m matches m only when it is
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ^m 仅当它是
- en: the first character of the
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 的第一个字符
- en: string that we are testing
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在测试的
- en: '**^** is called anchor, that'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**^** 被称为锚点，它'
- en: against the regular
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**^** (捕获)'
- en: '**^** (cap)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 前瞻和后瞻断言
- en: matches start of the line
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '***** 匹配0个或多个'
- en: expression. Also, note that
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: you do not use ^ in the
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: middle of a regular
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: expression.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '**$** is called anchor that'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '**$** (dollar)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '**m$** matches m only at line end.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: matches line end.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '**\b**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Alphabets, numbers, and
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '**\bjava\b** matches the word, java .'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: underscore are considered
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: So, it will not match javascript
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: followed
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: word characters. **\b** asserts
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: since the word, javascript, will
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: by the
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: word boundary, which is the
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: fail to assert \b after java in the
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: letter b)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: position just before and
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: regex.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: after a word.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '**\B**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: For the input text, *abc*,
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**\B** asserts true where **\b**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: followed
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: doesn't, that is, between two
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '**\B** will be asserted at two places:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: by
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: word characters.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: uppercase
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Between *a* and *b*.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: B)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Between *b* and *c*.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '**(...)** a sub-'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: This is for grouping a part
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '**m(ab)*t** matches m, followed'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: pattern
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: of text that can be used to
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: by zero or more occurrences
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: inside
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: capture a certain substring
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: of the substring, **ab**, followed
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: round
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: or for setting precedence.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: by **t**.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: parentheses
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: A quantifier range to match
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '**mp{2,4}** matches m followed **2**'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: the preceding element
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '{min,max}'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: to **4** occurrences of the letter
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: between the minimum and
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: p.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: the maximum number.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: This is called a character
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '**[A-Z]** matches any uppercase'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '**[...]**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: class.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: English alphabet.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '**\d**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '**\d** matches any digit in the 0-'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: followed
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: This will match any digit.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 9 range.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: by the
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: letter d)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '**\D**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: followed
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: This matches any character
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '**\D** matches a, $, or _.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: by
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: that is not a digit.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: uppercase
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: D)
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '**\s**'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Matches any whitespace,
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: followed
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: including tab, space, or
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '**\s** matches **[ \t\n]**.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: by the
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: newline.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: letter s)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '**\S**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: followed
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Matches any non-
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '**\S** matches the opposite of \s'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: by
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: whitespace.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: uppercase
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: S)
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '**\w**'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '**\w** will match [a-zA-Z0-9_], so'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Matches any word character
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: it will match any of these
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: followed
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: that means all alphanumeric
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'strings: " *abc*", " *a123*", or by the'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: characters or underscore.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '" *pq_12_ABC*"'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: letter w)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Matches any non-word
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '**\W**'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: character, including
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: (backslash
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: whitespaces. In regex, any
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: It will match any of these
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: followed
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: character that is not
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'strings: " *+/=*", " *$*", or " *!~*"'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: by the
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: matched by \w can be
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: letter W)
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: matched using \W.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '**Some basic regular**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '**expression examples**'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some basic examples of regular expressions: ab*c'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: This will match a, followed by zero or more b, followed by c.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: ab+c
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: This will match a followed by one or more b, followed by c.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: ab?c
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: This will match a followed by zero or one b, followed by c. Thus, it will match
    both abc or ac.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: ^abc$
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: This will match abc in a line, and the line must not have anything other than
    the string abc due to the use of the start and end anchors on either side of the
    regex.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: a(bc)*z
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 'This will match a, followed by zero or more occurrences of the string bc, followed
    by z. Thus, it will match the following strings: az, abcz, abcbcz, abcbcbcz, and
    so on.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: ab{1,3}c
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'This will match a, followed by one to three occurrences of b, followed by c.
    Thus, it will match following strings: abc, abbc, and abbbc.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配 a，后面跟一个到三个 b 的出现，然后是 c。因此，它将匹配以下字符串：abc，abbc 和 abbbc。
- en: red|blue
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: red|blue
- en: This will match either the string red or the string blue.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配字符串 red 或字符串 blue。
- en: \b(cat|dog)\b
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: \b(cat|dog)\b
- en: This will match either the string cat or the string dog, ensuring both cat and
    dog must be complete words; thus, it will **fail** the match if the input is cats
    or dogs.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配字符串 cat 或字符串 dog，确保 cat 和 dog 必须是完整的单词；因此，如果输入是 cats 或 dogs，则匹配将**失败**。
- en: '[0-9]'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[0-9]'
- en: This is a character class with a character range. The preceding example will
    match a digit between 0 and 9\.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有字符范围的字符类。前面的示例将匹配介于 0 和 9 之间的数字。
- en: '[a-zA-Z0-9]'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[a-zA-Z0-9]'
- en: This is a character class with a character range. The preceding example will
    match any alpha-numeric character.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有字符范围的字符类。前面的示例将匹配任何字母数字字符。
- en: ^\d+$
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ^\d+$
- en: This regex will match an input containing only one or more digits.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式将匹配只包含一个或多个数字的输入。
- en: '![Image 6](img/index-37_1.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![Image 6](img/index-37_1.jpg)'
- en: ^\d{4,8}$
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ^\d{4,8}$
- en: This regex will allow an input containing four to eight digits only. For example,
    1234, 12345, 123456, and 12345678 are valid inputs.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式将只允许包含四个到八个数字的输入。例如，1234，12345，123456 和 12345678 都是有效的输入。
- en: ^\d\D\d$
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ^\d\D\d$
- en: This regex not only allows only one digit at the start and end but also enforces
    that between these two digits there must be one non-digit character. For example,
    1-5, 3:8, 8X2, and so on are valid inputs.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式不仅允许在开始和结束处只有一个数字，而且强制在这两个数字之间必须有一个非数字字符。例如，1-5，3:8，8X2等等都是有效的输入。
- en: ^\d+\.\d+$
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: ^\d+\.\d+$
- en: This regex matches a floating point number. For example, 1.23, 1548.567, and
    7876554.344 are valid inputs.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式匹配一个浮点数。例如，1.23，1548.567，和 7876554.344 都是有效的输入。
- en: .+
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: .+
- en: 'This matches any character one or more times. For example, qwqewe, 12233, or
    f5^h_=!bg are all valid inputs:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配任意字符一次或多次。例如，qwqewe，12233，或 f5^h_=!bg 都是有效的输入：
- en: ^\w+\s+\w+$
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: ^\w+\s+\w+$
- en: This matches a word, followed by one or more whitespaces, followed by another
    word in an input. For example, hello word, John Smith, and United Kingdom will
    be matched using this regex.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配一个单词，后面跟一个或多个空格，然后是另一个单词。例如，hello word，John Smith 和 United Kingdom 将使用此正则表达式进行匹配。
- en: '***Engine** is a term often used for an underlying module that evaluates* *the
    provided regular expression and matches the input string.*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '***引擎**是一个术语，通常用于评估提供的正则表达式并匹配输入字符串的底层模块。***'
- en: '**Eager matching**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪婪匹配**'
- en: At this point, it is important to understand one important behavior of regular
    expression engines, called eagerness. A regular expression engine performs a match
    operation from left to right in an input string. While matching a regex pattern
    against the input string, the regex engine moves from left to right and is always
    eager to complete a match, even though there are other alternative ways in the
    regular expression to complete the match. Once a substring is matched, it stops
    proceeding further and returns the match. Only when a character position fails
    to match all the possible permutations of the regular expression, then the regex
    engine moves character by character to attempt a match at the next position in
    the input string. While evaluating a regex pattern, the regex engine may move
    backwards (backtrack) one position at a time to attempt matching.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，理解正则表达式引擎的一个重要行为非常重要，称为贪婪。正则表达式引擎从左到右在输入字符串中执行匹配操作。当将正则表达式模式与输入字符串匹配时，正则表达式引擎从左到右移动，并且总是渴望完成匹配，即使正则表达式中还有其他替代方式可以完成匹配。一旦匹配了子字符串，它就会停止进一步处理并返回匹配结果。只有当字符位置无法匹配正则表达式的所有可能的排列时，正则表达式引擎才会逐字符移动，尝试在输入字符串的下一个位置进行匹配。在评估正则表达式模式时，正则表达式引擎可能会逐个位置向后移动（回溯）以尝试匹配。
- en: '**The effect of eager matching**'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪婪匹配的效果**'
- en: '**on regular expression**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**在正则表达式上**'
- en: '**alternation**'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**交替**'
- en: This regular expression engine behavior may return unexpected matches in alternation
    if alternations are not ordered carefully in the regex pattern.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在正则表达式模式中不仔细排序交替，这种正则表达式引擎的行为可能会在交替中返回意外的匹配。
- en: 'Take an example of this regex pattern, which matches the strings white or whitewash:
    white|whitewash'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个正则表达式模式为例，它匹配字符串 white 或 whitewash：white|whitewash
- en: While applying this regex against an input of *whitewash*, the regex engine
    finds that the first alternative white matches the *white* substring of the input
    string *whitewash*, hence, the regex engine stops proceeding further and returns
    the match as white.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这个正则表达式应用于输入 *whitewash* 时，正则表达式引擎发现第一个备选的 white 匹配了输入字符串 *whitewash* 中的
    *white* 子串，因此，正则表达式引擎停止进一步处理并返回匹配结果为 white。
- en: Note that our regex pattern has a better second alternative as whitewash, but
    due to the regex engine's eagerness to complete and return the match, the first
    alternative is returned as a match and the second alternative is ignored.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的正则表达式模式有更好的第二个备选 whitewash，但由于正则表达式引擎急于完成并返回匹配结果，第一个备选被作为匹配返回，而第二个备选被忽略。
- en: 'However, consider swapping the positions of the third and fourth alternatives
    in our regex pattern to make it as follows:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑交换我们正则表达式模式中的第三和第四个备选的位置，使其如下所示：
- en: whitewash|white
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: whitewash|white
- en: If we apply this against the same input, *whitewash*, then the regex engine
    correctly returns the match as whitewash.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个正则表达式应用于相同的输入，*whitewash*，那么正则表达式引擎会正确地返回匹配结果为whitewash。
- en: 'We can also use anchors or boundary matchers in our regular expressions to
    make it match a complete word. Any of the following two patterns will match and
    return whitewash as a match:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在正则表达式中使用锚点或边界匹配器来使其匹配一个完整的单词。以下两种模式中的任何一种都会匹配并返回 whitewash 作为匹配结果：
- en: ^(white|whitewash)$
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: ^(white|whitewash)$
- en: \b(white|whitewash)\b
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: \b(white|whitewash)\b
- en: 'Let''s take a look at a more interesting example, which attempts to match a
    known literal string " *cat & rat"* or a complete word in the input, using the
    following pattern:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更有趣的例子，它尝试使用以下模式匹配一个已知的字面字符串 " *cat & rat*" 或输入中的完整单词：
- en: \b(\w+|cat & rat)\b
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: \b(\w+|cat & rat)\b
- en: 'If the input string is *story of cat & rat*, and we apply our regex pattern
    repeatedly, then the following four matched substrings will be returned:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入字符串是 *story of cat & rat*，并且我们反复应用我们的正则表达式模式，那么以下四个匹配的子串将被返回：
- en: 1\. story
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. story
- en: 2\. of
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. of
- en: 3\. cat
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. cat
- en: 4\. rat
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. rat
- en: It is because the regex engine is eagerly using the first alternative pattern
    \w+ to match a complete word and is returning all the matched words. The engine
    never attempts a second alternative of the literal string, cat & rat, because
    a successful match is always found using the first alternative. However, let's
    change the regex pattern to the
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为正则表达式引擎正急切地使用第一个备选模式 \w+ 来匹配一个完整的单词，并返回所有匹配的单词。引擎从未尝试第二个备选的字符串，cat & rat，因为总是使用第一个备选来找到成功的匹配。然而，让我们将正则表达式模式更改为
- en: 'following:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 'following:'
- en: \b(cat & rat|\w+)\b
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: \b(cat & rat|\w+)\b
- en: 'If we apply this regex on the same sting, *story of cat & rat*, and we apply
    our regex pattern repeatedly, then the following three matched substrings will
    be returned: 1\. story'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个正则表达式应用于相同的字符串，*story of cat & rat*，并且我们反复应用我们的正则表达式模式，那么以下三个匹配的子串将被返回：1\.
    story
- en: 2\. of
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. of
- en: 3\. cat & rat
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. cat & rat
- en: This is because now cat & rat is the first alternative and when the regex engine
    moves to a position before the letter c in the input, it is able to match and
    return a successful match using the first alternative.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为现在 cat & rat 是第一个备选，当正则表达式引擎移动到输入中字母 c 之前的位置时，它能够使用第一个备选匹配并返回一个成功的匹配。
- en: '**Summary**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you were introduced to regular expressions with a bit of history
    and their flavors. You learnt some use cases where regex are needed. Finally,
    we covered the basic rules and building blocks of writing regex, with a few examples.
    You also learnt the eager-matching behavior of the regex engine and how it may
    impact matching in alternations.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过一些历史背景和它们的风格了解了正则表达式。你学习了需要正则表达式的一些用例。最后，我们介绍了编写正则表达式的基本规则和构建块，并附带了一些示例。你还学习了正则表达式引擎的贪婪匹配行为及其如何可能影响备选匹配。
- en: In the next chapter, we will go a level deeper and cover the core concepts of
    regex in detail, such as quantifiers, lazy vs greedy matching, anchors, negated
    character classes, Unicode and predefined character classes, special escape sequences,
    and the rules of escaping inside a character class.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨正则表达式的核心概念，详细讲解量词、懒惰匹配与贪婪匹配、锚点、否定字符类、Unicode和预定义字符类、特殊转义序列以及字符类内转义的规则。
- en: '**Understanding the Core**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解核心**'
- en: '**Constructs of Java Regular**'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java正则表达式结构**'
- en: '**Expressions**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: Using Java as a regular expression flavor, in this chapter, we will go a bit
    deeper and learn in detail about anchors, quantifiers, boundary matchers, all
    the available character classes, negated character classes, predefined character
    classes, and character classes escaping rules, using Java as a reference point.
    You will also learn Unicode text matching, using *regular expressions* in Java.
    We will also cover greedy versus non-greedy (lazy matching) and the change of
    regular expression behavior with lazy matching.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java作为正则表达式风味，在本章中，我们将深入探讨并详细学习关于锚点、量词、边界匹配器、所有可用的字符类、否定字符类、预定义字符类和字符类转义规则，以Java作为参考点。你还将学习使用Java中的*正则表达式*进行Unicode文本匹配。我们还将涵盖贪婪与非贪婪（懒惰匹配）以及正则表达式行为在懒惰匹配中的变化。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：
- en: Anchors and quantifiers
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点和量词
- en: Boundary matchers
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 边界匹配器
- en: Character classes
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类
- en: Regex escaping rules
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式转义规则
- en: Escaping inside character classes
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类内的转义
- en: Negated character classes
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 否定字符类
- en: Predefined character classes
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义字符类
- en: Unicode characters matching
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字符匹配
- en: Greedy quantifiers
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪量词
- en: Lazy quantifiers
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰量词
- en: Possessive quantifiers
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 占有性量词
- en: Various embedded modes in regular expressions and their meaning Enabling/disabling
    regular expression modes inside the regex
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中的各种嵌入模式及其意义 在正则表达式内启用/禁用正则表达式模式
- en: '**Understanding the core**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**理解核心**'
- en: '**constructs of regular**'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式的结构**'
- en: '**expressions**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: Certain special character constructs are allowed literally in Java regular expressions.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java正则表达式中，某些特殊字符结构可以按字面意思使用。
- en: 'Here they are:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它们：
- en: '**Special**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊**'
- en: '**Meaning**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**意义**'
- en: '**Character**'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符**'
- en: '**\0c**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '**\0c**'
- en: A character with the octal value c
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 一个八进制值为c的字符
- en: '**\0cc**'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '**\0cc**'
- en: A character with the octal value cc
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 一个八进制值为cc的字符
- en: A character with the octal value ncc, where n cannot be
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 一个八进制值为ncc的字符，其中n不能是
- en: '**\0ncc**'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '**\0ncc**'
- en: more than 3
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 超过3
- en: '**\xhh**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**\xhh**'
- en: A character with the hexadecimal value 0xhh
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 一个十六进制值为0xhh的字符
- en: '**\uhhhh**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**\uhhhh**'
- en: A character with the hexadecimal value 0xhhhh
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 一个十六进制值为0xhh的字符
- en: A character with the hexadecimal value 0xh...h, where h
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 一个十六进制值为0xh...h的字符，其中h
- en: '**\x{h...h}**'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '**\x{h...h}**'
- en: must be a valid CODE_POINT
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 必须是一个有效的CODE_POINT
- en: '**\n**'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '**\n**'
- en: Newline character or u000A
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 换行字符或u000A
- en: '**\t**'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '**\t**'
- en: Tab character or u0009
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 制表符或u0009
- en: '**\r**'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '**\r**'
- en: Carriage return character or u000D
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 回车字符或u000D
- en: '**\f**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**\f**'
- en: Form feed character or u000C
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 换页字符或u000C
- en: '**\e**'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '**\e**'
- en: Escape character or u\u001B
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 转义字符或u\u001B
- en: '**\a**'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '**\a**'
- en: Bell character or \u0007
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 铃声字符或\u0007
- en: '**\cn**'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '**\cn**'
- en: A control character represented by n
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 由n表示的控制字符
- en: '**Quantifiers**'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**量词**'
- en: We briefly looked at quantifiers in the first chapter. Quantifiers allow us
    to quantify the occurrences of our matches. We can match the input in various
    ways, such as an optional match, an open-ended range, a closed range, and by using
    a fixed number.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章简要介绍了量词。量词允许我们量化匹配的次数。我们可以以各种方式匹配输入，例如可选匹配、开放式范围、封闭范围以及使用固定数量。
- en: Let's take a closer look at them, as quantifiers are integral to most of the
    regular expressions.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看它们，因为量词对于大多数正则表达式都是至关重要的。
- en: '![Image 7](img/index-45_1.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![Image 7](img/index-45_1.jpg)'
- en: '**Basic quantifiers**'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本量词**'
- en: 'The following table lists all the quantifiers available in Java regular expressions:
    **Quantifier**'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了Java正则表达式中所有可用的量词：**量词**
- en: '**Meaning**'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '**意义**'
- en: '**m***'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '**m*** '
- en: Match **m** zero or more times
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配**m**零次或多次
- en: '**m+**'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '**m+**'
- en: Match **m** one or more times
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配**m**一次或多次
- en: '**m?**'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**m?**'
- en: Match **m** one or zero times (also called an optional match) **m{X}**
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配**m**一次或零次（也称为可选匹配）**m{X}**
- en: Match **m** exactly *X* times
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配**m**正好**X**次
- en: '**m{X,}**'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,}**'
- en: Match **m** *X* or more times
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配**m**至少**X**次
- en: '**m{X,Y}**'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,Y}**'
- en: Match **m** at least *X* and at most *Y* times *In all the aforementioned cases,
    **m** can be a single character or a* *group of characters. We will discuss grouping
    in more detail later.*
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配**m**至少**X**次和最多**Y**次*在所有上述情况下，**m**可以是一个单个字符或一组字符。我们将在稍后更详细地讨论分组。*
- en: '![Image 8](img/index-46_1.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![Image 8](img/index-46_1.jpg)'
- en: '**Examples using quantifiers**'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用量词的示例**'
- en: Let's look at few examples to understand these basic quantifiers better.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个示例来更好地理解这些基本量词。
- en: Which regex pattern should be used to match a two-digit year or a four-digit
    year?
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个正则表达式模式应该用于匹配两位数年份或四位数年份？
- en: \d{2}|\d{4}
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: \d{2}|\d{4}
- en: 'Which regex pattern should be used to match a signed decimal number? The pattern
    should also match a signed integer number:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用哪个正则表达式模式来匹配一个有符号的十进制数？该模式还应匹配有符号的整数数：
- en: ^[+-]?\d*\.?\d+$
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: ^[+-]?\d*\.?\d+$
- en: 'Here is the breakup of the preceding regex pattern:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是先前正则表达式模式的分解：
- en: The ^ and $ symbols are the start/end anchors
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: ^ 和 $ 符号是开始/结束锚点
- en: The [+-]? pattern makes either the + sign or the - sign (optional because of
    ?) at the start
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '[+-]? 模式使起始处的 + 符号或 - 符号（由于 ? 而是可选的）'
- en: The \d* pattern matches zero or more digits
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: \d* 模式匹配零个或多个数字
- en: The \.? pattern matches an optional dot (.) literally
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: \.? 模式匹配一个可选的点（.）字面量
- en: The \d+ pattern matches one or more digits
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: \d+ 模式匹配一个或多个数字
- en: 'The preceding regex will match all of these inputs:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的正则表达式将匹配以下所有输入：
- en: '.45'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '.45'
- en: '123789'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '123789'
- en: '5'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '123.45'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '123.45'
- en: '+67.66'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '+67.66'
- en: '-987.34'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '-987.34'
- en: What would be the regex to match a number that is at least 10 but not more than
    9999?
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配至少为 10 但不超过 9999 的数字，应该使用什么正则表达式？
- en: ^\d{2,4}$
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: ^\d{2,4}$
- en: Since we have a minimum of two digits, 10 is the smallest match, whereas the
    maximum number of digits allowed is four, and hence, 9999 is the highest match.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们至少有两个数字，10 是最小的匹配，而允许的最大数字数量是四个，因此 9999 是最高的匹配。
- en: What is the regex for an input that has seven digits and that can have + or
    - at the start?
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个有七个数字且开头可以有 + 或 - 的输入，正则表达式是什么？
- en: ^[+-]?\d{7}$
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: ^[+-]?\d{7}$
- en: The [+-]? pattern makes it an optional match at the start before we match the
    seven digits using \d{7}.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: The [+-]? pattern makes it an optional match at the start before we match the
    seven digits using \d{7}.
- en: '*The preceding regex can also be written as ^[+-]?[0-9]{7}$, as \d is a* *shorthand
    property to match [0-9]*'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '*先前的正则表达式也可以写成 ^[+-]?[0-9]{7}$，因为 \d 是* *一个简写属性，用于匹配 [0-9]*'
- en: '**Greedy versus reluctant**'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪婪与懒惰**'
- en: '**(lazy) matching using**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**(懒惰)匹配使用**'
- en: '**quantifiers**'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '**量词**'
- en: So far, we have discussed all the quantifiers available to us in a regular expression
    to match fixed-size or variable-length text. These quantifiers are, by default,
    **greedy** in nature. Greediness is in terms of their matching. In a regex, quantifiers
    attempt to match the longest possible text, from left to right. Only when the
    regex engine fails to complete a match, it moves back in the input text one character
    at a time, as required, to complete the match. Sometimes, the regex engine moves
    back and forth multiple times in attempts to complete a match in a complex (nested)
    regular expression.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了正则表达式中可用于匹配固定大小或可变长度文本的所有量词。这些量词默认是 **贪婪** 的。贪婪性在于它们的匹配。在正则表达式中，量词尝试匹配尽可能长的文本，从左到右。只有当正则表达式引擎无法完成匹配时，它才会逐个字符地向后移动输入文本，以完成所需的匹配。有时，正则表达式引擎会在复杂（嵌套）正则表达式中多次来回移动，以尝试完成匹配。
- en: So, for example, if the input is pqrstmprt and our regular expression is p.+r,
    then our match will be from p at the start to the last r, that is, pqrstmpr**,**
    not pqr. It is due to the same greediness that was stated earlier, where the regex
    engine attempts to match the longest possible match when using quantifiers.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果输入是 pqrstmprt，我们的正则表达式是 p.+r，那么我们的匹配将从起始处的 p 到最后一个 r，即 pqrstmpr**,**，而不是
    pqr。这是由于之前提到的相同贪婪性，当使用量词时，正则表达式引擎尝试匹配尽可能长的匹配。
- en: Regular expressions also provide a way to change this greedy behavior of the
    regex engine. If we place a ? ( *called the lazy or reluctant quantifier*) in
    front of any of the quantifiers, then the behavior of the regex engine changes
    from **greedy** to **lazy**. With the lazy quantifier in place, the regex engine
    attempts to match the shortest match, only expanding further as required to complete
    the match with the remainder of the regex pattern next to the lazy quantifier.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式还提供了一种改变正则表达式引擎贪婪行为的方法。如果我们将一个 ?（称为懒惰或不愿意的量词）放在任何量词之前，那么正则表达式引擎的行为将从 **贪婪**
    变为 **懒惰**。在有懒惰量词的情况下，正则表达式引擎尝试匹配最短的匹配，只有在需要时才会进一步扩展以完成与懒惰量词旁边的正则表达式模式的匹配。
- en: So, in the preceding example, if we use the regex as p.+?r, then our matched
    text will be pqr, because *pqr* is the smallest possible match between p and r.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在先前的例子中，如果我们使用正则表达式 p.+?r，那么我们的匹配文本将是 pqr，因为 *pqr* 是 p 和 r 之间可能的最小匹配。
- en: 'Here is a list of all the greedy quantifiers and their corresponding lazy quantifiers:
    **Greedy Quantifier**'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有贪婪量词及其对应懒惰量词的列表：**贪婪量词**
- en: '**Lazy Quantifier**'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒惰量词**'
- en: '**m***'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**m*** '
- en: '**m*?**'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '**m*?**'
- en: '**m+**'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**m+**'
- en: '**m+?**'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**m+?**'
- en: '**m?**'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '**m?**'
- en: '**m??**'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**m??**'
- en: '**m{X}**'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X}**'
- en: '**m{X}?**'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X}?**'
- en: '**m{X,}**'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,}**'
- en: '**m{X,}?**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,}?**'
- en: '**m{X,Y}**'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,Y}**'
- en: '**m{X,Y}?**'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,Y}?**'
- en: '**Possessive quantifiers**'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**占有量词**'
- en: Possessive quantifiers are quantifiers that are greedy when matching text like
    greedy quantifiers do. Both greedy and possessive quantifiers try to match as
    many characters as possible. The important difference, however, is that the possessive
    quantifiers do not backtrack (go back) unlike greedy quantifiers; therefore, it
    is possible that the regex match fails if the possessive quantifiers go too far.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 占有量词是像贪婪量词一样在匹配文本时贪婪的量词。贪婪和占有量词都试图匹配尽可能多的字符。然而，重要的区别是占有量词不会回溯（后退），与贪婪量词不同；因此，如果占有量词走得太远，正则表达式匹配可能会失败。
- en: 'This table shows all the three types of quantifiers, side by side: **Greedy
    Quantifier**'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示了所有三种类型的量词并排：**贪婪量词**
- en: '**Lazy Quantifier**'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒惰量词**'
- en: '**Possessive** **Quantifier**'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**占有** **量词**'
- en: '**m***'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**m*** '
- en: '**m*?**'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '**m*?**'
- en: '**m*+**'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**m*+**'
- en: '**m+**'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**m+**'
- en: '**m+?**'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '**m+?**'
- en: '**m++**'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '**m++**'
- en: '**m?**'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '**m?**'
- en: '**m??**'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '**m??**'
- en: '**m?+**'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '**m?+**'
- en: '**m{X}**'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X}**'
- en: '**m{X}?**'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X}?**'
- en: '**m{X}+**'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X}+**'
- en: '**m{X,}**'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,}**'
- en: '**m{X,}?**'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,}?**'
- en: '**m{X,}+**'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,}+**'
- en: '**m{X,Y}**'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,Y}**'
- en: '**m{X,Y}?**'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,Y}?**'
- en: '**m{X,Y}+**'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '**m{X,Y}+**'
- en: Let's take an example input string, a1b5, and see the behavior of the greedy,
    lazy, and possessive quantifiers.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个示例输入字符串a1b5，看看贪婪、懒惰和占有量词的行为。
- en: If we apply a regex using the greedy quantifier, \w+\d, then it will match a1b
    (the longest match before backtracking starts) using \w+, and 5 will be matched
    using \d; thus, the full match will be a1b5\.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用贪婪量词的正则表达式，\w+\d，那么它将使用\w+匹配a1b（回溯开始之前的最长匹配），并使用\d匹配5；因此，完整的匹配将是a1b5\。
- en: Now, if we apply a regex using the non-greedy quantifier, \w+?\d, then it will
    match a (the shortest match before expanding starts) using \w+?, and then the
    adjacent digit 1
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用非贪婪量词的正则表达式，\w+?\d，那么它将使用\w+?匹配（在扩展开始之前的最短匹配），然后匹配相邻的数字1
- en: will be matched using \d. Thus, the first full match will be a1\. If we let
    the regex execute again, then it will find another match, b5\.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用\d进行匹配。因此，第一个完整的匹配将是a1\.如果我们让正则表达式再次执行，那么它将找到另一个匹配，b5\。
- en: Finally, if we apply a regex using the possessive quantifier, \w++\d, then it
    will match all the characters a1b5 (the longest possible match without giving
    back) using \w++ .
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们使用占有量词的正则表达式，\w++\d，那么它将使用\w++匹配所有字符a1b5（不回退的最长匹配）。
- en: Due to this, \d remains unmatched, and hence the regex fails to find any match.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，\d没有匹配，因此正则表达式无法找到任何匹配。
- en: Let's take another example. The requirement is to match a string that starts
    with lowercase English alphabets or hyphen. The string can have any character
    after the alphabets/hyphens, except a colon. There can be any number of any characters
    of any length after the colon until the end.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子。要求是匹配一个以小写英文字母或连字符开头的字符串。字符串可以在字母/连字符之后有任意字符，但不能是冒号。冒号之后可以有任何数量和长度的任意字符，直到字符串结束。
- en: An example of a valid input is as-df999 and that of an invalid input is asdf-:123\.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效输入的例子是as-df999，无效输入的例子是asdf-:123\.
- en: 'Now, let''s try solving this regex problem using a greedy quantifier regex:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用贪婪量词正则表达式来解决这个正则表达式问题：
- en: ^[a-z-]+[^:].*$
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: ^[a-z-]+[^:].*$
- en: Unfortunately, this is not the right regex pattern because this regex will match
    both
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不是正确的正则表达式模式，因为这个正则表达式将匹配以下两种
- en: the aforementioned valid and invalid inputs. This is because of the backtracking
    behavior of the regex engine in greedy quantifiers. The [a-z-]+ pattern will find
    the longest possible match in the form of asdf-, but due to the negated character
    class pattern [^:] , the regex engine will backtrack one position to asdf and
    will match the next *hyphen* for [^:]. All the remaining text, that is, :123,
    will be matched using .*.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 上述有效和无效的输入。这是因为贪婪量词的正则表达式引擎的回溯行为。模式[a-z-]+将找到最长可能的匹配形式为asdf-，但由于否定字符类模式[^:]，正则表达式引擎将回溯一个位置到asdf，并匹配下一个*连字符*用于[^:]。所有剩余的文本，即：123，将使用.*进行匹配。
- en: 'Let''s try to solve this regex problem using the following possessive quantifier
    regex:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用以下占有量词正则表达式来解决这个正则表达式问题：
- en: ^[a-z-]++[^:].*$
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: ^[a-z-]++[^:].*$
- en: This regex pattern will still match our valid input, but it will fail to match
    an invalid input because there is no backtracking in possessive quantifiers; hence,
    the regex engine will not go back any position after matching asdf- in the second
    example string. Since the next character is a colon and our regex sub-pattern
    is [^:], the regex engine will stop matching and correctly declare our invalid
    input a failed match.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式模式仍然会匹配我们的有效输入，但它将无法匹配无效输入，因为没有回溯；因此，正则表达式引擎不会在第二个示例字符串匹配 asdf- 之后回到任何位置。由于下一个字符是冒号，并且我们的正则表达式子模式是
    [^:]，正则表达式引擎将停止匹配，并正确地宣布我们的无效输入为失败匹配。
- en: Possessive quantifiers are good for the performance of the underlying regex
    engine because the engine does not have to keep any backtracking information in
    memory.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 占有量词对底层正则表达式引擎的性能有益，因为引擎不需要在内存中保留任何回溯信息。
- en: The performance increase is even more when a regex fails to match because possessive
    quantifiers fail faster. So, remember that the benefit of possessive quantifiers
    is to improve the regex performance, especially when using nested quantifiers.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 当正则表达式无法匹配时，性能提升更为显著，因为占有量词失败得更快。所以，记住占有量词的好处是提高正则表达式的性能，尤其是在使用嵌套量词时。
- en: '![Image 9](img/index-50_1.jpg)'
  id: totrans-768
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9](img/index-50_1.jpg)'
- en: '**Boundary constructs**'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '**边界构造**'
- en: 'Boundary constructs allow us to specify where our matches should start or stop
    by restricting our matches to certain boundaries. We avoid matching unwanted text
    by adding restrictions to the start and stop positions of the matching text using
    boundary matchers. Here are all the boundary constructs available in Java regular
    expressions: **Boundary**'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 边界构造允许我们通过限制匹配的起始或结束位置来指定我们的匹配应该在哪里开始或停止。我们通过在匹配文本的起始和结束位置添加限制来避免匹配不需要的文本。以下是
    Java 正则表达式中所有可用的边界构造：**边界**
- en: '**Matcher**'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '**匹配器**'
- en: '**Meaning**'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '**意义**'
- en: '**Name**'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**'
- en: Word boundary; position between a word and a non-word
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 单词边界；位于单词和非单词之间
- en: '**\b**'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '**\b**'
- en: character
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: Non-word boundary; it compliments **\b** and asserts true
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 非单词边界；它与 **\b** 相辅相成并断言为真
- en: '**\B**'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '**\B**'
- en: wherever **\b** asserts false
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **\b** 断言为假的地方
- en: '**^**'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**^**'
- en: Line-start anchor, which matches the start of a line
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 行首锚点，匹配行的开始
- en: Line-end anchor, which matches just before the optional line **$**
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾锚点，匹配在可选行 **$** 之前
- en: break at the end of a line
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾的换行符
- en: Permanent start of input; in a multiline input using
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的永久起始位置；在多行输入中使用
- en: '**\A**'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '**\A**'
- en: MULTILINE mode, **\A** matches only at the very beginning, while **^** is matched
    at every line start position
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 多行模式，**\A** 只匹配在最开始的位置，而 **^** 在每一行的起始位置匹配
- en: Permanent end of input; in a multiline input using
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的永久结束位置；在多行输入中使用
- en: '**\z**'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '**\z**'
- en: MULTILINE mode, **\z** matches only at the very end while **$**
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 多行模式，**\z** 只匹配在最后的位置，而 **$**
- en: is matched at every line end position
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配在每一行的末尾位置
- en: Similar to **\z** with the only difference being that it matches
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **\z** 类似，唯一的区别是它匹配
- en: '**\Z**'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '**\Z**'
- en: just before the optional line break at the very end of the input.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在输入的最后一个可选换行符之前。
- en: End of the previous match; we will discuss it in advanced
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个匹配的末尾；我们将在高级课程中讨论它
- en: '**\G**'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '**\G**'
- en: sections of the book in the next chapters.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍下一章中的部分。
- en: '*Let''s recall from the first chapter that [a-zA-Z0-9_] are called word* *characters.
    All other characters are considered non-word characters.*'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们回顾第一章的内容，[a-zA-Z0-9_] 被称为单词* *字符。所有其他字符都被视为非单词字符。*'
- en: '![Image 10](img/index-51_1.jpg)'
  id: totrans-798
  prefs: []
  type: TYPE_IMG
  zh: '![图片 10](img/index-51_1.jpg)'
- en: '**Examples using boundary**'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例使用边界**'
- en: '**constructs**'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造**'
- en: Which regex should be used to match "at" when the input is 'Hat at work"?
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入是 'Hat at work' 时，应该使用哪个正则表达式来匹配 "at"？
- en: \bat\b
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: \bat\b
- en: The preceding regex should be used because \b (word boundary) stops the regex
    engine to match at in Hat, because \bat\b can match full words only.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用前面的正则表达式，因为 \b（单词边界）阻止正则表达式引擎在 Hat 中匹配 at，因为 \bat\b 只能匹配完整的单词。
- en: What should be regex if we only want to match at in Hat but not the one that
    was matched in the preceding regex?
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想匹配 Hat 中的 at 而不是前一个正则表达式匹配的 at，那么正则表达式应该是什么？
- en: \Bat\b
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: \Bat\b
- en: Now, this regex will match at that is a part of Hat because \B asserts a position
    that is between two word characters or a position between two non-word characters.
    Because of the presence of \B in the regex, it matches at only in Hat but not
    the word at.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个正则表达式将匹配 Hat 中的 at，因为 \B 断言的位置是在两个单词字符之间或两个非单词字符之间。由于正则表达式中存在 \B，它只匹配 Hat
    中的 at，而不匹配单词 at。
- en: If the input is suppress expression press depression, what will be the matches
    if the regex is \Bpress\B?
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是抑制表**达**式 按压表**达**，那么如果正则表达式是 \Bpress\B，将会匹配什么？
- en: suppress ex**press**ion press de**press**ion
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 抑制表**达**式 按压表**达**
- en: This is because \B matches the position between word characters, and the other
    instances, suppress and press, have non-word characters after press.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 \B 匹配单词字符之间的位置，而其他实例，抑制和按压，在按压后有非单词字符。
- en: 'If the input is ppp\n555\n, then show the matched text using the following
    two regular expressions:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是 ppp\n555\n，那么使用以下两个正则表达式显示匹配的文本：
- en: \Ap+\n5{3}\Z
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: \Ap+\n5{3}\Z
- en: \Ap+\n5{3}\z
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: \Ap+\n5{3}\z
- en: 'Here are the matches:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是匹配结果：
- en: '**A)** ppp\n555'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '**A)** ppp\n555'
- en: '**B)** No match'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '**B)** 无匹配'
- en: The starting part, \Ap+\n5{3}, is common in both the regex patterns and matches
    ppp\n555 both the times. However, we are getting no match in the second case because
    of the subtle difference between the \Z and \z assertions. \Z asserts the position
    at the end or just before the last line terminator whereas \z always asserts the
    position at the very end. Due to the presence of \n at the end of the file, our
    second regex does not match. If we change the second regex to \Ap+\n5{3}\n\z,
    then it will match the entire input.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式模式中的起始部分，\Ap+\n5{3}，在两种模式中都是共同的，并且两次都匹配 ppp\n555。然而，由于 \Z 和 \z 断言之间的细微差别，我们在第二种情况下没有匹配。\Z
    断言在末尾或最后一个换行符之前的位置，而 \z 总是断言在非常末尾的位置。由于文件末尾存在 \n，我们的第二个正则表达式没有匹配。如果我们将第二个正则表达式更改为
    \Ap+\n5{3}\n\z，那么它将匹配整个输入。
- en: '*Note that the end anchor $ also behaves like \Z if the MULTILINE flag* *(will
    be discussed later) is not enabled in an input text with multiple* *lines. Thus,
    the preceding input string can also be matched using*'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意，如果输入文本中有多行且没有启用 MULTILINE 标志* *(稍后讨论) *，则末尾锚点 $ 也像 \Z 一样行为。因此，也可以使用前面的输入字符串进行匹配*'
- en: '*^p+\n5{3}$.*'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '*^p+\n5{3}$.*'
- en: '**Character classes**'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: We briefly looked at character classes in the first chapter. Character classes
    (or character sets) let us match one out of the many characters defined inside
    a class.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中简要介绍了字符类。字符类（或字符集）让我们匹配类中定义的许多字符之一。
- en: Character classes are enclosed inside a square bracket. The order of the characters
    inside a character class does not matter.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类被括号包围。字符类内部字符的顺序并不重要。
- en: '**Examples of character**'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符示例**'
- en: '**classes**'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别**'
- en: Which regex will match the letters *p*, *m*, or *z*?
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个正则表达式可以匹配字母 *p*、*m* 或 *z*？
- en: '**Solution 1:**'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案 1：**'
- en: '[pmz]'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '[pmz]'
- en: '**Solution 2:**'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案 2：**'
- en: '[zmp]'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '[zmp]'
- en: '**Solution 3:**'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案 3：**'
- en: '[mzp]'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '[mzp]'
- en: All the preceding three regular expressions will behave in exactly the same
    manner because the order of the characters inside the character class does not
    matter.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前三个正则表达式将以完全相同的方式表现，因为字符类内部字符的顺序并不重要。
- en: Which regex will match English language vowels *a*, *e*, *i*, *o*, and *u*?
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个正则表达式可以匹配英语语言元音 *a*、*e*、*i*、*o* 和 *u*？
- en: '[aeiou]'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '[aeiou]'
- en: Which regex will match the field extensions .mp3 or .mp3?
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个正则表达式可以匹配字段扩展名 .mp3 或 .mp3？
- en: \.mp[34]
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: \.mp[34]
- en: Which regex will match the letters **@**, **#**, or **=**?
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个正则表达式可以匹配字母 **@**、**#** 或 **=**？
- en: '[@#=]'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '[@#=]'
- en: '**Range inside a character**'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符范围内的范围**'
- en: '**class**'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别**'
- en: We can also specify a **character range** inside a character class by using
    a hyphen ( - ) between two characters. You just have to make sure that the left-hand
    side character of a range is lower in the ASCII table than the right-hand side
    character. We can match all the digits using the regex patterns, [0123456789],
    or a shorter [0-9].
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在两个字符之间使用连字符（-）来指定字符类内的字符范围。你只需确保范围左侧的字符在 ASCII 表中的位置低于右侧的字符。我们可以使用正则表达式模式匹配所有数字，例如
    [0123456789]，或者更短的 [0-9]。
- en: '**Examples of character range**'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符范围示例**'
- en: 'The following is a regex that matches any uppercase or lowercase alphabet in
    the English language:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个匹配英语语言中任何大写或小写字母的正则表达式：
- en: '[a-zA-Z]'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '[a-zA-Z]'
- en: The a-z pattern is for the lowercase character range and A-Z is for the uppercase
    character range.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: a-z 模式用于小写字母范围，A-Z 用于大写字母范围。
- en: 'The following regex matches any alphanumeric characters:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配任何字母数字字符：
- en: '[a-zA-Z0-9]'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '[a-zA-Z0-9]'
- en: Alpha numeric characters consist of any English alphabets and digits.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 阿拉伯数字字符由任何英语字母和数字组成。
- en: 'The following regex matches any hexadecimal character:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配任何十六进制字符：
- en: '[a-fA-F0-9]'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '[a-fA-F0-9]'
- en: We know that hexadecimal characters consist of digits, 0 to 9, and letters,
    A to F
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道十六进制字符由数字组成，0 到 9，以及字母，A 到 F
- en: (ignore casing). The preceding regex pattern shows a character class that includes
    these two character ranges. We use a-f and A-F ranges to make it match uppercase
    or lowercase letters.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: (忽略大小写)。前面的正则表达式模式显示了一个包含这两个字符范围的字符类。我们使用 a-f 和 A-F 范围来使其匹配大写或小写字母。
- en: '**Escaping special regex**'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊正则表达式的转义**'
- en: '**metacharacters and escaping**'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**元字符和转义**'
- en: '**rules inside the character**'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符内部的规则**'
- en: '**classes**'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: We know that . matches any character, [ and ] are used for character classes,
    { and }
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 . 匹配任何字符，[ 和 ] 用于字符类，{ 和 }
- en: are used for limiting quantifiers, and ? , *, and + are used for various quantifiers.
    To match any of the metacharacters *literally*, one needs to *escape* these characters
    using a *backslash (*\ ) to suppress their special meaning. Similarly, ^ and $
    are anchors that are also considered regex metacharacters.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 用于限制量词，而 ? , *, 和 + 用于各种量词。为了匹配元字符 *literally*，需要使用 *escape* 这些字符，通过一个 *backslash
    (*\ ) 来抑制它们的特殊意义。同样，^ 和 $ 是锚点，也被认为是正则表达式元字符。
- en: Let's see some examples of escaping metacharacters in regular expressions.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些在正则表达式中转义元字符的示例。
- en: 'The following regex matches the string, a.b?:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '以下正则表达式匹配字符串，a.b?:'
- en: a\.b\?
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: a\.b\?
- en: 'The following regex matches the string, {food}:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '以下正则表达式匹配字符串，{food}:'
- en: \{food\}
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: \{food\}
- en: 'The following regex matches the string, abc:][}{:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '以下正则表达式匹配字符串，abc:][}{:'
- en: abc:\]\[\}\{
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: abc:\]\[\}\{
- en: 'The following regex matches the string, $25.50:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '以下正则表达式匹配字符串，$25.50:'
- en: \$\d+\.\d+
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: \$\d+\.\d+
- en: 'The following regex matches the string, ^*+.:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '以下正则表达式匹配字符串，^*+.:'
- en: \^\*\+\.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: \^\*\+\.
- en: '![Image 11](img/index-57_1.jpg)'
  id: totrans-869
  prefs: []
  type: TYPE_IMG
  zh: '![Image 11](img/index-57_1.jpg)'
- en: '**Escaping inside a character**'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类内部的转义**'
- en: '**class**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: In the Java regex engine, all the special regex metacharacters lose their special
    meaning inside a character class except the ^ (**carrot**), - (**hyphen**), ]
    (**right square** **bracket**), and \ (**backslash**) characters.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 正则表达式引擎中，所有特殊正则表达式元字符在字符类内部都失去了它们的特殊意义，除了 ^ (**胡萝卜**)、- (**连字符**)、] (**右方括号**)
    和 \ (**反斜杠**) 字符。
- en: '*Inside a character class, the hyphen also does not need to be escaped* *when
    used as the first or last character, since a character range* *requires both the
    left-hand side and the right-hand side characters.*'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '*在字符类内部，连字符也不需要转义，当用作第一个或最后一个字符时，因为字符范围* *需要左右两侧的字符。*'
- en: '*Similarly, ^ (carrot) needs to escaped only when used as the first* *character
    inside a character class.*'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '*同样，^ (胡萝卜) 只需要在作为字符类内部第一个字符时进行转义。*'
- en: '**Examples of escaping rules**'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '**转义规则的示例**'
- en: '**inside the character class**'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类内部**'
- en: 'The following regex matches a string containing one or more of the ap.9 characters:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配包含一个或多个ap.9字符的字符串：
- en: ^[ap9.]+$
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: ^[ap9.]+$
- en: The dot (.) doesn't need to be escaped inside the character class.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 点 (.) 在字符类内部不需要转义。
- en: 'The following regex matches a string containing one or more of the @#$%.* characters:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配包含一个或多个@#$%.*字符的字符串：
- en: ^[$#@%.*]+$
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: ^[$#@%.*]+$
- en: None of the preceding special characters require escaping inside the character
    class.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的所有特殊字符在字符类内部都不需要转义。
- en: 'The following regex matches a string containing one or more of the ?*+. characters:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配包含一个或多个?*+.字符的字符串：
- en: ^[*+?.]+$
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: ^[*+?.]+$
- en: 'The following regex matches an input that allows any digit, ], or ^ in the
    input:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配允许任何数字、]，或 ^ 的输入：
- en: ^[\^\]0-9]+$
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: ^[\^\]0-9]+$
- en: We can also write our regex as ^[\]0-9^]+$ by moving ^ away from the first position
    and avoiding the escaping.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将我们的正则表达式写成 ^[\]0-9^]+$，通过将 ^ 移离第一个位置并避免转义。
- en: 'The following regex matches an input that allows any alphanumeric character,
    hyphen, dot, or backslash, such as xyzTR-4.5\00:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配允许任何字母数字字符、连字符、点或反斜杠的输入，例如 xyzTR-4.5\00：
- en: ^[a-zA-Z0-9.\-\\]+$
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: ^[a-zA-Z0-9.\-\\]+$
- en: 'We can also write our regex as follows by moving - to the last position inside
    the character class, thus avoiding the escaping:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将 - 移到字符类内的最后一个位置来避免转义，从而写成以下正则表达式：
- en: ^[a-zA-Z0-9.\\-]+$
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: ^[a-zA-Z0-9.\\-]+$
- en: '**Literally matching a string**'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '**字面匹配字符串**'
- en: '**that may contain special**'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能包含特殊**'
- en: '**regex metacharacters**'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式元字符**'
- en: We have seen how we need to escape all the special regex metacharacters to be
    able to match them literally.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们需要转义所有特殊正则表达式元字符才能字面匹配它们。
- en: The Java regex engine provides special escape sequences, \Q and \E, for this
    purpose.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: Java 正则表达式引擎为此提供了特殊的转义序列，\Q 和 \E。
- en: Any string that is wrapped between \Q and \E looses interpretation of all the
    regex metacharacters in the wrapped string.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 任何被\Q和\E包裹的字符串都会丢失包裹字符串中所有正则表达式元字符的解释。
- en: 'For example, to write a regex that matches a string ^*+., we can avoid all
    escaping and use this regex:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要编写一个匹配字符串^*+.,的正则表达式，我们可以避免所有转义并使用此正则表达式：
- en: \Q^*+.\E
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: \Q^*+.\E
- en: Note that there must not be any character escaping between \Q and \E sequences.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，\Q和\E序列之间不得有任何字符转义。
- en: 'To match an input string, "[a-z0-9]", we can write our regex as follows:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配一个输入字符串 "[a-z0-9]"，我们可以将我们的正则表达式写成如下：
- en: \Q[a-z0-9]\E
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: \Q[a-z0-9]\E
- en: Java provides a convenient method to return a literal pattern sting for the
    given string called Pattern.quote(String). We will learn about this method in
    [Chapter 5,](index_split_001.html#p111) *Introduction* *to Java Regular Expressions
    APIs - Pattern and Matcher Classes*, of the book.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一个方便的方法来返回给定字符串的文本模式字符串，称为Pattern.quote(String)。我们将在本书的[第5章](index_split_001.html#p111)，*Java正则表达式API介绍
    - Pattern和Matcher类*中学习此方法。
- en: '![Image 12](img/index-60_1.jpg)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
  zh: '![Image 12](img/index-60_1.jpg)'
- en: '**Negated character classes**'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '**否定字符类**'
- en: By placing the carrot character (^) in the first position inside a character
    class (just next to [) **negates** the matching of the character class. A negated
    character class matches any character that is not included in the class. A negated
    character class also negates a character range by matching any character not matched
    by the character range.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在字符类内部的第一位置放置胡萝卜字符（^）（紧挨着[）**否定**了字符类的匹配。否定字符类匹配不在类中的任何字符。否定字符类还通过匹配字符范围之外的任何字符来否定字符范围。
- en: '*You learned in [Chapter 1](#p27)* *, Getting Started with Regular Expressions,
    that* *dot (.) matches any character except the newline character. However,* *note
    that the negated character class also matches newline characters* *such as \r,
    \n, and so on.*'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '*您在[第1章](#p27)* *中学习了关于正则表达式的入门知识，即点（.）匹配除换行符以外的任何字符。然而，*请注意，否定字符类也匹配换行符* *如\r、\n等。*'
- en: '**Examples of negated**'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '**否定示例**'
- en: '**character classes**'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: 'The following regex matches any character except a forward slash:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配除正斜杠以外的任何字符：
- en: '[^/]'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '[^/]'
- en: Also, remember the fact that a negated character such as [^/] must match a single
    character. It doesn't match zero-width assertions such as ^, $, \Z, \z, \b, \B,
    and so on.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，记住以下事实：一个否定字符，如[^/]，必须匹配单个字符。它不匹配零宽断言，如^、$、\Z、\z、\b、\B等。
- en: 'The following regex matches any character but a and A:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配任何字符但a和A：
- en: '[^aA]'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '[^aA]'
- en: 'The following regex matches all the *consonants* of the English language:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配英语语言中的所有**辅音**：
- en: '[^aeiou]'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '[^aeiou]'
- en: All non-vowels are considered *consonants***;** hence, we just need to negate
    the vowel character class.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非元音都被认为是**辅音**；因此，我们只需要否定元音字符类。
- en: 'The following regex matches all the characters except digits, dots, and line
    breaks:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式匹配除数字、点和换行符之外的所有字符：
- en: '[^0-9.\r\n]'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '[^0-9.\r\n]'
- en: 'In this regex, we could also use the predefined property \d for [0-9]:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个正则表达式中，我们也可以使用预定义属性\d来表示[0-9]：
- en: '[^\d.\r\n]'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '[^\d.\r\n]'
- en: 'This regex matches http followed by any character except s: http[^s]'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 此正则表达式匹配http后跟除s以外的任何字符：http[^s]
- en: '**Predefined shorthand**'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '**预定义简写**'
- en: '**character classes**'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: As we have seen from the preceding examples, certain character classes, such
    as digits
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的示例，某些字符类，如数字
- en: '[0-9] or word characters [0-9A-Za-z_], are used in most regex patterns. The
    Java language, like all regular expression flavors, provides convenient predefined
    character classes for these character classes. Here is the list:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '[0-9]或单词字符[0-9A-Za-z_]，在大多数正则表达式模式中使用。Java语言，像所有正则表达式变体一样，为这些字符类提供了方便的预定义字符类。以下是列表：'
- en: '**Shorthand**'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '**简写**'
- en: '**Meaning**'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '**意义**'
- en: '**Character Class**'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: '**Class**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别**'
- en: '**\d**'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '**\d**'
- en: A digit 0-9
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字0-9
- en: '[0-9]'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '[0-9]'
- en: '**\D**'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '**\D**'
- en: A non-digit
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非数字
- en: '[^\d]'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '[^\d]'
- en: '**\w**'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '**\w**'
- en: A word character
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单词字符
- en: '[a-zA-Z0-9_]'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '[a-zA-Z0-9_]'
- en: '**W**'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '**W**'
- en: A non-word character
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非单词字符
- en: '[^\w]'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '[^\w]'
- en: A whitespace character,
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空白字符，
- en: '**\s**'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '**\s**'
- en: '[ \t\r\n\f\x0B]'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '[ \t\r\n\f\x0B]'
- en: including line break
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 包括换行符
- en: A non-whitespace
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非空白
- en: '**\S**'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '**\S**'
- en: '[^\s]'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '[^\s]'
- en: chacracter
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: A horizontal whitespace
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 一个水平空白
- en: '**\h**'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '**\h**'
- en: '[ \t\xA0\u1680\u180e\u2000-'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '[ \t\xA0\u1680\u180e\u2000-'
- en: character
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: \u200a\u202f\u205f\u3000]
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: \u200a\u202f\u205f\u3000]
- en: A non-horizontal
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非水平
- en: '**\H**'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '**\H**'
- en: '[^\h]'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '[^\h]'
- en: whitespace character
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 空白字符
- en: A vertical whitespace
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 一个垂直空白
- en: '**\v**'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '**\v**'
- en: '[\n\x0B\f\r\x85\u2028\u2029]'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '[\n\x0B\f\r\x85\u2028\u2029]'
- en: character
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: A non-vertical whitespace
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 非垂直空白
- en: '**\V**'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '**\V**'
- en: '[^\v]'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '[^\v]'
- en: character
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: '**POSIX character classes**'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**POSIX 字符类**'
- en: 'Java also supports many POSIX character classes for matching ASCII text. Here
    is the list:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还支持许多 POSIX 字符类以匹配 ASCII 文本。以下是列表：
- en: '**POSIX Character**'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '**POSIX 字符**'
- en: '**Meaning**'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '**意义**'
- en: '**Character Class**'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: '**Class**'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: '**\p{ASCII}**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{ASCII}**'
- en: All ASCII characters
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 ASCII 字符
- en: '[\x00-\x7F]'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '[\x00-\x7F]'
- en: '**\p{Digit}**'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Digit}**'
- en: Any digit
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数字
- en: '[0-9]'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '[0-9]'
- en: '**\p{Lower}**'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Lower}**'
- en: Lowercase alphabets
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 小写字母
- en: '[a-z]'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '[a-z]'
- en: '**\p{Upper}**'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Upper}**'
- en: Uppercase alphabets
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 大写字母
- en: '[A-Z]'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '[A-Z]'
- en: '**\p{Alpha}**'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Alpha}**'
- en: Any alphabet
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 任何字母表
- en: '[\p{Lower}\p{Upper}]'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '[\p{Lower}\p{Upper}]'
- en: Any alpha-numeric
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 任何字母数字
- en: '**\p{Alnum}**'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Alnum}**'
- en: '[\p{Lower}p{Upper}\p{Digit}]'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '[\p{Lower}p{Upper}\p{Digit}]'
- en: character
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: A punctuation
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标点符号
- en: '**\p{Punct}**'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Punct}**'
- en: '[!"\#$%&''()*+,-./:;<=>?@\'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '[!"\#$%&''()*+,-./:;<=>?@\\]'
- en: character
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: '[\\\]^_`{|}~]'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '[\\\]^_`{|}~]'
- en: '**\p{Blank}**'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Blank}**'
- en: Space or tab
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 空格或制表符
- en: '[ \t]'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '[空格或制表符]'
- en: A whitespace
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 空白
- en: '**\p{Space}**'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Space}**'
- en: '[ \t\n\x0B\f\r]'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '[ \t\n\x0B\f\r]'
- en: character
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: A visible ASCII
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 可见的 ASCII
- en: '**\p{Graph}**'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Graph}**'
- en: '[\p{Alnum}\p{Punct}]'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '[\p{Alnum}\p{Punct}]'
- en: character
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 字符
- en: '**\p{Print}**'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Print}**'
- en: A printable character
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 可打印字符
- en: '[\p{Graph}\x20]'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '[\p{Graph}\x20]'
- en: '**\p{Cntrl}**'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Cntrl}**'
- en: A control character
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 控制字符
- en: '[\x00-\x1F\x7F]'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '[\x00-\x1F\x7F]'
- en: '**\p{XDigit}**'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{XDigit}**'
- en: A hexadecimal digit
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 一个十六进制数字
- en: '[0-9a-fA-F]'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '[0-9a-fA-F]'
- en: 'Java also supports four additional predefined character classes based on the
    java.lang.Character methods:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还支持基于 java.lang.Character 方法的四个额外的预定义字符类：
- en: '**Class Name**'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '**类名**'
- en: '**Implementing Method**'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现方法**'
- en: '**\p{javaLowerCase}**'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{javaLowerCase}**'
- en: Equivalent to java.lang.Character.isLowerCase()
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 java.lang.Character.isLowerCase()
- en: '**\p{javaUpperCase}**'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{javaUpperCase}**'
- en: Equivalent to java.lang.Character.isUpperCase()
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 java.lang.Character.isUpperCase()
- en: '**\p{javaWhitespace}**'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{javaWhitespace}**'
- en: Equivalent to java.lang.Character.isWhitespace()
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 java.lang.Character.isWhitespace()
- en: '**\p{javaMirrored}**'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{javaMirrored}**'
- en: Equivalent to java.lang.Character.isMirrored()
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 java.lang.Character.isMirrored()
- en: '**Unicode support in Java**'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 中的 Unicode 支持**'
- en: '**regular expressions**'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: So far, all the examples that we have seen in the first two chapters are for
    the English language only. However, a regular expression needs to have full support
    for all the languages using Unicode characters. Java has a Unicode-based regex
    engine and has extensive support for various Unicode scripts, blocks, and categories.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在前两章中看到的所有示例都仅适用于英语。然而，正则表达式需要完全支持所有使用 Unicode 字符的语言。Java 具有基于 Unicode
    的正则表达式引擎，并广泛支持各种 Unicode 字符脚本、块和类别。
- en: 'A specific Unicode character can be matched in two different ways in Java:
    1\. **Unicode escape sequence** **or the** \u **notation**: This can be written
    as "\u1234" or'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，可以以两种不同的方式匹配特定的 Unicode 字符：1\. **Unicode 转义序列** **或** \u **表示法**：这可以写成
    "\u1234" 或
- en: '"\\u1234".'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '"\\u1234".'
- en: '2\. **Hex notation**: This can be written as "\x{1234}".'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. **十六进制表示法**：这可以写成 "\x{1234}"。
- en: '**Commonly used Unicode**'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '**常用 Unicode**'
- en: '**character properties**'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符属性**'
- en: 'Here is the list of commonly used Unicode character properties in regular expressions
    that require to match Unicode texts:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是正则表达式中常用的 Unicode 字符属性列表，这些属性需要匹配 Unicode 文本：
- en: '**Unicode**'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unicode**'
- en: '**character**'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符**'
- en: '**Meaning**'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '**意义**'
- en: '**class**'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**'
- en: '**\p{L}**'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{L}**'
- en: Match any letter from any language
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何语言的任何字母
- en: '**\p{Lu}**'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Lu}**'
- en: Match any uppercase letter from any language
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何语言的任何大写字母
- en: '**\p{Ll}**'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Ll}**'
- en: Match any lowercase letter from any language
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何语言的任何小写字母
- en: '**\p{N}**'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{N}**'
- en: Match any digit from any language
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何语言的任何数字
- en: '**\p{P}**'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{P}**'
- en: Match any punctuation letter from any language
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何语言的任何标点字母
- en: '**\p{Z}**'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Z}**'
- en: Match any kind of whitespace or invisible separator
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何类型的空白或不可见分隔符
- en: '**\p{C}**'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{C}**'
- en: Match any invisible control letter
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何不可见的控制字母
- en: '**\p{Sc}**'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '**\p{Sc}**'
- en: Match any currency symbol
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配任何货币符号
- en: Any Unicode linebreak sequence; is equivalent to
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Unicode 行分隔序列；等同于
- en: \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]
- en: '**\R**'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '**\R**'
- en: '***It is recommended to use** \R **to match any newline character***'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '***建议使用** \R **来匹配任何换行符***'
- en: '***even if dealing with ASCII text.***'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '***即使处理 ASCII 文本时也是如此。***'
- en: '**Negation of the preceding**'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '**前一个类的否定**'
- en: '**regex directives**'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式指令**'
- en: To match a single character belonging to a particular *category*, we use the
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配属于特定 *类别* 的单个字符，我们使用
- en: \p{propertyName} directive.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: \p{propertyName} 指令。
- en: To match a single character **not** belonging to a particular *category*, we
    use the
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配不属于特定 *类别* 的单个字符 **不**，我们使用
- en: \P{propertyName} directive (note the uppercase **P** instead of the lowercase
    **p**).
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: \P{propertyName} 指令（注意大写 **P** 而不是小写 **p**）。
- en: '**Unicode scripts support**'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unicode 脚本支持**'
- en: 'Java supports all the Unicode scripts as defined by the Unicode standard. Here
    is a list of all the supported Unicode scripts:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: Java 支持由 Unicode 标准定义的所有 Unicode 脚本。以下是所有支持的 Unicode 脚本列表：
- en: \p{IsCommon}
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsCommon}
- en: \p{IsArabic}
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsArabic}
- en: \p{IsArmenian}
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsArmenian}
- en: \p{IsBengali}
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsBengali}
- en: \p{IsBopomofo}
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsBopomofo}
- en: \p{IsBraille}
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsBraille}
- en: \p{IsBuhid}
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsBuhid}
- en: \p{IsCanadian_Aboriginal}
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsCanadian_Aboriginal}
- en: \p{IsCherokee}
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsCherokee}
- en: \p{IsCyrillic}
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsCyrillic}
- en: \p{IsDevanagari}
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsDevanagari}
- en: \p{IsEthiopic}
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsEthiopic}
- en: \p{IsGeorgian}
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsGeorgian}
- en: \p{IsGreek}
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsGreek}
- en: \p{IsGujarati}
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsGujarati}
- en: \p{IsGurmukhi}
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsGurmukhi}
- en: \p{IsHan}
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsHan}
- en: \p{IsHangul}
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsHangul}
- en: \p{IsHanunoo}
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsHanunoo}
- en: \p{IsHebrew}
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsHebrew}
- en: \p{IsHiragana}
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsHiragana}
- en: \p{IsInherited}
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsInherited}
- en: \p{IsKannada}
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsKannada}
- en: \p{IsKatakana}
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsKatakana}
- en: \p{IsKhmer}
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsKhmer}
- en: \p{IsLao}
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsLao}
- en: \p{IsLatin}
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsLatin}
- en: \p{IsLimbu}
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsLimbu}
- en: \p{IsMalayalam}
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsMalayalam}
- en: \p{IsMongolian}
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsMongolian}
- en: \p{IsMyanmar}
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsMyanmar}
- en: \p{IsOgham}
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsOgham}
- en: \p{IsOriya}
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsOriya}
- en: \p{IsRunic}
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsRunic}
- en: \p{IsSinhala}
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsSinhala}
- en: \p{IsSyriac}
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsSyriac}
- en: \p{IsTagalog}
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsTagalog}
- en: \p{IsTagbanwa}
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsTagbanwa}
- en: \p{IsTaiLe}
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsTaiLe}
- en: \p{IsTamil}
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsTamil}
- en: \p{IsTelugu}
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsTelugu}
- en: \p{IsThaana}
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsThaana}
- en: \p{IsThai}
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsThai}
- en: \p{IsTibetan}
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsTibetan}
- en: \p{IsYi}
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: \p{IsYi}
- en: '**Unicode blocks**: Java supports all the previously listed script for matching
    Unicode blocks. We just need to replace Is with In in the preceding expressions.
    For example, to check for a **Thai** code block, we can use:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unicode 区块**: Java 支持之前列出的所有脚本以匹配 Unicode 区块。我们只需将前面的表达式中的 Is 替换为 In。例如，要检查
    **泰语** 区块，我们可以使用：'
- en: \p{InThai}
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: \p{InThai}
- en: '**Examples of matching**'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '**匹配示例**'
- en: '**Unicode text in regular**'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式中的 Unicode 文本**'
- en: '**expressions**'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: 'The following regex will match accented characters, such as " **à**":'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '以下正则表达式将匹配带音标的字符，例如 " **à**":'
- en: ^\p{L}+$
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: ^\p{L}+$
- en: 'The following regex will match a text consisting of Latin characters and Unicode
    whitespaces:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式将匹配由拉丁字符和 Unicode 空白符组成的文本：
- en: ^[\p{IsLatin}\p{Zs}]+$
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: ^[\p{IsLatin}\p{Zs}]+$
- en: 'The following regex should be used to detect the presence of a **Hebrew** character
    in input:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式应用于检测输入中是否存在 **希伯来语** 字符：
- en: \p{InHebrew}
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: \p{InHebrew}
- en: 'The following regex should be used to detect an input that contains only **Arabic**
    text:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式应用于检测仅包含 **阿拉伯语** 文本的输入：
- en: ^\p{InArabic}+$
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: ^\p{InArabic}+$
- en: 'How can we match Urdu text? Since Urdu is not a script, we will need to match
    certain Unicode code ranges. These are as follows:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何匹配乌尔都语文本？由于乌尔都语不是一个脚本，我们需要匹配某些 Unicode 代码范围。这些如下所示：
- en: U+0600 to U+06FF
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: U+0600 到 U+06FF
- en: U+0750 to U+077F
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: U+0750 到 U+077F
- en: U+FB50 to U+FDFF
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: U+FB50 到 U+FDFF
- en: U+FE70 to U+FEFF
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: U+FE70 到 U+FEFF
- en: 'A Java regex to detect the presence of any Urdu character will be:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 检测任何乌尔都语字符的 Java 正则表达式如下：
- en: '[\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '[\u0600-\u06FF\u0750-\u077F\uFB50-\uFDFF\uFE70-\uFEFF]'
- en: '**Double escaping in a Java**'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 中的双重转义**'
- en: '**String when defining regular**'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义正则表达式时的字符串**'
- en: '**expressions**'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: In Java, all the regular expressions are entered as a String type, where \ acts
    as an escape character and is used to interpret certain special characters such
    as \t, \n, and so on. So, it is necessary to double-escape all the predefined
    classes, such as \w, \d, \s, using two backslashes and while escaping metacharacters,
    such as \[, \(, \+, and so on, in string literals.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，所有正则表达式都作为 String 类型输入，其中 \ 作为转义字符，用于解释某些特殊字符，如 \t、\n 等。因此，必须使用两个反斜杠来转义所有预定义类，如
    \w、\d、\s 等，并在字符串字面量中转义元字符，如 \[、\(、\+ 等。
- en: 'If we have to use the preceding regex for a dollar amount in Java, then it
    would be as follows:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须在 Java 中使用前面的正则表达式来匹配金额，则如下所示：
- en: final String re = "\\$\\d+\\.\\d+";
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: final String re = "\\$\\d+\\.\\d+";
- en: 'The preceding example that matches a signed decimal number has to be written
    as follows in Java:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 之前匹配有符号十进制数的示例在 Java 中必须写成如下：
- en: final String re = "^[+-]?\\d*\\.?\\d+$";
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: final String re = "^[+-]?\\d*\\.?\\d+$";
- en: 'For the same reasons, if we have to match a single backslash character, then
    it would be as follows:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，如果我们必须匹配单个反斜杠字符，则如下所示：
- en: \\\\
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: \\\\
- en: 'How can we write a regex string that matches an input that allows any alphanumeric
    character, hyphen, dot, or backslash, such as xyzTR-4.5\00? Here is how: final
    String re = "^[a-zA-Z0-9.\-\\\\]+$";'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 如何编写一个正则表达式字符串，以匹配允许任何字母数字字符、连字符、点或反斜杠的输入，例如 xyzTR-4.5\00？以下是方法：final String
    re = "^[a-zA-Z0-9.\-\\\\]+$";
- en: 'How can we write a regular expression in Java that will accept any Latin character,
    Unicode whitespaces, or Unicode digits? Refer to the following regex: final String
    re = "^[\\p{IsLatin}\\p{Zs}\\p{N}]+$"; How to write a regular expression in Java
    that will accept any Unicde character, Unicode whitespaces, Unicode digits, or
    Unicode punctuation characters? Check out the following regex:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在 Java 中编写一个正则表达式，使其接受任何拉丁字符、Unicode 空白或 Unicode 数字？请参考以下正则表达式：final String
    re = "^[\\p{IsLatin}\\p{Zs}\\p{N}]+$"; 如何在 Java 中编写一个正则表达式，使其接受任何 Unicode 字符、Unicode
    空白、Unicode 数字或 Unicode 标点字符？查看以下正则表达式：
- en: 'final String re = "^[\\p{L}\\p{Z}\\p{N}\\p{P}]+$"; The following Java regex
    matches the string, " **abc:][}[**": final String re = "abc:\\]\\[\\}\\{";'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 'final String re = "^[\\p{L}\\p{Z}\\p{N}\\p{P}]+$"; 以下 Java 正则表达式匹配字符串 " **abc:][**":
    final String re = "abc:\\]\\[\\}\\{";'
- en: '**Embedded regular**'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '**内嵌正则**'
- en: '**expression mode modifiers**'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式模式修饰符**'
- en: 'Like all other regular expression flavors, Java also allows the **embedding**
    of some standard modes in the regular expression itself. These mode modifiers
    are used to change regular expression behavior in a certain manner. In the following
    table, we will list all these modes and their meaning:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他正则表达式风味一样，Java 也允许在正则表达式本身中嵌入一些标准模式。这些模式修饰符用于以某种方式更改正则表达式的行为。在以下表中，我们将列出所有这些模式及其含义：
- en: Mode
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: Name
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: Meaning
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 含义
- en: Ignore case
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略大小写
- en: Enables case-insensitive matching for US-ASCII
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 US-ASCII 不区分大小写的匹配
- en: '**(?i)**'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '**(?i)**'
- en: mode
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: text
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 文本
- en: DOTALL
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: DOTALL
- en: Makes DOT match all the characters, including
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 使 DOT 匹配所有字符，包括
- en: '**(?s)**'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '**(?s)**'
- en: mode
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: line breaks
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符
- en: Multiline
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 多行
- en: Makes the carrot and dollar match the start and
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 使得 carrot 和 dollar 匹配开始和
- en: '**(?m)**'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '**(?m)**'
- en: mode
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: end of each line in a multiline input
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的末尾
- en: Unicode-
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode-
- en: '**(?u)**'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '**(?u)**'
- en: aware case
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 感知大小写
- en: Enables Unicode-aware case folding
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Unicode 感知的大小写折叠
- en: folding
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠
- en: Unicode
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode
- en: Enables the Unicode version of predefined
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 启用预定义模式的 Unicode 版本
- en: '**(?U)**'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '**(?U)**'
- en: matching
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配
- en: character classes and POSIX character classes.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类和 POSIX 字符类。
- en: Unix line
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 行
- en: '**(?d)**'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '**(?d)**'
- en: Enables Unix lines mode
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Unix 行模式
- en: mode
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: Comment
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Allows for the presence of whitespace and
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在多行输入中存在空白和
- en: '**(?x)**'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '**(?x)**'
- en: mode
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: comments in the regex pattern
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式模式中的注释
- en: Let's check some examples to understand these modes better.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一些示例，以更好地理解这些模式。
- en: How to match an input in which the starting word is **Java** and the ending
    word is **Mode**, and we don't know what is in between these two words? Also,
    the input may contain line breaks as well.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 如何匹配一个以 **Java** 开头并以 **Mode** 结尾的输入，我们不知道这两个词之间有什么内容？此外，输入可能还包含换行符。
- en: 'Consider the following example input text, which is in two lines: Java regex'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例输入文本，它分为两行：Java 正则表达式
- en: Embedded Mode
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 内嵌模式
- en: 'Let''s use the following regex:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下正则表达式：
- en: \AJava.*Mode\z
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: \AJava.*Mode\z
- en: If we use the preceding regex, then the match will fail because we know that
    DOT
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面的正则表达式，那么匹配将失败，因为我们知道 DOT
- en: 'matches all the characters except line breaks by default. Hence, we need to
    enable the DOTALL mode here using the following:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下匹配所有字符（除了换行符）。因此，我们需要使用以下内容启用 DOTALL 模式：
- en: (?s)\AJava.*Mode\z
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: (?s)\AJava.*Mode\z
- en: Our regex will match the input because (?s) will enable the **DOTALL** mode
    and then
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的正则表达式将匹配输入，因为 (?s) 将启用 **DOTALL** 模式，然后
- en: .* will match the text between **Java** and **Mode**.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: .* 将匹配 **Java** 和 **Mode** 之间的文本。
- en: It is considered good practice to insert comments and line breaks in a complex
    and lengthy regular expression. In order to allow that, we will need to enable
    the comment mode using (?x).
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂且长的正则表达式中插入注释和换行符是一种良好的做法。为了允许这样做，我们需要使用 (?x) 启用注释模式。
- en: 'Here is an example of a regex with comments and extra whitespaces using multiple
    modifiers, including (?x):'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含多个修饰符（包括 (?x)）的带有注释和额外空白的正则表达式示例：
- en: 'String regex = "(?ixs)\\A # assert start of the string\n"'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 'String regex = "(?ixs)\\A # 断言字符串的开始\n"'
- en: + "java\n"
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: + "java\n"
- en: + "\\s\n"
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: + "\\s\n"
- en: + "regex\n"
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: + "regex\n"
- en: '+ ".* # match 0 or more of any character including line breaks\n"'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '+ ".* # 匹配 0 或多个任何字符，包括换行符\n"'
- en: + "Mode\n"
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: + "模式\n"
- en: '+ "\\z # assert end of the string";'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '+ "\\z # 断言字符串的末尾";'
- en: It is interesting to note that this regular expression will still match the
    input text that we used in the previous example. You can clearly see how the use
    of (?x) allows us to use arbitrary white-spaces and inline comments in our regex.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这个正则表达式仍然会匹配我们在上一个例子中使用的输入文本。你可以清楚地看到如何使用(?x)允许我们在正则表达式中使用任意空白和内联注释。
- en: Let's examine the use of the **MULTILINE** mode. In the same input text, that
    is, Java regex\nEmbedded Mode, what would be the regular expression that validates
    the first line only, which contains the text, *Java regex*?
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察**多行**模式的使用。在相同的输入文本中，即Java正则表达式\n嵌入模式，验证只包含文本*Java正则表达式*的第一行的正则表达式是什么？
- en: 'Let''s use anchors (caret and dollar) and write the regex as follows:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用锚点（尖号和美元符号）并将正则表达式写成如下：
- en: ^Java regex$
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: ^Java regex$
- en: This regex will **fail** to match our input because the input contains two lines
    and $ will not assert the position at the end of every line without enabling the
    **MULTILINE**
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 此正则表达式将**失败**匹配我们的输入，因为输入包含两行，并且$不会在没有启用**多行**模式的情况下断言每行的末尾位置。
- en: mode.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 模式。
- en: 'Change your regex to the following:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的正则表达式更改为以下：
- en: (?m)^Java regex$
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: (?m)^Java regex$
- en: And bingo! Our regex works now because we enabled the **MULTILINE** mode using
    (?m) at the start of the regex.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 bingo！我们的正则表达式现在工作正常了，因为我们已经在正则表达式的开头使用了(?m)启用了**多行**模式。
- en: '**The placement of embedded**'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入模式的放置**'
- en: '**modes in a Java regular**'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java正则表达式中的模式**'
- en: '**expression**'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式**'
- en: All the aforementioned embedded modes can be placed at the start of a regular
    expression to enable one or more modes for the complete regular expression. We
    can also place these modes in the middle of a regex to enable it for a specific
    group or a remainder of the regex pattern.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述嵌入模式都可以放置在正则表达式的开头，以启用整个正则表达式的单个或多个模式。我们也可以将这些模式放置在正则表达式的中间，以使其适用于特定的组或正则表达式模式的剩余部分。
- en: 'We can also **combine** multiple mode modifiers into a single expression like
    this: (?is)'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以**组合**多个模式修饰符到一个单独的表达式，如下所示：(?is)
- en: This enables the DOTALL and ignore case modes.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 这启用了DOTALL和忽略大小写模式。
- en: '**Disabling mode modifiers**'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用模式修饰符**'
- en: To disable a previously enabled mode, we can place a hyphen (-) before the modifier
    symbol anywhere in your regular expression.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用之前启用的模式，我们可以在正则表达式的任何位置放置修饰符符号之前放置一个连字符（-）。
- en: Let's look at some examples.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子。
- en: 'To disable DOTALL, we can use the following regex:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用DOTALL，我们可以使用以下正则表达式：
- en: (?-s)
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: (?-s)
- en: 'To disable ignore case matching, we can use the following regex: (?-i)'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用忽略大小写匹配，我们可以使用以下正则表达式：(?-i)
- en: 'To disable the MULTILINE mode, we can use the following regex: (?-m)'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用MULTILINE模式，我们可以使用以下正则表达式：(?-m)
- en: 'To disable both ignore case and MULTILINE mode, we can use the following regex:
    (?-im)'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用忽略大小写和MULTILINE模式，我们可以使用以下正则表达式：(?-im)
- en: 'To disable the ignore case, DOTALL, and MULTILINE modes, we can use the following
    regex:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用忽略大小写、DOTALL和MULTILINE模式，我们可以使用以下正则表达式：
- en: (?-ism)
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: (?-ism)
- en: '**Summary**'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we covered the core constructs of regular expressions in depth.
    You learned anchors, quantifiers, boundary matchers, various character classes,
    negated character classes, and predefined character classes. We found out that
    escaped characters need to be escaped twice in the Java language. You also learned
    Unicode text matching using regular expressions in Java. We covered greedy, non-greedy,
    and possessive quantifiers. You learned embedded mode modifiers in Java regular
    expressions and how they can change the interpretation of a regular expression.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了正则表达式的核心结构。你学习了锚点、量词、边界匹配器、各种字符类、否定字符类和预定义字符类。我们发现Java语言中转义字符需要被转义两次。你还学习了在Java中使用正则表达式进行Unicode文本匹配。我们涵盖了贪婪、非贪婪和占有量词。你学习了Java正则表达式中的嵌入模式修饰符以及它们如何改变正则表达式的解释。
- en: In the next chapter, we will cover another very important feature of regular
    expressions, called grouping. You will learn the various types of grouping available
    in Java regular expressions and how to use them.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍正则表达式的另一个非常重要的功能，称为分组。你将学习Java正则表达式中的各种分组类型以及如何使用它们。
- en: '**Working with Groups,**'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '**与组一起工作，**'
- en: '**Capturing, and References**'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '**捕获和引用**'
- en: In this chapter, you will learn how to match, capture, and reference substrings
    from a given input text using regular expressions. We will cover various types
    of groups available in Java, and the naming and numbering of captured groups.
    Readers will also learn how to use back reference or forward reference of the
    capturing groups.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用正则表达式匹配、捕获和引用给定输入文本中的子字符串。我们将介绍Java中可用的各种类型的组，以及捕获组的命名和编号。读者还将学习如何使用捕获组的后向引用或前向引用。
- en: 'We will be covering the following topics in this chapter: Grouping'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：分组
- en: Capturing groups
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获组
- en: Group numbering
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 组编号
- en: Non-capturing groups
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 非捕获组
- en: Back references
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 后向引用
- en: Named groups
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 命名组
- en: Forward references
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 前向引用
- en: Invalid references
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 无效引用
- en: '**Capturing groups**'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '**捕获组**'
- en: 'Groups are a very useful feature of regular expressions, which are supported
    in all the flavors of regular expressions. Groups are used to combine multiple
    characters or multiple smaller components of regular expressions into a single
    unit. We create groups by placing a series of characters or subpatterns inside
    round brackets or parentheses, ( and ). For example, consider the following regex
    pattern: (blue|red)'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 组是一个非常有用的正则表达式特性，它被所有正则表达式的变体所支持。组用于将多个字符或正则表达式的多个较小组件组合成一个单一的单位。我们通过在圆括号或括号（）内放置一系列字符或子模式来创建组。例如，考虑以下正则表达式模式：(blue|red)
- en: 'It means a capturing group that uses alternation. It either matches the letters
    b, l, u, and e or it matches the letters r, e, and d. In other words, it matches
    the strings blue or red, and more importantly, it creates a capturing group with
    either of the two matched strings. Each group becomes a single unit that can be
    used to apply certain constructs to the entire group. For example, anchors, boundary
    assertion, quantifiers, or alternation can be restricted to a part of the regular
    expression represented by the group. For example, look at the following regex
    pattern:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个使用交替的捕获组。它要么匹配字母b、l、u和e，要么匹配字母r、e和d。换句话说，它匹配字符串blue或red，更重要的是，它创建了一个捕获组，可以是这两个匹配字符串中的任何一个。每个组成为一个单独的单位，可以用来对整个组应用某些结构。例如，锚点、边界断言、量词或交替可以限制在由组表示的正则表达式的一部分。例如，看看以下正则表达式模式：
- en: ^Regular(Expression)?$
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: ^Regular(Expression)?$
- en: This regular expression will match the string, Regular, at the start. After
    that, there is one capturing group with the string, Expression; however, due to
    the placement of the ?
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式将匹配字符串，Regular，在开头。之后，有一个捕获组，字符串为，Expression；然而，由于?的位置
- en: quantifier after the group, it will match the 0 or 1 occurrence of the preceding
    group, making it an **optional capturing group**. Hence, this regex will either
    match the string, Regular, with an **empty** first capturing group or it will
    match the string RegularExpression, with the substring, Expression, in the first
    capturing group.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 组后面的量词，它将匹配前一个组的0或1次出现，使其成为一个**可选捕获组**。因此，这个正则表达式将要么匹配字符串，Regular，并且第一个捕获组为**空**，要么匹配字符串RegularExpression，并且子字符串，Expression，位于第一个捕获组中。
- en: 'If we are given a problem to write a regular expression that matches only an
    even number of digits in the input, then we can use this pattern:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到一个编写正则表达式的问题，要求匹配输入中的偶数个数字，那么我们可以使用这个模式：
- en: ^([0-9]{2})+$
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: ^([0-9]{2})+$
- en: Since the + quantifier (one or more) is used next to the group that matches
    a pair of digits, this quantifier is applied to the entire group. Hence, this
    regular expression will match one or more pairs of digits (2, 4, 6, 8, 10, ...),
    or in simple words, it matches an even number of digits.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于+量词（一个或多个）紧接匹配一对数字的组之后，这个量词应用于整个组。因此，这个正则表达式将匹配一个或多个数字对（2、4、6、8、10、...），或者简单地说，它匹配偶数个数字。
- en: A regular expression can have multiple capturing groups, which can be nested
    inside each other as well.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以有多个捕获组，这些组可以嵌套在彼此内部。
- en: 'For example, in the following regular expression, there are three capturing
    groups:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下正则表达式中，有三个捕获组：
- en: ^((\d+)-([a-zA-Z]+))$
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: ^((\d+)-([a-zA-Z]+))$
- en: 'The preceding expression will match the input string, that is, 1234-aBc with
    the following groups:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式将匹配输入字符串，即1234-aBc，并具有以下组：
- en: '1\. Group 1: 1234-aBc'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 组1：1234-aBc
- en: '2\. Group 2: 1234'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 组2：1234
- en: '3\. Group 3: aBc'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 组3：aBc
- en: '**Group numbering**'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '**组编号**'
- en: Capturing groups are numbered in increasing numbers, starting with number one.
    Java regular expressions support up to 99 capturing groups. Group zero always
    stands for the entire matched text.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获组按递增顺序编号，从数字一开始。Java 正则表达式支持最多 99 个捕获组。组零始终代表整个匹配文本。
- en: For nested capturing groups, group numbers are incremented with the appearance
    of the opening parenthesis from left to right.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套捕获组，组号从左到右根据开括号的出现在递增。
- en: 'To understand this better, let''s consider the following regular expression
    with nested multiple capturing groups:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们考虑以下具有嵌套多个捕获组的正则表达式：
- en: (((a|b)-(c|d))/(\d+))
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: (((a|b)-(c|d))/(\d+))
- en: 'It will match the input string as follows:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 它将按照以下方式匹配输入字符串：
- en: a-c/15
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: a-c/15
- en: a-d/99
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: a-d/99
- en: b-c/567
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: b-c/567
- en: b-d/1000
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: b-d/1000
- en: 'For the input string, a-c/15, we will get the following captured groups: **Group
    Num**'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入字符串 a-c/15，我们将得到以下捕获组：**组号**
- en: '**Captured Text**'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '**捕获文本**'
- en: '**Group 0**'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '**组 0**'
- en: a-c/15
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: a-c/15
- en: '**Group 1**'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '**组 1**'
- en: a-c/15
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: a-c/15
- en: '**Group 2**'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '**组 2**'
- en: a-c
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: a-c
- en: '**Group 3**'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '**组 3**'
- en: a
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: '**Group 4**'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '**组 4**'
- en: c
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: '**Group 5**'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '**组 5**'
- en: '15'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: Also note that in the case of repeated matches in a capturing group using a
    quantifier, it will capture the last matched text in the given group.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在捕获组中使用量词进行重复匹配的情况下，它将捕获给定组中的最后一个匹配文本。
- en: 'For example, consider the following regex:'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下正则表达式：
- en: (\w+\s+){3}
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: (\w+\s+){3}
- en: If the input text is around the word, then the captured group number one will
    contain word after the regex execution, even though it also matches around and
    the before completing the match with the last word.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入文本位于单词周围，那么捕获组号一将包含正则表达式执行后的单词，即使它也匹配周围，并且在完成与最后一个单词的匹配之前。
- en: '**Named groups**'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名组**'
- en: 'In Java regular expressions, capturing groups can be defined in two ways: 1\.
    Using numbers that get incremented automatically (as we discussed earlier).'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 正则表达式中，捕获组可以通过两种方式定义：1. 使用自动递增的数字（如我们之前讨论的）。
- en: 2\. Using names.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 使用名称。
- en: Starting from Java 7, the regular expressions API offers support for named capturing
    groups. Named capturing groups are especially useful where there are lots of capturing
    groups. If we have to insert a new group or remove an existing group, then the
    numerical order changes for every capturing group that comes after the new or
    removed group, thus requiring the updating of all those references.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 7 开始，正则表达式 API 提供了对命名捕获组的支持。命名捕获组在存在大量捕获组的情况下特别有用。如果我们需要插入新组或删除现有组，那么每个新或删除组之后的捕获组的数字顺序都会改变，因此需要更新所有这些引用。
- en: 'The syntax for defining a capturing group is as follows:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 定义捕获组的语法如下：
- en: (?<name>RE)
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: (?<name>RE)
- en: In the preceding line, RE is the pattern we are using for capturing a group.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，RE 是我们用于捕获组的模式。
- en: 'There are certain rules to specify a named group in Java: 1\. Names are case
    sensitive, so these are four different named capturing groups: (?<name>RE)'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中指定命名组有一些规则：1. 名称区分大小写，因此这四个命名捕获组是不同的：(?<name>RE)
- en: (?<Name>RE)
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: (?<Name>RE)
- en: (?<NAME>RE)
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: (?<NAME>RE)
- en: (?<naME>RE)
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: (?<naME>RE)
- en: '2\. A name must satisfy the following regular expression:'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 一个名称必须满足以下正则表达式：
- en: '[a-zA-Z][a-zA-Z0-9]*'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: '[a-zA-Z][a-zA-Z0-9]*'
- en: This means that the name must start with a letter and may contain letters or
    digits after the first position.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着名称必须以字母开头，并且第一个位置之后可以包含字母或数字。
- en: 3\. Names cannot be duplicate in Java regex.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 3. Java 正则表达式中的名称不能重复。
- en: Keep in mind that even when we use a name to define groups, the groups are still
    numbered as \1, \2, \3, and so on, and that these numbers can also be used in
    references.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使我们使用名称来定义组，组仍然按 \1、\2、\3 等顺序编号，并且这些数字也可以用于引用。
- en: 'For example, in the following regular expression, we are specifying four named
    groups, id, subject, score, and term, all separated by a colon: (?<id>\d+):(?<subject>[a-zA-Z]+):(?<score>\d+):(?<term>[A-Z]+)
    If matched with 123456:Science:97:II, then the following groups will be captured:
    Group " **id**": "123456"'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，在以下正则表达式中，我们指定了四个命名组，id、subject、score 和 term，它们通过冒号分隔：(?<id>\d+):(?<subject>[a-zA-Z]+):(?<score>\d+):(?<term>[A-Z]+)
    如果与 123456:Science:97:II 匹配，则以下组将被捕获：组 " **id**": "123456"'
- en: 'Group " **subject**": "Science"'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '组 " **subject**": "Science"'
- en: 'Group " **score**": "97"'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '组 " **score**": "97"'
- en: 'Group " **term**": "II"'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '组 " **term**": "II"'
- en: 'Group **1**: "123456"'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: '组 **1**: "123456"'
- en: 'Group **2**: "Science"'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '组 **2**: "Science"'
- en: 'Group **3**: "97"'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '组 **3**: "97"'
- en: 'Group **4**: "II"'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '组 **4**: "II"'
- en: '**Non-capturing groups**'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '**非捕获组**'
- en: There are cases while building regular expressions when we don't really want
    to capture any text but just want to group a subpattern to apply a boundary assertion
    or quantifier. This is the case for using non-capturing groups. We can mark a
    group as a non-capturing group by *adding a question mark and a colon* right after
    the opening parenthesis.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建正则表达式时，有时我们并不真的想捕获任何文本，而只是想分组一个子模式以应用边界断言或量词。这就是使用非捕获组的情况。我们可以通过在开括号后立即添加一个问号和一个冒号来标记一个组为非捕获组。
- en: Note that we can also place one or more mode modifiers between the question
    mark and the colon. The scope of the modifier used in this manner is only effective
    for that group.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以在问号和冒号之间放置一个或多个模式修改符。以这种方式使用的修改符的作用范围仅限于该组。
- en: 'For example, we can use a non-capturing group in our regex to match an even
    number of digits:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在我们的正则表达式中使用非捕获组来匹配偶数个数字：
- en: ^(?:\d{2})+$
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?:\d{2})+$
- en: Since we are not really interested in capturing any text from a matched string,
    it is a good choice to use a non-capturing group here.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们并不真的对从匹配的字符串中捕获任何文本感兴趣，因此在这里使用非捕获组是一个不错的选择。
- en: 'An example of a non-capturing group with the ignore case modifier is as follows:
    (?i:red|green|blue|white)'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有忽略大小写修改符的非捕获组示例如下：(?i:red|green|blue|white)
- en: Due to the presence of the i modifier, this capturing group will match all the
    alternations by ignoring the case. Thus, it may match red, RED, White, blue, Green,
    BluE, greeN, WHITE, and so on.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在i修改符，此捕获组将通过忽略大小写来匹配所有交替项。因此，它可以匹配red、RED、White、blue、Green、BluE、greeN、WHITE等等。
- en: 'There are major differences between the following three regular expression
    patterns: (?:abc)'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个正则表达式模式之间存在重大差异：(?:abc)
- en: (?mi:abc)
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: (?mi:abc)
- en: ((?:abc)?)
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: ((?:abc)?)
- en: In the first case, we define a non-capturing group with a pattern as abc.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们使用模式abc定义了一个非捕获组。
- en: In the second case, we define a non-capturing group with the m ( *multiline*)
    and i ( *ignore case*) modifiers. This allows the regex to match abc, ABC, Abc,
    or aBC.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们定义了一个带有m（**多行**）和i（**忽略大小写**）修改符的非捕获组。这允许正则表达式匹配abc、ABC、Abc或aBC。
- en: In the third case, we define an optional non-capturing group inside the capturing
    group that matches abc or an empty string in the captured group.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种情况下，我们在捕获组内定义了一个可选的非捕获组，该组匹配abc或捕获组中的空字符串。
- en: '**Advantages of non-capturing**'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '**非捕获组的优势**'
- en: '**groups**'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '**组**'
- en: A non-capturing group lets us use the grouping inside a regular expression without
    changing the numbers assigned to the back references (explained in the next section).
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 非捕获组允许我们在正则表达式中使用分组，而不改变分配给回溯引用的数字（在下一节中解释）。
- en: This can be very useful in building large and complex regular expressions.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构建大型和复杂的正则表达式时非常有用。
- en: Non-capturing groups also give us the flexibility to add or remove groups from
    a long regular expression with multiple groups. If we have to insert a new group
    or remove an existing group, then the numerical order changes for every group
    on the right-hand side of the new or removed group.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 非捕获组还使我们能够灵活地在具有多个组的长时间正则表达式中添加或删除组。如果我们必须插入一个新组或删除现有组，那么新或删除组右侧的每个组的数字顺序都会改变。
- en: Using a non-capturing group instead of a capturing group saves memory, as the
    regular expression engine doesn't need to store groups in buffers, thus optimizing
    the overall regex execution. It is recommended to mark each group as non-capturing
    when we do not want to extract a grouped substring or refer to them anywhere in
    the regular expression.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非捕获组代替捕获组可以节省内存，因为正则表达式引擎不需要在缓冲区中存储组，从而优化整体正则表达式执行。当我们不希望提取分组子串或在任何地方引用它们时，建议将每个组标记为非捕获组。
- en: '**Back references**'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '**回溯引用**'
- en: Back references provide a convenient way of matching a repeated character or
    repeated tokens in the input text. By using back references, the regular expression
    engine can match the **exact same text** as previously matched by a capturing
    group.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯引用提供了一种方便的方法来匹配输入文本中的重复字符或重复标记。通过使用回溯引用，正则表达式引擎可以匹配与之前由捕获组匹配的**完全相同的文本**。
- en: 'The syntax of a back reference is a backslash followed by a capturing group
    number, as shown in the following example:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯引用的语法是一个反斜杠后跟一个捕获组编号，如下例所示：
- en: \3
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: \3
- en: The preceding example is a back reference of the third capturing group.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例是第三个捕获组的回溯引用。
- en: In Java regular expressions, there can be up to 99 back references, each number
    referencing a captured group number.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 正则表达式中，可以有最多 99 个反向引用，每个数字引用一个捕获组编号。
- en: 'For example, if we need to match a two-digit number with the restriction that
    both digits must be the same, then we need to capture the first digit and then
    use a back reference for the first captured group, as follows:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们需要匹配一个两位数，且两个数字都必须相同，那么我们需要捕获第一个数字，然后使用第一个捕获组的反向引用，如下所示：
- en: ^(\d)\1$
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '`^(\d)\1$`'
- en: 'Now, this regex will match any of these strings: 11, 22, 55, and 88\.'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个正则表达式将匹配以下任何字符串：11，22，55 和 88。
- en: We can also use quantifiers after back references as we use them with capturing
    or non-capturing groups.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在反向引用后面使用量词，就像我们在捕获组或非捕获组中使用它们一样。
- en: 'For example, if we have to match a five-digit number with all the same digits,
    then we can use the following regex:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们必须匹配一个五位数，且所有数字都相同，那么我们可以使用以下正则表达式：
- en: ^(\d)\1{4}$
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '`^(\d)\1{4}$`'
- en: 'As an example, we want to create a regex that matches four pairs of digits,
    separated by the colon (:), dash (-), or slash (/) characters. We also require
    the digit pairs to be the same on the first and third positions, and likewise,
    they must also be the same on the second and fourth positions. For example, 12-45:12-45
    and 56/00:56-00 will be a matching string, but 57-13-58:13 will not, because 57
    in the first pair of digits is not the same as 58, which is the third pair of
    digits. We can write our regex as follows:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要创建一个匹配四个数字对的正则表达式，这些数字对由冒号（:）、破折号（-）或斜杠（/）字符分隔。我们还要求数字对在第一和第三位置相同，同样，它们在第二和第四位置也必须相同。例如，12-45:12-45
    和 56/00:56-00 将是一个匹配的字符串，但 57-13-58:13 不会匹配，因为第一对数字中的 57 与第三对数字中的 58 不相同。我们可以写出以下正则表达式：
- en: ^(\d{2})[:/-](\d{2})[:/-]\1[:/-]\2$
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '`^(\d{2})[:/-](\d{2})[:/-]\1[:/-]\2$'
- en: 'Let''s look at some more useful regular expressions using capturing groups
    and back references. Suppose we need to write a regular expression for two repeated
    words, separated by one or more non-word characters in between. We can write our
    regular expression as follows:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些使用捕获组和反向引用的更有用的正则表达式。假设我们需要编写一个正则表达式来匹配两个重复的单词，这两个单词之间由一个或多个非单词字符分隔。我们可以写出我们的正则表达式如下：
- en: ^(\w+)\W+\1$
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '`^(\w+)\W+\1$`'
- en: The back reference, \1, will make sure we match the exact same word as matched
    by the first capturing group in this regular expression.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 反向引用 \1 将确保我们匹配与这个正则表达式的第一个捕获组匹配的完全相同的单词。
- en: 'Next, we need to write a regular expression for quoted words. Words can be
    wrapped using single quotes or double quotes, but the mixing of quotes is not
    allowed. We can then write our regex as follows:'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个用于匹配引号内单词的正则表达式。单词可以用单引号或双引号括起来，但不能混合使用引号。然后我们可以写出我们的正则表达式如下：
- en: ^(['"])\w+\1$
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: '`^([''"])\w+\1$`'
- en: Here, this regex pattern matches and captures the opening single or double quote
    using a character class. On the other side of the word, we use the \1 back reference
    to ensure that the same quote is matched in the end.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，这个正则表达式模式匹配并捕获了单词开头的单引号或双引号，使用字符类。在单词的另一侧，我们使用 \1 反向引用来确保在结尾匹配相同的引号。
- en: Back references cannot be used inside a character class, as we learned earlier.
    There is no grouping inside a character class, and most of the special meta characters
    become just literals inside a character class.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 反向引用不能在字符类内部使用，正如我们之前所学的。字符类内部没有分组，并且大多数特殊元字符在字符类内部只是字面量。
- en: '**Back reference of a named**'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名组的反向引用**'
- en: '**group**'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '**group**'
- en: 'The syntax for the back reference of a named group is as follows:'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 命名组的反向引用语法如下：
- en: \k<group1>
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '`\k<group1>`'
- en: Here, group1 is the name of the named capturing group.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，group1 是命名捕获组的名称。
- en: 'For example, we can write our regular expression of repeating numbers, using
    a named group and named back reference, as follows:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用命名组和命名反向引用来编写我们的重复数字正则表达式，如下所示：
- en: ^(?<matchedDigits>\d+)\s+\k<matchedDigits>$
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '`^(?<matchedDigits>\d+)\s+\k<matchedDigits>$`'
- en: Here, we are defining a captured group called num to capture a number using
    the first, and then, we are using a back reference of the named group using \k<num>.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个名为 num 的捕获组，用于捕获一个数字，然后使用命名组的反向引用 \k<num>。
- en: This will match inputs such as 1234 1234 or 989 989\.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配类似于 1234 1234 或 989 989 的输入。
- en: 'Since the named capturing groups are numbered automatically as well, we can
    write the same regular expression as follows:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命名捕获组也会自动编号，我们可以写出相同的正则表达式如下：
- en: ^(?<num>\d+)\s+\1$
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: '`^(?<num>\d+)\s+\1$`'
- en: '**Replacement reference of a**'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '**a的替换引用**'
- en: '**named group**'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名组**'
- en: 'We haven''t yet discussed the Java API for regular expression replacement,
    but just for reference, it will be pertinent to discuss the syntax of a named
    group reference in a replacement string:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论Java的正则表达式替换API，但仅作为参考，讨论替换字符串中命名组引用的语法是相关的：
- en: '${group1}: This will be replaced in the resulting string by the matched content
    of the named captured group, group1'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '${group1}: 这将在结果字符串中由命名捕获组group1的匹配内容替换'
- en: '$1: This will be replaced in the resulting string by the matched content of
    the captured group number 1'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '$1: 这将在结果字符串中由捕获组编号1的匹配内容替换'
- en: 'Note that the double escaping of String while defining a Java regular expression
    should be applied here in defining named groups, named back references, and numbered
    back references. Thus, repeating the previous regular expressions used in Java
    code:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在定义Java正则表达式时，字符串的双重转义应该应用于此处，用于定义命名组、命名后引用和编号后引用。因此，重复在Java代码中使用的先前正则表达式：
- en: 'final String regex = "^(?<num>\\d+)\\s+\\k<num>$"; or using numbered back references:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: final String regex = "^(?<num>\\d+)\\s+\\k<num>$"; 或者使用编号后引用：
- en: final String regex = "^(\\d+)\\s+\\1$";
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: final String regex = "^(\\d+)\\s+\\1$";
- en: '**Forward references**'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '**前向引用**'
- en: Back reference is the term used when a capturing group is referenced after we
    capture it. Likewise, a forward reference is the term for referencing a group
    before capturing the text using a captured group. In other words, the forward
    reference refers to a capturing group that appears later in the regular expression
    pattern. Forward references are only useful if we use them inside a repeated group,
    since the regex engine will be able to resolve captured groups and populate the
    forward reference while repeating a match using quantifiers.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 后向引用是在我们捕获捕获组之后引用捕获组时使用的术语。同样，前向引用是在使用捕获组捕获文本之前引用组的术语。换句话说，前向引用是指正则表达式模式中出现较晚的捕获组。前向引用只有在我们在重复组内部使用它们时才有用，因为正则表达式引擎将能够在使用量词重复匹配时解析捕获组和填充前向引用。
- en: As with most modern languages, Java allows us to use the forward reference of
    the captured group. Forward reference is a fairly complex concept to understand
    in regex.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 如同大多数现代语言一样，Java允许我们使用捕获组的前向引用。前向引用是正则表达式中一个相当复杂的概念。
- en: 'Let''s consider an example regex to understand better:'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例正则表达式来更好地理解：
- en: ^(\d+)-(?:\2[\dA-Fa-f]{4}|(\d*\.?\d+:))+$
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: ^(\d+)-(?:\2[\dA-Fa-f]{4}|(\d*\.?\d+:))+$
- en: 'Here, in this pattern, you can see that we are using the group reference, \2,
    before defining the captured group number, 2, which comes later in the regex pattern
    as: (\d*\.?\d+:). For this reason, \2 is a forward reference instead of a backward
    reference.'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，你可以看到我们在定义捕获组编号2之前使用了组引用\2，该编号在正则表达式模式中稍后出现：（\d*\.?\d+:）。因此，\2是一个前向引用而不是后向引用。
- en: 'With the preceding regex, the following string matches:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的正则表达式，以下字符串匹配：
- en: '666-6.6:6.6:abcd3.3:'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '666-6.6:6.6:abcd3.3:'
- en: 'The string matches because in the first repetition of the non-captured group,
    the second captured group becomes 6.6: and this can be referenced later.'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串匹配，因为在非捕获组的第一次重复中，第二个捕获组变为6.6:，这可以在稍后引用。
- en: 'The following string also matches because the second captured group is overwritten
    each time it is matched:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字符串也匹配，因为每次匹配时第二个捕获组都会被覆盖：
- en: 666-3.3:5.5:5.5:abcd
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 666-3.3:5.5:5.5:abcd
- en: 'The first value that the second captured group captures is 3.3:, but it is
    overwritten by 5.5: later, and this is matched the third time when the first part
    of the alternatives matches in the non-capturing group.'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个捕获组捕获的第一个值是3.3:，但后来被5.5:覆盖，这是在非捕获组的第一个部分匹配时第三次匹配的。
- en: 'The following string, however, does not match, although the first capture of
    the second group will be the string, 3.3:, by the time it is required by the forward
    reference:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下字符串不匹配，尽管在需要前向引用时第二个组的第一次捕获将是字符串，3.3:：
- en: '666-3.3:abcd3.3:'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '666-3.3:abcd3.3:'
- en: Thus, as it is undefined, it does not match anything, not even the empty string.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于它是未定义的，它不会匹配任何内容，甚至不是空字符串。
- en: Therefore, the first part of the alternative group does not match, and at this
    point, the second half also does not match, thereby leading to a failed matching.
    This way, the captured group, in this case, never captures the string, 3.3:.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择组的第一个部分不匹配，此时第二个部分也不匹配，从而导致匹配失败。这样，捕获组，在这种情况下，永远不会捕获字符串，3.3:。
- en: To summarize this behavior, the forward reference does reference something that
    is defined in the regular expression later, but only when the expression has already
    been matched at least once.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这种行为，前引用确实引用了在正则表达式后面定义的内容，但仅当表达式已经至少匹配一次时。
- en: For this reason, there is no point in using a forward reference outside some
    repeated
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在某个重复构造作为交替匹配的一部分之外使用前引用是没有意义的。
- en: construct as a part of one member of an alternative matching.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 作为交替匹配的一个成员的一部分。
- en: 'Similarly, in the following example, the regex pattern uses a forward reference:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在以下示例中，正则表达式模式使用了一个前引用：
- en: ^(?:\1#color|(red|blue|white))+$
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: ^(?:\1#color|(red|blue|white))+$
- en: This anchored regex uses the **forward reference**, \1, before matching the
    literal text,
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 这个锚定正则表达式在匹配文本之前使用了**前引用**，\1，
- en: '#color, on the left-hand side of the alternation. On the right-hand side of
    the alternation, it matches one of the given colors and captures it in the first
    capturing group. The entire alternation has the + quantifier after to make repeated
    matches.'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '#color，在交替表达式的左侧。在交替表达式的右侧，它匹配给定的颜色之一并将其捕获在第一个捕获组中。整个交替表达式在后面跟有+量词，以进行重复匹配。'
- en: In the first attempt, \1 fails the match and forces the regex engine to attempt
    the right-hand side of the alternation and match a color to populate \1 with the
    matching color.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次尝试中，\1失败匹配并迫使正则表达式引擎尝试交替的右侧并匹配一个颜色，用匹配的颜色填充\1。
- en: 'If there is any text left to be matched in the input, the regex engine, in
    the second attempt, matches the now populated reference, \1, followed by #color
    as the first alternation or an allowed color as the second alternation. This process
    is repeated until the regex engine either matches the complete string or fails
    the match.'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入中还有任何文本需要匹配，正则表达式引擎在第二次尝试中，将匹配现在已填充的引用\1，后跟#color作为第一个交替或允许的颜色作为第二个交替。这个过程会重复进行，直到正则表达式引擎要么匹配整个字符串，要么失败匹配。
- en: 'This will match any of the following strings:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配以下任何字符串：
- en: blue
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: blue
- en: redblue
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: redblue
- en: blueblueblue
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: blueblueblue
- en: redbluewhite
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: redbluewhite
- en: redred#color
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: redred#color
- en: whitewhite#color
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: whitewhite#color
- en: blueredred#color
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: blueredred#color
- en: 'However, it won''t match the following strings:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它不会匹配以下字符串：
- en: '#color'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: '#color'
- en: red#color
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: red#color
- en: bluered#color
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: bluered#color
- en: redbluefruit
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: redbluefruit
- en: redbluered#color
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: redbluered#color
- en: '**Invalid (non-existing)**'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '**无效（不存在）**'
- en: '**backward or forward**'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '**向后或向前**'
- en: '**references**'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考文献**'
- en: The Java regular expression engine handles back references to non-existing groups
    in the same manner as back references to existing groups. Invalid or non-existing
    back references do not participate in the match. This means that a regular expression
    with an invalid back reference always fails, although it does not cause any exception.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: Java正则表达式引擎以与现有组相同的方式处理对不存在组的后引用。无效或不存在的前引用不参与匹配。这意味着具有无效前引用的正则表达式总是失败，尽管它不会引发任何异常。
- en: 'For example, consider the following regex example:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下正则表达式示例：
- en: (apple|orange|banana)\2
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: (apple|orange|banana)\2
- en: The \2 back reference will be invalid because there is only one capturing group
    in this regular expression. Hence, the back reference of \2 always makes it a
    failed match against any input.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: \2后引用将是无效的，因为在这个正则表达式中只有一个捕获组。因此，\2的后引用总是使它对任何输入都成为失败的匹配。
- en: 'The same happens even when we have a regex pattern as follows:'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 即使当我们有一个如下正则表达式模式时，同样会发生这种情况：
- en: \1
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: \1
- en: Due to a similar rule, it will fail to match an empty string as well.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类似的规则，它也会失败匹配空字符串。
- en: '**Summary**'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how to capture and reference substrings from an
    input text using regular expressions. Using non-capturing groups, we discussed
    how to optimize our regex patterns. We discussed the various types of groups available
    in Java regular expressions, the numbering of captured groups, and named groups.
    You also learned how to use back reference and forward reference of the capturing
    groups using numbered and named references. In the next chapter, you will get
    to writing code in Java to evaluate regular expressions. You will also be introduced
    to Java regular expressions using the Java String API, and then, we will move
    on to regex capabilities in the Java Scanner API.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用正则表达式从输入文本中捕获和引用子字符串。我们讨论了如何使用非捕获组来优化我们的正则表达式模式。我们讨论了Java正则表达式中的各种组类型、捕获组的编号和命名组。你还学习了如何使用编号和命名的引用来使用捕获组的后向和前向引用。在下一章中，你将学习如何在Java中编写代码来评估正则表达式。你还将通过Java
    String API了解Java正则表达式，然后我们将继续讨论Java Scanner API中的正则表达式功能。
- en: '**Regular Expression**'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**'
- en: '**Programming Using Java**'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Java编程**'
- en: '**String and Scanner APIs**'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: '**String和Scanner API**'
- en: In this chapter, you will be introduced to Java regular expressions using Java
    String methods and we will move on to regular expression capabilities in Java
    Scanner API.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过Java String方法了解Java正则表达式，然后我们将继续讨论Java Scanner API中的正则表达式功能。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Java String methods that use regular expressions
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式的Java String方法
- en: What these methods are used for and how to use them
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的使用目的以及如何使用它们
- en: The use of regular expressions in Java Scanner
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: Java Scanner中正则表达式的使用
- en: So far, we have covered many theoretical concepts of writing regular expressions
    in depth. The time has now come to see some of these regular expressions in action.
    We are going to introduce you to Java programs evaluating these regular expressions
    using the java.lang.String and java.util.Scanner APIs.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经深入探讨了编写正则表达式的许多理论概念。现在是时候看看一些正则表达式在实际中的应用了。我们将介绍使用java.lang.String和java.util.Scanner
    API评估这些正则表达式的Java程序。
- en: '**Introduction to the Java**'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java简介**'
- en: '**String API for regular**'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式String API**'
- en: '**expressions'' evaluation**'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式评估**'
- en: 'The Java String API provides some useful methods to evaluate regular expressions
    against a text represented by the String object. Let''s list those methods from
    the String class:'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: Java String API为使用String对象表示的文本提供了一些有用的方法来评估正则表达式。以下是String类中的这些方法：
- en: Method Signature
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名
- en: Purpose
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 目的
- en: boolean
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: boolean
- en: Matches the given regular expression against the string that matches(String
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 与匹配给定正则表达式的字符串匹配(String
- en: the method is invoked on and returns true/false, indicating regex)
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法的对象并返回true/false，表示正则表达式)
- en: whether the match is successful (true) or not (false).
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是否成功（true）或未成功（false）。
- en: String
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: String
- en: Replaces each substring of the subject string that matches the replaceAll(String
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 替换主体字符串中与匹配的每个子字符串replaceAll(String
- en: given regular expression with the replacement string and
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 给定正则表达式和替换字符串，并
- en: regex, String
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式，String
- en: returns the new string with the replaced content.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 返回带有替换内容的新字符串。
- en: replacement)
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: replacement)
- en: This method does the same as the previous one with the
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与上一个方法相同，使用
- en: String
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: String
- en: exception that it replaces only the first substring of the replaceFirst(String
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是它只替换第一个子字符串replaceFirst(String
- en: subject string that matches the given regular expression with regex, String
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式与给定的正则表达式匹配的字符串主体，String
- en: the replacement string and returns the new string with the replacement)
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字符串并返回带有替换内容的新字符串)
- en: replaced content.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 替换内容。
- en: String[]
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: String[]
- en: Splits the subject string using the given regular expression split(String regex)
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的正则表达式拆分主体字符串split(String regex)
- en: into an array of substrings (example given ahead).
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 到一个子字符串数组中（以下给出示例）。
- en: This overloaded method does the same as the previous one
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 此重载方法与上一个方法相同
- en: String[]
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: String[]
- en: split(String regex,
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: split(String regex,
- en: but there is an additional second parameter. The limit
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一个额外的第二个参数。限制
- en: int limit)
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: int limit)
- en: parameter controls the number of times regular expressions are applied for splitting.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 参数控制正则表达式在拆分中应用的次数。
- en: '[For the complete reference of the String class, refer to https://docs.oracle.com/javase/8/docs/](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于 String 类的完整参考，请参阅 https://docs.oracle.com/javase/8/docs/](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)'
- en: '[api/java/lang/String.html.](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: '[api/java/lang/String.html.](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)'
- en: '**Method - boolean**'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 - boolean**'
- en: '**matches(String regex)**'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: '**matches(String regex)**'
- en: 'This method attempts to match a given regular expression against the complete
    subject String and returns **true**/**false**, indicating whether the match is
    successful or not. The following are a few important points to note:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法尝试将给定的正则表达式与整个主题字符串进行匹配，并返回 **true**/**false**，表示匹配是否成功。以下是一些需要注意的重要点：
- en: Regular expression is applied against the entire String; there is no partial
    matching
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式应用于整个字符串；没有部分匹配
- en: Regular expression does not need to be anchored using ^ and $, since it is matched
    against the entire input
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不需要使用 ^ 和 $ 锚定，因为它是对整个输入进行匹配
- en: The equivalent of Pattern.matches(**String regex**, CharSequence**input**) method
    (will be covered later)
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: Pattern.matches(**String regex**, CharSequence**input**) 方法的等效（将在后面介绍）
- en: '**Example of the matches**'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '**matches 方法示例**'
- en: '**method**'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**'
- en: Let's look at a few examples to understand this method better.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个示例来更好地理解此方法。
- en: 'The following code snippet using the matches method will return false:'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 matches 方法编写的以下代码片段将返回 false：
- en: '"1234".matches("\\d");'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '"1234".matches("\\d");'
- en: 'It is because the matches method attempts to apply a given regex against the
    entire input and effectively runs this code as:'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 matches 方法尝试将给定的正则表达式应用于整个输入，并有效地运行以下代码：
- en: '"1234".matches("^\\d$");'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '"1234".matches("^\\d$");'
- en: This will obviously fail as we have three digits in the input, not just one.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然会失败，因为我们输入中有三个数字，而不仅仅是单个数字。
- en: 'The code that matches the string "1234" and the call to the matches()method
    that returns true will use the quantifier + or * after \\d. Therefore, the following
    two method calls will return true:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配字符串 "1234" 并调用返回 true 的 matches() 方法的代码将在 \\d 后使用 + 或 * 量词。因此，以下两个方法调用将返回
    true：
- en: '"1234".matches("\\d+");'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '"1234".matches("\\d+");'
- en: '"1234".matches("\\d+");'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '"1234".matches("\\d+");'
- en: 'To validate a given string that contains the colors **red**, **blue,** or **green**,
    we shall use this code listing:'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证包含颜色 **red**、**blue** 或 **green** 的给定字符串，我们将使用以下代码：
- en: package example.regex;
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: public class StringMatches
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: public class StringMatches
- en: '{'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: boolean result;
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: boolean result;
- en: String regex;
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: String regex;
- en: String input = "Sky is blue"; // First regex regex = "\\b(red|blue|green)\\b";
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: String input = "Sky is blue"; // 第一个正则表达式 regex = "\\b(red|blue|green)\\b";
- en: result = input.matches(regex);
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: result = input.matches(regex);
- en: 'System.out.printf("Match result: %s%n", result);'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("匹配结果: %s%n", result);'
- en: // prints false
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印 false
- en: // Second regex
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: // 第二个正则表达式
- en: regex = ".*\\b(red|blue|green)\\b.*";
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: regex = ".*\\b(red|blue|green)\\b.*";
- en: result = input.matches(regex);
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: result = input.matches(regex);
- en: 'System.out.printf("Match result: %s%n", result);'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("匹配结果: %s%n", result);'
- en: // prints true
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印 true
- en: '}'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'A few points about this regex are as follows:'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此正则表达式的一些要点如下：
- en: Alternation (**red**|**blue**|**green**) is being used to match any of the allowed
    colors The first regex fails to match because we are only matching the allowed
    colors using alternation but are not matching the text on either side of the alternation
    The second regex succeeds as we are using . ***** on both sides of the alternation
    to match any text before and after the allowed colors in the input text We are
    also using the word, **boundary assertions**, around our alternation expression
    to ensure that we match complete words only
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交替（**red**|**blue**|**green**）来匹配任何允许的颜色。第一个正则表达式未能匹配，因为我们只是使用交替匹配允许的颜色，但没有匹配交替两边的文本。第二个正则表达式成功，因为我们使用
    . ***** 在交替的两边来匹配输入文本中允许颜色之前和之后的任何文本。我们还在交替表达式周围使用 **边界断言**，以确保只匹配完整的单词
- en: 'To verify that the given input starts and ends with an English letter while
    allowing digits, letters, underscores, and hyphens in the middle, we can use the
    following regular expression in the matches() method:'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证给定的输入以英语字母开头和结尾，同时允许中间有数字、字母、下划线和连字符，我们可以在 matches() 方法中使用以下正则表达式：
- en: 'input.matches("[a-zA-Z][a-zA-Z0-9_-]*[a-zA-Z]"); Else, we can also use the
    predefined class, \w:'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 'input.matches("[a-zA-Z][a-zA-Z0-9_-]*[a-zA-Z]"); 否则，我们还可以使用预定义的类，\w:'
- en: input.matches("[a-zA-Z][\w-]*[a-zA-Z]");
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: input.matches("[a-zA-Z][\\w-]*[a-zA-Z]");
- en: 'In addition, we can use the modifier, (?i):'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用修饰符，(?i)：
- en: input.matches("(?i)[a-z][\w-]*[a-z]");
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: input.matches("(?i)[a-z][\\w-]*[a-z]");
- en: 'To verify that the input contains six to nine digits, use the following: input.matches("\\d{6,9}");'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证输入是否包含六到九位数字，可以使用以下方法：input.matches("\\d{6,9}");
- en: '![Image 13](img/index-96_1.jpg)'
  id: totrans-1513
  prefs: []
  type: TYPE_IMG
  zh: '![Image 13](img/index-96_1.jpg)'
- en: '**Method - String**'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 - String**'
- en: '**replaceAll(String regex,**'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '**replaceAll(String regex,**）'
- en: '**String replacement)**'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '**String 替换**）'
- en: This method replaces each substring of the subject string that matches the given
    regular expression with the replacement String. As the name implies, replaceAll
    replaces all the matching occurrences of the input String. Note that we can also
    supply a simple String containing no regex meta character in the first argument.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将主题字符串中与给定正则表达式匹配的每个子字符串替换为替换字符串。正如其名所示，replaceAll 替换输入字符串中所有匹配的实例。请注意，我们还可以在第一个参数中提供一个不包含正则表达式元字符的简单字符串。
- en: 'Calling this method is equivalent to a call to the following: Pattern.compile(regex).matcher(input).replaceAll(replacement);'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法相当于调用以下方法：Pattern.compile(regex).matcher(input).replaceAll(replacement);
- en: '***Note**: We will cover Pattern and Matcher APIs in [Chapter 5](index_split_001.html#p111)*
    *,* *Introduction to Java Regular Expression APIs - Pattern and Matcher* *Classes.*'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: '***注意**：我们将在第 5 章[Pattern 和 Matcher API](index_split_001.html#p111)中介绍 Pattern
    和 Matcher API* *—— Java 正则表达式 API 的介绍 - Pattern 和 Matcher 类* *。'
- en: 'The replacement string allows the use of references to substrings, represented
    by the captured groups used in the regular expression. These references can be
    of two types: **Numbered references**: These are written as $n, where n is a number,
    such as $1, $2, and $3, which represent a reference to each of the captured groups
    in the regular expression'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字符串允许使用对子字符串的引用，这些引用由正则表达式中使用的捕获组表示。这些引用可以是两种类型之一：**编号引用**：这些以 $n 的形式书写，其中
    n 是一个数字，例如 $1, $2, $3，它们代表对正则表达式中每个捕获组的引用
- en: '**Named references**: These are written as ${groupName}, where groupName is
    the name of the captured group in the regular expression'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名引用**：这些以 ${groupName} 的形式书写，其中 groupName 是正则表达式中捕获组的名称'
- en: To place a literal dollar or literal backslash in the replacement string, we
    need to escape these characters using double backslash (\\).
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 要在替换字符串中放置字面量美元符号或字面量反斜杠，我们需要使用双反斜杠（\\）来转义这些字符。
- en: Here, at this point, you should understand the difference between back-reference
    and replacement reference. Back-reference is used in the regular expression pattern
    itself and is written as **\1,\2,\3**, and so on for a numbered group's back-reference
    and
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在这个点上，你应该理解反向引用和替换引用之间的区别。反向引用用于正则表达式模式本身，并写成 **\1,\2,\3**，等等，用于编号组的反向引用
- en: '**\k<groupName>** for a named group''s back-reference. However, replacement
    reference is either written as **$1, $2, $3**, for a numbered group''s reference
    or **${groupName}** for a named group''s reference.'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '**\k<groupName>** 用于命名组的反向引用。然而，替换引用要么以 **$1, $2, $3** 的形式书写，用于编号组的引用，要么以 **${groupName}**
    的形式书写，用于命名组的引用。'
- en: '**Examples of the replaceAll**'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '**replaceAll 的示例**'
- en: '**method**'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**'
- en: 'To replace all the semi-colons with hyphens, we can use the following: input
    = input.replaceAll(";", "-");'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所有分号替换为破折号，可以使用以下方法：input = input.replaceAll(";", "-");
- en: 'To remove all the non-digits from the input, we can use:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 要从输入中删除所有非数字字符，可以使用：
- en: input = input.replace("\\D+", "");
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: input = input.replace("\\D+", "");
- en: 'To replace all the leading and trailing commas from an input, we can use an
    alternation regex:'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换输入中的所有前导和尾随逗号，我们可以使用交替正则表达式：
- en: 'input = input.replaceAll("^,+|,+$", ""); To replace all the occurrences of
    two or more white spaces with a single space, we can use:'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: input = input.replaceAll("^,+|,+$", ""); 要替换所有两个或多个空白字符为单个空格，可以使用：
- en: input = input.replaceAll("\\s{2,}, " ");
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: input = input.replaceAll("\\s{2,}, " ");
- en: 'How can we escape all the dollar signs that are just before the % character?
    In other words, to replace all the occurrences of $% with \$%, we can use: input
    = input.replaceAll("\\$%", "\\\\\\$%"); Note that we are using \\\\ (four backslashes)
    to enter a single \, and we''re using \\$'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何转义所有位于 % 字符之前的美元符号？换句话说，要替换所有 $% 的出现，我们可以使用：input = input.replaceAll("\\$%",
    "\\\\\\$%"); 注意，我们使用 \\\\（四个反斜杠）来输入单个 \，并且我们使用 \\
- en: to enter a single $ in the replacement, whereas % will just be a literal.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 要在替换中输入单个 $，而 % 将只是一个字面量。
- en: 'Consider the following input:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下输入：
- en: $200 $%apple% $%banana% $%orange%
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: $200 $%apple% $%banana% $%orange%
- en: 'It will be converted into this:'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被转换为：
- en: $200 \$%apple% \$%banana} \${orange}
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: $200 \$%apple% \$%banana} \${orange}
- en: 'We can also leverage the group reference $0 here, which is populated with the
    entire matched text using a regex. So, our code can be simplified to this as $0
    will refer to the matched text $% by our regex:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用这里的组引用$0，它使用正则表达式填充了整个匹配文本。因此，我们的代码可以简化为如下，因为$0将引用正则表达式中的匹配文本$%：
- en: 'input = input.replaceAll("\\$%", "\\\\$0"); Another nice trick we can use here
    is to use the static method, Matcher.quoteReplacement that is in the Matcher API.
    This method handles all the special characters in a replacement string and escapes
    them appropriately. Now, our code can become this: input = input.replaceAll("\\$%",
    Matcher.quoteReplacement("\\") + "$0"); Let''s solve an interesting problem. We
    need to replace all the multiple occurrences of non-word characters with a single
    instance of the same character.'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: input = input.replaceAll("\\$%", "\\\\$0"); 另一个我们可以使用的技巧是，在Matcher API中使用静态方法Matcher.quoteReplacement。此方法处理替换字符串中的所有特殊字符，并适当地转义它们。现在，我们的代码可以变成这样：input
    = input.replaceAll("\\$%", Matcher.quoteReplacement("\\") + "$0"); 让我们解决一个有趣的问题。我们需要将所有非单词字符的多个出现替换为该字符的单个实例。
- en: 'Consider the following input text:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下输入文本：
- en: 'Let''''''''''''s learn::: how to write cool regex...'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习：如何编写酷炫的正则表达式...
- en: 'The expected output is:'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出是：
- en: 'Let''s learn: how to write cool regex.'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习：如何编写酷炫的正则表达式。
- en: Note that we are replacing multiple occurrences of non-word characters only
    and not replacing multiple occurrences of word characters.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只替换非单词字符的多个出现，而不是单词字符的多个出现。
- en: 'Here is the code listing to solve this problem:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决这个问题的代码列表：
- en: package example.regex;
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: public class StringReplaceAll
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: public class StringReplaceAll
- en: '{'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main(String[] args)
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // our input string
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: // 我们输入的字符串
- en: 'String input = "Let''''''''''''s learn::: how to write cool regex...";'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 'String input = "Let''''''''''''s learn::: how to write cool regex...";'
- en: // call replaceAll and assign replaced string to same variable input = input.replaceAll("(\\W)\\1+",
    "$1");
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用replaceAll并将替换后的字符串赋值给相同的变量 input = input.replaceAll("(\\W)\\1+", "$1");
- en: // print the result
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: // 打印结果
- en: 'System.out.printf("Replaced result: %s%n", input);'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.printf("替换后的结果: %s%n", input);'
- en: '}'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Here are a few points about this solution:'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个解决方案的几点说明：
- en: We are using the predefined class, \W, to match a non-word character We are
    using a capturing group around the non-word character to be able to use a back-reference
    later in the regex and in the replacement The pattern, (\\W)\\1+, is used to match
    two or more occurrences of the same non-word character
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用预定义的类\W来匹配非单词字符。我们围绕要稍后在正则表达式和替换中使用回溯引用的非单词字符使用捕获组。模式(\\W)\\1+用于匹配相同非单词字符的两个或多个出现
- en: \1 represents the back-reference to the first captured group In the replacement,
    we are using the reference, $1, to place the captured non-word character back
    in the replaced string
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: \1代表对第一个捕获组的回溯引用。在替换中，我们使用引用$1将捕获的非单词字符放回替换后的字符串中
- en: $1 represents the reference to the first captured group
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: $1代表第一个捕获组的引用
- en: 'Using the named group directives that you learnt in the previous chapter, we
    can also write the replaceAll method call as follows:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在上一章中学到的命名组指令，我们也可以将replaceAll方法的调用写成如下形式：
- en: input = input.replaceAll("(?<nwchar>\\W)\\k<nwchar>+", "${nwchar}");
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: input = input.replaceAll("(?<nwchar>\\W)\\k<nwchar>+", "${nwchar}");
- en: '![Image 14](img/index-99_1.jpg)'
  id: totrans-1565
  prefs: []
  type: TYPE_IMG
  zh: '![图像 14](img/index-99_1.jpg)'
- en: '**Method - String**'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 - 字符串**'
- en: '**replaceFirst(String regex,**'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '**replaceFirst(String regex,**）'
- en: '**String replacement)**'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串替换**）'
- en: This method replaces the first substring of the subject string, which matches
    the given regular expression with the replacement String. As the name implies,
    replaceFirst replaces only the first matching occurrence of the input String.
    Note that we can also supply a simple String containing no regex meta character
    in the first argument as regex.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法替换主字符串中与给定正则表达式匹配的第一个子字符串，并用替换字符串替换。正如其名所示，replaceFirst只替换输入字符串的第一个匹配项。请注意，我们也可以在第一个参数中提供一个不包含正则表达式元字符的简单字符串作为正则表达式。
- en: 'Calling this method is equivalent to the following call:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法等同于以下调用：
- en: 'Pattern.compile(regex).matcher(input).replaceFirst(replacement); *Note: We
    will cover the Pattern and Matcher APIs in later chapters.*'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: Pattern.compile(regex).matcher(input).replaceFirst(replacement); *注意：我们将在后面的章节中介绍Pattern和Matcher
    API。*
- en: A replacement string allows the use of group references, such as $1, $2, $3,
    and so on, for numbered references or ${groupName} for named references, which
    represent each of the captured groups in the regular expressions. To place a literal
    dollar or a literal backslash in the replacement, we need to escape these characters
    using the double backslash.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字符串允许使用组引用，例如 $1, $2, $3 等，用于编号引用，或者使用 ${groupName} 用于命名引用，这些引用代表正则表达式中的每个捕获组。要在替换中放置字面美元符号或字面反斜杠，我们需要使用双反斜杠来转义这些字符。
- en: '**Examples of the replaceFirst**'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: '**replaceFirst 的示例**'
- en: '**method**'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**'
- en: 'To replace *only the first* semi-colon with a hyphen, we can use the following:
    input = input.replaceFirst(";", "-"); What will be the output if we have to use
    the replaceFirst method instead of replaceAll in the input text of "$%apple% $%banana%
    $%orange%" for escaping the dollar signs?'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 要只替换第一个分号为连字符，我们可以使用以下代码：input = input.replaceFirst(";", "-"); 如果我们必须在输入文本 "$%apple%
    $%banana% $%orange%" 中使用 replaceFirst 方法而不是 replaceAll 来转义美元符号，输出将会是什么？
- en: 'The code will become as follows:'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: 'input = input.replaceFirst("\\$", "\\\\\\$"); It will replace only the first
    $ sign; hence, the output will only have the first $ escaped as follows:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: input = input.replaceFirst("\\$", "\\\\\\$"); 它将只替换第一个美元符号；因此，输出将只将第一个美元符号转义如下：
- en: \$%apple% $%banana% $%orange%
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: \$%apple% $%banana% $%orange%
- en: 'To replace the first dot of an IPV4 IP address with a colon, we can use the
    following code:'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 要将IPv4 IP地址的第一个点替换为冒号，我们可以使用以下代码：
- en: String newip = ipaddress.replaceFirst("\\.", ":"); Only the first dot will be
    replaced by a colon; hence, an IP value of 10.11.22.123 will become 10:11.22.123\.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 'String newip = ipaddress.replaceFirst("\\.", ":"); 只会将第一个点替换为冒号；因此，IP 值 10.11.22.123
    将变为 10:11.22.123\. '
- en: '**Methods - String split**'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法 - String split**'
- en: '**methods**'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**'
- en: 'The String class has two split methods with the following signatures: String[]
    split(String regex, int limit)'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: String 类有两个 split 方法，其签名如下：String[] split(String regex, int limit)
- en: String[] split(String regex)
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: String[] split(String regex)
- en: These split methods split the subject string into an array around the matches
    of the given regular expression, also called delimiters.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分割方法将主题字符串分割成一个数组，围绕给定的正则表达式匹配项，也称为分隔符。
- en: When there is a *positive width* match at the beginning of an input string,
    then an empty string is included at the beginning of the resulting array. However,
    a match of *zero width* by regular expression does not include any empty string
    at the beginning of the resulting array.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入字符串的开头存在 *正宽度* 匹配时，结果数组的开头将包含一个空字符串。然而，正则表达式的 *零宽度* 匹配不会在结果数组的开头包含任何空字符串。
- en: 'The array returned by this method contains a combination of the following elements:
    Token substrings that are split by the delimiter, matched using the given regular
    expression'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回的数组包含以下元素的组合：由分隔符分割的标记子字符串，使用给定的正则表达式匹配
- en: Input substring beyond the last match of the delimiter, using the given regular
    expression
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的正则表达式输入分隔符之后的子字符串
- en: A leading empty string when there is a *positive width* delimiter Trailing empty
    strings (see the next subsection on the limit parameter) When splitting regular
    a expression does not match any part of the input, the resulting array will just
    have a single element, that is, the complete input string.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在 *正宽度* 分隔符时，会有一个前导空字符串。当分割正则表达式不匹配输入的任何部分时，结果数组将只有一个元素，即完整的输入字符串。
- en: 'split(String regex) is just an overloaded method with the same functionality
    that calls the two-argument split method with the limit parameter as zero, thus
    making a call as: split(regex, 0)'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: split(String regex) 是一个具有相同功能的方法，它调用具有限制参数的两个参数分割方法，该参数为零，因此调用如下：split(regex,
    0)
- en: '**The limit parameter rules**'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制参数规则**'
- en: 'The limit parameter controls the number of times the regular expression pattern
    is applied for splitting the subject string. It affects the length of the resulting
    array with the following rules:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 限制参数控制正则表达式模式在分割主题字符串时应用的次数。它影响结果数组的长度，以下是一些规则：
- en: 1\. If the limit is greater than 0, then the pattern will be applied at most
    one time, the resulting array's length will not be greater than the limit, and
    the array's last entry will contain all input substrings beyond the last matched
    delimiter.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 如果限制大于 0，则模式最多应用一次，结果数组的长度不会超过限制，并且数组的最后一个条目将包含所有输入子字符串，这些子字符串在最后一个匹配的分隔符之后。
- en: 2\. If the limit is negative, then the pattern will be applied as many times
    as possible, and the resulting array can have any length.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果限制为负数，则模式将被尽可能多次应用，并且结果数组可以具有任何长度。
- en: 3\. If the limit is zero (as in the single parameter split method call), then
    the pattern will be applied as many times as possible, the array can have any
    length, and **trailing empty strings will be discarded**.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果限制为零（如在单参数split方法调用中），则模式将被尽可能多次应用，数组可以具有任何长度，并且**尾随空字符串将被丢弃**。
- en: '**Examples of the split method**'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '**split方法的示例**'
- en: 'Let''s look at the following code listing, which splits the subject string
    on each occurrence of a hyphen:'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码列表，它根据每个连字符拆分主题字符串：
- en: package example.regex;
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: package example.regex;
- en: import java.util.*;
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 导入java.util.*;
- en: class StringSplit
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: class StringSplit
- en: '{'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public static void main (String[] args)
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main (String[] args)
- en: '{'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: final String input = "green-red-blue-yellow";
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: final String input = "green-red-blue-yellow";
- en: Arrays.stream(input.split("-"))
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.stream(input.split("-"))
- en: .forEach(System.out::println);
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::println);
- en: '}'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This will generate the following output:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '"green"'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: '"green"'
- en: '"red"'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: '"red"'
- en: '"blue"'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '"blue"'
- en: '"yellow"'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: '"yellow"'
- en: 'Now, let''s change our code to the following by splitting on each occurrence
    of the letter e:'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将代码更改为以下内容，通过在每个字母e的出现处进行拆分：
- en: Arrays.stream(input.split("e"))
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.stream(input.split("e"))
- en: .forEach(System.out::println);
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::println);
- en: 'The preceding code will generate the following output:'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下输出：
- en: '"gr"'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: '"gr"'
- en: '""'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: '""'
- en: '"n-r"'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '"n-r"'
- en: '"d-blu"'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: '"d-blu"'
- en: '"-y"'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: '"-y"'
- en: '"llow"'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: '"llow"'
- en: We got one empty result because we split on each e and there are two e letters
    in green, thus giving us an empty string between the two e letters.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个空的结果，因为我们根据每个e进行拆分，绿色中有两个e字母，因此在这两个e字母之间得到一个空字符串。
- en: 'Now, let''s change our code to the following by splitting on one or more occurrences
    of e:'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过拆分一个或多个e的出现来更改我们的代码：
- en: Arrays.stream(input.split("e+"))
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.stream(input.split("e+"))
- en: .forEach(System.out::println);
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::println);
- en: 'We will get the following output:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '"gr"'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '"gr"'
- en: '"n-r"'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: '"n-r"'
- en: '"d-blu"'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '"d-blu"'
- en: '"-y"'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: '"-y"'
- en: '"llow"'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: '"llow"'
- en: We did not get any empty results now because we split on each e+ and the two
    e letters in green are matched in a single match.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们没有得到任何空的结果，因为我们根据每个e+进行拆分，绿色中的两个e字母在单个匹配中匹配。
- en: '**Example of the split method**'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: '**split方法的示例**'
- en: '**using the limit parameter**'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用limit参数**'
- en: 'To understand the impact of the limit parameter, let''s take a comma-separated
    input string with two trailing commas:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解limit参数的影响，让我们考虑一个以逗号分隔的输入字符串，有两个尾随逗号：
- en: fox,tiger,wolf,,
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: fox,tiger,wolf,,
- en: 'We can call the split method in two ways. We can call the split method with
    limit=0: String[] arr = input.split(",", 0);'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式调用split方法。我们可以使用limit=0调用split方法：String[] arr = input.split(",", 0);
- en: 'We can also call the single parameter split method call as: String[] arr =
    input.split(",");'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将单参数split方法调用称为：String[] arr = input.split(",");
- en: 'It splits the input string around a comma and the trailing empty strings are
    discarded, with the following values being returned by the split method:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 它在逗号周围拆分输入字符串，并且丢弃尾随空字符串，split方法返回以下值：
- en: '"fox"'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: '"fox"'
- en: '"tiger"'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: '"tiger"'
- en: '"wolf"'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: '"wolf"'
- en: 'Now, let''s call the split method with limit=1:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用limit=1调用split方法：
- en: String[] arr = input.split(",", 1);
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr = input.split(",", 1);
- en: 'It splits the input string around a comma and then gets a single element in
    the resulting array, that is, the input string itself. The following value is
    returned by the split method:'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 它在逗号周围拆分输入字符串，然后得到结果数组中的一个元素，即输入字符串本身。split方法返回以下值：
- en: '"fox,tiger,wolf,,"'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: '"fox,tiger,wolf,,"'
- en: 'Let''s call the split method with limit=2:'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用limit=2调用split方法：
- en: String[] arr = input.split(",", 2);
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr = input.split(",", 2);
- en: 'It splits the input string around a comma and then gets exactly two elements
    in the resulting array. The following two values are returned by the split method:'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 它在逗号周围拆分输入字符串，然后得到结果数组中的两个元素。split方法返回以下两个值：
- en: '"fox"'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: '"fox"'
- en: '"tiger,wolf,,"'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '"tiger,wolf,,"'
- en: 'Let''s call the split method with limit=3:'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用limit=3调用split方法：
- en: String[] arr = input.split(",", 3);
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr = input.split(",", 3);
- en: 'It splits the input string around a comma, and then we get exactly three elements
    in the resulting array. The following three values are returned by the split method:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 它在逗号周围拆分输入字符串，然后我们得到结果数组中的三个元素。split方法返回以下三个值：
- en: '"fox"'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: '"fox"'
- en: '"tiger"'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: '"tiger"'
- en: '"wolf,,"'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: '"wolf,,"'
- en: 'Let''s call the split method with a negative limit:'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用负数限制调用split方法：
- en: 'String[] arr = input.split(",", -1); It splits the input string around a comma
    **as many times as possible, with the trailing** **empty strings included in the
    split array**, and we get these elements in the resulting array. The following
    values are returned by the split method. Note the two empty strings at the end
    of the split array:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: '"fox"'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: '"tiger"'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: '"wolf"'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: '""'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: '""'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 15](img/index-106_1.jpg)'
  id: totrans-1667
  prefs: []
  type: TYPE_IMG
- en: '**Using regular expressions in**'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Scanner API**'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: A scanner is a utility class used for parsing the input text and breaking the
    input into tokens of various types, such as Boolean, int, float, double, long,
    and so on. It generates tokens of various types using regular expression-based
    delimiters. The default delimiter is a whitespace. Using the Scanner API, we can
    generate tokens of all the primitive types in addition to string tokens.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: The String, Pattern, and Matcher classes are able to parse the input and generate
    tokens of the String type only, but the Scanner class is very useful for checking
    and generating tokens of different types from the input source. The Scanner instance
    can be constructed using the File, InputStream, Path, Readable, ReadableByteChannel,
    and String arguments.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '*Pattern and Matcher will be covered in detail in [Chapter 5](index_split_001.html#p111)*
    *, Introduction to* *Java Regular Expression APIs - Pattern and Matcher Classes.*'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many methods in the scanner that support regular expressions. Let''s
    list those methods down and understand them better:'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: '**Method Signature**'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: '**Purpose**'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: Scanner
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: Sets this scanner's delimiter regex pattern to a String
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: useDelimiter(String
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: regex argument.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: but gets a Pattern as an argument instead of a String.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can pass a regular expression
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: already compiled. If we are forced to use the version
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: Scanner
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: with the
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: useDelimiter(Pattern
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: String argument, the scanner would compile
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: the string to a
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: Pattern object even if we have already
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: executed that compilation in other parts of the code.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the Pattern and Matcher class in the
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: next chapter.
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: Returns the pattern being used by this scanner to
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: Pattern delimiter()
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: match delimiters.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: MatchResult match()
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: Returns the match result of the latest scan operation
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: performed by this scanner.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: boolean hasNext(String
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: Returns true if the next token matches the pattern
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: constructed from the specified string.
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: boolean hasNext(Pattern
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: but gets Pattern as an argument instead of String.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: Returns the next token if it matches the pattern
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: String next(String pattern)
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: constructed from the specified string.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: String
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: next(Pattern pattern)
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: but gets Pattern as an argument instead of String.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to find the next occurrence of a pattern
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: String findInLine(String
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: constructed from the specified string, ignoring
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: pattern)
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: delimiters.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: String findInLine(Pattern
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: This method is almost the same as the previous one
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法几乎与上一个相同
- en: pattern)
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: pattern)
- en: but gets Pattern as an argument instead of String.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 但将 Pattern 作为参数而不是 String。
- en: Scanner skip(String
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: Scanner skip(String
- en: Skips the input that matches a pattern constructed
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过与构造的图案匹配的输入
- en: pattern)
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: pattern)
