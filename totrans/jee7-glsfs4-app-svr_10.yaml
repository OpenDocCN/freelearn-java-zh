- en: Chapter 10. Web Services with JAX-WS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java EE specification includes the JAX-WS API as one of its technologies.
    JAX-WS is the standard way to develop **Simple Object Access Protocol** (**SOAP**)
    web services on the Java platform. It stands for **Java API for XML Web Services**.
    JAX-WS is a high-level API; invoking web services via JAX-WS is done via remote
    procedure calls. JAX-WS is a very natural API for Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: Web services are application programming interfaces that can be invoked remotely.
    Web services can be invoked from clients written in any programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics we will cover include:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing web services with the JAX-WS API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web service clients with the JAX-WS API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding attachments to web service calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing EJBs as web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web services with the JAX-WS API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JAX-WS is a high-level API that simplifies development of SOAP-based web services.
    Developing a web service via JAX-WS consists of writing a class with public methods
    to be exposed as web services. The class needs to be decorated with the `@WebService`
    annotation. All public methods in the class are automatically exposed as web services,
    they can optionally be decorated with the `@WebMethod` annotation. The following
    example illustrates this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class exposes its two methods as web services. The `add()` method
    simply adds the two `int` primitives it receives as parameters and returns the
    result. The `subtract()` method subtracts its two parameters and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: We indicate that the class implements a web service by decorating it with the
    `@WebService` annotation. Any methods that we would like exposed as web services
    can be decorated with the `@WebMethod` annotation; however, this isn't necessary,
    as all public methods are automatically exposed as web services.
  prefs: []
  type: TYPE_NORMAL
- en: To deploy our web service, we need to package it in a `.war` file. Before Java
    EE 6, all valid `.war` files were required to contain a `web.xml` deployment descriptor
    in their `WEB-INF` directory. As we have already covered in previous chapters,
    this deployment descriptor is optional when working with Java EE 6 (and later)
    and is not required to deploy a web service under this environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we choose to add a `web.xml` deployment descriptor, nothing needs to be
    added to the `.war` file''s `web.xml` in order to successfully deploy our web
    service. Simply having an empty `<web-app>` element in the deployment descriptor
    will be enough to successfully deploy our WAR file, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling, packaging, and deploying the code, we can verify that it was
    successfully deployed by logging into the GlassFish admin web console and expanding
    the **Applications** node on the left-hand side. We should see our newly deployed
    web service listed under this node, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, notice that there is a **View Endpoint** link
    at the bottom right of the page. Clicking on that button takes us to the **Web
    Service Endpoint Information** page shown in the following screenshot, which has
    some information about our web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that there is a link labeled **Tester:** in the preceding screenshot;
    clicking on this link takes us to an automatically generated page that allows
    us to test our web service. This page looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To test methods, we can simply enter some parameters in the text fields and
    click on the appropriate button. For example, entering the values `2` and `3`
    in the text fields corresponding to the `add` method and clicking on the **add**
    button would result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'JAX-WS uses the SOAP protocol behind the scenes to exchange information between
    web service clients and servers. By scrolling down the preceding page, we can
    see the SOAP request and response generated by our test, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As application developers, we don't need to concern ourselves too much with
    these SOAP requests, since they are automatically taken care of by the JAX-WS
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Web service clients need a **Web Services Definition Language** (**WSDL**) file
    in order to generate executable code that they can use to invoke the web service.
    WSDL is a standard XML-based interface definition language that defines the functionality
    of a web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'WSDL files are typically placed in a web server and accessed by the client
    via its URL. When deploying web services developed using JAX-WS, a WSDL file is
    automatically generated for us. We can see it, along with its URL, by clicking
    on the **View WSDL** link on the **Web Service Endpoint Information** page, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing web services with the JAX-WS API](img/6886EN_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the WSDL URL in the browser's location text field. We will need this
    URL when developing a client for our web service.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a web service client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, executable code needs to be generated from the WSDL of
    a web service. A web service client will then invoke this executable code to access
    the web service.
  prefs: []
  type: TYPE_NORMAL
- en: GlassFish includes a utility to generate Java code from a WSDL. The name of
    the utility is `wsimport`. It can be found under `[glassfish installation directory]/glassfish/bin/`.
    The only required argument for `wsimport` is the URL of the WSDL, which corresponds
    to the web service, for example, `wsimport` `http://localhost:8080/calculatorservice/CalculatorService?wsdl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command in the preceding screenshot will generate the following compiled
    Java classes that allow client applications to access our web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddResponse.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Calculator.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CalculatorService.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ObjectFactory.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package-info.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subtract.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubtractResponse.class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Keeping the Generated Source Code**'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the source code for the generated class files is automatically deleted;
    it can be kept by passing the `-keep` parameter to `wsimport`.
  prefs: []
  type: TYPE_NORMAL
- en: These classes need to be added to the client's CLASSPATH in order for them to
    be accessible to the client's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the command-line tool, GlassFish includes a custom ANT task
    to generate code from a WSDL. The following ANT build script illustrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is a very minimal ANT build script that only illustrates
    how to set up the custom `<wsimport>` ANT target. In reality, the ANT build script
    for the project would have several other targets for compilation, building a `.war`
    file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `<wsimport>` is a custom ANT target and it is not standard, we need to
    add a `<taskdef>` element to our ANT build script. We need to set the `name` and
    `classname` attributes as illustrated in the example. Additionally, we need to
    add the following `.jar` files to the task''s CLASSPATH via nested `<classpath>`
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webservices-osgi.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jaxb-osgi.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javaee.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `webservices-osgi.jar` and `jaxb-osgi.jar` files can be found under the
    `[glassfish installation directory]/glassfish/modules` directory. The `javaee.jar`
    file contains all the Java EE APIs and can be found under `[glassfish installation
    directory]/glassfish/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we set up the custom `<wsimport>` task via the `<taskdef>` element, we
    are ready to use it. We need to indicate the WSDL location via its `wsdl` attribute.
    Once this task executes, the Java code that is required to access the web service
    defined by the WSDL is generated.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.6 comes bundled with JAX-WS 2.1\. If we are using this version of the
    JDK, we need to tell ANT to use the JAX-WS 2.2 API included with GlassFish. This
    can be done easily by setting the `xendorsed` attribute of the custom `wsimport`
    ANT task to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Readers using Maven to build their projects can take advantage of Maven's `AntRun`
    plugin to execute the `wsimport` ANT target when building their code. This approach
    is illustrated in the following `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Nested in the `pom.xml` file's `<configuration>` tag, corresponding to the `AntRun`
    plugin, we place any ANT tasks we need to execute. Unsurprisingly, the body of
    this tag in our example looks nearly identical to the ANT build file we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to build our code with ANT or Maven, we can develop a
    simple client to access our web service, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `@WebServiceRef` annotation injects an instance of the web service into
    our client application. Its `wsdlLocation` attribute contains the URL of the WSDL
    that corresponds to the web service we are invoking.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the web service class is an instance of a class called `CalculatorService`.
    This class was created when we invoked the `wsimport` utility. The `wsimport`
    utility always generates a class whose name is the name of the class we implemented
    plus the `Service` suffix. We use this service class to obtain an instance of
    the web service class we developed. In our example, we do this by invoking the
    `getCalculatorPort()` method on the `CalculatorService` instance. In general,
    the method invoked to get an instance of our web service class follows the pattern
    `getNamePort()`, where `Name` is the name of the class we wrote to implement the
    web service. Once we get an instance of our web service class, we can simply invoke
    its methods like with any regular Java object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strictly speaking, the `getNamePort()` method of the service class returns an
    instance of a class that implements an interface generated by `wsimport`. This
    interface is given the name of our web service class and declares all of the methods
    we declared to be web services. For all practical purposes, the object returned
    is equivalent to our web service class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from our previous discussion that in order for resource injection to
    work in a standalone client (that does not get deployed to GlassFish), we need
    to execute it through the `appclient` utility. Assuming we packaged our client
    in a `.jar` file called `calculatorserviceclient.jar`, the command to execute
    would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After entering the preceding command in the command line, we should see the
    following output of our client on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we passed primitive types as parameters and return values.
    Of course, it is also possible to pass objects both as parameters and as return
    values. Unfortunately, not all standard Java classes or primitive types can be
    used as method parameters or return values when invoking web services. The reason
    for this is that behind the scenes, method parameters and return types get mapped
    to XML definitions, and not all types can be properly mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid types that can be used in JAX-WS web service calls are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.awt.Image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Java.lang.String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.math.BigDecimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.math.BigInteger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.net.URI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Calendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.UUID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.activation.DataHandler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.datatype.Duration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.datatype.XMLGregorianCalendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.namespace.QName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`javax.xml.transform.Source`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, the following primitive types can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use our own custom classes as method parameters and/or return values
    for web service methods, but member variables of our classes must be one of the
    types listed in the preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, arrays can be used both as method parameters or return values,
    however, when executing `wsimport`, these arrays get converted to `Lists`, generating
    a mismatch between the method signature in the web service and the method call
    invoked in the client. For this reason, it is preferred to use `Lists` as method
    parameters and/or return values, since this is also valid and does not create
    a mismatch between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JAX-WS internally uses the **Java Architecture for XML Binding** (**JAXB**)
    to create SOAP messages from method calls. The types we are allowed to use for
    method calls and return values are the ones that JAXB supports. You can get more
    information on JAXB at [https://jaxb.dev.java.net/](https://jaxb.dev.java.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Sending attachments to web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to sending and accepting the data types discussed in the previous
    sections, web service methods can send and accept file attachments. The following
    example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In order to write a web service method that receives one or more attachments,
    all we need to do is to add a parameter of type `javax.activation.DataHandler`
    for each attachment the method will receive. In the preceding example code, the
    `attachFile()` method takes a single parameter of this type and simply writes
    it to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with any standard web service, the preceding code needs to be packaged
    in a WAR file and deployed. Once deployed, a WSDL will automatically be generated.
    We then need to execute the `wsimport` utility to generate the code that our web
    service client can use to access the web service. As previously discussed, the
    `wsimport` utility can be invoked directly from the command line or via a custom
    ANT target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have executed `wsimport` to generate code to access the web service,
    we can write and compile our client code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A web service client that needs to send one or more attachments to the web service
    first obtains an instance of the web service as usual. It then creates an instance
    of `java.io.File`, passing the location of the file to attach as its constructor's
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an instance of `java.io.File` containing the file we wish to attach,
    we then need to convert the file to a byte array and pass this byte array to the
    web service method that expects an attachment.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the parameter type used when the client invokes a method expecting
    an attachment is different from the parameter type of the method in the web server
    code. The method in the web server code expects an instance of `javax.activation.DataHandler`
    for each attachment. However, the code generated by `wsimport` expects an array
    of bytes for each attachment. These arrays of bytes are converted to the right
    type (`javax.activation.DataHandler`) behind the scenes by the code generated
    by `wsimport`. We as application developers don't need to concern ourselves with
    the details of why this happens. We just need to keep in mind that when sending
    attachments to a web service method, the parameter types will be different in
    the web service code and in the client invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing EJBs as web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to creating web services as described in the previous section,
    public methods of stateless session beans can easily be exposed as web services.
    The following example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the only thing we need to do to expose a stateless session bean's
    public methods is decorate its class declaration with the `@WebService` annotation.
    Since the class is a stateless session bean, it also needs to be decorated with
    the `@Stateless` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like regular stateless session beans, the ones whose methods are exposed
    as web services need to be deployed in a `.jar` file. Once deployed, we can see
    the new web service under the **Applications** node in the GlassFish administration
    web console. Clicking on the application''s node, we can see some details in the
    GlassFish console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exposing EJBs as web services](img/6886EN_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the value in the **Type** column for our new web service is **StatelessSessionBean**.
    This allows us to see at a glance that the web service is implemented as an **Enterprise
    JavaBean** (**EJB**).
  prefs: []
  type: TYPE_NORMAL
- en: Just like standard web services, EJB web services automatically generate a WSDL
    to be used by its clients upon deployment; it can be accessed the same way by
    clicking on the **View EndPoint** link.
  prefs: []
  type: TYPE_NORMAL
- en: EJB web service clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following class illustrates the procedure to be followed to access EJB
    web service methods from a client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, nothing special needs to be done when accessing an EJB web service
    from a client. The procedure is the same as with standard web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the preceding example is a standalone application, it needs to be executed
    via the `appclient` application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Securing web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like with regular web applications, web services can be secured so that
    only authorized users can access them. This can be accomplished by modifying the
    web service''s `web.xml` deployment descriptor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we modify our calculator service so that only authorized users
    can access it. Notice that the modifications needed to secure the web service
    are no different from the modifications needed to secure any regular web application.
    The URL pattern to be used for the `<url-pattern>` element can be obtained by
    clicking on the **View WSDL** link corresponding to our service. In our example,
    the URL for the link is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/calculatorservice/CalculatorService?wsdl`'
  prefs: []
  type: TYPE_NORMAL
- en: The value to be used for `<url-pattern>` is the value right after the context
    root (`/CalculatorService` in our example) and before the question mark, followed
    by a slash and an asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the preceding `web.xml` deployment descriptor only secures HTTP
    `POST` requests. The reason for this is that `wsimport` uses a `GET` request to
    obtain the WSDL and generate the appropriate code. If `GET` requests are secured,
    `wsimport` will fail, since it will be denied access to the WSDL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code illustrates how a standalone client can access a secured
    web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a modified version of the `Calculator` service standalone
    client we saw earlier in the chapter. This version was modified to access the
    secure version of the service. As can be seen in the code, all we need to do to
    access the secured version of the server is put a username and a password in the
    request context. The username and password must be valid for the realm used to
    authenticate the web service.
  prefs: []
  type: TYPE_NORMAL
- en: We can add the username and password to the request context by casting our web
    service endpoint class to `javax.xml.ws.BindingProvider` and calling its `getRequestContext()`
    method. This method returns a `java.util.Map` instance. We can then simply add
    the username and password by calling the `put` method of `Map` and using the constants
    `USERNAME_PROPERTY` and `PASSWORD_PROPERTY` defined in `BindingProvider` as keys,
    and the corresponding `String` objects as values.
  prefs: []
  type: TYPE_NORMAL
- en: Securing EJB web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like standard web services, EJBs exposed as web services can be secured
    so that only authorized clients can access them. This can be accomplished by configuring
    the EJB via the `glassfish-ejb-jar.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the preceding deployment descriptor, security is set up differently
    for EJBs exposed as web services rather than with standard EJBs. For EJBs exposed
    as web services, the security configuration is done inside the `<webservice-endpoint>`
    element of the `glassfish-ejb-jar.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `<port-component-name>` element must be set to the name of the EJB we are
    exposing as a web service. This name is defined in the `<ejb-name>` element for
    the EJB.
  prefs: []
  type: TYPE_NORMAL
- en: The `<login-config>` element is very similar to the corresponding element in
    a web application's `web.xml` deployment descriptor. The `<login-config>` element
    must contain an authorization method, defined by its `<auth-method>` subelement,
    and a realm to use for authentication. The realm is defined by the `<realm>` subelement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use the `@RolesAllowed` annotation for EJBs intended to be exposed as
    web services. This annotation is intended for when the EJB methods are accessed
    through its remote or local interface. If an EJB or one or more of its methods
    are decorated with this annotation, then invoking the method will fail with a
    security exception.
  prefs: []
  type: TYPE_NORMAL
- en: Once we configure an EJB web service for authentication, we package it in a
    `.jar` file, and then deploy it as usual. The EJB web service is now ready to
    be accessed by clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates how an EJB web service client can access
    a secure EJB web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the previous example, the procedure for accessing an EJB exposed
    as a web service is identical to accessing a standard web service. The implementation
    of the web service is irrelevant to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to develop web services and web service clients
    via the JAX-WS API. We explained how to incorporate web service code generation
    for web service clients when using ANT or Maven as a build tool. We also covered
    the valid types that can be used for remote method calls via JAX-WS. Additionally,
    we discussed how to send attachments to a web service. We also covered how to
    expose EJB methods as web services. Lastly, we covered how to secure web services
    so that they are not accessible to unauthorized clients.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover RESTful web services with JAX-RS.
  prefs: []
  type: TYPE_NORMAL
