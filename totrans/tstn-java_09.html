<html><head></head><body>
		<div id="_idContainer054">
			<h1 id="_idParaDest-178" class="chapter-number"><a id="_idTextAnchor195"/>9</h1>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor196"/>Using Threads in Java</h1>
			<p>One of the first software development contracts I had was to develop software for an invisible fence security system at thoroughbred horse farms in Kentucky, USA. The computer we used was an Apple II plus. There was no such thing as threads in the 6502 CPU or the OS, ProDOS. What we did was write all the code in assembly language in small units that were measured by the number of cycles each unit took. Once we finished our allotted cycles, we would save our state in a defined region of memory and turn over control to the next unit. It worked quite well, and if a horse wandered off, alarms would be sounded. The monitoring of the fence, just a buried cable that could detect a horse walking over it, continued even while the alarm sounded. This was my introduction to threaded programming. This was <span class="No-Break">in 1982.</span></p>
			<p>I did not work with threads again until 1999 when I moved from C++ to Java. One of the features that made Java stand out and why I abandoned C++ was Java’s standardized support for threading in the language. This, along with support for GUI applications with Swing, made it clear to me that Java was the language that students in my program needed to learn. In 2002, Dawson College’s Computer Science Technology program, of which I was the chairperson, abandoned COBOL as the primary teaching language in favor <span class="No-Break">of Java.</span></p>
			<p>Today, many languages, including C++, have native support for multithreaded programming. In this chapter, we will examine how you can write threaded code in Java that depends on the Java virtual machine working with the computer’s OS. There are issues to deal with when threads share a resource. Using synchronization to deal with these issues will be examined. In this chapter, we will look at <span class="No-Break">the following:</span></p>
			<ul>
				<li>Creating Java native <span class="No-Break">OS threads</span></li>
				<li><a id="_idTextAnchor197"/>Preventing race and deadlock conditions <span class="No-Break">in threads</span></li>
				<li>Creating new <span class="No-Break">virtual threads</span></li>
			</ul>
			<p>Let us begin by looking at how we write threaded code using <span class="No-Break">native threads.</span></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor198"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Java 17 installed to work with native <span class="No-Break">threads only</span></li>
				<li>A <span class="No-Break">text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
			</ul>
			<p>The sample code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter09"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter09</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor199"/>Creating Java native OS threads</h1>
			<p>The term <em class="italic">native thread</em> refers<a id="_idIndexMarker636"/> to threads managed by the computer’s OS. When we create a Java native thread, we are referring to threads that the JVM manages using the underlying OS’s threads library API. This also means that the JVM deals with the different threads libraries on different OSs, while we use the Java API to create threads. A program that employs threads written on an Apple Mac will work on a Windows machine as the JVM handles the lowest levels <span class="No-Break">of threads.</span></p>
			<p>We will look at three different ways to create Java native threads<a id="_idIndexMarker637"/> and one way to create a pool of threads. These will involve <span class="No-Break">the following:</span></p>
			<ul>
				<li>Extending the <span class="No-Break"><strong class="source-inline">Thread</strong></span><span class="No-Break"> clas<a id="_idTextAnchor200"/>s</span></li>
				<li>Implementing the <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> interface</span></li>
				<li>Creating a thread pool <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ExecutorService</strong></span></li>
				<li>Implementing the <span class="No-Break"><strong class="source-inline">Callable</strong></span><span class="No-Break"> interface</span></li>
				<li><span class="No-Break">Managing threads</span></li>
			</ul>
			<p>The final items we will cover are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Daemon and <span class="No-Break">non-daemon threads</span></li>
				<li><span class="No-Break">Thread priority</span></li>
			</ul>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor201"/>Extending the Thread class</h2>
			<p>Any class that<a id="_idIndexMarker638"/> extends the <strong class="source-inline">Thread</strong> class can contain methods that execute as part of a thread. Just creating an object does not create threads. Instead, a class that extends <strong class="source-inline">Thread</strong> must override the <strong class="source-inline">run</strong> method of the <strong class="source-inline">Thread</strong> superclass. Anything in this method becomes a thread. The <strong class="source-inline">run</strong> method can carry out all the work in the thread. Unless this is a simple task, the <strong class="source-inline">run</strong> method acts like the <strong class="source-inline">perform</strong> method I have used in my previous samples. Everything in the <strong class="source-inline">run</strong> method is what this thread will do. Let us look at a simple class that extends the <span class="No-Break"><strong class="source-inline">Thread</strong></span><span class="No-Break"> class.</span></p>
			<p>We extend <strong class="source-inline">Thread</strong> to indicate that code in this class contains code that will <span class="No-Break">be threaded:</span></p>
			<pre class="source-code">
public class ThreadClass extends Thread {</pre>
			<p>In this example, the work that each thread will do is count backward from whatever value we initially assign to a field <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">actionCounter</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    private int actionCounter = 25;</pre>
			<p>Threads can be assigned a name. We want each thread in this example to have a number as its name. For this reason, it must be a static variable because there will just be one <strong class="source-inline">threadCounter</strong> integer, no matter how many instances of <strong class="source-inline">threadCounter</strong> we create. Static fields are considered thread-safe, meaning that there cannot be a conflict if two or more threads want access to the <span class="No-Break">static field:</span></p>
			<pre class="source-code">
    private static int threadCounter = 0;</pre>
			<p>The constructor is assigning the thread’s name to the superclass’s constructor. Each time we create an instance of this object, the value of <strong class="source-inline">threadCounter</strong> will be the same as what the previous instance set it as. This allows each thread to have a <span class="No-Break">unique name:</span></p>
			<pre class="source-code">
    public ThreadClass() {
        super("" + ++threadCounter);
    }</pre>
			<p>The only task that this thread will perform is to display its name and the current value of the <strong class="source-inline">actionCounter</strong> field. We are overriding the <strong class="source-inline">toString</strong> method that is called whenever a reference to an object must act as <strong class="source-inline">String</strong>. It will return a string made up of the name assigned to it, by calling the superclass <strong class="source-inline">getName</strong> method, and the current value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">actionCounter</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    @Override
    public String toString() {
        return "#" + getName() + " : " + actionCounter;
    }</pre>
			<p>Thread classes must override the superclass <strong class="source-inline">run</strong> method. This is where the work of a thread happens. In this case, we are using an infinite <strong class="source-inline">while</strong> loop in which we are displaying this object’s thread name and the current value of <strong class="source-inline">actionCounter</strong>. When <strong class="source-inline">actionCounter</strong> reaches zero, we return from the <strong class="source-inline">run</strong> method and the thread ends. The use of an infinite look syntax, <strong class="source-inline">while (true)</strong>, means that the decision to end the loop is based on something that is happening in the loop, which, in this case, is decrementing <strong class="source-inline">actionCounter</strong> until it reaches zero. This is not the only way to write a <strong class="source-inline">run</strong> method, but it is the <span class="No-Break">most</span><span class="No-Break"><a id="_idIndexMarker639"/></span><span class="No-Break"> common:</span></p>
			<pre class="source-code">
    @Override
    public void run() {
        System.out.printf("extends Thread%n");
        while (true) {
            System.out.printf("%s%n", this);
            if (--actionCounter == 0) {
                return;
            }
        }
    }
}</pre>
			<p>With our threaded class in place, we can now write a class that will instantiate and run each of <span class="No-Break">the threads:</span></p>
			<pre class="source-code">
public class ThreadClassRunner {</pre>
			<p>Here, in <strong class="source-inline">perform</strong>, we are <a id="_idIndexMarker640"/>instantiating five instances of <strong class="source-inline">ThreadClass</strong>. We call <strong class="source-inline">start</strong> and not <strong class="source-inline">run</strong>. The <strong class="source-inline">start</strong> method is an override of the <strong class="source-inline">Thread</strong> superclass’s <strong class="source-inline">start</strong> method, and it is responsible for setting up the thread and then calling the <strong class="source-inline">run</strong> method. Calling the <strong class="source-inline">run</strong> method yourself will not start <span class="No-Break">a thread:</span></p>
			<pre class="source-code">
    public void perform() {
        for (int i = 0; i &lt; 5; i++) {
            new ThreadClass().start();
        }
    }
    public static void main(String[] args) {
        new ThreadClassRunner().perform();
    }
}</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Threads are <span class="No-Break">not deterministic.</span></p>
			<p>This is an important point to always be aware of. Each time you run this example code, the output will be different. The threads will execute in an order unrelated to the order they were created. Run this example a few times and take note that the order of the results is different <span class="No-Break">every time.</span></p>
			<p>There is one problem with this <a id="_idIndexMarker641"/>approach. You cannot extend any other superclass in <strong class="source-inline">ThreadClass</strong>. This brings us to the <span class="No-Break">second approach.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor202"/>Implementing the Runnable interface</h2>
			<p>In this approach, we<a id="_idIndexMarker642"/> implement the <strong class="source-inline">Runnable</strong> interface. We are performing the same task as in the <span class="No-Break">previous example:</span></p>
			<pre class="source-code">
public class ThreadRunnableInterface implements Runnable{
    private int actionCounter = 25;
    @Override
    public String toString() {</pre>
			<p>We are calling <strong class="source-inline">Thread.currentThread().getName()</strong> to retrieve the name of this thread. When we extended the <strong class="source-inline">Thread</strong> class, we could call <strong class="source-inline">getName</strong>. As we are implementing the <strong class="source-inline">Runnable</strong> interface, we do not have superclass methods to call. We now get the name by using static methods of the <strong class="source-inline">Thread</strong> class, which will return information about the <a id="_idIndexMarker643"/>current thread that calls <span class="No-Break">these methods:</span></p>
			<pre class="source-code">
        return "#" + Thread.currentThread().getName() +
                 " : " + actionCounter;
    }</pre>
			<p>The <strong class="source-inline">run</strong> method <span class="No-Break">is unchanged:</span></p>
			<pre class="source-code">
    @Override
    public void run() {
        while (true) {
            System.out.printf("%s%n", this);
            if (--actionCounter == 0) {
                return;
            }
        }
    }
}</pre>
			<p>The <strong class="source-inline">perform</strong> method in the class that starts the threads is different when using the <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
    public void perform() {
        System.out.printf("implements Runnable%n");
        for (int i = 0; i &lt; 5; i++) {</pre>
			<p>We create these threads by instantiating a <strong class="source-inline">Thread</strong> class, passing to its constructor an instance of the <strong class="source-inline">Runnable</strong> thread class along with the thread’s name. In this example, the <strong class="source-inline">Thread</strong> object is anonymous; we do not assign it to a variable, and on it, we <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">start</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
            new Thread(new ThreadRunnableInterface(), ""
                          + ++i).start();
        }
    }</pre>
			<p>Just like in the <a id="_idIndexMarker644"/>previous example, the output will be different for <span class="No-Break">each run.</span></p>
			<p>Which technique should you use? The current best practice is to prefer the <strong class="source-inline">Runnable</strong> interface. This permits you to extend another class while it’s still being threaded. Let us look at <span class="No-Break">thread pooling.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor203"/>Creating a thread pool with ExecutorService</h2>
			<p>What we have <a id="_idIndexMarker645"/>seen so far requires us to create a <a id="_idIndexMarker646"/>thread for every instance of the <strong class="source-inline">Thread</strong> class. An<a id="_idIndexMarker647"/> alternative approach is to create a pool of threads that can be reused. This is where the <strong class="source-inline">ExecutorService</strong> approach comes in. With this, we can create a pool of threads while, at the same time, defining the maximum number that can run concurrently. If more threads are required than the pool allows, then threads will wait until an executing thread ends. Let us change our basic example to use <span class="No-Break">this service.</span></p>
			<p>We begin with a class that implements <strong class="source-inline">Runnable</strong>. The <strong class="source-inline">actionCounter</strong> field is the number we will count down from in <span class="No-Break">the thread:</span></p>
			<pre class="source-code">
public class ExecutorThreadingInterface implements Runnable {
    private int actionCounter = 250;</pre>
			<p>As we will leave the creation of the <strong class="source-inline">Thread</strong> class to <strong class="source-inline">ExecutorService</strong>, we no longer have a constructor that accepts <strong class="source-inline">String</strong> for the name of the thread. We will pass the name as <strong class="source-inline">int</strong> to the constructor and store it here. Fields in a class that becomes a single thread will each have their own <strong class="source-inline">actionCounter</strong> and <span class="No-Break"><strong class="source-inline">threadCount</strong></span><span class="No-Break"> instances:</span></p>
			<pre class="source-code">
    private final int threadCount;</pre>
			<p>Here is the constructor that takes the name we want to know the <span class="No-Break">thread by:</span></p>
			<pre class="source-code">
    public ExecutorThreadingInterface(int count) {
        threadCount = count;
    }</pre>
			<p>We are overriding the <strong class="source-inline">toString</strong> method to return <strong class="source-inline">String</strong> with the current thread’s name, which is assigned by <strong class="source-inline">ExecutorService</strong>, along with the name we assigned to <strong class="source-inline">threadCount</strong> as a number, followed by the current value of <strong class="source-inline">actionCounter</strong>, which decreases while the <span class="No-Break">thread runs:</span></p>
			<pre class="source-code">
    @Override
    public String toString() {
        return "#" + Thread.currentThread().getName()
            + "-" + threadCount + " : " + actionCounter;
    }</pre>
			<p>The last <a id="_idIndexMarker648"/>method<a id="_idIndexMarker649"/> is <strong class="source-inline">run</strong>. This<a id="_idIndexMarker650"/> <span class="No-Break">remains unchanged:</span></p>
			<pre class="source-code">
    @Override
    public void run() {
        while (true) {
            System.out.printf("%s%n", this);
            if (--actionCounter == 0) {
                return;
            }
        }
    }
}</pre>
			<p>Now, let us look at how we use <strong class="source-inline">ExecutorService</strong> to create <span class="No-Break">the threads:</span></p>
			<pre class="source-code">
public class ExecutorServiceRunner {</pre>
			<p>I have chosen to make the variables we use as fields. They could all just be declared as local variables in a <span class="No-Break">single method:</span></p>
			<pre class="source-code">
    private final int numOfThreads = 5;
    private final int threadPoolSize = 2;
    private final ExecutorService service;</pre>
			<p>The <a id="_idIndexMarker651"/>constructor now has the responsibility to<a id="_idIndexMarker652"/> instantiate <strong class="source-inline">ExecutorService</strong>, along with an <a id="_idIndexMarker653"/>array of <span class="No-Break"><strong class="source-inline">Runnable</strong></span><span class="No-Break"> threads:</span></p>
			<pre class="source-code">
    public ExecutorServiceRunner() {
        service =
             Executors.newFixedThreadPool(threadPoolSize);
    }
    public void perform() {
        for (int i = 0; i &lt; numOfThreads; i++) {</pre>
			<p>We add threads to <strong class="source-inline">ExecutorService</strong> using the <strong class="source-inline">execute</strong> method. We do not need access to the threads, so they are <span class="No-Break">instantiated anonymously:</span></p>
			<pre class="source-code">
            service.execute(
                      new ExecutorThreadingInterface(i));
        }</pre>
			<p>The service will shut down after all threads have finished. You can no longer add any threads to the service after this method <span class="No-Break">is called:</span></p>
			<pre class="source-code">
        service.shutdown();
    }</pre>
			<p>We end this class with the usual <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
    public static void main(String[] args) {
        new ExecutorServiceRunner().perform();
    }
}</pre>
			<p>These three <a id="_idIndexMarker654"/>approaches allow you to easily create <a id="_idIndexMarker655"/>threads. One issue that they all share is that when the <a id="_idIndexMarker656"/>thread ends, it does not return a value because <strong class="source-inline">run</strong> is void. We can resolve this, if needed, by combining <strong class="source-inline">ExecutorService</strong> with a third type of threaded class by using the <span class="No-Break"><strong class="source-inline">Callable</strong></span><span class="No-Break"> interface.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor204"/>Implementing the Callable interface</h2>
			<p>In each of the thread classes we have seen, they have all had a <strong class="source-inline">run</strong> method <a id="_idIndexMarker657"/>that returned void when the thread ended. This leads us to the <strong class="source-inline">Callable</strong> interface. Using this interface, the end of a thread returns a value. We can only use this technique if we use <strong class="source-inline">ExecutorService</strong>. Let’s begin by looking at a <strong class="source-inline">Callable</strong> <span class="No-Break">thread class.</span></p>
			<p>We begin with the class that we want to thread. We implement the <strong class="source-inline">Callable</strong> interface, and using generic notation, we state that the value returned when the thread ends will be a string. The fields, constructor, and <strong class="source-inline">toString</strong> are the same <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">ExecutorThreadingInterface</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class ThreadCallableInterface
                          implements Callable&lt;String&gt; {
    private int actionCounter = 250;
    private final int threadCount;
    public ThreadCallableInterface(int count) {
        threadCount = count;
    }
    @Override
    public String toString() {
        return "#" + Thread.currentThread().getName() +
                "-" + threadCount + " : " + actionCounter;
    }</pre>
			<p>Here, we <a id="_idIndexMarker658"/>replace <strong class="source-inline">run</strong> with <strong class="source-inline">call</strong> and show a return type. The <strong class="source-inline">return</strong> statement will display the thread name that we assigned as an integer to <span class="No-Break">each thread.</span></p>
			<pre class="source-code">
    @Override
    public String call() {
        while (true) {
            System.out.printf("%s%n", this);
            if (--actionCounter == 0) {
                return "Thread # " + threadCount +
                                          " is finished";
            }
        }
    }
}</pre>
			<p>Now, let us look at the runner for this <span class="No-Break"><strong class="source-inline">Callable</strong></span><span class="No-Break"> thread.</span></p>
			<pre class="source-code">
public class ThreadCallableInterfaceRunner {</pre>
			<p>The first variable we are<a id="_idIndexMarker659"/> declaring is <strong class="source-inline">List</strong> of the <strong class="source-inline">Future</strong> type. <strong class="source-inline">Future</strong> is an interface, like <strong class="source-inline">List</strong>. When we use, not execute, the <strong class="source-inline">submit</strong> method of <strong class="source-inline">ExecutorService</strong>, it returns an object that implements the <strong class="source-inline">Future</strong> interface. Objects that implement this interface represent the result of an asynchronous task. When we instantiate this object in a few lines from here, it will be <strong class="source-inline">List</strong> of <strong class="source-inline">Future</strong> strings that are delivered by <span class="No-Break">the thread:</span></p>
			<pre class="source-code">
    private final List&lt;Future&lt;String&gt;&gt; futureList;
    private final ExecutorService executor;
    private final int numOfThreads = 5;
    private final int threadPoolSize = 2;</pre>
			<p>A new<a id="_idIndexMarker660"/> feature in this example is the display of the current date and time that each thread ends. The <strong class="source-inline">DateTimeFormatter</strong> object converts an <strong class="source-inline">LocalDateTime</strong> object into a <span class="No-Break">readable string:</span></p>
			<pre class="source-code">
    private final DateTimeFormatter dtf;</pre>
			<p>The constructor instantiates the <span class="No-Break">class fields:</span></p>
			<pre class="source-code">
    public ThreadCallableInterfaceRunner() {
        executor =
            Executors.newFixedThreadPool(threadPoolSize);</pre>
			<p>We instantiate <strong class="source-inline">futureList</strong> as <strong class="source-inline">ArrayList</strong>. We follow this by defining the format of the date and time <span class="No-Break">we want:</span></p>
			<pre class="source-code">
        futureList = new ArrayList&lt;&gt;();
        dtf = DateTimeFormatter.ofPattern(
                                "yyyy/MM/dd HH:mm:ss");
    }
    public void perform(){</pre>
			<p>Here, we use <strong class="source-inline">submit</strong> to submit the threads to the <strong class="source-inline">ExecutorService</strong>. Using <strong class="source-inline">submit</strong> implies that we expect a return of type <strong class="source-inline">Future</strong>. We also add each <strong class="source-inline">Future</strong> object to an <span class="No-Break"><strong class="source-inline">ArrayList</strong></span><span class="No-Break"> instance:</span></p>
			<pre class="source-code">
        for (int i = 0; i &lt; numOfThreads; i++) {
            Future&lt;String&gt; future = executor.submit(
                           new ThreadCallableInterface(i));
            futureList.add(future);
        }</pre>
			<p>Here, we cycle through the <strong class="source-inline">ArrayList</strong> instance displaying the current date and time along with the thread’s returned value – in this example, <strong class="source-inline">String</strong>. We access the return value of the <strong class="source-inline">Future</strong> object by calling the <strong class="source-inline">get</strong> method. This is a blocking method call. Each <strong class="source-inline">Future</strong> object is associated with a specific thread, and <strong class="source-inline">get</strong> will wait for its result before it allows the next <strong class="source-inline">Future</strong> object’s <strong class="source-inline">get</strong> to execute. A call to <strong class="source-inline">get</strong> can result in two checked exceptions, so we must place the call in a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block. For the purpose of this example, we are just printing the stack trace. You should never just print a stack trace without taking<a id="_idIndexMarker661"/> any <span class="No-Break">appropriate action:</span></p>
			<pre class="source-code">
        for (Future&lt;String&gt; futureResult : futureList) {
            try {
                System.out.println(
                    dtf.format(LocalDateTime.now()) + ":" +
                    futureResult.get());
            } catch (InterruptedException |
                             ExecutionException e) {
                e.printStackTrace();
            }
        }</pre>
			<p><strong class="source-inline">ExecutorService</strong> must be <a id="_idIndexMarker662"/>explicitly shut down when you no longer need <span class="No-Break">the service:</span></p>
			<pre class="source-code">
        executor.shutdown();
    }</pre>
			<p>We end this with the usual <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
    public static void main(String[] args) {
        new ThreadCallableInterfaceRunner().perform();
    }
}</pre>
			<p>Now that we have reviewed the most common approaches to creating <strong class="source-inline">Threads</strong>, let us look a little deeper at how we can manage <span class="No-Break">a thread.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor205"/>Managing threads</h2>
			<p>There are three <strong class="source-inline">Thread</strong> methods <a id="_idIndexMarker663"/>that are commonly used to manage a thread. These are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">yield()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">join()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">sleep()</strong></span></li>
			</ul>
			<p>The <strong class="source-inline">yield()</strong> method informs the thread scheduler that it can give up its current usage of the processor but<a id="_idIndexMarker664"/> wishes to be rescheduled as soon as possible. This is only a suggestion, and the scheduler is free to do what it wishes. This makes it non-deterministic as well as dependent on the platform it is running on. It should only be used when it can be proved, usually by profiling the code, that it can <span class="No-Break">improve performance.</span></p>
			<p>The <strong class="source-inline">join()</strong> method can <a id="_idIndexMarker665"/>be useful when one thread (we will call it <strong class="bold">A</strong>), starts another thread (we will call it <strong class="bold">B</strong>). If we require the <strong class="bold">B</strong> thread to complete its task before the <strong class="bold">A</strong> thread, then we can use a join on the <strong class="bold">A</strong> thread, and that will block the <strong class="bold">A</strong> thread until <strong class="bold">B</strong> finishes its task. Using <strong class="source-inline">join()</strong> affects the first thread that created the second thread. There are two additional overloaded versions of join that allow you to set the length of time to block the thread that started it in either milliseconds, or milliseconds <span class="No-Break">and nanoseconds.</span></p>
			<p>The final method is a static method of the <strong class="source-inline">Thread</strong> class. The <strong class="source-inline">sleep()</strong> method pauses the thread it is executed in for a<a id="_idIndexMarker666"/> specific length of time. The time can be, like join, in milliseconds, or milliseconds <span class="No-Break">and nanoseconds.</span></p>
			<p>One characteristic of <a id="_idIndexMarker667"/>both <strong class="source-inline">join()</strong> and <strong class="source-inline">sleep()</strong> is that they can throw checked exceptions. They must be<a id="_idIndexMarker668"/> coded inside a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block. The following is a thread class that instantiates and starts a second class but then joins the second class, thus blocking itself until the thread it <span class="No-Break">started finishes.</span></p>
			<p>This is like the first <strong class="source-inline">ThreadClass</strong> instance we had seen. The difference is that it instantiates another<a id="_idIndexMarker669"/> thread class and then starts that thread at the beginning of the <span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
public class ThreadClass1 extends Thread {
    private int actionCounter = 500;
    private static int threadCounter = 0;
    private final ThreadClass2 tc2;
    public ThreadClass1() {
        super("" + ++threadCounter);
        tc2 = new ThreadClass2();
    }
    @Override
    public String toString() {
        return "#" + getName() + " : " + actionCounter;
    }
    @Override
    public void run() {</pre>
			<p>Here, we start the second thread, and it will now execute as determined by <span class="No-Break">the scheduler:</span></p>
			<pre class="source-code">
        tc2.start();
        while (true) {
            System.out.printf("%s%n", this);</pre>
			<p>When the first thread<a id="_idIndexMarker670"/> reaches 225, we issue a join on the second thread. The result will be that the first thread is blocked, and the second thread will run till it finishes before unblocking the <span class="No-Break">first thread:</span></p>
			<pre class="source-code">
                if (actionCounter == 225) {
                    try {
                        tc2.join();
                    } catch (InterruptedException ex) {
                        ex.printStackTrace();
                    }
                }
            if (--actionCounter == 0) {
                return;
            }
        }
    }
}</pre>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor206"/>Daemon and non-daemon threads</h2>
			<p>The term <em class="italic">daemon</em> refers to <a id="_idIndexMarker671"/>what is considered a low-priority thread. What this means is<a id="_idIndexMarker672"/> that any such native threads designated as daemons will end, regardless of what they are doing at that moment in time when the application’s main <span class="No-Break">thread ends.</span></p>
			<p>A non-daemon thread, the<a id="_idIndexMarker673"/> default for when a native thread is created, will block the<a id="_idIndexMarker674"/> application’s main thread from ending until the thread completes its task. This tells us that non-daemon threads must have an ending condition. A daemon thread does not need an ending condition, as it will end with the <span class="No-Break">main thread.</span></p>
			<p>You can set a native thread to be a daemon with a simple <span class="No-Break">method call:</span></p>
			<pre class="source-code">
thread.setDaemon(true);</pre>
			<p>You can only call this method on a thread after it has been instantiated but before it has started. You cannot change the daemon status after it starts. Calling this method will result in an exception <span class="No-Break">being thrown.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor207"/>Thread priority</h2>
			<p>As already pointed out, threads are <a id="_idIndexMarker675"/>non-deterministic. This means we have no absolute control over when a thread will get its slice of time to run or how long that time slice will be. We can make a suggestion, also called a hint, and that is where thread priority <span class="No-Break">comes in.</span></p>
			<p>The range of possible values for thread priority is 1 through 10. There are three defined static constants that are used in most cases rather than a number. These are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Thread.MAX_PRIORITY</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Thread.MIN_PRIORITY</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Thread.NORM_PRIORITY</strong></span></li>
			</ul>
			<p>As this suggests, you cannot rely on maximum priority getting more time slices than minimum priority. It should get more slices, and that is the best that you can <span class="No-Break">hope for.</span></p>
			<p>Now that we have seen how to manage our threads, let us look at one more topic, <span class="No-Break">thread safety.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor208"/>Preventing race and deadlock conditions in threads</h1>
			<p>There are two common <a id="_idIndexMarker676"/>problems that can cause problems with threaded code. The<a id="_idIndexMarker677"/> first is the race condition. This is what can happen when two or more threads work with a block of code that changes a variable shared by all <span class="No-Break">the threads.</span></p>
			<p>The second is the <a id="_idIndexMarker678"/>deadlock condition. To resolve race conditions, you lock a<a id="_idIndexMarker679"/> block of code. If multiple threads use the same lock object, then you could have a situation where these threads are waiting for each other to finish with the lock but none finish. Let us look more closely at these <span class="No-Break">two conditions.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor209"/>Race condition</h2>
			<p>Imagine a scenario where you <a id="_idIndexMarker680"/>share a reference to an object among multiple threads. Calling <a id="_idIndexMarker681"/>upon methods in this shared class that only use local variables is thread-safe. Thread-safe, in this case, occurs because each thread maintains its own private stack for local variables. There can be no conflict <span class="No-Break">between threads.</span></p>
			<p>It is a different story if the shared object’s methods access and alter a class field. Unlike local variables, class fields are unique to the shared object and every thread that calls methods in this class is possibly altering a field. Operations on these fields may not finish before the thread’s time slice ends. Now, imagine that a thread expects a field to have a specific value based on the last time slice that accessed the field. Unbeknown to it, another thread has changed that value. This results in what is referred to as a race condition. Let us look at <span class="No-Break">an example.</span></p>
			<p>Here is a simple class that adds a passed value to a field of the class called <strong class="source-inline">counter</strong> and returns the result of adding the value. Every time we call <strong class="source-inline">addUp</strong>, we expect the <strong class="source-inline">counter</strong> field to change <span class="No-Break">the value:</span></p>
			<pre class="source-code">
public class Adder {
    private long counter = 0;
    public long addUp(long value) {
        counter += value;</pre>
			<p>How much time a thread gets from the scheduler is related to the CPU of your computer. A high clock rate along with multiple CPU cores sometimes permits a thread to complete its task before the next thread takes over. For that reason, I have slowed down the <strong class="source-inline">addUp</strong> method by <a id="_idIndexMarker682"/>having it sleep for a <span class="No-Break">half second:</span></p>
			<pre class="source-code">
        try {
            Thread.sleep(500);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
        return counter;
    }
}</pre>
			<p>The threaded class is based on <strong class="source-inline">ThreadClass</strong> we have <span class="No-Break">already seen:</span></p>
			<pre class="source-code">
public class SynchronizedThreadClass extends Thread {
    private int actionCounter = 5;
    private static int threadCounter = 0;</pre>
			<p>We have a field for holding<a id="_idIndexMarker683"/> a reference to an <strong class="source-inline">Adder</strong> object. No matter how many threads we create, they will all share the <span class="No-Break">field variables:</span></p>
			<pre class="source-code">
    private final Adder adder;</pre>
			<p>The constructor receives a reference to the <span class="No-Break"><strong class="source-inline">Adder</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
    public SynchronizedThreadClass(Adder adder) {
        super("" + ++threadCounter);
        this.adder = adder;
    }
    @Override
    public String toString() {
        return "#" + getName() + " : " + actionCounter;
    }
    @Override
    public void run() {
        while (true) {
            var value = adder.addUp(2);</pre>
			<p>Here, we are<a id="_idIndexMarker684"/> printing <a id="_idIndexMarker685"/>information on this thread and the current value from the <span class="No-Break"><strong class="source-inline">addUp</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
            System.out.printf(
                 "%s : %d%n", this, adder.addUp(2));
            if (--actionCounter == 0) {
                return;
            }
        }
    }
}</pre>
			<p>Here is the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public class SynchronizedExample {</pre>
			<p>We will have two threads of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">SynchronizedThreadClass</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    private final SynchronizedThreadClass tc1;
    private final SynchronizedThreadClass tc2;
    private final Adder sa;</pre>
			<p>Before we instantiate each thread, we create a single <strong class="source-inline">Adder</strong> object that we share with each <span class="No-Break">threaded class:</span></p>
			<pre class="source-code">
    public SynchronizedExample() {
        sa = new Adder();
        tc1 = new SynchronizedThreadClass(sa);
        tc2 = new SynchronizedThreadClass(sa);
    }
    public void perform() {
        tc1.start();
        tc2.start();
    }
    public static void main(String[] args) {
        new SynchronizedExample().perform();
    }
}</pre>
			<p>This code is not yet <a id="_idIndexMarker686"/>synchronized. Here is a table of results when access to the<a id="_idIndexMarker687"/> adder is <span class="No-Break">not synchronized:</span></p>
			<table id="table001-2" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="3">
							<p><span class="No-Break"><strong class="bold">Unsynchronized</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Thread</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Thread </strong><span class="No-Break"><strong class="bold">class actionCounter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Adder </strong><span class="No-Break"><strong class="bold">class counter</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>5</p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>5</p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
						<td class="No-Table-Style">
							<p>8</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">10</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">12</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">14</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">16</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">18</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">20</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">20</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1 – The results from running the code unsynchronized</p>
			<p>The <a id="_idIndexMarker688"/>expectation is that the <strong class="source-inline">Adder</strong> class counter should count from 2 to 20. It does not. The first thread begins adding the value passed, 2, to the counter. But before it can<a id="_idIndexMarker689"/> display its result, the second thread comes along and adds 2 to the same counter, now increasing the value to 4. When we return to the first thread that will just display the result, it is now 4, and not the value of 2 that it had when its first time slice ended. If you run this multiple times, the results will be different, but we will see this problem in other places in <span class="No-Break">the output.</span></p>
			<p>Now, let us synchronize the code. Synchronizing applies a lock to a section of code commonly called a critical section. The lock is a reference to an object, as all objects, by virtue of their <strong class="source-inline">Object</strong> superclass, can be used as a lock. We only need to change the <strong class="source-inline">Adder</strong> class and specifically the <span class="No-Break"><strong class="source-inline">addUp</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
    public long addUp(long value) {
        synchronized (this) {
            counter += value;
            try {
                Thread.sleep(10);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            return counter;
        }
    }</pre>
			<p>As the entire method is considered a critical section, we can remove the synchronize block and apply the <strong class="source-inline">synchronized</strong> keyword to the <span class="No-Break">method name:</span></p>
			<pre class="source-code">
    public synchronized long addUp(long value) {</pre>
			<p>Here is the table<a id="_idIndexMarker690"/> of results using <a id="_idIndexMarker691"/>the synchronized version of the <strong class="source-inline">addUp</strong> <strong class="source-inline">Adder</strong> <span class="No-Break">class method:</span></p>
			<table id="table002-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style" colspan="3">
							<p><span class="No-Break"><strong class="bold">Synchronized</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Thread</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Thread </strong><span class="No-Break"><strong class="bold">class actionCounter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Adder </strong><span class="No-Break"><strong class="bold">class counter</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>5</p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>5</p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
						<td class="No-Table-Style">
							<p>6</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
						<td class="No-Table-Style">
							<p>8</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">10</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">12</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">14</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">16</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#1</p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">18</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>#2</p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">20</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.2 – The results from running the code synchronized</p>
			<p>You can see that every value from 2 to <span class="No-Break">20 appears.</span></p>
			<p>As a <a id="_idIndexMarker692"/>developer, you are always looking for tasks that can be carried out concurrently. Once identified, you will apply threading where appropriate. Any long-running task is a candidate for a thread. User interfaces typically run the interface in one or more threads, and as tasks are selected from menus or buttons, they too are run in threads. This means that the user interface can respond to you even while it is performing<a id="_idIndexMarker693"/> a <span class="No-Break">long-running task.</span></p>
			<p>Now, let us look at a problem that can arise if we synchronize blocks of code with the same lock <span class="No-Break">object improperly.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor210"/>Deadlock condition</h2>
			<p>A thread<a id="_idIndexMarker694"/> deadlock occurs when thread locks get intertwined, especially if a<a id="_idIndexMarker695"/> thread is nested inside another one. This results in each thread waiting for the other to end. When using synchronize, a lock can be any object or class in Java that will protect a critical section, usually to avoid the race condition. You can also create objects of type <strong class="source-inline">Lock</strong> or <strong class="source-inline">ReentrantLock</strong>. Either approach, as we shall see, can result in a deadlock. Deadlock can be difficult to recognize, as it does not crash the program or throw an exception. Let us look at an example of code that will <span class="No-Break">be deadlocked.</span></p>
			<p>We begin with the class that will create the lock objects and then we start two threads <span class="No-Break">with them:</span></p>
			<pre class="source-code">
public class Deadlock1 {</pre>
			<p>Here are the two lock objects we will use with synchronize in <strong class="source-inline">Thread1</strong> and <strong class="source-inline">Thread2</strong>. Any object in Java, either one you create or one that already exists, such as <strong class="source-inline">String</strong>, can be used as <span class="No-Break">a lock:</span></p>
			<pre class="source-code">
    public final Object lock1 = new Object();
    public final Object lock2 = new Object();
    public void perform() {
        var t1 = new ThreadLock1(lock1, lock2);
        var t2 = new ThreadLock2(lock1, lock2);
        t1.start();
        t2.start();
    }
    public static void main(String args[]) {
        new Deadlock1().perform();
    }
}</pre>
			<p>Now, let us look at the class that extends <strong class="source-inline">Thread</strong>. Take note of the fact that <strong class="source-inline">Thread1</strong> uses <strong class="source-inline">lock1</strong> before <strong class="source-inline">lock2</strong>, while <strong class="source-inline">Thread2</strong> uses <strong class="source-inline">lock2</strong> <span class="No-Break">before </span><span class="No-Break"><strong class="source-inline">lock1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class ThreadLock1 extends Thread {
    private final Object lock1;
    private final Object lock2;
    public ThreadLock1(Object lock1, Object lock2) {
       this.lock1 = lock1;
       this.lock2 = lock2;
    }</pre>
			<p>In this <strong class="source-inline">run</strong> method, we <a id="_idIndexMarker696"/>have a synchronized block that uses <strong class="source-inline">lock1</strong> and then a<a id="_idIndexMarker697"/> nested synchronized block that <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">lock2</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    @Override
    public void run() {
        synchronized (lock1) {
            System.out.printf(
                      "Thread 1: Holding lock 1%n");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
            }
            System.out.printf(
                       "Thread 1: Waiting for lock 2%n");
            synchronized (lock2) {
                System.out.printf(
                        "Thread 1: Holding lock 1 &amp; 2%n");
            }
        }
    }
}
public class ThreadLock2 extends Thread {
    private final Object lock1;
    private final Object lock2;
    public ThreadLock2(Object lock1, Object lock2) {
       this.lock1 = lock1;
       this.lock2 = lock2;
    }</pre>
			<p>In this <strong class="source-inline">run</strong> method, we<a id="_idIndexMarker698"/> have a synchronized block that uses <strong class="source-inline">lock2</strong> and then a<a id="_idIndexMarker699"/> nested synchronized block that <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">lock1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    @Override
    public void run() {
        synchronized (lock2) {
            System.out.printf(
                       "Thread 2: Holding lock 2%n");
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
            }
            System.out.printf(
                     "Thread 2: Waiting for lock 1%n");
            synchronized (lock1) {
                System.out.printf(
                      "Thread 2: Holding lock 1 &amp; 2%n");
            }
        }
    }
}</pre>
			<p>When we run this code, the output will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">Thread 1: Holding lock 1</strong>
<strong class="bold">Thread 2: Holding lock 2</strong>
<strong class="bold">Thread 1: Waiting for lock 2</strong>
<strong class="bold">Thread 2: Waiting for lock 1</strong></pre>
			<p>The program is now<a id="_idIndexMarker700"/> deadlocked, and both threads are waiting for the other<a id="_idIndexMarker701"/> thread to finish. If we change the order of the locks we use so that both use <strong class="source-inline">lock1</strong> first and <strong class="source-inline">lock2</strong> second, we will get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">Thread 1: Holding lock 1</strong>
<strong class="bold">Thread 1: Waiting for lock 2</strong>
<strong class="bold">Thread 1: Holding lock 1 &amp; 2</strong>
<strong class="bold">Thread 2: Holding lock 2</strong>
<strong class="bold">Thread 2: Waiting for lock 1</strong>
<strong class="bold">Thread 2: Holding lock 1 &amp; 2</strong></pre>
			<p>The deadlock condition is solved. Deadlocks are rarely this obvious, and you may not even be aware that there is a deadlock happening. You need a thread dump to determine whether there is a deadlock in <span class="No-Break">your code.</span></p>
			<p>Here’s one final point on this topic – rather than using an instance of the <strong class="source-inline">Object</strong> class as the lock, you can use the <strong class="source-inline">Lock</strong> class. The syntax is a little different, and you can ask a <strong class="source-inline">Lock</strong> object whether it is being used. The following code snippet shows what it will look like, but it does not solve <span class="No-Break">the deadlock.</span></p>
			<p>In the <strong class="source-inline">main</strong> class, the<a id="_idIndexMarker702"/> locks will use the <strong class="source-inline">Lock</strong> interface with the <strong class="source-inline">ReentrantLock</strong> class<a id="_idIndexMarker703"/> that implements <span class="No-Break">the interface:</span></p>
			<pre class="source-code">
    public final Lock lock1 = new ReentrantLock();
    public final Lock lock2 = new ReentrantLock();</pre>
			<p>In this code, we are passing the <strong class="source-inline">Lock</strong> objects to the class through <span class="No-Break">the constructor:</span></p>
			<pre class="source-code">
public class ThreadLock1a extends Thread {
    private final Lock lock1;
    private final Lock lock2;
    public ThreadLock1a(Lock lock1, Lock lock2) {
       this.lock1 = lock1;
       this.lock2 = lock2;
    }
    @Override
    public void run() {</pre>
			<p>Note that we do not use a synchronized block, but instead, we call <strong class="source-inline">lock</strong> on <strong class="source-inline">lock1</strong>, and when the critical section is finished, we issue <strong class="source-inline">unlock</strong> <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">lock1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        lock1.lock();
        System.out.printf("Thread 1a: Holding lock 1%n");
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
        }
        System.out.printf(
              "Thread 1a: Waiting for lock 2%n");
        lock2.lock();
        System.out.printf("Thread 1a: Holding lock 1 &amp; 2");
        lock2.unlock();
        lock1.unlock();
    }
}</pre>
			<p>One advantage of <a id="_idIndexMarker704"/>using <strong class="source-inline">lock</strong> objects rather than a synchronized block is<a id="_idIndexMarker705"/> that the call to <strong class="source-inline">unlock</strong> does not have to be in the <span class="No-Break">same class.</span></p>
			<p>Multithreading is a <a id="_idIndexMarker706"/>powerful feature of Java that you should use when appropriate. What we saw is based on native threading available in Java from version 1.0. Recently, a new type of threading was introduced. Let us look <span class="No-Break">at it.</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor211"/>Creating new virtual threads</h1>
			<p>As pointed out at the beginning of the previous section, native Java threads are managed by the JVM by working directly with the OS’s threading library. There is a one-to-one relationship between a native thread and an OS thread. This new approach is called <strong class="bold">virtual threads</strong>. While <a id="_idIndexMarker707"/>native threads are managed by the JVM in collaboration with the OS, virtual threads are managed exclusively by the JVM. OS threads are still used, but what makes this approach significant is that virtual threads can share OS threads and are no <span class="No-Break">longer one-to-one.</span></p>
			<p>Virtual threads do not run faster and can suffer from race and deadlock conditions. What is special with virtual threads is that the number of threads that you can start up could be in the millions. How we use virtual threads is not much different from native threads. The following code snippet shows the <strong class="source-inline">perform</strong> method that we saw in the previous examples creating virtual threads. The thread class is unchanged, thus making the use of a virtual thread rather than a native thread <span class="No-Break">quite easy:</span></p>
			<pre class="source-code">
     public void perform() {
        for (int i = 0; i &lt; 5; ++i) {</pre>
			<p>Here, we are creating<a id="_idIndexMarker708"/> a virtual thread and <span class="No-Break">starting it:</span></p>
			<pre class="source-code">
            Thread.ofVirtual().name("Thread # " + i).
               start(new VirtualThreadRunnableInterface());
        }
        try {
            Thread.sleep(500);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }</pre>
			<p>I must embarrassingly admit that it took me 3 days to get this code to work. Why? I neglected an important characteristic of virtual threads – they are daemon threads. Attempting to make them non-daemon has no effect. What was happening to me is that the program would end before any output appeared, or only some appeared but not all of the expected output from the threads. When <strong class="source-inline">perform</strong> ended and returned to the <strong class="source-inline">main()</strong> method, the main native thread ended. When this happened, all daemon threads were ended. My PC executed <strong class="source-inline">perform</strong>, returned to <strong class="source-inline">main</strong>, and ended before a single virtual thread could display <span class="No-Break">its output.</span></p>
			<p>You can see the solution I <a id="_idIndexMarker709"/>used to make this code work. I called <strong class="source-inline">Thread.sleep()</strong>. This puts the current thread to sleep for a specified length of time. In this case, 500 milliseconds was enough time for the virtual threads to complete all their tasks before the main <span class="No-Break">thread ended.</span></p>
			<p>Finally, you cannot change the priority of virtual threads. They all run <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">NORM_PRIORITY</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor212"/>Summary</h1>
			<p>As mentioned at the start of this chapter, Java’s native support of threads is one of the reasons for its popularity. In this chapter, we saw how we can create threads by extending the <strong class="source-inline">Thread</strong> class and by implementing either a <strong class="source-inline">Runnable</strong> or <strong class="source-inline">Callable</strong> interface. We saw how <strong class="source-inline">ExecutorService</strong> allows us to pool threads. We concluded by looking at one specific issue, where two or more threads compete for access to a shared resource, called a race condition, and saw how we resolve this by applying locks through the application <span class="No-Break">of synchronization.</span></p>
			<p>There are changes coming to threading. Project Loom, at the time of writing, introduces threads managed exclusively by the JVM along with a framework for concurrency. Some features are in preview, while others are in incubation. It will be a few years before these new types of threads become commonplace. I recommend following the development of <span class="No-Break">this project.</span></p>
			<p>In our next chapter, we will look at the most used design patterns in Java development. These patterns will provide us with well-established approaches to organizing <span class="No-Break">our code.</span></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor213"/>Further reading</h1>
			<ul>
				<li><em class="italic">Creating and Starting Java </em><span class="No-Break"><em class="italic">Threads</em></span><span class="No-Break">: </span><a href="https://jenkov.com/tutorials/java-concurrency/creating-and-starting-threads.html"><span class="No-Break">https://jenkov.com/tutorials/java-concurrency/creating-and-starting-threads.html</span></a></li>
				<li><em class="italic">Introduction to Thread Pools in </em><span class="No-Break"><em class="italic">Java</em></span><span class="No-Break">: </span><a href="https://www.baeldung.com/thread-pool-java-and-guava"><span class="No-Break">https://www.baeldung.com/thread-pool-java-and-guava</span></a></li>
				<li><em class="italic">Deadlock in Java </em><span class="No-Break"><em class="italic">Multithreading</em></span><span class="No-Break">: </span><a href="https://www.geeksforgeeks.org/deadlock-in-java-multithreading/"><span class="No-Break">https://www.geeksforgeeks.org/deadlock-in-java-multithreading/</span></a></li>
				<li>Here is a book from 2006, that remains one of the finest references on threading in Java: <em class="italic">Java Concurrency in Practice, 1st Edition</em>, by Brian Goetz with Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea (<span class="No-Break">ISBN-13: 978-0321349606)</span></li>
				<li><em class="italic">JEP 425: Virtual </em><span class="No-Break"><em class="italic">Threads</em></span><span class="No-Break">: </span><a href="https://openjdk.org/jeps/425"><span class="No-Break">https://openjdk.org/jeps/425</span></a></li>
			</ul>
		</div>
	</body></html>