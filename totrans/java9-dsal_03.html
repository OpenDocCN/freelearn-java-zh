<html><head></head><body>
<div class="book" title="Chapter&#xA0;3.&#xA0;Protocols &#x2013; Abstract Data Types"><div class="book" id="MSDG2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Protocols – Abstract Data Types</h1></div></div></div><p class="calibre8">In the last chapter, we saw a few basic data structures and some algorithms to manipulate them. However, sometimes we may want to hide the implementation details of a data structure and only want to know how they interact with other algorithms. We may want to specify a few operations that they must allow and forget about how they are achieved. This is not very different from abstraction of a part of a program in any large software application. For example, in Java, we create interfaces that only define the methods of an object that its class must implement, and then we use this interface type, being confident that they will be implemented properly. We do not want to think about how an implementation class would provide their implementation. Such interfaces of data structure are called abstract data types. To put this another way, an <span class="strong"><strong class="calibre2">abstract data type</strong></span> (<span class="strong"><strong class="calibre2">ADT</strong></span>) is a<a id="id72" class="calibre1"/> description of what a data structure should do for its user. It is a list of operations that any implementation must support and the complete description of what these operations are supposed to do. A few of these have very frequent usage and have names given to them. We will discuss a few of these here.</p><p class="calibre8">In this chapter, you will learn about the following concepts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The definition of some common ADTs and their operations</li><li class="listitem">How to implement these ADTs using both simple arrays and the data structures you learned in the last chapter</li></ul></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Protocols &#x2013; Abstract Data Types">
<div class="book" title="Stack"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec17" class="calibre1"/>Stack</h1></div></div></div><p class="calibre8">A <span class="strong"><strong class="calibre2">stack</strong></span> is a <a id="id73" class="calibre1"/>very commonly used ADT. It is so named because it resembles a stack of plates used in a restaurant. In such a stack, a plate that has been washed and put last would stay on top. This would be the first plate to be picked up when a plate is needed. The plate that went in first would be at the bottom of the stack and would be picked last. So, the last plate to be placed in the stack is the first plate to get out, we can also <a id="id74" class="calibre1"/>call this <span class="strong"><strong class="calibre2">last in first out</strong></span> (<span class="strong"><strong class="calibre2">LIFO</strong></span>).</p><p class="calibre8">Similarly, a <a id="id75" class="calibre1"/>stack ADT has a protocol where the last value that is put in it must be returned on the first attempt to get a value out, and the value that went in first must come out last. The following figure will make it more clear:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Stack" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">The operation of putting a new value in a stack is called push, and the operation of retrieving a value from a stack is called pop. The element that was pushed last must be popped first. The operation that allows one to see what the next pop will return is called peek. The peek operation returns the top element without modifying the stack. We expect all stack implementations to have all operations implemented in the time complexity of <span class="strong"><em class="calibre12">O(1)</em></span>. This is also part of our stack protocol.</p><p class="calibre8">The stack ADT has the following operations:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Push</strong></span>: This<a id="id76" class="calibre1"/> adds an element at the top of the stack</li><li class="listitem"><span class="strong"><strong class="calibre2">Pop</strong></span>: This <a id="id77" class="calibre1"/>removes the element at the top of the stack</li><li class="listitem"><span class="strong"><strong class="calibre2">Peek</strong></span>: This <a id="id78" class="calibre1"/>checks the next value to be popped</li></ul></div><p class="calibre8">Since we know that ADTs are to data structures what interfaces are to classes, we will code an ADT as an interface. The following is our interface for a stack:</p><div class="informalexample"><pre class="programlisting">public interface Stack&lt;E&gt; {
  void push(E value);
  E pop();
  E peek();
}</pre></div><p class="calibre8">Of course, we will not leave it at this. We will see how a stack can actually be implemented. To this end, we will see both a fixed-sized stack using an array to store it's data, and a growing <a id="id79" class="calibre1"/>stack using a linked list for storing data. We will start with the first.</p></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Protocols &#x2013; Abstract Data Types">
<div class="book" title="Stack">
<div class="book" title="Fixed-sized stack using an array"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec26" class="calibre1"/>Fixed-sized stack using an array</h2></div></div></div><p class="calibre8">A fixed-sized stack uses a pre-allocated array to store values, that is when this stack has used up the <a id="id80" class="calibre1"/>entire array, it can no longer accept new<a id="id81" class="calibre1"/> values until the old ones are popped. This is not very different from an actual stack of plates, which most certainly has a maximum height that it can handle.</p><p class="calibre8">As always, we start with the basic structure of the class, as follows:</p><div class="informalexample"><pre class="programlisting">public class StackImplArray&lt;E&gt; implements Stack&lt;E&gt; {
</pre></div><p class="calibre8">We need an array to store the elements, and we need to remember where the top of the stack is in that array. The top always marks the index of the element that will be popped next. When there are no more elements to be popped, it is set to <code class="email">-1</code>. Why <code class="email">-1</code>? Because this is the natural choice as it does not require any special handling when the first element is inserted:</p><div class="informalexample"><pre class="programlisting">protected E[] array;
  int top=-1;

  public StackImplArray(int size){
    array = (E[])new Object[size];
  }
}</pre></div><p class="calibre8">The <code class="email">push</code> operation in a stack can be to simply put the value in the array right next to the current <code class="email">top</code> and then set the <code class="email">top</code> to the new position, as illustrated in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public void push(E value) {</pre></div><p class="calibre8">We first check whether the stack is already full or the current <code class="email">top</code> is equal to the maximum index possible, like this:</p><div class="informalexample"><pre class="programlisting">  if(top == array.length-1){
    throw new NoSpaceException("No more space in stack");
  }</pre></div><p class="calibre8">Now, we set the <code class="email">top</code> to the new position and put the value we need to store in there as follows:</p><div class="informalexample"><pre class="programlisting">  top++;
  array[top] = value;
}</pre></div><p class="calibre8">The exception we used is a custom exception for this purpose. The code of the exception is simple as <a id="id82" class="calibre1"/>shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class NoSpaceException extends RuntimeException{
  public NoSpaceException(String message) {
    super(message);
  }
}</pre></div><p class="calibre8">The <code class="email">pop</code> operation<a id="id83" class="calibre1"/> is just the opposite. We need to first take the value of the current <code class="email">top</code> and then update the <code class="email">top</code> to the new position, which is one less than the current position, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public E pop() {</pre></div><p class="calibre8">We first check whether the stack is already empty, in which case we return a special value, <code class="email">null</code>. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">  if(top==-1){
    return null;
  }</pre></div><p class="calibre8">Then we update the <code class="email">top</code> and return the value at the current <code class="email">top</code> as follows:</p><div class="informalexample"><pre class="programlisting">  top--;
  return array[top+1];
}</pre></div><p class="calibre8">The <code class="email">peek</code> operation does not change the state of the stack, and hence is even simpler:</p><div class="informalexample"><pre class="programlisting">@Override
public E peek() {</pre></div><p class="calibre8">Just like the <code class="email">pop</code> operation, we return <code class="email">null</code> if the stack is empty:</p><div class="informalexample"><pre class="programlisting">  if(top==-1){
    return null;
  }</pre></div><p class="calibre8">Otherwise, we return the <code class="email">top</code> element, as follows:</p><div class="informalexample"><pre class="programlisting">  return array[top];
}</pre></div><p class="calibre8">It is in fact possible to have a stack without an upper limit backed up by an array. What we really need to do is that whenever we run out of space, we can resize the array. Array actually cannot be resized, so the operation would be to create a new array with a higher size (maybe twice as much as the original size), and copy all the old elements into this array. Since<a id="id84" class="calibre1"/> this involves copying all the <span class="strong"><em class="calibre12">n</em></span> elements<a id="id85" class="calibre1"/> to the new array one by one, the complexity of this operation is <span class="strong"><em class="calibre12">O(n)</em></span>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Protocols &#x2013; Abstract Data Types">
<div class="book" title="Stack">
<div class="book" title="Variable-sized stack using a linked list"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec27" class="calibre1"/>Variable-sized stack using a linked list</h2></div></div></div><p class="calibre8">The problem <a id="id86" class="calibre1"/>with an  array-based implementation<a id="id87" class="calibre1"/> is that since arrays are fixed in size, the stacks cannot grow beyond a fixed-size. To resolve this, we have to do what we did to fix the same problem for an array, that is, use a linked list instead. We start such an implementation with the following bare bone class. The linked list will store the values. Instead of assigning a new linked list to it, we do so using an overridable method <code class="email">getNewLinkedList()</code>. This will be useful in the class that extends from this one:</p><div class="informalexample"><pre class="programlisting">public class StackImplLinkedList&lt;E&gt; implements Stack&lt;E&gt; {
  protected LinkedList&lt;E&gt; list = getNewLinkedList();

  protected LinkedList&lt;E&gt; getNewLinkedList(){
    return new LinkedList&lt;&gt;();
  }
}</pre></div><p class="calibre8">To see which end of the linked list must be used as the top of the stack, we need to remember that our stack protocol expects the operations to be <span class="strong"><em class="calibre12">O(1)</em></span>, so we must choose an end that allows both insertion and removal in <span class="strong"><em class="calibre12">O(1)</em></span> time. That end is of course the front of the list as we saw in the last chapter. This makes the following code for the <code class="email">push</code> operation self-explanatory:</p><div class="informalexample"><pre class="programlisting">@Override
public void push(E value) {
  list.appendFirst(value);
}</pre></div><p class="calibre8">Note that this time, we did not check whether the stack is full because this implementation of the stack is never full, it grows as it needs and the underlying linked list takes care of that.</p><p class="calibre8">The <code class="email">pop</code> operation, however, does need to check whether the stack is empty and return <code class="email">null</code> at that point. The following code for the <code class="email">pop</code> operation is also quite self-explanatory:</p><div class="informalexample"><pre class="programlisting">@Override
public E pop() {
  if(list.getLength()==0){
    return null;
  }
  E value = list.getFirst();
  list.removeFirst();
  return value;
}</pre></div><p class="calibre8">The <code class="email">peek</code> operation <a id="id88" class="calibre1"/>is, of course, the same, except<a id="id89" class="calibre1"/> it does not remove the top element:</p><div class="informalexample"><pre class="programlisting">@Override
public E peek() {
  if(list.getLength()==0){
    return null;
  }
  return list.getFirst();
}</pre></div><p class="calibre8">This concludes our linked list-based implementation of a stack. In the next section, we will check out <a id="id90" class="calibre1"/>another ADT called a <span class="strong"><strong class="calibre2">queue</strong></span>.</p></div></div></div>

<div class="book" title="Queue" id="NQU21-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec18" class="calibre1"/>Queue</h1></div></div></div><p class="calibre8">What is the <a id="id91" class="calibre1"/>opposite of a stack? This may be a weird question. However, a stack follows LIFO, last in first out. The opposite of that is <span class="strong"><strong class="calibre2">first-in-first-out</strong></span> (<span class="strong"><strong class="calibre2">FIFO</strong></span>). So, in<a id="id92" class="calibre1"/> some sense, a FIFO ADT can be considered as the opposite of a stack. This is not very different from a queue of people waiting for a bus or at a doctor's clinic. The first person to show up gets the first chance to get onto the bus or to get to see the doctor. The second person gets the second chance. No wonder, such <a id="id93" class="calibre1"/>an abstract data type is called a queue. Appending to the end of a queue is called <span class="strong"><strong class="calibre2">enqueuing</strong></span> and removing from it is called <span class="strong"><strong class="calibre2">dequeuing</strong></span>. The <a id="id94" class="calibre1"/>contract is, of course, that the first value that is enqueued would be the first to be dequeued. The following figure illustrates this operation:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00019.jpeg" alt="Queue" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">The queue ADT has the following operations:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Enqueue</strong></span>: This <a id="id95" class="calibre1"/>adds an element at the back of the queue</li><li class="listitem"><span class="strong"><strong class="calibre2">Dequeue</strong></span>: This<a id="id96" class="calibre1"/> removes an element from the front of the queue</li><li class="listitem"><span class="strong"><strong class="calibre2">Peek</strong></span>: This<a id="id97" class="calibre1"/> checks the element that would be dequeued next</li></ul></div><p class="calibre8">The queue will be represented by the following interface:</p><div class="informalexample"><pre class="programlisting">public interface Queue&lt;E&gt; {
  void enqueue(E value);
  E dequeue();
  E peek();
}</pre></div></div>

<div class="book" title="Queue" id="NQU21-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Fixed-sized queue using an array"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec28" class="calibre1"/>Fixed-sized queue using an array</h2></div></div></div><p class="calibre8">Just like the<a id="id98" class="calibre1"/> stack, we have an array-based implementation of a queue. However, since a queue receives new values and removes old<a id="id99" class="calibre1"/> values from opposite sides, the body of the queue moves as it does. The following figure will illustrate this point:</p><p class="calibre8"> </p><div class="mediaobject"><img src="../images/00020.jpeg" alt="Fixed-sized queue using an array" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">
</p><p class="calibre8">This means that after a sequence of a few such operations, the end of the queue will reach the end of the array, and there will be space left at the beginning of the array. At this point, we don't want to stop receiving new values as there is space left, so we roll over to the beginning of the array. That is to say, we continue adding the new values at the beginning of <a id="id100" class="calibre1"/>the array.</p><p class="calibre8">To do all these <a id="id101" class="calibre1"/>manipulations, we must have separate variables storing the indexes of the beginning and the end of the queue. Also, since due to roll over, sometimes the end is smaller than the beginning, we store the length separately to avoid confusion. We start with the bare bone implementation of the class just as before. The start represents the index of the element that would be dequeued next and the end represents the position of the next value that would be enqueued. This is illustrated in the following code:</p><div class="informalexample"><pre class="programlisting">public class QueueImplArray&lt;E&gt;  implements Queue&lt;E&gt;{
  protected E[] array;
  protected int start=0;
  protected int end=0;
  protected int length=0;
  public QueueImplArray(int size){
    array = (E[]) new Object[size];
  }
}</pre></div><p class="calibre8">The <code class="email">enqueue</code> operation does not change the start position. The new value is put at the end position of the array and the end is incremented by one. The end, of course, needs to be rolled over in case it goes beyond the maximum index of the array, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public void enqueue(E value) {
  if(length&gt;=array.length){
    throw new NoSpaceException("No more space to add an element");
  }
  array[end] = value;</pre></div><p class="calibre8">The modulo operator will make sure that the index goes to the beginning of the array when it hits the <code class="email">end</code> of the array, as follows:</p><div class="informalexample"><pre class="programlisting">  end = (end+1) % array.length;
  length++;
}</pre></div><p class="calibre8">The <code class="email">dequeue</code> operation does not change the end position. We read from the start index and then increment the start index with rollover, as follows:</p><div class="informalexample"><pre class="programlisting">@Override
public E dequeue() {
  if(length&lt;=0){
    return null;
  }
  E value = array[start];
  start = (start+1) % array.length;
  length--;
  return value;
}</pre></div><p class="calibre8">The <code class="email">peek</code> operation<a id="id102" class="calibre1"/> lets us see the element that<a id="id103" class="calibre1"/> would be dequeued next, without removing it. It is, of course, simpler. We just return the next element to be dequeued. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">@Override
public E peek() {
  if(length&lt;=0){
    return null;
  }
  return array[start];
}</pre></div><p class="calibre8">A queue backed up by an array can be resized in a similar manner as described for the case of a stack, and this too will be <span class="strong"><em class="calibre12">O(n)</em></span>, since we must copy all the old elements to the newly allocated array one by one.</p></div></div>

<div class="book" title="Queue" id="NQU21-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="Variable-sized queue using a linked list"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec29" class="calibre1"/>Variable-sized queue using a linked list</h2></div></div></div><p class="calibre8">Just like a stack, we want to implement a queue using a linked list. We need to remember that all operations must be <span class="strong"><em class="calibre12">O(1)</em></span> in running time. If we enqueue by appending new elements at the beginning of the linked list, we will need to remove elements from the end of the list during dequeuing. This will not work as removal of an element from the end of a linked list is <span class="strong"><em class="calibre12">O(n)</em></span>. But appending at the end of a linked list is <span class="strong"><em class="calibre12">O(1)</em></span> and so is removing from the beginning of the list. Hence, the end of the queue, where new elements are enqueued, would be the end of the list. And the start of the queue, where the elements are dequeued from, would be the beginning of the linked list.</p><p class="calibre8">Given this, the implementation of a queue using a linked list is straightforward. Again, we create an instance of the list only using a <code class="email">getNewLinkedList()</code> method, which can be overridden by a subclass to use a different linked list, as follows:</p><div class="informalexample"><pre class="programlisting">public class QueueImplLinkedList&lt;E&gt; implements Queue&lt;E&gt;{
  protected LinkedList&lt;E&gt; list = getNewLinkedList();

  protected LinkedList&lt;E&gt; getNewLinkedList(){
    return new LinkedList&lt;&gt;();
  }</pre></div><p class="calibre8">The <code class="email">enqueue</code> operation simply appends at the end of the list as follows:</p><div class="informalexample"><pre class="programlisting">  @Override
  public void enqueue(E value) {
    list.appendLast(value);
  }</pre></div><p class="calibre8">The <code class="email">dequeue</code> operation first checks if the list is empty so it can return <code class="email">null</code>, and then it simply removes<a id="id104" class="calibre1"/> the first element from the list. It must<a id="id105" class="calibre1"/> also return the element that it just removed:</p><div class="informalexample"><pre class="programlisting">  @Override
  public E dequeue() {
    if(list.getLength()==0){
      return null;
    }
    E value = list.getFirst();
    list.removeFirst();
    return value;
  }</pre></div><p class="calibre8">Just like the <code class="email">dequeue</code> operation, the <code class="email">peek</code> operation first needs to check whether the list is empty, in which case it has to return a <code class="email">null</code> value, otherwise it simply returns the element at the beginning of the list that would be dequeued on the next <code class="email">dequeue</code> operation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  @Override
  public E peek() {
    if(list.getLength()==0){
      return null;
    }
    return list.getFirst();
  }
}</pre></div></div></div>

<div class="book" title="Double ended queue"><div class="book" id="OPEK2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec19" class="calibre1"/>Double ended queue</h1></div></div></div><p class="calibre8">A double ended queue is a combination of a stack and a queue. The idea is that you are allowed to<a id="id106" class="calibre1"/> insert and remove elements at both ends of the queue. If you remove elements from the side you have inserted, it will behave like a stack. On the other hand, if you insert and remove on opposite ends, it will behave like a queue. You can mix these operations and use them in any order you like. The following figure shows a few operations to clarify this idea:</p><div class="mediaobject"><img src="../images/00021.jpeg" alt="Double ended queue" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">A double<a id="id107" class="calibre1"/> ended queue has the following operations all with a complexity of <span class="strong"><em class="calibre12">O(n)</em></span>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Push</strong></span>: This <a id="id108" class="calibre1"/>inserts an element at the beginning</li><li class="listitem"><span class="strong"><strong class="calibre2">Pop</strong></span>: This<a id="id109" class="calibre1"/> removes an element from the beginning</li><li class="listitem"><span class="strong"><strong class="calibre2">Inject</strong></span>: This <a id="id110" class="calibre1"/>inserts an element at the end</li><li class="listitem"><span class="strong"><strong class="calibre2">Eject</strong></span>: This<a id="id111" class="calibre1"/> removes an element from the end</li><li class="listitem"><span class="strong"><strong class="calibre2">Peek</strong></span>: This<a id="id112" class="calibre1"/> checks the first element</li><li class="listitem"><span class="strong"><strong class="calibre2">PeekLast</strong></span>: This <a id="id113" class="calibre1"/>checks the last element</li></ul></div><p class="calibre8">A double ended queue  will be represented by the following interface:</p><div class="informalexample"><pre class="programlisting">public interface DoubleEndedQueue&lt;E&gt; extends Stack&lt;E&gt; {
  void inject(E value);
  E eject();
  E peekLast();
}</pre></div><p class="calibre8">Note that since a<a id="id114" class="calibre1"/> double ended queue has <code class="email">push</code> and <code class="email">pop</code> operations just like a stack and it preserves the same meaning, we create this interface extending the <code class="email">Stack</code> interface.</p></div>

<div class="book" title="Double ended queue">
<div class="book" title="Fixed-length double ended queue using an array"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec30" class="calibre1"/>Fixed-length double ended queue using an array</h2></div></div></div><p class="calibre8">Since we have<a id="id115" class="calibre1"/> created the double ended queue as an extension of a stack, one would expect its implementation to extend a stack implementation as well. However, remember that a double <a id="id116" class="calibre1"/>ended queue is both a stack and a queue. The array-based implementation for a queue was more complex than that for a stack due to rollover of the indexes. We don't want to reprogram those, so we choose to extend a queue implementation instead of a stack implementation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public class DoubleEndedQueueImplArray&lt;E&gt; extends QueueImplArray&lt;E&gt; implements DoubleEndedQueue&lt;E&gt; {</pre></div><p class="calibre8">We initialize the queue to the fixed length, as follows:</p><div class="informalexample"><pre class="programlisting">  public DoubleEndedQueueImplArray(int size) {
    super(size);
  }</pre></div><p class="calibre8">This is appended at the end of the double ended queue, which is the same as the <code class="email">enqueue</code> operation of a queue:</p><div class="informalexample"><pre class="programlisting">  @Override
  public void inject(E value) {
    enqueue(value);
  }</pre></div><p class="calibre8">The <code class="email">eject</code> operation is the removal of an element from the end of the double ended queue. We don't have an equivalent operation in a simple queue. So, we must code for it as follows:</p><div class="informalexample"><pre class="programlisting">  @Override
  public E eject() {
    if (length &lt;= 0) {
      return null;
    }</pre></div><p class="calibre8">The <code class="email">end</code> has to decrement by one with a provision for rollover. But if the <code class="email">end</code> is already at zero, it will become negative, which will not work well with the modulo operator, because it will return a negative value. To always keep it positive, we add the length of the array<a id="id117" class="calibre1"/> to it. Note that it does not change the remainder when divided by the length of the array. This is <a id="id118" class="calibre1"/>shown in the following code:</p><div class="informalexample"><pre class="programlisting">    end = (end + array.length - 1) % array.length;
    E value = array[end];
    length--;
    return value;
  }</pre></div><p class="calibre8">The <code class="email">peekLast</code> operation simply needs to return the element that would have been returned by the <code class="email">eject</code> operation without modifying anything, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  @Override
  public E peekLast() {
    if (length &lt;= 0) {
      return null;
    }
    return array[(end + array.length - 1) % array.length];
  }</pre></div><p class="calibre8">The <code class="email">push</code> operation is the insertion of an element at the beginning of the double ended queue. There is no equivalent operation in a simple queue. Hence, we need to code for it as follows:</p><div class="informalexample"><pre class="programlisting">  @Override
  public void push(E value) {
    if (length &gt;= array.length) {
      throw new NoSpaceException("No more space to add an element");
    }</pre></div><p class="calibre8">This operation is very similar to updating the end index <code class="email">eject</code> operation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">    start = (start + array.length - 1) % array.length;
    array[start] = value;
    length++;
  }</pre></div><p class="calibre8">The <code class="email">pop</code> operation is the removal of the element at the beginning of the queue, which is the same as the <code class="email">dequeue</code> operation of an ordinary queue. This is illustrated in the following code:</p><div class="informalexample"><pre class="programlisting">  @Override
  public E pop() {
    return dequeue();
  }
}</pre></div><p class="calibre8">Note that <a id="id119" class="calibre1"/>we don't <a id="id120" class="calibre1"/>write any code for the peek operation, which should return the element at the beginning of the double ended queue, as it is the same as the peek operation for a simple queue.</p><p class="calibre8">The array-based implementation is, of course, fixed in size and cannot hold more elements than it's fixed size. Next, we develop a linked list-based implementation.</p></div></div>

<div class="book" title="Double ended queue">
<div class="book" title="Variable-sized double ended queue using a linked list"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec31" class="calibre1"/>Variable-sized double ended queue using a linked list</h2></div></div></div><p class="calibre8">We had <a id="id121" class="calibre1"/>earlier <a id="id122" class="calibre1"/>used a simple linked list to implement both a queue and a stack. However, remember again that all operations must be <span class="strong"><em class="calibre12">O(1)</em></span>. Now, we must both add and remove elements at both ends of the underlying linked list. We know that removal from the end of a singly linked list is <span class="strong"><em class="calibre12">O(n)</em></span> and we cannot use it. So, we must use a doubly linked list instead.</p><p class="calibre8">This time we do not have to worry about rollovers and so we will extend the linked list implementation of a stack, which is the natural choice. We will replace its singly linked list with a doubly linked list by overriding the <code class="email">getLinkedList()</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">public class DoubleEndedQueueImplLinkedList&lt;E&gt; extends StackImplLinkedList&lt;E&gt; implements DoubleEndedQueue&lt;E&gt; {

  @Override
  protected LinkedList&lt;E&gt; getNewLinkedList() {
    return new DoublyLinkedList&lt;E&gt;();
  }</pre></div><p class="calibre8">The <code class="email">inject</code> operation inserts a new element at the end of the list as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  @Override
  public void inject(E value) {
    list.appendLast(value);
  }</pre></div><p class="calibre8">The <code class="email">eject</code> operation must remove and return the last element of the list. This is illustrated<a id="id123" class="calibre1"/> in the <a id="id124" class="calibre1"/>following code:</p><div class="informalexample"><pre class="programlisting">  @Override 
  public E eject() {
    if(list.getLength()==0){
      return null;
    }
    E value = list.getLast();
    list.removeLast();
    return value;
  }</pre></div><p class="calibre8">Finally, the <code class="email">peekLast()</code> method will just return the last element of the doubly linked list as follows:</p><div class="informalexample"><pre class="programlisting">  @Override
  public E peekLast() {
    if(list.getLength()==0){
      return null;
    }
    return list.getLast();
  }
}</pre></div><p class="calibre8">We only had to implement the <code class="email">inject()</code>, <code class="email">eject()</code>, and <code class="email">peekLast()</code> methods as the other methods are already implemented by the stack we extend.</p></div></div>
<div class="book" title="Summary" id="PNV61-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec20" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we saw that an abstract data type or ADT is an abstraction of a data structure. It is a contract that an underlying data structure is supposed to adhere to. The contract involves different operations on the data structure and their specific behavior. We then saw a few simple ADTs as examples. These ADTs are, however, extremely useful as we will see in the course of this book when we encounter other algorithms. Abstraction allows different implementations of the structures. We will also see more ADTs in the course of this book and their implementations.</p><p class="calibre8">In the next chapter, we will take a detour into a new area of algorithms called <span class="strong"><strong class="calibre2">functional programming</strong></span>. Remember that an algorithm is a sequence of steps that may be followed to achieve a desired processing; it turns out that there is another way of looking at it, which we will explore in the next chapter.</p></div></body></html>