- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the Nature of Driving and Driven Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We spent the previous chapters analyzing the elements comprising each hexagon
    in the **hexagonal architecture**. We learned about entities, value objects, and
    business rules, and how to arrange them in the Domain hexagon to create a meaningful
    domain model. After that, when dealing with the Application hexagon, we learned
    how to utilize use cases and ports to create fully fledged software features on
    top of the domain model. Finally, we learned how to create adapters to integrate
    the hexagonal application features with different technologies.
  prefs: []
  type: TYPE_NORMAL
- en: To better comprehend a hexagonal system, we also need to be aware of its surroundings.
    That’s why, in this chapter, we explore the nature of driving and driven operations,
    as they represent the external elements interacting with the hexagonal application.
    On the driving side, we’ll see how frontend applications act as primary actors,
    driving the behavior of a hexagonal system. On the driven side, we will learn
    what is necessary to enable a message-based system to be driven by a hexagonal
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reaching the hexagonal application with driving operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating web applications with the hexagonal system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running test agents and calling the hexagonal system from other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling external resources with driven operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know the most common driving and driven
    operations. Once you understand these operations and how they influence the inner
    structure of a hexagonal system, you’ll have learned all the building blocks of
    the hexagonal architecture, enabling you to develop complete hexagonal applications
    while leveraging all the techniques presented so far.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the code examples presented in this chapter, you need the
    **Java SE Development Kit** (**JDK**) (version 17 or higher) and **Maven 3.8**
    installed on your computer. They are all available for **Linux**, **Mac**, and
    **Windows** operating systems. You will also need to download these tools: **Postman**,
    **Newman** (from **npm**), and **Kafka**. We recommend using Linux to run Kafka
    properly. If you’re using a Windows system, you can use **Windows Subsystem for
    Linux** (**WSL**) to run Kafka.'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest version of Kafka from [https://kafka.apache.org/downloads.html](https://kafka.apache.org/downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest version of Postman from [https://www.postman.com/downloads](https://www.postman.com/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest version of Newman from [https://www.npmjs.com/package/newman](https://www.npmjs.com/package/newman).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: Reaching the hexagonal application with driving operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may consider it inconceivable that a system can be self-contained in the
    sense that no one interacts with it and that this system doesn’t interact with
    other users or systems. Such an arrangement goes against the fundamentals of computer
    architecture (von Neumann, 1940), which presume the presence of input and output
    operations in any computer system. Indeed, it’s difficult to imagine a useful
    software program that doesn’t receive any data or produce any result.
  prefs: []
  type: TYPE_NORMAL
- en: Through the lens of the hexagonal architecture, the input side of a system is
    controlled by driving operations. We call them *driving operations* because they
    actually initiate and drive the behavior of a hexagonal application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B19777_03.xhtml#_idTextAnchor066), *Handling Behavior with
    Ports and Use Cases*, we related driving operations to primary actors. These actors
    are in charge of triggering driving operations in the hexagonal system. The driving
    operations can assume different facets: they can be users interacting directly
    with the system through a command-line console, a web **User Interface** (**UI**)
    application requesting data to present it in a browser, a testing agent wanting
    to validate a specific test case, or any other system interested in the features
    exposed by the hexagonal application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these different facets are grouped on the **driving side**, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The driving side and the hexagonal application](img/B19777_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The driving side and the hexagonal application
  prefs: []
  type: TYPE_NORMAL
- en: We saw, in the previous chapter, how to interact with a hexagonal application
    using a **Command-Line Interface** (**CLI**) and through **HTTP REST**. Now, we’ll
    explore how to integrate other types of driving operations to communicate with
    the topology and inventory system we’ve been developing so far.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have these integrations in place, we will analyze the path a request
    needs to take in order to traverse all the hexagons until it reaches the Domain
    one. This exercise will help us to understand the role played by each hexagon
    and its components in processing the request of a driving operation. So, let’s
    start by integrating a web UI with the hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating web applications with the hexagonal system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, with the advent of **HTML** **5**, modern **JavaScript**, and continuously
    improving web development techniques, it’s possible to build highly sophisticated
    systems that run directly from the web browser. Faster internet connections, more
    computational resources, and better and well-established web standards have all
    contributed to the improvement of web applications. The old and cluttered **Flash**
    or **Java applet**-based systems, for example, have been replaced by frontend
    applications based on fancy frameworks such as **Angular**, **React**, or **Vue**.
  prefs: []
  type: TYPE_NORMAL
- en: Not only has the technology evolved and changed, but the practices surrounding
    web development have evolved too. Encouraged by the `.ear` or `.war` package file,
    it wasn’t rare to see that the business logic had leaked into the presentation
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java EE** (now **Jakarta EE**) and other frameworks, such as **Struts**,
    utilized technologies such as **Servlets**, **JSP**, and **JSF** to allow full
    integration between presentation and business code. After some time, people started
    to realize that this practice of putting frontend and backend code too close to
    each other could be a source of entropy for their software projects.'
  prefs: []
  type: TYPE_NORMAL
- en: As a response to such practices, the industry turned to decoupled architectures
    where the frontend system is a separate, standalone application that interacts
    via the network with one or more backend systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will create a simple, standalone frontend application that obtains its
    data from our topology and inventory system. Our application will be based only
    on HTML 5, CSS, and *vanilla* JavaScript. The application aims to allow users
    to add networks to a router and retrieve existing routers from the system database.
    We will also refactor part of the hexagonal application to enable better integration
    with our frontend application. The result will be a web browser application integrated
    with the hexagonal system, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The Topology & Inventory frontend application](img/B19777_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The Topology & Inventory frontend application
  prefs: []
  type: TYPE_NORMAL
- en: The frontend application will allow users to add networks to an existing router
    and view a graphical representation of the router and its networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start enhancing the hexagonal application by adding the `getRouter` method
    to the `RouterNetworkUseCase` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `getRouter` method signature is simple. It receives `RouterId` and returns
    a `Router` object. We need this behavior to allow the frontend application to
    display a router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to provide an implementation for the `getRouter` method. We do
    that by implementing the `RouterNetworkUseCase` interface with the `RouterNetworkInputPort`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `fetchRouter` already existed in the input port implementation,
    but we didn’t have an exposed operation that allowed us to retrieve the router.
    The `fetchRouter` method is then used not only by the `addNetworkToRouter` method
    but now also by `getRouter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s necessary to propagate the input port change to the input adapter. We
    do that by creating a `getRouter` method on the base input adapter defined in
    the `RouterNetworkAdapter` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `RouterNetworkAdapter` is the base input adapter for both `RouterNetworkCLIAdapter`
    and `RouterNetworkRestAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the frontend application to communicate with the hexagonal system,
    we’ll use the REST adapter. So, there are some changes we need to make in `RouterNetworkRestAdapter`
    to allow this communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The changes to the `processRequest` method were made so it can properly handle
    requests coming from the `/network/add` and `/``network/get` paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can move now to the development of the frontend part of our topology and
    inventory system. Our focus will be on the HTML and JavaScript elements. We’ll
    create two pages: the first one is to allow users to add networks, and the second
    one is where users will be able to retrieve a graphical view of a router and its
    networks.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Add Network page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating the first HTML page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The Add Network page of the Topology & Inventory frontend application](img/B19777_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The Add Network page of the Topology & Inventory frontend application
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Add Network** page contains a form, where users are asked to type the
    necessary data to add a network to an existing router. Here is the code for the
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to process the preceding `addNetworkToRouter`, which is present in
    the `networkTools.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `XMLHttpRequest` object to process `GET` requests in the `/network/add`
    endpoint exposed by the REST adapter in the hexagonal application. It is a short
    JavaScript code that captures the values entered in the HTML form, processes them,
    and then shows a success message if everything goes okay or an error message if
    not, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Adding a new network to the topology and inventory application](img/B19777_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Adding a new network to the topology and inventory application
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the creation of the **Get** **Router** page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Get Router page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Get Router** page contains an HTML form to process the user request,
    but it also provides a graphical view based on the JSON response obtained from
    the hexagonal application. Let’s start by considering the HTML form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The Get Router page of the topology and inventory frontend application](img/B19777_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The Get Router page of the topology and inventory frontend application
  prefs: []
  type: TYPE_NORMAL
- en: The **Get Router** HTML page follows the same structure as the one we used on
    the **Add Network** page, but this form uses only one parameter to query a router
    from the hexagonal application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a JSON-based graphical view of the router and its networks, we’ll
    use a JavaScript library called `D3` that consumes the JSON data and produces
    the graphical view. The JavaScript code processes the form, and then it uses the
    JSON response with the `D3` libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are passing the `/network/get` endpoint defined previously in the hexagonal
    application. The `getRouter` function processes the `GET` requests and uses the
    JSON response as the parameter for the `createTree` function that will construct
    the graphical view of the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we fill the form with the router ID, `ca23800e-9b5a-11eb-a8b3-0242ac130003`,
    to retrieve a router, the result we get is like the one shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The network graphical view provided by the Get Router page](img/B19777_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The network graphical view provided by the Get Router page
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the data presented in the preceding screenshot came ultimately from
    the H2 in-memory database that we attached directly to the REST input adapter
    used here by the frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how test agents can be integrated with the topology and inventory
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Running test agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from frontend applications, another common type of driven operation comes
    from test and monitoring agents interacting with the hexagonal system to verify
    whether its features are working well. With tools such as Postman, we can create
    comprehensive test cases to validate how the application behaves when faced with
    certain requests.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can periodically issue requests to certain application endpoints
    to check whether they are healthy. This practice has been popularized with tools
    such as **Spring Actuator**, which provides a specific endpoint in the application
    that allows you to check whether it’s healthy. Also, some techniques involve the
    use of probe mechanisms that periodically send a request to the application to
    see whether it is alive. For example, if the application is not alive or is causing
    timeouts, then it can be automatically restarted. In cloud-native architectures
    based on **Kubernetes**, it’s common to see systems using probe mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: This section will explore how to run a simple test case to confirm whether the
    application behaves according to our expectations. There will be no need to change
    the topology and inventory system we have been developing so far. Here, we will
    create a test case using a tool called Postman. In Postman, test cases are known
    as **testing collections**. Once these testing collections are made, we can execute
    them using **Newman**, which is a CLI tool used specifically to run Postman collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, you have to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download both Postman and Newman. The download links are available in the *Technical
    requirements* section. The collection used in this chapter is also present in
    the chapter’s GitHub repository ([https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/blob/main/Chapter05/topology-inventory.postman_collection.json](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/blob/main/Chapter05/topology-inventory.postman_collection.json)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the collection to Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once imported, the collection will present two requests. One request is for
    the `getRouter` endpoint and the other is for `addNetwork`. The following screenshot
    shows how the two requests should appear after importing the collections to Postman:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The topology and inventory collection from Postman](img/B19777_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The topology and inventory collection from Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the test on Postman, be sure to bring up the topology and inventory
    application by running the following command from the project’s `root` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we want to validate whether the returned value is what we are expecting.
    In this case, we expect to encounter only three networks in the system: `HR`,
    `Marketing`, and `Engineering`. In Postman, we create tests for each request.
    So, we will create tests for the two requests present in the collection we imported.
    Let’s start by creating a test for the `getRouter` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we first check whether the HTTP response code is `200`.
    Then, we proceed to parse and peek at the JSON response data to see whether it
    matches what we expect. In this test, we expect a response containing a router
    with a switch comprising three networks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The test from the `addNetwork` request is similar to the `getRouter` request’s
    test. The difference, though, is that the response expected this time contains
    the additional `Finance` network, as we can see in the following test code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `addNetwork` request in that collection adds a network named `Finance`.
    That’s why we are only checking to see whether the `Finance` network was correctly
    added. Also, we expect the length of the list of networks to be `4` after adding
    the `Finance` network.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you want to run these tests from outside Postman, you can do that by first
    exporting the collection to a `.json` file, then using Newman to execute the tests
    from that collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is something like the one presented in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Running topology and inventory application tests with Newman](img/B19777_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Running topology and inventory application tests with Newman
  prefs: []
  type: TYPE_NORMAL
- en: This kind of test execution using Newman is ideal for integrating the hexagonal
    application into **Continuous Integration** (**CI**) pipelines. Developers use
    Postman to create collections and their respective tests, and these same collections
    are triggered and validated through CI tools (such as **Jenkins**) that can use
    Newman to execute the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are acquainted with both frontend applications and test agents as
    means of driving operations, let’s check out one more type of driving operation.
    Next, we will discuss the driving operation that occurs in distributed or microservices
    architecture, where different applications from the same system communicate through
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the hexagonal system from other applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a recurring debate about whether to develop a monolith or microservices
    system. In a monolith, we have data flowing directly between objects and method
    calls. All the software instructions are grouped in the same application, diminishing
    the communication overhead and centralizing the logs generated by the system.
  prefs: []
  type: TYPE_NORMAL
- en: With both microservices and a distributed system, we have part of the data flowing
    through the network between standalone, self-contained applications that cooperate
    in providing the features of the whole system. This approach decouples the development,
    allowing more modularized components. It also improves compilation times because
    the packages are smaller, contributing to faster feedback loops in CI tools. Microservices,
    though, offer some challenges because the logs are not centralized anymore, and
    the network communication overhead can represent a limiting factor, depending
    on the system’s purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a distributed approach, two or more hexagonal self-contained systems can
    comprise the whole hexagonal-based system. In such a scenario, the hexagonal **System
    A** that initiates the request acts as a primary actor and triggers a driving
    operation on the hexagonal **System B**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Multiple hexagonal applications](img/B19777_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Multiple hexagonal applications
  prefs: []
  type: TYPE_NORMAL
- en: Note that **System A** triggers a request through one of its output adapters.
    This request goes directly to one of the input adapters from **System B**. An
    exciting thing about distributed architecture is that you don’t need to use the
    same programming language to develop all the system components.
  prefs: []
  type: TYPE_NORMAL
- en: In a distributed architecture scenario, we could write **System A** in Java
    and **System B** in Python. As long as they agree on a common medium of communication
    – JSON and HTTP, for example – they can cooperate in the same system. With the
    advent of container technologies such as Docker and Kubernetes, it’s not a big
    deal to have a technology-hybrid system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has looked at what driving operations are and how we can use them
    to interact with the hexagonal system. In the next section, we’ll see the other
    side of the coin: driven operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling external resources with driven operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A general characteristic of business applications is their need to send or request
    data from other systems. We’ve already seen that output ports and adapters are
    the hexagonal architecture components we use to allow the hexagonal system to
    interact with external resources without compromising the business logic. These
    external resources are also known as *secondary actors* and provide data or capabilities
    absent in the hexagonal application that requests them.
  prefs: []
  type: TYPE_NORMAL
- en: When the hexagonal application sends a request to a secondary actor – generally,
    on behalf of a primary actor who first triggered a driving operation from one
    of the hexagon application’s use cases – we call such a request a *driven* operation.
    It’s driven because these operations are controlled and driven by the hexagonal
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *driving* operations come from the primary actor’s requests that drive
    the behavior of a hexagonal system, whereas *driven* operations are the requests
    initiated by the hexagonal application itself toward secondary actors (such as
    databases or other systems). The following diagram shows the driven side with
    some examples of driven operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The driven side and the hexagonal application](img/B19777_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – The driven side and the hexagonal application
  prefs: []
  type: TYPE_NORMAL
- en: This section will explore some of the possible driven operations a hexagonal
    application can perform, as shown in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Data persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Driven operations based on data persistence are the most common. The H2 output
    adapter we created in [*Chapter 4*](B19777_04.xhtml#_idTextAnchor083), *Creating
    Adapters to Interact with the Outside World*, is one example of a driven operation
    that deals with data persistence by utilizing an in-memory database. This kind
    of driven operation often leverages **Object-Relational Mapping** (**ORM**) techniques
    to handle and translate objects between the hexagonal system and a database. In
    the Java world, **Hibernate** and **EclipseLink** provide robust **Java Persistence
    API** (**JPA**) implementations with ORM features.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction mechanisms are also a part of persistence-based driven operations.
    When working with transactions, we can make the hexagonal system directly deal
    with transactional boundaries or delegate this responsibility to an application
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging and events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not every system relies only on synchronous communication. Depending on the
    situation, you may want to trigger events about your *stuff* without interrupting
    the runtime flow of your application.
  prefs: []
  type: TYPE_NORMAL
- en: There are types of architecture strongly influenced by techniques where the
    communication between system components occurs asynchronously. These systems become
    more loosely coupled by employing such techniques because their components are
    no longer attached to the interfaces provided by other applications. Instead of
    relying solely on APIs blocking connections, we let messages and events drive
    the behavior of applications in a non-blocking way.
  prefs: []
  type: TYPE_NORMAL
- en: By *blocking*, we mean those connections that need to wait for a response to
    allow the application flow to proceed. The non-blocking approach allows an application
    to send a request and move forward without the need for an immediate response.
    There are also situations where an application reacts to messages or events to
    take some action.
  prefs: []
  type: TYPE_NORMAL
- en: Message-based systems are secondary actors driven by the hexagonal application.
    Unlike databases, where the communication will start from the hexagonal application,
    there are scenarios where the message-based system will start the communication
    with the hexagonal application. But, to receive or send messages, the hexagonal
    system always needs to first establish a flow of communication with a message
    system. Such a scenario is widespread when dealing with technologies such as Kafka,
    where the application can be both a consumer and producer of messages. To be integrated
    with a message system such as Kafka, the hexagonal application needs to express
    its intent by joining a **Kafka** **topic**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how a message-based system integrates with a hexagonal
    application, we’ll implement a feature in our topology and inventory system to
    allow us to see events produced by the application. The backend hexagonal part
    of the system will send events to Kafka, and the frontend will consume those events
    in real time and display them in the web browser. We’ll implement this feature
    by executing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by bringing up Kafka and creating a topic for our application.
    The Kafka download URL is available in the *Technical requirements* section. Once
    you have downloaded the latest Kafka version, extract it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'broker service:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, Kafka is up and running in your environment. Let’s now create
    the topic for our application in a third shell session or tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public interface NotifyEventOutputPort {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void sendEvent(String Event);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: String getEvent();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we implement the output port with the `NotifyEventKafkaAdapter` output
    adapter. We start the `NotifyEventKafkaAdapter` adapter implementation by first
    defining the Kafka connection properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `KAFKA_BROKERS` variable value, set to `localhost:9092`, corresponds
    to the host and port used to bootstrap the Kafka topic. The `TOPIC_NAME` variable
    value, set to `topology-inventory-events`, represents the topic that we use to
    produce and consume messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s move on now to create the method to send messages to our Kafka topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getProducer` method configures the Producer properties by setting the required
    attributes in the `ProducerConfig` class. Then, it returns a `KafkaProducer` instance,
    which we use to produce messages in the Kafka topic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the other hand, we have the `getConsumer` method, which consumes the messages
    generated by the `Producer` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `getConsumer` method, we use the `ConsumerConfig` class to set the
    required properties. This method returns a `KafkaConsumer` instance that we use
    to consume and read messages from the Kafka topic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Moving ahead, we override the first method, `sendEvent`, declared in `NotifyEventOutputPort`.
    It’s with this method that we’ll be able to send messages to the Kafka P`roducer`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line of the `sendEvent` method creates a `ProducerRecord` instance
    that informs the constructor parameters about the topic name and the message we
    intend to send as an event. Near the end, we have a call to the `getEvent` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we shall see next in more detail, we call this method to consume messages
    from Kafka and forward them to a `WebSocket` server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getEvent` method relies on the `KafkaConsumer` instance assigned to the
    `consumer` variable. With that instance, it retrieves messages from the Kafka
    topic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After retrieving the message, the `getEvent` method calls the `sendMessage`
    method to forward that message to the `WebSocket` server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `sendMessage` method receives a parameter as a string, containing the consumed
    Kafka topic message. It then forwards that message to a `WebSocket` server running
    on port `8887`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s see briefly how that `WebSocket` server is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `startServer` method creates an instance of `NotifyEventWebSocketAdapter`,
    containing the host and port of the `WebSocket` server. When we are starting the
    hexagonal application, one of the first things that occurs is the calling of the
    `startServer` method to bring up the WebSocket server on port `8887`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with a WebSocket server class, we also need to implement a WebSocket
    client class to process the events coming from Kafka:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When a message is consumed from the Kafka topic, the hexagonal application uses
    `WebSocketClientAdapter` to forward the message to the WebSocket server. The `onMessage`,
    `onOpen`, `onClose`, and `onError` methods represent the WebSocket protocol operations
    that the `WebSocketClientAdapter` class needs to support.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the hexagonal application is to make the `addNetworkToRouter`
    and `getRouter` methods send events using the ports and adapters we have just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that now we are calling `sendEvent` on both methods (`addNetworkToRouter`
    and `getRouter`), so whenever we add a network or retrieve a router, the hexagonal
    application will send an event informing us what has happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add an **Events** page to allow the frontend application to connect
    with the WebSocket server from the hexagonal application. The following screenshot
    shows us the **Events** page that we’ll create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The topology and inventory application Events page](img/B19777_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The topology and inventory application Events page
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Events** page follows the same structure we used in previous pages. The
    important part of this page is the JavaScript code utilized to connect users to
    the WebSocket server exposed by our hexagonal application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onmessage` method creates and appends a new `div` HTML element for every
    new message received from the WebSocket connection. So, every event generated
    by the hexagonal application will be sent to Kafka and printed in real time in
    the frontend application. The communication between the frontend, the hexagonal
    application with WebSocket, and the Kafka message system is represented in the
    following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The flow between the frontend, the hexagonal application with
    WebSocket, and the message system](img/B19777_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – The flow between the frontend, the hexagonal application with
    WebSocket, and the message system
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this flow, make sure to have your local Kafka instance running. Then,
    start the hexagonal application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a WebSocket connection between your browser and the application,
    you need to open the `ca23800e-9b5a-11eb-a8b3-0242ac130003` ID. The event entries
    will appear as follows on the **Events** page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 –  The frontend application receiving events from Kafka through
    a WebSocket connection](img/B19777_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – The frontend application receiving events from Kafka through a
    WebSocket connection
  prefs: []
  type: TYPE_NORMAL
- en: This integration using Kafka and WebSockets has shown us how a hexagonal application
    deals with message-driven operations. We didn’t need to touch the business logic
    to add these technologies. All we had to do was create more ports and adapters
    to augment the system’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s briefly see one more type of driven operation that a hexagonal application
    can handle.
  prefs: []
  type: TYPE_NORMAL
- en: Mock servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The typical approach for software development is to have multiple environments,
    such as development, QA, and production. The first working software releases start
    going to development environments and then progressively make their way to production.
    This journey to production is generally conducted by CI pipelines that constantly
    validate and ensure the software is working well.
  prefs: []
  type: TYPE_NORMAL
- en: Among CI validations, unit and integration tests may happen during the pipeline
    execution. Integration tests, in particular, depend on external components such
    as other applications, systems, databases, and services – all of them provided
    in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: The execution of integration tests in development environments poses a low risk
    but can cause problems if there is, for example, concurrent usage of resources.
    This concurrency issue can generate inconsistency in test results. For QA, the
    situation is slightly more complicated because we must ensure consistency when
    dealing with test data explicitly tailored to specific scenarios. If that test
    data changes inadvertently, we may find inconsistencies in test results. We need
    to be careful because the cost of test failures in QA is even higher than in development
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: In order to overcome testing obstacles, some tools simulate application endpoints
    and their responses. Those tools are known as **mock solutions**, and they come
    in various shapes and forms. You can manually mock the responses and endpoints
    of a service that your application needs; however, this is not always trivial,
    and it may take considerable effort. Also, there are sophisticated tools that
    do the dirty work and let you focus just on the logic. That is the role of mocking
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Because mocking servers act as an external entity providing useful resources
    to the application, we also consider them secondary actors driven by a hexagonal
    system that wants to leverage mocking server capabilities instead of hitting actual
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: By no means have we exhausted all the possible driven operations a hexagonal
    system can have. But, in this section, we peeked into some of the relevant driven
    operations present in a hexagonal application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had the opportunity to dive deep into the nature of driving
    and driven operations. Although we had already dealt with them in previous chapters,
    we examined these operations in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with *driving operations*, we learned that they drive the hexagonal
    application behavior by calling its input adapters. To illustrate driving operations,
    we first created a frontend application to play the role of a primary actor requesting
    data through the input adapters provided by the topology and inventory hexagonal
    application. Then, to explore testing tools as driving operations, we created
    a Postman collection with tests based on API endpoints exposed by the hexagonal
    application.
  prefs: []
  type: TYPE_NORMAL
- en: On the *driven operations* side, we saw how to enable the hexagonal application
    to work with message-based systems such as Kafka. To better understand the effects
    of message-based systems on the hexagonal application, we created ports and adapters
    that enabled the application to send and consume messages from Kafka. Also, we
    made a WebSocket server to let the frontend application retrieve the events generated
    by the hexagonal system in real time.
  prefs: []
  type: TYPE_NORMAL
- en: By handling different kinds of driving and driven operations, we can now better
    comprehend the inner workings of a hexagonal system, its surroundings, and how
    the driving and driven operations influence the hexagonal application.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals acquired from this chapter and the previous ones provide all
    the building blocks to start developing robust, change-tolerant systems with the
    hexagonal architecture instruments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll apply the things we have learned to initiate the
    construction of a production-grade hexagonal system that will incorporate features
    from the Java module system and **Quarkus** framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are driving operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give one example of a driving operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are driven operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give one example of a driven operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving operations are requests initiated by the primary actors that drive the
    hexagonal application’s behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A frontend application calling a hexagonal system through one of its input adapters
    is an example of a driving operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Driven operations are requests initiated by the hexagonal application itself,
    generally on behalf of a use case need, toward secondary actors driven by a hexagonal
    system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the hexagonal application accesses a database. In this case, the database
    is driven by the hexagonal application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 2: Using Hexagons to Create a Solid Foundation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By following a real-world example of a system that manages a telco's network
    and topology inventory, in this part, you will learn how to implement the building
    blocks for creating such a system using hexagonal architecture ideas.
  prefs: []
  type: TYPE_NORMAL
- en: This is a hands-on part where we'll have the opportunity to get our hands dirty
    while applying the hexagonal architecture principles. We start by implementing
    the Domain hexagon, which contains the domain model of the topology and inventory
    system. Then, we implement the Application hexagon by using use cases and ports
    to express system behaviors. To enable and expose the features provided by the
    hexagonal system, we use adapters to implement the Framework hexagon. Closing
    this part, we learn how to use Java modules to apply dependency inversion in our
    hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19777_06.xhtml#_idTextAnchor126), *Building the Domain Hexagon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19777_07.xhtml#_idTextAnchor152), *Building the Application
    Hexagon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19777_08.xhtml#_idTextAnchor174), *Building the Framework Hexagon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19777_09.xhtml#_idTextAnchor192), *Applying Dependency Inversion
    with Java Modules*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
