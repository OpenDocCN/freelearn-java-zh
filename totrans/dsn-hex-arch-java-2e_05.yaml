- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Exploring the Nature of Driving and Driven Operations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索驾驶和被驱动操作的本质
- en: We spent the previous chapters analyzing the elements comprising each hexagon
    in the **hexagonal architecture**. We learned about entities, value objects, and
    business rules, and how to arrange them in the Domain hexagon to create a meaningful
    domain model. After that, when dealing with the Application hexagon, we learned
    how to utilize use cases and ports to create fully fledged software features on
    top of the domain model. Finally, we learned how to create adapters to integrate
    the hexagonal application features with different technologies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们分析了构成每个六边形的**六边形架构**的元素。我们学习了实体、值对象和业务规则，以及如何将它们安排在领域六边形中，以创建一个有意义的领域模型。之后，当处理应用六边形时，我们学习了如何利用用例和端口在领域模型之上创建完整的软件功能。最后，我们学习了如何创建适配器，以将六边形应用功能与不同技术集成。
- en: To better comprehend a hexagonal system, we also need to be aware of its surroundings.
    That’s why, in this chapter, we explore the nature of driving and driven operations,
    as they represent the external elements interacting with the hexagonal application.
    On the driving side, we’ll see how frontend applications act as primary actors,
    driving the behavior of a hexagonal system. On the driven side, we will learn
    what is necessary to enable a message-based system to be driven by a hexagonal
    system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解六边形系统，我们还需要了解其周围环境。这就是为什么在本章中，我们探讨了驱动和被驱动操作的本质，因为它们代表了与六边形应用交互的外部元素。在驱动方面，我们将看到前端应用如何作为主要演员，驱动六边形系统的行为。在被驱动方面，我们将学习使基于消息的系统能够被六边形系统驱动所必需的条件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reaching the hexagonal application with driving operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过驱动操作达到六边形应用
- en: Integrating web applications with the hexagonal system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Web应用与六边形系统集成
- en: Running test agents and calling the hexagonal system from other applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试代理并从其他应用程序调用六边形系统
- en: Handling external resources with driven operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用驱动操作处理外部资源
- en: By the end of this chapter, you will know the most common driving and driven
    operations. Once you understand these operations and how they influence the inner
    structure of a hexagonal system, you’ll have learned all the building blocks of
    the hexagonal architecture, enabling you to develop complete hexagonal applications
    while leveraging all the techniques presented so far.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解最常见的驱动和被驱动操作。一旦您理解了这些操作以及它们如何影响六边形系统的内部结构，您就将学会六边形架构的所有构建块，这将使您能够在利用迄今为止所展示的所有技术的同时开发完整的六边形应用。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the code examples presented in this chapter, you need the
    **Java SE Development Kit** (**JDK**) (version 17 or higher) and **Maven 3.8**
    installed on your computer. They are all available for **Linux**, **Mac**, and
    **Windows** operating systems. You will also need to download these tools: **Postman**,
    **Newman** (from **npm**), and **Kafka**. We recommend using Linux to run Kafka
    properly. If you’re using a Windows system, you can use **Windows Subsystem for
    Linux** (**WSL**) to run Kafka.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，您需要在您的计算机上安装**Java SE开发工具包**（**JDK**）（版本17或更高）和**Maven 3.8**。它们都适用于**Linux**、**Mac**和**Windows**操作系统。您还需要下载以下工具：**Postman**、**Newman**（来自**npm**）和**Kafka**。我们建议使用Linux来正确运行Kafka。如果您使用的是Windows系统，您可以使用**Windows子系统（WSL**）来运行Kafka。
- en: You can download the latest version of Kafka from [https://kafka.apache.org/downloads.html](https://kafka.apache.org/downloads.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://kafka.apache.org/downloads.html](https://kafka.apache.org/downloads.html)下载Kafka的最新版本。
- en: You can download the latest version of Postman from [https://www.postman.com/downloads](https://www.postman.com/downloads).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://www.postman.com/downloads](https://www.postman.com/downloads)下载Postman的最新版本。
- en: You can download the latest version of Newman from [https://www.npmjs.com/package/newman](https://www.npmjs.com/package/newman).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://www.npmjs.com/package/newman](https://www.npmjs.com/package/newman)下载Newman的最新版本。
- en: 'You can find the code files for this chapter on GitHub:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件：
- en: '[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter05)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter05)'
- en: Reaching the hexagonal application with driving operations
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用驾驶操作到达六边形应用程序
- en: We may consider it inconceivable that a system can be self-contained in the
    sense that no one interacts with it and that this system doesn’t interact with
    other users or systems. Such an arrangement goes against the fundamentals of computer
    architecture (von Neumann, 1940), which presume the presence of input and output
    operations in any computer system. Indeed, it’s difficult to imagine a useful
    software program that doesn’t receive any data or produce any result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能认为一个系统可以自给自足，即没有人与之交互，并且这个系统不与其他用户或系统交互，这是不可想象的。这种安排违反了计算机架构的基本原则（冯·诺伊曼，1940年），它假定任何计算机系统都存在输入和输出操作。事实上，很难想象一个有用的软件程序不会接收任何数据或产生任何结果。
- en: Through the lens of the hexagonal architecture, the input side of a system is
    controlled by driving operations. We call them *driving operations* because they
    actually initiate and drive the behavior of a hexagonal application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过六边形架构的视角，系统的输入侧由驾驶操作控制。我们称它们为*驾驶操作*，因为它们实际上启动并驱动六边形应用程序的行为。
- en: 'In [*Chapter 3*](B19777_03.xhtml#_idTextAnchor066), *Handling Behavior with
    Ports and Use Cases*, we related driving operations to primary actors. These actors
    are in charge of triggering driving operations in the hexagonal system. The driving
    operations can assume different facets: they can be users interacting directly
    with the system through a command-line console, a web **User Interface** (**UI**)
    application requesting data to present it in a browser, a testing agent wanting
    to validate a specific test case, or any other system interested in the features
    exposed by the hexagonal application.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19777_03.xhtml#_idTextAnchor066) *使用端口和用例处理行为*中，我们将驾驶操作与主要演员联系起来。这些演员负责在六边形系统中触发驾驶操作。驾驶操作可以采取不同的方面：它们可以是直接通过命令行控制台与系统交互的用户，是一个请求数据以在浏览器中展示的**用户界面**（**UI**）应用程序，是一个想要验证特定测试用例的测试代理，或者任何对六边形应用程序公开的功能感兴趣的任何系统。
- en: 'All these different facets are grouped on the **driving side**, as shown in
    the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不同的方面都被归类在**驾驶侧**，如下面的图所示：
- en: '![Figure 5.1 – The driving side and the hexagonal application](img/B19777_05_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 驾驶侧和六边形应用程序](img/B19777_05_01.jpg)'
- en: Figure 5.1 – The driving side and the hexagonal application
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 驾驶侧和六边形应用程序
- en: We saw, in the previous chapter, how to interact with a hexagonal application
    using a **Command-Line Interface** (**CLI**) and through **HTTP REST**. Now, we’ll
    explore how to integrate other types of driving operations to communicate with
    the topology and inventory system we’ve been developing so far.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用**命令行界面**（**CLI**）和通过**HTTP REST**与六边形应用程序交互。现在，我们将探讨如何集成其他类型的驾驶操作，以与我们迄今为止一直在开发的拓扑和库存系统进行通信。
- en: Once we have these integrations in place, we will analyze the path a request
    needs to take in order to traverse all the hexagons until it reaches the Domain
    one. This exercise will help us to understand the role played by each hexagon
    and its components in processing the request of a driving operation. So, let’s
    start by integrating a web UI with the hexagonal system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了这些集成，我们将分析请求需要经过的路径，以便穿越所有六边形直到到达领域。这项练习将帮助我们理解每个六边形及其组件在处理驾驶操作请求中所扮演的角色。因此，让我们首先将一个网络UI与六边形系统集成起来。
- en: Integrating web applications with the hexagonal system
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Web应用程序与六边形系统集成
- en: Nowadays, with the advent of **HTML** **5**, modern **JavaScript**, and continuously
    improving web development techniques, it’s possible to build highly sophisticated
    systems that run directly from the web browser. Faster internet connections, more
    computational resources, and better and well-established web standards have all
    contributed to the improvement of web applications. The old and cluttered **Flash**
    or **Java applet**-based systems, for example, have been replaced by frontend
    applications based on fancy frameworks such as **Angular**, **React**, or **Vue**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着**HTML** **5**、现代**JavaScript**和不断改进的Web开发技术的出现，可以直接从Web浏览器运行高度复杂的系统。更快的互联网连接、更多的计算资源以及更好和更稳定的Web标准都为Web应用程序的改进做出了贡献。例如，旧的杂乱无章的**Flash**或**Java小程序**系统已经被基于**Angular**、**React**或**Vue**等花哨框架的前端应用程序所取代。
- en: Not only has the technology evolved and changed, but the practices surrounding
    web development have evolved too. Encouraged by the `.ear` or `.war` package file,
    it wasn’t rare to see that the business logic had leaked into the presentation
    code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅技术已经发展和变化，围绕Web开发的实践也发生了演变。受到`.ear`或`.war`包文件的鼓励，业务逻辑泄漏到表示代码中并不罕见。
- en: '**Java EE** (now **Jakarta EE**) and other frameworks, such as **Struts**,
    utilized technologies such as **Servlets**, **JSP**, and **JSF** to allow full
    integration between presentation and business code. After some time, people started
    to realize that this practice of putting frontend and backend code too close to
    each other could be a source of entropy for their software projects.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java EE**（现在称为**Jakarta EE**）和其他框架，如**Struts**，利用了**Servlets**、**JSP**和**JSF**等技术，以实现表示层和业务代码之间的完全集成。过了一段时间，人们开始意识到，将前端和后端代码放得太近可能会成为他们软件项目的熵源。'
- en: As a response to such practices, the industry turned to decoupled architectures
    where the frontend system is a separate, standalone application that interacts
    via the network with one or more backend systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这些做法的回应，行业转向了解耦架构，其中前端系统是一个独立的、独立的应用程序，通过网络与一个或多个后端系统交互。
- en: 'So, we will create a simple, standalone frontend application that obtains its
    data from our topology and inventory system. Our application will be based only
    on HTML 5, CSS, and *vanilla* JavaScript. The application aims to allow users
    to add networks to a router and retrieve existing routers from the system database.
    We will also refactor part of the hexagonal application to enable better integration
    with our frontend application. The result will be a web browser application integrated
    with the hexagonal system, as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个简单、独立的客户端应用程序，该应用程序从我们的拓扑和库存系统中获取数据。我们的应用程序将仅基于HTML 5、CSS和*vanilla*
    JavaScript。该应用程序旨在允许用户将网络添加到路由器，并从系统数据库中检索现有路由器。我们还将重构部分六边形应用程序，以实现与前端应用程序更好的集成。结果将是一个集成了六边形系统的网络浏览器应用程序，如下面的截图所示：
- en: '![Figure 5.2 – The Topology & Inventory frontend application](img/B19777_05_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 前端拓扑与库存应用程序](img/B19777_05_02.jpg)'
- en: Figure 5.2 – The Topology & Inventory frontend application
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 前端拓扑与库存应用程序
- en: The frontend application will allow users to add networks to an existing router
    and view a graphical representation of the router and its networks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用程序将允许用户将网络添加到现有路由器，并查看路由器和其网络的图形表示。
- en: 'Let’s start enhancing the hexagonal application by adding the `getRouter` method
    to the `RouterNetworkUseCase` interface:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向`RouterNetworkUseCase`接口添加`getRouter`方法开始，增强六边形应用程序。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `getRouter` method signature is simple. It receives `RouterId` and returns
    a `Router` object. We need this behavior to allow the frontend application to
    display a router.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRouter`方法签名很简单。它接收`RouterId`并返回一个`Router`对象。我们需要这种行为，以便前端应用程序能够显示一个路由器。'
- en: 'Next, we need to provide an implementation for the `getRouter` method. We do
    that by implementing the `RouterNetworkUseCase` interface with the `RouterNetworkInputPort`
    class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`getRouter`方法提供一个实现。我们通过使用`RouterNetworkInputPort`类实现`RouterNetworkUseCase`接口来完成这一点：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that `fetchRouter` already existed in the input port implementation,
    but we didn’t have an exposed operation that allowed us to retrieve the router.
    The `fetchRouter` method is then used not only by the `addNetworkToRouter` method
    but now also by `getRouter`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`fetchRouter`已经在输入端口实现中存在，但我们没有暴露的操作来检索路由器。然后`fetchRouter`方法不仅被`addNetworkToRouter`方法使用，现在也被`getRouter`使用。
- en: 'It’s necessary to propagate the input port change to the input adapter. We
    do that by creating a `getRouter` method on the base input adapter defined in
    the `RouterNetworkAdapter` abstract class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要将输入端口的变化传播到输入适配器。我们通过在`RouterNetworkAdapter`抽象类中定义的基输入适配器上创建一个`getRouter`方法来完成这一点：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that `RouterNetworkAdapter` is the base input adapter for both `RouterNetworkCLIAdapter`
    and `RouterNetworkRestAdapter`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`RouterNetworkAdapter`是`RouterNetworkCLIAdapter`和`RouterNetworkRestAdapter`两个适配器的基输入适配器。
- en: 'To allow the frontend application to communicate with the hexagonal system,
    we’ll use the REST adapter. So, there are some changes we need to make in `RouterNetworkRestAdapter`
    to allow this communication:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许前端应用程序与六边形系统通信，我们将使用REST适配器。因此，我们需要在`RouterNetworkRestAdapter`中进行一些更改，以允许这种通信：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The changes to the `processRequest` method were made so it can properly handle
    requests coming from the `/network/add` and `/``network/get` paths.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `processRequest` 方法的更改是为了使其能够正确处理来自 `/network/add` 和 `/network/get` 路径的请求。
- en: 'We can move now to the development of the frontend part of our topology and
    inventory system. Our focus will be on the HTML and JavaScript elements. We’ll
    create two pages: the first one is to allow users to add networks, and the second
    one is where users will be able to retrieve a graphical view of a router and its
    networks.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转向拓扑和库存系统前端部分的开发。我们的重点将是 HTML 和 JavaScript 元素。我们将创建两个页面：第一个页面允许用户添加网络，第二个页面将允许用户获取路由器和其网络的图形视图。
- en: Creating the Add Network page
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建添加网络页面
- en: 'Let’s start by creating the first HTML page, as shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建第一个 HTML 页面开始，如下面的截图所示：
- en: '![Figure 5.3 – The Add Network page of the Topology & Inventory frontend application](img/B19777_05_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 前端应用拓扑和库存的添加网络页面](img/B19777_05_03.jpg)'
- en: Figure 5.3 – The Add Network page of the Topology & Inventory frontend application
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 前端应用拓扑和库存的添加网络页面
- en: 'The **Add Network** page contains a form, where users are asked to type the
    necessary data to add a network to an existing router. Here is the code for the
    form:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加网络** 页面包含一个表单，用户被要求输入添加现有路由器所需的数据。以下是表单的代码：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to process the preceding `addNetworkToRouter`, which is present in
    the `networkTools.js` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 `networkTools.js` 文件中存在的 `addNetworkToRouter`，需要进行以下操作：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use the `XMLHttpRequest` object to process `GET` requests in the `/network/add`
    endpoint exposed by the REST adapter in the hexagonal application. It is a short
    JavaScript code that captures the values entered in the HTML form, processes them,
    and then shows a success message if everything goes okay or an error message if
    not, as we can see here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `XMLHttpRequest` 对象在六边形应用中 REST 适配器公开的 `/network/add` 端点中处理 `GET` 请求。这是一段简短的
    JavaScript 代码，它捕获在 HTML 表单中输入的值，处理它们，然后如果一切顺利则显示成功消息，如果不顺利则显示错误消息，就像我们在这里看到的那样：
- en: '![Figure 5.4 – Adding a new network to the topology and inventory application](img/B19777_05_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 在拓扑和库存应用中添加新的网络](img/B19777_05_04.jpg)'
- en: Figure 5.4 – Adding a new network to the topology and inventory application
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 在拓扑和库存应用中添加新的网络
- en: Now, let’s move on to the creation of the **Get** **Router** page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建 **获取** **路由器** 页面。
- en: Creating the Get Router page
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建获取路由器页面
- en: 'The **Get Router** page contains an HTML form to process the user request,
    but it also provides a graphical view based on the JSON response obtained from
    the hexagonal application. Let’s start by considering the HTML form:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取路由器** 页面包含一个 HTML 表单来处理用户请求，但它还基于从六边形应用获得的 JSON 响应提供图形视图。让我们首先考虑 HTML 表单：'
- en: '![Figure 5.5 – The Get Router page of the topology and inventory frontend application](img/B19777_05_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 前端应用拓扑和库存的获取路由器页面](img/B19777_05_05.jpg)'
- en: Figure 5.5 – The Get Router page of the topology and inventory frontend application
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 前端应用拓扑和库存的获取路由器页面
- en: The **Get Router** HTML page follows the same structure as the one we used on
    the **Add Network** page, but this form uses only one parameter to query a router
    from the hexagonal application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取路由器** HTML 页面与我们之前在 **添加网络** 页面上使用的结构相同，但这个表单只使用一个参数从六边形应用中查询路由器。'
- en: 'To create a JSON-based graphical view of the router and its networks, we’ll
    use a JavaScript library called `D3` that consumes the JSON data and produces
    the graphical view. The JavaScript code processes the form, and then it uses the
    JSON response with the `D3` libraries:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建基于 JSON 的路由器和其网络的图形视图，我们将使用一个名为 `D3` 的 JavaScript 库，该库消费 JSON 数据并生成图形视图。JavaScript
    代码处理表单，然后使用 `D3` 库和 JSON 响应：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are passing the `/network/get` endpoint defined previously in the hexagonal
    application. The `getRouter` function processes the `GET` requests and uses the
    JSON response as the parameter for the `createTree` function that will construct
    the graphical view of the network.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在传递之前在六边形应用中定义的 `/network/get` 端点。`getRouter` 函数处理 `GET` 请求，并使用 JSON
    响应作为 `createTree` 函数的参数，该函数将构建网络的图形视图。
- en: 'If we fill the form with the router ID, `ca23800e-9b5a-11eb-a8b3-0242ac130003`,
    to retrieve a router, the result we get is like the one shown in the following
    screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们填写表单中的路由器ID，`ca23800e-9b5a-11eb-a8b3-0242ac130003`，以检索路由器，我们得到的结果如下所示：
- en: '![Figure 5.6 – The network graphical view provided by the Get Router page](img/B19777_05_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – Get Router页面提供的网络图形视图](img/B19777_05_06.jpg)'
- en: Figure 5.6 – The network graphical view provided by the Get Router page
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – Get Router页面提供的网络图形视图
- en: Remember, the data presented in the preceding screenshot came ultimately from
    the H2 in-memory database that we attached directly to the REST input adapter
    used here by the frontend application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，前面截图中的数据最终来源于我们直接附加到前端应用程序在此处使用的REST输入适配器的H2内存数据库。
- en: Now, let’s see how test agents can be integrated with the topology and inventory
    system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看测试代理如何与总线和库存系统集成。
- en: Running test agents
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试代理
- en: Aside from frontend applications, another common type of driven operation comes
    from test and monitoring agents interacting with the hexagonal system to verify
    whether its features are working well. With tools such as Postman, we can create
    comprehensive test cases to validate how the application behaves when faced with
    certain requests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前端应用程序外，另一种常见的驱动操作来自测试和监控代理与六边形系统交互，以验证其功能是否运行良好。使用Postman等工具，我们可以创建全面的测试用例来验证应用程序在面临特定请求时的行为。
- en: In addition, we can periodically issue requests to certain application endpoints
    to check whether they are healthy. This practice has been popularized with tools
    such as **Spring Actuator**, which provides a specific endpoint in the application
    that allows you to check whether it’s healthy. Also, some techniques involve the
    use of probe mechanisms that periodically send a request to the application to
    see whether it is alive. For example, if the application is not alive or is causing
    timeouts, then it can be automatically restarted. In cloud-native architectures
    based on **Kubernetes**, it’s common to see systems using probe mechanisms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以定期向某些应用程序端点发出请求以检查它们是否健康。这种做法已经通过**Spring Actuator**等工具普及，这些工具在应用程序中提供了一个特定的端点，允许您检查其是否健康。还有一些技术涉及使用探针机制定期向应用程序发送请求以查看其是否存活。例如，如果应用程序不活跃或导致超时，则可以自动重启。在基于**Kubernetes**的云原生架构中，使用探针机制的系统很常见。
- en: This section will explore how to run a simple test case to confirm whether the
    application behaves according to our expectations. There will be no need to change
    the topology and inventory system we have been developing so far. Here, we will
    create a test case using a tool called Postman. In Postman, test cases are known
    as **testing collections**. Once these testing collections are made, we can execute
    them using **Newman**, which is a CLI tool used specifically to run Postman collections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨如何运行一个简单的测试用例以确认应用程序是否按我们的预期行为。我们不需要更改迄今为止一直在开发的总线和库存系统。在这里，我们将使用一个名为Postman的工具创建测试用例。在Postman中，测试用例被称为**测试集合**。一旦创建了这些测试集合，我们就可以使用**Newman**执行它们，Newman是一个专门用于运行Postman集合的命令行工具。
- en: 'To get started, you have to follow these steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您必须遵循以下步骤：
- en: Download both Postman and Newman. The download links are available in the *Technical
    requirements* section. The collection used in this chapter is also present in
    the chapter’s GitHub repository ([https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/blob/main/Chapter05/topology-inventory.postman_collection.json](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/blob/main/Chapter05/topology-inventory.postman_collection.json)).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Postman和Newman。下载链接可在*技术要求*部分找到。本章使用的集合也存在于该章节的GitHub仓库中([https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/blob/main/Chapter05/topology-inventory.postman_collection.json](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/blob/main/Chapter05/topology-inventory.postman_collection.json))。
- en: Import the collection to Postman.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将集合导入Postman。
- en: 'Once imported, the collection will present two requests. One request is for
    the `getRouter` endpoint and the other is for `addNetwork`. The following screenshot
    shows how the two requests should appear after importing the collections to Postman:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入后，集合将显示两个请求。一个请求是针对`getRouter`端点，另一个是针对`addNetwork`。以下截图显示了将集合导入Postman后两个请求的显示方式：
- en: '![Figure 5.7 – The topology and inventory collection from Postman](img/B19777_05_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – Postman中的拓扑和库存集合](img/B19777_05_07.jpg)'
- en: Figure 5.7 – The topology and inventory collection from Postman
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – Postman中的拓扑和库存集合
- en: 'Before running the test on Postman, be sure to bring up the topology and inventory
    application by running the following command from the project’s `root` directory:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman上运行测试之前，请确保通过从项目的`root`目录运行以下命令来启动拓扑和库存应用程序：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we want to validate whether the returned value is what we are expecting.
    In this case, we expect to encounter only three networks in the system: `HR`,
    `Marketing`, and `Engineering`. In Postman, we create tests for each request.
    So, we will create tests for the two requests present in the collection we imported.
    Let’s start by creating a test for the `getRouter` request:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们想要验证返回的值是否是我们所期望的。在这种情况下，我们期望在系统中只遇到三个网络：`HR`、`Marketing`和`Engineering`。在Postman中，我们为每个请求创建测试。因此，我们将为导入的集合中现有的两个请求创建测试。让我们先为`getRouter`请求创建一个测试：
- en: '[PRE8]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we first check whether the HTTP response code is `200`.
    Then, we proceed to parse and peek at the JSON response data to see whether it
    matches what we expect. In this test, we expect a response containing a router
    with a switch comprising three networks.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先检查HTTP响应代码是否为`200`。然后，我们继续解析和预览JSON响应数据，以查看它是否与我们所期望的匹配。在这个测试中，我们期望一个包含由三个网络组成的交换机的路由器的响应。
- en: 'The test from the `addNetwork` request is similar to the `getRouter` request’s
    test. The difference, though, is that the response expected this time contains
    the additional `Finance` network, as we can see in the following test code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自`addNetwork`请求的测试与`getRouter`请求的测试类似。然而，这次预期的响应中包含额外的`Finance`网络，正如我们在以下测试代码中所看到的：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `addNetwork` request in that collection adds a network named `Finance`.
    That’s why we are only checking to see whether the `Finance` network was correctly
    added. Also, we expect the length of the list of networks to be `4` after adding
    the `Finance` network.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该集合中的`addNetwork`请求添加了一个名为`Finance`的网络。这就是为什么我们只检查是否正确添加了`Finance`网络。此外，我们期望在添加`Finance`网络后，网络的列表长度为`4`。
- en: 'If you want to run these tests from outside Postman, you can do that by first
    exporting the collection to a `.json` file, then using Newman to execute the tests
    from that collection:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想在Postman外部运行这些测试，你可以通过首先将集合导出为`.json`文件，然后使用Newman从该集合执行测试来实现：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result is something like the one presented in the following screenshot:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果类似于以下截图所示：
- en: '![Figure 5.8 – Running topology and inventory application tests with Newman](img/B19777_05_08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 使用Newman运行拓扑和库存应用程序测试](img/B19777_05_08.jpg)'
- en: Figure 5.8 – Running topology and inventory application tests with Newman
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 使用Newman运行拓扑和库存应用程序测试
- en: This kind of test execution using Newman is ideal for integrating the hexagonal
    application into **Continuous Integration** (**CI**) pipelines. Developers use
    Postman to create collections and their respective tests, and these same collections
    are triggered and validated through CI tools (such as **Jenkins**) that can use
    Newman to execute the tests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Newman进行此类测试执行非常适合将六边形应用程序集成到**持续集成**（**CI**）管道中。开发者使用Postman创建集合及其相应的测试，然后通过CI工具（如**Jenkins**）触发和验证这些相同的集合，这些工具可以使用Newman执行测试。
- en: Now that we are acquainted with both frontend applications and test agents as
    means of driving operations, let’s check out one more type of driving operation.
    Next, we will discuss the driving operation that occurs in distributed or microservices
    architecture, where different applications from the same system communicate through
    the network.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了前端应用程序和测试代理作为驱动操作的手段，让我们再看看另一种驱动操作类型。接下来，我们将讨论在分布式或微服务架构中发生的驱动操作，其中来自同一系统的不同应用程序通过网络进行通信。
- en: Calling the hexagonal system from other applications
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从其他应用程序调用六边形系统
- en: There is a recurring debate about whether to develop a monolith or microservices
    system. In a monolith, we have data flowing directly between objects and method
    calls. All the software instructions are grouped in the same application, diminishing
    the communication overhead and centralizing the logs generated by the system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否开发单体或微服务系统，有一个反复出现的争论。在单体中，数据直接在对象和方法调用之间流动。所有软件指令都组在同一个应用程序中，减少了通信开销并集中了系统生成的日志。
- en: With both microservices and a distributed system, we have part of the data flowing
    through the network between standalone, self-contained applications that cooperate
    in providing the features of the whole system. This approach decouples the development,
    allowing more modularized components. It also improves compilation times because
    the packages are smaller, contributing to faster feedback loops in CI tools. Microservices,
    though, offer some challenges because the logs are not centralized anymore, and
    the network communication overhead can represent a limiting factor, depending
    on the system’s purpose.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务和分布式系统中，部分数据会在独立、自包含的应用程序之间通过网络流动，这些应用程序合作提供整个系统的功能。这种方法解耦了开发，允许更模块化的组件。它还因为包更小而提高了编译时间，有助于在CI工具中形成更快的反馈循环。然而，微服务也带来了一些挑战，因为日志不再集中，网络通信开销可能成为限制因素，这取决于系统的目的。
- en: 'In a distributed approach, two or more hexagonal self-contained systems can
    comprise the whole hexagonal-based system. In such a scenario, the hexagonal **System
    A** that initiates the request acts as a primary actor and triggers a driving
    operation on the hexagonal **System B**, as shown in the following diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式方法中，两个或更多六边形自包含系统可以组成整个基于六边形的系统。在这种情况下，启动请求的六边形**系统A**充当主要参与者，并在六边形**系统B**上触发驱动操作，如下所示：
- en: '![Figure 5.9 – Multiple hexagonal applications](img/B19777_05_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 多个六边形应用程序](img/B19777_05_09.jpg)'
- en: Figure 5.9 – Multiple hexagonal applications
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 多个六边形应用程序
- en: Note that **System A** triggers a request through one of its output adapters.
    This request goes directly to one of the input adapters from **System B**. An
    exciting thing about distributed architecture is that you don’t need to use the
    same programming language to develop all the system components.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**系统A**通过其输出适配器之一触发请求。这个请求直接从**系统B**的一个输入适配器接收。分布式架构的一个令人兴奋之处在于，你不需要使用相同的编程语言来开发所有系统组件。
- en: In a distributed architecture scenario, we could write **System A** in Java
    and **System B** in Python. As long as they agree on a common medium of communication
    – JSON and HTTP, for example – they can cooperate in the same system. With the
    advent of container technologies such as Docker and Kubernetes, it’s not a big
    deal to have a technology-hybrid system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式架构场景中，我们可以用Java编写**系统A**，用Python编写**系统B**。只要它们就通信的公共媒介达成一致——例如JSON和HTTP——它们就可以在同一系统中协作。随着容器技术如Docker和Kubernetes的出现，拥有一个技术混合系统并不是什么大问题。
- en: 'This section has looked at what driving operations are and how we can use them
    to interact with the hexagonal system. In the next section, we’ll see the other
    side of the coin: driven operations.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了驱动操作是什么以及我们如何使用它们与六边形系统交互。在下一节中，我们将看到硬币的另一面：驱动操作。
- en: Handling external resources with driven operations
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用驱动操作处理外部资源
- en: A general characteristic of business applications is their need to send or request
    data from other systems. We’ve already seen that output ports and adapters are
    the hexagonal architecture components we use to allow the hexagonal system to
    interact with external resources without compromising the business logic. These
    external resources are also known as *secondary actors* and provide data or capabilities
    absent in the hexagonal application that requests them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 商业应用程序的一般特征是它们需要从其他系统发送或请求数据。我们已经看到，输出端口和适配器是我们用来允许六边形系统与外部资源交互而不损害业务逻辑的六边形架构组件。这些外部资源也被称为*次要参与者*，并提供六边形应用程序请求的数据或能力。
- en: When the hexagonal application sends a request to a secondary actor – generally,
    on behalf of a primary actor who first triggered a driving operation from one
    of the hexagon application’s use cases – we call such a request a *driven* operation.
    It’s driven because these operations are controlled and driven by the hexagonal
    system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当六边形应用程序向一个次要参与者发送请求——通常是代表首先从一个六边形应用程序的使用案例中触发驱动操作的原始参与者——我们称这样的请求为*驱动*操作。这是因为这些操作由六边形系统控制和驱动。
- en: 'So, *driving* operations come from the primary actor’s requests that drive
    the behavior of a hexagonal system, whereas *driven* operations are the requests
    initiated by the hexagonal application itself toward secondary actors (such as
    databases or other systems). The following diagram shows the driven side with
    some examples of driven operations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**驱动**操作来自主要演员的请求，这些请求驱动六边形系统的行为，而**驱动**操作是六边形应用程序本身向次要演员（如数据库或其他系统）发起的请求。以下图显示了驱动端和一些驱动操作的示例：
- en: '![Figure 5.10 – The driven side and the hexagonal application](img/B19777_05_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 驱动端和六边形应用程序](img/B19777_05_10.jpg)'
- en: Figure 5.10 – The driven side and the hexagonal application
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 驱动端和六边形应用程序
- en: This section will explore some of the possible driven operations a hexagonal
    application can perform, as shown in the preceding diagram.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨六边形应用程序可以执行的一些可能的驱动操作，如图中所示。
- en: Data persistence
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据持久性
- en: Driven operations based on data persistence are the most common. The H2 output
    adapter we created in [*Chapter 4*](B19777_04.xhtml#_idTextAnchor083), *Creating
    Adapters to Interact with the Outside World*, is one example of a driven operation
    that deals with data persistence by utilizing an in-memory database. This kind
    of driven operation often leverages **Object-Relational Mapping** (**ORM**) techniques
    to handle and translate objects between the hexagonal system and a database. In
    the Java world, **Hibernate** and **EclipseLink** provide robust **Java Persistence
    API** (**JPA**) implementations with ORM features.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据持久性的驱动操作是最常见的。我们在[*第 4 章*](B19777_04.xhtml#_idTextAnchor083)，“创建与外部世界交互的适配器”中创建的
    H2 输出适配器是一个处理数据持久性的驱动操作的例子，它通过使用内存数据库来实现。这类驱动操作通常利用**对象关系映射**（**ORM**）技术来处理和转换六边形系统与数据库之间的对象。在
    Java 世界中，**Hibernate**和**EclipseLink**提供了具有 ORM 功能的强大**Java 持久性 API**（**JPA**）实现。
- en: Transaction mechanisms are also a part of persistence-based driven operations.
    When working with transactions, we can make the hexagonal system directly deal
    with transactional boundaries or delegate this responsibility to an application
    server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 事务机制也是基于持久性驱动的操作的一部分。当处理事务时，我们可以让六边形系统直接处理事务边界，或者将这项责任委托给应用程序服务器。
- en: Messaging and events
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息和事件
- en: Not every system relies only on synchronous communication. Depending on the
    situation, you may want to trigger events about your *stuff* without interrupting
    the runtime flow of your application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个系统都只依赖于同步通信。根据情况，您可能希望在不妨碍应用程序运行时流程的情况下触发有关您的**东西**的事件。
- en: There are types of architecture strongly influenced by techniques where the
    communication between system components occurs asynchronously. These systems become
    more loosely coupled by employing such techniques because their components are
    no longer attached to the interfaces provided by other applications. Instead of
    relying solely on APIs blocking connections, we let messages and events drive
    the behavior of applications in a non-blocking way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些架构类型受到异步通信技术的影响很大。通过采用这些技术，这些系统变得更加松散耦合，因为它们的组件不再依赖于其他应用程序提供的接口。我们不再仅仅依赖于阻塞连接的API，而是让消息和事件以非阻塞的方式驱动应用程序的行为。
- en: By *blocking*, we mean those connections that need to wait for a response to
    allow the application flow to proceed. The non-blocking approach allows an application
    to send a request and move forward without the need for an immediate response.
    There are also situations where an application reacts to messages or events to
    take some action.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**阻塞**，我们指的是那些需要等待响应以允许应用程序流程继续进行的连接。非阻塞方法允许应用程序发送请求并继续前进，而无需立即响应。也存在一些情况下，应用程序会响应消息或事件来采取某些行动。
- en: Message-based systems are secondary actors driven by the hexagonal application.
    Unlike databases, where the communication will start from the hexagonal application,
    there are scenarios where the message-based system will start the communication
    with the hexagonal application. But, to receive or send messages, the hexagonal
    system always needs to first establish a flow of communication with a message
    system. Such a scenario is widespread when dealing with technologies such as Kafka,
    where the application can be both a consumer and producer of messages. To be integrated
    with a message system such as Kafka, the hexagonal application needs to express
    its intent by joining a **Kafka** **topic**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基于消息的系统是受六边形应用驱动的次要参与者。与数据库不同，通信将从六边形应用开始，但在某些场景中，基于消息的系统将首先与六边形应用开始通信。但是，为了接收或发送消息，六边形系统始终需要首先与消息系统建立通信流程。在处理
    Kafka 等技术时，这种情况很常见，其中应用可以是消息的消费者和生产者。为了与 Kafka 等消息系统集成，六边形应用需要通过加入 **Kafka** **主题**
    来表达其意图。
- en: 'To better understand how a message-based system integrates with a hexagonal
    application, we’ll implement a feature in our topology and inventory system to
    allow us to see events produced by the application. The backend hexagonal part
    of the system will send events to Kafka, and the frontend will consume those events
    in real time and display them in the web browser. We’ll implement this feature
    by executing the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解基于消息的系统如何与六边形应用集成，我们将在我们的拓扑和库存系统中实现一个功能，以便我们可以看到应用产生的事件。系统的后端六边形部分将发送事件到
    Kafka，而前端将实时消费这些事件并在网页浏览器中显示它们。我们将通过执行以下步骤来实现此功能：
- en: 'Let’s start by bringing up Kafka and creating a topic for our application.
    The Kafka download URL is available in the *Technical requirements* section. Once
    you have downloaded the latest Kafka version, extract it:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先启动 Kafka 并为我们的应用程序创建一个主题。Kafka 下载 URL 可在 *技术要求* 部分找到。一旦你下载了最新的 Kafka 版本，提取它：
- en: '[PRE11]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'broker service:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代理服务：
- en: '[PRE12]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, Kafka is up and running in your environment. Let’s now create
    the topic for our application in a third shell session or tab:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，Kafka 已在你的环境中启动并运行。现在，让我们在第三个 shell 会话或标签中创建我们的应用程序的主题：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: public interface NotifyEventOutputPort {
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`public interface NotifyEventOutputPort {`'
- en: void sendEvent(String Event);
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`void sendEvent(String Event);`'
- en: String getEvent();
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`String getEvent();`'
- en: '}}'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`}}`'
- en: '[PRE15]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we implement the output port with the `NotifyEventKafkaAdapter` output
    adapter. We start the `NotifyEventKafkaAdapter` adapter implementation by first
    defining the Kafka connection properties:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现输出端口，使用 `NotifyEventKafkaAdapter` 输出适配器。我们首先通过定义 Kafka 连接属性来启动 `NotifyEventKafkaAdapter`
    适配器实现：
- en: '[PRE16]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the `KAFKA_BROKERS` variable value, set to `localhost:9092`, corresponds
    to the host and port used to bootstrap the Kafka topic. The `TOPIC_NAME` variable
    value, set to `topology-inventory-events`, represents the topic that we use to
    produce and consume messages.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`KAFKA_BROKERS` 变量的值设置为 `localhost:9092`，对应于启动 Kafka 主题所使用的宿主机和端口。`TOPIC_NAME`
    变量的值设置为 `topology-inventory-events`，代表我们用于产生和消费消息的主题。
- en: 'Let’s move on now to create the method to send messages to our Kafka topic:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建将消息发送到我们的 Kafka 主题的方法：
- en: '[PRE17]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `getProducer` method configures the Producer properties by setting the required
    attributes in the `ProducerConfig` class. Then, it returns a `KafkaProducer` instance,
    which we use to produce messages in the Kafka topic.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getProducer` 方法通过在 `ProducerConfig` 类中设置所需的属性来配置生产者属性。然后，它返回一个 `KafkaProducer`
    实例，我们使用该实例在 Kafka 主题中产生消息。'
- en: 'On the other hand, we have the `getConsumer` method, which consumes the messages
    generated by the `Producer` method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，我们有 `getConsumer` 方法，它消费由 `Producer` 方法生成的消息：
- en: '[PRE18]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the `getConsumer` method, we use the `ConsumerConfig` class to set the
    required properties. This method returns a `KafkaConsumer` instance that we use
    to consume and read messages from the Kafka topic.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `getConsumer` 方法，我们使用 `ConsumerConfig` 类设置所需的属性。此方法返回一个 `KafkaConsumer` 实例，我们使用该实例从
    Kafka 主题中消费和读取消息。
- en: 'Moving ahead, we override the first method, `sendEvent`, declared in `NotifyEventOutputPort`.
    It’s with this method that we’ll be able to send messages to the Kafka P`roducer`
    instance:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们覆盖在 `NotifyEventOutputPort` 中声明的第一个方法 `sendEvent`。我们将通过此方法将消息发送到 Kafka
    P`roducer` 实例：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line of the `sendEvent` method creates a `ProducerRecord` instance
    that informs the constructor parameters about the topic name and the message we
    intend to send as an event. Near the end, we have a call to the `getEvent` method.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sendEvent`方法的第一行创建了一个`ProducerRecord`实例，该实例向构造函数参数传达了主题名称和我们打算作为事件发送的消息。在接近结尾的地方，我们调用了`getEvent`方法。'
- en: 'As we shall see next in more detail, we call this method to consume messages
    from Kafka and forward them to a `WebSocket` server:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们将在下一部分更详细地看到的那样，我们调用这个方法来从Kafka消费消息并将它们转发到运行在端口`8887`上的`WebSocket`服务器：
- en: '[PRE20]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `getEvent` method relies on the `KafkaConsumer` instance assigned to the
    `consumer` variable. With that instance, it retrieves messages from the Kafka
    topic.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getEvent`方法依赖于分配给`consumer`变量的`KafkaConsumer`实例。通过这个实例，它从Kafka主题中检索消息。'
- en: 'After retrieving the message, the `getEvent` method calls the `sendMessage`
    method to forward that message to the `WebSocket` server:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检索到消息后，`getEvent`方法调用`sendMessage`方法将那条消息转发到`WebSocket`服务器：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `sendMessage` method receives a parameter as a string, containing the consumed
    Kafka topic message. It then forwards that message to a `WebSocket` server running
    on port `8887`.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sendMessage`方法接收一个字符串参数，其中包含消费的Kafka主题消息。然后，它将那条消息转发到运行在端口`8887`上的`WebSocket`服务器。'
- en: 'Let’s see briefly how that `WebSocket` server is implemented:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看这个`WebSocket`服务器是如何实现的：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `startServer` method creates an instance of `NotifyEventWebSocketAdapter`,
    containing the host and port of the `WebSocket` server. When we are starting the
    hexagonal application, one of the first things that occurs is the calling of the
    `startServer` method to bring up the WebSocket server on port `8887`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`startServer`方法创建了一个`NotifyEventWebSocketAdapter`实例，其中包含了`WebSocket`服务器的地址和端口。当我们启动六边形应用时，最早发生的事情之一就是调用`startServer`方法，在端口`8887`上启动WebSocket服务器：'
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Along with a WebSocket server class, we also need to implement a WebSocket
    client class to process the events coming from Kafka:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了WebSocket服务器类，我们还需要实现一个WebSocket客户端类来处理来自Kafka的事件：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When a message is consumed from the Kafka topic, the hexagonal application uses
    `WebSocketClientAdapter` to forward the message to the WebSocket server. The `onMessage`,
    `onOpen`, `onClose`, and `onError` methods represent the WebSocket protocol operations
    that the `WebSocketClientAdapter` class needs to support.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当从Kafka主题中消费消息时，六边形应用使用`WebSocketClientAdapter`将消息转发到WebSocket服务器。`onMessage`、`onOpen`、`onClose`和`onError`方法代表了`WebSocketClientAdapter`类需要支持的WebSocket协议操作。
- en: 'The last thing we need to do in the hexagonal application is to make the `addNetworkToRouter`
    and `getRouter` methods send events using the ports and adapters we have just
    created:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形应用中，我们需要做的最后一件事是让`addNetworkToRouter`和`getRouter`方法使用我们刚刚创建的端口和适配器发送事件：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that now we are calling `sendEvent` on both methods (`addNetworkToRouter`
    and `getRouter`), so whenever we add a network or retrieve a router, the hexagonal
    application will send an event informing us what has happened.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们在两个方法（`addNetworkToRouter`和`getRouter`）上都调用了`sendEvent`，所以无论何时添加网络或检索路由器，六边形应用都会发送一个事件来通知我们发生了什么。
- en: 'We can now add an **Events** page to allow the frontend application to connect
    with the WebSocket server from the hexagonal application. The following screenshot
    shows us the **Events** page that we’ll create:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个**事件**页面，以便前端应用能够从六边形应用连接到WebSocket服务器。以下截图显示了我们将要创建的**事件**页面：
- en: '![Figure 5.11 – The topology and inventory application Events page](img/B19777_05_11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11 – 拓扑和库存应用事件页面](img/B19777_05_11.jpg)'
- en: Figure 5.11 – The topology and inventory application Events page
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 拓扑和库存应用事件页面
- en: 'The **Events** page follows the same structure we used in previous pages. The
    important part of this page is the JavaScript code utilized to connect users to
    the WebSocket server exposed by our hexagonal application:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**页面遵循我们在之前页面中使用的相同结构。这个页面的重要部分是用于将用户连接到我们六边形应用暴露的WebSocket服务器的JavaScript代码：'
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `onmessage` method creates and appends a new `div` HTML element for every
    new message received from the WebSocket connection. So, every event generated
    by the hexagonal application will be sent to Kafka and printed in real time in
    the frontend application. The communication between the frontend, the hexagonal
    application with WebSocket, and the Kafka message system is represented in the
    following flow:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`onmessage` 方法为从 WebSocket 连接接收到的每条新消息创建并附加一个新的 `div` HTML 元素。因此，由六边形应用程序生成的每个事件都将发送到
    Kafka，并在前端应用程序中实时打印。前端、具有 WebSocket 的六边形应用程序和 Kafka 消息系统之间的通信在以下流程中表示：'
- en: '![Figure 5.12 – The flow between the frontend, the hexagonal application with
    WebSocket, and the message system](img/B19777_05_12.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 前端、具有 WebSocket 的六边形应用程序和消息系统之间的流程](img/B19777_05_12.jpg)'
- en: Figure 5.12 – The flow between the frontend, the hexagonal application with
    WebSocket, and the message system
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 前端、具有 WebSocket 的六边形应用程序和消息系统之间的流程
- en: 'To test this flow, make sure to have your local Kafka instance running. Then,
    start the hexagonal application:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此流程，请确保您的本地 Kafka 实例正在运行。然后，启动六边形应用程序：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To create a WebSocket connection between your browser and the application,
    you need to open the `ca23800e-9b5a-11eb-a8b3-0242ac130003` ID. The event entries
    will appear as follows on the **Events** page:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的浏览器和应用程序之间创建 WebSocket 连接，您需要打开 `ca23800e-9b5a-11eb-a8b3-0242ac130003` ID。事件条目将在
    **事件** 页面上显示如下：
- en: '![Figure 5.13 –  The frontend application receiving events from Kafka through
    a WebSocket connection](img/B19777_05_13.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 前端应用程序通过 WebSocket 连接接收来自 Kafka 的事件](img/B19777_05_13.jpg)'
- en: Figure 5.13 – The frontend application receiving events from Kafka through a
    WebSocket connection
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 前端应用程序通过 WebSocket 连接接收来自 Kafka 的事件
- en: This integration using Kafka and WebSockets has shown us how a hexagonal application
    deals with message-driven operations. We didn’t need to touch the business logic
    to add these technologies. All we had to do was create more ports and adapters
    to augment the system’s capabilities.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kafka 和 WebSocket 的这种集成向我们展示了六边形应用程序如何处理消息驱动操作。我们不需要修改业务逻辑来添加这些技术。我们只需创建更多的端口和适配器来增强系统的功能。
- en: Now, let’s briefly see one more type of driven operation that a hexagonal application
    can handle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要地看看六边形应用程序可以处理的另一种驱动操作类型。
- en: Mock servers
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟服务器
- en: The typical approach for software development is to have multiple environments,
    such as development, QA, and production. The first working software releases start
    going to development environments and then progressively make their way to production.
    This journey to production is generally conducted by CI pipelines that constantly
    validate and ensure the software is working well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的典型方法是有多个环境，例如开发、QA 和生产。第一个工作的软件版本开始进入开发环境，然后逐步进入生产环境。这种进入生产的过程通常由 CI 管道执行，它们持续验证并确保软件运行良好。
- en: Among CI validations, unit and integration tests may happen during the pipeline
    execution. Integration tests, in particular, depend on external components such
    as other applications, systems, databases, and services – all of them provided
    in different environments.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI 验证中，单元和集成测试可能在管道执行期间发生。特别是集成测试，它依赖于外部组件，如其他应用程序、系统、数据库和服务，所有这些都在不同的环境中提供。
- en: The execution of integration tests in development environments poses a low risk
    but can cause problems if there is, for example, concurrent usage of resources.
    This concurrency issue can generate inconsistency in test results. For QA, the
    situation is slightly more complicated because we must ensure consistency when
    dealing with test data explicitly tailored to specific scenarios. If that test
    data changes inadvertently, we may find inconsistencies in test results. We need
    to be careful because the cost of test failures in QA is even higher than in development
    environments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中执行集成测试风险较低，但如果存在资源并发使用的情况，可能会引起问题。这种并发问题可能导致测试结果不一致。对于 QA 来说，情况稍微复杂一些，因为我们必须确保在处理专门针对特定场景量身定制的数据时的一致性。如果测试数据意外更改，我们可能会在测试结果中找到不一致性。我们需要小心，因为
    QA 中测试失败的成本甚至高于开发环境。
- en: In order to overcome testing obstacles, some tools simulate application endpoints
    and their responses. Those tools are known as **mock solutions**, and they come
    in various shapes and forms. You can manually mock the responses and endpoints
    of a service that your application needs; however, this is not always trivial,
    and it may take considerable effort. Also, there are sophisticated tools that
    do the dirty work and let you focus just on the logic. That is the role of mocking
    servers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服测试障碍，一些工具模拟应用程序端点和它们的响应。这些工具被称为**模拟解决方案**，它们以各种形状和形式存在。你可以手动模拟应用程序所需服务的响应和端点；然而，这并不总是简单的事情，可能需要相当大的努力。此外，还有一些复杂的工具会做脏活，让你只需关注逻辑。这就是模拟服务器的角色。
- en: Because mocking servers act as an external entity providing useful resources
    to the application, we also consider them secondary actors driven by a hexagonal
    system that wants to leverage mocking server capabilities instead of hitting actual
    systems.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模拟服务器充当一个提供有用资源的对外实体，我们也认为它们是六边形系统中的次要角色，该系统希望通过利用模拟服务器功能而不是实际系统。
- en: By no means have we exhausted all the possible driven operations a hexagonal
    system can have. But, in this section, we peeked into some of the relevant driven
    operations present in a hexagonal application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对没有穷尽六边形系统可能拥有的所有可能的驱动操作。但，在本节中，我们窥视了六边形应用程序中存在的一些相关驱动操作。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had the opportunity to dive deep into the nature of driving
    and driven operations. Although we had already dealt with them in previous chapters,
    we examined these operations in more depth.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有深入了解驱动和驱动操作本质的机会。尽管我们已经在之前的章节中处理过它们，但我们对这些操作进行了更深入的探讨。
- en: Starting with *driving operations*, we learned that they drive the hexagonal
    application behavior by calling its input adapters. To illustrate driving operations,
    we first created a frontend application to play the role of a primary actor requesting
    data through the input adapters provided by the topology and inventory hexagonal
    application. Then, to explore testing tools as driving operations, we created
    a Postman collection with tests based on API endpoints exposed by the hexagonal
    application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从**驱动操作**开始，我们了解到它们通过调用其输入适配器来驱动六边形应用程序的行为。为了说明驱动操作，我们首先创建了一个前端应用程序，扮演主要角色，通过拓扑和库存六边形应用程序提供的输入适配器请求数据。然后，为了探索作为驱动操作的测试工具，我们创建了一个基于六边形应用程序公开的API端点的Postman集合进行测试。
- en: On the *driven operations* side, we saw how to enable the hexagonal application
    to work with message-based systems such as Kafka. To better understand the effects
    of message-based systems on the hexagonal application, we created ports and adapters
    that enabled the application to send and consume messages from Kafka. Also, we
    made a WebSocket server to let the frontend application retrieve the events generated
    by the hexagonal system in real time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在**驱动操作**方面，我们看到了如何使六边形应用程序能够与基于消息的系统（如Kafka）一起工作。为了更好地理解基于消息的系统对六边形应用程序的影响，我们创建了端口和适配器，使应用程序能够从Kafka发送和消费消息。此外，我们还创建了一个WebSocket服务器，让前端应用程序实时检索六边形系统生成的事件。
- en: By handling different kinds of driving and driven operations, we can now better
    comprehend the inner workings of a hexagonal system, its surroundings, and how
    the driving and driven operations influence the hexagonal application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过处理不同类型的驱动和驱动操作，我们现在可以更好地理解六边形系统的内部运作、其环境以及驱动和驱动操作如何影响六边形应用程序。
- en: The fundamentals acquired from this chapter and the previous ones provide all
    the building blocks to start developing robust, change-tolerant systems with the
    hexagonal architecture instruments.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章和前几章获得的基本原理为使用六边形架构工具开始开发健壮、可容忍变化的系统提供了所有构建块。
- en: In the next chapter, we’ll apply the things we have learned to initiate the
    construction of a production-grade hexagonal system that will incorporate features
    from the Java module system and **Quarkus** framework.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将应用我们所学到的知识来启动构建一个生产级六边形系统的过程，该系统将结合Java模块系统和**Quarkus**框架的功能。
- en: Questions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are driving operations?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动操作是什么？
- en: Give one example of a driving operation.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请举一个驱动操作的例子。
- en: What are driven operations?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动操作是什么？
- en: Give one example of a driven operation.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请举一个驱动操作的例子。
- en: Answers
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Driving operations are requests initiated by the primary actors that drive the
    hexagonal application’s behavior.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动操作是由驱动六边形应用程序行为的主体角色发起的请求。
- en: A frontend application calling a hexagonal system through one of its input adapters
    is an example of a driving operation.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个前端应用程序通过其输入适配器之一调用六边形系统是驱动操作的例子。
- en: Driven operations are requests initiated by the hexagonal application itself,
    generally on behalf of a use case need, toward secondary actors driven by a hexagonal
    system.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动操作是由六边形应用程序本身发起的请求，通常代表用例需求，向由六边形系统驱动的次要角色发起。
- en: When the hexagonal application accesses a database. In this case, the database
    is driven by the hexagonal application.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当六边形应用程序访问数据库时。在这种情况下，数据库由六边形应用程序驱动。
- en: 'Part 2: Using Hexagons to Create a Solid Foundation'
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：使用六边形创建坚实基础
- en: By following a real-world example of a system that manages a telco's network
    and topology inventory, in this part, you will learn how to implement the building
    blocks for creating such a system using hexagonal architecture ideas.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过跟随一个管理电信网络和拓扑库存的系统的真实世界示例，在本部分中，你将学习如何使用六边形架构思想构建创建此类系统的构建块。
- en: This is a hands-on part where we'll have the opportunity to get our hands dirty
    while applying the hexagonal architecture principles. We start by implementing
    the Domain hexagon, which contains the domain model of the topology and inventory
    system. Then, we implement the Application hexagon by using use cases and ports
    to express system behaviors. To enable and expose the features provided by the
    hexagonal system, we use adapters to implement the Framework hexagon. Closing
    this part, we learn how to use Java modules to apply dependency inversion in our
    hexagonal system.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实践部分，我们将有机会在应用六边形架构原则的同时亲自动手。我们首先实现领域六边形，其中包含拓扑和库存系统的领域模型。然后，我们通过用例和端口来表示系统行为，实现应用程序六边形。为了启用和暴露六边形系统提供的功能，我们使用适配器实现框架六边形。在本部分的结尾，我们学习如何使用Java模块在我们的六边形系统中应用依赖倒置。
- en: 'This part has the following chapters:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B19777_06.xhtml#_idTextAnchor126), *Building the Domain Hexagon*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19777_06.xhtml#_idTextAnchor126), *构建领域六边形*'
- en: '[*Chapter 7*](B19777_07.xhtml#_idTextAnchor152), *Building the Application
    Hexagon*'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19777_07.xhtml#_idTextAnchor152), *构建应用程序六边形*'
- en: '[*Chapter 8*](B19777_08.xhtml#_idTextAnchor174), *Building the Framework Hexagon*'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19777_08.xhtml#_idTextAnchor174), *构建框架六边形*'
- en: '[*Chapter 9*](B19777_09.xhtml#_idTextAnchor192), *Applying Dependency Inversion
    with Java Modules*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19777_09.xhtml#_idTextAnchor192), *使用Java模块实现依赖倒置*'
