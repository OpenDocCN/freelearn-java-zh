- en: Chapter 4. JSF Validation and AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"It always seems impossible until it is done."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Nelson Mandela* |'
  prefs: []
  type: TYPE_TB
- en: So far, we have created a digital customer journey that accomplishes the common
    create, retrieve, update, and delete, that is, the famous CRUD requirement. The
    results are attractive to the stakeholder and to the product owner, but the user
    members of our team are not satisfied with the form, because it lacks the ability
    to verify the data entries made by members of the general public.
  prefs: []
  type: TYPE_NORMAL
- en: When we think about it, validation is important for the user as he or she is
    the one entering the data in a web application. It saves time and frustration
    for the user, because they know that the entry is wrong as they enter the data.
    It avoids the costs incurred for fixing of the wrongly submitted data by the database
    administrator. Validation improves the efficiency of a web application that works
    24/7 over the Internet. As more of our daily lives get dependent on the digital
    adaptation of traditional services, e-commerce is now a necessity; it is essential
    that we give the general public the right information at the right time, that
    is, at the point-of-sale or point-of-capture.
  prefs: []
  type: TYPE_NORMAL
- en: Validation methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, taking the basic JSF form as a base, we will learn how to apply
    validation on the server side and on the client-server side. There are certain
    advantages to both the strategies; we will learn about the pros and cons of both
    the approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Form validation can be achieved on the server-side in a Java EE application
    running on the application server or the servlet container. The information is
    sent from the web browser to the web application as a normal HTTP form submission.
    In this mode, the form is submitted as a traditional HTML form element. The web
    framework, in this case Java EE, validates the input and sends back a response
    to the client. If the form fails the validation, the page that contains the web
    form is redisplayed and error messages are shown.
  prefs: []
  type: TYPE_NORMAL
- en: The server-side quick validation is secure in the sense that it will protect
    the database even if JavaScript is disabled or unavailable in a web browser. On
    the other hand, this type of validation requires a round trip from the client
    to the server side. The users will not get feedback about the form data until
    they submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: There always seems to be an exception to a rule. If the server-side form validation
    is submitted using AJAX, then we can get around the slow response. AJAX validation
    is a nice compromise, because the form can be validated as and when the user enters
    the data on the form. On the other hand, AJAX requires JavaScript to be enabled
    in the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user-experience person in our team really prefers the client-side validation,
    but this type of validation requires the presence of JavaScript in the browser
    (or an equivalent type of dynamic scripting technology). Client-side validation
    affords a more responsive and richer user interaction with the form.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side validation ensures that the form is always correct before the user
    is allowed to submit the form. With JavaScript being a progressive language, there
    are many ways to inform the user how to better interact with the form submission
    process. Technologies such as jQuery allow the programmers to add hinting and
    validation error messages in flight as the user types the data.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations where JavaScript is disabled or unavailable in the web
    browser. I can readily think of government security or specialist centers where
    the sandbox is strictly controlled. When JavaScript is turned off by the user
    or by the administrator of the device, client-side validation will certainly fail,
    and the user is able to bypass the validation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Combine client-side and server-side validation**'
  prefs: []
  type: TYPE_NORMAL
- en: In professional applications for businesses, I strongly recommend that you combine
    both the approaches to validation in order to get the best of both worlds. Client-side
    validation provides a faster and richer experience and server-side validation
    protects your data and database from bad data and hacking.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go through the technical topic of validation, we must understand how
    messages are represented in JSF.
  prefs: []
  type: TYPE_NORMAL
- en: Faces messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSF provides two custom tags to display error messages. The `<h:message>`
    tag displays messages that are bound to specific components. The `<h:messages>`
    tag displays messages that are not bound to specific components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw our first use of `<h:message>` in [Chapter 3](part0035.xhtml#aid-11C3M2
    "Chapter 3. Building JSF Forms"), *Building JSF Forms*. The tag is typically associated
    with a form control. We can add messages to our JSF pages with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The tag is added to the top of the content. The attribute `globalStyle` is a
    Boolean value, and it specifies whether the tag should display messages that are
    not associated with a component. Here, we are using the Bootstrap CSS selectors
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table of the attributes that are shared between the JSF
    tags, `<h:messages>` and `<h:message>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Id` | Specifies the unique identifier |'
  prefs: []
  type: TYPE_TB
- en: '| `errorClass` | Specifies the CSS class selectors for error messages |'
  prefs: []
  type: TYPE_TB
- en: '| `errorStyle` | Specifies the style for error messages |'
  prefs: []
  type: TYPE_TB
- en: '| `infoClass` | Specifies the CSS class selector for information messages |'
  prefs: []
  type: TYPE_TB
- en: '| `infoStyle` | Specifies the CSS styles for information messages |'
  prefs: []
  type: TYPE_TB
- en: '| `for` | Specifies the component that a message is associated with |'
  prefs: []
  type: TYPE_TB
- en: '| `rendered` | Sets a Boolean value to specify whether the tag is rendered
    to the page or not |'
  prefs: []
  type: TYPE_TB
- en: '| `style` | Defines the CSS selectors for all the message types |'
  prefs: []
  type: TYPE_TB
- en: '| `styleClass` | Defines the CSS style for all the message types |'
  prefs: []
  type: TYPE_TB
- en: Behind the scenes, these tags render the content from the `javax.faces.HtmlMessages`
    and `javax.faces.HtmlMessages` components respectively, which in turn, rely on
    the list collection of the `javax.faces.application.FacesMessage` elements. As
    a JSF digital developer, we do not have to worry too much about the `HtmlMessage`
    and `HtmlMessages` components from day-to-day, as they lie under the car bonnet.
    If we were in the business of writing a new JSF renderer or an extension, then
    we would have to look at the Javadoc and JSF specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](part0035.xhtml#aid-11C3M2 "Chapter 3. Building JSF Forms"),
    *Building JSF Forms*, you were introduced to the application, `FacesMessage`,
    for creating the JSF CRUD style forms. In the Controller, we can create a validation
    error message that is not associated to any `UIComponent` in the form. Therefore
    this validation error is accessible only through global error messages. Here is
    code that generates such a validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FacesMessage` object represents a validation message with a severity level.
    We add it to the `FacesContext` object. The `FacesMessage` constructor is of the
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The severity can be of four static constants defined in the `FaceMessages` class,
    which are `SEVERITY_INFO`, `SERVERITY_WARNING`, `SEVERITY_ERROR`, and `SEVERITY_FATAL`.
    These values are actually instantiations of a private inner class `Severity` that,
    unfortunately, is not accessible outside the enclosing class, so we can invent
    our own severities.
  prefs: []
  type: TYPE_NORMAL
- en: A Faces message also requires a summary of the message and, optionally, details
    about the invalidation message.
  prefs: []
  type: TYPE_NORMAL
- en: '`javax.faces.context.FacesContext` is an aggregate holder for the current incoming
    request and the potential response. The object instance is instantiated on the
    initial JSF incoming request (Faces Request), and it will stay alive until the
    subsequent JSF `release()` method is triggered, which is usually deep inside the
    framework. `FacesContext` is the place from where a `FacesMessage` is added and
    from where the list collection of messages can be retrieved.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FacesContext` has several interesting methods including `isValidationFailed()`,
    which is useful to detect any validation failure earlier in the JSF lifecycle.
    We shall see an example of this call later with Bean Validation. There are other
    methods as well like using `getViewRoot()` to get the view root, `getCurrentPhaseId()`
    to get the current phase in the JSF lifecycle, and `getRenderKit()` to retrieve
    the render kit form. With the `isPostback()` method, we can find out if the request
    was an HTML form and if the JSF framework is about to send the data back to the
    same form. There is much more to the context objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to add a faces message to the context looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the `clientId` attribute is null, the message is a globally available message
    and is not associated with any view component.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've understood how to generate JSF- specific messages, let's delve
    into the validation of a JSF application.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a two main ways of achieving validation on the server side. One route
    to follow is through the use of Bean Validation version 1.1 from the Java EE 7
    specification, and the other traditional route takes you through JSF validation.
  prefs: []
  type: TYPE_NORMAL
- en: Constraining form content with Bean Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bean Validation is a specification that allows the developers to annotate the
    POJOs and entity beans and then call a custom validator instance to verify the
    properties. The validation framework works with Java annotation and thus, the
    digital engineer can firmly say how a property or even a method is validated.
  prefs: []
  type: TYPE_NORMAL
- en: I devoted an entire chapter to Bean Validation in the *Java EE 7 Developer Handbook*;
    nevertheless, I will run through the basics with you here, in this Digital Web
    Application book. There are several annotations in the Bean Validation 1.1 standard
    that you can use straightaway. However, if your platform allows or if you decide
    to add Hibernate Validator, then many more useful validation annotations are available.
    The developer can also create custom validations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `ContactDetail` entity again, but this time we have added Bean
    Validation annotations to the properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We added the annotations `@Pattern`, `@Past`, `@NotNull`, and `@Size` to the
    properties of the `ContactDetail` entity. The annotations can be found in the
    Java package `javax.validation.constraints`, reserved for Bean Validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table of the important Bean Validation annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constraint Name | Description | Allowed Types |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@Null` | Specifies that the element must be a null reference pointer. |
    Any |'
  prefs: []
  type: TYPE_TB
- en: '| `@NotNull` | Specifies that the element must not be a null reference pointer.
    | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `@Min` | Specifies that the element must be a number value that is greater
    than or equal to the minimum value supplied. Because of floating arithmetic rounding
    errors, float and double are not supported. | `BigDecimal, BigInteger, byte, short,
    int, and long` |'
  prefs: []
  type: TYPE_TB
- en: '| `@Max` | Specifies that the element must be a number value that is less than
    or equal to the minimum value supplied. Because of floating arithmetic rounding
    errors, float and double are not supported. | `BigDecimal, BigInteger, byte, short,
    int, and long` |'
  prefs: []
  type: TYPE_TB
- en: '| `@DecimalMin` | Similar to `@Min` but adds the ability to set the value as
    a String parameter. The number value must be greater than or equal to the supplied
    value. FP restriction also applies here. | `BigDecimal, BigInteger,``CharSequence,
    byte, short, int, and long` |'
  prefs: []
  type: TYPE_TB
- en: '| `@DecimalMax` | Similar to `@Max` but adds the ability to set the value as
    a String parameter. The number value must be less than or equal to the supplied
    value. FP restriction also applies here. | `BigDecimal, BigInteger,``CharSequence,
    byte, short, int, and long` |'
  prefs: []
  type: TYPE_TB
- en: '| `@Size` | The element''s size must be inside the supplied inclusive boundary
    limits. | `CharSequence, Collection, Map and primitive array` |'
  prefs: []
  type: TYPE_TB
- en: '| `@Past` | The element must be a date in the past according to the current
    time of the Java Virtual Machine. | `java.util.Date and java.util.Calendar` |'
  prefs: []
  type: TYPE_TB
- en: '| `@Future` | The element must be a date in the future according to the current
    time of the Java Virtual Machine. | `java.util.Date and java.util.Calendar` |'
  prefs: []
  type: TYPE_TB
- en: '| `@Pattern` | The element must match against a supplied regular expression
    pattern that conforms to the Java convention. | `CharSequence` |'
  prefs: []
  type: TYPE_TB
- en: Bean Validation annotations typically accept a message attribute, which is the
    validation message for the user, or it can be a value in brackets, which is a
    trigger for the validation framework to search for a message from `java.util.ResourceBundle`.
    Certain annotations like `@Min`, `@Max`, `@DecimalMin`, and `@DecimalMax` have
    additional attributes like `min` and `max` to specify the obvious boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an `@NotNull` constraint on the property with the validation
    message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is a good approach, possibly for prototyping a website; but as we know from
    our knowledge of software archaeology. This could be a maintenance nightmare,
    because we are writing a digital copy directly into Java code. It is far better
    to write a text copy inside a property file that can be picked up by the standard
    `ResourceBundle`, which Bean Validation uses. Jenny, our resident digital strategist
    and copywriting expert, will thank us for sending her a property file instead
    of Java source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s rewrite this constraint on the property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Bean Validation can be integrated with JSF by placing the messages at a specific
    location. The programmer need only create a `ValidationMessages.properties` file
    in the folder `WEB-INF/classes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extract of the message properties file for the `ContactDetail`
    entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With Bean Validation, we can add placeholders that are denoted with curly brackets
    to enrich the messages that the user will see. The placeholders are specific like
    `{min}` and `{max}`. The other advantage of property files is that the `ResourceBundle`
    in the JDK already handles the tricky topic of internationalization for different
    locales.
  prefs: []
  type: TYPE_NORMAL
- en: There are big disadvantages to just relying on Bean Validation using JSF. It
    is great for protecting a database from poorly entered data, and with the Java
    EE 7 application server that the digital developer gets almost for free, validation
    is added or amended to the database before each record. However, the Bean Validation
    has no connection to the JSF frontend. The framework does not have any association
    with the page author's content. Nor would we want this dependency between the
    presentation and the model layer in modern day software engineering. One of the
    best practices in object-oriented programming is the SOLID principle. We certainly
    want the layers to be singularly responsible for a purpose; open to extension,
    but closed to modification and, most importantly, to prevent the leaky abstractions
    that cause a technical debt in the software as it ages.
  prefs: []
  type: TYPE_NORMAL
- en: Another disadvantage about just relying on Bean Validation is that the verification
    of the data depends solely on the skills of the Java digital engineer. It means
    that the page author or designer cannot innovate, edit, or remove validation on
    the road to a better user-centric experience.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation is great for adding validation in the application logic. You
    can ensure that the contact detail's title is never blank, if this is a business
    requirement. Complex and group validations for properties can be achieved. Refer
    to my book, *Java EE 7 Developer Handbook*, for further details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows `bean-validation`/`createContactDetail.xhtml`
    in action from the book source code. The screenshot shows what happens when the
    user just submits the form without filling it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constraining form content with Bean Validation](img/image00385.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of Bean Validation on the contact details application
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:messages>` tag with the setting `globalStyle=true` shows the output
    of the validation messages that the framework discovers in the `ContactDetail`
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: Validating user input with JSF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSF has always had a validation framework since its inception in 2004\. It was
    a feature that separated JSF from the de facto Apache Struts web framework, at
    the time, as the latter had no built-in support for validation.
  prefs: []
  type: TYPE_NORMAL
- en: It is helpful to remember that conversion and validation occur at different
    phases of the JavaServer Faces lifecycle (review the diagram from [Chapter 2](part0025.xhtml#aid-NQU22
    "Chapter 2. JavaServer Faces Lifecycle"), *JavaServer Faces Lifecycle*, *The execute
    and render lifecycle* section). As a reminder, JSF will set the values in a component
    during the Apply-Request values phase and then use various conversions, if required,
    to transform the input String values to the target object. Validation occurs during
    the Process-Validations phase and this lifecycle follows by design. In order to
    transform the input data from the HTML request, JSF attempts and checks whether
    the parameters can be set in the backing bean. The Update-Model-Values phase follows
    the earlier phases. If a validation or a conversion error occurs in the lifecycle,
    then it is effectively shortened. JSF moves directly to the Render-Response phase
    and it converts the properties in the backing bean to Strings so that the web
    client can display them.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF provides a small set of prebuilt validator tags, which you can apply to
    mark up as a page author, A table of the Core JSF Custom Tags has been given in
    [Chapter 3](part0035.xhtml#aid-11C3M2 "Chapter 3. Building JSF Forms"), *Building
    JSF Forms*. Some of them are as follows: `<f:validateDoubleRange>`, `<f:validateLength>`,
    `<f:validateLongRange>`, `<f:validateRegex>`, and `<f:validateRequired>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply these tags to the contact detail CRUD example. So let''s start
    with the `createContact.xhtml` page. The following is a short extract from the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We placed the `<f:validateRequired>`, `<f:validateLength>`, and `<f:validateLongRange>`
    tags inside the body content of the JSF HTML rendering tags like `<h:inputText>`
    and `<h:selectOneMenu>`. The `validateLength` tag verifies the length of String
    property. The tag accepts a maximum parameter, but it can also take a minimum
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added a `<h:message>` tag close to its respective HTML input field.
    The `styleClass` attribute specifies a custom CSS selector that forces the validation
    message on a separate new line. The CSS for this looks like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to avoid JSF sugared names like `<jsf_form>:<form_property_name>`
    to the validation error message, which would give a result like `contactDetail:title
    -Validation Error: Value is required`, we specify the label attribute for each
    HTML render tag. The title input field has an attribute setting `label="Title"`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<f:validateLongRange>` tag checks if the actual content of the String is
    a numerical value between the minimum and maximum attributes. We use this tag
    in the `date-of-birth` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following extract is the authoring for the day field in the DOB group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates how the `<f:validateLongRange>` tag enforces
    the day-of-the month field in the form. We rinse and repeat for the other DOB
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<f:validateRegex>` tag matches the input property string against a regular
    expression. We use this tag for the `email` property. The following is the code
    for this validation check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is interesting to note that the overbearing pattern attribute value, the
    regular expression, is almost exactly the same as in the Bean Validation `@Pattern`.
    We had to convert the double backslash characters to single backslash, because
    we do not need to escape the literal in a normal regular expression, not set in
    Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the page `jsf-validation`/`createContactDetail.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating user input with JSF](img/image00386.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot demonstrating JSF built-in validation rules
  prefs: []
  type: TYPE_NORMAL
- en: Customizing JSF validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have played around with the source code and ran the example, I bet you
    would have noticed some glaring issues with the JSF validation. For instance,
    when the `email` field has a value that is not a valid e-mail address, you will
    see a validation message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, this very detailed application message fails the user-centric design
    and clean language for the public. What can we do with JSF to avoid these messages?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three attributes that can be applied to the HTML rendering tags for
    input fields like `<h:inputText>` and `<h:selectOneMenu>`. The following table
    shows the attributes that can help customize the JSF validation messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `requiredMessage` | Defines a value-based expression that will be used as
    a message text if the field is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `validatorMessage` | Defines a value-based expression that will be used as
    a validation text if the field and property fails validation. |'
  prefs: []
  type: TYPE_TB
- en: '| `conversionMessage` | Defines a value-based expression that will be used
    as a message if the field can be converted to the target type. |'
  prefs: []
  type: TYPE_TB
- en: 'With this information, we can easily solve our issue with the messages by applying
    the `requiredMessage` attribute to our field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `requiredMessage`, `validatorMessage`, and `conversionMessage` override
    any message that is set by the JSF validator on the server side. Note that these
    attributes can accept value expressions. This is great for page authors to dictate
    the method. On the other side of the fence though, our e-mail address field has
    two validation constraints, a regular expression check and a length-of-field constraint.
    The message is not appropriate for `validateLength`. So we have a problem there
    if we use more than one type of validator following this approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another approach that we could take. How about overriding the validation
    messages globally in the JSF framework? We can configure our own version of the
    JSF validator messages. In order to achieve this goal, first, we configure the
    framework with the information regarding the location for loading these messages.
    We set up a message bundle in the `WEB-INF/faces-config.xml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This configuration file defines the Faces resources for the application, and
    here we can configure a message bundle that references a property file. The path
    to the property file is actually `uk/co/xenonique/digital/JSFVMessages.properties`,
    which you find in the project resources `ch04/jsf-crud-validation/src/main/resources`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we supply our own message-bundle file. The contents of this property
    file `JSFVMessages.properties` are simply the following property definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have overridden the property `RegexValidator.NOT_MATCHED`
    to provide a new message. The original definitions are found in the JAR file in
    the application server or bundle as a third party JAR in your servlet container.
    The definitions can be found in the package of the JAR (`jsf-api-2.2.jar`) `javax/faces/Messages.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original definitions for the regular expression validator look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can examine this file in the source code at [http://svn.apache.org/repos/asf/myfaces/core/branches/2.0.x/api/src/main/resources/javax/faces/Messages.properties](http://svn.apache.org/repos/asf/myfaces/core/branches/2.0.x/api/src/main/resources/javax/faces/Messages.properties).
    As you can see, they are quite technical and user-unfriendly. Many property definitions
    in the message bundle do accept placeholders for the parameters. The `NOT_MATCHED`
    accepts two parameters: the first parameter `{0}` is the pattern and the second
    parameter `{1}` is the label of the input field.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java EE 7, the placeholders for parameterization in JSF validation are different
    from those in the Bean Validation framework. JSF uses integer indices, whereas
    Bean Validation can use named placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, there is a bug in the reference implementation of the
    JSF validator, which prevents the developers from using some of the placeholders
    in a message property. We would have enjoyed a property definition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, the current bug in Mojarra prevents us from writing this out as production
    code.
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative strategy to customizing the JSF validation. We can define
    our own validators in order to extend the functionality of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSF allows the digital engineer to configure a method in a managed bean controller
    that will be called to validate a field. Adding the attribute validator to the
    HTML render tags accomplishes this strategy, and it is a value expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a way to add a custom validation method to the `emailAddress`
    property of the contact detail form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The attribute validator references the method `validateEmailAddress()` in the
    modified `ContactDetailControllerJV` bean. This method looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding method `validateEmailAddress()`, the incoming parameters are
    the `FacesContext`, the component being validated is of type UIComponent, and
    the pending value to be checked is of type Object. This method is validating two
    constraints: it checks that the length of the field is not too long and that the
    field is an e-mail address. We use the JDK standard library `javax.regex` package
    to fulfill this. To assert the validation errors, if any, we create the `FacesMessage`
    objects and add them to the current `FacesContext` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom validators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing validators in controllers or a CDI named bean is a helpful strategy.
    However, the disadvantage is that you always need an indirect POJO in your application.
    There is another strategy where JSF allows us to define custom validators, which
    are integrated within the framework. A developer may choose to write a POJO that
    is declared with the annotation `javax.faces.validator.FacesValidator`. The POJO
    must implement the interface `javax.faces.validator.Validator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move our e-mail address checking code into a custom validator. The code
    for `FacesEmailAddressValidator` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This class is annotated with `@FacesValidator`, and the single argument identifies
    the name of the validator in the page view. The method `validate()` implements
    the design by constraint in the validator interface. JSF passes in the `FacesContext`,
    the associated component with the input value, and the value itself.
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve the input value as a text string. The regular expression code that
    validates the e-mail address is almost the same as before except for the message
    key. The error key is `{application.emailAddress.pattern}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our POJO custom validator in place, we can rewrite the HTML on the page
    view to use it. The following is the extract view from `login.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is the validator attribute in the `<h:inputText>` element.
    This attribute specifies the custom validator by name as `emailValidator`. As
    we can see, we can combine the custom validator with the default standard validators.
    There is still a `<f:validateRequired>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the rendered output of `LoginControllerJV`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining custom validators](img/image00387.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A front-end page view demonstration two-factor security login and validation
  prefs: []
  type: TYPE_NORMAL
- en: Validating groups of properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have knowledge of the JSF custom validators, we can write a custom
    validator to verify the group Date-of-Birth input fields. We can achieve this
    goal, because the `FacesContext` has been passed. It is possible to look up the
    UI components individually, separate from the context.
  prefs: []
  type: TYPE_NORMAL
- en: We shall use the JSF technique called binding inside a page view. Binding effectively
    publishes the instance of `javax.faces.component.UIInput` in JSF value and makes
    it available elsewhere in a page. The attribute binding on the HTML rendering
    JSF tags binds a component's reference in the component tree to a scoped variable.
    The following is the relevant JSF code. In particular, pay close attention to
    the JSF hidden input element at the start of the code extract from `jsf-validation/createContact.xhtml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We utilize the hidden field, which is identified as `aggregateDobHidden` with
    a dummy form parameter name `hiddenField1`. It always sends a true value. The
    `<f:attribute>` element appends additional binding information to this UI component.
    We need three attributes with the names `dob_dotm` (day of the month), `dob_moty`
    (month of the year), and `dob_year`. These attributes are value expressions for
    the similarly-named page scope variables `#{dob_dotm}`, `#{dob_moty}`, and `#{dob_year}`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a binding attribute to each of the JSF selection components. Look at
    the following first field, again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The attribute binding associates the component to the view and makes it available
    in the page scope variable defined by the literal String definition `#{dob_dotm}`.
    This is an instance of the `javax.faces.component.UIInput` class, which has a
    `getSubmittedValue()` method to get the submitted value. We repeat adding the
    binding for the other two properties. During a form submission, `hiddenField1`
    has the record of bound values for each of the individual properties. This property
    is different from the individual day, month, and year properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'This trick with the binding allows us to group properties together for form
    validation. The following source code shows the validation on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The POJO `FacesDateOfBirthValidator` verifies the three DOB properties. It does
    this using a technique in JSF called binding in the page view, which we will see
    in a minute. Binding allows JSF input properties to be propagated to another named
    scope variable that can be used elsewhere on the page. As for the validator, we
    use an HTML hidden element as a vehicle to retrieve these bounded values as attributes.
    This is the purpose of the code that casts the component to `javax.faces.component.UIInput`
    and then extracts a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have a helper method, `parsePositiveInteger()` for converting the text value
    to an integer. Before that, we create a list collection to store any error messages.
    We then validate the boundary for the day-of-the month from 1 to 31\. The logic
    is almost identical for the month property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the year property, we take a different step. Using the JDK Calendar and
    Date classes, we build two Date instances: one represents the current date exactly
    100 years ago and the other represents the current date 18 years ago. We can then
    compare if the user''s entry date falls inside these two birthday limits.'
  prefs: []
  type: TYPE_NORMAL
- en: If there are any errors at the end of the method `validate()`, then it raises
    a `ValidatorException` exception with the error collections. Note that we elect
    to use the alternative constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the validator, the helper method `parsePositiveInteger()` can be
    written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of the contact detail that demonstrates the group
    validator in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating groups of properties](img/image00388.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the date of birth validators
  prefs: []
  type: TYPE_NORMAL
- en: Converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard JSF validators allow the digital developer to achieve a lot of
    functionality. There are circumstances when the requirements exceed the default
    behavior. Converters are JSF classes that convert between strings and objects.
    Similar to the way in which annotations define the custom validator, JSF permits
    the registration of custom convertors. A converter is associated with a JSF component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The annotation `@java.faces.convert.FacesConverter` denotes that a POJO is
    a custom JSF converter. This type must implement the `javax.faces.convert.Converter`
    interface, which has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The method `getAsObject()` converts a string representation from the client
    to the target object. The other method `getAsString()` converts the object to
    the string representation, which is rendered in the client browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall exemplify the custom JSF converter with one that converts a string
    to the suits of playing cards. We can write this using a simple Java enumeration
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the full listing for the custom converter `FrenchSuitConverter`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The POJO is the annotated `@FacesConverter`, and the value becomes the identifier
    in the page view.
  prefs: []
  type: TYPE_NORMAL
- en: JSF invokes the `getAsObject()` method with the text representation, which is
    trimmed and transformed to the uppercase in order to make the comparisons easier.
    At the beginning of the method, there is a possibility that the new value could
    be a blank string. If this is true, then we retrieve the text representation from
    the already submitted value. For this particular converter, the use case of an
    empty value is a possibility, so we add the guard. If there is an issue with the
    process, the method raises an exception, `javax.faces.convert.ConverterException`.
  prefs: []
  type: TYPE_NORMAL
- en: JSF calls the `getAsString()` method in order to convert the object representation
    to a String. Depending on the object type, the method defends against the different
    types of input. The input value may be just a string, or it may be an instance
    of the `FrenchSuit` enumeration. If the input value is not one of these, the method
    raises `ConverterException`.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, we know that there will always be four suits in a set of
    playing cards, and therefore, we can be fairly confident about the maintainability
    of our enumeration. As a digital developer, you may not have such luxuries, and
    hence, applying the principle of defensive programming in a converter and a validator
    can go a long way to tracking down bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extract from the page `/jsf-validation/french-suit.xhtml`
    that exercises the custom converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding view, we are using a dropdown menu `<h:selectOneMenu>` that
    allows the user to select a card suit. The code should be very familiar to you
    by now. The difference lies in the value expressions for each card suit, which
    are all method invocations with a String-literal parameter. The Expression Language
    allows you to call methods with parameters. Therefore, the expression: `#{frenchSuitController.suitEnumValue(''HEARTS'')}`
    translates to a method call on the controller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the body content of `<h:selectOneMenu>`, we explicitly reference the
    custom converter by an identifier, and associate it with the UI component through
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: JSF then invokes the custom converter in order to translate the individual `FrenchSuit`
    enumeration to a String from the page view. It sounds like a roundabout way to
    show a list of values, but this example demonstrates that the method `getAsString()`
    in `FrenchSuitConverter` is being called. Additionally, it illustrates how to
    reference Java enumeration in a page view and in a controller in a robust manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the controller now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are jumping ahead slightly with this code for `FrenchSuitController`. First,
    let me draw your attention to the method `suitEnumValue()`, which converts a String
    literal to the enumeration type `FrenchSuit`. This is a nice handy trick for obtaining
    enumerations in the page view, because Expression Language does not allow direct
    access to the Java enumerations. It will especially work with enumerations that
    change over time through different project releases.
  prefs: []
  type: TYPE_NORMAL
- en: The `doAction()` and `cancel()` methods return the URI with a special query
    parameter `redirect=true`. This is an instruction for JSF to return a bookmarkable
    URL; we shall cover this topic much later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Within `doAction()` we are making use of the Flash scope in JSF for the first
    time. The Flash scope is a temporary context that allows the controllers to pass
    on data to the next navigation view. Remember that the View scope is only valid
    for the current controller that navigates to the same page view. The `@ViewScoped`
    managed beans go out of scope when the `FacesContext` moves to the next page view.
    The methods set a key value association in the `javax.faces.context.Flash` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of the puzzle demonstrates how we use the Flash scope in a
    page view. This code can be found in the file `/jsf-validation/french-suit-complete.xhtml`.
    The following code is an extract from the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this page view, we use the map expression to retrieve values from the Flash
    scope. The expression `#{flash['suit']}` is the suit that the user selected. The
    reader is also directed to look at the documentation for the default JSF converter
    `javax.faces.convert.EnumConverter`. In the same package, there are other standard
    converters such as `BigDecimalConverter`, `BigIntegerConverter`, `DateTimeConverter`,
    `ByteConverter`, `LongConverter`, and `DoubleConverter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will leave you with the screenshot for the form view `french-suit.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converters](img/image00389.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the suites of cards with the JSF convertor
  prefs: []
  type: TYPE_NORMAL
- en: The following is a screenshot showing the end state of `french-suit-complete.xhtml`.
    The mark up shows nice visuals in the CSS jumbotron style from Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: '![Converters](img/image00390.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The second screen from the house of cards example after form submission and
    validation
  prefs: []
  type: TYPE_NORMAL
- en: We have covered a lot of validation that happens on the server side. Let's now
    move on to AJAX validation.
  prefs: []
  type: TYPE_NORMAL
- en: Validating immediately with AJAX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Asynchronous JavaScript and XML** (**AJAX**) is a group of technologies that
    together solve the restriction to the retrieving of partial updates to a web page
    and that provide a rich interactive user experience. The key to AJAX is the term
    *asynchronous*, which builds on a **World Wide Web Consortium** (**W3C**) standard
    namely, the `XmlHttpRequest` object. It was introduced in the Internet Explorer
    in 2006 and all modern web browsers by now support this object. The asynchronous
    mode allows the browser to make a data transfer request to the server on a separate
    connection; the enterprise backend response responds with a data result, usually
    JSON or XML. These AJAX data transfers tend to be smaller in comparison to reloading
    the entire page each time.'
  prefs: []
  type: TYPE_NORMAL
- en: JSF has built-in support for AJAX requests and responses; the developer does
    not have to know the finer details of `XmlHttpRequest` and JavaScript programming
    to get the benefit of an immediate response. The digital developer can start with
    the default JavaScript library for performing AJAX interaction.
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy to get started with AJAX in JSF with the `<f:ajax>` tag. This
    Core JSF tag registers the AJAX behavior with a UI component, and it is used to
    perform validation on a field. Developers are only required to place the tag inside
    the body content of an HTML JSF tag that represents a component, which requires
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to use this tag with the contact details application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `tag` attribute event establishes when the framework would invoke the AJAX
    validation. The blur value denotes that it occurs when the user moves from this
    component field to the next input field. So when the user presses the *Tab* key
    on a desktop computer or navigates the UI on a phone or a tablet, validation occurs
    immediately, because JavaScript fires an AJAX request to the server. The second
    attribute, render, informs the framework about the specific UI component to render
    the error message to, if any. JSF receives an AJAX response, and if there is an
    error, it knows the HTML component ID to update with the validation message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the project `ch04/jsf-crud-ajax-validation`, which is the full
    extract of the page view `jsf-validation/createContactDetail.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This page view exemplifies that adding the AJAX validation to a page is extremely
    easy in JSF. The `<f:ajax>` Core JSF tag is embedded in the corresponding HTML
    JSF tag, as you can see for the first and last name fields. The other difference
    between the non-AJAX and AJAX page for contact details is the addition of the
    identifiers such as `firstNameError` and `lastNameError` to the `<h:message>`
    tag. We need to add the HTML identifier elements for allowing JavaScript to look
    up the HTML element by ID from the browser's **Document Object Model** (**DOM**).
  prefs: []
  type: TYPE_NORMAL
- en: The page has an AJAX validation added to all the properties except for the middle
    name and the newsletter HTML checkbox field. AJAX validation also works with custom
    validators and converters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the single property AJAX validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating immediately with AJAX](img/image00391.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot demonstrating single validations for each input fields
  prefs: []
  type: TYPE_NORMAL
- en: Validating groups of input fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we have seen the JSF AJAX validation on single instances of input fields.
    The `<f:ajax>` tag also works with validation on a group of components. We can
    enclose the tag around one or more JSF input fields and then the `<f:ajax>` tag
    becomes the parent of the UI component. This causes JSF to apply the AJAX validation
    to multiple components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the group validation to the Date-of-Birth fields in the contact
    details form with the following page view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we surround the DOB input fields with an encompassing `<f:ajax>`
    tag. The event attribute is still set to `blur`. The render attribute is set to
    a list of the HTML element IDs for specific validation messages, namely `dobDayError`,
    `dobMonthError`, and `dobYearError`.
  prefs: []
  type: TYPE_NORMAL
- en: The `aggregationDobHidden` HTML hidden element is kept the same as in the non-AJAX
    example in order to illustrate that the validation does not interfere with the
    custom validation.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, use the `<f:ajaxTag>`, and embed it inside any JSF component. To validate
    over a group of multiple components, surround the components with `<f:ajaxTag>`.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot depicts the multiple component AJAX validation around
    the DOB fields. The month-of-the-year component had the browser's focus last and
    hence, the corresponding validation message depicts the `onblur` DOM JavaScript
    event. Similarly, tabbing across this set of fields produces the error messages
    one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating groups of input fields](img/image00392.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the group validation for date of birth input fields
  prefs: []
  type: TYPE_NORMAL
- en: AJAX custom tag in depth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is useful to understand the attributes that can be applied to this Core JSF
    custom tag. The following table describes the attributes for `<f:ajax>`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `delay` | Specifies the delay in milliseconds between sending multiple AJAX
    requests to the server. Requests are queued up by the JSF implementation. Setting
    the value to none disables the feature. |'
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | Specifies a Boolean value to indicate the tag status. If set
    to true, then the AJAX behavior is not rendered. The default value is false. |'
  prefs: []
  type: TYPE_TB
- en: '| `event` | Defines a String enumeration that represents the event type of
    the AJAX action. By default, JSF determines the event name for the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `execute` | Enumerates a space-delimited collection of names that represent
    the components that are executed on the server. The value can be a string or a
    value expression. The default value is `@this`, which indicates the parent component
    of the AJAX behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| `immediate` | States a Boolean value that indicates whether the input value
    is processed early in the JSF lifecycle. |'
  prefs: []
  type: TYPE_TB
- en: '| `listener` | Indicates the name of the listener method that will be called
    during a broadcast event, namely `AjaxBehaviorEvent`. |'
  prefs: []
  type: TYPE_TB
- en: '| `onerror` | Specifies the name of a JavaScript function that will accept
    errors. |'
  prefs: []
  type: TYPE_TB
- en: '| `onevent` | Specifies the name of a JavaScript function that will handle
    the UI events. |'
  prefs: []
  type: TYPE_TB
- en: '| `render` | Enumerates a collection of UI components that will be rendered
    on the client when the AJAX behavior completes. This value can be a space-delimited
    collection of component identifiers, or it can be a value expression. The default
    value is `@none`, which means that no components are rendered. |'
  prefs: []
  type: TYPE_TB
- en: 'From this preceding table, you will notice that the execute and render attributes
    may indicate additional meaningful values. The execute attribute stipulates the
    components to be executed on the server. The render attribute determines the affected
    UI components for when the AJAX behavior completes. The following table lists
    the attribute values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@all` | Specifies that all the components are executed or rendered in the
    view. |'
  prefs: []
  type: TYPE_TB
- en: '| `@form` | Specifies that only the components that are the children of the
    form are executed or rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `@none` | Specifies that no components are executed or rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `@this` | Specifies that only the current component that triggered the AJAX
    request is executed or rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `List of component identifiers` | Enumerates the identifiers of the UI components
    that are explicitly executed or rendered as an AJAX request. |'
  prefs: []
  type: TYPE_TB
- en: '| `Expression language` | Specifies a value expression that ultimately returns
    a collection of Strings, which indicates the UI components that are executed or
    rendered as an AJAX request-response. |'
  prefs: []
  type: TYPE_TB
- en: A partial JSF lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSF lifecycle is, in effect, for all Faces requests and responses including
    those that emanate from the AJAX-enabled components. Behind the scenes, JSF instantiates
    a special object, `javax.faces.context.PartialViewContext` for the AJAX requests
    and responses, and that is entered into the processing lifecycle. This context
    object contains the information that allows JSF to update the component model
    on the server-side. Based on the partial context, JSF decides whether to accomplish
    partial processing of the selected UI component and/or partial rendering of the
    UI components. Partial processing corresponds to the Apply-Requests-Values, Process-Validations,
    and Update-Model-Values phases of the lifecycle. Partial rendering refers to the
    Render-Response phase.
  prefs: []
  type: TYPE_NORMAL
- en: '![A partial JSF lifecycle](img/image00393.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Partial request – response lifecycle for AJAX submissions
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram encapsulates our understanding of the partial context
    for the AJAX request and response in the JSF lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Handling views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've chiefly examined the validation of the users' input with
    JSF. There were some miscellaneous concepts regarding navigation that we glossed
    over. Let's now talk about handling views and navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking controller methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to invoke the controller from a page view with parameters.
    For many situations in the digital e-commerce applications, developers need to
    retrieve a particular data record, trigger a server-side action, or save a certain
    state from the client-side at the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized method invocations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSF allows the developer to pass parameters to methods in the page view using
    the Expression Language . The first feature given in [Chapter 3](part0035.xhtml#aid-11C3M2
    "Chapter 3. Building JSF Forms"), *Building JSF Forms* is called Method Expression
    Invocation, which was introduced in JSF 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extract from the page view `/jsf-miscellany/examplar-methods.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code depicts the `<h:commandButton>` tag with an action value
    expression, which is `#{examplarController.methodThreeArgs('Obiwan','Ben','Kenobi')}`.
    This is a method invocation with three arguments of literal string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments can also be references to other JSF scope instances. The following
    is another invocation with only two arguments that show this off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments are dynamically set from the controller bean properties. Let''s
    look at the controller `ExamplarController` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There are three methods that are called `methodOneArg()`, `methodTwoArgs()`,
    and `methodThreeArgs()`. The names are self-explanatory for the number of arguments
    that can be passed; each one saves an output result in the JSF Flash scope, before
    moving to the next page view, `/jsf-miscellany/examplar-methods-complete.xhtml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the extract of the end state Facelet view, `exemplar-methods-complete.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Passing parameters to the controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before the JSF 2.0 specification was created, it was possible to send parameters
    to a backing bean controller using the `<f:param>` tag inside of the body of a
    `<h:commandLink>`, `<h:commandButton>`, or `<h:link>` tag. Although this technique
    is superseded by the method invocation expressions in JSF 2.0, it is still a useful
    technique to send out-of-bounds communication to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the recipe, and we embed two `<f:param>` elements
    in a `<h:commandButton>` custom tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The authoring on this page view invokes the controller's no argument method,
    `methodPassingParameters()`. JSF passes two parameters to the target method through
    the Faces request with the key names `callToActionText` and `customerType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the controller method that handles this invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Inside the method `methodPassingParameters()`, we retrieve the parameters from
    the `FacesContext` instance by using the nested call `getRequestParameterMap()`.
    It is then straightforward to access the parameters from the map collection of
    type `Map<String,String>`. It is interesting to note that the parameters can only
    be Strings, and that this technique can be combined with method parameters invocations
    in JSF 2.0 and later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays the page to demonstrate the method invocation
    techniques described in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing parameters to the controller](img/image00394.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the method invocation JSF example
  prefs: []
  type: TYPE_NORMAL
- en: Invoking an action event listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final technique for handling views invokes an action listener in the controller.
    Any instance method that accepts a single argument of `javax.faces.event.ActionEvent`
    can be an action event listener. An action listener is associated with a UI component
    in the page markup. JSF invokes action listeners before invoking the actions,
    so this technique is helpful for hooking in the business logic and setting up
    data for the action call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an extract from the method invocation page that enacts this
    technique. We will dispense with the Bootstrap CSS markup in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `<h:commandButton>` tag has an additional `actionListener` attribute set
    to the expression that references the action listener method, `attributeListener()`.
    The tag also embeds an `<f:attribute>` to define a passed attribute. The action
    attribute references the method `performAction()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine our `ExamplarController` backing bean to see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: On submission of the command button, JSF invokes the method `attributeListener()`
    first with an `ActionEvent` instance. We can find the component responsible for
    the invocation and retrieve the attributes stored on it. In this case, we retrieve
    the value for the attribute keyed in as `contactName`. This value is stored in
    the controller's instance variable. (We must be careful with this technique if
    the scope of our backing bean is set to a scope other than `@RequestScope` or
    `@ViewScope`, because the instance variable will be shared between multiple requests
    over time!)
  prefs: []
  type: TYPE_NORMAL
- en: After the action listener returns, eventually, JSF invokes the action method
    `performAction()`. The instance variable `contactName` is available and has the
    current value from the page. The method proceeds to the next page view.
  prefs: []
  type: TYPE_NORMAL
- en: Redirection pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have been following the examples in this chapter, you must have noticed
    that the page views have been suffixed with a query parameter `redirect=true`
    (or `faces-redirect=true`, according to the official JSF specification). This
    is an instruction to JSF for sending an HTTP Response back to the web client to
    be redirected to a URL. Why is this suffix required? It allows the user to bookmark
    page views, because the JSF framework effectively hides the current page view
    from the user by just rendering the output. The main issue is internal page forwarding
    that makes it difficult for the customers using a digital application to remember
    or bookmark their location. If the customer has a deeply nested site of information
    architecture, the ability to provide page redirection is key. The secondary issue
    is that if your web application exercises a flow of process in a linear fashion,
    then the web browser's URL is updated, but always shows the previous page in the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Redirection works in controller methods `examplar-methods-complete?redirect=true`
    that cause JSF to send an HTTP Response Redirect to the browser. The web browser
    interprets the redirect to another HTTP GET request for a URL such as `http://localhost:8080/jsf-crud-ajax-validation-1.0-SNAPSHOT/jsf-miscellany/examplar-methods.xhtml`.
    The consequence of the redirection is that there are at least two request-response
    events occurring for each page navigation or action. If you remember, the scope
    of `@ViewScoped` or `@RequestScoped` bean is available only for a short duration.
    By the time JSF processes the HTTP GET from the redirection instruction, the original
    bean has already disappeared. This is the reason why the examples use the Flow
    scope; that scope guarantees that the data from the controller business logic
    survives till the next page view is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to specify page redirection is through `faces-config.xml` for
    particular navigation cases. We can define a case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This style of configuration can be useful in setting up third-party JSF packages.
    Of course, it also provides flexibility for library writers, and it does not pollute
    the Java-managed bean redirect strings. I suppose it is a horses-for-courses situation
    and, therefore, depends on the purpose of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the developer can set redirection directly to page views through submission
    links and buttons. The following code shows this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Debugging the JSF content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybe I should have introduced this feature of JSF earlier, because learning
    to develop with JSF can be puzzling to beginners. It is possible to get debuggable
    output in a JSF application if you include the `<ui:debug/>` custom tag element
    inside one of the template views. Actually, the Facelet view renderer output of
    the framework is responsible for this feature.
  prefs: []
  type: TYPE_NORMAL
- en: By embedding a single `<ui:debug>` inside a `<ui:insert>` tag causes JSF to
    add a special UI component to the UI hierarchy tree. This debug component captures
    the Facelet view information and current state of the UI hierarchy, including
    any scoped variables in the application. Information is captured at the time of
    rendering . If the user presses the keys *Ctrl* + *Shift* + *D*, JSF opens a separate
    browser window showing the debuggable information, which is really useful in tough
    situations. The main template of the application is the best place to add the
    `<ui:debug>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<ui:debug>` tag accepts the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `hotkey` | `String` | Defines the single character of the hotkey that causes
    the debuggable window to open. The default is `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `rendered` | `ValueExpression` | Specifies if the debug component is rendered
    or not. It must be a value expression or a String literal that evaluates to `true`
    or `false`. |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot shows the exemplar method invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the JSF content](img/image00395.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the plus (**+**) symbols expands the content so that the developers
    see more information dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter focused on the different forms of JSF validation, because it is
    extremely important for the user to know if the data has been entered correctly.
    We examined the two forms of validation methods: client side and server side.
    We looked at the `FacesMessage` instances and learnt how to create them. Afterwards,
    we proceeded to cover validation from the server side, particularly, the Bean
    Validation framework in Java EE 7\. We then took an extended developer journey
    into JSF validation. We learnt how to create custom validators and converters.
    We also learnt how to perform immediate mode validation with AJAX and understood
    the partial context life cycle. Finally, we spent a good deal of time on handling
    views and passing information from the page view to the controller. Along the
    way, we addressed the JSF flow scope and page redirection.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will turn our attention to conversational scopes and
    start putting the useful process flow applications together. At this point, we
    add finesse and sophistication to our burgeoning digital JSF applications. I will
    you see there.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the fundamental difference between the `<h:outputLink>` and `<h:commandButton>`
    elements? How do you style the control elements appropriately with a CSS framework
    such as Bootstrap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the previous chapter, there were exercises around developing a web application
    for registering new people to a local hobbyist book-reading club. Did you happen
    to write content in separate pages with no reuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the UI template compositing to your hobby book club project. Call this
    version two and save the first version for your reference. Make use of the Template
    Composition tags `<ui:define>`, `<ui:composition>`, and `<ui:insert>` only at
    this stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<ui:debug>` custom tag to master the template page. What does this special
    tag do for the developer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An annoyed business stakeholder arrives at your office and tells you about an
    issue that they are having with spoof data. It seems that some naughty people
    on the Internet are faking data entry and this is causing more burden for the
    caseworkers. As a consultant with JSF, explain how you can protect the data in
    the backend database using validation. Would only a server-side validation work?
    Would only client-side validation work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With reference to the previous Hobby Book Club application, let's now add validation
    to the JSF form elements that you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Bean Validation to the registrant class (`Registrant.java`—you may have
    named this class differently in your own project). Will your users be satisfied
    with the validation output?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you add only the server-side validation to an application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the differences between Bean Validation and JSF validation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the similarities between Bean Validation and JSF validation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How appropriate are the error messages for Bean Validation and JSF validation
    according to the users ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start with the creation page. Validate against the registrant's name. You can
    validate with `<f:validateRequired>` and `<f:validateLength>` directly on the
    page view. Add appropriate `<h:messages>` to the page view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some registrants use social networks like Facebook, Twitter, and Instagram.
    Add some properties to the Registrant POJO. Add a URL validator to verify that
    the social network properties are correct. Use the regular expression validator
    to verify the Twitter account syntax or, perhaps, write your own custom validator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the book's source code example and run the sample code for Chapter
    4\. Study how validation occurs from the server side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given that you have developed your project with server-side validation, you
    must take the Hobby Book Club web application up a notch. Add client-side validation
    with AJAX for control elements. You will need to add appropriate `<f:ajax>` elements
    to your JSF form control elements. Don't forget that each control requires an
    area to render a specific error message; so, you will not add a corresponding
    `<h:message>` element on the page in close proximity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the Chrome Developer Web Tools or similar web page inspection development
    tools, and inspect the HTML content of the JSF application. What do you observe
    and notice about the naming of the various HTML elements, especially the forms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a breather and add modern CSS styles to the Hobby Book Club application.
    Ask a colleague or friend to evaluate the user experience of your application
    and gather feedback. Act on the feedback; change the content around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a cancel operation to your CRUD application; what do you need to ensure
    that JSF does not validate the input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
