- en: Implementing Modern Java Enterprise Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施现代Java企业应用程序
- en: Now after we saw what components are contained in projects and modules and how
    to find and construct reasonably sized modules and packages, let's get more down
    to earth and discuss the topic of Java EE. It certainly makes sense to think about
    the business concerns first and follow the practices of Domain-Driven Design to
    identify bounded context and modules with all the contents of our domain.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了项目中包含哪些组件以及如何找到和构建合理大小的模块和包，让我们更接地气地讨论Java EE的话题。首先考虑业务问题，并遵循领域驱动设计的实践来识别边界上下文和包含我们领域所有内容的模块，这当然是有意义的。
- en: Let's see how to realize the identified business modules and use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现已识别的业务模块和用例。
- en: 'This chapter will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖：
- en: How to implement application use case boundaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现应用程序用例边界
- en: What the Java EE core domain components are
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE核心领域组件是什么
- en: Design patterns and Domain-Driven Design with Java EE
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java EE进行设计模式和领域驱动设计
- en: Application communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序通信
- en: How to integrate persistence
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何集成持久化
- en: Technical cross-cutting concerns and asynchronous behavior
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术横切关注点和异步行为
- en: Concepts and principles of Java EE
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE的概念和原则
- en: How to achieve maintainable code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现可维护的代码
- en: Use case boundaries
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例边界
- en: Organizing packages after domain concerns leads us to an architectural structure,
    where the actual business, rather than technical details are reflected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据领域关注点组织包，使我们达到一个架构结构，其中实际业务而不是技术细节得到反映。
- en: The business use cases handle all logic required to fulfill the business purpose,
    using all our module contents. They act as a starting point into the application's
    domain. The use cases are exposed and invoked via the system boundaries. The enterprise
    systems offers communication interfaces to the outside world, mostly via web services
    or web-based frontends, that invoke the business functionalities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 业务用例处理实现业务目的所需的所有逻辑，使用我们模块的所有内容。它们作为进入应用程序领域的起点。用例通过系统边界公开和调用。企业系统提供与外部世界的通信接口，主要通过Web服务或基于Web的前端，调用业务功能。
- en: When starting a new project, it makes sense to start with the domain logic first,
    indifferent to system boundaries or any technical implementation details. This
    contains constructing all contents of the domain, designing types, dependencies
    and responsibilities, and prototyping these into code. As we will see in this
    chapter, the actual domain logic is implemented primarily in plain Java. The initial
    model can be self-sufficient and tested solely using code level tests. After a
    sufficiently matured domain model has been found, we target the remaining technical
    concerns that are outside of the domain module, such as accessing databases or
    external systems, as well as system endpoints.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动新项目时，首先从领域逻辑开始是有意义的，不考虑系统边界或任何技术实现细节。这包括构建领域所有内容、设计类型、依赖和责任，并将这些原型编码化。正如我们将在本章中看到的，实际的领域逻辑主要是用纯Java实现的。初始模型可以自给自足，仅使用代码级别测试进行测试。在找到一个足够成熟的领域模型后，我们将针对领域模块之外的技术问题进行目标定位，例如访问数据库或外部系统，以及系统端点。
- en: In a Java EE application, a boundary is implemented using managed beans, that
    is, **Enterprise JavaBeans** (**EJB**) or **Contexts and Dependency Injection
    for Java** (**CDI**) managed beans. The topic *EJB and CDI - differenciation and
    integration* will show the differences and significance of these technologies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE应用程序中，边界是通过托管Bean实现的，即**企业JavaBean**（**EJB**）或**Java的上下文和依赖注入**（**CDI**）托管Bean。主题“EJB和CDI
    - 区分和集成”将展示这些技术的差异和重要性。
- en: Depending on the complexity of the individual use cases, we introduce *delegates*
    which are realized as CDI managed beans or EJBs, as well, depending on the requirements.
    These delegates reside in the control package. Entities are realized as POJOs,
    optionally annotated to integrate technical functionality such as specifying the
    database mapping or serialization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据单个用例的复杂性，我们引入了*委托*，这些委托作为CDI托管Bean或EJB实现，具体取决于需求。这些委托位于控制包中。实体作为POJO实现，可选地注解以集成技术功能，例如指定数据库映射或序列化。
- en: Core domain components of modern Java EE
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代Java EE的核心领域组件
- en: Plain Java together with CDI and EJB form the core domain components of a modern
    Java EE application. Why is it called core domain? As mentioned, we want to pay
    attention to the actual business. There are aspects, components, and functionality
    that serve the business purpose at their core, whereas others just *support*,
    make the business domain accessible, or fulfill other technical requirements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 纯Java与CDI和EJB结合，形成了现代Java EE应用程序的核心领域组件。为什么称之为核心领域？正如所述，我们希望关注实际业务。有些方面、组件和功能在其核心上服务于业务目的，而其他方面只是*支持*，使业务领域可访问，或满足其他技术需求。
- en: Java EE ships with many APIs that support realizing dozens of technical requirements.
    Most of them are technically motivated though. The biggest advantage of the Java
    EE platform, however, is that clean Java business logic can be implemented with
    minimal code impact of the technology. The APIs required for that are mainly CDI
    and EJB. Other APIs, that are required for technical motivations, such as JPA,
    JAX-RS, JSON-P, and many others, are introduced with a secondary priority.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE提供了许多API，支持实现数十个技术需求。尽管大多数API都是技术驱动的。然而，Java EE平台最大的优势是，可以使用最少的代码影响实现干净的Java业务逻辑。为此所需的API主要是CDI和EJB。其他API，如JPA、JAX-RS、JSON-P等，由于技术驱动的原因，其引入具有次要优先级。
- en: Managed beans, no matter whether CDI or EJB, are implemented as annotated Java
    classes, without any technical super classes or interfaces required. In the past,
    this was called the no-interface view. Nowadays this is the default case. Extending
    classes obscure the picture on the domain and also come with other shortcomings
    when it comes to testability. A modern framework integrates itself as simply and
    as lean as possible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Bean，无论是CDI还是EJB，都作为注解Java类实现，不需要任何技术超类或接口。在过去，这被称为无接口视图。如今，这已成为默认情况。扩展类会模糊领域视图，并且在可测试性方面也存在其他缺点。一个现代框架尽可能地简单和精简地集成自身。
- en: EJB and CDI - differentiation and integration
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB和CDI - 区别与集成
- en: Now the question is, whether to use EJBs or CDI managed beans.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，是否使用EJB或CDI管理的Bean。
- en: In general, EJBs ship more functionality that is already usable out of the box.
    CDI managed beans offer a somewhat lighter alternative. What are the main differences
    between these technologies and how does it affect the developer's work?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，EJB提供了更多开箱即用的功能。CDI管理的Bean提供了一种相对较轻的替代方案。这些技术的主要区别是什么，以及它们如何影响开发者的工作？
- en: The first difference are the scopes. EJB session beans are either stateless,
    that is, active during the duration of the client request, stateful, that is,
    active during the lifespan of a client's HTTP session, or singletons. CDI managed
    beans come with similar scopes plus more possibilities, such as adding custom
    scopes and the default dependent scope which is active depending on the lifespan
    of its injection point. The topic *Scopes* will handle bean scopes more detailed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别在于作用域。EJB会话Bean可以是无状态的，即在客户端请求期间活跃，也可以是有状态的，即在客户端的HTTP会话生命周期内活跃，或者单例。CDI管理的Bean具有类似的作用域，还有更多可能性，例如添加自定义作用域和默认的依赖作用域，该作用域根据其注入点的生命周期而活跃。主题“作用域”将更详细地处理Bean的作用域。
- en: Another difference between EJBs and CDI beans is that EJBs implicitly comprise
    certain cross-cutting concerns, such as monitoring, transactions, exception handling,
    and managing concurrency for singleton beans. For example, calling an EJB business
    method implicitly starts a technical transaction, which is active during the method
    execution and which integrates datasources or external systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: EJB和CDI Bean之间的另一个区别是，EJB隐式包含某些横切关注点，例如监控、事务、异常处理以及为单例Bean管理并发。例如，调用EJB业务方法隐式启动一个技术事务，该事务在方法执行期间活跃，并集成数据源或外部系统。
- en: Also, stateless EJBs are pooled after usage. This means that after a stateless
    session bean's business method has been invoked, the bean instance can and will
    be reused from the container. Due to this fact, EJBs perform a little better than
    CDI beans, which are instantiated every time their scope requires it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无状态EJB在使用后会被池化。这意味着在无状态会话Bean的业务方法被调用后，Bean实例可以并且将被容器重用。由于这个原因，EJB的性能略优于每次其作用域需要时都会实例化的CDI
    Bean。
- en: Practically, the technical differences don't impact the developer's work too
    much. Besides using different annotations, both technologies can be used in the
    same look and feel. The direction of Java EE moves toward a more open choice of
    these two; for instance, since Java EE 8 it's possible to handle asynchronous
    events solely with CDI, not just EJB.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，技术差异对开发者的工作影响不大。除了使用不同的注解外，这两种技术都可以用于相同的界面和感觉。Java EE的发展方向是更开放地选择这两种技术；例如，自从Java
    EE 8以来，仅使用CDI就可以处理异步事件，而不仅仅是EJB。
- en: The integration of functionality that CDI provides is, however, one of the biggest
    features of the Java EE APIs. Just alone dependency injection, CDI producers,
    and events are effective means to tackle various situations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CDI提供的功能集成是Java EE API的最大特性之一。仅依赖注入、CDI生产者和事件就是有效应对各种情况的手段。
- en: The single most used CDI feature is dependency injection using the `@Inject`
    annotation. The injection is built in such a way that no matter which Java EE
    technology manages the beans, it *just works* for developers. You can mix and
    match CDI beans and EJBs with all scopes; the framework will take care of which
    beans are instantiated or used in which scope, respectively. This enables a flexible
    usage, such as cases when beans with a shorter scope are injected into longer
    scoped beans; for example, when a session scoped bean is injected into a singleton.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的CDI功能是使用`@Inject`注解进行依赖注入。注入是构建的，无论哪种Java EE技术管理豆，它对开发者来说“只需工作”。你可以混合和匹配CDI豆和EJBs，使用所有作用域；框架将负责在哪个作用域中实例化或使用哪些豆。这使使用更加灵活，例如，当短作用域的豆被注入到长作用域的豆中时；例如，当会话作用域的豆被注入到单例中时。
- en: This feature supports the business domain in such a way that boundaries and
    controls can just inject required dependencies without worrying about instantiating
    or managing them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能以这种方式支持业务领域，使得边界和控制可以注入所需的依赖项，而无需担心它们的实例化或管理。
- en: The following code demonstrates how a boundary implemented as stateless session
    bean injects the required controls.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何将作为无状态会话豆实现的边界注入所需的控件。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `CarManufacturer` class represents a stateless EJB. The injected `CarFactory`
    and `CarStorage` beans are realized as dependent scoped CDI beans that will be
    instantiated and injected into the EJB. The Java EE platforms simplifies dependency
    resolution by enabling to use `@Inject` to inject any project-specific beans.
    This was not always the case; In the past, the `@EJB` annotation was used to inject
    EJBs. `@Inject` simplifies the usage within Java EE.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarManufacturer`类代表一个无状态的EJB。注入的`CarFactory`和`CarStorage`豆被实现为依赖作用域的CDI豆，它们将被实例化并注入到EJB中。Java
    EE平台通过启用使用`@Inject`注解注入任何特定项目豆来简化依赖项解析。这并非总是如此；在过去，使用`@EJB`注解注入EJB。`@Inject`简化了Java
    EE中的使用。'
- en: Attentive readers may have noticed the field-based injection with package-private
    Java scopes. Field-based injection has the least impact on the contents of a class - since
    a custom constructor can be avoided. Package-private visibility enables developers
    to set and inject dependencies in a test scope. We will cover this topic and potential
    alternatives in Chapter 7, *Testing*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者可能已经注意到了基于字段注入与包私有Java作用域。基于字段的注入对类的内容影响最小——因为可以避免自定义构造函数。包私有可见性允许开发者设置和注入测试作用域中的依赖项。我们将在第7章*测试*中介绍这个主题和潜在的替代方案。
- en: CDI producers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI生产者
- en: CDI producers are another Java EE feature that is especially helpful to realize
    factories of all kinds of sorts. The producers, mostly realized as producer methods,
    provide the object that can be injected in other managed beans. This decouples
    creation and configuration logic from the usage. Producers are helpful when custom
    types other than managed bean types need to be injected.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CDI生产者是Java EE的另一个特别有用的功能，可以帮助实现各种类型的工厂。生产者主要实现为生产者方法，提供可以注入到其他管理豆中的对象。这解耦了创建和配置逻辑与使用。当需要注入除管理豆类型之外的定制类型时，生产者非常有用。
- en: 'The following shows the definition of a CDI producer method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了CDI生产者方法的定义：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The exposed `CarFactory` type can simply be injected using `@Inject`, as seen
    previously in the `CarManufacturer` example. CDI invokes the `exposeCarFactory()`
    method once a `CarFactory` instance is required and inserts the returned object
    into the injection point.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的`CarManufacturer`示例中所示，`CarFactory`类型可以通过`@Inject`简单地注入。CDI在需要`CarFactory`实例时调用`exposeCarFactory()`方法，并将返回的对象插入到注入点。
- en: These techniques already cover most of the requirements for the core domain
    logic use cases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术已经涵盖了核心领域逻辑用例的大部分需求。
- en: Emitting domain events
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射领域事件
- en: CDI provides an eventing feature for cases where business functionality needs
    to be decoupled even more. Beans can fire event objects, which act as payloads
    and which are handled in event observers. By emitting and handling CDI events,
    we decouple the main business logic from side aspects of handling the event. This
    idea particularly matches use cases, where the business domain already comprises
    the concept of events. By default, CDI events are handled in a synchronous way;
    interrupting the execution at the point where they are fired. CDI events can also
    be handled asynchronously or at specific points in the life cycle of the technical
    transaction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CDI为那些需要进一步解耦业务功能的情况提供了一个事件功能。Bean可以触发事件对象，这些对象作为有效载荷，并在事件观察者中处理。通过发射和处理CDI事件，我们可以将主要业务逻辑从处理事件的侧面方面解耦。这个想法特别适合那些业务领域已经包含事件概念的使用案例。默认情况下，CDI事件以同步方式处理；在它们被触发的地方中断执行。CDI事件也可以异步处理或在技术事务的生命周期中的特定点处理。
- en: 'The following code demonstrates how to define and fire CDI events as part of
    a business use case:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何在业务用例中定义和触发CDI事件：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `CarCreated` event is immutable and contains information that is relevant
    to the domain event, such as the car specification. The event is handled in the
    `CreatedCarListener` class, which resides in the control package:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarCreated`事件是不可变的，并包含与领域事件相关的信息，例如汽车规格。该事件在`CreatedCarListener`类中处理，该类位于控制包中：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The listener is therefore decoupled from the main business logic. The CDI container
    will take care of connecting the event handling functionality and synchronously
    calling the `onCarCreated()` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，监听器与主要业务逻辑解耦。CDI容器将负责连接事件处理功能，并同步调用`onCarCreated()`方法。
- en: The topic *Flow of execution*, shows how events can be fired and handled asynchronously
    or alternatively at specific points in the life cycle of the transaction.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 主题“执行流程”，展示了事件如何在事务的生命周期中的特定点异步触发和处理。
- en: CDI events are a way how to decouple the definition of domain events from handling
    them. The event handler logic can be changed or enhanced without touching the
    car manufacturer component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CDI事件是将领域事件定义与处理它们解耦的一种方式。事件处理逻辑可以更改或增强，而无需触及汽车制造商组件。
- en: Scopes
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: Bean scopes are quite important for the cases when state is kept in the application
    for longer than the duration of a single request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序中保持的状态持续时间超过单个请求的持续时间时，Bean作用域对于这种情况非常重要。
- en: If the whole business process can be implemented in a stateless way, by just
    executing some logic and discarding all state afterwards, scope definitions are
    pretty straightforward. Stateless session beans with dependent scoped CDI beans
    already fulfill a lot of these cases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整个业务流程都可以以无状态的方式实现，只需执行一些逻辑并在之后丢弃所有状态，作用域定义就相当直接。具有依赖作用域的CDI无状态会话Bean已经满足了许多这些案例。
- en: The EJB singleton scope and the CDI application scope, respectively, are used
    quite frequently as well. Single instances of a bean type are a straightforward
    way to store or cache information that have a long lifespan. Besides all the sophisticated
    caching technology, a singleton containing simple collections or maps with managed
    concurrency is still the most simple way to design application-specific, volatile
    stores. Singletons also provide a single point of responsibility for functionality
    that for some reason needs to be accessed in a restricted way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: EJB单例作用域和CDI应用程序作用域也经常被使用。Bean类型的单例实例是存储或缓存具有长期生命周期的信息的直接方式。除了所有复杂的缓存技术之外，包含简单集合或映射的单一实例，具有管理的并发性，仍然是设计特定于应用程序的、易失性存储的最简单方式。单一实例还提供了一个单一的责任点，对于某些原因需要以受限方式访问的功能。
- en: The last scope of both EJBs and CDI beans is the session scope, which is bound
    to the client's HTTP session. Beans of this scope will be active and reused with
    all their states as long as the user's session is active. However, storing session
    data in stateful beans introduces the challenge that clients need to reconnect
    to the same application server again. This is certainly possible but prevents
    designing stateless applications which are easier to manage. If the application
    becomes unavailable, all temporary session data is lost as well. In modern enterprise
    applications, state is typically kept in the database or in caches for optimization
    purposes. Therefore, session scoped beans aren't used too much anymore.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: EJB和CDI实体的作用域最后一个是会话作用域，它与客户端的HTTP会话绑定。只要用户的会话保持活跃，这种作用域的Bean就会保持活跃并复用其所有状态。然而，在状态Bean中存储会话数据会引入一个挑战，即客户端需要再次连接到相同的应用服务器。这当然是可以实现的，但会阻止设计无状态的、易于管理的应用。如果应用变得不可用，所有临时会话数据也会丢失。在现代企业应用中，状态通常存储在数据库或缓存中以优化目的。因此，会话作用域的Bean不再被广泛使用。
- en: CDI managed beans come with more built-in scopes, namely the conversation scope
    or the default dependent scope. There are also possibilities for adding custom
    scopes for special requirements. However, experience shows that the built-in scopes
    are usually sufficient for the majority of enterprise applications. The CDI specification
    provides further information how to extend the platform and develop custom scopes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: CDI管理Bean带有更多内置的作用域，即会话作用域或默认的依赖作用域。也有可能为特殊需求添加自定义作用域。然而，经验表明，内置的作用域通常足以满足大多数企业应用的需求。CDI规范提供了有关如何扩展平台和开发自定义作用域的更多信息。
- en: As you have seen, we can already achieve a lot with these Java EE core components.
    Before looking into integration technologies, such as HTTP communication or database
    access, let's have a closer look into design patterns used in our core domain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们已可以使用这些Java EE核心组件实现很多功能。在探讨集成技术，如HTTP通信或数据库访问之前，让我们先深入了解我们核心领域中使用的设计模式。
- en: Patterns in Java EE
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE中的模式
- en: A lot has been written about design patterns. The most prominent and always
    recited example is the well-known book *Design Patterns* by the *Gang of Four*
    (GoF). It describes common situations in software design that are solved using
    specific implementation patterns.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设计模式已经有很多论述。最突出且总是被引用的例子是《设计模式》这本书，由“四人帮”（GoF）所著。它描述了在软件设计中使用特定实现模式解决的常见情况。
- en: Whereas the design and motivation for specific patterns are still valid today,
    the actual implementation may have changed, especially in the enterprise area.
    Besides the well-known design patterns which are applicable for all kind of applications,
    there are also a lot of enterprise-related patterns that have emerged. In particular,
    a variety of J2EE-related enterprise patterns came up in the past. Since we are
    in the age of Java EE 8, not J2EE anymore, there are now easier ways to implement
    various patterns which tackle specific situations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管特定模式的设计和动机至今仍然有效，但实际的实现可能已经改变，尤其是在企业领域。除了适用于所有类型应用的知名设计模式外，还有很多与企业相关的模式出现。特别是，过去出现了许多与J2EE相关的企业模式。由于我们现在处于Java
    EE 8时代，不再是J2EE，现在有更简单的方法来实现各种模式，以应对特定情况。
- en: Design patterns revisited
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视设计模式
- en: The design patterns described in the GoF book are categorized into creational,
    structural, and behavioral patterns. Each of the patterns describe a typical challenge
    in software and shows a way to tackle and solve those situations. They represent
    implementation blueprints and are not dependent on any specific technology. That
    is why the idea of each of these patterns can be realized without precisely matching
    the described implementation. In the modern world of Java SE 8 and EE 8, we have
    more language features available than was the case in the past. I want to show
    some of the Gang of Four design patterns, their motivations, and how they can
    be realized in Java EE.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GoF书中描述的设计模式被分为创建型、结构型和行为型。每个模式都描述了软件中的典型挑战，并展示了如何应对和解决这些情况。它们代表实现蓝图，不依赖于任何特定技术。这就是为什么这些模式的想法可以在不精确匹配描述的实现的情况下实现。在Java
    SE 8和EE 8的现代世界中，我们比过去有更多的语言特性可用。我想展示一些四人帮的设计模式、它们的动机以及如何在Java EE中实现它们。
- en: Singleton
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: The singleton pattern is a well-known pattern or, as some would argue, anti-pattern.
    Singletons have only one single instance per class within the whole application.
    The motivation for this pattern is the capability of storing states as well as
    being able to coordinate actions at a central place. Singletons definitely have
    their right to exist. If a certain state needs to be shared reliably among several
    consumers, a single point of entry is definitely the simplest solution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是一个众所周知的设计模式，或者有些人可能会认为它是一个反模式。单例在整个应用程序中每个类只有一个实例。这种模式的动机是能够在中央位置存储状态以及能够协调动作。单例确实有存在的理由。如果某些状态需要在多个消费者之间可靠地共享，那么一个单一的入口点无疑是简单的方法。
- en: However, there are some points to be aware of. Having a single point of responsibility
    also introduces concurrency that needs to be managed. Therefore, singletons need
    to be thread-safe. That said, we should keep in mind that singletons naturally
    don't scale, since there's only one instance. The more synchronization we introduce
    due to the contained data structure, the less our class will scale for concurrent
    access. However, depending on the use case, this might or might not be a issue.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些需要注意的点。拥有单一责任点也引入了需要管理的并发。因此，单例需要是线程安全的。话虽如此，我们应该记住，单例本身并不易于扩展，因为只有一个实例。由于包含的数据结构，我们引入的同步越多，我们的类在并发访问方面的扩展性就越差。然而，根据具体的使用情况，这可能是也可能不是问题。
- en: The GoF book describes a static singleton instance that is managed in the singleton
    class. In Java EE the concept of singletons is directly built into EJBs with singleton
    session beans and CDIs with the application scope. These definitions will create
    one managed bean that is used in all clients.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GoF（设计模式：可复用面向对象软件的基础）书中描述了一个静态单例实例，该实例由单例类管理。在Java EE中，单例的概念直接集成到EJBs（企业JavaBeans）中的单例会话Bean和CDIs（上下文依赖注入）的应用程序作用域中。这些定义将创建一个用于所有客户端的单例管理Bean。
- en: 'The following demonstrates an example of a singleton EJB:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单例EJB的示例：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is some difference in whether we implement singletons using EJB singleton
    sessions beans or CDI application scoped beans.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用EJB单例会话Bean或CDI应用程序作用域Bean实现单例方面存在一些差异。
- en: 'By default, the container manages the concurrency of EJB singletons. This ensures
    that only one public business method is executed at a time. The behavior can be
    changed by providing the `@Lock` annotation which declares methods either as write-lock
    or read-lock, respectively, where the beans acts as a read-write lock. All EJB
    singleton business methods are implicitly write-locked. The following shows an
    example of using an EJB with container managed concurrency and lock annotations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器管理EJB单例的并发。这确保了同一时间只执行一个公共业务方法。可以通过提供`@Lock`注解来改变这种行为，该注解分别声明方法为写锁或读锁，其中Bean充当读写锁。所有EJB单例业务方法都是隐式写锁定的。以下是一个使用具有容器管理并发和锁注解的EJB的示例：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The concurrency can also switched off using bean managed concurrency. Then
    the bean will be called concurrently and the implementation itself has to ensure
    thread-safety. Using a thread-safe data structure, for example, doesn''t require
    the EJB singleton to manage concurrent accesses. The business methods of the EJB
    instance will then be called in parallel, similarly to CDI application scoped
    beans:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用Bean管理并发来关闭并发。然后Bean将被并发调用，实现本身必须确保线程安全。例如，使用线程安全的数据结构不需要EJB单例管理并发访问。EJB实例的业务方法将并行调用，类似于CDI应用程序作用域Bean：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: CDI application scoped beans don't restrict concurrent access and the implementation
    always has to deal with concurrency itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CDI应用程序作用域的Bean不限制并发访问，实现本身必须处理并发问题。
- en: These solutions tackle situations where a singleton is required; for example,
    a state that needs to be shared in-memory in the whole application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案解决需要单例的情况；例如，需要在整个应用程序中共享内存中的状态。
- en: CDI application scoped beans or EJB singletons with bean managed concurrency
    and thread-safe data structures provide an application-wide, non-clustered in-memory
    cache that scale really well. If distribution is not required this is a simplest
    yet elegant solution.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CDI应用程序作用域的Bean或具有Bean管理并发和线程安全数据结构的EJB单例提供了一个应用程序范围内的、非集群的内存缓存，扩展性非常好。如果不需要分布式处理，这是一个简单而优雅的解决方案。
- en: Another widely used scenario for EJB singletons is the ability to invoke a single
    process at application startup. By declaring the `@Startup` annotation, the bean
    will be instantiated and prepared at application startup, invoking the `@PostConstruct`
    method. Startup processes can be defined for all EJBs, but using singletons we
    can realize processes that need to be set up exactly once.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: EJB单例的另一个广泛使用的场景是在应用启动时调用单个进程的能力。通过声明`@Startup`注解，该Bean将在应用启动时实例化和准备，调用`@PostConstruct`方法。可以为所有EJB定义启动过程，但使用单例我们可以实现需要恰好设置一次的过程。
- en: Abstract factory
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: The GoF abstract factory pattern aims to separate the creation of objects from
    their usage. Creating complex objects may involve knowledge about certain prerequisites,
    implementation details, or which implementation class to be used. Factories help
    us creating these objects without deep knowledge about the internals. Later in
    this chapter, we will talk about Domain-Driven Design factories, which are closely
    related to this pattern. The motivations are the same. Abstract factories aim
    toward having several implementations of an abstract type where the factory itself
    is also an abstract type. The users of the functionality develop against interfaces,
    whereas the concrete factory will produce and return the concrete instances.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: GoF抽象工厂模式旨在将对象的创建与其使用分离。创建复杂对象可能需要了解某些先决条件、实现细节或要使用的实现类。工厂帮助我们创建这些对象，而无需深入了解内部。在本章的后面，我们将讨论与该模式密切相关的问题域驱动设计工厂。动机是相同的。抽象工厂旨在拥有多个抽象类型的实现，其中工厂本身也是一个抽象类型。功能的使用者针对接口进行开发，而具体的工厂将产生并返回具体的实例。
- en: There may be an abstract `GermanCarFactory` with concrete implementations as
    `BMWFactory` and `PorscheFactory`. Both car factories may produce some implementation
    of `GermanCar`, be it a `BMWCar` or `PorscheCar`, respectively. The client that
    just wants to have some German car won't care about which actual implementation
    class the factory will use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一个抽象的`GermanCarFactory`，具体实现为`BMWFactory`和`PorscheFactory`。这两个汽车工厂可能分别产生`GermanCar`的一些实现，无论是`BMWCar`还是`PorscheCar`。只想拥有一些德国汽车的客户端不会关心工厂将使用哪个实际的实现类。
- en: In the Java EE world, we already have a powerful functionality that is in fact
    a factory framework, namely CDI. CDI provides tons of features to create and inject
    instances of certain types. Whereas the motivations and outcome are the same,
    the implementation differs in detail. In fact, there are many ways to realize
    abstract factories, depending on the use case. Let's have a look at a few of them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE世界中，我们已经有了一个强大的功能，实际上是一个工厂框架，即CDI。CDI提供了大量功能来创建和注入特定类型的实例。虽然动机和结果相同，但在细节实现上有所不同。实际上，根据用例，实现抽象工厂的方法有很多。让我们看看其中的一些。
- en: 'A managed bean can inject instances that are concrete or abstract and even
    parameterized types. If we want to have only one instance in our current bean,
    we directly inject a `GermanCar`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Bean可以注入具体或抽象的实例，甚至是参数化类型。如果我们想在当前的Bean中只有一个实例，我们直接注入一个`GermanCar`：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Having multiple implementations of the `GermanCar` type would lead to a dependency
    resolving exception at this point since the container cannot know which actual
    car to inject. To resolve this issue, we can introduce qualifiers that explicitly
    ask for a specific type. We could use the available `@Named` qualifier with defined
    string values; however, doing so won''t introduce typesafety. CDI gives us the
    possibility to specify our own typesafe qualifiers that will match our use case:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在多个`GermanCar`类型的实现，那么在这一点上将会出现依赖解析异常，因为容器不知道应该注入哪一辆实际的汽车。为了解决这个问题，我们可以引入显式请求特定类型的限定符。我们可以使用可用的`@Named`限定符和定义的字符串值；然而，这样做不会引入类型安全。CDI为我们提供了指定自己的类型安全限定符的可能性，这些限定符将匹配我们的用例：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Qualifiers are custom runtime-retention annotations, themselves annotated with
    `@Qualifier` and typically `@Documented`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化是自定义运行时保留注解，自身被`@Qualifier`注解，通常还带有`@Documented`：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The qualifiers are specified at the injection point. They qualify the injected
    type and decouple the injection from the actual type being used:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 限定符在注入点指定。它们限定注入的类型，并将注入与实际使用的类型解耦：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Obtaining an instance of `CarEnthusiast` will now create and inject a dependent-scoped
    `BMWCar`, since this type matches the injection point.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`CarEnthusiast`的实例现在将创建并注入一个依赖范围的`BMWCar`，因为这种类型与注入点匹配。
- en: 'We could now even define a sub-type of a BMW car, that will be used without
    changing the injection point. This is realized by *specializing* the `BMWCar`
    type with a different implementation. The `ElectricBMWCar` type sub-classes `BMWCar`
    and specifies the `@Specializes` annotation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在甚至可以定义一个宝马汽车的子类型，它将在不改变注入点的情况下使用。这是通过用不同的实现来*专门化*`BMWCar`类型来实现的。`ElectricBMWCar`类型是`BMWCar`的子类，并指定了`@Specializes`注解：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Specialized beans inherit the types and qualifiers of their parent type and
    will be transparently used instead of the parent type. In this example, injecting
    a `GermanCar` with `@BMW` qualifier will provide you an instance of `ElectricBMWCar`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 专用豆继承了其父类型的类型和限定符，并将透明地用于代替父类型。在这个例子中，使用`@BMW`限定符注入`GermanCar`将提供一个`ElectricBMWCar`的实例。
- en: 'However, to be closer to the design pattern described in the book, we could
    also define a car factory type used to create several cars as desired:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了更接近书中描述的设计模式，我们也可以定义一个用于创建所需数量汽车的汽车工厂类型：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This car factory is implemented with different specifics:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汽车工厂以不同的具体方式实现：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Doing so, the client would now inject and use a manufacturer directly to create
    new German cars:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，客户端现在可以直接注入并使用一个制造商来创建新的德国汽车：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Injecting types that are explicitly defined and qualified, such as our two German
    cars, provides a lot of flexibility for implementations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显式定义和指定的类型注入，例如我们的两款德国汽车，为实现提供了很大的灵活性。
- en: Factory method
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法
- en: To understand the factory method, let's look into another pattern that has similar
    motivations, but which is realized differently. Factory methods define factories
    that are implemented as methods on specific types. There is no single class responsible
    for creating certain instances; rather, the creation becomes the responsibility
    of the factory method which is defined as part of a domain class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解工厂方法，让我们看看另一个具有类似动机但实现方式不同的模式。工厂方法定义了作为特定类型上方法的工厂。没有单个类负责创建特定实例；相反，创建成为定义为一个域类部分的工厂方法的职责。
- en: 'For example, let''s consider a car that uses its recorded trips to generate
    a driver''s logbook. It perfectly makes sense to include a `createDriverLog()`
    method in the car type which returns a logbook value type, since the class itself
    can provide the logic in a self-sufficient manner. These solutions would be implemented
    purely in Java without any frameworks or annotations required:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一辆使用其记录的行程来生成驾驶员日志簿的汽车。在汽车类型中包含一个`createDriverLog()`方法，该方法返回日志簿值类型，这是完全合理的，因为该类本身可以以自给自足的方式提供逻辑。这些解决方案将纯粹在Java中实现，无需任何框架或注解：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we will see later in this chapter, Domain-Driven Design factories don't distinguish
    between abstract factories and factory methods. They are more directed toward
    the motivations of the domain. In some cases, it makes sense to encapsulate factories
    as methods together with other responsibilities of a class. In other cases, where
    creation logic is that particular, single points of responsibility in form of
    separate classes are more appropriate. Generally speaking, putting the creation
    logic into domain types is desirable since it may make use of other functionalities
    and properties of that domain class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面看到的那样，领域驱动设计工厂不区分抽象工厂和工厂方法。它们更多地针对领域的动机。在某些情况下，将工厂封装为方法，与其他类的职责一起定义是有意义的。在其他情况下，如果创建逻辑是那种特定的、以单独类形式存在的单一责任点，则更合适。一般来说，将创建逻辑放入域类型是可取的，因为它可能利用该域类的其他功能和属性。
- en: 'Let''s have a look at CDI producers. Producers are defined as methods or fields
    that are used dynamically to look up and inject instances of certain types. We
    have full flexibility of what values a field contains or a method returns, respectively.
    We can equally specify qualifiers to ensure that the producers don''t collide
    with other potentially produced types. The beans that defines the producer method
    can also contain further properties that is used in the producer:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看CDI生产者。生产者被定义为用于动态查找和注入特定类型实例的方法或字段。我们对字段包含的值或方法返回的值有完全的灵活性。我们可以同样指定限定符以确保生产者不会与其他可能产生的类型冲突。定义生产方法豆也可以包含用于生产者的进一步属性：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This matches the idea of factory methods implemented as CDI producers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这与作为CDI生产者实现的工厂方法的想法相匹配。
- en: The scope of the produced instances needs to be considered. As any other CDI
    managed bean, the producers are by default dependent scoped. The scope defines
    the life cycle of managed beans and how they are injected. It affects how often
    the producer method will be invoked. For the default scope, the method is invoked
    once per injected instance when the calling managed bean is instantiated. Every
    time the bean that injects the produced value is injected, the producer method
    will be called. If that bean has a longer lifetime, the producer method won't
    be invoked again for that duration.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑产生的实例的范围。与其他任何CDI管理Bean一样，生产者默认是依赖范围的。范围定义了管理Bean的生命周期以及它们的注入方式。它影响生产者方法将被调用的频率。对于默认范围，当调用管理Bean实例化时，方法对每个注入实例调用一次。每次注入产生值的Bean被注入时，都会调用生产者方法。如果该Bean有更长的生命周期，那么在该期间不会再次调用生产者方法。
- en: Later in this chapter, we will see more sophisticated usages of CDI producers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到CDI生产者更复杂的用法。
- en: Object pool
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池
- en: The object pool design pattern was designed for performance optimization. The
    motivation behind pools is to avoid to constantly create new instances of required
    objects and dependencies, by retaining them in a pool of objects for a longer
    period of time. A required instance is retrieved from this pool of objects and
    released after usage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池设计模式是为了性能优化而设计的。池背后的动机是避免不断创建所需对象和依赖项的新实例，通过在对象池中保留它们更长时间来实现。所需实例从这个对象池中检索出来，并在使用后释放。
- en: This concept is already built into Java EE containers in different forms. As
    mentioned earlier, stateless session beans are pooled. This is the reason why
    they perform exceptionally well. However, developers have to be aware of the fact
    that instances are being reused; instances must not retain any state after they
    have been used. The container keeps a pool of these instances.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念已经以不同形式内置到Java EE容器中。如前所述，无状态会话Bean是池化的。这也是它们表现异常出色的原因。然而，开发者必须意识到实例正在被重用；在使用后，实例不得保留任何状态。容器保留了一组这些实例。
- en: Another example is the pooling of database connections. Database connections
    are rather expensive to initiate and it makes sense to keep a few of them alive
    for later use. Depending on the persistence implementation, these connections
    are reused once a new query is requested.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是数据库连接的池化。数据库连接的初始化成本相当高，因此保留几个供以后使用是有意义的。根据持久化实现的不同，一旦请求新的查询，这些连接就会被重用。
- en: Threads are also pooled in enterprise applications. In a Java server environment,
    a client request typically results in a Java thread that handles the logic. After
    handling the request, the threads will be reused again. Thread pool configuration
    as well as having different pools is an important topic for further performance
    optimization. We will cover this topic in Chapter 9, *Monitoring, Performance,
    and Logging*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，线程也会被池化。在Java服务器环境中，客户端请求通常会导致一个Java线程来处理逻辑。处理完请求后，这些线程将被再次重用。线程池配置以及拥有不同的池是进一步性能优化的一个重要主题。我们将在第9章“监控、性能和日志”中介绍这个主题。
- en: Developers won't typically implement the object pool pattern themselves. The
    container already includes this pattern for instances, threads, and databases.
    The application developer implicitly uses these available features.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常不会自己实现对象池模式。容器已经为实例、线程和数据库包含了这种模式。应用程序开发者隐式地使用了这些可用功能。
- en: Decorator
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者
- en: Another well-known design pattern is the decorator pattern. This pattern allows
    us to add behavior to an object without affecting other objects of that class.
    Quite often this behavior is composable with several subtypes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个众所周知的设计模式是装饰者模式。这个模式允许我们向对象添加行为，而不影响该类的其他对象。这种行为通常可以与几个子类型组合。
- en: A good example is food. Everybody has their own preferences in tastes and compositions.
    Let's take coffee as an example. We can drink just plain black coffee, with milk,
    with sugar, with both milk and sugar, or even with syrup, cream, or whatever will
    be popular in the future. And that's not taking into account the different ways
    of how to brew coffee.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的例子是食物。每个人在口味和成分上都有自己的偏好。以咖啡为例。我们可以喝纯黑咖啡，加牛奶，加糖，牛奶和糖都加，甚至加糖浆、奶油，或者未来可能流行的任何东西。而且这还没有考虑到不同的冲泡咖啡的方式。
- en: The following shows a realization of the decorator pattern using plain Java.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了使用纯Java实现的装饰者模式。
- en: 'We specify the following `Coffee` type which can be decorated using the sub-type
    `CoffeeGarnish`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The default coffee garnish just delegates to its parent coffee. There may be
    several implementations of a coffee:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Besides regular black coffee, we also specify some garnishes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the coffee types, we can compose our desired coffee with its specific
    behavior:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An example for the decorator pattern in the JDK is the `InputStream` class with
    the possibility to add specific behavior for files, byte arrays, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java EE, we again make use of CDI which ships with a decorator functionality.
    Decorators add specific behavior to a bean. Invocations on an injected bean call
    the decorator instead of the actual bean; the decorator adds specific behavior
    and delegates to the bean instance. The original bean type becomes a so-called
    delegate of the decorator:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The delegate type must be an interface. The `CountingCoffeeMaker` decorates
    the existing coffee maker functionality:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The decorator functionality is activated via the `beans.xml` descriptor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After activating the decorator, injected instances of the `CoffeeMaker` type
    use the decorated functionality instead. This happens without changing the original
    implementation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Managed beans can have several decorators. If necessary, ordering can be specified
    on the decorators using the Java EE `@Priority` annotation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: This CDI functionality applies to managed beans. Depending on whether we want
    to add additional behavior to our domain model classes or the services involved,
    we will use the pattern either with plain Java, as described first, or by using
    CDI decorators.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Facade
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The facade design pattern is used to provide a clean and simple interface to
    certain functionalities. Encapsulation and abstraction layers are certainly among
    the most important principles for writing code. We introduce facades which encapsulate
    complex functionality or legacy components that are cumbersome to use, into simpler
    interfaces. A facade is therefore a prime example for abstraction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a rather complex setup in a coffee shop. There are grinders,
    coffee machines, scales, and various tools in use that all need to be configured
    accordingly:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One could certainly argue that this class already needs refactoring. However,
    legacy classes may not be changeable easily. We will introduce a barista that
    acts as a facade:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the Java EE world, the most prominent example of facades are boundaries implemented
    with EJBs. They provide the facade to the business use cases that are part of
    our business domain. Besides that, facades can be implemented using all kinds
    of managed beans. Facades delegate and orchestrate complex logic appropriately.
    Well-chosen abstractions improve the software design and are an aim to strive
    for.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proxy design pattern is probably the most obvious one that is included in
    Java EE. Injected bean references contain in almost all cases not a reference
    to the actual instance, but a proxy. Proxies are thin wrappers around instances
    that can add certain functionalities. The client doesn't even notice that it interacts
    with a proxy instead of the actual object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代理设计模式可能是 Java EE 中包含的最明显的设计模式之一。注入的 bean 引用几乎在所有情况下都不是实际实例的引用，而是一个代理。代理是围绕实例的薄包装，可以添加某些功能。客户端甚至没有意识到它与代理而不是实际对象交互。
- en: Proxies enable the cross-cutting functionality which is required in an enterprise
    environment, such as interceptors, transactions, logging, or monitoring. They
    are also required to perform dependency injection in the first place.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代理允许在企业环境中实现所需的横切功能，例如拦截器、事务、日志记录或监控。它们最初也是执行依赖注入所必需的。
- en: Application developers typically don't use the proxy pattern directly. However,
    it is recommended to understand how the proxy pattern works in general and how
    it's used in the Java EE platform in particular.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者通常不会直接使用代理模式。然而，了解代理模式的一般工作原理以及在 Java EE 平台上的具体使用方法是推荐的。
- en: Observer
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: The observer design pattern describes how an object manages and notifies observers
    in case of change in the overall state. Observers register themselves at the subject
    and will be notified later on. The notification of observers can happen in a synchronous
    or asynchronous way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式描述了在整体状态发生变化时，一个对象如何管理和通知观察者。观察者在主题上注册自己，稍后将被通知。观察者的通知可以是同步或异步的。
- en: As seen before, CDI includes an eventing functionality, which implements the
    observer pattern. Developers do not need to handle the registration and notification
    logic themselves; they just declare the loose coupling using annotation. As shown
    in the topic *Core domain components of modern Java EE,* the `Event<T>` type and
    `@Observes` annotations declare the event publishing and observation. In the topic
    *Flow of execution*, we will cover asynchronous CDI events.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CDI 包含一个事件功能，该功能实现了观察者模式。开发者不需要自己处理注册和通知逻辑；他们只需通过注解声明松耦合即可。正如在 *现代 Java
    EE 的核心领域组件* 主题中所示，`Event<T>` 类型以及 `@Observes` 注解声明了事件发布和观察。在 *执行流程* 主题中，我们将介绍异步
    CDI 事件。
- en: Strategy
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: The strategy design pattern is used to dynamically choose an implementation
    algorithm, a strategy, at runtime. The pattern is used, for example, to select
    different business algorithms depending on the circumstances.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式用于在运行时动态选择一个实现算法，即策略。该模式用于根据情况选择不同的业务算法，例如。
- en: 'We have several possibilities to make use of the strategy pattern, depending
    on the situation. We can define different implementations of an algorithm as separate
    classes. Java SE 8 includes the functionality of lambda methods and method references
    that can be used as a lightweight strategy implementation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况，我们可以有多种方式来利用策略模式。我们可以将算法的不同实现定义为单独的类。Java SE 8 包含了可以用于轻量级策略实现的 lambda 方法和方法引用功能：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The example shows that functional interfaces can be used to dynamically define
    strategies that are applied and chosen at runtime.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例表明，功能接口可以用于动态定义在运行时应用和选择的策略。
- en: 'In a Java EE environment, we can again make use of CDI dependency injection.
    To showcase that CDI supports any Java type, we will use the same example with
    a strategy that is represented by a functional interface. The greeting strategy
    is represented by the `Function` type:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 环境中，我们又可以利用 CDI 依赖注入。为了展示 CDI 支持任何 Java 类型，我们将使用一个表示功能接口的策略的相同示例。问候策略由
    `Function` 类型表示：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A CDI producer method dynamically selects the greeting strategy:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CDI 生产者方法可以动态选择问候策略：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In order to complete the example, let's introduce specific classes for the algorithm
    implementations. CDI is able to inject all instances of a certain type that can
    dynamically be selected.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成示例，让我们引入用于算法实现的特定类。CDI 能够注入所有可以动态选择的特定类型的实例。
- en: 'The `GreetingStrategy` type is selectable after daytime appropriateness:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreetingStrategy` 类型在白天适宜时是可选择的：'
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The CDI producer can inject all possible `GreetingStrategy` instances and select
    based on their specification:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 生产者可以注入所有可能的 `GreetingStrategy` 实例，并根据它们的规范进行选择：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `@Any` qualifier implicitly exists on any managed bean. Injection points
    with the `Instance` type and this qualifier inject all instances that match the
    corresponding type, here `GreetingStrategy`. The `Instance` type allows us to
    dynamically obtain and qualify instances of a certain type. It implements an iterator
    over all eligible types.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Any`限定符在任何一个托管Bean上隐式存在。具有`Instance`类型和此限定符的注入点会注入所有匹配相应类型的实例，这里是指`GreetingStrategy`。`Instance`类型允许我们动态获取和限定特定类型的实例。它实现了对所有合格类型的迭代器。'
- en: By providing custom selection logic, we chose an appropriate strategy that is
    then injected into the greeter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供自定义选择逻辑，我们选择了一个合适的策略，然后将其注入到问候者中。
- en: CDI allows several ways to specify and choose different strategies. Depending
    on the situation, dependency injection can be used to separate the selection logic
    from the usage.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: CDI提供了多种指定和选择不同策略的方法。根据具体情况，依赖注入可以用来将选择逻辑与使用逻辑分离。
- en: Further patterns
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步的模式
- en: Besides the mentioned patterns that are implemented with specific Java EE functionalities,
    there are other design patterns that still are implemented with pure Java, as
    described in the GoF book. The presented list is certainly not complete, but includes
    design patterns that are usually being used in enterprise projects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提到的使用特定Java EE功能实现的模式之外，还有一些设计模式仍然使用纯Java实现，正如GoF书中所描述的。提供的列表当然并不完整，但它包括了在企业项目中通常使用的模式。
- en: There are some design patterns that are at the core of Java EE, such as the
    proxy pattern. Another example is the mediator pattern that encapsulates communication
    between a set of objects. For example, to design loosely coupled communication,
    we would not implement this pattern ourselves rather than use API functionality
    that implements it internally, such as CDI events.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有些设计模式是Java EE的核心，例如代理模式。另一个例子是中介者模式，它封装了一组对象之间的通信。例如，为了设计松耦合的通信，我们不会自己实现这个模式，而是使用实现它的API功能，例如CDI事件。
- en: There are many other patterns that aren't used much by the Java EE API, but
    would be implemented using plain Java. Depending on the actual case, CDI could
    be used to support the creation and instantiation of objects. Examples for these
    patterns are prototype, builder, adapter, bridge, composite, flyweight, chain
    of responsibility, state, and visitor.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他模式在Java EE API中用得不多，但会使用纯Java来实现。根据实际情况，CDI可以用来支持对象的创建和实例化。这些模式的例子包括原型、构建器、适配器、桥接、组合、享元、责任链、状态和访问者。
- en: Again if we look into the Enterprise API, we will find, for example, the builder
    pattern being heavily used in the JSON-P API. I refer to the *Design Patterns*
    book by the Gang of Four, for further usage and patterns.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看企业API，我们会发现，例如，在JSON-P API中大量使用了构建器模式。我参考了《设计模式》这本书，由四人帮编写，以了解进一步的用法和模式。
- en: Domain-Driven Design
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: Now we have seen how the GoF design patterns are implemented in the age of Java
    EE. Besides that, I want to point out some patterns and concepts that are applied
    in our core domain before continuing to more purely technical concerns. The book
    *Domain-Driven Design* by Eric Evans, extensively describes these patterns and
    concepts that support constructing software models that match the actual business
    domain as accurately as possible. In particular, the importance of communicating
    with domain experts, sharing a common, *ubiquitous* domain language, deeply understanding
    the underlying domain model, and gradually refactoring it, is pointed out. Domain-Driven
    Design also introduces certain concepts in the software world, such as repositories,
    services, factories, or aggregates.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了GoF设计模式在Java EE时代的实现。除此之外，我想指出一些在我们核心领域应用的模式和概念，然后再继续探讨更纯粹的技术问题。Eric
    Evans所著的《领域驱动设计》一书详细描述了这些模式和概念，它们支持构建尽可能准确地匹配实际业务领域的软件模型。特别是，强调了与领域专家沟通、共享通用、*无处不在*的领域语言、深入理解底层领域模型以及逐步重构它的重要性。领域驱动设计还引入了软件世界中的某些概念，如仓库、服务、工厂或聚合。
- en: Now the question arises as to whether and how these concepts are realizable
    with Java Enterprise? Domain-Driven Design always aims to include important aspects
    of the application directly into the domain model rather than just *outside* as
    part of a service or transaction script. We will see how this fact plays well
    with EJBs or CDI managed beans.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，这些概念是否以及如何用 Java 企业版实现？领域驱动设计始终旨在将应用程序的重要方面直接包含到领域模型中，而不是仅仅作为服务或事务脚本的一部分“外部”。我们将看到这一事实如何与
    EJB 或 CDI 管理的豆很好地结合。
- en: Services
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: The Domain-Driven Design language defines the concept of a service. Services
    are responsible for orchestrating various business logic processes. Typically,
    they are an entry point for use cases and create or manage objects of the domain
    model. Services hold the single business process steps together.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计语言定义了服务的概念。服务负责编排各种业务逻辑过程。通常，它们是使用案例的入口点，并创建或管理领域模型的对象。服务将单一的业务流程步骤保持在一起。
- en: If you map this concept with the idea and contents of the Entity Control Boundary
    packaging, you will see that it fulfills the same purpose as boundaries or controls,
    respectively. In Java EE, these services would therefore be implemented as EJBs
    or CDI managed beans. Services that represent the entry point of a use case are
    implemented as boundaries; whereas services that orchestrate further business
    logic, access databases or external systems represent controls.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个概念与实体控制边界打包的思想和内容相对应，你会发现它满足了边界或控制相同的用途。因此，在 Java EE 中，这些服务将因此实现为 EJB
    或 CDI 管理的豆。代表用例入口点的服务实现为边界；而那些编排进一步业务逻辑、访问数据库或外部系统的服务代表控制。
- en: Entities
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: Domain-Driven Design also defines so-called entities. As the name already suggests,
    an entity represents a business domain entity in essence. These entities are identifiable
    instances of a concept deeply contained in the specific domain. Users, articles,
    and cars are examples of such entities. It is important to the domain that the
    entities can be separately identified. It makes a difference whether user *John
    Doe* or user *John Smith* invoked some use case. This aspect distinguishes entities
    from value objects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计还定义了所谓的实体。正如其名称所暗示的，实体本质上代表了业务域实体。这些实体是特定领域内某个概念的可识别实例。用户、文章和汽车都是此类实体的例子。对于领域来说，实体能够被单独识别是很重要的。用户
    *John Doe* 或用户 *John Smith* 调用某个用例时，这一点是有区别的。这一方面将实体与值对象区分开来。
- en: Entities, as well as other model objects, are implemented as plain Java classes.
    For the sole business domain to function, there is no framework support required.
    Ideally, entities already encapsulate certain business logic that is self-contained
    within the entity type. That means that we will not only model simple POJOs with
    properties plus getter and setter methods but also business relevant methods that
    operate on that entity. Integrating business logic directly at the core of the
    business entities increases cohesion, understanding, and embraces the single responsibility
    principle.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实体以及其他模型对象，都实现为普通的 Java 类。仅为了业务域的功能，不需要框架支持。理想情况下，实体已经封装了某些在实体类型内部自包含的业务逻辑。这意味着我们不仅会使用具有属性以及
    getter 和 setter 方法的简单 POJO 进行建模，还会包含对实体进行操作的业务相关方法。将业务逻辑直接集成到业务实体的核心中，增加了内聚性、理解性，并遵循单一职责原则。
- en: Typically, entities as well as other domain model types, are persisted in a
    database. Java EE does support object-relational mapping with JPA which is used
    to persist and retrieve objects and object hierarchies. In fact, the JPA annotation
    used to declare entity types is called `@Entity`. In a later sub-chapter, we will
    see in detail how JPA supports to persist domain model types with minimal disruption
    on the model classes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，实体以及其他领域模型类型都会保存在数据库中。Java EE 支持使用 JPA 进行对象关系映射，用于持久化和检索对象及其对象层次结构。实际上，用于声明实体类型的
    JPA 注解被称为 `@Entity`。在后续的子章节中，我们将详细看到 JPA 如何以最小的对模型类的影响来支持持久化领域模型类型。
- en: Value objects
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象
- en: Types of the business domain that do not form identifiable entities but only
    specific *values* are called value objects. Value objects are preferably immutable
    and therefore reusable, since the content can't change. Java enumerations are
    a good example of this. Any objects where identity doesn't matter will be realized
    as value objects. For example, for Java enumerations it doesn't matter which instance
    of `Status.ACCEPTED` is returned, here there is even only one enum instance which
    is used in all places. The same is true for a lot of types in the domain, such
    as addresses. As long as the value of the address pointing to *42 Wallaby Way,
    Sydney* remains the same, it doesn't matter which address instance we refer to.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不形成可识别实体但只包含特定 *值* 的业务域类型被称为值对象。值对象最好是不可变的，因此是可重用的，因为其内容不能改变。Java 枚举是这种类型的良好例子。任何身份不重要的对象都将实现为值对象。例如，对于
    Java 枚举，返回 `Status.ACCEPTED` 的哪个实例并不重要，这里甚至只有一个枚举实例被用于所有地方。对于领域中的许多类型也是如此，例如地址。只要指向
    *42 Wallaby Way, Sydney* 的地址值保持不变，我们引用哪个地址实例就无关紧要了。
- en: Depending on whether the set of values is finite, value objects are either modeled
    as enumerations or POJOs, ideally immutable. Immutability represents the concept
    of value objects and reduces the probability of potential errors. Changing a mutable
    object that is shared by multiple locations can lead to unplanned side effects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 根据值集是否有限，值对象要么被建模为枚举或 POJO，理想情况下是不可变的。不可变性代表了值对象的概念，并减少了潜在错误的可能性。改变多个位置共享的可变对象可能会导致不可预见的副作用。
- en: As value objects are not identified directly they also won't be persisted and
    managed directly in a database. They certainly can be persisted indirectly, as
    part of a graph of objects, referenced from an entity or aggregate. JPA supports
    managing persistence of objects that are not entities or aggregates.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值对象不是直接标识的，因此它们也不会直接在数据库中持久化和管理。它们当然可以作为对象图的一部分间接持久化，从实体或聚合中引用。JPA 支持管理非实体或聚合的对象的持久化。
- en: Aggregates
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: Aggregates represent a concept in the Domain-Driven Design language, which is
    sometimes confusing to developers. Aggregates are complex models that consist
    of several entities or value objects, respectively, which form a whole. For consistency
    reasons, this conglomerate of objects should be accessed and managed as a whole
    as well. Accessing methods of some contained objects directly could lead to inconsistencies
    and potential errors. The idea behind aggregates it to represent a root objects
    for all operations. A good example is a car consisting of four wheels, an engine,
    a chassis, and so on. Whenever some operation, such as *drive* is required, it
    will be invoked on the whole car, potentially involving several objects at once.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是领域驱动设计语言中的一个概念，有时会让开发者感到困惑。聚合是由几个实体或值对象组成的复杂模型，形成一个整体。出于一致性的原因，这个对象集合应该作为一个整体来访问和管理。直接访问某些包含对象的访问方法可能会导致不一致和潜在的错误。聚合背后的想法是为所有操作提供一个根对象。一个很好的例子是由四个轮子、发动机、底盘等组成的汽车。每当需要进行某些操作，如
    *drive*，它将在整个汽车上调用，可能同时涉及多个对象。
- en: Aggregates are entities that also define the root of an object hierarchy. They
    are implemented as plain Java classes containing business domain functionality
    and holding reference onto entities and value objects, respectively.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是定义对象层次结构根的实体。它们作为包含业务域功能并持有实体和值对象引用的普通 Java 类来实现。
- en: Therefore, aggregates can be persisted using JPA as well. All persistence operations
    are invoked on the aggregate, the root object, and cascaded to its contained objects.
    JPA supports persistence of complex object hierarchies, as we will see in later
    sub-chapters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，也可以使用 JPA 来持久化聚合。所有持久化操作都是在聚合上触发的，即根对象，并且会级联到其包含的对象上。JPA 支持持久化复杂对象层次结构，我们将在后面的子章节中看到这一点。
- en: Repositories
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: Speaking of database access Domain-Driven Design defines repositories that will
    manage persistence and consistency of entities. The motivation behind repositories
    was to have a single point of responsibility that enables the domain model to
    be persistent with consistency in mind. Defining these functionalities should
    not clutter the domain model code with persistence implementation details. Therefore,
    Domain-Driven Design defines the concept of repositories which encapsulate these
    operations in a self-sufficient and consistent way.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 说到数据库访问，领域驱动设计定义了仓库，用于管理实体的持久性和一致性。仓库背后的动机是拥有一个单一的责任点，使得领域模型能够以一致性为前提进行持久化。定义这些功能不应使领域模型代码充斥着持久化实现细节。因此，领域驱动设计定义了仓库的概念，以自给自足和一致的方式封装这些操作。
- en: The repositories are the entry point for persistence operations for a specific
    entity type. Since only instances of aggregates and entities need to be identified,
    only these types require repositories.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库是特定实体类型持久化操作的入口点。由于只需要识别聚合和实体的实例，因此只有这些类型需要仓库。
- en: In Java EE and JPA, there is already a functionality that matches the idea of
    repositories well, JPA's `EntityManager`. The entity manager is used to persist,
    retrieve, and manage objects that are defined as entities or potential object
    hierarchies thereof. The fact that the JPA managed objects need to be identifiable
    entities perfectly fits the constraints set by the Domain-Driven Design idea of
    entities.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE和JPA中，已经存在一个与仓库概念很好地匹配的功能，即JPA的`EntityManager`。实体管理器用于持久化、检索和管理定义为实体或潜在对象层次结构的对象。JPA管理对象需要是可识别的实体的事实完美符合领域驱动设计理念中实体所设定的约束。
- en: The entity manager is injected and used in managed beans. This matches the idea
    that services, either as boundaries or controls, are meant to orchestrate the
    business use case, here by invoking the entity manager to provide the persistence
    of the entities.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实体管理器被注入并用于托管Bean中。这符合服务作为边界或控制的想法，即服务旨在编排业务用例，在此处通过调用实体管理器来提供实体的持久性。
- en: Factories
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: The motivation behind Domain-Driven Design factories is that creating domain
    objects can require logic and constraints that are more complex than just calling
    a constructor. Creation of consistent domain objects may need to perform validations
    or complex processes. Therefore, we define the creation logic in specific methods
    or classes that encapsulate this logic from the rest of the domain.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计工厂背后的动机是，创建领域对象可能需要比仅仅调用构造函数更复杂的逻辑和约束。创建一致的领域对象可能需要执行验证或复杂的过程。因此，我们将创建逻辑定义在特定的方法或类中，这些方法或类封装了这种逻辑，使其与领域其他部分隔离开。
- en: This is the same motivation behind the abstract factory and factory method design
    patterns discussed earlier. Therefore, the same realization using CDI features
    hold true here as well. The CDI specification is in fact a factory functionality.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前讨论的抽象工厂和工厂方法设计模式背后的动机相同。因此，使用CDI特性实现的相同实现也适用于此处。实际上，CDI规范就是一个工厂功能。
- en: Domain object factories can also be implemented as methods being part of another
    domain model class such as an entity. These solutions would be implemented purely
    in Java without any frameworks or annotations required. The car driver's logbook
    functionality discussed in the factory method design pattern is a good example
    for a factory method being included in a domain entity. If the domain class itself
    can provide the logic in a self-sufficient manner it perfectly makes sense to
    include the factory logic there as well.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 领域对象工厂也可以实现为另一个领域模型类（如实体）的一部分的方法。这些解决方案将完全用Java实现，不需要任何框架或注解。在工厂方法设计模式中讨论的汽车驾驶员日志簿功能是工厂方法包含在领域实体中的良好示例。如果领域类本身能够以自给自足的方式提供逻辑，那么在那里包含工厂逻辑也是完全合理的。
- en: Domain event
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域事件
- en: Domain events represent events that are relevant to the business domain. They
    usually emerge from business use cases and have specific domain semantics. Examples
    for domain events are `UserLoggedIn`, `ActiclePurchased`, or `CoffeeBrewFinished`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件代表与业务领域相关的事件。它们通常来自业务用例，并具有特定的领域语义。领域事件的例子包括`UserLoggedIn`（用户登录）、`ActiclePurchased`（文章购买）或`CoffeeBrewFinished`（咖啡煮制完成）。
- en: Domain events are typically implemented as value objects containing the required
    information. In Java, we realize events as immutable POJOs. Events happened in
    the past and can't be changed later on, so it is highly recommended to make them
    immutable. As seen before, we can use the CDI events functionality to publish
    and observe events with loose coupling. In CDI, all Java types can be used to
    be published as events. The concept of domain events is therefore a business definition
    rather than a technical one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件通常实现为包含所需信息的值对象。在Java中，我们将事件实现为不可变的POJOs。过去发生的事件不能在以后更改，因此强烈建议使它们不可变。如前所述，我们可以使用CDI事件功能以松耦合的方式发布和观察事件。在CDI中，所有Java类型都可以用作发布事件。因此，领域事件的概念是一个业务定义，而不是技术定义。
- en: Domain events are particularly important for event sourcing and event-driven
    architectures, which we will extensively discuss in Chapter 8, *Microservices
    and System Architecture*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件对于事件存储和事件驱动架构尤为重要，我们将在第8章“微服务和系统架构”中广泛讨论。
- en: External and cross-cutting concerns in enterprise applications
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业应用程序中的外部和横切关注点
- en: Now we have seen the concepts and implementations necessary to realize domain
    logic in our application. In theory it's already sufficient to implement standalone
    business logic; however, the use cases won't provide much value to the customer
    if they can't be accessed from outside of the system.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了实现应用程序中领域逻辑所需的概念和实现。从理论上讲，实现独立业务逻辑已经足够；然而，如果它们不能从系统外部访问，这些用例将不会为顾客提供太多价值。
- en: Therefore, let's have a look at technically motivated external and cross-cutting
    concerns. These are functionalities that are not at the core of the business domain,
    but that need to be fulfilled as well. Examples for technically motivated concerns
    are accessing external systems or databases, configuring the application, or caching.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来看看由技术驱动的外部和横切关注点。这些功能不是业务域的核心，但同样需要实现。技术驱动的关注点的例子包括访问外部系统或数据库、配置应用程序或缓存。
- en: Communication with external systems
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部系统的通信
- en: Communicating to the outside world is one of the most important technical aspects
    of an enterprise application. Without that communication, the application will
    hardly bring any value to the customer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与外部世界的沟通是企业应用程序最重要的技术方面之一。没有这种沟通，应用程序几乎无法为顾客带来任何价值。
- en: How to choose communication technology
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何选择通信技术
- en: When enterprise systems require communication, the question of which communication
    protocols and technologies to use arises. There are many forms of synchronous
    and asynchronous communications to choose from. There are some considerations
    to make upfront.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当企业系统需要通信时，就会产生使用哪种通信协议和技术的问题。有许多同步和异步通信形式可供选择。有一些考虑因素需要在开始时考虑。
- en: Which communication technology is supported by the chosen languages and frameworks?
    Are there any existing systems that require a certain form of communication? Do
    the systems exchange information in a synchronous or asynchronous way? What solution
    is the team of engineers familiar with? Does the system reside in an environment
    where high performance is crucial?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所选语言和框架支持哪些通信技术？是否存在需要某种形式通信的现有系统？系统是以同步还是异步方式交换信息？工程师团队熟悉哪种解决方案？系统是否位于一个高性能至关重要的环境中？
- en: Looking from a business perspective again, communication between systems is
    necessary and should not *get in the way* of implementing a business use case.
    That said, exchanging information should at first be implemented in a straightforward
    way, matching the specific domain, regardless of whether the communication is
    performed synchronously or asynchronously. These considerations have a big impact
    not only on the actual implementation, but also as to whether the whole use case
    matches the chosen solution. Therefore, this is one of the first questions to
    be asked, whether the communication happens in a synchronous or asynchronous way.
    Synchronous communication ensures consistency and ordering of the exchanged information.
    However, it also comes with less performance compared to asynchronous calls and
    will not scale infinitely. Asynchronous communication leads to looser coupling
    of the systems involved, increases the overall performance as well as overhead
    and enables scenarios where systems are not reliably available all the time. For
    reasons of simplicity enterprise applications typically use synchronous communication,
    and also in regard to consistency.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The chosen way of communication needs to be supported not only by the language
    and frameworks, but also the environments and tools being used. Does the environment
    and network setup make any constraints on the communication? In fact, this was
    one of the reasons why the SOAP protocol was widely chosen in the past; being
    able to be transmitted over network port `80`, which was permitted by the majority
    of network configurations. Tool support, especially during development and for
    debugging purposes is another important aspect. This is the reason why HTTP in
    general is widely used.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In the Java world, arguably most of the communication solutions out there are
    supported, either natively, such as HTTP, or by third-party libraries. This is
    certainly not the case with other technologies. This was, for example, one of
    the issues with the SOAP protocol. Implementation of the SOAP protocol was effectively
    only seen in Java and .NET applications. Other technologies typically chose different
    forms of communication.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Performance of the communication technology is an issue to consider, not only
    in high performance environments. Exchanging information over the network always
    introduces a huge overhead compared to both inter- or intra-process communication.
    The question is how big that overhead is. This essentially regards the density
    of information and the performance of processing messages or payloads. Is the
    information exchanged in a binary or plain text format? Which format does the
    content type represent? Generally speaking, binary formats with high information
    density and low verbosity perform better and transmit less data sizes, but are
    also harder to debug and comprehend.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect is the flexibility of the communication solution. The
    chosen technology should not constrain the exchange of information too much. Ideally,
    the protocol supports different ways of communicating; for example, both synchronous
    and asynchronous communication, binary formats, or Hypermedia. Since our application's
    main concerns is the business logic, the chosen technology can ideally adapt to
    the overall requirements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In today's systems, the communication protocol with the greatest usage is HTTP.
    There are several reasons for this. HTTP is well supported by all kinds of language
    platforms, frameworks, and libraries. The variety of tool choices is extremely
    high and the protocol is well known to most software engineers. HTTP does not
    make many constraints on how it is used and can therefore be applied to all kinds
    of information exchange. It can be used to realize both synchronous or asynchronous
    communication, Hypermedia, or straightforward invocations of remote functionality,
    such as remote procedure calls. However, HTTP does encourage certain usage. We
    will discuss semantic HTTP, remote procedure calls and REST in the next topic.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: There are communication protocols that are, not necessarily, but typically,
    built on top of HTTP. The most prominent example from the past was SOAP; a more
    recent example is gRPC. Both protocols implement a remote procedure call approach.
    Remote procedure calls represent a straightforward form of calling a function
    of another system over the wire. The function needs to be specified with input
    and output values. SOAP realized these remote procedure calls in the XML format
    whereas gRPC uses binary protocol buffers to serialize data structures.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what the business requirements are in terms of synchronous or asynchronous
    behavior of the communication, it is highly recommended to implement the behavior
    consistently. In general, you should avoid mixing synchronous or asynchronous
    behavior. Wrapping services that contain asynchronous logic in a synchronous way
    doesn't make sense. The caller will be blocked until the asynchronous process
    is completed and the whole functionality will not scale. On the contrary, it sometimes
    makes sense to use asynchronous communication in order to encapsulate long-running
    synchronous processes. This includes external systems which cannot be changed
    or legacy applications. The client component will connect to the system in a separate
    thread, allowing the calling thread to continue immediately. The client thread
    either blocks until the synchronous process has finished or makes use of polling.
    However, it is preferred to model the systems and the style of communication after
    what makes sense for the business requirements.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few protocols and formats of communications to choose from, a
    lot of them are proprietary. It is advisable for engineers to be aware of the
    different concepts and ways of communicating in general. Communication technology
    changes but the principles of exchanging data are timeless. As of writing this
    book, HTTP is the most widespread communication protocol being used. This is arguably
    one of the most important technologies to implement, it is well-understood, and
    has a great tooling support.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous HTTP communication
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of today's synchronous communication within enterprise systems is realized
    via HTTP. Enterprise applications expose HTTP endpoints that are accessed by the
    clients. These endpoints are typically in the form of web services or web frontends
    as HTML over HTTP.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Web services can be designed and specified in various ways. In the simplest
    form, we just want to call a function of another system over the wire. That function
    needs to be specified with input and output values. These functions or **remote
    procedure calls** (**RPC**) are in this case realized over HTTP, typically using
    an XML format that specifies the parameter arguments. In the age of J2EE, these
    types of web services were pretty common. The most prominent example for this
    was the SOAP protocol which is implemented with the JAX-WS standard. However,
    the SOAP protocol and its XML format was quite cumbersome to use and not well
    supported by other languages other than Java and .NET.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In today's system, the REST architectural style with its concept and constraints
    is used far more often.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Representational State Transfer
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ideas and constraints of **Representational State Transfer** (**REST**),
    as initiated by Roy T. Fielding, provide an architectural style of web services
    that in many ways suit the needs of enterprise applications better. The ideas
    lead to systems that are coupled more loosely with interfaces that are accessed
    from various clients in a uniform and straightforward way.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The REST constraint of a *uniform interface* requires the resources to be identified
    in requests using the URI in web-based systems. The resources represent our domain
    entities; for example, users or articles which are individually identified by
    URLs of the enterprise application. That said, the URLs no longer represent RPC
    methods, but actual domain entities. These representations are modified in a uniform
    way, in HTTP using the HTTP methods such as GET, POST, DELETE, PATCH, or PUT.
    The entities may be represented in different formats that are requested by the
    client, such as XML or JSON. If supported by the server, clients are free to choose
    whether they access the specific user in its XML or JSON representation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of the uniform interface constraint is to make use of Hypermedia
    as the engine of the application state. Hypermedia means linking resources that
    are related together using hyperlinks. REST resources that are transferred to
    the client can include links to other resources with semantic link relations.
    If some user includes information about their manager, that information can be
    serialized using a link to the resource of the second user, the manager.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an example for a book representation with Hypermedia links
    included in a JSON response:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In websites designed for humans, these links are one of the main aspects. In
    a Hypermedia API, these links are used by the REST clients to navigate through
    the API. The concept of discoverability decreases coupling and increases evolvability
    of the systems involved. If this concept is fully embraced, clients only need
    to know an entry point of the API and discover the available resources using semantic
    link relations, such as `related-books`. They will follow the known relations
    using the provided URLs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In most REST APIs, it's not sufficient for clients to only follow links and
    fetch resource representation using the HTTP GET method. Information is exchanged
    using HTTP methods that change state such as POST or PUT and request bodies which
    contain the payload. Hypermedia supports these so-called actions as well, using
    Hypermedia controls. Actions describe not only the target URL, but also the HTTP
    method and required information to send.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The following demonstrates a more sophisticated Hypermedia example using the
    concept of actions. This example shows the Siren content type and is meant to
    give you an idea of potential contents of Hypermedia responses:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is one example of a content type that enables Hypermedia controls. At the
    time of writing this book, none of the hypermedia-enabled content type such as
    Siren, HAL, or JSON-LD has emerged as a standard or de facto standard yet. However,
    this Siren content type should sufficiently communicate the concepts of links
    and actions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Using Hypermedia decouples the client from the server. First of all, the responsibility
    of URLs solely reside on the server side. Clients cannot make any assumption how
    the URLs are created; for example, that the book resource resides under `/books/1234`,
    which is constructed from the path `/books/` plus the book ID. We have seen many
    of these assumption that duplicate URL logic into the clients in real-world projects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The next aspect that is decoupled is how state is changed on the server. For
    example, the instruction that clients need to POST a JSON content type to `/shopping-cart`
    with a certain JSON structure is no longer baked into the client, but retrieved
    dynamically. The client will only refer to the Hypermedia action using its relation
    or name, here `add-to-cart`, and the information provided in the action. By using
    this approach, the client only needs to know the business meaning of the *add-to-cart*
    action and the origin of the required ISBN and quantity field. This is certainly
    client logic. The field values could be retrieved from the resource representation
    itself or from a client process. For example, the quantity of books could be presented
    as a drop-down field in the UI.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Another potential of using Hypermedia is to decouple business logic from the
    client. By using links and actions to direct the client to available resources,
    the information contained in the available links and actions is used to implicitly
    tell clients which use cases are possible with the current state of the system.
    For example, assuming that only books which have a certain availability can be
    added to the shopping cart. Clients that implement this behavior, that is, only
    showing an *add-to-cart* button for these situations, need to be aware of this
    logic. The client functionality then will check whether the book availability
    meets the criteria, and so on. Technically, this business logic should reside
    on the server-side only. By dynamically providing links and actions to available
    resources, the server dictates which functionality is possible under the current
    state. The *add-to-cart* action would then only be included if the book can actually
    be added to the cart. The client logic therefore is simplified to checking whether
    links and actions with known relations or names, respectively, are included. Therefore,
    the client only displays an active *add-to-cart* button if the corresponding action
    is provided in the response.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Together with the advent of Java EE, the REST architectural style gained more
    and more attention. While most web services out there don't implement all of the
    constraints that the REST architectural style defines, especially Hypermedia,
    they are mostly considered as REST services.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: For more information about REST constraints, I refer you to the dissertation
    of Roy T. Fielding's *Architectural Styles and the Design of Network-based Software
    Architectures*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Java API for RESTful web services
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java EE, the **Java API for RESTful web services** (**JAX-RS**) is used to
    both define and access REST services. JAX-RS is widely used in the Java ecosystem, even
    by other enterprise technologies. Developers especially like the declarative development
    model that makes it easy to develop REST services in a productive way.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'So-called JAX-RS resources specify REST resources which will be available under
    a certain URL. The JAX-RS resources are methods in a resource class that implement
    the business logic once the URL is accessed with a specific HTTP method. The following
    shows an example of a JAX-RS resource class for users:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `getUsers()` method is the JAX-RS resource method that will be invoked by
    the container once the HTTP call `GET .../users` is performed by a client. The
    list of users is then returned to the client in the JSON format, that is, as a
    JSON array containing JSON objects for each of the users. That is specified via
    the `@Produces` annotation that will here implicitly use the **Java API for JSON
    Binding** (**JSON-B**) to map Java types to their corresponding JSON representation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see the inversion of control principle at work. We don't have to
    wire up or register the URL ourselves, the declaration using the `@Path` annotation
    is sufficient. The same is true for mapping Java types into representations such
    as JSON. We specify in a declarative way which representation formats we want
    to provide. The rest is handled by the container. The JAX-RS implementation also
    takes care of the required HTTP communication. By returning an object, here the
    list of users, JAX-RS implicitly assumes the HTTP status code `200 OK`, which
    is returned to the client together with our JSON representation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to register JAX-RS resources to the container, the application can
    ship a sub-class of `Application` which bootstraps the JAX-RS runtime. Annotating
    this class with `@ApplicationPath` automatically registers the provided path as
    Servlet. The following shows a JAX-RS configuration class which is sufficient
    for the vast majority of use cases:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: JAX-RS, as well as the other standards in the Java EE umbrella, make use of
    the convention over configuration principle. The default behavior of this REST
    resource is plausibly sufficient for most of the use cases. If not, then the default
    behavior can always be overridden with custom logic. This is the reason why JAX-RS,
    among others, provides a productive programming model. The default cases are realizable
    very quickly with the option to enhance further.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a more comprehensive example. Assuming we want to create a new
    user in the system that is provided by a client using our REST service. Following
    HTTP semantics, that action would be a POST request to the user's resource, since
    we are creating a new resource that may not be identified yet. The difference
    between the POST and the PUT method is that the latter is omnipotent, only changing
    the accessed resource with the provided representation, whereas POST will create
    new resources in the form of new URLs. This is the case here. We are creating
    a new user that will be identifiable with a new, generated URL. If the resource
    for the new user is created, the client should be directed toward that URL. For
    creating resources, this is typically realized with the `201 Created` status code,
    which indicates that a new resource has been created successfully, and the `Location`
    header, which contains the URL where the resource will be found.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fulfill that requirement, we have to provide more information in
    our JAX-RS resource. The following demonstrates how this is accomplished in the
    `createUser()` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We make use of the `UriInfo` feature included in JAX-RS, so that we don't need
    to repeat ourselves when constructing the new URL. That feature uses the path
    information which is already present in the annotations of our resource class.
    The `Response` method is used to specify the actual HTTP response using a builder
    pattern approach. JAX-RS notices that the return type of our method is now a response
    specification and will respond to the client appropriately. By this approach,
    we have full control and flexibility as to what the response to the client looks
    like.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, these methods are the entry point to our business use cases.
    We inject the `UserStore` boundary which in our case is implemented as EJB, providing
    the logic to return the list of users and creating new users, respectively.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS provides a productive and straightforward way to expose business functionality
    with RESTful web services. Developers don't have to write any low-level HTTP *plumbing*
    if the default behavior is sufficient.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Mapping HTTP content types
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the same mindset of giving developers as much productivity as possible,
    Java EE includes standards to transparently map POJOs to JSON or XML. The example
    you saw with JAX-RS implicitly used JSON-B to map our `User` types to JSON objects
    and arrays, respectively.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: This again uses the principle of convention over configuration. If nothing is
    else specified JSON-B assumes to map the POJO properties directly as JSON object
    key-value pairs. The user's *id* was present in the JSON output as well.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The same holds true for the **Java Architecture for XML Binding** (**JAXB**)
    and its XML binding, which was included in Java EE much earlier than JSON-B. Both
    standards support a declarative configuration approach using annotations that
    are placed on the mapped Java types. If we''re about to change the JSON representation
    of the type, we annotate the corresponding fields:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we want to implement more sophisticated resource mapping, such as in the
    Hypermedia book examples shown before, we can do so using the declarative mapping
    approach. For instance, to map the links into the books resource, we can use a
    map containing links and link relations:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These links are set in the JAX-RS resource appropriately:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of the list of books will look similar to the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using this approach, we can now programmatically introduce links with relations
    that are used and being followed within the client. However, using a Hypermedia
    approach pretty quickly reaches the point where a declarative mapping introduces
    too much overhead on the model. The map of links and relations already is not
    part of the business domain, but a technical necessity and should therefore be
    questioned. We could introduce transfer object types that separate the technical
    mapping from the domain model. But this would certainly introduce a lot of duplication
    and clutter our project with a number of classes that serve no value to the business.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge to be faced is the flexibility that Hypermedia requires. Even
    for simpler examples that make use of Hypermedia controls, we want to specify
    and include links and actions depending on the current state of the system. It's
    in the nature of Hypermedia to control the flow of clients and direct them to
    certain resources. For example, a client response should only include the action
    to place an order if a book is in stock or certain credit is on their account.
    This requires the response mapping to be changeable on demand. Since a declarative
    mapping can't be changed easily at runtime, we would need a more flexible approach.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java EE 7, there is the **Java API for JSON Processing** (**JSON-P**)
    standard which provides programmatic mapping of JSON structures in a builder pattern-like
    fashion. We can simply invoke the builder types `JsonObjectBuilder` or `JsonArrayBuilder`
    to create arbitrary complex structures:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The resulting JSON object looks as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Especially in situations where we need a lot of flexibility such as in Hypermedia
    this approach is quite helpful. The JSON-P standard, as well as JSON-B or JAXB,
    seamlessly integrates with JAX-RS. JAX-RS resource methods that return JSON-P
    types, such as `JsonObject`, will automatically return the JSON content type together
    with the corresponding response. No further configuration is required. Let's have
    a look how the example containing resource links is implemented using JSON-P.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The JSON-P objects are created dynamically using a builder pattern approach.
    We have full flexibility over the desired output. This approach of using JSON-P
    is also advisable if a communication needs a representation of an entity different
    to the current model. In the past, projects always introduced transfer objects
    or DTOs for this purpose. Here the JSON-P objects are in fact transfer objects.
    By using this approach, we eliminate the need for another class that also duplicates
    the majority of structures of the model entity.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: However, there is also some duplication in this example. The property names
    of the resulting JSON objects are now provided by strings. To refactor that example
    a little bit, we would introduce a single point of responsibility, such as a managed
    bean responsible for creating the JSON-P objects from the model entities.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: This bean, for example `EntityBuilder`, would be injected in this and other
    JAX-RS resource classes. Then the duplication is still existent, but encapsulated
    in that single point of responsibility and reused from multiple resource classes.
    The following code shows an example `EntityBuilder` for books and potentially
    other objects to be mapped to JSON.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the representation to some endpoint or external system differs from our model,
    we won't be able to fully avoid duplication without other downsides. By using
    this approach, we decouple the mapping logic from the model and have full flexibility.
    The mapping of the POJO properties happens in the builder pattern invocations.
    Compared to introducing separate transfer object classes and mapping them in another
    functionality, this results in less obfuscation and ultimately less code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Let's take up on the Hypermedia example using the *add-to-cart* Siren actions
    again. This example gave an idea of the potential content of Hypermedia responses.
    For responses like these, the output needs to be dynamic and flexible, depending
    on the application's state. Now we can imagine the flexibility and strength of
    a programmatic mapping approach such as JSON-P. This output is not really feasible
    using declarative POJO mapping, which would introduce a quite complex graph of
    objects. In Java EE, it is advisable to either use JSON-P in a single responsibility
    or a third-party dependency for the desired content type.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: For mapping Java objects into JSON or XML payloads, JAXB, JSON-B, and JSON-P
    offers seamless integration into other Java EE standards, such as JAX-RS. Besides
    the integration into JAX-RS that we just saw we can also integrate CDI injection;
    this interoperability holds true as for all modern Java EE standards.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON-B type adapters enable to map custom Java types that are unknown to JSON-B.
    They transform custom Java types into known and mappable types. A typical example
    is serializing references to objects as identifiers:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The type adapter specified on the `organization` field is used to represent
    the reference as the organization''s ID. To resolve that reference, we need to
    look up valid organizations. This functionality can be simply injected into the
    JSON-B type adapter:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This example already shows the benefit of having several standards that work
    well with each other. Developers can simply use and integrate the functionalities
    without spending time on configuration and *plumbing*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Validating requests
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAX-RS offers an integration of HTTP endpoints into our system. This includes
    mapping of requests and responses into Java types of our application. However,
    the client requests need to be validated in order to prevent misuse of the system.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The **Bean Validation** standard provides validation of all kind of sorts. The
    idea is to declare validation constraints, such as *this field must not be null*,
    *this integer must not be negative* or *this salary raise must align with the
    company policies*, to Java types and properties. The standard already ships the
    typically required technically motivated constraints. Custom constraints, especially
    those that are motivated by the business functionality and validation, can be
    added as well. This becomes interesting not only from a technical, but a domain
    perspective. Validation logic that is motivated by the domain can be implemented
    using this standard.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The validation is activated by annotating method parameters, return types, or
    properties with `@Valid`. Whereas validation can be applied in many points in
    the application, it is particularly important to endpoints. Annotating a JAX-RS
    resource method parameter with `@Valid` will validate the request body or parameter,
    respectively. If the validation fails, JAX-RS automatically responds to the HTTP
    request with a status code indicating a client error.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'The following demonstrates the integration of a user validation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The user type is annotated with validation constraints:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The annotations placed on the JAX-RS method tell the implementation to validate
    the request body as soon as a client request arrives. The request body must be
    available, not `null`, and valid following the configuration of the user type.
    The user's name property is constrained to not be blank; that is, it should not
    be `null` or not just containing whitespace, respectively. The user's email property
    has to comply with a valid email address format. These constraints are enforced
    when validating a user object.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Internally, a `Validator` included in Bean Validation validates the objects.
    The validator will throw `ConstraintViolationException`s if the validation fails.
    This validator functionality can also be obtained by dependency injection and
    called programmatically. JAX-RS automatically calls the validator and sends an
    appropriate response to the client if the validation fails.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: This example would fail on illegal HTTP POST invocations to the `/users/` resource,
    such as providing user representations without a name. This results in `400 Bad
    Request` status codes, the JAX-RS default behavior for failed client validations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'If the clients need more information about why a request was declined, the
    default behavior can be extended. The violation exceptions which are thrown by
    the validator can be mapped to HTTP responses with the JAX-RS exception mapper
    functionality. Exception mappers handle exceptions that are thrown from JAX-RS
    resource methods to appropriate client responses. The following demonstrates an
    example of such an `ExceptionMapper` for `ConstraintViolationExceptions`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Exception mappers are providers for the JAX-RS runtime. Providers are either
    configured programmatically in the JAX-RS base application class or, as shown
    here, in a declarative way using the `@Provider` annotation. The JAX-RS runtime
    will scan the classes for providers and apply them automatically.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The exception mapper is registered for the given exception type and sub-types.
    All the constraint violation exceptions thrown by a JAX-RS resource method here
    are mapped to a client response including a basic description of which fields
    caused the validation to fail. The violation messages are a functionality of Bean
    Validation providing human readable, global messages.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'If the built-in validation constraints are not sufficient for the validation,
    custom validation constraints can be used. This is especially required for validation
    rules that are specific to the domain. For example, usernames could need more
    sophisticated validation based on the current state of the system. In this example,
    the usernames must not be taken when creating new users. Other constraints on
    the format or allowed characters could be set as well, obviously:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `@UserNameNotTaken` annotation is a custom validation constraint defined
    by our application. Validation constraints delegate to a constraint validator,
    the actual class that performs the validation. Constraint validators have access
    to the annotated object, such as the class or field in this case. The custom functionality
    checks whether the provided object is valid. The validation method can use the
    `ConstraintValidatorContext` to control custom violations including messages and
    further information.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the custom constraint definition:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Our constraint is validated by the `UserNameNotTakenValidator` class:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As with other standards, constraint validators can use dependency injection
    to use managed beans. This is very often required for custom validation logic
    that makes calls to controls. In this example, the validator injects the `UserStore`.
    Once again, we can reuse different standards within the Java EE umbrella.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation constraints are very often motivated by the business domain.
    It can make sense to encapsulate complex, composed validation logic into such
    custom constraints. When applied, this approach also leverages the single responsibility
    principle, separating the validation logic into a single validator rather than
    spreading them in atomic constraints.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation offers more complex functionality for scenarios where different
    ways of validation are required for the same types. Therefore, the concept of
    groups is used to group certain constraints together into groups which can possibly
    be validated individually. For more information on this, I refer the reader to
    the Bean Validation specification.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: As shown previously, HTTP JSON payloads can also be mapped in JAX-RS using the
    JSON-P standard. This is also true for HTTP request bodies. The request bodies
    parameters can be provided as JSON-P types containing JSON structures that are
    read dynamically. As well as for response bodies, it makes sense to represent
    request bodies using JSON-P types if the object structure differs from the model
    types or needs more flexibility, respectively. For this scenario, validation of
    the provided objects is even more important, since the JSON-P structures can be
    arbitrary. To rely on certain JSON properties being existent on the request object,
    these objects are validated using a custom validation constraint.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Since JSON-P objects are built programmatically and there are no pre-defined
    types, programmers have no way of annotating fields in the same way as for Java
    types. Therefore, custom validation constraints are used on the request body parameters
    that are bound to a custom validator. The custom constraints define the structure
    of a valid JSON object for the specific request bodies. The following code shows
    the integration of a validated JSON-P type in a JAX-RS resource method:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The custom validation constraint `ValidUser` references the used constraint
    validator. Since the structure of the provided JSON-P objects is arbitrary, the
    validator has to check for the presence and type of properties:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The custom constraint validator is applicable on JSON-P types, as well:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After the provided JSON-P object has been validated, the defined properties
    can safely be extracted. This example showcases how the flexible, programmatic
    types are integrated and validated in JAX-RS methods. The resource class extracts
    the request body into a domain entity type and uses the boundary to invoke the
    business use case.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Mapping errors
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the last examples, JAX-RS provides the ability to map exceptions
    to custom responses. This is a helpful functionality to implement transparent
    custom error handling without impacting the production code workflow.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: A common issue when dealing with EJBs is that any thrown exception will be wrapped
    in an `EJBException` when accessed by any non-EJB context; for example, a request
    scoped JAX-RS resource. This makes exception handling quite cumbersome, as the
    `EJBException` would have to be unwrapped to inspect the cause.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'By annotating custom exception types with `@ApplicationException`, the cause
    will not be wrapped:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Calling an EJB that throws the `GreetingException` will not result in a wrapped
    `EJBException` and produce the exception type directly. The application can then
    define a JAX-RS exception mapper for the actual `GreetingException` type, similar
    to the one mapping constraint violations.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Specifying `@ApplicationException(rollback = true)` will furthermore cause the
    container to roll back an active transaction when the exception occurs.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Accessing external systems
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now seen how our business domain is accessed from the outside via HTTP.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform the business logic, the majority of enterprise applications
    need to access other external systems as well. External systems don't include
    databases that are owned by our application. Usually external systems are external
    to the application's domain. They reside in another bounded context.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: In order to access external HTTP services, we integrate a client component into
    our project, usually as a separate control. This control class encapsulates the
    functionality required to communicate with the external system. It is advisable
    to carefully construct the interface and not to mix domain concerns with communication
    implementation details. These details include potential payload mappings, the
    communication protocol, HTTP information if HTTP is being used, and any other
    aspect not relevant to the core domain.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS ships with a sophisticated client feature that accesses HTTP services
    in a productive way. It provides the same type mapping functionalities as it does
    for resource classes. The following code represents a control that accesses an
    external system to order coffee beans:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The JAX-RS client is built and configured by the client builder and uses web
    targets to access URLs. These targets can be modified using a URI builder functionality,
    similar to the one in the JAX-RS resources. Targets are used to build new invocations
    that represent the actual HTTP invocations. The invocations can be configured
    in regard to HTTP information, such as content types, headers, as well as specifics
    of mapped Java types.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the target that points to the external URL builds a new request
    for the JSON content type with a HTTP POST method. The returned JSON structure
    is expected to be mappable to a `BeanOrder` object. The client performs further
    logic to extract the necessary information.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The client instance will be closed properly on container shutdown in the `@PreDestroy`-method
    to prevent resource leaks.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Stability when consuming HTTP
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example, however, lacks some aspects in regard to resilience. Calling this
    client control without further consideration could lead to unwanted behavior.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The client request blocks until the HTTP invocation either returned successfully
    or the connection timed-out. The HTTP connection timeout configuration depends
    on the JAX-RS implementation, which is set to infinite blocking in some technologies.
    For resilient clients, this is obviously not acceptable. A connection could wait
    forever, blocking the thread and, in a worst-case scenario, could block the whole
    application if all available threads are stuck at that location, waiting for their
    individual HTTP connection to finish. To prevent this scenario, we configure the
    client to use custom connection timeouts.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The timeout values depend on the application, especially the network configuration
    to the external system. It varies what are reasonable values for HTTP timeouts.
    To get sensible timeout values, it is advisable to gather statistics about the
    latency to the external system. For systems where load and network latency vary
    a lot, for example e-commerce systems with selective high utilization during certain
    seasons, the nature of variations should be considered.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP connect timeout is the maximum time allowed until a connection has
    been established. Its value should be small. The HTTP read timeout specifies how
    long to wait to read data. Its value depends on the nature of the external service
    being consumed. Following the gathered statistics, a good starting point for configuring
    the read timeout is to calculate the mean response times plus three times the
    standard deviation. We will cover the topic of performance and service backpressure
    in Chapter 9, *Monitoring, Performance, and Logging*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows how to configure both the HTTP connect and read timeout:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Client invocations can result in potential errors. The external service could
    respond with an unexpected status code, an unexpected response, or no response
    at all.This needs to be considered when implementing client components.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: The `readResponse()` client call expects the response to be of the HTTP status
    code `SUCCESSFUL` family and the response body to be mappable into the given Java
    type from the requested content type. If something goes wrong, a `RuntimeException`
    is thrown. Runtime exceptions enable engineers to write code without obfuscating
    try-catch blocks, but also require them to be aware of the potential errors.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The client method could catch the runtime exceptions in order to prevent them
    from being thrown to the calling domain service. There is also another, leaner
    possibility using interceptors. Interceptors provide cross-cutting functionalities
    that are applied without being tightly coupled to the decorated functionality.
    For example, this client method should intentionally return `null` when the external
    system could not deliver a reasonable response.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'The following demonstrates an interceptor that intercepts method invocations
    and applies this behavior on occurred exceptions. This interceptor is integrated
    by annotating the method of the `CoffeePurchaser` control:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `purchaseBean()` method is annotated with `@Interceptors(FailureToNullInterceptor.class)`.
    This activates the cross-cutting concerns for that method.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: In regard to resilience, the client functionality could include further logic.
    If several systems are available, the client can retry failed invocations on a
    different system. Then, only as a last resort, the invocation would fail without
    a result.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: In the topic, *Cross-cutting concerns*, we will see how to implement further
    cross-cutting concerns.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Hypermedia REST services
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP web services that apply REST constraints, especially in regard to Hypermedia,
    need more sophisticated logic on the client side. Services direct clients to corresponding
    resources that need to be accessed in certain ways. Hypermedia decouples services
    and enables API features such as evolvability and discovery, but also require
    more dynamic and logic on the client side.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'The Siren content type example earlier gives an impression of how service responses
    direct REST clients to available subsequent calls. Assume the client retrieves
    the response of an order and wants to follow the `add-to-cart` action:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The client is only coupled to the knowledge of what business meaning the *add-to-cart*
    action has and how to provide the field value information for ISBN and quantity.
    This is certainly client domain logic that needs to be implemented. The information
    on how the subsequent resource, the shopping cart, is accessed, using which HTTP
    method, and what content type is now dynamic and not baked into the client.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add a book to the shopping cart, the client will first access the
    book''s resource. The *add-to-cart* use case is called subsequently, extracting
    the information of the specified Hypermedia action. The information for the required
    fields needs to be provided by the invocation. The client then accesses the second
    resource, using the information provided both by the REST service and the invocation
    by the control:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `Entity` type encapsulates information of the Hypermedia entity types. The
    `EntityMapper` is responsible for mapping the content type into domain models
    and vice versa. In this example, all the required fields for the action result
    from the properties of the resource plus the provided `quantity` parameter. To
    enable a certain dynamic, all entity properties are added into a map and are provided
    to the `performAction()` method. Depending on the action specified by the server,
    the required fields are extracted from this map. If more fields are required,
    the client logic obviously has to change.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: It certainly makes sense to encapsulate logic for accessing Hypermedia services
    as well as mapping domain models to a content types into separate delegates. Functionality
    for accessing REST services could also sensibly be replaced by a library.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: You might notice how the URI has now leaked into the public interface of the
    client class. This was not accidental, but required to identify resources over
    several use case calls. That said, the URIs move into the business domain as general
    identifier of resources. Since the logic of how URLs are created from technical
    IDs reside on the client side, the whole URL of an entity resource becomes the
    *identifier*. However, when designing client controls, engineers should take care
    of the public interface. In particular, no information about the communication
    to the external system should leak into the domain. Using Hypermedia supports
    this approach well. All the required transport information is retrieved and used
    dynamically. The navigation logic that follows Hypermedia responses resides in
    the client control.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: This example aims to give the reader an idea how a client uses Hypermedia REST
    services.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous communication and messaging
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous communication leads to looser coupling of the systems. It generally
    increases the overall responsiveness as well as overhead and enables scenarios
    where systems are not reliably available all the time. There exist many forms
    of how to design asynchronous communication, on a conceptual or technical level.
    Asynchronous communication doesn't imply that there can't be synchronous calls
    on a technical level. The business process can be built in an asynchronous way
    that models one or several synchronous invocations that are not performed or handled
    immediately. For example, an API can offer synchronous methods to create long-running
    processes that are frequently polled for updates later on.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: On a technical level, asynchronous communication is usually designed in a message-oriented
    way implemented using message queues or the publish-subscribe pattern. Applications
    only directly communicate with a message queue or a broker, respectively, and
    messages are not directly passed to a specific receiver.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the various ways to accomplish asynchronous communication.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous HTTP communication
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The request response model of HTTP communication usually involves synchronous
    communication. A client requests a resource at a server and blocks until the response
    has been transmitted. Asynchronous communication using HTTP is therefore typically
    archived on a conceptual basis. The synchronous HTTP invocations can trigger long-running
    business processes. The external system can then either notify the caller by another
    mechanism later on or offer functionality for polling for updates.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: For example, a sophisticated user management system offers methods to create
    users. Assume users need to be registered and legitimized in external systems
    as part of a longer-running, asynchronous business process. The application would
    then offer an HTTP functionality, such as `POST /users/`, which starts the process
    to create new users. However, invoking that use case does not guarantee that the
    user will be created and registered successfully. The response of that HTTP endpoint
    would only acknowledge the attempt to create a new user; for example, by the `202
    Accepted` status code. This indicates that the request has been accepted, but
    has not necessarily been processed completely. The `Location` header field could
    be used to direct to the resource where the client can poll for updates on the
    partly-finished user.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: On a technical level, HTTP does not only support synchronous invocations. In
    Sub-chapter *Server-sent events*, we will have a look at server-sent events as
    an example of a HTTP standard using asynchronous message-oriented communication.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Message-oriented communication
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message-oriented communication exchanges information in asynchronously sent
    messages, usually implemented using message queues or the publish-subscribe pattern.
    It offers the advantage of decoupling systems since applications only directly
    communicate with the message queue or the broker, respectively. The decoupling
    not only affects dependencies on systems and used technology, but also the nature
    of communication by decoupling business processes by the asynchronous messages.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Message queues are queues where messages are sent to that are consumed later
    by one consumer at a time. In enterprise systems, message queues are typically
    realized in a **message-oriented middleware** (**MOM**). We have seen these MOM
    solutions quite regularly in the past with message queue systems such as ActiveMQ,
    RabbitMQ, or WebSphere MQ.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: The publish-subscribe pattern describes consumers that subscribe to a topic
    and receive messages that are published to the topic. The subscribers register
    for the topic and receives messages that are sent by the publisher. This concept
    scales well for a bigger number of peers involved. Message-oriented middleware
    typically can be used to take advantages of both message queuing and publish-subscribe
    approaches.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: However, as well as for asynchronous communication in general, message-oriented
    solutions also have certain shortcomings. The reliable delivery of messages is
    a first aspect to be aware of is. Producers send the messages in an asynchronous,
    *fire and forget* fashion. Engineers have to be aware of the defined and supported
    semantics of message delivery, whether a message will be received *at most once*,
    *at least once,* or *exactly once*. Choosing technology that supports certain
    delivery semantics, especially *exactly once* semantics, will have an impact on
    scalability and throughput. In Chapter 8, *Microservices and System Architecture*
    we will cover that topic in detail when discussing event-driven applications.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: For Java EE applications, the **Java Message Service** (**JMS**) API can be
    used to integrate message-oriented middleware solutions. The JMS API supports
    solutions for both message queuing and publish-subscribe approaches. It only defines
    interfaces and is implemented with the actual message-oriented middleware solutions.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: However, the JMS API does not have a high developer acceptance and, at the time
    of writing, is arguably not used that much in current systems. Compared to other
    standards, the programming model is not that straightforward and productive. Another
    trend in message-oriented communication is that instead of traditional MOM solutions,
    more lightweight solutions are gaining popularity. As of today, a lot of these
    message-oriented solutions are integrated using proprietary APIs. An example of
    such a solution is Apache Kafka, which utilizes both message queuing and the publish-subscribe
    model. Chapter 8, *Microservices and System Architecture* shows the integration
    of Apache Kafka as an example of a MOM solution into Java EE applications.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent events
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Server-sent events** (**SSE**) is an example of an asynchronous, HTTP-based,
    publish-subscribe technology. It offers an easy-to-use one-way streaming communication
    protocol. Clients can register for a topic by requesting a HTTP resource that
    leaves an open connection. The server sends messages to connected clients over
    these active HTTP connections. Clients cannot directly communicate back, but can
    only open and close connections to the streaming endpoint. This lightweight solution
    fits use cases with broadcast updates, such as social media updates, stock prices,
    or news feeds.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'The server pushes UTF-8 text-based data as content type `text/event-stream`
    to clients who previously registered for the topics. The following shows the format
    of the events:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The fact that server-sent events are based on HTTP makes them easy to integrate
    in existing networks or developer tools. SSE natively support event IDs and reconnects.
    Clients that reconnect to a streaming endpoint provide the last received event
    ID to continue subscribing where they left off.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS supports server-sent events on both the server-side and client-side.
    SSE streaming endpoints are defined using JAX-RS resources as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `text/event-stream` content type is used for Server-sent events. The registered
    `SseEventSink` instructs JAX-RS to keep the client connection open for future
    events sent through the broadcaster. The SSE standard defines that the `Last-Event-ID`
    header controls where the event stream will continue. In this example, the server
    will resend the messages that have been published while clients were disconnected.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The `itemEvents()` method implements the streaming registration and immediately
    resends missing events to that client if required. After the output is registered
    the client, together will all other active clients, will receive future messages
    that are created using `Sse`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous integration into our enterprise application happens via the
    observed `DomainEvent`. Every time a CDI event of this type is fired somewhere
    in the application, active SSE clients will receive a message.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS also supports the ability to consume SSE. `SseEventSource` offers a
    functionality to open a connection to an SSE endpoint. It registers an event listener
    that is called as soon as a message arrives:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After the `SseEventSource` successfully opens the connection, the current thread
    continues. The listener, in this case, `dataConsumer#accept`, will be called as
    soon as events arrive. `SseEventSource` will handle all required handling defined
    by the SSE standard. This includes, for example, reconnecting after connection
    loss and sending a `Last-Event-ID` header.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Clients also have the possibility for more sophisticated solutions with manually
    controlling headers and reconnects. Therefore the `SseEventInput` type is requested
    with the `text/event-stream` content type from a conventional web target. For
    more information, please refer to the JAX-RS specification.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent events offer an easy-to-use one-way streaming solution over HTTP
    that integrates itself well into the Java EE technology.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-sent events compete with the more powerful **WebSocket** technology which
    supports bi-directional communication. WebSocket which has been standardized by
    the IETF is another example for message-oriented, publish-subscribe communication.
    It was intended to be used in browser-based applications, but can be used for
    any client-server exchange of messages. WebSocket usually uses the same ports
    as the HTTP endpoints, but with its own TCP-based protocol.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket is supported in Java EE as part of the **Java API for WebSocket**.
    It includes server, and client-side support.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'The programming model for server-side endpoint definitions again matches the
    overall Java EE picture. Endpoints can be defined using a programmatic or declarative,
    annotation-driven approach. The latter defines annotations that are added on endpoint
    classes, similar to the programming model of JAX-RS resources:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The annotated methods of the server endpoint class will be called on initiated
    sessions, arriving messages and closing connections, respectively. The sessions
    represent the conversation between two endpoints.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'WebSocket endpoints can define decoders and encoders, respectively, in order
    to map custom Java types to binary or plain text data and vice versa. This example
    specifies a custom type for chat messages which is mapped using custom decoders
    and encoders. Similar to JAX-RS, WebSocket ships with default serialization capabilities
    for usual serializable Java types such as strings. The following code demonstrates
    an encoder for our custom domain type:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'These types correspond to the `MessageBodyWriter` and `MessageBodyReader` types
    in the JAX-RS standard. The following shows the corresponding message decoder:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Client endpoints are defined similarly to server endpoints. The difference is
    that only WebSocket servers listen to new connection on a path.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The client functionality of the WebSocket API can not only be used in an enterprise
    environment, but also in Java SE applications. The same is true for JAX-RS on
    the client-side. Implementing a WebSocket client endpoint is left as an exercise
    to the reader.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket, as well as server-sent events, offers well-integrated, message-oriented
    technologies. What applications choose to use, of course, highly depends on the
    business requirements, existing environments, and the nature of the communication.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Connecting enterprise technology
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some external enterprise systems that need to be integrated from an application
    don't offer standard interfaces or Java APIs. Legacy systems as well as other
    systems being used within the organization may fall under this category. The **Java
    EE Connector Architecture** (**JCA**) API can integrate these so-called **Enterprise
    Information Systems** (**EIS**) into Java EE applications. Examples of EISs include
    transaction processing systems, messaging systems, or proprietary databases.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: JCA resource adapters are deployable EE components that integrate information
    systems into the application. They include contracts such as connections, transactions,
    security, or life cycle management. The information system can be integrated better
    into the application compared to other connection technologies. Resource adapters
    are packaged as **Resource Adapter Archives** (**RAR**) and can be accessed within
    the application using the functionality of the `javax.resource` package and its
    sub-packages. Some EIS vendors provide resource adapters for their systems. For
    developing and deploying resource adapters, refer to the JCA specification.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: JCA offers a variety of integration possibilities for external information systems.
    However, the standard is not widely used and has not a high acceptance by enterprise
    engineers. Developing resource adapters is quite cumbersome, the JCA API is not
    well known among developers, and companies usually choose to integrate systems
    in other ways. In fact, it should be considered whether the effort of writing
    resource adapters is preferred over integrating information systems using other
    integration technology. Other solutions include integration frameworks such as
    Apache Camel or Mule ESB.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Database systems
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of enterprise applications use database systems as their persistence.
    Databases are at the core of the enterprise system, containing the application's
    data. As of today, data is already one the most important commodities. Companies
    spend a lot of time and effort gathering, securing, and using data.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways in which a state is represented in enterprise systems;
    however, relational databases are still the most popular. The concepts and usages
    are well understood and well integrated in enterprise technology.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Integrating RDBMS systems
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Persistence API** (**JPA**) is used to integrate relational database
    systems into enterprise applications. Compared to outdated approaches of the J2EE
    era, JPA integrates well with domain models built after the concepts of Domain-Driven
    Design. Persisting entities does not introduce much overhead and does not set
    many constraints on the model. This enables constructing the domain model first,
    focusing on business aspects, and integrating the persistence layer afterwards.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Persistence is integrated into the domain as a necessary part of handling the
    business use case. Depending on the complexity of use cases, the persistence functionality
    is invoked either in dedicated controls or directly in the boundary. Domain-Driven
    Design defines the concept of repositories which, as mentioned before, matches
    the responsibilities of JPA's entity manager well. The entity manager is used
    to obtain, manage, and persist entities and to perform queries. Its interface
    was abstracted with the intention to be used in a general way.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: In the J2EE era, the **data access object** (**DAO**) pattern was used heavily.
    The motivation behind this pattern was to abstract and encapsulate functionality
    to access data. This includes the type of the accessed storage system, such as
    RDBMSs, object-oriented databases, LDAP systems, or files. Whereas the reasoning
    certainly makes sense, following the pattern in times of Java EE is not required
    for the majority of use cases.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Most enterprise applications use relational databases that support both SQL
    and JDBC. JPA already abstracts RDBMS systems so that engineers usually don't
    deal with vendor specifics. Changing the nature of the used storage system to
    something other than a RDBMS will impact the application's code anyway. Mapping
    domain entity types into storage does not require the use of transfer objects
    anymore, since JPA integrates well into domain models. Directly mapping domain
    entity types is a productive approach to integrate persistence without much overhead.
    For straightforward use cases, such as persisting and retrieving entities, a DAO
    approach is therefore not required. However, for complex database queries involved,
    it does make sense to encapsulate that functionality into separate controls. These
    repositories then contain the whole persistence for the specific entity types.
    It is advisable though to start with a straightforward approach and only refactor
    the persistence into a single point of responsibility if the complexity increases.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Boundaries or controls, respectively, obtain an entity manager to manage the
    persistence of entities. The following shows how to integrate an entity manager
    into a boundary:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `persist()` operation on creating new persons makes the person a managed
    entity. It will be added into the database once the transaction commits and can
    be obtained later using its assigned ID. The `updateAddress()` method showcases
    this. A person entity is retrieved using its ID into a managed entity. All changes
    in the entity; for example, changing its address will be synchronized into the
    database at transaction commit time.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Mapping domain models
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, entities, aggregates, and value objects are integrated
    with JPA without introducing many constraints on the model. Entities as well as
    aggregates, are represented as JPA entities:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The person type is an entity. It needs to be identifiable using an ID that will
    be the primary key in the `persons` table. Every property is mapped into the database
    in a certain way, depending on the nature of the type and relation. The person's
    name is a simple text-based column.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: The address is a value object that is not identifiable. From a domain perspective,
    it does not matter *which* address we refer to, as long as the values match. Therefore
    the address is not an entity and thus is not mapped into JPA as such. Value objects
    can be implemented via JPA embeddable types. The properties of these types will
    be mapped to additional columns in the table of the entity that refers to them.
    Since the person entity includes a specific address value, the address properties
    will be part of the persons table.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Root aggregates that consist of several entities can be realized by configuring
    the relations to be mapped in appropriate database columns and tables, respectively.
    For example, a car consists of an engine, one or more seats, a chassis, and many
    other parts. Some of them are entities that potentially can be identified and
    accessed as individual objects. The car manufacturer can identify the whole car
    or just the engine and repair or replace it accordingly. The database mapping
    can be placed on top of this existing domain model as well.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippets show the car domain entity, including JPA mapping:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The seats are included in a collection. The `HashSet` is instantiated for new
    `Car` instances; Java collections that are `null` should be avoided.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'The engine represents another entity in our domain:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The car seats represent entities as well, identifiable by their ID:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'All entities, referenced from other entities or standalone, need to be managed
    in the persistence context. If the engine of a car is replaced by a new entity,
    this needs to be persisted separately as well. The persist operations are either
    called explicitly on the individual entities or cascaded from object hierarchies.
    The cascades are specified on the entity relations. The following code shows the
    two approaches of persisting a new car engine from a service:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: After loading the car from its identifier, it is a managed entity. The engine
    still needs to be persisted. The first approach persists the engine explicitly
    in the service.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach cascades a merge operation, that also handles new entities,
    from the car aggregate:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: It is highly advisable to apply the latter approach. Aggregate roots are responsible
    to maintain an integer and consistent state of the overall state. The integrity
    is achieved more reliably when all operations are initiated and cascaded from
    the root entity.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Integrating database systems
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An entity manager manages persistent entities within a persistence context.
    It uses a single persistence unit that corresponds to a database instance. Persistence
    units include all managed entities, entity managers, and mapping configurations.
    If only one database instance is accessed then the entity manager can be obtained
    directly, as shown in the previous example. The persistence context annotation
    then refers to the sole persistence unit.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Persistence units are specified in the `persistence.xml` descriptor file, which
    resides under the `META-INF` directory. This is one of the few cases in modern
    Java EE where XML-based configuration is used. The persistence descriptor defines
    the persistence unit and optional configuration. The datasource is referenced
    only by its JNDI name in order to separate the configuration for accessing the
    database instance from the application. The actual configuration of the datasource
    is specified in the application server. If the application server contains only
    one application that uses a single database, developers can use the application
    server's default datasource. In that case, the datasource name can be omitted.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an example `persistence.xml` file showing a single
    persistence unit using the default datasource:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This example is already sufficient for a majority of enterprise applications.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'The next snippet demonstrates a `persistence.xml` file containing several persistence
    unit definitions for multiple datasources:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Injecting entity managers need to reference the desired persistence unit by
    its name. Entity managers always correspond to a single persistence context that
    uses a single persistence unit. The following `CarManagement` definition shows
    the previous example in an environment of several persistence units:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Optionally, injection of specific entity managers can be simplified by using
    CDI producer fields. By explicitly emitting entity managers using custom qualifiers,
    injection can be implemented in a typesafe way:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The emitted entity managers can be injected, now using `@Inject` and the typesafe
    qualifier:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This approach can simplify usage in environments where different entity managers
    are injected in many locations.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: There are also other possible approaches to map domain models to databases.
    Database mapping can also be defined in XML files. However, past approaches in
    J2EE, have shown that declarative configuration using annotations allows a more
    productive usage. Annotating domain models also provides a better overview.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persistence operations need to be performed in a transaction context. Managed
    entities that are modified are synchronized into the datasource at transaction
    commit time. Therefore, a transaction spans the modifying action, and typically
    the whole business use case.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: If the boundary is implemented as EJB, a transaction is active during the business
    method execution by default. This matches the typical scenarios for JPA persistence
    being involved in the application.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: The same behavior is realized with CDI managed beans that annotate their methods
    with `@Transactional`. Transactional boundaries specify a specific behavior once
    the business method is entered. By default, this behavior defines that a transaction
    is `REQUIRED`; that is, a transaction is either created or reused if the calling
    context is already executed within an active transaction.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '`REQUIRES_NEW` behavior will always start a new transaction that is executed
    individually and resumes a potential previous transaction once the method and
    the new transaction has completed. This is useful for longer-running business
    processes that handle a great amount of data that can be processed in several,
    individual transactions.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Other transaction behavior is possible as well, such as enforcing an already
    active transaction or not supporting transactions at all. This is configured by
    annotating business methods with `@Transactional`. EJBs implicitly define `REQUIRED`
    transactions.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: RDBMS systems integrate well into Java EE applications. Following convention
    over configuration, the typical use cases are implemented in a productive way.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases versus NoSQL
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past years, a lot has happened in database technology, especially with
    regard to distribution. Traditional relational databases are, however, still the
    most used choice as of today. Their most significant characteristics are the table-based
    data schemas and the transactional behavior.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '**NoSQL** (**non SQL** or **not only SQL**) database systems provide data in
    other forms than relational tables. These forms include document stores, key-value
    stores, column-oriented stores, and graph databases. Most of them compromise consistency
    in favor of availability, scalability, and network partition tolerance. The idea
    behind NoSQL not making use of full support of relational table structures, **ACID**
    transactions (**Atomicity, Consistency, Isolation, Durability**), and foreign
    keys as well as table joins, was to support horizontal scalability. This goes
    back to the well-known CAP theorem. The **CAP** theorem (**Consistency, Availability,
    Partition tolerance**) claims that it is impossible for distributed datastores
    to guarantee at most two of the three specified constraints. Since distributed
    networks do not operate reliably (partition tolerance), systems can basically
    choose whether they want to guarantee consistency or horizontal scalability. Most
    NoSQL databases choose scalability over consistency. This fact needs to be considered
    when choosing a datastore technology.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind NoSQL systems lays in the shortcomings of relational databases.
    The biggest issue is that relational databases supporting ACID don't scale well
    horizontally. Database systems are at the core of the enterprise system, usually
    accessed by multiple application servers. Data that needs to be updated consistently
    needs to be synchronized in a central place. This synchronization happens in the
    technical transaction of the business use case. Database systems that are replicated
    and should both retain consistency would need to maintain distributed transactions
    in-between themselves. However, distributed transactions do not scale and arguably
    do not reliably work in every solution.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Still, relational database systems scale well enough for the majority of enterprise
    applications. If horizontal scalability becomes an issue so that a centralized
    database is not an option anymore, one solution is to split up persistence using
    approaches such as event-driven architectures. We will cover that topic in detail
    in Chapter 8, *Microservices and System Architecture*.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases also have some shortcomings, especially with regard to transactional
    behavior. It highly depends on the business requirements of the application as
    to whether data needs to be persistent in a transactional approach. Experience
    shows that in almost all enterprise systems at least some parts of persistence
    demand reliability; that is, transactions. However, sometimes there are different
    categories of data. Whereas certain domain models are more crucial and require
    transactional handling, other data may be recalculated or regenerated; for example,
    statistics, recommendations, or cached data. For the latter type of data, NoSQL
    datastores may be a good choice.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, no NoSQL system has emerged as a standard or de facto
    standard yet. Many of them also vary widely in their concepts and usages. There
    is also no standard targeting NoSQL included in Java EE 8.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, accessing NoSQL systems is usually realized using the Java APIs provided
    by the vendors. These make use of lower level standards such as JDBC or their
    proprietary APIs.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cutting concerns
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise applications require some technically motivated cross-cutting concerns.
    Examples of these are transactions, logging, caching, resilience, monitoring,
    security, and other non-functional requirements. Even for systems that solely
    target business, use cases need some amount of *technical plumbing*.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: We just saw in the handling of transactions, an example of a non-functional
    cross-cutting concern. Java EE doesn't require much time and effort spent by engineers
    to integrate transactional behavior. The same is true for other cross-cutting
    concerns.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Java EE interceptors is a prime example for cross-cutting concerns. Following
    the concept of aspect-oriented programming, the implementation of the cross-cutting
    concern is separated from the decorated functionality. Methods of managed beans
    can be decorated to define interceptors, which interrupt the execution and perform
    the desired task. Interceptors have full control over the execution of the intercepted
    method including returned values and thrown exceptions. To match the idea of other
    APIs, interceptors are integrated in a lightweight fashion, not setting many constraints
    on the decorated functionality.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example of transparently handling errors in a HTTP client class
    showed the usage of an interceptor. Business methods also can be decorated using
    custom interceptor bindings. The following demonstrates a business motivated process
    tracking aspect realized via custom annotations:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `Tracked` annotation defines a so-called interceptor binding. The annotation
    parameter represents a non-binding value that configures the interceptor:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The interceptor is activated via the binding annotation:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: By default, interceptors bound via interceptor bindings are not enabled. An
    interceptor must either be explicitly enabled via specifying a priority via `@Priority`,
    like demonstrated in this example. Another possibility is to activate it in the
    `beans.xml` descriptor.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Interceptors can use reflection to retrieve potential annotation parameters,
    such as the process tracking category in the example. Interceptor bindings can
    be placed either on method or class level.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Interceptors decorate behavior on methods without tightly coupling them. They
    especially make sense for scenarios where the cross-cutting aspects need to be
    added to a lot of functionality.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Interceptors are similar to CDI decorators. Both concepts decorate managed beans
    with custom behavior that is encapsulated in a different place. The difference
    is that decorators are meant to be used for decorating business logic, which is
    also mostly specific to the decorated bean. Interceptors, however, are mostly
    used for technical concerns. They offer a broader usage, making it possible to
    annotate all kind of beans. Both concepts are a helpful functionality to realize
    cross-cutting aspects.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Configuring applications
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application behavior that cannot be hardcoded but needs to be defined dynamically
    is realized via configuration. It depends on the application and the nature of
    the dynamic behavior how the configuration is implemented.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: What aspects need to be configurable? Is it sufficient to define configuration
    files that are already part of the shipped artifact? Does the packaged application
    need to be configurable from the outside? Is there a requirement for changing
    behavior during runtime?
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Configuration that does not need to change after the application has been built
    can easily be implemented in the project itself, that is, in the source code.
    Assuming we require more flexibility.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Java environment, the arguably most straightforward way is to provide
    property files that contain key-value pairs of configuration values. The configured
    values need to be retrieved in order to be used in the code. It certainly is possible
    to write Java components that programmatically provide property values. In a Java
    EE environment, dependency injection will be used to retrieve such components.
    At the time of writing, no Java EE standard supports out-of-the-box configuration
    yet. However, using CDI features provide this functionality in a few lines of
    code. The following shows a possible solution, that enables to inject configuration
    values identified by keys:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In order to unambiguously inject configuration values, for example, provided
    as strings, qualifier such as `@Config` are required. This custom qualifier is
    defined in our application. The goal is to inject values identified by the provided
    key:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'A CDI producer is responsible for retrieving and providing specific configuration
    values:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The reference key in the `@Config` annotation is a non-binding attribute since
    all injected values are handled by our CDI producer method. The `InjectionPoint`
    provided by CDI contains information about the location where the dependency injection
    is specified. The producer retrieves the annotation with the actual configuration
    key and uses it to look up the configured property. The properties file `application.properties`
    is expected to reside in the classpath. This approach comprises configuration
    values that need to be available at runtime. Since the properties map is initiated
    once, the values will not change after they have been loaded. The configuration
    exposer bean is application-scoped to only load the required values into the properties
    map once.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: If a scenario requires changing the configuration at runtime, the producer method
    would have to reload the configuration file. The scope of the producer method
    defines the life cycle of the configured value, how often the method will be called.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: This example implements configuration using plain Java EE. There are some third-party
    CDI extensions available that provide similar, as well as more sophisticated,
    functionality. At the time of writing, an often used example for such a solution
    is Apache Deltaspike.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Besides the enterprise technology, an important aspect to consider, as well,
    is the environment in which the container runs; especially, as container technologies
    set certain constraint on the runtime environment. [Chapter 5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml),
    *Container and Cloud Environments with Java EE* covers the topic of modern environments
    and their impact on the Java EE runtime, including how to design dynamic configuration.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: The power of CDI producers lays in their flexibility. Any source of configuration
    can easily be attached to expose configured values.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is a technically motivated cross-cutting concern that becomes interesting
    once applications face issues in performance, such as slow external systems, expensive
    and cachable calculations, or huge amount of data. In general, caching aims to
    lower response times by storing data that is costly to retrieve in a potentially
    faster cache. A typical example is to hold responses of external systems or databases
    in memory.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Before implementing caching, a question that needs to be asked is whether a
    cache is required or even possible. Some data doesn't qualify for being cached,
    such as data that needs to be calculated on demand. If the situation and data
    is potentially eligible for caching, it depends on the situation if another solution
    other than caching is possible. Caching introduces duplication and the possibility
    of receiving outdated information and, generally speaking, for the majority of
    enterprise applications, should be avoided. For example, if database operations
    are too slow, it is advisable to consider whether other means, such as indexing,
    can help.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: It depends a lot on the situation and what caching solutions are required. In
    general, caching directly in memory in the application already solves a lot of
    scenarios.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: The most straightforward way of caching information is in a single place in
    the application. Singleton beans perfectly fit this scenario. A data structure
    that naturally fits the purpose of a cache is a Java `Map` type.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CarStorage` code snippet presented earlier, represents a singleton EJB
    with bean-managed concurrency containing a thread-safe map to store data. This
    storage is injected and used in other managed beans:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If more flexibility is required, for example pre-loading cache contents from
    a file, the bean can control the life cycle using post-construct and pre-destroy
    methods. To guarantee functionality to be executed during application startup
    time, the EJB is annotated using `@Startup`:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Interceptor can be used for adding cache in a transparent way, without needing
    to programmatically inject and use a cache. The interceptor interrupts the execution
    before a business method is being called and will return cached values instead.
    The most prominent example for this is the `CacheResult` functionality of the
    **Java Temporary Caching API** (**JCache**). JCache is a standard that is targeted
    for Java EE but, as of writing this book, not included in the umbrella specification.
    For applications that add the JCache functionality, the eligible business methods
    are annotated with `@CacheResult` and transparently being served by a specific
    cache.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: JCache, in general, provides sophisticated caching capabilities for scenarios
    where simple Java EE solutions are not sufficient. This includes distributed caching
    provided by JCache implementations. As of today, caching solutions typically being
    used are **Hazelcast**, **Infinispan**, or **Ehcache**. This is especially the
    case when several caches need to be integrated with specific concerns, such as
    cache eviction. JCache, and its implementations, provide powerful solutions.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Flow of execution
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Business processes that run in enterprise applications describe certain flows
    of process executions. For use cases that are triggered, this either includes
    a synchronous request-response approach or asynchronous handling of the triggered
    process.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Use case invocations run in a separate thread, one thread per request or invocation,
    respectively. The threads are created by the container and pooled for reuse once
    the invocation has been handled successfully. By default, the business processes
    defined in the application classes, as well as cross-cutting concerns, such as
    transactions, run sequentially.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous execution
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a typical use case triggered by a HTTP request and involving a database
    query this works as follows. The request thread handles the request that goes
    into the boundary; for example, a JAX-RS `UsersResource`, by the inversion of
    control principle, the JAX-RS resource method is called by the container. The
    resource injects and uses a `UserManagement` EJB, which is also invoked indirectly
    by the container. All operations executed by the proxies happen in synchronous
    terms. The EJB will use an entity manager to store a new `User` entity and as
    soon as the business method that initiated the currently active transaction returns,
    the container will try to commit the transaction to the database. Depending on
    the transaction result, the boundary resource method resumes and constructs the
    client response. All this happens synchronously while the client call blocks and
    waits for the response.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous execution includes the handling of synchronous CDI events. Events
    decouple firing domain events from handling them; however, the event handling
    is performed synchronously. There are several kinds of transactional observer
    methods. By specifying the transaction phase, the event will be handled at transaction
    commit time, either before completion, after completion, only after a failed transaction,
    or after a successful transaction, respectively. By default, or when no transaction
    is active, CDI events are handled immediately when they are fired. This enables
    engineers to implement sophisticated solutions; for example, involving events
    that happen only after entities have been added to the database successfully.
    Again, in all cases, this handling is executed synchronously.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous execution
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whereas the synchronous flow of execution fulfills a lot of business use cases,
    other scenarios need asynchronous behavior. The Java EE environment sets a few
    constraints to the application in regard to threading. The container manages and
    pools resources and threads. External concurrency utilities outside of the container
    are not aware of these threads. Therefore, the application's code is not supposed
    to start and manage own threads, but to use Java EE functionality to do so. There
    are several APIs that natively support asynchronicity.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous EJB methods
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A straightforward way to invoke asynchronous behavior is to annotate an EJB
    business method, or the EJB class, with `@Asynchronous`. Invocations to these
    methods immediately return, optionally with a `Future` response type. They are
    executed in a separate, container-managed thread. This usage works well for simple
    scenarios but is limited to EJBs:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Managed Executor Service
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For asynchronous execution in CDI managed beans or by using Java SE concurrency
    utilities, Java EE includes container-managed versions of `ExecutorService` and
    `ScheduledExecutorService` functionality. These are used to execute asynchronous
    tasks in container-managed threads. Instances of `ManagedExecutorService` and
    `ManagedScheduledExecutorService` are injected into the application''s code. These
    instances can be used to execute their own runnable logic; however, they shine
    when combined together with Java SE concurrency utilities such as completable
    futures. The following shows the creation of completable futures using container-managed
    threads:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The calculator bean returns a value of type *completable future of double* that
    may still be calculated while the calling context resumes. The future can be asked
    whether the calculation has finished. It can also be combined into subsequent
    executions. No matter where new threads are required in an enterprise application,
    Java EE functionality should be used to manage them.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous CDI events
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CDI events can also be handled in an asynchronous way. The same holds true
    that the container will provide a thread for executing the event handling. To
    define asynchronous event handlers, the method is annotated with `@ObservesAsync`
    and the event is fired using the `fireAsync()` method. The next code snippets
    demonstrate asynchronous CDI events:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The event handler is called in an own, container-managed thread:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: For backwards compatibility reasons, synchronous CDI events can also be handled
    in an EJB asynchronous method. Therefore, the events and handlers are defined
    in a synchronous way, but the handler method is an EJB business method annotated
    with `@Asynchronous`. Before asynchronous events were added to the CDI standard
    in Java EE 8, this was the only way to provide this feature. To avoid confusion,
    this implementation should be avoided in Java EE 8 and newer.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Scopes in asynchronicity
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the container cannot make any assumption on how long asynchronous tasks
    may run, usage of scopes is limited. Request-scoped or session-scoped beans that
    were available as the asynchronous task started are not guaranteed to be active
    during the whole execution; the request and session may have ended a long time
    ago. Threads that are running asynchronous tasks, for example, provided by a managed
    executor service or asynchronous events, can therefore not access the request-scoped
    or session-scoped bean instances that were active during the originating invocation.
    This also includes accessing references to injected instances, for example, in
    lambda methods that are part of the originating synchronous execution.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: This has to be taken into account when modeling asynchronous tasks. All invocation-specific
    information needs to be provided at task start time. An asynchronous task can,
    however, have its own instances of scoped beans.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Timed execution
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Business use cases cannot only be invoked from the outside, for example, by
    a HTTP request, but also emerge from the inside of the application, by a job that
    runs at a defined time.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Unix world, cron jobs are a well-known functionality to trigger periodic
    jobs. EJBs provide similar possibilities using EJB timers. Timers invoke business
    methods based on a recurring pattern or after a specific time. The following shows
    the definition of a scheduled timer that times out every 10 minutes:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: All EJBs, singleton, stateful, or stateless beans can define timers. However,
    in the majority of use cases it makes sense to define timers on singleton beans.
    The timeout is invoked on all active beans and it usually is desired to invoke
    the scheduled job reliably; that is, on a singleton bean. For the same reason
    this example defines the EJB to be active during application startup. This guarantees
    that the timer is executed from the beginning.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Timers can be defined as persistent, which extends their lifetime beyond the
    JVM life cycle. The container is responsible for keeping timers persistent, usually
    in a database. Persistent timers that would have been executed while an application
    is unavailable are triggered at startup. This also enables the possibility to
    share timers across multiple instances. Persistent timers together with corresponding
    server configuration are a straightforward solution for business processes that
    need to be executed exactly once across multiple servers.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: The timers that are automatically created using the `@Schedule` annotation are
    specified using Unix-like cron expressions. For more flexibility, EJB timers are
    defined programmatically using the container-provided timer service that creates
    `Timers` and `@Timeout` callback methods.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'Periodic or delayed jobs can also be defined outside EJB beans using the container-managed
    scheduled executor service. A `ManagedScheduledExecutorService` instance that
    executes tasks after a specified delay or periodically is injectable into managed
    beans. Executing these tasks will happen using container-managed threads:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Invoking `startAsyncJobs()` will cause `execute()` to run in a managed thread,
    10 seconds after the invocation and continuously, every 10 seconds, after an initial
    minute has passed.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous and reactive JAX-RS
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JAX-RS supports asynchronous behavior to not unnecessarily block request threads
    on the server-side. Even if an HTTP connection is currently waiting for a response,
    the request thread could potentially handle other requests while the long-running
    process on the server is handled. Request threads are pooled by the container
    and this pool only has a certain size. In order to not unnecessarily occupy a
    request thread, JAX-RS asynchronous resource methods submit tasks that are executed
    while the request thread returns and is free to be reused again. The HTTP connection
    is being resumed and responded after the asynchronous task has been finished or
    when a timeout occurs. The following code shows an asynchronous JAX-RS resource
    method:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: For the request thread not to be occupied for too long, the JAX-RS method needs
    to return fast. This is due to the resource method being called from the container
    using inversion of control. The completion stage's result will be used to resume
    the client connection once processing has finished.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Returning completion stages is a fairly recent approach in the JAX-RS API. If
    a timeout declaration, together with more flexibility on the asynchronous response,
    is required, the `AsyncResponse` type can be injected into the method. The following
    code snippet demonstrates this approach.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Using custom timeouts, the client request will not wait infinitely, only until
    either the result is completed or the invocation timed out. The calculation, however,
    will continue since it's executed asynchronously.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: For JAX-RS resources being implemented as EJBs, `@Asynchronous` business methods
    can be used to omit the asynchronous invocation using an executor service.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: The JAX-RS client also supports asynchronous behavior. Depending on the requirements,
    it makes sense to not block during HTTP invocations. A previous example showed
    how to set timeouts on client requests. For long running and especially parallel
    external system calls, asynchronous and *reactive* behavior provides benefits.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Imagine several backends that provide weather information. The client component
    accesses all of them and provides the average weather forecast. Accessing the
    systems ideally happens in parallel.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `invokeTargetsAsync()` method invokes the available targets asynchronously,
    using the managed executor service. The `CompletableFuture` handles are returned
    and used to calculate the average results. Calling the `join()` method will block
    until the invocation has finished and will deliver the individual results.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: By invoking the available targets asynchronously, they call and wait for the
    potentially slow resource in parallel. Waiting for the weather service resources
    then only takes as long as the slowest response, not the sum of all responses.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest version of JAX-RS natively supports completion stages, which reduces
    boilerplate code in the applications. Similar to using completable futures, the
    invocation immediately returns a completion stage instance for further usage.
    The following demonstrates reactive JAX-RS client functionality using the `rx()`
    invocation:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The preceding example doesn't require to lookup the managed executor service.
    The JAX-RS client will manage this internally.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Before the `rx()` method was introduced, the client contained an explicit `async()`
    invocation that behaves similarly, but only returns `Future`s. The reactive client
    approach usually fits the need in projects better.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: As seen before, we are using the container-managed executor service since we're
    in a Java EE environment.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and design principles of modern Java EE
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java EE API is built around conventions and design principles that are present
    throughout the whole set of standards. Software engineers will find familiar API
    patterns and approaches while developing applications. Java EE aims to maintain
    consistent API usage.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: For applications that focus on business use cases first, the most important
    principle of the technology is *not getting in the way*. As mentioned earlier,
    engineers should be able to focus on solving business problems, not spending the
    majority of their time dealing with technology or framework concerns. Ideally,
    the domain logic is implemented using plain Java and *enhanced* with annotations
    and aspects that enable enterprise environments without affecting or obfuscating
    the domain code. This implies that the technology doesn't need much engineer attention
    by enforcing overly complex constraints. In the past, J2EE required many of these
    overly-complex solutions. Managed beans as well as persistent beans needed to
    implement interfaces or extend base classes. This obfuscates the domain logic
    and complicates testability.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: In the age of Java EE, the domain logic is implemented in plain Java classes
    annotated with annotations that tell the container runtime how to apply the enterprise
    concerns. Clean code practices often suggest writing code for delectability, not
    reusability. Java EE supports this approach. If for some reason the technology
    needs to be replaced and the domain logic extracted, this is possible by simply
    removing the corresponding annotations.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in Chapter 7, *Testing* the programming approach highly supports
    testability, since for the developers, the majority of Java EE specifics are not
    more than annotations.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: A design principle that is existent throughout the whole API is **inversion
    of control** (**IoC**), in other words, *don't call us, we'll call you*. We see
    this especially in application boundaries such as JAX-RS resources. The resource
    methods are defined by annotation Java methods that are later invoked by the container
    in the correct context. The same holds true for dependency injection that needs
    to resolve producers or include cross-cutting concerns such as interceptors. Application
    developers can focus on implementing the logic and defining relationships and
    leave the actual plumbing to the container. Another, not that obvious example,
    is declaring the mapping of Java objects to JSON and back via JSON-B annotations.
    The objects are mapped implicitly in a declarative approach, not necessarily in
    an explicit, programmatic way.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Another principle that enables engineers to use the technology in a productive
    way is **convention over configuration**. By default, Java EE defines specific
    behavior that matches the majority of use cases. If that is not sufficient or
    doesn't match the requirements, behavior can be overridden, often at several levels.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: There are countless examples of convention over configuration. JAX-RS resource
    methods mapping Java functionality into HTTP responses is one such method. If
    JAX-RS's default behavior regarding responses is not adequate, the `Response`
    return type can be used. Another example is the specification of managed beans
    that is usually realized using annotations. To override this behavior, the `beans.xml`
    XML descriptor can be used. The welcoming aspect for developers is that in a modern
    Java EE world, enterprise applications are developed in a pragmatic and highly
    productive way that does not usually require at lot of XML usage like in the past.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: In terms of developer productivity, another important design principle of Java
    EE is that the platform requires the container to integrate the different standards.
    As soon as containers support a specific set of APIs, which is the case if the
    whole Java EE API is supported, it is also required that implementations of the
    APIs enable straightforward integration of other APIs. A good example is that
    JAX-RS resources are able to use JSON-B mapping and Bean Validation without explicit
    configuration other than annotations. In previous examples, we saw how functionalities
    that are defined in separate standards can be used together without additional
    effort required. This is also one of the biggest advantages of the Java EE platform.
    The umbrella specification ensures that the specific standards play well together.
    Developers can rely on certain features and implementation being provided by the
    application server.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Preserving maintainable code with high quality
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers generally agree that code quality is a goal to strive for. Yet not
    all technology supports this ambition equally well.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned from the start, the business logic should be the main focus of
    applications. If changes in the business logic or new knowledge after working
    in the domain emerge, the domain model, as well as the source code, needs to be
    refactored. Iterative refactoring is a necessity to achieve and maintain high
    quality of the modeled domain as well as the source code in general. Domain-Driven
    Design describes this effort of deepening the understanding of the business knowledge.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: A lot has been written on refactoring at the code level. After the business
    logic has initially been represented into the code and verified by tests, developers
    should spend some time and effort to rethink and improve the first attempt. This
    includes identifier names, methods, and classes. Especially, **naming**, **layers
    of abstractions** and **single points of responsibility** are important aspects.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Following the reasoning of Domain-Driven Design, the business domain should
    fit its code representations as much as possible. This includes, especially, the
    language of the domain; that is, how developers and business experts talk about
    certain features. The goal of the whole team is to find a uniform, *ubiquitous
    language* that is used and well represented not only in discussions and presentation
    slides, but also in the code. Refinement of business knowledge will happen in
    an iterative approach. As well as refactoring at the code level, this approach
    implies that an initial model won't perfectly match all the requirements from
    the beginning.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the technology being used should support changes in the model and
    code. Too many restrictions become hard to change later on.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: For application development in general, but especially for refactoring, it is
    crucial to have a sufficient coverage of automated software tests. As soon as
    the code is changed, regression tests ensure that no business functionality has
    accidentally been damaged. Sufficient test cases thus support refactoring attempts,
    giving engineers clarity as to whether functionality still works as expected after
    it has been touched. The technology should ideally support testability by not
    constraining code structures. Chapter 7, *Testing* will cover that topic in detail.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve *refactorability*, loose coupling is favored over tight
    coupling. All functionality that explicitly invokes or requires other components
    needs to be touched if either of those change. Java EE supports loose coupling
    in several aspects; for example, dependency injection, eventing, or cross-cutting
    concerns, such as interceptors. All of these simplify code changes.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: There are some tools and methods that measure the quality. Especially, static
    code analysis can gather information about complexity, coupling, relationships
    of classes and packages, and implementation in general. These means can help engineers
    to identify potential issues and provide an overall picture of the software project.
    [Chapter 6](599c6821-8971-4489-931c-9e11b5e23afd.xhtml), *Application Development
    Workflows* covers how to verify code quality in an automated way.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is advisable to refactor and improve the code quality constantly.
    Software projects are often driven to implement new functionality that generates
    revenue instead of improving existing functionality. The issue with that is that
    refactoring and improving quality is often seen to not provide any benefit from
    the business perspective. This is, of course, not true. In order to achieve a
    steady velocity and to integrate new features with satisfying quality, it is absolutely
    necessary to reconsider existing features. Ideally periodical refactor cycles
    are already built into the project schedule. Experience shows that project managers
    are often not aware of this issue. However, it is a responsibility of the software
    engineer team to address the relevance of quality.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Engineers are advised to focus on the domain and business logic first, by starting
    from the use case boundaries and stepping down the abstraction layers. Java EE
    core domain components, namely EJBs, CDI, CDI producers and events, are used to
    implement the plain business logic. Other Java EE APIs are mainly used to support
    the business logic in technical necessities. As we have seen, Java EE implements
    and encourages numerous software design patterns as well as the approaches of
    Domain-Driven Design in modern ways.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to choose and implement communication, in both synchronous
    and asynchronous ways. The communication technology depends on the business requirements.
    Especially HTTP is widely used and well-supported in Java EE via JAX-RS. REST
    is a prime example of an communication protocol architectural style that supports
    to loosely couple system.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Java EE ships with functionality that implements and enables technical cross-cutting
    concerns such as managed persistence, configuration, or caching. Especially the
    use of CDI realizes various technically-motivated use cases. Required asynchronous
    behavior can be implemented in different ways. Applications should not manage
    own threading or concurrency management, rather than use Java EE features. Container-managed
    executor services, asynchronous CDI events, or EJB timers are examples that should
    be used instead.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: The concepts and principles of the Java EE platform support developing enterprise
    applications with focusing on business logic. Especially the lean integration
    of different standards, inversion of control, convention over configuration, and
    the principle of *not getting in the way*, support this aspect. Engineers should
    aim to maintain high code quality, not only by code level refactoring, but also
    by refining the business logic and the *ubiquitous language* the teams share.
    Refining code quality as well as suitability of the domain model happens in iterative
    steps.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, technology should support changes in model and code and not putting
    too many restrictions onto solutions. Java EE supports this by minimizing the
    framework impact on the business code and by enabling to loosely couple functionality.
    Teams should be aware of refactoring together with automated testing being a necessity
    of high quality software.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: The following chapter will cover what other aspects make the Java EE a modern
    and suitable platform for developing enterprise applications. We will see what
    deployment approaches are advisable and how to lay the foundation for productive
    development workflows.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
