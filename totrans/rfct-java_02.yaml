- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good Coding Habits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a book about refactoring, I believe it’s necessary to talk about well-written
    code. These are two obviously closely related aspects that almost overlap. The
    lack of good code or solid architecture is among the main reasons for refactoring;
    refactoring is the means through which we aim to improve the writing of a method,
    a class, a project, or an architecture.
  prefs: []
  type: TYPE_NORMAL
- en: To understand clearly what we’re talking about, it’s important to try to explain
    what good code is and, by exclusion, what is considered poorly written code. It
    may seem excessive to try to define what good code is because, in reality, it
    should be – or should be treated as – something quite intuitive. We should almost
    have *spider senses* that tingle when we see code that is hard to understand or
    overly complicated. If you don’t have spider senses developed yet, don’t worry!
    They will grow with experience (and this book could help you get there).
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, good code is often synonymous with *Clean Code*, that is, a collection
    of informal rules gathered in the book of the same name by Robert C. Martin (we’re
    going to speak about Clean Code a lot). In this chapter, we’ll try to summarize
    in broad terms what Clean Code means, what its fundamental principles are, and
    why we should all strive for Clean Code every day of our professional lives.
  prefs: []
  type: TYPE_NORMAL
- en: Clean Code is often accompanied by and closely related to the so-called SOLID
    principles, for which the computer science community has shown great inventiveness
    regarding acronyms. But they also provide *solid* (do software developers love
    dad jokes?) foundations for writing excellent code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is good code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write SOLID code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side effects and mutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Causes of bad code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small disclaimer
  prefs: []
  type: TYPE_NORMAL
- en: I don’t claim to present the ultimate truth about anything. I know that some
    of what I’ll write is the subject of debate, and there are plenty of programmers
    out there ready to question everything (and I say that as a good thing). The intention
    is to share what I believe are healthy habits to practice every day, to avoid
    getting stuck and, most importantly, to find joy in our beautiful craft as artisans.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of good code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, I must disappoint you. I struggle to find a clear, precise, and
    universally agreed-upon definition of what good code is. It is a highly subjective
    concept that heavily depends on the context. Online and in textbooks, you can
    find numerous definitions that differ slightly from each other. However, I strongly
    believe that there are some foundations on which we can all agree. I will try
    to summarize the various interpretations of good code and provide some feedback
    based on my experience, for what it’s worth.
  prefs: []
  type: TYPE_NORMAL
- en: Good code is readable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Obviously, this is the first thing. Pretty intuitive, right? Well, yes, but
    it’s one of the aspects that I’ve often found to be underestimated. Sometimes
    we are so focused on achieving the end result, on delivering a product at all
    costs, that we forget about what comes after; we forget that – as already mentioned
    – code must not only speak to machines but also and above all to other programmers.
    And those other programmers are also our future selves! Doing things quickly is
    not the only reason for which code lacks readability: for instance, sometimes
    we could have performance issues to handle. Anyways, if you have other aspects
    to handle, my small piece of advice is to make sure to at least strike a balance
    between readability and those aspects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a definition of readable code, we don’t need to rely on the code itself.
    Plain language is enough. Just imagine for a moment that you’re at your own home
    and you need to assemble one of those beautiful, satisfying, low-budget Swedish
    furniture pieces that we have to assemble ourselves, like a wardrobe. Instead
    of the crystal-clear visual instructions that we are familiar with, we find a
    text that says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Take the white wooden piece with dimensions A x B, which we will now refer
    to as L. Take another wooden board with dimensions B x C, which we’ll call M.
    Take the tool consisting of a metal rod with a cross-shaped end. Take a screw
    that fits into the holes of both L and M; it must be not too short and not too
    long. Using the cross-shaped end of the aforementioned tool, rotate the screw
    clockwise so that they inextricably join, forming a single partial structure that
    we’ll* *call P.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This text is obviously incomprehensible. I suffered a lot in writing it. Don’t
    fall into the trap of thinking that code is different from prose language. I mean,
    of course, it’s different, but in an abstract way, you should consider them as
    the same thing. Imagine, when you write code, writing in prose. You should aim
    for prose writing, in a way, so that your code is as readable as possible. When
    a piece of code is readable even by someone who knows nothing about the project
    or has basic programming skills, then you have succeeded. The excerpt from the
    previous instruction manual could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Take the wooden board labeled “left side” and screw it together with the one
    labeled “back” using a* *Phillips screwdriver.*'
  prefs: []
  type: TYPE_NORMAL
- en: This excerpt can certainly be further improved. But the starting point is definitely
    understandable; it’s understandable to me and it’s understandable to others, and
    that’s how your code should be. Readable code is code that can be improved and
    expanded upon.
  prefs: []
  type: TYPE_NORMAL
- en: Good code is reliable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If I have to think of a definition for “reliable,” it brings to mind a friend
    of mine who, when they say they will do something, they do it and only that. Nothing
    more, nothing less. So, think of reliable code as your friend who always agrees
    to help you in the best possible way—no surprises, as Radiohead used to sing.
    I could give you an example of unreliable code not so far from certain things
    I have encountered in the past. For instance, imagine you have an entity in your
    domain represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Example entity](img/B20912_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – Example entity
  prefs: []
  type: TYPE_NORMAL
- en: Both `id` and `taxCode` are of type String and are unique within the domain.
    That means there cannot be two students with the same `id` or the same `taxCode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also have an exposed method from the `Student` interface that is written
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, this signature of this method is correct, because it does not expose
    the internal structure of the object. But, it could also have been named `getId()`
    or `getTaxCode()` and that is *exactly* the point. Without looking at the implementation,
    we don’t know if we will get `taxCode` or `id` when using it. When we actually
    use `getUniqueIdentifier()`, we realize that the behavior is variable and depends
    on the specific implementation. If we were to use this method within a payment
    and invoicing system where we specifically need `taxCode`, this method would be
    unreliable. One possible solution could be to expose two separate getter methods
    so that we know exactly which information we are reading at that moment. Alternatively,
    another solution could be to expose an additional method called `getTaxIdentifier()`
    that specifically returns `taxCode`. This way, you would have separate methods
    providing clear and unambiguous access to each piece of information without exposing
    the internal structure.
  prefs: []
  type: TYPE_NORMAL
- en: Good code is hard to misuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To easily explain the concept of code that cannot be misused, all I have to
    do is take a look inside my children’s room. There are toys, sometimes referred
    to as “Montessori toys,” that involve small wooden objects being inserted into
    a box with corresponding holes of the right shape for each object. As can be seen
    from *Figure 2**.1*, it is impossible to fit a cylinder into a square, a cube
    into a circle, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – An example of a Montessori toy](img/B20912_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – An example of a Montessori toy
  prefs: []
  type: TYPE_NORMAL
- en: The usage is intuitive and provides immediate feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to envision writing the code and designing the components in this way:
    we expect our code to perform certain actions, which may have impacts on external
    systems or a database. Misusable code could potentially cause significant problems—for
    instance, it could write incorrect information to a database—or it could simply
    fail to function properly. When providing our services, which include our code,
    libraries, and design, we must put ourselves in the shoes of those who will integrate
    or utilize them.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several techniques to make your code non-misusable, and it would take
    – and indeed there are – entire books on the subject. However, I want to give
    you a couple of ideas here that can be easily applied even without delving too
    deep.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be overly generic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One “trick” to make your code non-misusable is to avoid overly generic data
    types whenever possible. Types like Integer, String, List, and so on, serve as
    the building blocks for constructing our programs and are very versatile. However,
    the flip side is that they can sometimes be too generic. Let me give you a couple
    of examples from my own experience: in a company operating in the travel industry,
    we deal with a service that returns all available flights based on a user’s search.
    As we need to represent the number of adults, children, and infants for whom a
    solution is being sought, we chose the following solution (for simplicity, let’s
    omit the handling of null values, possible initializations with default values,
    etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, for example, if we are searching for a flight for 2 adults, 1 child, and
    1 infant, the convention would be to populate `passengers` as an array: `[2, 1,
    1]`. In my opinion, this choice is very risky. We could insert fewer values than
    necessary, for example, just one or two. We could insert more values. We could
    even omit them entirely. Yes, we could introduce some input validation, but why
    allow input and then return an error later? If this were a library, by the way,
    I would be forced to read the documentation to understand how to populate that
    field (there’s nothing wrong with reading documentation, of course, but it should
    be something that could be more intuitive). It would be more intuitive instead
    to divide the information into a more meaningful structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Much clearer, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, in fact, go further and create an ad-hoc structure for our needs,
    something that cannot lead to confusion. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And that would lead to having a single, understandable field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Use standards for writing good code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to make your code non-misusable is to use standards whenever possible.
    A couple of examples come to mind, related to handling time. If you need to represent
    a date, choose a format, document that you are using it, and consistently use
    it throughout your project. One thing I’ve seen done very often is trying to represent
    a time period or duration with an Integer or even a String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting from `Duration` class, and I highly recommend using it. It is incredibly
    versatile and allows you to represent a duration of time unambiguously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional cool thing: the preceding duration serializes according to a convenient
    ISO standard (ISO-8601), such as `PT2H30M`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing here is simple: don’t reinvent the wheel! After all, Java is so widespread
    also because there are a multitude of libraries available, so I suggest, while
    we are solving common problems, to avoid recreating basic components and instead
    rely on language features or open source libraries. One of the first things that
    I always ask myself is: am I the first one having this issue? The answer is rarely
    yes.'
  prefs: []
  type: TYPE_NORMAL
- en: Use single sources of truth for data and logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Last piece of advice: use a single source of truth for data and a single source
    of truth for logic. I must admit that the concepts of a single source of truth
    are often straightforward to explain but less easy to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me try to illustrate what I have in mind with an example. Once again, let’s
    imagine managing a flight search system. Typically, the data can be divided into
    primary data and derived data. Primary data is essentially the information without
    which our system couldn’t function, while derived data refers to all the other
    information. In our flight search example, let’s say we need to provide, among
    other details, the duration of a trip from Milan to San Francisco. The trip consists
    of two flights: one from Milan to Copenhagen and another from Copenhagen to San
    Francisco. In this example, we can consider the departure and arrival times of
    each individual flight as primary data. From these, we can derive information
    about the duration of the trip and potentially the duration of the layover. Managing
    derived data as primary data, for example by storing it in the database, could
    lead to inconsistencies. Especially when deriving information from a large volume
    of data – or when the derivation is complex or involves some external system –
    the computational cost of such calculations could be high. I would advise you
    to exercise caution and consider implementing a mechanism called **lazy calculation**.
    Essentially, this approach involves calculating the derived data only when it
    is needed, rather than in advance, and saving it in a cache so that it is readily
    available for future use. In our flight duration example, we would calculate the
    journey duration using the flight’s departure and arrival times (we have also
    to consider the airport locations and their time zones) without storing it in
    a database, but at most in a short-term cache or something like that. If we stored
    it in a database, in fact, we would have to recalculate it every time the flight
    departure/arrival times change (in industry jargon, every time there is a “schedule
    change”) or we might get inconsistencies.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as having a single source of truth is a good practice, having a single
    source of logic is also beneficial. In the aforementioned case, for instance,
    we need to calculate the duration of a flight from Milan to San Francisco. While
    it may not be rocket science, it is not a trivial calculation either, as it involves
    different time zones and the so-called daylight saving time. It is one of those
    things that is easy to underestimate and can, more easily than you might think,
    lead to bugs in production (and there are many flight search websites that have
    this bug in production at the moment I’m writing). In this case, it is very helpful
    to write the function once, thoroughly test it, and then consistently use it throughout
    our code base. This way, we do not stray far from the good old principle of **Don’t
    Repeat Yourself** (**DRY**). In this case, you could write a library, a service,
    or just a class in your project that deals with the journey duration and use it
    every time you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Good code is modular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, modularity refers to the concept of dividing a system or complex
    entity into smaller, independent components or modules. It is a principle that
    can be applied beyond software and is used in various fields and disciplines.
    Let’s consider a shelving unit consisting of individual modules that can be easily
    assembled and disassembled.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – This kind of furniture is composed of a set of identical and
    reusable modules](img/B20912_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – This kind of furniture is composed of a set of identical and reusable
    modules
  prefs: []
  type: TYPE_NORMAL
- en: Each module serves as a building block, and you can arrange them in various
    configurations to create different shelving arrangements based on your needs.
    This modular approach allows for flexibility in adapting the furniture to different
    spaces and changing requirements. For example, as seen in *Figure 2**.2*, it is
    possible to use the same type of brackets vertically, adapting them to shelves
    of different lengths.
  prefs: []
  type: TYPE_NORMAL
- en: The components that make up this shelf are easy to use, meaning they have clear
    interfaces and few points of interaction. If you put yourselves in the shoes of
    both the designer of this shelf and the person who has to assemble and maintain
    it, you understand that modularity is essential. If there were a different way
    to assemble each shelf or bracket, or if there were different brackets for different
    shelves, the management would be much more complex and prone to errors. We’ll
    say something more about modularity in the text sections.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes often need to use other classes. In well-organized code, we often solve
    each of these smaller problems with a separate class. However, there isn’t always
    just one way to solve a problem, so it can be helpful to structure our code in
    a way that allows us to change how we solve these smaller problems. That’s where
    dependency injection comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'I could give you a quick example relating to our example flight search system.
    Let’s suppose we have `FlightSearcher` which returns, given an itinerary and a
    description of the people involved, some possible travel plans around Europe and
    their relative prices. Of course, we are a profitable company so we want to surcharge
    the original price to get some earnings out of it. A crucial part of the response
    will be the price given to the customer, calculated through a component called
    `FlightPricer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is clear to see that the `FlightSearcher` components depend on `EuroFlightPricer`.
    As easily inferred from the name of the `EuroFlightPricer` component, it handles
    and returns prices in euros. Without blaming the hard-working development team
    that was under pressure to deliver this feature as quickly as possible to ensure
    the company’s commercial success, it is clear that hardcoding this dependency
    is not a wise long-term choice. Certainly, ensuring simplicity and readability
    of the code is guaranteed (for example, there is no need to provide any parameters
    for the constructor). However, if we were to use another currency or any other
    logic for calculations in the future, we would need to modify the existing code.
    The solution is to inject the dependency from the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is crucial to note that `FlightSearcher` now depends on an interface. We
    will use, in fact, a specific implementation of the `FlightPricer` interface intended
    just to handle the euro currency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With dependency injection, we can easily reconfigure the `FlightSearcher` class.
    This is possible because all the different pricer classes implement the same `FlightPricer`
    interface, allowing the `FlightSearcher` class to depend on it. This means we
    can use any implementation of `FlightPricer`, making the code more flexible and
    adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to a general technique for making code more modular and adaptable:
    if we depend on a class that implements an interface with the needed functionality,
    it’s usually better to depend on the interface itself instead of the specific
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Law of Demeter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Law of Demeter**, also known as the principle of least knowledge and
    sometimes abbreviated as **LoD**, is a software design guideline that promotes
    loose coupling and encapsulation. According to this principle, an object should
    have limited knowledge about other objects and should only interact with its immediate
    neighbors. Let’s see some applications of this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid chaining method calls excessively**: Instead of accessing methods of
    multiple objects in a single chain, limit the number of method invocations to
    maintain loose coupling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While this code works, it could be problematic for several reasons. Firstly,
    it assumes that each method call will successfully return a non-null object, otherwise,
    it may encounter a `NullPointerException`. Additionally, it tightly couples the
    code to the specific structure of the object hierarchy. If the structure changes
    in the future, this code will need to be modified accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this version, the nested object hierarchy is traversed step by step, and
    each intermediate object is stored in a separate variable. This approach allows
    for better readability, improved error handling (it would be possible to check
    for null values), and flexibility in case the structure of the object hierarchy
    changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Don’t expose the internals of an object by returning references to internal
    objects**: Instead, provide high-level methods that encapsulate the required functionality.
    For example, let’s suppose we must retrieve all the books from a warehouse that
    stores several types of goods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code is technically OK, but the caller is forced to retrieve all the items
    and then filter to keep only the books. This is unpleasant for several reasons:
    we query the `Warehouse` for all of the items, but we only need books; the caller
    must increase its complexity to filter the items; we must expose the internal
    structure of `Item` to let the client get the `Type` of the `Item` itself, so
    that it can apply filtering. We’re producing, above all else, strong couplings.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this way, we don’t let the client do all the filtering and we only enquire
    in the warehouse for books. We are not forced to expose the type of the `Item`,
    because the client just asked for a given category. We should optimize even more
    this code, for example returning a `Book` class instead of `Item`, but the purpose
    was just to provide an example for the internal structure exposure, so we’ll stop
    here for now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Avoid passing objects further than necessary as method arguments**: If an
    object requires access to another object, provide only the necessary information
    or dependencies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, the `shipOrder` method receives all of the order, while it needs
    only the `items` of the order itself. It would be better to change the `shipOrder`
    signature so that it takes only them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we provide to `shipOrder` only the necessary information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It can’t be said that the entire developer community fully agrees with the Law
    of Demeter (refer to the Further reading section), so much so that some think
    it should be called the *suggestion* of Demeter.
  prefs: []
  type: TYPE_NORMAL
- en: Data cohesion (make related data work together)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes help us organize things, but it can become problematic if we group too
    many things together in a single class. We should be careful about this, but at
    the same time, we shouldn’t forget the benefits of grouping things together when
    it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, certain pieces of data are naturally related to each other, and our
    code needs to handle them together. In such cases, it makes sense to group them
    into a class or a similar structure. By doing this, our code can focus on the
    overall concept that the group of items represents, rather than dealing with specific
    details all the time. This approach promotes modularity in our code and allows
    changes in requirements to be isolated more easily.
  prefs: []
  type: TYPE_NORMAL
- en: An example of related data grouping is the combination of price and currency.
    In many applications, when dealing with financial transactions or monetary values,
    it is essential to consider both the price amount and the currency in which it
    is expressed.
  prefs: []
  type: TYPE_NORMAL
- en: By grouping the price and currency together into a class or a data structure,
    we can conveniently handle these related pieces of information as a single unit.
    This allows us to perform calculations, conversions, and other operations on the
    price while ensuring that the corresponding currency is correctly accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we can create a `Price` class that encapsulates the price value
    and the currency code. This class would provide methods to perform arithmetic
    operations and currency conversions and enforce consistency between the price
    and currency (and thus, the logic would all be in one place, behaving as a single
    source of truth).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of related data grouping could involve latitude and longitude
    coordinates. When working with location-based applications or mapping systems,
    latitude and longitude values are often used together to specify a specific point
    on the Earth’s surface. By grouping latitude and longitude into a class or a data
    structure (simply put: `Point`) and encapsulating the latitude and longitude values,
    we can conveniently handle and manipulate geographic coordinates as a cohesive
    unit. And again, we could perform various operations such as distance calculations,
    mapping functionalities, or finding nearby locations (actually, many libraries
    that deal with geographical calculation do exactly this).'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t leak implementation details in the return type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to keep things organized and easy to work with, it’s important to make
    sure that each layer of abstraction is clean and doesn’t reveal how things are
    implemented under the hood. When implementation details are leaked, it can expose
    information about lower layers in the code and make it really tough to make changes
    or customize things later on. One common way this happens is when the code returns
    a type that’s tightly connected to those specific details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our hypothetical flight search system, let’s consider the scenario where
    we depend on external suppliers through traditional web service calls. Due to
    legal requirements, we are obligated to retain all the requests and responses
    for a specific duration. To address this, we have implemented a service within
    our code base that handles the storage of these records. We use a cloud storage
    system, referred to as SkyVault, for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the class spills the beans about using `SkyVault` as our storage
    service, and it binds the client to this choice. This makes it super hard to change
    things if we ever want to switch to a different storage service, use a database,
    or go for any other type of data storage. Changing the code would be very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution to this problem could be to abstract the response in a very trivial
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the return type, there are cases where the implementation is overly
    visible, creating a tight connection between library or service users and the
    service itself. For example, the implementation complexities of external systems
    are exposed instead of being simplified and pushed up to the caller level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the client needs to first check if the payload `exists` before
    calling the `upload` method. If it does exist, they have to use the `overWrite`
    method instead. This extra step adds unnecessary complexity for the client. It
    would have been better if this complexity was handled internally within the method
    itself (unless, of course, overwriting an existing file is somehow important to
    our specific situation).
  prefs: []
  type: TYPE_NORMAL
- en: Good code is reusable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As engineers, we often solve big problems by breaking them down into smaller
    ones (the good old *divide et impera*). And guess what? We keep running into the
    same small problems over and over again across different projects. So, if we or
    other engineers have already figured out a solution to one of these recurring
    problems, it just makes sense to reuse it. It saves us time and reduces the chances
    of introducing bugs because we know the solution has already been tried and tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of reusability is closely tied to two key practices: establishing
    clear layers of abstraction and developing modular code. By implementing clean
    layers of abstraction and modularizing our code, we naturally break down solutions
    to subproblems into separate code components that are loosely interconnected.
    This approach significantly enhances the ease and safety of code reuse and generalization.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t make assumptions while writing your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't make assumptions is a good piece of advice for life in general – but I
    don’t want to be your life coach here, so don’t worry.
  prefs: []
  type: TYPE_NORMAL
- en: There is no specific definition for an assumption, but I can provide you with
    a recent example I encountered. Imagine you are responsible for managing an e-commerce
    system and need to maintain records of purchases. Each purchase is characterized
    by a set of properties, and each purchase has a unique identifier called the **ID**.
    It is important to note that this ID is a numeric value that increases sequentially.
    For instance, if a purchase has ID *x*, the subsequent purchase will be identified
    as *x+1*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside the purchase management system, there is a typical component found
    in most companies called a reporting system (in my mind, I can hear a horse neighing,
    as in the movie *Frankenstein Junior*). This reporting system relies on determining
    the relative recency of purchases. The logical basis for this comparison is typically
    a date field such as `created_on` or a similar attribute. However, the reporting
    system in this case makes the assumption that the ordering of purchases is solely
    dependent on the `id` field. It assumes that the lower the ID, the more recent
    the purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider a scenario where the maintainers of the purchase management
    system needed to migrate data. It became convenient for them to change the ID
    generation process to use random alphanumeric strings instead of numeric increments.
    Consequently, the reporting system, which had assumed that the IDs were numerical
    and sequentially incremental, ceased to function correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assumptions can lead to bugs when code is reused because the reused code may
    rely on certain conditions or behaviors that are not met or consistent in the
    new context. These bugs may kick in many different ways, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Contextual differences**: When code is reused in a different context or environment,
    the assumptions made during the original implementation may not hold true anymore.
    The underlying dependencies, data structures, or system configurations might be
    different, causing the code to behave unexpectedly or produce incorrect results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit dependencies**: Reused code may have implicit dependencies on external
    factors, such as specific data formats, database schemas, or API responses. If
    these dependencies are not properly understood or communicated, using the code
    in a different context can result in compatibility issues and unexpected failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assumed constraints**: The reused code might make assumptions about the limitations
    or constraints of the original system. These assumptions could include factors
    like data size, frequency of operations, or expected usage patterns. If these
    constraints are exceeded or not satisfied in the new context, the reused code
    may not handle the situations correctly, leading to bugs or system failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility issues**: Code reuse often involves integrating different components
    or libraries. If the reused code relies on specific versions or configurations
    of these components, it may not work as intended when used with different versions
    or alternative implementations. Incompatible interactions between reused code
    and other components can introduce bugs or cause system instability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited validation**: Assumptions may not have been thoroughly validated
    during the original implementation. When code is reused, there is a risk that
    the assumptions were only valid in the original use case but not in other scenarios.
    Insufficient validation of assumptions can result in bugs that arise when the
    code is reused in a different context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you make assumptions, identify them clearly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I am a man who lives by his own contradictions, and so now I tell you: making
    assumptions is crucial! The important thing is to do it at the right time, in
    the right amount, and for the right things. For example, when we find ourselves
    working on a completely unfamiliar code base, it is vital to make assumptions;
    otherwise, we would be navigating through every single class, every single line,
    searching for answers to our countless questions. Another example is debugging:
    when it comes to fixing bugs, start by making lots of assumptions, especially
    if you’re familiar with the code. Trust your gut feeling. Most of the time, when
    someone starts explaining the problem to you, you will already know where the
    bug is hiding. Also, when creating new code, assumptions can be crucial in order
    to build quickly and effectively. Otherwise, we may end up stuck trying to create
    code to handle every possible use case, even the ones that are not going to happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At times, making assumptions becomes necessary or simplifies the code significantly,
    outweighing any drawbacks. However, when we make assumptions in our code, it’s
    crucial to remember that other engineers might not be aware of them. To prevent
    them from inadvertently being affected by our assumptions, we need to enforce
    them. There are generally two approaches we can adopt to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create()` method instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilizing an error-signaling technique**: If it’s not feasible to make the
    assumption foolproof, we can implement code that detects when the assumption is
    violated and employs an error-signaling technique to quickly halt the execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you would like to look more deeply into these aspects, I recommend the book
    by Tom Long listed in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve learned what makes code good, the most important things for which
    are readability and reliability. Good code should be easy to understand and hard
    to mess up. It’s modular, like a well-built piece of furniture that you can use
    over and over again. Of course, there’s some room for debate and personal preference,
    but I think we can mostly agree on these points. Now, let’s move on to another
    important way to create good code: **Clean Code**.'
  prefs: []
  type: TYPE_NORMAL
- en: Clean Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most well-known book on Clean Code is called *Clean Code* by Robert C. Martin.
    Surprisingly, even Martin himself struggles to come up with a single definition
    for Clean Code. It seems like there are multiple definitions floating around among
    us developers. In fact, in his book, Martin asks several developers to provide
    their own “custom” definitions, and he includes all of them so that we can create
    our own understanding of what Clean Code means.
  prefs: []
  type: TYPE_NORMAL
- en: Clean Code is all about writing code that’s easy to understand and follows a
    logical and disciplined approach. The main goal is to create software efficiently
    and effectively while ensuring that the code is readable, adaptable, expandable,
    and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could argue that this definition is not objective, and you would be right!
    For example, “*readable*” is something very personal (and depends also on the
    seniority and the skillset of those who are approaching the code). More often
    than you might think, we judge code by our guts. Can I understand it? Then it’s
    readable! Rephrasing from the “*Fundamental Theorem of Readability*” book by Bowsell
    and Foucher: *code should be crafted in a way that reduces the amount of time
    someone else would need to* *comprehend it.*'
  prefs: []
  type: TYPE_NORMAL
- en: And when we use the word “*understand*,” we set a very high standard. To truly
    comprehend your code, someone should possess the ability to make modifications,
    identify bugs, and grasp how it interacts with the rest of your code base. Clean
    Code is not a set of laws or a set of rules; it is an attitude, a mindset that
    we all should follow.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, refactoring and clean code are strictly related, since
    they both aim to improve the quality and maintainability of software.
  prefs: []
  type: TYPE_NORMAL
- en: Why Clean Code?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exactly as happens with refactoring, when I talk about Clean Code at work to
    people who don’t have a technical background, the reactions vary, but not so much:
    they range from yawning to rolling their eyes, from looking down to impatient
    gestures. They perceive someone talking about incomprehensible topics to them,
    or proposing “changing something that works” or “writing code well,” as if there
    was something other than code that either works or doesn’t work (and – let’s face
    it – considering practices such as refactoring as a waste of time and money).'
  prefs: []
  type: TYPE_NORMAL
- en: Things such as documentation and comments are definitely important (and we’ll
    get there), but the most crucial thing that should always speak for itself is
    your code. Write your code as if you’re talking in everyday language. Make it
    understandable not just for now, but also for yourself and others in the future.
    Remember that a big part of our job is maintenance (which might not be fun, but
    it’s a reality). When your code can speak for itself, it not only improves your
    technical skills but also enhances the quality of your code. Being able to communicate
    clearly about your code allows you to seek help and receive valuable suggestions
    for improvement. Clean code doesn’t magically appear; it requires dedicated effort
    to express your intentions effectively. Aim to write self-explanatory code, organized
    and structured, so that you don’t have to litter it with excessive comments to
    explain its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already mentioned that your code will be read by someone else, whether
    it’s another person or even yourself. This highlights the need to write Clean
    Code, as it benefits teamwork. It takes less time to understand what the code
    does, fix it when issues arise, and add new features. Clean Code promotes code
    reusability and makes you a more efficient programmer; it facilitates easier and
    faster maintenance, as it is easier to understand, debug, and modify when needed.
    Simply put, it makes the team faster. You can use this argument (this *fact*)
    when a colleague or manager accuses you of wasting time by being picky about the
    code!
  prefs: []
  type: TYPE_NORMAL
- en: One often underestimated aspect of writing clean code is feeling comfortable
    with what you’re doing. Imagine having to ask someone for help and showing them
    something messy and shaky, something that is hard to understand and complicated
    to explain. It would be embarrassing. Moreover, in my opinion, working on a clean
    project boosts morale. You have the satisfaction of doing things properly, almost
    something beautiful, you could say. It’s what a craftsman should do (forgive the
    clichéd metaphor). We’re not just button pushers; we’re artisans. Let’s always
    write code as if we were going to show it to someone else (and actually showing
    it to someone else, through peer reviews or pair programming, really helps—we’ll
    come on to that later). Clean Code just works better, hence the satisfaction is
    not only when people look at your code, but also when they use the services it
    provides and they work properly.
  prefs: []
  type: TYPE_NORMAL
- en: If you think your main job as a programmer is writing code, think again. You
    actually spend more time reading code, hunting down bugs, identifying issues,
    and figuring out solutions. Clean Code simplifies all of these tasks. One thing
    every programmer can unanimously agree on is that Clean Code is undeniably better.
  prefs: []
  type: TYPE_NORMAL
- en: Some principles of Clean Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trying to explain Clean Code in its entirety would take a whole book, and guess
    what? It already exists courtesy of Uncle Bob, Robert C. Martin. However, I do
    think it would be helpful to provide you with some highlights, especially if you’re
    new to this topic. We’ll delve deeper into some of these aspects later on.
  prefs: []
  type: TYPE_NORMAL
- en: KISS – Keep things as simple as possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KISS** (short for **Keep It Simple, Stupid** or **Keep It Stupid-Simple**,
    depending on how bold you want to be) is one of the oldest rules in clean code.
    It urges programmers to keep their code as simple as possible. Avoid making things
    needlessly complicated. In the world of programming, there’s never just one way
    to solve a problem. You can accomplish a task using different languages and various
    commands. Programmers who embrace the KISS principle always ask themselves if
    there’s a simpler way to tackle a specific problem.'
  prefs: []
  type: TYPE_NORMAL
- en: DRY – Avoid repetition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the main functions of computer science is to come up with cool acronyms.
    **DRY** (short for **Don’t Repeat Yourself**) is one of them. It’s like a more
    specific version of KISS, emphasizing that functions in Clean Code should do one
    thing only (and do it well). It’s worth noting that the opposite of DRY code is
    called **WET**, which stands for **We Enjoy Typing** or **Write** **Everything
    Twice**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very trivial WET code example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this code, there are many lines that are basically the same.
    We must try to avoid these repetitions; to continue with the wordplay, we must
    *dry* this *wet* code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its DRY version, the preceding code becomes the following, with no surprises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the DRY version, we simply isolated the repeated code in a single method.
    This example was very simple because the repeated line was just a one-line `sysout`,
    but this was just to explain the concept: imagine how it would be if there were
    many lines. And that will not only create clean, more readable code but will also
    reduce the possibility of bugs sneaking in (and security issues, as well).'
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI – delete what’s useless
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Clean Code principle **YAGNI** (short for **You Aren’t Gonna Need It**)
    follows this simple idea: a developer should only add extra functionality to code
    when it’s actually needed. YAGNI is closely associated with Agile software development
    approaches. According to the YAGNI principle, instead of starting with a grand
    plan, you should build the software architecture in small increments to address
    problems as they arise. This allows for dynamic and individualized problem-solving.
    Clean Code is achieved when the underlying problem is solved efficiently without
    unnecessary bells and whistles.'
  prefs: []
  type: TYPE_NORMAL
- en: Code should be readable, not concise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code needs to do its job and be interpreted correctly by the machine. But it’s
    not just the machine that needs to understand it—other developers should be able
    to comprehend the code too, especially in collaborative projects. That’s why readability
    is always prioritized over brevity in software development. Writing concise code
    is pointless if it becomes incomprehensible to others. A prime example of producing
    clean and readable code lies in variable naming.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable should have a name that clearly conveys its purpose. Take the following
    variable, for instance, which is cryptic without the requisite background knowledge
    and explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But also, this somewhat more precisely named variable still leaves some doubt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be elapsed... time, OK, but what’s the measurement unit? By using
    the following name for the same variable, its purpose becomes evident:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our personal opinion on the length of variable names is that I prefer them to
    be longer rather than too short. It would be ideal to find a middle ground, but
    it’s not always possible. Between the two extremes, I lean towards longer names
    as they enhance readability. However, it’s important to note that lengthy names
    can sometimes indicate underlying issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we quickly reviewed what Clean Code is. There are entire books,
    online courses, and company workshops dedicated to this topic... in short, there
    is a whole world around it, and I don’t expect these few lines to cover everything.
    My invitation, as usual, is to delve into it as much as possible. There are still
    people out there who consider Clean Code as an accessory, something that wastes
    time because the code works even when it’s not clean. I hope I conveyed the concept
    that things don’t work that way and that good and clean code brings numerous advantages
    with relatively low effort if approached methodically. In the next section, we
    will add another adjective to our code: after good and clean, we will see what
    is meant by *SOLID* code!'
  prefs: []
  type: TYPE_NORMAL
- en: Write SOLID code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there’s one thing the software engineering community excels at, it’s coming
    up with cool acronyms! That’s exactly what Michael Feathers did when he took inspiration
    from a paper by the ever-present Robert C. Martin (aka Uncle Bob) and came up
    with the term **SOLID principles**. In his essay, Martin recognized that software
    evolves and gets more complicated over time. But without good design principles,
    he warned that software becomes rigid, fragile, and hard to work with. That’s
    where the SOLID principles come in—they were created to tackle these issues head-on
    and make software development easier and more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The acronym SOLID represents five fundamental design principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility** **Principle** (**SRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open-closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These principles are widely adopted by software engineers and offer significant
    advantages for developers. Please note that, unlike what is explained in the other
    sections, the SOLID principles apply only to object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essence of the SRP, as eloquently stated by Robert Martin, is that “*a class
    should have one, and only one, reason to change*.” By adhering to this principle,
    each class focuses on a specific task, ensuring that every class, module, or component
    in the software system has a clear responsibility. In simpler terms, each class
    should address a single problem.
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle is a fundamental concept already employed
    by most developers when writing code. It can be applied to various levels, such
    as classes, software components, or microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'By following this principle, several benefits arise: code becomes easier to
    test and maintain, software implementation becomes more straightforward, and it
    helps prevent unexpected side effects when making future changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe it’s worth providing an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `UserManager` class violates the SRP by having two distinct
    responsibilities: saving the user to the database and sending emails to the user.
    Ideally, each class should have only one responsibility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To address the SRP violation, we can refactor the code by separating the concerns
    into different classes. Here’s a possible refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this refactored code, the `UserRepository` class is responsible for handling
    persistence logic, while the `EmailService` class handles email communication.
    By separating these concerns into different classes, we adhere to the SRP and
    make the code more maintainable and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Open-closed principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept behind the open-closed principle is that when new functionality
    needs to be added, it’s preferable to extend existing, well-tested classes rather
    than modify them. Making changes to classes can introduce issues or bugs. The
    goal is to be able to enhance a class’s behavior without altering its original
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adhering to this principle is crucial for developing code that is easily maintainable
    and adaptable. A class follows the open-closed principle if it satisfies the following
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open for extension**: The class’s behavior can be extended or augmented'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closed for modification**: The source code of the class remains unchanged
    and is not directly modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At first glance, these two criteria might appear contradictory, but as you become
    more familiar with the principle, you’ll realize that it’s not as complex as it
    initially seems.
  prefs: []
  type: TYPE_NORMAL
- en: To follow these principles and make sure your class can be easily extended without
    changing the code, you need to use abstractions. Inheritance or interfaces that
    allow for different implementations are commonly used to meet this requirement.
    No matter which method you choose, it’s important to stick to this principle so
    that your code remains easy to maintain and update.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you work for a travel e-commerce company that sells various modes
    of transportation. With a focus on environmental sustainability, you decide to
    display the CO2 emissions for each mode of transport. Currently, you handle airplanes
    and trains.
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to have the following interface and classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two implementations of `Co2Calculator`, one used for planes and one
    for trains. Each of them implements, of course, the same method. This interface
    would be used in another class – let’s call it `EmissionCalculator`, in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Should we decide to introduce a new transportation mode, for example, `Bus`,
    it would be easy to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: None of the existing code has been touched. Our `EmissionCalculator` class doesn’t
    need to implement new logic when we introduce a new transportation mode.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among the five SOLID principles, the Liskov substitution principle can be challenging
    to grasp. In essence, this principle states that any derived class should be capable
    of replacing its parent class without causing any issues. Simply put, if class
    *A* is a subtype of class *B*, we should be able to replace *B* with *A* without
    disrupting the behavior of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a very trivial example, let’s suppose we must model vehicles (for simplicity,
    I’m omitting constructors, getters, and setters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Introducing a new `Bicycle` entity and making it extend the `Vehicle` class
    would violate the principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are forced to implement the method of the `Vehicle` interface,
    but we are also unable to do it because, you know, bicycles have no engine! So
    we’re forced to cause disruption, for example, throwing an exception. We would
    not be able to replace a vehicle with a bike without disrupting the behavior of
    our program, violating the Liskov principle.
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main idea behind the **Interface Segregation Principle** (**ISP**) is to
    have many small interfaces rather than a few big ones. According to Martin, “*Make
    fine grained interfaces that are client-specific. Clients should not be forced
    to implement interfaces they do* *not use.*”
  prefs: []
  type: TYPE_NORMAL
- en: For software engineers, this means you shouldn’t just add new methods to an
    existing interface. Instead, start fresh and build new interfaces tailored to
    each client’s needs. Using smaller interfaces encourages composition over inheritance
    and promotes loose coupling. If an interface is too big, it’s better to break
    it down into smaller ones. That way, classes implementing those interfaces just
    have to worry about the methods they actually care about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we have the usual transportation selling system, and we have
    the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This interface seems pretty big, and the fact that its name ends with “*manager*”
    is too generic and could be a problem (because it lacks specificity and doesn’t
    provide clear information about the responsibilities or purpose of the class or
    component). It covers a lot of different things. If you were to implement it in
    a class, you’d have to handle a bunch of different stuff, each with its own level
    of importance.
  prefs: []
  type: TYPE_NORMAL
- en: What about splitting the `FlightManager` interface into three specific “calculators”,
    one for each concern?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we can have greater flexibility in deciding which classes will
    implement specific interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, each specific class only implements the required method(s) and isn’t aware
    of anything that is not its particular concern.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle helps separate software components. Basically, the dependency
    inversion principle suggests that developers should “*depend on general concepts,
    not specific implementations.*” Martin also explains that “*higher-level modules
    should not rely on lower-level modules. Both should rely on abstract concepts.*”
    Additionally, *“abstract concepts should not rely on specific details. Details
    should rely on* *abstract concepts.*”
  prefs: []
  type: TYPE_NORMAL
- en: A common approach to following this principle is to use a dependency inversion
    pattern, but that’s not the only way to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this principle, let’s suppose we have a (simplified) `LocationCatalog`
    class, which handles all of the queries about locations in a system. This class
    takes the “location dictionary” from a database repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code will function correctly, allowing us to utilize `LocationDatabaseRepository`
    without limitations in our `LocationCatalog` class.
  prefs: []
  type: TYPE_NORMAL
- en: So everything’s OK now? Not quite. There’s an issue, and it lies in tightly
    coupling these three classes together when declaring `locationRepository` with
    the new `LocationDatabaseRepository` class.
  prefs: []
  type: TYPE_NORMAL
- en: This not only makes it difficult to test our `LocationCatalog` class, but it
    also eliminates the possibility of easily swapping out the `LocationDatabaseRepository`
    class for a different one if needed.
  prefs: []
  type: TYPE_NORMAL
- en: To address this, let’s decouple our location manager from `LocationDatabaseRepository`
    by introducing a more generic `LocationRepository` interface and incorporating
    it into our class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully eliminated the dependency and now have the freedom to choose
    any source for our location, be it a file, an external service, or a mocked implementation
    (particularly useful for testing purposes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a good foundation in writing good code: we know what it is, we
    know about Clean Code, and we know that good code is also SOLID code. Next, let’s
    consider the reliability of code and the fact that reliable code does not produce
    unwanted effects, also known as side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Side effects and mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When something is immutable, it means its *state* can’t be changed once it’s
    created. Understanding why immutability is a good thing involves recognizing the
    problems that can arise from its opposite—mutability.
  prefs: []
  type: TYPE_NORMAL
- en: There are several downsides to having mutable objects or, in general, in being
    forced to handle mutability (and thus, handling objects’ state).
  prefs: []
  type: TYPE_NORMAL
- en: A mutable class that has setup functions can easily be misconfigured, leading
    to an invalid state; this is a sort of addendum (a *spin-off*) to what we said
    before (“*good code is hard to misuse*”). If you allow a class to have some kind
    of really detailed and complicated setup functions, it will be more likely to
    misuse it, ending up with a wrong or invalid configuration that will end in some
    malfunctioning in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Another big issue with mutable objects arises when you think about thread safety,
    a critical concern in multi-threaded or parallel programming because multiple
    threads can access and modify shared data simultaneously. For more information
    about what thread safety is, there’s an entry in the *Further reading* section.
    Mutable objects are not thread-safe because they can be modified by multiple threads
    concurrently without proper synchronization, leading to unpredictable and potentially
    incorrect behavior.
  prefs: []
  type: TYPE_NORMAL
- en: However the real problem with mutability occurs when a function messes with
    the input parameters. It’s like lending something to a friend. When you lend something,
    you don’t want it to get messed up because you might need it later or want to
    lend it to someone else (think of a book, a bike, or your favorite Batman action
    figure). That function holds important information that the function needs, but
    you might still need it for other things after the function is done.
  prefs: []
  type: TYPE_NORMAL
- en: If a function starts changing the input parameter, it’s like scratching your
    bike or ruining your Batman action figure. Usually, when you pass an object to
    a function, you expect it to be borrowed and returned as it is. But if the function
    goes ahead and messes with it, that’s not cool. Changing an input parameter is
    a side effect because it affects something outside the function itself. Typically,
    functions take inputs through parameters and give back results through return
    values.
  prefs: []
  type: TYPE_NORMAL
- en: For most engineers, modifying an input parameter is an unexpected side effect
    that can lead to surprises and confusion. So, it’s best to avoid messing with
    borrowed objects and stick to the convention of using parameters for inputs and
    return values for results.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way to make code non-misusable is to use immutable objects. In Java
    specifically, a typical immutable object would contain just the fields (with the
    final modifier), a constructor, and – optionally – the getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This object is indeed immutable, and it follows a common pattern for implementing
    immutability. All of its properties are declared as `final`, meaning they cannot
    be modified after they are initialized. The properties are typically declared
    in a constructor, which may or may not require all of these parameters, depending
    on the specific requirements. This object does not provide setter methods, as
    attempting to do so would result in a compilation error due to the `final` fields.
    However, it does provide getters for accessing the property values, but this can
    vary depending on your specific needs. It should be evident that once this object
    is created, it cannot be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the same aim can be achieved in a much simpler way using a Java record
    (introduced in **Java 14**), but that would be a bit out of scope here. The goal
    is to promote immutability; this implementation is just an example. There's also
    the builder pattern that we'll introduce in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another really common example in Java is the `String` class. A `String` object
    always represents the same string. Since `String` is immutable, once created,
    a `String` object always has the same value. To add something to the end of a
    `String`, you have to create a new `String` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, to make a class immutable, follow these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t provide any methods that modify the state of your object (aka mutators).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the class can’t be extended (this is mostly done by making it `final`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make all fields `final` and `private`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensure exclusive access to any mutable components: it can happen that a field
    of your class is defined as a mutable object. In this case, be sure that a client
    cannot obtain references to this object. Initialize it *inside* your class and
    make defensive copies in constructors and accessors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You could argue: OK, but I just have that one use case in which I *must* create
    an object and then change it. A typical example is when you have to create an
    object and fill its fields in different steps. My suggestion here is to use the
    builder pattern instead.'
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A builder is a design pattern commonly used in object-oriented programming to
    construct complex objects step by step. It provides a flexible and readable way
    to create objects with multiple optional parameters or configurations. The builder
    pattern separates the construction of an object from its representation, allowing
    the same construction process to create different representations of the object.
    It provides a clear and intuitive API for constructing objects by providing methods
    to set values for various properties or parameters. Typically, a builder class
    is created for each complex object, and it contains methods to set individual
    properties or configurations of the object. The builder accumulates these settings
    and finally constructs the object when requested. This approach allows for more
    readable and maintainable code, especially when dealing with objects that have
    many optional parameters or configurations. It promotes the idea of *fluent* or
    chainable method calls, where each method returns the builder instance itself,
    allowing for a more concise and readable construction syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a builder to create a “student”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The class provides a default constructor, which doesn’t take any parameters.
    The `StudentBuilder` class also provides two setter-like methods: `withName(String
    name)` and `withSurname(String surname)`. These methods allow setting the name
    and surname properties of the student, respectively. Each setter-like method updates
    the corresponding property of the builder instance and returns the builder object
    itself (`this`) to support method chaining. Finally, the `build()` method is used
    to construct and return a new `Student` object using the values set in the builder.
    It creates a new `Student` instance with the name and surname obtained from the
    builder and returns the constructed object. With this builder class, you can construct
    a `Student` object step by step, setting the name and surname values as needed.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new `Student` object with the name `"John"` and surname
    `"Doe"` using the builder pattern. By chaining the `withName()` and `withSurname()`
    methods, you can set the desired values for the name and surname properties, respectively.
    Finally, the `build()` method constructs and returns the `Student` object with
    the provided values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem a bit inconsistent with the message we provided earlier, the
    one regarding long chains of calls. However, in my opinion, this is a special
    case where we are simply constructing an object: there is no logic, the return
    type is always the same, and the alternatives would be equally complex, or worse
    – a long sequence of “set” methods and/or a constructor with many parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: The builder can be implemented in slightly different ways, and what’s more,
    it can be automated. You have the option to use IDE plugins or metaprogramming
    libraries such as Lombok. We will discuss these alternatives later on in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope that, up to this point, I have provided you with some small tools to
    help combat bad code; not an exhaustive list, but I hope to have at least sparked
    curiosity. Another thing I have always wondered is: why does bad code exist? Assuming
    it is not due to laziness or incompetence of individuals, let’s quickly explore
    some contingent causes that contribute to the situation we are trying to address.'
  prefs: []
  type: TYPE_NORMAL
- en: Causes of bad code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the previous chapter, I don’t have the intention of blaming
    those who write bad code. I myself have written bad code; it has happened in the
    past, it still happens, and it will happen again (I can already imagine my colleagues
    nodding as they read these lines!). In the vast majority of cases, those who write
    bad code do so without realizing it because we are human and can only handle a
    certain number of tasks at once. In our hearts, we have the desire to do a good
    job, something to be proud of, but in our minds, we have deadlines, and pressure,
    and we generally work within an ecosystem that we don’t fully control. Very often,
    companies are complex systems that may have clear rules (for example, regarding
    the methodologies to follow), but they have to deal with an increasingly hectic
    world, with time-to-market pressures, and the need to compete fiercely. There’s
    a way things should be and the way they actually are. As software engineers, we
    guide or support the work of the company and often find ourselves interacting
    with mentalities and needs that are very different from our own. Sometimes, the
    result is sacrificing quality and experiencing a bit of frustration. Almost always,
    this leads to having a bad code base. But why does this happen? If we could identify
    some common causes of bad code, maybe we’d be able to recognize them and avoid
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Deadlines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is definitely going to be a controversial point. For many, blaming deadlines
    as the cause of bad code is just an excuse to hide laziness or incompetence. It’s
    not true that there’s no time; it’s just that you don’t want to put in the effort
    to think and do things properly. In some cases, that may very well be true. Over
    the years, though, I’ve often observed – although I must say, not always and to
    a lesser extent as time goes on – a disconnect between management and engineers.
    There’s often a tendency to “sell” the solution without paying much attention
    to how long it will actually take to implement it. As a result, developers end
    up not negotiating a deadline but simply being subjected to it. So they take shortcuts,
    maybe cut back on testing, documentation, and overall quality (violating some
    of the principles seen so far, such as keeping code readable or without repetitions).
  prefs: []
  type: TYPE_NORMAL
- en: 'On this matter, I’d advise you to take a look at what’s called the *project*
    *management triangle*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The project management triangle](img/B20912_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The project management triangle
  prefs: []
  type: TYPE_NORMAL
- en: It’s like an equilateral triangle with sides representing the **Scope**, **Cost**,
    and **Time** of a project. These three dimensions are interconnected, and changing
    one of them will affect the overall shape of the triangle, which represents the
    quality. Furthermore, since the triangle needs to remain equilateral, it’s clear
    that modifying the available time will decrease the cost, and vice versa. By extending
    the time available, you can increase the project scope, but the costs will also
    go up accordingly. It’s a neat metaphor for how projects, including software projects,
    work.
  prefs: []
  type: TYPE_NORMAL
- en: The Broken Window theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s another thing to consider: the Broken Window theory. Philip Zimbardo,
    a psychologist from Stanford, did a very interesting study: he parked a car in
    a fancy neighborhood for a couple of days and just watched it. Surprisingly, nothing
    happened. He waited and waited, but nobody touched the car. Then, he decided to
    break a small window to see if things would change. Within just a few hours, the
    car was completely stripped; everything was gone – tires, wheels, electronics,
    steering wheel, seats, mats, even the engine. All that was left was a bare-bones
    car sitting on cinder blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the same kind of thing can happen with code. You start off with a clean
    situation; everything’s looking good. But as soon as you introduce one bit of
    bad code, things can quickly go out of control. For instance, you ignore code
    duplication in a few places, leave inconsistent formatting, and tolerate inconsistent
    variable naming. Again, you can start adding code without the proper test coverage,
    or you avoid upgrading your project’s dependencies due to fear of issues sneaking
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, these may seem like minor problems, and developers prioritize adding
    new features or fixing critical bugs instead. Other team members notice these
    neglected issues but also follow suit, assuming they are not a high priority.
    As developers, we’re already making some mistakes, so why bother doing it right
    in this case? Taking shortcuts and doing things the easier, faster way seems tempting.
    As time goes on, more developers join the project, and the code base grows larger
    and more complex. The neglected issues start to accumulate, making the code harder
    to understand and maintain. The lack of consistent conventions leads to confusion,
    reduces code readability, and introduces errors. Additionally, because the existing
    issues were not addressed, developers may feel less motivated to maintain code
    quality. They might think, “If there are already duplicated code snippets, what
    harm can a few more do?”. Eventually, the code base becomes a tangled mess of
    poorly organized, duplicated, and hard-to-read code. New developers joining the
    project struggle to make sense of it and find it increasingly difficult to introduce
    changes without inadvertently introducing bugs or breaking existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: It’s like a snowball effect, and things can get pretty messy in no time. And
    this kind of mess can produce technical debt; you re-pay technical debt with slowness
    in developing new features.
  prefs: []
  type: TYPE_NORMAL
- en: No code review process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we started programming, maybe back in school, it often happened that we
    did it alone. You wrote the code, tested it in some way, and that was it. The
    code and the design only needed to make sense to us and no one else.
  prefs: []
  type: TYPE_NORMAL
- en: When working in a team, it’s a good idea to implement code review mechanisms.
    A **code review** is the process of reviewing and examining code to improve its
    quality, identify issues, and ensure adherence to standards – we’ll delve into
    that in [*Chapter 8*](B20912_08.xhtml#_idTextAnchor183). Code reviews are also
    useful to make the code we write somewhat “consistent” and clear for all team
    members. When code reviews are absent, the code can become subject to personal
    preferences, may contain errors, or have room for improvement in terms of performance.
    Some people see the review process as a distraction from business activities;
    some developers see it as a hindrance to their own tasks. Sometimes, of course,
    even reviews cannot address particularly deep-rooted problems. However, they at
    least help identify major “issues” that may have slipped past the individual developer,
    who was focused on solving complex problems. It happens more often than you might
    think.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B20912_08.xhtml#_idTextAnchor183), we will introduce the **Pair
    Programming** practice, which can be used as a substitute for code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient domain or technical knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the reason behind bad code is simply that the people who worked on
    it were not aware of the application domain or the technologies being used. These
    are different aspects but somehow related.
  prefs: []
  type: TYPE_NORMAL
- en: When lacking domain knowledge, it’s easy to misinterpret requirements or write
    the logic in the wrong place (maybe not knowing that it already exists elsewhere).
    The situation gets worse when the code is already messy, and we have to work on
    it without really knowing what we’re doing. In this situation, even with the purest
    of intentions, removing an apparently unused `if` statement or changing how an
    object is created requires careful consideration (and adequate test coverage,
    something else we’ll tackle later).
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge gaps can also be purely technological. It may be that some of us are
    new and don’t yet have a clear understanding of the technology stack. This often
    leads to overly complex solutions or, on the contrary, workarounds and hacks.
    It can happen that the developer lacks certain discipline and the habitual use
    of good practices that we’ve tried to explain in this chapter. These practices
    – contrary to what it may seem – don’t exist to slow us down, but actually enable
    us to produce high-quality code quickly and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: We have tried to investigate some of the most common causes of bad code. I realize
    that I have relied on my own experience to some extent, but I believe that some
    of the concepts expressed here are universal and worth considering, such as the
    Broken Window theory or the project management triangle. The next time a manager
    asks you to do something well and in less time, you will hopefully have an additional
    argument on your side!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking of refactoring, it is crucial to understand what needs to be refactored;
    in other words, it is necessary to distinguish good code from bad code. In this
    chapter, we have seen what is typically meant by good code, providing an overview
    of its characteristics. When these characteristics are lacking, it is likely that
    refactoring is needed. When discussing good code, we must also talk about Clean
    Code; we addressed this topic and learned how to recognize it and, hopefully,
    write it. Good code is usually also SOLID code, and we briefly touched upon the
    meaning of that as well. Lastly, after understanding what good code is, we investigated
    some causes of bad code; the hope is that you will be alert if you find yourself
    in one of the described situations.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we'll address a set of warning signs—elements in your
    code that should alert you and prompt contemplation on refactoring your code.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'mscharhag, *ISO 8601 durations in* *Java*: [https://www.mscharhag.com/java/iso8601-durations](https://www.mscharhag.com/java/iso8601-durations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tom Long, *Good Code, Bad* *Code*, Manning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Stop calling it bad code*, by Joel Spolsky: [https://blog.pragmaticengineer.com/bad-code/](https://blog.pragmaticengineer.com/bad-code/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The law of leaky abstraction*, by Joel Spolsky: [https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What does Clean Code** **mean?** [https://cogut.medium.com/what-does-clean-code-mean-2190e4aed818](https://cogut.medium.com/what-does-clean-code-mean-2190e4aed818)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robert C Martin, *Clean Code*, Prentice-Hall 2009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Robert C Martin, *Design Principles and Design* *Patterns*: [http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf](http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is thread** **safety?**: [https://en.wikipedia.org/wiki/Thread_safety](https://en.wikipedia.org/wiki/Thread_safety)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The SOLID principles in** **pictures**: [https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898](https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*You should break the Law of Demeter*, by Ted Kaminski [https://www.tedinski.com/2018/12/18/the-law-of-demeter.html](https://www.tedinski.com/2018/12/18/the-law-of-demeter.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Essence of Refactoring and Good Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going through code, especially old code, is a big part of a software developer’s
    job. There are certain warning signs, like “red flags,” that professionals should
    notice right away. Recognizing and avoiding these issues is an important skill,
    and in this section, we’ll understand how to spot them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned what refactoring is and why it’s important, let’s explore
    a crucial requirement. Refactoring isn’t safe unless you have really good test
    coverage. We’ll find out why having thorough tests is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Next, how do you actually refactor your code? There are some common techniques
    that can be very helpful. We’ll learn how to master them.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we’ll delve into metaprogramming. Instead of manually changing code,
    metaprogramming techniques can automatically analyze and refactor it. For example,
    metaprogramming can generate code, replace method calls, or dynamically modify
    class structures. This makes refactoring faster and less prone to errors by reducing
    the amount of manual work needed.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we’ll discuss static and dynamic analysis. Static analysis involves
    examining code without running it and identifying issues like code smells and
    security vulnerabilities. Dynamic analysis, on the other hand, involves analyzing
    code by running it, helping find performance bottlenecks and runtime issues like
    memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B20912_03.xhtml#_idTextAnchor070), *Code Smells*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B20912_04.xhtml#_idTextAnchor095), *Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B20912_05.xhtml#_idTextAnchor117), *Refactoring Techniques*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B20912_06.xhtml#_idTextAnchor150), *Metaprogramming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20912_07.xhtml#_idTextAnchor161), *Static and Dynamic Analysis*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
