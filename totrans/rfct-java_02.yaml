- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Good Coding Habits
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好的编码习惯
- en: In a book about refactoring, I believe it’s necessary to talk about well-written
    code. These are two obviously closely related aspects that almost overlap. The
    lack of good code or solid architecture is among the main reasons for refactoring;
    refactoring is the means through which we aim to improve the writing of a method,
    a class, a project, or an architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在一本关于重构的书里，我认为有必要讨论编写良好的代码。这两个显然紧密相关的方面几乎重叠。缺乏好的代码或稳固的架构是重构的主要原因之一；重构是我们旨在改进方法、类、项目或架构的写作的手段。
- en: To understand clearly what we’re talking about, it’s important to try to explain
    what good code is and, by exclusion, what is considered poorly written code. It
    may seem excessive to try to define what good code is because, in reality, it
    should be – or should be treated as – something quite intuitive. We should almost
    have *spider senses* that tingle when we see code that is hard to understand or
    overly complicated. If you don’t have spider senses developed yet, don’t worry!
    They will grow with experience (and this book could help you get there).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地了解我们在谈论什么，尝试解释什么是好代码，以及什么是被认为写得不好的代码，这是很重要的。试图定义好代码可能看起来有些过度，因为实际上，它应该——或者应该被视为——某种相当直观的东西。我们应该几乎有*蜘蛛感*，当我们看到难以理解或过于复杂的代码时，会感到刺痛。如果你还没有发展出蜘蛛感，不要担心！它们会随着经验增长（这本书可能有助于你达到那里）。
- en: Nowadays, good code is often synonymous with *Clean Code*, that is, a collection
    of informal rules gathered in the book of the same name by Robert C. Martin (we’re
    going to speak about Clean Code a lot). In this chapter, we’ll try to summarize
    in broad terms what Clean Code means, what its fundamental principles are, and
    why we should all strive for Clean Code every day of our professional lives.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，好的代码通常与*清洁代码*同义，即由罗伯特·C·马丁（我们将在很多地方讨论清洁代码）在同名书中收集的一系列非正式规则。在本章中，我们将尝试从广义上总结清洁代码的含义，其基本原理是什么，以及为什么我们每个人都应该在职业生涯的每一天都努力追求清洁代码。
- en: Clean Code is often accompanied by and closely related to the so-called SOLID
    principles, for which the computer science community has shown great inventiveness
    regarding acronyms. But they also provide *solid* (do software developers love
    dad jokes?) foundations for writing excellent code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码通常与所谓的SOLID原则密切相关，计算机科学界在缩写词方面表现出了极大的创造力。但它们也为编写优秀的代码提供了*坚固*（软件开发者喜欢父亲笑话吗？）的基础。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is good code?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是好的代码？
- en: Clean Code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁代码
- en: Write SOLID code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写SOLID代码
- en: Side effects and mutability
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副作用和可变性
- en: Causes of bad code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏代码的原因
- en: A small disclaimer
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的免责声明
- en: I don’t claim to present the ultimate truth about anything. I know that some
    of what I’ll write is the subject of debate, and there are plenty of programmers
    out there ready to question everything (and I say that as a good thing). The intention
    is to share what I believe are healthy habits to practice every day, to avoid
    getting stuck and, most importantly, to find joy in our beautiful craft as artisans.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不声称要呈现任何事物的终极真理。我知道我将要写的一些内容可能会引起争议，而且有很多程序员随时准备质疑一切（我说这是好事）。目的是分享我认为每天应该练习的健康习惯，以避免陷入困境，最重要的是，在作为工匠的美丽工艺中找到快乐。
- en: Characteristics of good code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好代码的特点
- en: Once again, I must disappoint you. I struggle to find a clear, precise, and
    universally agreed-upon definition of what good code is. It is a highly subjective
    concept that heavily depends on the context. Online and in textbooks, you can
    find numerous definitions that differ slightly from each other. However, I strongly
    believe that there are some foundations on which we can all agree. I will try
    to summarize the various interpretations of good code and provide some feedback
    based on my experience, for what it’s worth.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我必须让您失望。我努力寻找一个清晰、精确且被普遍认同的好代码的定义，但很难找到。这是一个高度主观的概念，很大程度上取决于上下文。在网上和教科书中，你可以找到许多略有不同的定义。然而，我坚信有一些基础是我们都可以同意的。我将尝试总结关于好代码的各种解释，并基于我的经验提供一些反馈，仅供参考。
- en: Good code is readable
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好的代码是可读的
- en: 'Obviously, this is the first thing. Pretty intuitive, right? Well, yes, but
    it’s one of the aspects that I’ve often found to be underestimated. Sometimes
    we are so focused on achieving the end result, on delivering a product at all
    costs, that we forget about what comes after; we forget that – as already mentioned
    – code must not only speak to machines but also and above all to other programmers.
    And those other programmers are also our future selves! Doing things quickly is
    not the only reason for which code lacks readability: for instance, sometimes
    we could have performance issues to handle. Anyways, if you have other aspects
    to handle, my small piece of advice is to make sure to at least strike a balance
    between readability and those aspects.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是第一步。非常直观，对吧？嗯，是的，但这正是我经常发现被低估的一个方面。有时我们过于专注于实现最终结果，不惜一切代价交付产品，以至于忘记了接下来会发生什么；我们忘记了——正如之前提到的——代码不仅要对机器说话，而且还要首先对其他程序员说话。而那些其他程序员也是我们未来的自己！快速做事并不是代码缺乏可读性的唯一原因：例如，有时我们可能需要处理性能问题。无论如何，如果你有其他方面要处理，我的小小建议是确保至少在可读性和这些方面之间取得平衡。
- en: 'To give a definition of readable code, we don’t need to rely on the code itself.
    Plain language is enough. Just imagine for a moment that you’re at your own home
    and you need to assemble one of those beautiful, satisfying, low-budget Swedish
    furniture pieces that we have to assemble ourselves, like a wardrobe. Instead
    of the crystal-clear visual instructions that we are familiar with, we find a
    text that says the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要给出可读代码的定义，我们不需要依赖于代码本身。普通语言就足够了。想象一下，此刻你正身处自己的家中，需要组装那些美丽、令人满意、预算低廉的瑞典家具，比如衣柜。而不是我们熟悉的清晰视觉说明，我们发现一段文字如下：
- en: '*Take the white wooden piece with dimensions A x B, which we will now refer
    to as L. Take another wooden board with dimensions B x C, which we’ll call M.
    Take the tool consisting of a metal rod with a cross-shaped end. Take a screw
    that fits into the holes of both L and M; it must be not too short and not too
    long. Using the cross-shaped end of the aforementioned tool, rotate the screw
    clockwise so that they inextricably join, forming a single partial structure that
    we’ll* *call P.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*拿起尺寸为A x B的白色木块，我们现在将其称为L。再拿起一块尺寸为B x C的木板，我们将称之为M。拿起由带有十字形端头的金属棒组成的工具。拿起一个可以插入L和M孔中的螺丝；它不能太短也不能太长。使用上述工具的十字形端头，顺时针旋转螺丝，使它们不可分割地结合在一起，形成一个单一的局部结构，我们将*
    *称之为P。*'
- en: 'This text is obviously incomprehensible. I suffered a lot in writing it. Don’t
    fall into the trap of thinking that code is different from prose language. I mean,
    of course, it’s different, but in an abstract way, you should consider them as
    the same thing. Imagine, when you write code, writing in prose. You should aim
    for prose writing, in a way, so that your code is as readable as possible. When
    a piece of code is readable even by someone who knows nothing about the project
    or has basic programming skills, then you have succeeded. The excerpt from the
    previous instruction manual could be rewritten as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文字显然是无法理解的。我在写作时遇到了很多困难。不要陷入认为代码与散文语言不同的陷阱。我的意思是，当然，它们是不同的，但在抽象意义上，你应该将它们视为同一件事。想象一下，当你编写代码时，就像在写散文。你应该力求散文写作，以便你的代码尽可能易于阅读。当一段代码即使对不了解项目或只有基本编程技能的人来说也是可读的，那么你就成功了。上一份说明书中的摘录可以重写如下：
- en: '*Take the wooden board labeled “left side” and screw it together with the one
    labeled “back” using a* *Phillips screwdriver.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*拿起标有“左侧”的木板，并用* *十字螺丝刀* *将其与标有“背面”的木板一起拧紧。*'
- en: This excerpt can certainly be further improved. But the starting point is definitely
    understandable; it’s understandable to me and it’s understandable to others, and
    that’s how your code should be. Readable code is code that can be improved and
    expanded upon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段摘录当然可以进一步改进。但起点无疑是可理解的；对我来说是可理解的，对其他人来说也是可理解的，这就是你的代码应该做到的。可读的代码是可以改进和扩展的代码。
- en: Good code is reliable
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优秀的代码是可靠的
- en: 'If I have to think of a definition for “reliable,” it brings to mind a friend
    of mine who, when they say they will do something, they do it and only that. Nothing
    more, nothing less. So, think of reliable code as your friend who always agrees
    to help you in the best possible way—no surprises, as Radiohead used to sing.
    I could give you an example of unreliable code not so far from certain things
    I have encountered in the past. For instance, imagine you have an entity in your
    domain represented like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我必须为“可靠”这个词下定义，它让我想起了我的一个朋友，当他们说他们会做某事时，他们会做到，而且只有那件事。不多也不少。所以，将可靠的代码想象成你的朋友，他总是以最好的方式同意帮助你——没有惊喜，就像Radiohead曾经唱的那样。我可以给你一个例子，这个不可靠的代码并不遥远，它是我过去遇到的一些事情。例如，想象你有一个在域中代表如下所示的实体：
- en: '![Table 2.1 – Example entity](img/B20912_02_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![表2.1 – 示例实体](img/B20912_02_1.jpg)'
- en: Table 2.1 – Example entity
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – 示例实体
- en: Both `id` and `taxCode` are of type String and are unique within the domain.
    That means there cannot be two students with the same `id` or the same `taxCode`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`和`taxCode`都是String类型，在域内是唯一的。这意味着不能有两个学生的`id`或`taxCode`相同。'
- en: 'I also have an exposed method from the `Student` interface that is written
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我还有一个从`Student`接口公开的方法，其编写方式如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Apparently, this signature of this method is correct, because it does not expose
    the internal structure of the object. But, it could also have been named `getId()`
    or `getTaxCode()` and that is *exactly* the point. Without looking at the implementation,
    we don’t know if we will get `taxCode` or `id` when using it. When we actually
    use `getUniqueIdentifier()`, we realize that the behavior is variable and depends
    on the specific implementation. If we were to use this method within a payment
    and invoicing system where we specifically need `taxCode`, this method would be
    unreliable. One possible solution could be to expose two separate getter methods
    so that we know exactly which information we are reading at that moment. Alternatively,
    another solution could be to expose an additional method called `getTaxIdentifier()`
    that specifically returns `taxCode`. This way, you would have separate methods
    providing clear and unambiguous access to each piece of information without exposing
    the internal structure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法的特征是正确的，因为它没有暴露对象的内部结构。但是，它也可以被命名为`getId()`或`getTaxCode()`，这正是关键所在。在不查看实现的情况下，我们不知道在使用它时会得到`taxCode`还是`id`。当我们实际使用`getUniqueIdentifier()`时，我们会意识到其行为是可变的，并取决于具体的实现。如果我们要在需要特定`taxCode`的支付和发票系统中使用此方法，那么这个方法将是不可靠的。一个可能的解决方案是公开两个单独的getter方法，这样我们就可以确切地知道在那个时刻我们正在读取哪些信息。或者，另一个解决方案是公开一个名为`getTaxIdentifier()`的额外方法，它专门返回`taxCode`。这样，你将拥有提供清晰且明确访问每条信息的单独方法，而不暴露内部结构。
- en: Good code is hard to misuse
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好的代码不容易被误用
- en: To easily explain the concept of code that cannot be misused, all I have to
    do is take a look inside my children’s room. There are toys, sometimes referred
    to as “Montessori toys,” that involve small wooden objects being inserted into
    a box with corresponding holes of the right shape for each object. As can be seen
    from *Figure 2**.1*, it is impossible to fit a cylinder into a square, a cube
    into a circle, and so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松解释不可误用的代码的概念，我只需看看我孩子的房间。那里有玩具，有时被称为“蒙台梭利玩具”，涉及将小木块插入一个带有对应正确形状孔的盒子中。如*图2**.1所示，不可能将圆柱体放入正方形中，将立方体放入圆中，等等。
- en: '![Figure 2.1 – An example of a Montessori toy](img/B20912_02_2.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 蒙台梭利玩具的示例](img/B20912_02_2.jpg)'
- en: Figure 2.1 – An example of a Montessori toy
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 蒙台梭利玩具的示例
- en: The usage is intuitive and provides immediate feedback.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法直观，并提供即时反馈。
- en: 'We need to envision writing the code and designing the components in this way:
    we expect our code to perform certain actions, which may have impacts on external
    systems or a database. Misusable code could potentially cause significant problems—for
    instance, it could write incorrect information to a database—or it could simply
    fail to function properly. When providing our services, which include our code,
    libraries, and design, we must put ourselves in the shoes of those who will integrate
    or utilize them.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设想以这种方式编写代码和设计组件：我们期望我们的代码执行某些操作，这些操作可能对外部系统或数据库产生影响。不可用的代码可能会引起重大问题——例如，它可能将错误信息写入数据库——或者它可能简单地无法正常工作。当我们提供包括我们的代码、库和设计在内的服务时，我们必须设身处地地考虑那些将集成或使用它们的人。
- en: There are several techniques to make your code non-misusable, and it would take
    – and indeed there are – entire books on the subject. However, I want to give
    you a couple of ideas here that can be easily applied even without delving too
    deep.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种技术可以使你的代码不易误用，而且确实有关于这个主题的整本书。然而，我想在这里给你提供一些建议，即使不深入研究也能轻松应用。
- en: Don’t be overly generic
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要过于通用
- en: 'One “trick” to make your code non-misusable is to avoid overly generic data
    types whenever possible. Types like Integer, String, List, and so on, serve as
    the building blocks for constructing our programs and are very versatile. However,
    the flip side is that they can sometimes be too generic. Let me give you a couple
    of examples from my own experience: in a company operating in the travel industry,
    we deal with a service that returns all available flights based on a user’s search.
    As we need to represent the number of adults, children, and infants for whom a
    solution is being sought, we chose the following solution (for simplicity, let’s
    omit the handling of null values, possible initializations with default values,
    etc.):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的代码不易误用的一种“技巧”是尽可能避免过于通用的数据类型。像Integer、String、List等类型是我们构建程序的基础，并且非常灵活。然而，另一方面，它们有时可能过于通用。让我给你举几个我自己的经验例子：在一个运营在旅游行业的公司中，我们处理一个根据用户搜索返回所有可用航班的业务。由于我们需要表示正在寻求解决方案的成人、儿童和婴儿的数量，我们选择了以下解决方案（为了简单起见，让我们省略对null值的处理、可能的默认值初始化等）：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, for example, if we are searching for a flight for 2 adults, 1 child, and
    1 infant, the convention would be to populate `passengers` as an array: `[2, 1,
    1]`. In my opinion, this choice is very risky. We could insert fewer values than
    necessary, for example, just one or two. We could insert more values. We could
    even omit them entirely. Yes, we could introduce some input validation, but why
    allow input and then return an error later? If this were a library, by the way,
    I would be forced to read the documentation to understand how to populate that
    field (there’s nothing wrong with reading documentation, of course, but it should
    be something that could be more intuitive). It would be more intuitive instead
    to divide the information into a more meaningful structure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果我们正在为2位成人、1名儿童和1名婴儿搜索航班，惯例是将`passengers`作为一个数组进行填充：`[2, 1, 1]`。在我看来，这个选择非常冒险。我们可能会插入比必需的更少的值，例如，只有一个或两个。我们也可以插入更多的值。甚至可以完全省略它们。是的，我们可以引入一些输入验证，但为什么允许输入然后在之后返回错误呢？顺便说一句，如果这是一个库，我就不得不阅读文档来了解如何填充该字段（当然，阅读文档没有错，但它应该是更直观的东西）。相反，将信息划分为更有意义的结构会更为直观：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Much clearer, isn’t it?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更清晰，不是吗？
- en: 'We could, in fact, go further and create an ad-hoc structure for our needs,
    something that cannot lead to confusion. Something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以更进一步，为我们的需求创建一个专门的架构，这种架构不会导致混淆。就像这样：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And that would lead to having a single, understandable field:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致拥有一个单一、可理解的字段：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Use standards for writing good code
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标准编写良好的代码
- en: 'Another way to make your code non-misusable is to use standards whenever possible.
    A couple of examples come to mind, related to handling time. If you need to represent
    a date, choose a format, document that you are using it, and consistently use
    it throughout your project. One thing I’ve seen done very often is trying to represent
    a time period or duration with an Integer or even a String:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的代码不易误用的另一种方法是尽可能使用标准。我想到了几个与处理时间相关的例子。如果你需要表示一个日期，选择一个格式，记录你正在使用它，并在整个项目中一致地使用它。我经常看到的事情之一是尝试用Integer或甚至String来表示时间段或持续时间：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Starting from `Duration` class, and I highly recommend using it. It is incredibly
    versatile and allows you to represent a duration of time unambiguously:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Duration`类开始，我强烈推荐使用它。它极其灵活，允许你明确地表示时间的长度：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Additional cool thing: the preceding duration serializes according to a convenient
    ISO standard (ISO-8601), such as `PT2H30M`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 额外酷的功能：前面的持续时间按照方便的ISO标准（ISO-8601）进行序列化，例如`PT2H30M`。
- en: 'The thing here is simple: don’t reinvent the wheel! After all, Java is so widespread
    also because there are a multitude of libraries available, so I suggest, while
    we are solving common problems, to avoid recreating basic components and instead
    rely on language features or open source libraries. One of the first things that
    I always ask myself is: am I the first one having this issue? The answer is rarely
    yes.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的事情很简单：不要重新发明轮子！毕竟，Java之所以如此普及，也是因为有许多可用的库，所以我建议，当我们解决常见问题时，避免重新创建基本组件，而是依赖语言特性或开源库。我总是问自己的第一件事是：我是第一个遇到这个问题的人吗？答案很少是肯定的。
- en: Use single sources of truth for data and logic
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用单一的数据来源和单一的逻辑来源
- en: 'Last piece of advice: use a single source of truth for data and a single source
    of truth for logic. I must admit that the concepts of a single source of truth
    are often straightforward to explain but less easy to implement.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条建议：使用单一的数据来源和单一的逻辑来源。我必须承认，单一来源的概念通常很容易解释，但实施起来可能不那么容易。
- en: 'Let me try to illustrate what I have in mind with an example. Once again, let’s
    imagine managing a flight search system. Typically, the data can be divided into
    primary data and derived data. Primary data is essentially the information without
    which our system couldn’t function, while derived data refers to all the other
    information. In our flight search example, let’s say we need to provide, among
    other details, the duration of a trip from Milan to San Francisco. The trip consists
    of two flights: one from Milan to Copenhagen and another from Copenhagen to San
    Francisco. In this example, we can consider the departure and arrival times of
    each individual flight as primary data. From these, we can derive information
    about the duration of the trip and potentially the duration of the layover. Managing
    derived data as primary data, for example by storing it in the database, could
    lead to inconsistencies. Especially when deriving information from a large volume
    of data – or when the derivation is complex or involves some external system –
    the computational cost of such calculations could be high. I would advise you
    to exercise caution and consider implementing a mechanism called **lazy calculation**.
    Essentially, this approach involves calculating the derived data only when it
    is needed, rather than in advance, and saving it in a cache so that it is readily
    available for future use. In our flight duration example, we would calculate the
    journey duration using the flight’s departure and arrival times (we have also
    to consider the airport locations and their time zones) without storing it in
    a database, but at most in a short-term cache or something like that. If we stored
    it in a database, in fact, we would have to recalculate it every time the flight
    departure/arrival times change (in industry jargon, every time there is a “schedule
    change”) or we might get inconsistencies.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我尝试用一个例子来说明我心中的想法。再次想象一下管理一个航班搜索系统。通常，数据可以分为原始数据和派生数据。原始数据基本上是系统无法运行的信息，而派生数据则指的是所有其他信息。在我们的航班搜索示例中，假设我们需要提供其他细节之外的信息，比如从米兰到旧金山的旅行时长。这次旅行包括两段航班：一段从米兰到哥本哈根，另一段从哥本哈根到旧金山。在这个例子中，我们可以将每个单独航班的出发和到达时间视为原始数据。从这些数据中，我们可以推导出旅行的时长以及可能的转机时长。将派生数据作为原始数据管理，例如通过将其存储在数据库中，可能会导致不一致性。尤其是在从大量数据中派生信息——或者当派生过程复杂或涉及某些外部系统时——这种计算的计算成本可能会很高。我建议您谨慎行事，并考虑实施一种称为**延迟计算**的机制。本质上，这种方法涉及仅在需要时计算派生数据，而不是提前计算，并将其保存在缓存中，以便将来可以快速使用。在我们的航班时长示例中，我们会使用航班的出发和到达时间（我们还需要考虑机场位置及其时区）来计算旅行时长，但不会将其存储在数据库中，而最多只存储在短期缓存或类似的东西中。如果我们将其存储在数据库中，实际上，每次航班出发/到达时间改变（在行业术语中，每次有“时间表变更”）时，我们都必须重新计算它，或者我们可能会得到不一致的结果。
- en: Just as having a single source of truth is a good practice, having a single
    source of logic is also beneficial. In the aforementioned case, for instance,
    we need to calculate the duration of a flight from Milan to San Francisco. While
    it may not be rocket science, it is not a trivial calculation either, as it involves
    different time zones and the so-called daylight saving time. It is one of those
    things that is easy to underestimate and can, more easily than you might think,
    lead to bugs in production (and there are many flight search websites that have
    this bug in production at the moment I’m writing). In this case, it is very helpful
    to write the function once, thoroughly test it, and then consistently use it throughout
    our code base. This way, we do not stray far from the good old principle of **Don’t
    Repeat Yourself** (**DRY**). In this case, you could write a library, a service,
    or just a class in your project that deals with the journey duration and use it
    every time you need it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如拥有单一真相来源是一种良好的实践一样，拥有单一逻辑来源也有益。在上面的例子中，例如，我们需要计算从米兰到旧金山的航班时长。虽然这也许不是火箭科学，但也不是一个简单的计算，因为它涉及到不同的时区和所谓的夏令时。这是那些容易被低估的事情之一，而且比你想象的更容易导致生产中的错误（在我写作的时候，有许多航班搜索网站在生产中存在这个错误）。在这种情况下，编写一次函数、彻底测试它，并在整个代码库中一致地使用它是非常有帮助的。这样，我们就不会偏离“不要重复自己”的古老原则（**DRY**）。在这种情况下，你可以在项目中编写一个库、一个服务或只是一个类来处理行程时长，并在需要时使用它。
- en: Good code is modular
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优秀的代码是模块化的
- en: In general, modularity refers to the concept of dividing a system or complex
    entity into smaller, independent components or modules. It is a principle that
    can be applied beyond software and is used in various fields and disciplines.
    Let’s consider a shelving unit consisting of individual modules that can be easily
    assembled and disassembled.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模块化指的是将系统或复杂实体划分为更小、独立的组件或模块的概念。这是一个可以应用于软件之外的原理，并在各个领域和学科中得到应用。让我们考虑一个由单个模块组成的货架单元，这些模块可以轻松组装和拆卸。
- en: '![Figure 2.2 – This kind of furniture is composed of a set of identical and
    reusable modules](img/B20912_02_3.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 这种家具由一套相同且可重复使用的模块组成](img/B20912_02_3.jpg)'
- en: Figure 2.2 – This kind of furniture is composed of a set of identical and reusable
    modules
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 这种家具由一套相同且可重复使用的模块组成
- en: Each module serves as a building block, and you can arrange them in various
    configurations to create different shelving arrangements based on your needs.
    This modular approach allows for flexibility in adapting the furniture to different
    spaces and changing requirements. For example, as seen in *Figure 2**.2*, it is
    possible to use the same type of brackets vertically, adapting them to shelves
    of different lengths.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都作为一个构建块，您可以根据需要以不同的配置排列它们，以创建不同的货架布局。这种模块化方法允许家具适应不同的空间和不断变化的需求。例如，如图**图2.2**所示，可以使用相同类型的夹具垂直排列，以适应不同长度的货架。
- en: The components that make up this shelf are easy to use, meaning they have clear
    interfaces and few points of interaction. If you put yourselves in the shoes of
    both the designer of this shelf and the person who has to assemble and maintain
    it, you understand that modularity is essential. If there were a different way
    to assemble each shelf or bracket, or if there were different brackets for different
    shelves, the management would be much more complex and prone to errors. We’ll
    say something more about modularity in the text sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构成这个货架的组件易于使用，这意味着它们具有清晰的接口和很少的交互点。如果你站在这个货架的设计者和必须组装和维护它的人的角度，你就会明白模块化是至关重要的。如果组装每个货架或夹具的方式不同，或者如果不同货架有不同的夹具，管理就会变得复杂得多，更容易出错。我们将在文本部分中更多地讨论模块化。
- en: Dependency injection
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Classes often need to use other classes. In well-organized code, we often solve
    each of these smaller problems with a separate class. However, there isn’t always
    just one way to solve a problem, so it can be helpful to structure our code in
    a way that allows us to change how we solve these smaller problems. That’s where
    dependency injection comes in handy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类通常需要使用其他类。在组织良好的代码中，我们通常用单独的类来解决这些较小的问题。然而，解决问题并不总是只有一种方法，因此以允许我们更改解决这些较小问题的方法来结构化我们的代码可能是有帮助的。这就是依赖注入发挥作用的地方。
- en: 'I could give you a quick example relating to our example flight search system.
    Let’s suppose we have `FlightSearcher` which returns, given an itinerary and a
    description of the people involved, some possible travel plans around Europe and
    their relative prices. Of course, we are a profitable company so we want to surcharge
    the original price to get some earnings out of it. A crucial part of the response
    will be the price given to the customer, calculated through a component called
    `FlightPricer`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以给你一个与我们的示例航班搜索系统相关的快速示例。假设我们有一个 `FlightSearcher`，它根据行程和参与人员的描述，返回一些可能的欧洲旅行计划和它们的相关价格。当然，我们是一家盈利公司，所以我们想对原始价格进行加价以从中获利。响应的关键部分将是客户获得的价格，通过一个名为
    `FlightPricer` 的组件来计算：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is clear to see that the `FlightSearcher` components depend on `EuroFlightPricer`.
    As easily inferred from the name of the `EuroFlightPricer` component, it handles
    and returns prices in euros. Without blaming the hard-working development team
    that was under pressure to deliver this feature as quickly as possible to ensure
    the company’s commercial success, it is clear that hardcoding this dependency
    is not a wise long-term choice. Certainly, ensuring simplicity and readability
    of the code is guaranteed (for example, there is no need to provide any parameters
    for the constructor). However, if we were to use another currency or any other
    logic for calculations in the future, we would need to modify the existing code.
    The solution is to inject the dependency from the outside:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`FlightSearcher` 组件依赖于 `EuroFlightPricer`。从 `EuroFlightPricer` 组件的名称中可以轻易推断出，它处理并返回欧元价格。尽管没有责怪那个在压力下尽可能快地交付此功能以确保公司商业成功的辛勤工作的开发团队，但很明显，硬编码这个依赖并不是一个明智的长期选择。当然，确保代码的简洁性和可读性是有保障的（例如，不需要为构造函数提供任何参数）。然而，如果我们未来要使用另一种货币或任何其他计算逻辑，我们就需要修改现有的代码。解决方案是从外部注入依赖：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is crucial to note that `FlightSearcher` now depends on an interface. We
    will use, in fact, a specific implementation of the `FlightPricer` interface intended
    just to handle the euro currency:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`FlightSearcher` 现在依赖于一个接口。实际上，我们将使用 `FlightPricer` 接口的一个特定实现，这个实现专门用于处理欧元货币：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With dependency injection, we can easily reconfigure the `FlightSearcher` class.
    This is possible because all the different pricer classes implement the same `FlightPricer`
    interface, allowing the `FlightSearcher` class to depend on it. This means we
    can use any implementation of `FlightPricer`, making the code more flexible and
    adaptable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖注入，我们可以轻松地重新配置 `FlightSearcher` 类。这是因为所有不同的定价类都实现了相同的 `FlightPricer` 接口，使得
    `FlightSearcher` 类可以依赖于它。这意味着我们可以使用任何 `FlightPricer` 的实现，使代码更加灵活和适应性强。
- en: 'This leads to a general technique for making code more modular and adaptable:
    if we depend on a class that implements an interface with the needed functionality,
    it’s usually better to depend on the interface itself instead of the specific
    class.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一种使代码更加模块化和适应性的通用技术：如果我们依赖于实现所需功能接口的类，通常最好是依赖于接口本身而不是具体的类。
- en: Law of Demeter
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迪米特法则
- en: 'The **Law of Demeter**, also known as the principle of least knowledge and
    sometimes abbreviated as **LoD**, is a software design guideline that promotes
    loose coupling and encapsulation. According to this principle, an object should
    have limited knowledge about other objects and should only interact with its immediate
    neighbors. Let’s see some applications of this principle:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**迪米特法则**，也称为最小知识原则，有时简称为 **LoD**，是一种软件设计指南，它促进了松散耦合和封装。根据这个原则，一个对象应该对其他对象有有限的知识，并且只应与其直接邻居交互。让我们看看这个原则的一些应用：'
- en: '**Avoid chaining method calls excessively**: Instead of accessing methods of
    multiple objects in a single chain, limit the number of method invocations to
    maintain loose coupling:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免过度链式调用方法**：不要在单个链中访问多个对象的方法，限制方法调用的数量以保持松散耦合：'
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While this code works, it could be problematic for several reasons. Firstly,
    it assumes that each method call will successfully return a non-null object, otherwise,
    it may encounter a `NullPointerException`. Additionally, it tightly couples the
    code to the specific structure of the object hierarchy. If the structure changes
    in the future, this code will need to be modified accordingly.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然这段代码可以工作，但它有几个潜在问题。首先，它假设每个方法调用都将成功返回一个非空对象，否则，它可能会遇到`NullPointerException`。此外，它将代码紧密耦合到对象层次结构的特定结构。如果结构在未来发生变化，这段代码将需要相应地进行修改。
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this version, the nested object hierarchy is traversed step by step, and
    each intermediate object is stored in a separate variable. This approach allows
    for better readability, improved error handling (it would be possible to check
    for null values), and flexibility in case the structure of the object hierarchy
    changes.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个版本中，嵌套对象层次结构是逐步遍历的，每个中间对象都存储在一个单独的变量中。这种方法提高了可读性，改进了错误处理（可以检查空值），并且在对象层次结构结构发生变化时提供了灵活性。
- en: '**Don’t expose the internals of an object by returning references to internal
    objects**: Instead, provide high-level methods that encapsulate the required functionality.
    For example, let’s suppose we must retrieve all the books from a warehouse that
    stores several types of goods:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要通过返回内部对象的引用来暴露对象的内部结构**：相反，提供封装所需功能的高级方法。例如，假设我们必须从存储多种商品的仓库中检索所有书籍：'
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code is technically OK, but the caller is forced to retrieve all the items
    and then filter to keep only the books. This is unpleasant for several reasons:
    we query the `Warehouse` for all of the items, but we only need books; the caller
    must increase its complexity to filter the items; we must expose the internal
    structure of `Item` to let the client get the `Type` of the `Item` itself, so
    that it can apply filtering. We’re producing, above all else, strong couplings.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码在技术上是可以的，但调用者被迫检索所有项目，然后过滤以保留书籍。这有几个不愉快的原因：我们查询`Warehouse`以获取所有项目，但我们只需要书籍；调用者必须增加其复杂性以过滤项目；我们必须暴露`Item`的内部结构，以便客户端获取`Item`本身的`Type`，以便它可以应用过滤。我们首先产生的是强耦合。
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this way, we don’t let the client do all the filtering and we only enquire
    in the warehouse for books. We are not forced to expose the type of the `Item`,
    because the client just asked for a given category. We should optimize even more
    this code, for example returning a `Book` class instead of `Item`, but the purpose
    was just to provide an example for the internal structure exposure, so we’ll stop
    here for now.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做，我们不让客户端进行所有过滤，我们只查询仓库中的书籍。我们不必暴露`Item`的类型，因为客户端只是请求一个特定的类别。我们应该进一步优化这段代码，例如返回`Book`类而不是`Item`，但目的只是为了提供一个内部结构暴露的示例，所以现在我们先到这里。
- en: '**Avoid passing objects further than necessary as method arguments**: If an
    object requires access to another object, provide only the necessary information
    or dependencies:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免传递不必要的对象作为方法参数**：如果一个对象需要访问另一个对象，只提供必要的信息或依赖项：'
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, the `shipOrder` method receives all of the order, while it needs
    only the `items` of the order itself. It would be better to change the `shipOrder`
    signature so that it takes only them.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这段代码中，`shipOrder`方法接收了整个订单，而它只需要订单本身的`items`。最好改变`shipOrder`的签名，使其只接受它们。
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we provide to `shipOrder` only the necessary information.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们只向`shipOrder`提供必要的信息。
- en: It can’t be said that the entire developer community fully agrees with the Law
    of Demeter (refer to the Further reading section), so much so that some think
    it should be called the *suggestion* of Demeter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不能说整个开发者社区完全同意迪米特法则（请参阅进一步阅读部分），以至于有些人认为它应该被称为*迪米特的建议*。
- en: Data cohesion (make related data work together)
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据内聚（使相关数据协同工作）
- en: Classes help us organize things, but it can become problematic if we group too
    many things together in a single class. We should be careful about this, but at
    the same time, we shouldn’t forget the benefits of grouping things together when
    it makes sense.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类帮助我们组织事物，但如果我们在一个类中组合太多事物，可能会出现问题。我们应该对此保持警惕，同时，我们也不应该忘记当有道理时将事物组合在一起的好处。
- en: Sometimes, certain pieces of data are naturally related to each other, and our
    code needs to handle them together. In such cases, it makes sense to group them
    into a class or a similar structure. By doing this, our code can focus on the
    overall concept that the group of items represents, rather than dealing with specific
    details all the time. This approach promotes modularity in our code and allows
    changes in requirements to be isolated more easily.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，某些数据自然地相互关联，我们的代码需要一起处理它们。在这种情况下，将它们组合成一个类或类似的结构是有意义的。通过这样做，我们的代码可以专注于代表该组项目的整体概念，而不是总是处理具体细节。这种方法促进了我们代码的模块化，并允许更容易地将需求的变化隔离开来。
- en: An example of related data grouping is the combination of price and currency.
    In many applications, when dealing with financial transactions or monetary values,
    it is essential to consider both the price amount and the currency in which it
    is expressed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相关数据分组的一个例子是价格和货币的组合。在许多应用中，处理金融交易或货币值时，考虑价格金额及其表示的货币是至关重要的。
- en: By grouping the price and currency together into a class or a data structure,
    we can conveniently handle these related pieces of information as a single unit.
    This allows us to perform calculations, conversions, and other operations on the
    price while ensuring that the corresponding currency is correctly accounted for.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将价格和货币组合成一个类或数据结构，我们可以方便地将这些相关的信息作为一个单一单元来处理。这允许我们在对价格进行计算、转换和其他操作的同时，确保相应的货币被正确地考虑在内。
- en: For instance, we can create a `Price` class that encapsulates the price value
    and the currency code. This class would provide methods to perform arithmetic
    operations and currency conversions and enforce consistency between the price
    and currency (and thus, the logic would all be in one place, behaving as a single
    source of truth).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个`Price`类，它封装了价格值和货币代码。这个类将提供执行算术运算和货币转换的方法，并确保价格和货币（因此，逻辑都在一个地方，作为一个单一的真实来源）之间的一致性。
- en: 'Another example of related data grouping could involve latitude and longitude
    coordinates. When working with location-based applications or mapping systems,
    latitude and longitude values are often used together to specify a specific point
    on the Earth’s surface. By grouping latitude and longitude into a class or a data
    structure (simply put: `Point`) and encapsulating the latitude and longitude values,
    we can conveniently handle and manipulate geographic coordinates as a cohesive
    unit. And again, we could perform various operations such as distance calculations,
    mapping functionalities, or finding nearby locations (actually, many libraries
    that deal with geographical calculation do exactly this).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关数据分组示例可能涉及经纬度坐标。当处理基于位置的应用或地图系统时，经纬度值通常一起使用来指定地球表面上的一个特定点。通过将经纬度组合成一个类或数据结构（简单来说：`Point`）并封装经纬度值，我们可以方便地处理和操作地理坐标作为一个统一的单元。再次强调，我们可以执行各种操作，如距离计算、地图功能或查找附近的地点（实际上，许多处理地理计算的库正是这样做）。
- en: Don’t leak implementation details in the return type
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在返回类型中泄露实现细节
- en: In order to keep things organized and easy to work with, it’s important to make
    sure that each layer of abstraction is clean and doesn’t reveal how things are
    implemented under the hood. When implementation details are leaked, it can expose
    information about lower layers in the code and make it really tough to make changes
    or customize things later on. One common way this happens is when the code returns
    a type that’s tightly connected to those specific details.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持事物的组织性和便于操作，确保每一层抽象都是干净整洁的，并且不透露事物在底层是如何实现的，这一点非常重要。当实现细节泄露时，可能会暴露代码中较低层的某些信息，使得后续的修改或定制变得非常困难。这种情况通常发生在代码返回一个与特定细节紧密相连的类型时。
- en: 'In our hypothetical flight search system, let’s consider the scenario where
    we depend on external suppliers through traditional web service calls. Due to
    legal requirements, we are obligated to retain all the requests and responses
    for a specific duration. To address this, we have implemented a service within
    our code base that handles the storage of these records. We use a cloud storage
    system, referred to as SkyVault, for this purpose:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的假设飞行搜索系统中，让我们考虑这样一个场景，即我们通过传统的Web服务调用依赖外部供应商。由于法律要求，我们被迫保留所有请求和响应一段时间。为了解决这个问题，我们在代码库中实现了一个服务来处理这些记录的存储。我们使用一个称为SkyVault的云存储系统来完成这项任务：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, the class spills the beans about using `SkyVault` as our storage
    service, and it binds the client to this choice. This makes it super hard to change
    things if we ever want to switch to a different storage service, use a database,
    or go for any other type of data storage. Changing the code would be very difficult.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该类泄露了使用`SkyVault`作为我们的存储服务的信息，并且将客户端绑定到这个选择上。这使得如果我们想切换到不同的存储服务、使用数据库或选择任何其他类型的数据存储时，要改变事情变得极其困难。改变代码将会非常困难。
- en: 'One solution to this problem could be to abstract the response in a very trivial
    way:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一可能是以非常简单的方式抽象化响应：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Besides the return type, there are cases where the implementation is overly
    visible, creating a tight connection between library or service users and the
    service itself. For example, the implementation complexities of external systems
    are exposed instead of being simplified and pushed up to the caller level:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回类型之外，还有情况是实现过于明显，在库或服务用户和服务本身之间创建了一个紧密的联系。例如，外部系统的实现复杂性被暴露出来，而不是被简化并推到调用者级别：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, the client needs to first check if the payload `exists` before
    calling the `upload` method. If it does exist, they have to use the `overWrite`
    method instead. This extra step adds unnecessary complexity for the client. It
    would have been better if this complexity was handled internally within the method
    itself (unless, of course, overwriting an existing file is somehow important to
    our specific situation).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端需要首先检查负载`是否存在`，然后再调用`upload`方法。如果它存在，他们必须使用`overWrite`方法。这个额外的步骤给客户端增加了不必要的复杂性。如果这个复杂性在方法内部本身处理会更好（除非，当然，覆盖现有文件以某种方式对我们特定的情境很重要）。
- en: Good code is reusable
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优秀的代码是可重用的
- en: As engineers, we often solve big problems by breaking them down into smaller
    ones (the good old *divide et impera*). And guess what? We keep running into the
    same small problems over and over again across different projects. So, if we or
    other engineers have already figured out a solution to one of these recurring
    problems, it just makes sense to reuse it. It saves us time and reduces the chances
    of introducing bugs because we know the solution has already been tried and tested.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为工程师，我们经常通过将大问题分解为小问题（古老的*分割与征服*）来解决大问题。而且你知道吗？我们在不同的项目中一次又一次地遇到相同的小问题。所以，如果我们或其他工程师已经找到了这些重复出现的问题之一的解决方案，那么重用它是很有道理的。这节省了我们的时间，并减少了引入错误的机会，因为我们知道这个解决方案已经被尝试和测试过。
- en: 'The concept of reusability is closely tied to two key practices: establishing
    clear layers of abstraction and developing modular code. By implementing clean
    layers of abstraction and modularizing our code, we naturally break down solutions
    to subproblems into separate code components that are loosely interconnected.
    This approach significantly enhances the ease and safety of code reuse and generalization.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用性的概念与两个关键实践紧密相关：建立清晰的抽象层和开发模块化代码。通过实现干净的抽象层和模块化我们的代码，我们自然地将解决方案分解为单独的代码组件，这些组件松散地相互连接。这种方法显著提高了代码重用和泛化的便捷性和安全性。
- en: Don’t make assumptions while writing your code
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写代码时不要做假设
- en: Don't make assumptions is a good piece of advice for life in general – but I
    don’t want to be your life coach here, so don’t worry.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不要做假设是一般生活中很好的建议——但我不想在这里成为你的生活导师，所以不用担心。
- en: There is no specific definition for an assumption, but I can provide you with
    a recent example I encountered. Imagine you are responsible for managing an e-commerce
    system and need to maintain records of purchases. Each purchase is characterized
    by a set of properties, and each purchase has a unique identifier called the **ID**.
    It is important to note that this ID is a numeric value that increases sequentially.
    For instance, if a purchase has ID *x*, the subsequent purchase will be identified
    as *x+1*, and so on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于假设，并没有一个具体的定义，但我可以给你提供一个我最近遇到的一个例子。想象一下，你负责管理一个电子商务系统，并需要维护购买记录。每一次购买都由一组属性来定义，并且每一次购买都有一个唯一的标识符，称为**ID**。需要注意的是，这个ID是一个按顺序递增的数值。例如，如果一个购买有ID
    *x*，那么随后的购买将被标识为*x+1*，依此类推。
- en: Alongside the purchase management system, there is a typical component found
    in most companies called a reporting system (in my mind, I can hear a horse neighing,
    as in the movie *Frankenstein Junior*). This reporting system relies on determining
    the relative recency of purchases. The logical basis for this comparison is typically
    a date field such as `created_on` or a similar attribute. However, the reporting
    system in this case makes the assumption that the ordering of purchases is solely
    dependent on the `id` field. It assumes that the lower the ID, the more recent
    the purchase.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了购买管理系统之外，大多数公司都有一个典型的组件，称为报告系统（在我的想象中，我可以听到一匹马嘶鸣，就像电影《弗兰肯斯坦之子》中一样）。这个报告系统依赖于确定购买的相对时间。这种比较的逻辑基础通常是日期字段，如`created_on`或类似的属性。然而，在这个案例中，报告系统假设购买的顺序完全依赖于`id`字段。它假设ID越低，购买越新。
- en: Now, let’s consider a scenario where the maintainers of the purchase management
    system needed to migrate data. It became convenient for them to change the ID
    generation process to use random alphanumeric strings instead of numeric increments.
    Consequently, the reporting system, which had assumed that the IDs were numerical
    and sequentially incremental, ceased to function correctly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个场景，即购买管理系统的维护者需要迁移数据。对他们来说，改变ID生成过程，使用随机字母数字字符串而不是数值递增变得方便。因此，假设ID是数值和顺序递增的报告系统不再正确运行。
- en: 'Assumptions can lead to bugs when code is reused because the reused code may
    rely on certain conditions or behaviors that are not met or consistent in the
    new context. These bugs may kick in many different ways, including the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码被重用时，假设可能导致错误，因为重用的代码可能依赖于某些在新环境中未满足或不一致的条件或行为。这些错误可能会以许多不同的方式触发，包括以下几种：
- en: '**Contextual differences**: When code is reused in a different context or environment,
    the assumptions made during the original implementation may not hold true anymore.
    The underlying dependencies, data structures, or system configurations might be
    different, causing the code to behave unexpectedly or produce incorrect results.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境差异**：当代码在不同的环境或环境中被重用时，原始实现中做出的假设可能不再成立。底层依赖、数据结构或系统配置可能不同，导致代码行为异常或产生错误的结果。'
- en: '**Implicit dependencies**: Reused code may have implicit dependencies on external
    factors, such as specific data formats, database schemas, or API responses. If
    these dependencies are not properly understood or communicated, using the code
    in a different context can result in compatibility issues and unexpected failures.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式依赖**：重用的代码可能对外部因素有隐式依赖，例如特定的数据格式、数据库模式或API响应。如果这些依赖没有得到适当的理解或沟通，将代码用于不同的环境可能会导致兼容性问题和不预期的故障。'
- en: '**Assumed constraints**: The reused code might make assumptions about the limitations
    or constraints of the original system. These assumptions could include factors
    like data size, frequency of operations, or expected usage patterns. If these
    constraints are exceeded or not satisfied in the new context, the reused code
    may not handle the situations correctly, leading to bugs or system failures.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假设的约束**：重用的代码可能会对原始系统的限制或约束做出假设。这些假设可能包括数据大小、操作频率或预期使用模式等因素。如果这些约束在新环境中被超出或未满足，重用的代码可能无法正确处理这些情况，从而导致错误或系统故障。'
- en: '**Compatibility issues**: Code reuse often involves integrating different components
    or libraries. If the reused code relies on specific versions or configurations
    of these components, it may not work as intended when used with different versions
    or alternative implementations. Incompatible interactions between reused code
    and other components can introduce bugs or cause system instability.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性问题**：代码重用通常涉及集成不同的组件或库。如果重用的代码依赖于这些组件的特定版本或配置，那么在使用不同版本或替代实现时，可能无法按预期工作。重用代码与其他组件之间的不兼容交互可能会引入错误或导致系统不稳定。'
- en: '**Limited validation**: Assumptions may not have been thoroughly validated
    during the original implementation. When code is reused, there is a risk that
    the assumptions were only valid in the original use case but not in other scenarios.
    Insufficient validation of assumptions can result in bugs that arise when the
    code is reused in a different context.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的验证**：假设在原始实现中可能没有得到充分的验证。当代码被重用时，存在风险，即这些假设仅在原始用例中有效，但在其他场景中可能不适用。假设验证不足可能导致在代码在不同上下文中重用时出现错误。'
- en: If you make assumptions, identify them clearly
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果你做出假设，请明确识别它们
- en: 'I am a man who lives by his own contradictions, and so now I tell you: making
    assumptions is crucial! The important thing is to do it at the right time, in
    the right amount, and for the right things. For example, when we find ourselves
    working on a completely unfamiliar code base, it is vital to make assumptions;
    otherwise, we would be navigating through every single class, every single line,
    searching for answers to our countless questions. Another example is debugging:
    when it comes to fixing bugs, start by making lots of assumptions, especially
    if you’re familiar with the code. Trust your gut feeling. Most of the time, when
    someone starts explaining the problem to you, you will already know where the
    bug is hiding. Also, when creating new code, assumptions can be crucial in order
    to build quickly and effectively. Otherwise, we may end up stuck trying to create
    code to handle every possible use case, even the ones that are not going to happen.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个生活在自己矛盾中的人，所以现在我要告诉你：做出假设是至关重要的！重要的是要适时、适量、适当地做出假设。例如，当我们发现自己正在处理一个完全陌生的代码库时，做出假设是至关重要的；否则，我们将在每个类、每一行代码中寻找答案，以解决我们无数的疑问。另一个例子是调试：在修复错误时，首先要做出大量假设，尤其是如果你熟悉代码。相信你的直觉。大多数时候，当有人开始向你解释问题时，你早已知道错误隐藏在哪里。此外，在创建新代码时，假设对于快速有效地构建至关重要。否则，我们可能会陷入困境，试图创建代码来处理每一个可能的使用案例，即使这些案例可能永远不会发生。
- en: 'At times, making assumptions becomes necessary or simplifies the code significantly,
    outweighing any drawbacks. However, when we make assumptions in our code, it’s
    crucial to remember that other engineers might not be aware of them. To prevent
    them from inadvertently being affected by our assumptions, we need to enforce
    them. There are generally two approaches we can adopt to achieve this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，做出假设变得必要，或者可以显著简化代码，从而抵消任何缺点。然而，当我们代码中做出假设时，我们必须记住，其他工程师可能并不了解这些假设。为了防止他们无意中受到我们假设的影响，我们需要强制执行这些假设。通常，我们可以采用以下两种方法来实现这一点：
- en: '`create()` method instead.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`create()`方法。
- en: '**Utilizing an error-signaling technique**: If it’s not feasible to make the
    assumption foolproof, we can implement code that detects when the assumption is
    violated and employs an error-signaling technique to quickly halt the execution.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用错误信号技术**：如果无法使假设万无一失，我们可以实现代码来检测假设被违反的情况，并采用错误信号技术来快速停止执行。'
- en: If you would like to look more deeply into these aspects, I recommend the book
    by Tom Long listed in the *Further* *reading* section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更深入地了解这些方面，我推荐在*进一步阅读*部分列出的汤姆·朗的书。
- en: 'So far, we’ve learned what makes code good, the most important things for which
    are readability and reliability. Good code should be easy to understand and hard
    to mess up. It’s modular, like a well-built piece of furniture that you can use
    over and over again. Of course, there’s some room for debate and personal preference,
    but I think we can mostly agree on these points. Now, let’s move on to another
    important way to create good code: **Clean Code**.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了什么使代码变得良好，其中最重要的是可读性和可靠性。良好的代码应该易于理解且难以出错。它是模块化的，就像一件制作精良的家具，你可以反复使用。当然，有一些辩论和个人偏好的空间，但我认为我们大多数人在这些观点上可以达成一致。现在，让我们继续探讨创建良好代码的另一个重要方法：**清洁代码**。
- en: Clean Code
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁代码
- en: The most well-known book on Clean Code is called *Clean Code* by Robert C. Martin.
    Surprisingly, even Martin himself struggles to come up with a single definition
    for Clean Code. It seems like there are multiple definitions floating around among
    us developers. In fact, in his book, Martin asks several developers to provide
    their own “custom” definitions, and he includes all of them so that we can create
    our own understanding of what Clean Code means.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关于清洁代码最著名的书籍是由Robert C. Martin所著的《*清洁代码*》。令人惊讶的是，即使是Martin本人也难以给出清洁代码的单一定义。似乎在我们开发者中存在多个定义。事实上，在他的书中，Martin要求几位开发者提供他们自己的“定制”定义，并将它们全部包括在内，以便我们可以自己理解清洁代码的含义。
- en: Clean Code is all about writing code that’s easy to understand and follows a
    logical and disciplined approach. The main goal is to create software efficiently
    and effectively while ensuring that the code is readable, adaptable, expandable,
    and easy to maintain.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁代码的核心理念是编写易于理解且遵循逻辑和严谨方法的代码。主要目标是高效且有效地创建软件，同时确保代码可读、可适应、可扩展且易于维护。
- en: 'You could argue that this definition is not objective, and you would be right!
    For example, “*readable*” is something very personal (and depends also on the
    seniority and the skillset of those who are approaching the code). More often
    than you might think, we judge code by our guts. Can I understand it? Then it’s
    readable! Rephrasing from the “*Fundamental Theorem of Readability*” book by Bowsell
    and Foucher: *code should be crafted in a way that reduces the amount of time
    someone else would need to* *comprehend it.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说这个定义不是客观的，你是对的！例如，“*可读性*”是非常个人化的（也取决于接近代码的人的资历和技能）。比你想象的更经常的是，我们根据直觉来判断代码。我能理解它吗？那么它就是可读的！从Bowsell和Foucher的《*可读性基本定理*》一书中重新表述：*代码应该以减少他人理解所需时间的方式精心打造*。
- en: And when we use the word “*understand*,” we set a very high standard. To truly
    comprehend your code, someone should possess the ability to make modifications,
    identify bugs, and grasp how it interacts with the rest of your code base. Clean
    Code is not a set of laws or a set of rules; it is an attitude, a mindset that
    we all should follow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用“*理解*”这个词时，我们设定了一个非常高的标准。真正理解你的代码，某人应该具备修改、识别错误和掌握它与整个代码库交互的能力。清洁代码不是一套法律或一套规则；它是一种态度，一种我们所有人都应该遵循的心态。
- en: As already mentioned, refactoring and clean code are strictly related, since
    they both aim to improve the quality and maintainability of software.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在工作中与没有技术背景的人谈论清洁代码时，他们的反应各不相同，但并不太多：从打哈欠到翻白眼，从低头到不耐烦的手势。他们认为有人在谈论他们无法理解的话题，或者提出“改变一个正在工作的事物”或“编写好的代码”，好像除了代码之外，还有其他的东西要么工作要么不工作（而且——让我们面对现实——将重构等实践视为时间和金钱的浪费）。
- en: Why Clean Code?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么是清洁代码？
- en: 'Exactly as happens with refactoring, when I talk about Clean Code at work to
    people who don’t have a technical background, the reactions vary, but not so much:
    they range from yawning to rolling their eyes, from looking down to impatient
    gestures. They perceive someone talking about incomprehensible topics to them,
    or proposing “changing something that works” or “writing code well,” as if there
    was something other than code that either works or doesn’t work (and – let’s face
    it – considering practices such as refactoring as a waste of time and money).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，重构和清洁代码密切相关，因为它们都旨在提高软件的质量和可维护性。
- en: Things such as documentation and comments are definitely important (and we’ll
    get there), but the most crucial thing that should always speak for itself is
    your code. Write your code as if you’re talking in everyday language. Make it
    understandable not just for now, but also for yourself and others in the future.
    Remember that a big part of our job is maintenance (which might not be fun, but
    it’s a reality). When your code can speak for itself, it not only improves your
    technical skills but also enhances the quality of your code. Being able to communicate
    clearly about your code allows you to seek help and receive valuable suggestions
    for improvement. Clean code doesn’t magically appear; it requires dedicated effort
    to express your intentions effectively. Aim to write self-explanatory code, organized
    and structured, so that you don’t have to litter it with excessive comments to
    explain its purpose.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如文档和注释之类的东西肯定很重要（我们很快就会谈到），但始终应该自己说明的最关键的事情是你的代码。编写你的代码就像用日常语言交谈一样。让它不仅对现在，而且对未来的你和其他人都容易理解。记住，我们工作的一大部分是维护（这可能不是很有趣，但这是现实）。当你的代码能够为自己说话时，它不仅提高了你的技术技能，也提高了代码的质量。能够清楚地关于你的代码进行沟通，让你能够寻求帮助并获得改进的宝贵建议。清晰的代码不是凭空出现的；它需要投入专门的精力来有效地表达你的意图。目标是编写自解释的代码，组织有序，结构清晰，这样你就不需要用过多的注释来解释其目的。
- en: I’ve already mentioned that your code will be read by someone else, whether
    it’s another person or even yourself. This highlights the need to write Clean
    Code, as it benefits teamwork. It takes less time to understand what the code
    does, fix it when issues arise, and add new features. Clean Code promotes code
    reusability and makes you a more efficient programmer; it facilitates easier and
    faster maintenance, as it is easier to understand, debug, and modify when needed.
    Simply put, it makes the team faster. You can use this argument (this *fact*)
    when a colleague or manager accuses you of wasting time by being picky about the
    code!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到过，你的代码将被别人阅读，无论是另一个人还是你自己。这突出了编写清晰代码的需要，因为它有利于团队合作。理解代码所做的工作、在出现问题时修复它以及添加新功能所需的时间更少。清晰的代码促进了代码的可重用性，使你成为一个更高效的程序员；它简化了维护工作，因为它更容易理解、调试和修改。简单来说，它使团队更快。当同事或经理指责你过于挑剔代码而浪费时间时，你可以使用这个论点（这个事实）！
- en: One often underestimated aspect of writing clean code is feeling comfortable
    with what you’re doing. Imagine having to ask someone for help and showing them
    something messy and shaky, something that is hard to understand and complicated
    to explain. It would be embarrassing. Moreover, in my opinion, working on a clean
    project boosts morale. You have the satisfaction of doing things properly, almost
    something beautiful, you could say. It’s what a craftsman should do (forgive the
    clichéd metaphor). We’re not just button pushers; we’re artisans. Let’s always
    write code as if we were going to show it to someone else (and actually showing
    it to someone else, through peer reviews or pair programming, really helps—we’ll
    come on to that later). Clean Code just works better, hence the satisfaction is
    not only when people look at your code, but also when they use the services it
    provides and they work properly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰代码的一个常被低估的方面是感到自己在做的事情很舒适。想象一下，你需要向别人求助并展示一些杂乱无章、摇摇欲坠的东西，一些难以理解且难以解释的东西。这会让人感到尴尬。此外，在我看来，在一个整洁的项目上工作可以提高士气。你会有正确做事的满足感，几乎可以说是一种美。这就是工匠应该做的事情（请原谅这个陈词滥调的比喻）。我们不仅仅是按按钮的人；我们是工匠。让我们始终以我们打算向别人展示代码的方式编写代码（实际上通过同行评审或结对编程向别人展示，这真的很有帮助——我们稍后会谈到这一点）。清晰的代码效果更好，因此满足感不仅在于人们查看你的代码时，还在于他们使用它提供的服务并且它们能正常工作时。
- en: If you think your main job as a programmer is writing code, think again. You
    actually spend more time reading code, hunting down bugs, identifying issues,
    and figuring out solutions. Clean Code simplifies all of these tasks. One thing
    every programmer can unanimously agree on is that Clean Code is undeniably better.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你作为程序员的 主要工作是编写代码，那么请重新思考。实际上，你花更多的时间阅读代码、寻找错误、识别问题和找出解决方案。清晰的代码简化了所有这些任务。每个程序员都可以一致同意的一点是，清晰的代码无疑是更好的。
- en: Some principles of Clean Code
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清晰代码的一些原则
- en: Trying to explain Clean Code in its entirety would take a whole book, and guess
    what? It already exists courtesy of Uncle Bob, Robert C. Martin. However, I do
    think it would be helpful to provide you with some highlights, especially if you’re
    new to this topic. We’ll delve deeper into some of these aspects later on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 解释整个“清晰代码”的概念需要一整本书，你知道吗？这本书已经由Uncle Bob，罗伯特·C·马丁撰写并存在了。然而，我认为向您提供一些亮点会有所帮助，尤其是如果您对这个主题是新手的话。我们稍后会深入探讨这些方面的内容。
- en: KISS – Keep things as simple as possible
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KISS – 尽可能保持简单
- en: '**KISS** (short for **Keep It Simple, Stupid** or **Keep It Stupid-Simple**,
    depending on how bold you want to be) is one of the oldest rules in clean code.
    It urges programmers to keep their code as simple as possible. Avoid making things
    needlessly complicated. In the world of programming, there’s never just one way
    to solve a problem. You can accomplish a task using different languages and various
    commands. Programmers who embrace the KISS principle always ask themselves if
    there’s a simpler way to tackle a specific problem.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**KISS**（即**保持简单，傻瓜**或**保持简单愚蠢**，取决于您想有多大胆）是清晰代码中最古老的规则之一。它敦促程序员尽可能使代码保持简单。避免无谓的复杂化。在编程的世界里，解决一个问题的方法永远不止一种。您可以使用不同的语言和各种命令来完成一项任务。遵循KISS原则的程序员总是会问自己是否有更简单的方法来解决特定的问题。'
- en: DRY – Avoid repetition
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DRY – 避免重复
- en: One of the main functions of computer science is to come up with cool acronyms.
    **DRY** (short for **Don’t Repeat Yourself**) is one of them. It’s like a more
    specific version of KISS, emphasizing that functions in Clean Code should do one
    thing only (and do it well). It’s worth noting that the opposite of DRY code is
    called **WET**, which stands for **We Enjoy Typing** or **Write** **Everything
    Twice**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的主要功能之一是创造酷炫的首字母缩略词。**DRY**（即**不要重复自己**）就是其中之一。它就像KISS的一个更具体的版本，强调在清晰代码中函数应该只做一件事情（并且做好）。值得注意的是，与DRY代码相反的是被称为**WET**的代码，它代表**我们喜欢打字**或**写两次**。
- en: 'A very trivial WET code example is the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的WET代码示例如下：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, in this code, there are many lines that are basically the same.
    We must try to avoid these repetitions; to continue with the wordplay, we must
    *dry* this *wet* code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在这段代码中，有很多行基本上是相同的。我们必须尽量避免这些重复；继续使用这个双关语，我们必须“干燥”这段“湿润”的代码。
- en: 'In its DRY version, the preceding code becomes the following, with no surprises:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在DRY版本中，前面的代码变成了以下内容，没有任何惊喜：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the DRY version, we simply isolated the repeated code in a single method.
    This example was very simple because the repeated line was just a one-line `sysout`,
    but this was just to explain the concept: imagine how it would be if there were
    many lines. And that will not only create clean, more readable code but will also
    reduce the possibility of bugs sneaking in (and security issues, as well).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在DRY版本中，我们只是将重复的代码隔离在一个单独的方法中。这个例子非常简单，因为重复的行只是一个单行的`sysout`，但这只是为了解释这个概念：想象一下如果有许多行会怎样。这不仅会创建更干净、更易读的代码，还会减少错误悄悄潜入（以及安全问题）的可能性。
- en: YAGNI – delete what’s useless
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAGNI – 删除无用的内容
- en: 'The Clean Code principle **YAGNI** (short for **You Aren’t Gonna Need It**)
    follows this simple idea: a developer should only add extra functionality to code
    when it’s actually needed. YAGNI is closely associated with Agile software development
    approaches. According to the YAGNI principle, instead of starting with a grand
    plan, you should build the software architecture in small increments to address
    problems as they arise. This allows for dynamic and individualized problem-solving.
    Clean Code is achieved when the underlying problem is solved efficiently without
    unnecessary bells and whistles.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰代码原则**YAGNI**（即**你不需要它**）遵循这个简单的想法：开发者只有在实际需要时才应该向代码中添加额外的功能。YAGNI与敏捷软件开发方法密切相关。根据YAGNI原则，您不应该从宏伟的计划开始，而应该逐步构建软件架构，以解决出现的问题。这允许动态和个性化的问题解决。当基本问题得到有效解决而没有不必要的装饰时，就实现了清晰代码。
- en: Code should be readable, not concise
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码应该是可读的，而不是简洁的
- en: Code needs to do its job and be interpreted correctly by the machine. But it’s
    not just the machine that needs to understand it—other developers should be able
    to comprehend the code too, especially in collaborative projects. That’s why readability
    is always prioritized over brevity in software development. Writing concise code
    is pointless if it becomes incomprehensible to others. A prime example of producing
    clean and readable code lies in variable naming.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要完成其工作并被机器正确解释。但需要理解的不仅仅是机器——其他开发者也应该能够理解代码，尤其是在协作项目中。这就是为什么在软件开发中，可读性总是优先于简洁性。如果代码变得难以理解，那么编写简洁的代码就毫无意义。变量命名是编写干净和可读代码的一个典型例子。
- en: 'A variable should have a name that clearly conveys its purpose. Take the following
    variable, for instance, which is cryptic without the requisite background knowledge
    and explanation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 变量应该有一个清楚地传达其目的的名称。以下是一个例子，这个变量在没有必要的背景知识和解释的情况下是晦涩的：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But also, this somewhat more precisely named variable still leaves some doubt:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但同时，这个名称更为精确的变量仍然留下了一些疑问：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It should be elapsed... time, OK, but what’s the measurement unit? By using
    the following name for the same variable, its purpose becomes evident:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是经过的时间...，好吧，但测量单位是什么呢？通过使用以下名称来表示相同的变量，其目的就变得明显了：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our personal opinion on the length of variable names is that I prefer them to
    be longer rather than too short. It would be ideal to find a middle ground, but
    it’s not always possible. Between the two extremes, I lean towards longer names
    as they enhance readability. However, it’s important to note that lengthy names
    can sometimes indicate underlying issues.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对变量长度的个人观点是，我更喜欢它们更长而不是太短。找到一个中间点会很理想，但并不总是可能。在这两个极端之间，我倾向于更长的名称，因为它们提高了可读性。然而，需要注意的是，过长的名称有时可能表明潜在的问题。
- en: 'To summarize, we quickly reviewed what Clean Code is. There are entire books,
    online courses, and company workshops dedicated to this topic... in short, there
    is a whole world around it, and I don’t expect these few lines to cover everything.
    My invitation, as usual, is to delve into it as much as possible. There are still
    people out there who consider Clean Code as an accessory, something that wastes
    time because the code works even when it’s not clean. I hope I conveyed the concept
    that things don’t work that way and that good and clean code brings numerous advantages
    with relatively low effort if approached methodically. In the next section, we
    will add another adjective to our code: after good and clean, we will see what
    is meant by *SOLID* code!'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们快速回顾了什么是Clean Code。有关于这个主题的整本书、在线课程和公司研讨会...简而言之，围绕这个主题有一个庞大的世界，我不期望这几行文字能涵盖一切。像往常一样，我的邀请是尽可能深入地研究它。仍然有人认为Clean
    Code是一种配件，因为它即使不干净也能工作，所以是浪费时间。我希望我已经传达了这样的概念：事情并不是这样运作的，而且如果方法得当，良好的干净代码会带来许多优势，而所需的努力相对较低。在下一节中，我们将给我们的代码添加另一个形容词：在好和干净之后，我们将看到*SOLID*代码的含义！
- en: Write SOLID code
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写SOLID代码
- en: If there’s one thing the software engineering community excels at, it’s coming
    up with cool acronyms! That’s exactly what Michael Feathers did when he took inspiration
    from a paper by the ever-present Robert C. Martin (aka Uncle Bob) and came up
    with the term **SOLID principles**. In his essay, Martin recognized that software
    evolves and gets more complicated over time. But without good design principles,
    he warned that software becomes rigid, fragile, and hard to work with. That’s
    where the SOLID principles come in—they were created to tackle these issues head-on
    and make software development easier and more flexible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件工程界有什么擅长的事情，那就是想出酷炫的首字母缩略词！这正是迈克尔·费思（Michael Feathers）从罗伯特·C·马丁（Robert C.
    Martin，又称Uncle Bob）的一篇论文中汲取灵感，提出了**SOLID原则**这一术语时所做的事情。在他的文章中，马丁认识到软件会随着时间的推移而发展和变得更加复杂。但他警告说，如果没有良好的设计原则，软件会变得僵化、脆弱且难以操作。这就是SOLID原则发挥作用的地方——它们被创造出来就是为了直面这些问题，使软件开发变得更加容易和灵活。
- en: 'The acronym SOLID represents five fundamental design principles:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID代表五个基本的设计原则：
- en: '**Single Responsibility** **Principle** (**SRP**)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责** **原则**（**SRP**）'
- en: Open-closed principle
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: Liskov substitution principle
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则
- en: Interface segregation principle
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency inversion principle
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: These principles are widely adopted by software engineers and offer significant
    advantages for developers. Please note that, unlike what is explained in the other
    sections, the SOLID principles apply only to object-oriented languages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则被软件工程师广泛采用，并为开发者提供了显著的优势。请注意，与其它章节所解释的不同，SOLID原则仅适用于面向对象的语言。
- en: Single responsibility principle
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The essence of the SRP, as eloquently stated by Robert Martin, is that “*a class
    should have one, and only one, reason to change*.” By adhering to this principle,
    each class focuses on a specific task, ensuring that every class, module, or component
    in the software system has a clear responsibility. In simpler terms, each class
    should address a single problem.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）的本质，正如罗伯特·马丁（Robert Martin）所巧妙地表达的，“*一个类应该只有一个，且仅有一个，改变的理由*。”通过遵循这一原则，每个类都专注于特定的任务，确保软件系统中的每个类、模块或组件都有一个清晰的责任。用更简单的话说，每个类应该解决一个问题。
- en: The single responsibility principle is a fundamental concept already employed
    by most developers when writing code. It can be applied to various levels, such
    as classes, software components, or microservices.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）是一个基础概念，大多数开发人员在编写代码时已经使用。它可以应用于各种级别，如类、软件组件或微服务。
- en: 'By following this principle, several benefits arise: code becomes easier to
    test and maintain, software implementation becomes more straightforward, and it
    helps prevent unexpected side effects when making future changes.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这一原则，可以带来几个好处：代码更容易测试和维护，软件实现变得更加直接，并且在将来进行更改时有助于防止意外的副作用。
- en: 'Maybe it’s worth providing an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可能提供示例是有价值的：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, the `UserManager` class violates the SRP by having two distinct
    responsibilities: saving the user to the database and sending emails to the user.
    Ideally, each class should have only one responsibility.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`UserManager` 类违反了SRP，因为它有两个不同的职责：将用户保存到数据库并向用户发送电子邮件。理想情况下，每个类应该只有一个职责。
- en: 'To address the SRP violation, we can refactor the code by separating the concerns
    into different classes. Here’s a possible refactoring:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决SRP违规问题，我们可以通过将关注点分离到不同的类中来重构代码。以下是一个可能的重构示例：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this refactored code, the `UserRepository` class is responsible for handling
    persistence logic, while the `EmailService` class handles email communication.
    By separating these concerns into different classes, we adhere to the SRP and
    make the code more maintainable and flexible.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构的代码中，`UserRepository` 类负责处理持久化逻辑，而 `EmailService` 类负责处理电子邮件通信。通过将这些关注点分离到不同的类中，我们遵循了单一职责原则（SRP），使代码更易于维护和灵活。
- en: Open-closed principle
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: The concept behind the open-closed principle is that when new functionality
    needs to be added, it’s preferable to extend existing, well-tested classes rather
    than modify them. Making changes to classes can introduce issues or bugs. The
    goal is to be able to enhance a class’s behavior without altering its original
    implementation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 开放封闭原则背后的概念是，当需要添加新功能时，最好是扩展现有的、经过良好测试的类，而不是修改它们。对类的修改可能会引入问题或错误。目标是能够在不改变原始实现的情况下增强类的行为。
- en: 'Adhering to this principle is crucial for developing code that is easily maintainable
    and adaptable. A class follows the open-closed principle if it satisfies the following
    conditions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这一原则对于开发易于维护和适应的代码至关重要。一个类如果满足以下条件，则遵循开放封闭原则（OCP）：
- en: '**Open for extension**: The class’s behavior can be extended or augmented'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放扩展**：类的行为可以被扩展或增强'
- en: '**Closed for modification**: The source code of the class remains unchanged
    and is not directly modified'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁止修改**：类的源代码保持不变，不能直接修改'
- en: At first glance, these two criteria might appear contradictory, but as you become
    more familiar with the principle, you’ll realize that it’s not as complex as it
    initially seems.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这两个标准可能看似矛盾，但随着你对这一原则越来越熟悉，你会意识到它并不像最初看起来那么复杂。
- en: To follow these principles and make sure your class can be easily extended without
    changing the code, you need to use abstractions. Inheritance or interfaces that
    allow for different implementations are commonly used to meet this requirement.
    No matter which method you choose, it’s important to stick to this principle so
    that your code remains easy to maintain and update.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you work for a travel e-commerce company that sells various modes
    of transportation. With a focus on environmental sustainability, you decide to
    display the CO2 emissions for each mode of transport. Currently, you handle airplanes
    and trains.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to have the following interface and classes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have two implementations of `Co2Calculator`, one used for planes and one
    for trains. Each of them implements, of course, the same method. This interface
    would be used in another class – let’s call it `EmissionCalculator`, in this way:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Should we decide to introduce a new transportation mode, for example, `Bus`,
    it would be easy to do:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: None of the existing code has been touched. Our `EmissionCalculator` class doesn’t
    need to implement new logic when we introduce a new transportation mode.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among the five SOLID principles, the Liskov substitution principle can be challenging
    to grasp. In essence, this principle states that any derived class should be capable
    of replacing its parent class without causing any issues. Simply put, if class
    *A* is a subtype of class *B*, we should be able to replace *B* with *A* without
    disrupting the behavior of our program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'For a very trivial example, let’s suppose we must model vehicles (for simplicity,
    I’m omitting constructors, getters, and setters):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Introducing a new `Bicycle` entity and making it extend the `Vehicle` class
    would violate the principle:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this code, we are forced to implement the method of the `Vehicle` interface,
    but we are also unable to do it because, you know, bicycles have no engine! So
    we’re forced to cause disruption, for example, throwing an exception. We would
    not be able to replace a vehicle with a bike without disrupting the behavior of
    our program, violating the Liskov principle.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main idea behind the **Interface Segregation Principle** (**ISP**) is to
    have many small interfaces rather than a few big ones. According to Martin, “*Make
    fine grained interfaces that are client-specific. Clients should not be forced
    to implement interfaces they do* *not use.*”
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: For software engineers, this means you shouldn’t just add new methods to an
    existing interface. Instead, start fresh and build new interfaces tailored to
    each client’s needs. Using smaller interfaces encourages composition over inheritance
    and promotes loose coupling. If an interface is too big, it’s better to break
    it down into smaller ones. That way, classes implementing those interfaces just
    have to worry about the methods they actually care about.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we have the usual transportation selling system, and we have
    the following interface:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This interface seems pretty big, and the fact that its name ends with “*manager*”
    is too generic and could be a problem (because it lacks specificity and doesn’t
    provide clear information about the responsibilities or purpose of the class or
    component). It covers a lot of different things. If you were to implement it in
    a class, you’d have to handle a bunch of different stuff, each with its own level
    of importance.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: What about splitting the `FlightManager` interface into three specific “calculators”,
    one for each concern?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By doing this, we can have greater flexibility in deciding which classes will
    implement specific interfaces:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, each specific class only implements the required method(s) and isn’t aware
    of anything that is not its particular concern.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle helps separate software components. Basically, the dependency
    inversion principle suggests that developers should “*depend on general concepts,
    not specific implementations.*” Martin also explains that “*higher-level modules
    should not rely on lower-level modules. Both should rely on abstract concepts.*”
    Additionally, *“abstract concepts should not rely on specific details. Details
    should rely on* *abstract concepts.*”
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: A common approach to following this principle is to use a dependency inversion
    pattern, but that’s not the only way to achieve it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this principle, let’s suppose we have a (simplified) `LocationCatalog`
    class, which handles all of the queries about locations in a system. This class
    takes the “location dictionary” from a database repository:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code will function correctly, allowing us to utilize `LocationDatabaseRepository`
    without limitations in our `LocationCatalog` class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: So everything’s OK now? Not quite. There’s an issue, and it lies in tightly
    coupling these three classes together when declaring `locationRepository` with
    the new `LocationDatabaseRepository` class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: This not only makes it difficult to test our `LocationCatalog` class, but it
    also eliminates the possibility of easily swapping out the `LocationDatabaseRepository`
    class for a different one if needed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: To address this, let’s decouple our location manager from `LocationDatabaseRepository`
    by introducing a more generic `LocationRepository` interface and incorporating
    it into our class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have successfully eliminated the dependency and now have the freedom to choose
    any source for our location, be it a file, an external service, or a mocked implementation
    (particularly useful for testing purposes).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a good foundation in writing good code: we know what it is, we
    know about Clean Code, and we know that good code is also SOLID code. Next, let’s
    consider the reliability of code and the fact that reliable code does not produce
    unwanted effects, also known as side effects.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Side effects and mutability
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When something is immutable, it means its *state* can’t be changed once it’s
    created. Understanding why immutability is a good thing involves recognizing the
    problems that can arise from its opposite—mutability.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: There are several downsides to having mutable objects or, in general, in being
    forced to handle mutability (and thus, handling objects’ state).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: A mutable class that has setup functions can easily be misconfigured, leading
    to an invalid state; this is a sort of addendum (a *spin-off*) to what we said
    before (“*good code is hard to misuse*”). If you allow a class to have some kind
    of really detailed and complicated setup functions, it will be more likely to
    misuse it, ending up with a wrong or invalid configuration that will end in some
    malfunctioning in your code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Another big issue with mutable objects arises when you think about thread safety,
    a critical concern in multi-threaded or parallel programming because multiple
    threads can access and modify shared data simultaneously. For more information
    about what thread safety is, there’s an entry in the *Further reading* section.
    Mutable objects are not thread-safe because they can be modified by multiple threads
    concurrently without proper synchronization, leading to unpredictable and potentially
    incorrect behavior.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: However the real problem with mutability occurs when a function messes with
    the input parameters. It’s like lending something to a friend. When you lend something,
    you don’t want it to get messed up because you might need it later or want to
    lend it to someone else (think of a book, a bike, or your favorite Batman action
    figure). That function holds important information that the function needs, but
    you might still need it for other things after the function is done.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: If a function starts changing the input parameter, it’s like scratching your
    bike or ruining your Batman action figure. Usually, when you pass an object to
    a function, you expect it to be borrowed and returned as it is. But if the function
    goes ahead and messes with it, that’s not cool. Changing an input parameter is
    a side effect because it affects something outside the function itself. Typically,
    functions take inputs through parameters and give back results through return
    values.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: For most engineers, modifying an input parameter is an unexpected side effect
    that can lead to surprises and confusion. So, it’s best to avoid messing with
    borrowed objects and stick to the convention of using parameters for inputs and
    return values for results.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way to make code non-misusable is to use immutable objects. In Java
    specifically, a typical immutable object would contain just the fields (with the
    final modifier), a constructor, and – optionally – the getters:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This object is indeed immutable, and it follows a common pattern for implementing
    immutability. All of its properties are declared as `final`, meaning they cannot
    be modified after they are initialized. The properties are typically declared
    in a constructor, which may or may not require all of these parameters, depending
    on the specific requirements. This object does not provide setter methods, as
    attempting to do so would result in a compilation error due to the `final` fields.
    However, it does provide getters for accessing the property values, but this can
    vary depending on your specific needs. It should be evident that once this object
    is created, it cannot be modified.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the same aim can be achieved in a much simpler way using a Java record
    (introduced in **Java 14**), but that would be a bit out of scope here. The goal
    is to promote immutability; this implementation is just an example. There's also
    the builder pattern that we'll introduce in the next section.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Another really common example in Java is the `String` class. A `String` object
    always represents the same string. Since `String` is immutable, once created,
    a `String` object always has the same value. To add something to the end of a
    `String`, you have to create a new `String` object:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In general, to make a class immutable, follow these rules:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Don’t provide any methods that modify the state of your object (aka mutators).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the class can’t be extended (this is mostly done by making it `final`).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make all fields `final` and `private`.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensure exclusive access to any mutable components: it can happen that a field
    of your class is defined as a mutable object. In this case, be sure that a client
    cannot obtain references to this object. Initialize it *inside* your class and
    make defensive copies in constructors and accessors.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You could argue: OK, but I just have that one use case in which I *must* create
    an object and then change it. A typical example is when you have to create an
    object and fill its fields in different steps. My suggestion here is to use the
    builder pattern instead.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A builder is a design pattern commonly used in object-oriented programming to
    construct complex objects step by step. It provides a flexible and readable way
    to create objects with multiple optional parameters or configurations. The builder
    pattern separates the construction of an object from its representation, allowing
    the same construction process to create different representations of the object.
    It provides a clear and intuitive API for constructing objects by providing methods
    to set values for various properties or parameters. Typically, a builder class
    is created for each complex object, and it contains methods to set individual
    properties or configurations of the object. The builder accumulates these settings
    and finally constructs the object when requested. This approach allows for more
    readable and maintainable code, especially when dealing with objects that have
    many optional parameters or configurations. It promotes the idea of *fluent* or
    chainable method calls, where each method returns the builder instance itself,
    allowing for a more concise and readable construction syntax.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a builder to create a “student”:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The class provides a default constructor, which doesn’t take any parameters.
    The `StudentBuilder` class also provides two setter-like methods: `withName(String
    name)` and `withSurname(String surname)`. These methods allow setting the name
    and surname properties of the student, respectively. Each setter-like method updates
    the corresponding property of the builder instance and returns the builder object
    itself (`this`) to support method chaining. Finally, the `build()` method is used
    to construct and return a new `Student` object using the values set in the builder.
    It creates a new `Student` instance with the name and surname obtained from the
    builder and returns the constructed object. With this builder class, you can construct
    a `Student` object step by step, setting the name and surname values as needed.
    Here’s an example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code creates a new `Student` object with the name `"John"` and surname
    `"Doe"` using the builder pattern. By chaining the `withName()` and `withSurname()`
    methods, you can set the desired values for the name and surname properties, respectively.
    Finally, the `build()` method constructs and returns the `Student` object with
    the provided values.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem a bit inconsistent with the message we provided earlier, the
    one regarding long chains of calls. However, in my opinion, this is a special
    case where we are simply constructing an object: there is no logic, the return
    type is always the same, and the alternatives would be equally complex, or worse
    – a long sequence of “set” methods and/or a constructor with many parameters.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The builder can be implemented in slightly different ways, and what’s more,
    it can be automated. You have the option to use IDE plugins or metaprogramming
    libraries such as Lombok. We will discuss these alternatives later on in this
    book.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope that, up to this point, I have provided you with some small tools to
    help combat bad code; not an exhaustive list, but I hope to have at least sparked
    curiosity. Another thing I have always wondered is: why does bad code exist? Assuming
    it is not due to laziness or incompetence of individuals, let’s quickly explore
    some contingent causes that contribute to the situation we are trying to address.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Causes of bad code
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the previous chapter, I don’t have the intention of blaming
    those who write bad code. I myself have written bad code; it has happened in the
    past, it still happens, and it will happen again (I can already imagine my colleagues
    nodding as they read these lines!). In the vast majority of cases, those who write
    bad code do so without realizing it because we are human and can only handle a
    certain number of tasks at once. In our hearts, we have the desire to do a good
    job, something to be proud of, but in our minds, we have deadlines, and pressure,
    and we generally work within an ecosystem that we don’t fully control. Very often,
    companies are complex systems that may have clear rules (for example, regarding
    the methodologies to follow), but they have to deal with an increasingly hectic
    world, with time-to-market pressures, and the need to compete fiercely. There’s
    a way things should be and the way they actually are. As software engineers, we
    guide or support the work of the company and often find ourselves interacting
    with mentalities and needs that are very different from our own. Sometimes, the
    result is sacrificing quality and experiencing a bit of frustration. Almost always,
    this leads to having a bad code base. But why does this happen? If we could identify
    some common causes of bad code, maybe we’d be able to recognize them and avoid
    them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Deadlines
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is definitely going to be a controversial point. For many, blaming deadlines
    as the cause of bad code is just an excuse to hide laziness or incompetence. It’s
    not true that there’s no time; it’s just that you don’t want to put in the effort
    to think and do things properly. In some cases, that may very well be true. Over
    the years, though, I’ve often observed – although I must say, not always and to
    a lesser extent as time goes on – a disconnect between management and engineers.
    There’s often a tendency to “sell” the solution without paying much attention
    to how long it will actually take to implement it. As a result, developers end
    up not negotiating a deadline but simply being subjected to it. So they take shortcuts,
    maybe cut back on testing, documentation, and overall quality (violating some
    of the principles seen so far, such as keeping code readable or without repetitions).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'On this matter, I’d advise you to take a look at what’s called the *project*
    *management triangle*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The project management triangle](img/B20912_02_4.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The project management triangle
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: It’s like an equilateral triangle with sides representing the **Scope**, **Cost**,
    and **Time** of a project. These three dimensions are interconnected, and changing
    one of them will affect the overall shape of the triangle, which represents the
    quality. Furthermore, since the triangle needs to remain equilateral, it’s clear
    that modifying the available time will decrease the cost, and vice versa. By extending
    the time available, you can increase the project scope, but the costs will also
    go up accordingly. It’s a neat metaphor for how projects, including software projects,
    work.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The Broken Window theory
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s another thing to consider: the Broken Window theory. Philip Zimbardo,
    a psychologist from Stanford, did a very interesting study: he parked a car in
    a fancy neighborhood for a couple of days and just watched it. Surprisingly, nothing
    happened. He waited and waited, but nobody touched the car. Then, he decided to
    break a small window to see if things would change. Within just a few hours, the
    car was completely stripped; everything was gone – tires, wheels, electronics,
    steering wheel, seats, mats, even the engine. All that was left was a bare-bones
    car sitting on cinder blocks.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Now, the same kind of thing can happen with code. You start off with a clean
    situation; everything’s looking good. But as soon as you introduce one bit of
    bad code, things can quickly go out of control. For instance, you ignore code
    duplication in a few places, leave inconsistent formatting, and tolerate inconsistent
    variable naming. Again, you can start adding code without the proper test coverage,
    or you avoid upgrading your project’s dependencies due to fear of issues sneaking
    in.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Initially, these may seem like minor problems, and developers prioritize adding
    new features or fixing critical bugs instead. Other team members notice these
    neglected issues but also follow suit, assuming they are not a high priority.
    As developers, we’re already making some mistakes, so why bother doing it right
    in this case? Taking shortcuts and doing things the easier, faster way seems tempting.
    As time goes on, more developers join the project, and the code base grows larger
    and more complex. The neglected issues start to accumulate, making the code harder
    to understand and maintain. The lack of consistent conventions leads to confusion,
    reduces code readability, and introduces errors. Additionally, because the existing
    issues were not addressed, developers may feel less motivated to maintain code
    quality. They might think, “If there are already duplicated code snippets, what
    harm can a few more do?”. Eventually, the code base becomes a tangled mess of
    poorly organized, duplicated, and hard-to-read code. New developers joining the
    project struggle to make sense of it and find it increasingly difficult to introduce
    changes without inadvertently introducing bugs or breaking existing functionality.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: It’s like a snowball effect, and things can get pretty messy in no time. And
    this kind of mess can produce technical debt; you re-pay technical debt with slowness
    in developing new features.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: No code review process
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we started programming, maybe back in school, it often happened that we
    did it alone. You wrote the code, tested it in some way, and that was it. The
    code and the design only needed to make sense to us and no one else.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: When working in a team, it’s a good idea to implement code review mechanisms.
    A **code review** is the process of reviewing and examining code to improve its
    quality, identify issues, and ensure adherence to standards – we’ll delve into
    that in [*Chapter 8*](B20912_08.xhtml#_idTextAnchor183). Code reviews are also
    useful to make the code we write somewhat “consistent” and clear for all team
    members. When code reviews are absent, the code can become subject to personal
    preferences, may contain errors, or have room for improvement in terms of performance.
    Some people see the review process as a distraction from business activities;
    some developers see it as a hindrance to their own tasks. Sometimes, of course,
    even reviews cannot address particularly deep-rooted problems. However, they at
    least help identify major “issues” that may have slipped past the individual developer,
    who was focused on solving complex problems. It happens more often than you might
    think.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B20912_08.xhtml#_idTextAnchor183), we will introduce the **Pair
    Programming** practice, which can be used as a substitute for code reviews.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient domain or technical knowledge
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the reason behind bad code is simply that the people who worked on
    it were not aware of the application domain or the technologies being used. These
    are different aspects but somehow related.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: When lacking domain knowledge, it’s easy to misinterpret requirements or write
    the logic in the wrong place (maybe not knowing that it already exists elsewhere).
    The situation gets worse when the code is already messy, and we have to work on
    it without really knowing what we’re doing. In this situation, even with the purest
    of intentions, removing an apparently unused `if` statement or changing how an
    object is created requires careful consideration (and adequate test coverage,
    something else we’ll tackle later).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge gaps can also be purely technological. It may be that some of us are
    new and don’t yet have a clear understanding of the technology stack. This often
    leads to overly complex solutions or, on the contrary, workarounds and hacks.
    It can happen that the developer lacks certain discipline and the habitual use
    of good practices that we’ve tried to explain in this chapter. These practices
    – contrary to what it may seem – don’t exist to slow us down, but actually enable
    us to produce high-quality code quickly and consistently.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We have tried to investigate some of the most common causes of bad code. I realize
    that I have relied on my own experience to some extent, but I believe that some
    of the concepts expressed here are universal and worth considering, such as the
    Broken Window theory or the project management triangle. The next time a manager
    asks you to do something well and in less time, you will hopefully have an additional
    argument on your side!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking of refactoring, it is crucial to understand what needs to be refactored;
    in other words, it is necessary to distinguish good code from bad code. In this
    chapter, we have seen what is typically meant by good code, providing an overview
    of its characteristics. When these characteristics are lacking, it is likely that
    refactoring is needed. When discussing good code, we must also talk about Clean
    Code; we addressed this topic and learned how to recognize it and, hopefully,
    write it. Good code is usually also SOLID code, and we briefly touched upon the
    meaning of that as well. Lastly, after understanding what good code is, we investigated
    some causes of bad code; the hope is that you will be alert if you find yourself
    in one of the described situations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we'll address a set of warning signs—elements in your
    code that should alert you and prompt contemplation on refactoring your code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'mscharhag, *ISO 8601 durations in* *Java*: [https://www.mscharhag.com/java/iso8601-durations](https://www.mscharhag.com/java/iso8601-durations)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tom Long, *Good Code, Bad* *Code*, Manning
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Stop calling it bad code*, by Joel Spolsky: [https://blog.pragmaticengineer.com/bad-code/](https://blog.pragmaticengineer.com/bad-code/)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The law of leaky abstraction*, by Joel Spolsky: [https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What does Clean Code** **mean?** [https://cogut.medium.com/what-does-clean-code-mean-2190e4aed818](https://cogut.medium.com/what-does-clean-code-mean-2190e4aed818)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robert C Martin, *Clean Code*, Prentice-Hall 2009
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Robert C Martin, *Design Principles and Design* *Patterns*: [http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf](http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What is thread** **safety?**: [https://en.wikipedia.org/wiki/Thread_safety](https://en.wikipedia.org/wiki/Thread_safety)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The SOLID principles in** **pictures**: [https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898](https://medium.com/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*You should break the Law of Demeter*, by Ted Kaminski [https://www.tedinski.com/2018/12/18/the-law-of-demeter.html](https://www.tedinski.com/2018/12/18/the-law-of-demeter.html)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Essence of Refactoring and Good Code'
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going through code, especially old code, is a big part of a software developer’s
    job. There are certain warning signs, like “red flags,” that professionals should
    notice right away. Recognizing and avoiding these issues is an important skill,
    and in this section, we’ll understand how to spot them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned what refactoring is and why it’s important, let’s explore
    a crucial requirement. Refactoring isn’t safe unless you have really good test
    coverage. We’ll find out why having thorough tests is essential.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Next, how do you actually refactor your code? There are some common techniques
    that can be very helpful. We’ll learn how to master them.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: After that, we’ll delve into metaprogramming. Instead of manually changing code,
    metaprogramming techniques can automatically analyze and refactor it. For example,
    metaprogramming can generate code, replace method calls, or dynamically modify
    class structures. This makes refactoring faster and less prone to errors by reducing
    the amount of manual work needed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we’ll discuss static and dynamic analysis. Static analysis involves
    examining code without running it and identifying issues like code smells and
    security vulnerabilities. Dynamic analysis, on the other hand, involves analyzing
    code by running it, helping find performance bottlenecks and runtime issues like
    memory leaks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B20912_03.xhtml#_idTextAnchor070), *Code Smells*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B20912_04.xhtml#_idTextAnchor095), *Testing*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B20912_05.xhtml#_idTextAnchor117), *Refactoring Techniques*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B20912_06.xhtml#_idTextAnchor150), *Metaprogramming*'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20912_07.xhtml#_idTextAnchor161), *Static and Dynamic Analysis*'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
