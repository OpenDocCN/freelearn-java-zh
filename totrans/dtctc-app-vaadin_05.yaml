- en: Connecting to SQL Databases Using JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing information means performing operations such as storing, modifying,
    removing, sorting, arranging, linking, and matching data in a data store. Database
    management systems provide the means to perform these operations and relational
    databases are the most common type of data store used with web applications.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts by briefly discussing the fundamental Java technology for
    persistence, **Java Database Connectivity** (**JDBC**). We will learn how to connect
    and how to consume data from a relational database using connection pools and
    SQL queries. We will also describe the concept of a *data repository*, a way of
    encapsulating persistence implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop a very simple web UI that lists data from a database. The purpose
    of the example is to show you the very fundamentals of database connectivity.
    [Chapter 6](9a3c93d4-374e-4324-9201-1d446093fef3.xhtml), *Connecting to SQL Databases
    Using ORM Frameworks*, will focus on more advanced database operations with basic
    data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: JDBC technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDBC drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL query execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-05](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-05)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/7VonXg](https://goo.gl/7VonXg)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have developed *business applications* with Java, you have most likely
    used JDBC directly or indirectly(through an object-relational mapping framework)
    to connect and use relational databases. A *relational database* is a system for
    storing information in a tabular form; that is, in tables. There are many vendors
    offering free and commercial **relational database management systems** (**RDBMS**).
    Two of the most popular open source RDBMS are *PostgreSQL* and *MySQL*, while
    *Oracle Database* and *Microsoft SQL Server* are well-known options among the
    commercial ones. These systems understand the **Structured Query Language** (**SQL**),
    a *declarative language* used to perform tasks such as adding or deleting rows
    in a table.
  prefs: []
  type: TYPE_NORMAL
- en: When using a **declarative language**, you specify *what* you want the program
    to do. In contrast, when using an **imperative language**, such as the Java programming
    language, you specify *how* to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started with the actual code, try compiling and running the example
    application located in the `Data-centric-Applications-with-Vaadin-8/chapter-05`
    Maven module. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done so, import the `Data-centric-Applications-with-Vaadin-8`
    Maven project into your IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a *running configuration* for the `packt.vaadin.datacentric.chapter05.jdbc.H2Server`
    class and run it. This is your database server. It runs in a separate process
    in your computer. Alternatively, you can run the H2 server with Maven from the
    `chapter-05` directory: `mvn test exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.H2Server"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a running configuration for the `packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization`
    class and run it. You should see an initialization succeeded message in the log.
    This initialization creates a new table (`messages`) in the database, and adds
    some demo rows to it. Alternatively, you can run the initialization application
    with Maven: `mvn exec:java -Dexec.mainClass="packt.vaadin.datacentric.chapter05.jdbc.DatabaseInitialization"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a running configuration for the Jetty Maven Plugin in the `chapter-05`
    module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point your browser to `http://localhost:8080`. You should see some demo data
    rendered by a Vaadin application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The H2 server we started in step 2 starts also a web application you can use
    to run SQL queries. Let''s try it! Point your browser to `http://localhost:8082`
    and connect using the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0900594a-2c00-49a9-977a-176d67fc9eb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Insert a new row into the `messages` table by executing the following SQL statement:
    `INSERT INTO messages VALUES(''Welcome to JDBC!'')`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Point your browser to (or reload) the Vaadin application. You should see the
    new message listed there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8dbea3b-1e2c-420d-a407-f06490e4d521.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to, you can stop the Vaadin application and the H2 server, and run
    them again. You should see all the same data as before, including the newly inserted
    row. Just keep in mind that you need to run the H2 server first!
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious, the location of the actual H2 database file is `<home-directory>/h2-databases/demo.mv.db`.
    You can delete this file and run the `DatabaseInitialization` application again
    if you want to recreate the initial state of the database.
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Database Connectivity** (**JDBC**) **API** enables your applications
    to connect to an RDBMS and make SQL calls to it. Other technologies for SQL persistence
    are usually implemented on top of the JDBC. Understanding the key aspects of JDBC
    will make your life easier even if you are planning (or if you are already using)
    other persistence technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, your application should perform five steps in order to use a database
    with the JDBC API:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **JDBC driver** for your database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish a **connection** to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **statement** to **execute** an SQL query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get and process the **result set.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Close** the connection.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a JDBC driver for your database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting to an RDBMS from a Java application is done through a *JDBC driver*.
    Most (if not all) database vendors include JDBC drivers for their RDBMS. A JDBC
    driver, in practice, is just a Java dependency (a JAR) in your project. If, for
    example, you need to connect your application to a PostgreSQL database, you will
    need to add the `postgresql-x.x.x.jar` file to your classpath. This, of course,
    can also be done with Maven. It's through this JDBC driver that your Java application
    communicates with the RDBMS, and it does so by establishing connections and executing
    SQL statements to retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: We are not covering the details about RDBMS and SQL in this book. These topics
    are complex enough by themselves to deserve a complete book about them. There
    are plenty of good bibliographic and online resources you can consult to learn
    more about these topics.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we are going to use an H2 database. H2 is a popular open source
    database engine that doesn't require you to install anything on your computer.
    All the concepts apply to other RDBMS as well, and we'll include snippets or commented
    sections in the accompanying code that show the specifics for MySQL and PostgreSQL,
    in case you want to experiment with these databases by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a JDBC driver is as simple as including the right dependency in your
    project. For example, to include the H2 JDBC driver, add the following dependency
    to your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if you want to use MySQL or PostgreSQL, add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: JDBC was designed to support not only relational databases, but also any kind
    of data source, including file systems or object-oriented systems. Keep this in
    mind when you need to connect your application to any kind of data source; there
    might be a JDBC driver for it.
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, include several JDBC drivers in the same project. The `chapter-05`
    application includes all of the previous drivers.
  prefs: []
  type: TYPE_NORMAL
- en: In old versions of JDBC, you had to manually load the JDBC driver class using
    the `Class.forName` method. This is no longer required in JDBC 4.0\. Any JDBC
    4.0 driver in the classpath is automatically loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a database connection through a connection pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common pitfalls when developing web applications with Vaadin
    is to forget that what you are developing is actually a web application! Since
    the API resembles that of desktop-like UI frameworks, it's easy to forget that
    a Vaadin application is most likely going to be used by several users at the same
    time. You need to keep the multi user nature of a Vaadin application in mind when
    establishing connections to a database.
  prefs: []
  type: TYPE_NORMAL
- en: A desktop application you run locally on your machine might be able to work
    perfectly with a single connection to the database during its execution time (depending
    on the complexity of the application, of course). This is due to the single-user
    nature of the application; you know there's only one user per instance. On the
    other hand, a single instance of a web application is used by many users at the
    same time. It requires multiple connections to work properly. You don't want to
    have users *A, B, C..., X* waiting for the connection to be released by greedy
    user *Z*, right? However, establishing connections is expensive! Opening and closing
    a connection every time a new user requests the application is not an option,
    since your app could reach a big number of concurrent users, and hence connections.
  prefs: []
  type: TYPE_NORMAL
- en: This is where a *connection pool* comes in handy. A connection pool is a class
    that maintains several connections to the database, like a *cache* of connections,
    if you wish. The connection pool keeps all its connections open so that they can
    be reused by client classes when they need it. Without a connection pool, any
    time your app needs to perform a database operation, it has to create a new connection,
    execute the query, and close the connection. As mentioned previously, this is
    expensive and wastes resources. Instead, a connection pool creates a set of connections
    and "lends" them to client classes. Once the connection is used, it's not closed,
    but returned to the pool and used again.
  prefs: []
  type: TYPE_NORMAL
- en: As you can guess, connection pools are such a well-known pattern that many implementations
    exist. Let's see how to use one of them, `BoneCP`, a free open source JDBC connection
    pool implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Other popular connection pool implementations are *C3P0* and *Apache DBCP*.
    Moreover, application servers and servlet containers offer the possibility to
    define pooled data sources (see Java's `DataSource` interface documentation) as
    part of their configuration. This decouples the data source configuration from
    your running environment while offering connection pooling mechanisms for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, here are the dependencies you need to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`BoneCP` requires SLF4J, a logging library that offers a *facade* over several
    logging frameworks. This is needed in order to see logs by `BoneCP` in the console
    or web server log.'
  prefs: []
  type: TYPE_NORMAL
- en: There should be one instance of the connection pool per instance of the web
    application. We used a static Java block in the previous chapter to initialize
    application-level resources. This works in small applications where these resources
    don't depend on others. In more complex applications, your initialization code
    might depend on other services (such as *dependency injection*) in order to work,
    so let's use a more realistic approach this time and use a `ServletContextListener`
    to `init` the connection pool. A `ServletContextListener` allows your application
    to react to events in the *servlet context lifecycle*; in particular, the initialization
    of a servlet context and its destruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with previous examples, the `chapter-05` Vaadin application includes a `WebConfig`
    class that defines <q>everything web</q>; that is, servlets and event listeners.
    Besides the `VaadinServlet`, we can include a `ServletContextListener` that initializes
    the database when the servlet context is created (that is when the web application
    starts... sort of):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `@WebListener` annotation, this class is going to be discovered
    by the servlet container and registered with the servlet context automatically.
    Inside the `contextInitialized` method, we can add the code to initialize the
    connection pool; in this case, by delegating to the custom `DatabaseService` class
    we'll implement next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The infrastructure code is ready; now it''s time for the actual `BoneCp` connection
    pool. Let''s start with the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This implementation defines a static (only one instance per application) `BoneCP`
    field, `pool`, the actual connection pool. The `pool` field is initialized in
    the `init` method, which is called when the application starts (see the `JdbcExampleContextListener`
    class).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three things you need to specify when connecting to a database with
    JDBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The connection URL**: With JDBC, a database is represented by a connection
    URL. JDBC uses this URL to get the information about where and how to connect
    to the database. In the previous example, we can see that the string contains
    the name of the database (`h2`), a host (`localhost`), and a database name (`~/h2-databases/demo`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The username**: Databases allow you to define a set of users, roles, and
    permissions. The username is an identifier that the database can check in order
    to grant permissions on the data. By default, the H2 database defines the username
    `sa`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The password**: As you can guess, this is what allows the database engine
    to run the authentication check. By default, H2 uses an empty password for the
    default `sa` user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What if you wanted to use MySQL or PostgreSQL now? you would have to change
    the `String` literals in this class, recompile, and redeploy. A much better approach
    is to externalize this `String`. One approach is to use the standard Java `Properties`
    class to load *key/value* pairs with the connection URL, username, and password.
    For example, the `chapter-05` application includes a `datasource.properties` file
    in the `/src/main/resources` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With MySQL databases, use: `datasource.url=jdbc:mysql://localhost/demo`'
  prefs: []
  type: TYPE_NORMAL
- en: 'With PostgreSQL databases, use: `datasource.url=jdbc:postgresql://localhost:5432/demo`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DatabaseService` class can now use these properties (`datasource.*`) instead
    of the *hard-coded* literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The connection properties (`url`, `username`, and `password`) are now static
    fields in the class populated from the `datasource.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A way of making your web application configuration independent of the running
    environment is to use the operating system''s *environment variables*. For example,
    let''s say you define a `MY-WEBAPP-CONF-DIRECTORY` environment variable in your
    computer, and set its value to `~/my-webapp-conf`. Inside this directory, you
    can put all the `.properties` files that make up the configuration for example,
    the `datasource.properties` file. The web application can read the environment
    variable like this: `String confDirectory = System.getenv("MY-WEBAPP-CONF-DIRECTORY")`,
    and read any files inside this directory in order to configure the application
    accordingly. With this technique, each developer in the team can define their
    own local configuration. Moreover, you can easily configure *test* and *production*
    environments by defining the environment variable and placing the corresponding
    configuration files â€“ no need to worry about replacing files when you deploy to
    these environments besides checking that all configuration properties are in place.
    Make sure you show good error or warning messages when a property doesn''t exist.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a connection pool ready, we can get actual connections to
    the database. Here is how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A `Connection` represents a session with the database. This interface contains
    a number of methods to get information about the capabilities of the database
    and the state of the connection, but the most important part allows you to create
    `Statements` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Connection pool implementations offer good configurations for development or
    testing environments. This is most likely not optimal for a production environment.
    Consult the documentation of the implementation, and tune the configuration accordingly
    when deploying to production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a statement and executing an SQL query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Statement` object is used to invoke SQL statements in the database. The
    following snippet of code shows how to retrieve a `Connection` object from the
    connection pool. This object is used to create a new `Statement`, which, in turn,
    is used to execute an SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we are using the `Statement` interface and its `createStatement`
    counterpart method. In more critical applications, you should use the `PreparedStatement`
    interface and the `prepareStatement` method in order to increase performance and
    prevent SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and processing a result set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, the `execute` method of the `Statement` class returns a `ResultSet`
    object. A `ResultSet` object represents data from the database. It works like
    a cursor pointing to the rows in the data. First, the cursor is placed before
    the first row. You can use the `next` method to iterate through the rows as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we are using the `getString` method to get the value
    that corresponds to the `content` column. There are methods for various data types:
    for example, the `getInt` method returns the value in the specified column as
    a Java `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: Closing a database connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using a connection pool, the pool implementation takes care of closing
    the JDBC connections. Depending on the specific implementation, you might have
    to invoke this process. Usually, you want the pool to be active during the lifetime
    of your web application. Remember the `ServletContextListener` implementation
    we used to initialize the connection pool? Well, we can use it to shut the pool
    down. All we need to do is to implement the `contextDestroyed` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `shutdown` method is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s a good time for you to play with the `chapter-05` demo application
    again. Have a close look at the `DatabaseService` class and how it is used in
    the `VaadinUI` class. The `findAllMessages` method is pretty interesting in particular,
    as it acts as the main communication point between the Vaadin application and
    the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See how the SQL queries are defined in `String` constants. Can you think of
    a better way of doing this? In a more complex application, you might end up having
    hundreds of SQL queries. A better practice in these scenarios is to externalize
    the SQL code. Properties files might help, but defining SQL queries in a single
    line could be a challenge, to say the least. A better approach is XML, a format
    that allows you to use multiple lines to define values. We'll see how MyBatis
    promotes this approach in [Chapter 6](9a3c93d4-374e-4324-9201-1d446093fef3.xhtml),
    *Connecting to SQL Databases Using ORM Frameworks*.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting detail in the `findAllMessages` method is the return type.
    Why not return a `ResultSet` object? We do this to avoid coupling the presentation
    layer with persistence implementation details. This is what we are going to explore
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the `findAllMessages` method can throw an `SQLException`.
    This makes clients of this method aware of implementation details at some level.
    Although the name of the exception class implies SQL is being used, according
    to the API documentation, an `SQLException` is "<q>an exception that provides
    information on a database access error or other errors</q>". This exception is
    used even in drivers for *NoSQL* databases.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing data repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *repository*, for the purposes of this book, is a class that includes all
    or some of the **CRUD** operations (**Create, Read, Update, and Delete**). Repositories
    encapsulate persistence details in an application. A repository holds the means
    to the domain model (or entities).
  prefs: []
  type: TYPE_NORMAL
- en: More precisely, a domain model includes not only data, but also behavior. Another
    term used widely is **data transfer object** (**DTO**). Although the original
    definition of DTO was intended to describe a way to transport data between processes,
    many architectures (inaccurately) define DTO as an object that carries data between
    software components in the same process. To complicate things even more, there
    are *value objects* (objects that are equal if their properties are equal), and
    *entities* (objects that are equal based on their identity, which can be defined
    by a single property). When documenting and designing your software, spend some
    time investigating the terms, and try to choose the one that best matches your
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a domain model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s study this with an example. Suppose you are implementing a simple e-commerce
    application. You are in charge of the *orders module,* and have to provide access
    to the data related to this module through a web UI. After reading the specification,
    you designed a simple domain model formed by the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e32ca64-5673-45f9-aa28-4c1398348e8b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is pretty straightforward: an `Order` has one or more `Product` objects
    and one `Customer`. You want to use the hypothetical *Technology X* to persist
    data (it doesn''t matter which one for this example), and you want your Vaadin
    `UI` implementation to be able to directly use the domain class; however, you
    don''t want to couple your UI implementation with Technology X. Moreover, you
    have to expose orders and product data through a web service for an external accounting
    system. You decided, then, to implement three repositories, one for each domain
    class: `ProductRepository`, `OrderRepository`, and `CustomerRepository`.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing repositories and services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you started implementing the Vaadin UI, and had a clear understanding
    of the methods that the repositories should expose. You then implemented these
    methods in the respective repository classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a3386ea-77a5-4a66-9d54-43e4174a9f7a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a closer look at the methods in the repository classes. As you can
    see, all method names start with `find` or `get`. This is a well-known convention
    in the industry, and it's used by libraries such as **Spring Data** or **Apache
    DeltaSpike**. Methods starting with `find` return a collection of objects, while
    methods starting with `get` return single, ready-to-use values (such as a domain
    instance, or one of its properties).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how each repository has a private `persistence` field that represents
    the entry point to use Technology X, we will see concrete examples of this later
    in this chapter. If, for some reason, you had to change the persistence technology
    to something else, client classes wouldn''t be affected. Moreover, you can use
    different persistence technologies for different repositories without having client
    classes to deal with different APIs. The following code will give you a clear
    idea of how these repositories can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All the implementation details regarding how to get the data are encapsulated
    in the repository class. Now, let's move on and see how this can be used from
    a Vaadin application.
  prefs: []
  type: TYPE_NORMAL
- en: 'While doing *pair programming*, your colleague suggested you should use service
    classes to abstract away the concept of *repository* from the Vaadin UI. She argued
    that there should be one `service` class for each repository: `ProductService`,
    `OrderService`, and `CustomerService`. It seemed like a good idea to you too;
    however, she immediately noticed that the service classes would be simple *facades*
    for their repository counterparts, and wouldn''t include any extra logic. You
    pointed out that the application had to expose data through a web service consumed
    by the accounting system, and that the service classes might be used for that.
    After you and your colleague investigated the precise data the web service had
    to expose, you both decided to *Fight for Simplicity,* and not to implement one
    `service` class per `repository` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the Vaadin UI would be allowed to have references to the repository
    classes. You also decided to implement a separate `AccountingWebService` class
    to expose the data for the accounting system, so that you could know and control
    what this system is "seeing" in the future. As with the Vaadin UI classes, the
    web service implementation would use the repository classes to fetch data.
  prefs: []
  type: TYPE_NORMAL
- en: The previous hypothetical example doesn't imply that you shouldn't enforce a
    repository/service pairing kind of design in your projects. Always stop and think
    before making this kind of decision. The situation in the example shows how the
    developers considered alternatives, investigated the requirements more deeply,
    and then took an informed decision. Keep the developers, who will maintain your
    code in the future in mind. Keep your legacy in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The active record pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many architectural patterns that may or may not help in your projects;
    in particular, regarding domain models and persistence. You might want to have
    a look at the *active record pattern*. An active record class encapsulates not
    only the data, but also its persistence operations. For example, the `Order` class
    of the previous example would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29eb1f9e-ff9d-4527-a8fc-213b44ac9bea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the CRUD operations are implemented in the domain class alongside
    with the methods previously implemented in the `repository` class. Although being
    an alternative to keep in mind, we won't further cover or use the active record
    pattern in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter served as the fundamentals of database connectivity with Java.
    We learned concepts such as JDBC drivers (that allow applications to connect to
    specific relational database engines) and connection pools (to better use connection
    resources). We learned how to use a `ContextServletListener` to initialize connection
    pools or database-related services. We saw an example of a simple domain model,
    and how repository classes allow us to encapsulate access to data represented
    in this model.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about several persistence technologies,
    and how to integrate them with the Vaadin Framework.
  prefs: []
  type: TYPE_NORMAL
