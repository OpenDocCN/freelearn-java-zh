<html><head></head><body>
		<div id="_idContainer109">
			<h1 id="_idParaDest-301"><em class="italic"><a id="_idTextAnchor300"/>Chapter 15</em>: Calling and Creating Stored Functions and Procedures</h1>
			<p>SQL is a declarative language, but it also<a id="_idIndexMarker1558"/> has procedural features such as stored functions/procedures, triggers, and cursors, which means SQL is considered to be a <strong class="bold">Fourth-Generation Programming Language</strong> (<strong class="bold">4GL</strong>). In this chapter, we<a id="_idIndexMarker1559"/> will see how to call and create stored functions/procedures, or in other words, how to call and create Persistent Stored Modules (SQL/PSM) for MySQL, PostgreSQL, SQL Server, and Oracle.</p>
			<p>Just in case you need a quick reminder about the key differences<a id="_idIndexMarker1560"/> between the stored procedures<a id="_idIndexMarker1561"/> and functions, check out the following head-to-head table (some of these differences are entirely or partially true depending on the database):</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/Figure_15.1.jpg" alt="Figure 15.1 – Key differences between procedures and functions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – Key differences between procedures and functions</p>
			<p>As you can infer from the previous comparison, the main difference is that procedures (may) produce a side effect, whereas functions are (generally) expected not to.</p>
			<p>So, our agenda includes the following topics:</p>
			<ul>
				<li>Calling stored functions/procedures from jOOQ</li>
				<li>Stored procedures</li>
				<li>Creating stored functions/procedures via jOOQ</li>
			</ul>
			<p>Right before getting started, let's have some insight from Lukas Eder who shared that: "<em class="italic">This may come up later, but it might be worth mentioning early: there are some users who use jOOQ *only* for its stored procedure code generation capabilities. When you have a lot of stored procedures, it's almost impossible to bind to them without code generation, and jOOQ works very well out of the box, kind of like when you have a WSDL file (or something comparable), and you generate all the stubs with Axis or Metro, and so on."</em></p>
			<p>OK, now let's get started!</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor301"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter15">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter15</a>.</p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor302"/>Calling stored functions/procedures from jOOQ</h1>
			<p>Once you start dealing<a id="_idIndexMarker1562"/> with stored functions/procedures across different<a id="_idIndexMarker1563"/> database vendors, you'll be hit by the lack of standardization. For instance, the vendor-specific syntax for expressing functions/procedures, the wide variety of vendor-specific functions/procedure types, and different ways of supporting and treating the output parameters are just a few non-standard aspects of stored functions/procedures.</p>
			<p>Calling stored functions/procedures via plain JDBC code is not easy either, especially if advanced data types are involved (for instance, arrays or UDTs). But, as you already know, using the jOOQ DSL saves us from interacting directly with the JDBC API, so it saves us from making cutting-edge decisions regarding JDBC workarounds.</p>
			<p>The jOOQ DSL represents stored functions/procedures via the <strong class="source-inline">org.jooq.Routine</strong> API, so there is a common API for both. Whenever the jOOQ generator detects a stored function/procedure it generates (among other things) a dedicated class in the proper package (in our case, <strong class="source-inline">jooq.generated.routines</strong>) that reflects its name (for instance, by default, a stored function named <strong class="source-inline">get_emps_in_office()</strong> results in a class named <strong class="source-inline">GetEmpsInOffice</strong>) and extends the jOOQ <strong class="source-inline">AbstractRoutine</strong> class. The generated class exposes the API needed to call this stored function/procedure via jOOQ DSL. Moreover, as you'll see soon, calling a stored function/procedure can also be done in an anonymous procedural block via <strong class="source-inline">DSLContext.begin()</strong> and directly via <strong class="source-inline">DSLContext.call()</strong>. But, enough theory, next let's tackle some different kinds of stored functions/procedures<a id="_idIndexMarker1564"/> from the jOOQ perspective, and let's start<a id="_idIndexMarker1565"/> with stored functions.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor303"/>Stored functions</h2>
			<p>Stored functions return<a id="_idIndexMarker1566"/> a result (for instance, the result of a computation). They can be called in SQL statements and, usually, they don't support output (<strong class="source-inline">OUT</strong>) parameters. However, in Oracle and PostgreSQL, stored functions may have output parameters that can be interpreted as returned results. Moreover, until version 11, PostgreSQL supports only stored functions that combine the features of stored functions and procedures. On the other hand, PostgreSQL 11 and beyond, Oracle, MySQL, and SQL Server distinguish between stored functions and procedures.</p>
			<p>Next, let's see how we can call from jOOQ different kinds of stored functions expressed in one of these four dialects, and let's start by calling some scalar functions.</p>
			<h3>Scalar functions</h3>
			<p>A stored function that takes<a id="_idIndexMarker1567"/> none, one, or more parameters, and returns a single value<a id="_idIndexMarker1568"/> is commonly referred to as a scalar function. As a common practice, scalar functions encapsulate complex calculations that appear in many queries. Instead of expressing the calculation in every query, you can write a scalar function that encapsulates this calculation and uses it in each query. Roughly, the syntax of a scalar function is a variation of this skeleton:</p>
			<pre class="source-code">CREATE FUNCTION name (parameters)</pre>
			<pre class="source-code">RETURNS data_type AS</pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">    statements/computations</pre>
			<pre class="source-code">    RETURN value</pre>
			<pre class="source-code">END</pre>
			<p>For instance, a simple scalar function expressed in MySQL may look as follows:</p>
			<pre class="source-code">DELIMITER $$</pre>
			<pre class="source-code">CREATE FUNCTION `sale_price`(</pre>
			<pre class="source-code">  `quantity` INT, `list_price` REAL, `fraction_of_price` REAL)</pre>
			<pre class="source-code">  RETURNS REAL</pre>
			<pre class="source-code">  DETERMINISTIC</pre>
			<pre class="source-code">  BEGIN</pre>
			<pre class="source-code">    RETURN (`list_price` - </pre>
			<pre class="source-code">      (`list_price` * `fraction_of_price`)) * `quantity`;    </pre>
			<pre class="source-code">  END $$</pre>
			<pre class="source-code">DELIMITER ;</pre>
			<p>For this scalar function, the<a id="_idIndexMarker1569"/> jOOQ Code Generator produces a dedicated class<a id="_idIndexMarker1570"/> named <strong class="source-inline">jooq.generated.routines.SalePrice</strong>. Among its methods, this class exposes setters that allow us to provide the input parameters of the function. In our example, we will have <strong class="source-inline">setQuantity(Integer value)</strong>, <strong class="source-inline">setQuantity(Field&lt;Integer&gt; field)</strong>, <strong class="source-inline">setListPrice(Double value)</strong>, <strong class="source-inline">setListPrice(Field&lt;Double&gt; field)</strong>, <strong class="source-inline">setFractionOfPrice(Double value)</strong>, and <strong class="source-inline">setFractionOfPrice(Field&lt;Double&gt; field)</strong>. The function can be executed via jOOQ's well-known <strong class="source-inline">execute()</strong> methods. If the function already has a <strong class="source-inline">Configuration</strong> attached, then you can rely on <strong class="source-inline">execute()</strong> without parameters, otherwise use the <strong class="source-inline">execute(Configuration c)</strong> method as follows:</p>
			<pre class="source-code">SalePrice sp = new SalePrice();</pre>
			<pre class="source-code">sp.setQuantity(25);</pre>
			<pre class="source-code">sp.setListPrice(15.5);</pre>
			<pre class="source-code">sp.setFractionOfPrice(0.75);</pre>
			<pre class="source-code">sp.execute(ctx.configuration());</pre>
			<p>Getting the returned scalar result can be done via the <strong class="source-inline">getReturnValue()</strong> method. In this case, you can use it like this:</p>
			<pre class="source-code">double result = sp.getReturnValue();</pre>
			<p>As you just saw, each setter<a id="_idIndexMarker1571"/> has a flavor that gets a <strong class="source-inline">Field</strong> as an argument. This means that we can write something like this (check the first two setters):</p>
			<pre class="source-code">sp.setQuantity(field(select(PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">  .from(PRODUCT).where(PRODUCT.PRODUCT_ID.eq(1L))));</pre>
			<pre class="source-code">sp.setListPrice(field(select(PRODUCT.MSRP.coerce(Double.class))</pre>
			<pre class="source-code">  .from(PRODUCT).where(PRODUCT.PRODUCT_ID.eq(1L))));</pre>
			<pre class="source-code">sp.setFractionOfPrice(0.75);</pre>
			<pre class="source-code">sp.execute(ctx.configuration());</pre>
			<pre class="source-code">double result = sp.getReturnValue();</pre>
			<p>The previous examples are<a id="_idIndexMarker1572"/> useful if the routine has more than 254 parameters (which isn't allowed in Java), if there are default parameters, which users don't want to set, or if the parameters need to be set dynamically. Otherwise, most probably, you'll prefer to use the static convenience API.</p>
			<p>Writing these two examples in a more convenient/compact way can be done via the <strong class="source-inline">Routines.salePrice()</strong> static method. The <strong class="source-inline">jooq.generated.Routines</strong> class provides convenient static methods for accessing all stored functions/procedures that jOOQ has found in your database. In this case, the following two examples compact the previous examples (of course, you can shorten this example further by importing the <strong class="source-inline">jooq.generated.Routines.salePrice</strong> static):</p>
			<pre class="source-code">double sp = Routines.salePrice(</pre>
			<pre class="source-code">    ctx.configuration(), 25, 15.5, 0.75);</pre>
			<pre class="source-code">Field&lt;Float&gt; sp = Routines.salePrice(</pre>
			<pre class="source-code">  field(select(PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">         .from(PRODUCT).where(PRODUCT.PRODUCT_ID.eq(1L))),</pre>
			<pre class="source-code">  field(select(PRODUCT.MSRP.coerce(Double.class))</pre>
			<pre class="source-code">         .from(PRODUCT).where(PRODUCT.PRODUCT_ID.eq(1L))),</pre>
			<pre class="source-code">  val(0.75));</pre>
			<pre class="source-code">double sp = ctx.fetchValue(salePrice(</pre>
			<pre class="source-code"> field(select(PRODUCT.QUANTITY_IN_STOCK)</pre>
			<pre class="source-code">  .from(PRODUCT).where(PRODUCT.PRODUCT_ID.eq(1L))),</pre>
			<pre class="source-code"> field(select(PRODUCT.MSRP.coerce(Double.class))</pre>
			<pre class="source-code">  .from(PRODUCT).where(PRODUCT.PRODUCT_ID.eq(1L))),</pre>
			<pre class="source-code"> val(0.75)));</pre>
			<p>Scalar functions can be used in queries as <a id="_idIndexMarker1573"/>well. Here is an example<a id="_idIndexMarker1574"/> via another flavor of <strong class="source-inline">Routines.salePrice()</strong>:</p>
			<pre class="source-code">ctx.select(ORDERDETAIL.ORDER_ID,</pre>
			<pre class="source-code">    sum(salePrice(ORDERDETAIL.QUANTITY_ORDERED,</pre>
			<pre class="source-code">        ORDERDETAIL.PRICE_EACH.coerce(Double.class), </pre>
			<pre class="source-code">        val(0.75))).as("sum_sale_price"))</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .groupBy(ORDERDETAIL.ORDER_ID)</pre>
			<pre class="source-code">   .orderBy(field(name("sum_sale_price")).desc())</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>For MySQL, jOOQ renders the following plain SQL:</p>
			<pre class="source-code">SELECT `classicmodels`.`orderdetail`.`order_id`,</pre>
			<pre class="source-code">   sum(`classicmodels`.`sale_price`(</pre>
			<pre class="source-code">       `classicmodels`.`orderdetail`.`quantity_ordered`, </pre>
			<pre class="source-code">       `classicmodels`.`orderdetail`.`price_each`, 7.5E-1)) </pre>
			<pre class="source-code">          AS `sum_sale_price`</pre>
			<pre class="source-code">   FROM `classicmodels`.`orderdetail`</pre>
			<pre class="source-code">   GROUP BY `classicmodels`.`orderdetail`.`order_id`</pre>
			<pre class="source-code">   ORDER BY `sum_sale_price` DESC</pre>
			<p>You can practice this example in <em class="italic">ScalarFunction</em>.</p>
			<p>In this context, here is another <a id="_idIndexMarker1575"/>function that was written for PostgreSQL<a id="_idIndexMarker1576"/> that updates a <strong class="source-inline">PRODUCT.MSRP</strong> and returns it via <strong class="source-inline">UPDATE … RETURNING</strong> (do not confuse it with the function <strong class="source-inline">RETURN</strong> statement!):</p>
			<pre class="source-code">CREATE OR REPLACE FUNCTION "update_msrp" (</pre>
			<pre class="source-code">    "id" BIGINT, "debit" INTEGER) RETURNS REAL AS $$</pre>
			<pre class="source-code">    UPDATE "public"."product"</pre>
			<pre class="source-code">        SET "msrp" = "public"."product"."msrp" - "debit"</pre>
			<pre class="source-code">        WHERE "public"."product"."product_id" = "id"</pre>
			<pre class="source-code">        RETURNING "public"."product"."msrp";</pre>
			<pre class="source-code">$$ LANGUAGE SQL;</pre>
			<p>jOOQ can call such a function as you saw in the previous example. For instance, here it is called in a <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME, </pre>
			<pre class="source-code">           PRODUCT.MSRP.as("obsolete_msrp"), </pre>
			<pre class="source-code">           updateMsrp(PRODUCT.PRODUCT_ID, inline(50)))</pre>
			<pre class="source-code">   .from(PRODUCT).fetch();</pre>
			<p>And the rendered SQL is as follows:</p>
			<pre class="source-code">SELECT "public"."product"."product_id",</pre>
			<pre class="source-code">       "public"."product"."product_name",</pre>
			<pre class="source-code">       "public"."product"."msrp" AS "obsolete_msrp",</pre>
			<pre class="source-code">               "public"."update_msrp"("id" := "public"</pre>
			<pre class="source-code">                   ."product"."product_id", "debit" := 50)</pre>
			<pre class="source-code">FROM "public"."product"</pre>
			<p>You can practice this example in <em class="italic">UpdateFunction</em> for PostgreSQL.</p>
			<p>If your scalar functions are under Oracle, then you can take advantage of a nice Oracle<a id="_idIndexMarker1577"/> feature known as <em class="italic">scalar subquery caching</em>. Basically, this <a id="_idIndexMarker1578"/>feature renders the calls<a id="_idIndexMarker1579"/> of stored functions wrapped in SQL statements as a scalar subquery. This feature avoids switching between PL/SQL and SQL contexts and this may result in better performance.</p>
			<p>Consider the following scalar function:</p>
			<pre class="source-code">CREATE OR REPLACE NONEDITIONABLE FUNCTION </pre>
			<pre class="source-code">     "card_commission"("card_type" IN VARCHAR2)</pre>
			<pre class="source-code">RETURN NUMBER IS</pre>
			<pre class="source-code"> "commission" NUMBER := 0;</pre>
			<pre class="source-code"> BEGIN</pre>
			<pre class="source-code">   RETURN CASE "card_type"</pre>
			<pre class="source-code">     WHEN 'VisaElectron' THEN .15</pre>
			<pre class="source-code">     WHEN 'Mastercard' THEN .22</pre>
			<pre class="source-code">     ELSE .25</pre>
			<pre class="source-code">   END;</pre>
			<pre class="source-code">END;</pre>
			<p>Calling this scalar function in a query can be done here:</p>
			<pre class="source-code">ctx.select(cardCommission(BANK_TRANSACTION.CARD_TYPE))</pre>
			<pre class="source-code">   .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">List&lt;BigDecimal&gt; commission = ctx.fetchValues(</pre>
			<pre class="source-code">  select(cardCommission(BANK_TRANSACTION.CARD_TYPE))</pre>
			<pre class="source-code">    .from(BANK_TRANSACTION));</pre>
			<p>But keep in mind Lukas Eder's note: <em class="italic">"Just in case, scalar subquery caching isn't documented in Oracle, as far as I know. The context switch isn't avoided entirely, but it happens only once per scalar subquery input value, and thus per function argument value, and per query. So, instead of having 1 switch per row, we now have 1 switch per function input value."</em></p>
			<p>Each time we execute<a id="_idIndexMarker1580"/> this code, jOOQ renders a query <a id="_idIndexMarker1581"/>that requires switching between PL/SQL and SQL contexts in order to execute the scalar function:</p>
			<pre class="source-code">SELECT "CLASSICMODELS"."card_commission"(</pre>
			<pre class="source-code">       "CLASSICMODELS"."BANK_TRANSACTION"."CARD_TYPE")</pre>
			<pre class="source-code">FROM "CLASSICMODELS"."BANK_TRANSACTION"</pre>
			<p>But jOOQ has the <strong class="source-inline">withRenderScalarSubqueriesForStoredFunctions()</strong> flag-setting that is by default set to <strong class="source-inline">false</strong>. Once we set it to <strong class="source-inline">true</strong>, jOOQ turns on Oracle's <em class="italic">scalar subquery caching</em> feature. In the following<a id="_idIndexMarker1582"/> example, we turn this feature on only for the current SQL:</p>
			<pre class="source-code">ctx.configuration().derive(new Settings()</pre>
			<pre class="source-code">   .withRenderScalarSubqueriesForStoredFunctions(true))</pre>
			<pre class="source-code">   .dsl()</pre>
			<pre class="source-code">   .select(cardCommission(BANK_TRANSACTION.CARD_TYPE))</pre>
			<pre class="source-code">   .from(BANK_TRANSACTION)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This time, the call of the <strong class="source-inline">cardCommission()</strong> stored function is rendered as a scalar subquery:</p>
			<pre class="source-code">SELECT</pre>
			<pre class="source-code">  (SELECT "CLASSICMODELS"."card_commission"(</pre>
			<pre class="source-code">    "CLASSICMODELS"."BANK_TRANSACTION"."CARD_TYPE")</pre>
			<pre class="source-code">      FROM DUAL)</pre>
			<pre class="source-code">FROM "CLASSICMODELS"."BANK_TRANSACTION"</pre>
			<p>You can <a id="_idIndexMarker1583"/>practice<a id="_idIndexMarker1584"/> this example in <em class="italic">ScalarSubqueryCaching</em> for Oracle.</p>
			<h3>Functions returning arrays</h3>
			<p>PostgreSQL is a convenient<a id="_idIndexMarker1585"/> way to write a function that returns an array. For instance, here is a function returning <strong class="source-inline">DEPARTMENT.TOPIC</strong>, which is declared in our schema as an array of type <strong class="source-inline">TEXT[]</strong>:</p>
			<pre class="source-code">CREATE OR REPLACE FUNCTION "department_topic_arr" </pre>
			<pre class="source-code">   (IN "id" BIGINT)</pre>
			<pre class="source-code">RETURNS TEXT[] </pre>
			<pre class="source-code">AS $$</pre>
			<pre class="source-code">  SELECT "public"."department"."topic"</pre>
			<pre class="source-code">      FROM "public"."department" WHERE </pre>
			<pre class="source-code">           "public"."department"."department_id" = "id"</pre>
			<pre class="source-code">$$ LANGUAGE SQL; </pre>
			<p>Calling this function in <strong class="source-inline">SELECT</strong> via the dedicated method, <strong class="source-inline">departmentTopicArr()</strong>, generated by jOOQ in <strong class="source-inline">Routines</strong> can be done by unnesting the returned array as in the following examples:</p>
			<pre class="source-code">ctx.select().from(unnest(departmentTopicArr(2L))</pre>
			<pre class="source-code">   .as("t")).fetch();</pre>
			<pre class="source-code">ctx.fetch(unnest(departmentTopicArr(2L)).as("t"));</pre>
			<p>Next, let's take a function having an anonymous parameter (no explicit name) that builds and returns an array:</p>
			<pre class="source-code">CREATE OR REPLACE FUNCTION "employee_office_arr"(VARCHAR(10))</pre>
			<pre class="source-code">  RETURNS BIGINT[] </pre>
			<pre class="source-code">AS $$</pre>
			<pre class="source-code">  SELECT ARRAY(SELECT "public"."employee"."employee_number"</pre>
			<pre class="source-code">    FROM "public"."employee" WHERE "public"."employee"</pre>
			<pre class="source-code">         ."office_code" = $1)</pre>
			<pre class="source-code">$$ LANGUAGE sql;</pre>
			<p>This time, let's instantiate <strong class="source-inline">EmployeeOfficeArr</strong>, and let's pass<a id="_idIndexMarker1586"/> the required parameter via a setter:</p>
			<pre class="source-code">EmployeeOfficeArr eoa = new EmployeeOfficeArr();</pre>
			<pre class="source-code">eoa.set__1("1");</pre>
			<pre class="source-code">eoa.execute(ctx.configuration());</pre>
			<pre class="source-code">Long[] result = eoa.getReturnValue();</pre>
			<p>Since the function's parameter doesn't have a name, jOOQ has used its default implementation and generated a <strong class="source-inline">set__1()</strong> setter. If you had two no-name parameters, then jOOQ would generate <strong class="source-inline">set__1()</strong> and <strong class="source-inline">set__2()</strong>, and so on. In other words, jOOQ generates setters based on parameter positions starting from 1.</p>
			<p>On the other hand, using the generated <strong class="source-inline">Routines.employeeOfficeArr()</strong> in a <strong class="source-inline">SELECT</strong> query can be done as follows:</p>
			<pre class="source-code">ctx.select(field(name("t", "en")), sum(SALE.SALE_))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .rightJoin(unnest(employeeOfficeArr("1")).as("t", "en"))</pre>
			<pre class="source-code">     .on(field(name("t", "en")).eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .groupBy(field(name("t", "en"))).fetch();        </pre>
			<p>For PostgreSQL, jOOQ renders this SQL:</p>
			<pre class="source-code">SELECT "t"."en",sum("public"."sale"."sale")</pre>
			<pre class="source-code">FROM "public"."sale"</pre>
			<pre class="source-code">RIGHT OUTER JOIN unnest("public"."employee_office_arr"('1')) </pre>
			<pre class="source-code">AS "t" ("en") </pre>
			<pre class="source-code">ON "t"."en" = "public"."sale"."employee_number"</pre>
			<pre class="source-code">GROUP BY "t"."en"</pre>
			<p>You can practice<a id="_idIndexMarker1587"/> these examples in <em class="italic">ArrayFunction</em> for PostgreSQL.</p>
			<h3>Functions with output parameters</h3>
			<p>As we said earlier, PostgreSQL and Oracle<a id="_idIndexMarker1588"/> allow output parameters in functions. Here is an example in PostgreSQL:</p>
			<pre class="source-code">CREATE OR REPLACE FUNCTION "get_salary_stat"(</pre>
			<pre class="source-code">    OUT "min_sal" INT, OUT "max_sal" INT, OUT "avg_sal" NUMERIC) </pre>
			<pre class="source-code">  LANGUAGE plpgsql</pre>
			<pre class="source-code">  AS $$</pre>
			<pre class="source-code">  BEGIN  </pre>
			<pre class="source-code">    SELECT MIN("public"."employee"."salary"),</pre>
			<pre class="source-code">           MAX("public"."employee"."salary"),</pre>
			<pre class="source-code">           AVG("public"."employee"."salary")::NUMERIC(7,2)</pre>
			<pre class="source-code">      INTO "min_sal", "max_sal", "avg_sal"</pre>
			<pre class="source-code">      FROM "public"."employee";</pre>
			<pre class="source-code">  END;</pre>
			<pre class="source-code">$$;</pre>
			<p>This function doesn't have a <strong class="source-inline">RETURN</strong>, but it has three <strong class="source-inline">OUT</strong> parameters that help us to obtain the results<a id="_idIndexMarker1589"/> of execution. For each such parameter, jOOQ generates a getter, so we can call it via the generated <strong class="source-inline">jooq.generated.routines.GetSalaryStat</strong> like this:</p>
			<pre class="source-code">GetSalaryStat salStat = new GetSalaryStat();</pre>
			<pre class="source-code">salStat.execute(ctx.configuration());</pre>
			<pre class="source-code">Integer minSal = salStat.getMinSal();</pre>
			<pre class="source-code">Integer maxSal = salStat.getMaxSal();</pre>
			<pre class="source-code">BigDecimal avgSal = salStat.getAvgSal();</pre>
			<p>This code (more precisely the <strong class="source-inline">execute()</strong> call) leads to the following <strong class="source-inline">SELECT</strong> (or <strong class="source-inline">CALL</strong>, in Oracle):</p>
			<pre class="source-code">SELECT "min_sal", "max_sal", "avg_sal" </pre>
			<pre class="source-code">FROM "public"."get_salary_stat"()</pre>
			<p>Here's the same result via <strong class="source-inline">Routines.getSalaryStat(Configuration c)</strong>:</p>
			<pre class="source-code">GetSalaryStat salStat = getSalaryStat(ctx.configuration());</pre>
			<pre class="source-code">// call the getters</pre>
			<p>Here are two more examples:</p>
			<pre class="source-code">Integer minSal = ctx.fetchValue(val(getSalaryStat(</pre>
			<pre class="source-code">      ctx.configuration()).getMinSal()));</pre>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME,   </pre>
			<pre class="source-code">           EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.SALARY.coerce(BigDecimal.class)</pre>
			<pre class="source-code">      .gt(getSalaryStat(ctx.configuration()).getAvgSal()))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>But pay attention that both<a id="_idIndexMarker1590"/> of these examples lead to two <strong class="source-inline">SELECT</strong> statements (or, a <strong class="source-inline">CALL</strong> and a <strong class="source-inline">SELECT</strong> statement in Oracle) since functions with output parameters cannot be called from plain SQL. In other words, jOOQ calls the routine and fetches the <strong class="source-inline">OUT</strong> parameters as you can see next:</p>
			<pre class="source-code">SELECT "min_sal","max_sal","avg_sal"</pre>
			<pre class="source-code">FROM "public"."get_salary_stat"()</pre>
			<p>And, afterward, it executes the <strong class="source-inline">SELECT</strong> that uses the results extracted from the output parameters. The following <strong class="source-inline">SELECT</strong> fits our second example (65652.17 is the average salary computed via <strong class="source-inline">getSalaryStat(Configuration c)</strong>):</p>
			<pre class="source-code">SELECT "public"."employee"."first_name",</pre>
			<pre class="source-code">       "public"."employee"."last_name",</pre>
			<pre class="source-code">       "public"."employee"."salary"</pre>
			<pre class="source-code">FROM "public"."employee"</pre>
			<pre class="source-code">WHERE "public"."employee"."salary" &gt; 65652.17</pre>
			<p>Lukas Eder shared: <em class="italic">"In Oracle, functions with OUT parameters aren't "SQL callable," though... In PostgreSQL, they're just "syntax sugar" (or un-sugar, depending on taste) for a function returning a record."</em></p>
			<p>You can practice these examples in <em class="italic">InOutFunction</em> for PostgreSQL (here, you can find an <strong class="source-inline">IN OUT</strong> example as well). </p>
			<p>So, using <strong class="source-inline">OUT</strong> (or <strong class="source-inline">IN OUT</strong>) parameters in functions is not such a great idea and must be avoided. As Oracle<a id="_idIndexMarker1591"/> mentioned, besides preventing a function from being used in SQL queries (more details here: <a href="https://oracle-base.com/articles/12c/with-clause-enhancements-12cr1">https://oracle-base.com/articles/12c/with-clause-enhancements-12cr1</a>), the presence of output parameters in a function prevents a function from being marked as a <strong class="source-inline">DETERMINISTIC</strong> function or used as a result-cached function. Unlike PostgreSQL, Oracle functions having output parameters must have an explicit <strong class="source-inline">RETURN</strong>. Next to the jOOQ getters dedicated to output parameters, you can call <strong class="source-inline">getReturnValue()</strong> to obtain the result returned explicitly via the <strong class="source-inline">RETURN</strong> statement. When this book was written, functions with <strong class="source-inline">OUT</strong> parameters couldn't be called in jOOQ from plain SQL. Follow this feature request here: <a href="https://github.com/jOOQ/jOOQ/issues/3426">https://github.com/jOOQ/jOOQ/issues/3426</a>. </p>
			<p>You can practice<a id="_idIndexMarker1592"/> an example in <em class="italic">InOutFunction</em> for Oracle (here, you can find an <strong class="source-inline">IN OUT</strong> example too).</p>
			<h3>Polymorphic functions</h3>
			<p>Some databases support the so-called polymorphic functions<a id="_idIndexMarker1593"/> that accept and return polymorphic<a id="_idIndexMarker1594"/> types. For instance, PostgreSQL supports the following polymorphic types: <strong class="source-inline">anyelement</strong>, <strong class="source-inline">anyarray</strong>, <strong class="source-inline">anynonarray</strong>, <strong class="source-inline">anyenum</strong>, and <strong class="source-inline">anyrange</strong>. Here is an example that builds an array from two passed arbitrary data type elements:</p>
			<pre class="source-code">CREATE FUNCTION "make_array"(anyelement, anyelement) </pre>
			<pre class="source-code">RETURNS anyarray </pre>
			<pre class="source-code">AS $$</pre>
			<pre class="source-code">  SELECT ARRAY[$1, $2];</pre>
			<pre class="source-code">$$ LANGUAGE SQL;</pre>
			<p>Calling this function from jOOQ can be done as follows (notice the positional setters at work again):</p>
			<pre class="source-code">MakeArray ma = new MakeArray();</pre>
			<pre class="source-code">ma.set__1(1);</pre>
			<pre class="source-code">ma.set__2(2);</pre>
			<pre class="source-code">ma.execute(ctx.configuration());</pre>
			<p>The returned result is <strong class="source-inline">org.postgresql.jdbc.PgArray</strong>:</p>
			<pre class="source-code">PgArray arr = (PgArray) ma.getReturnValue();</pre>
			<p>In the bundled code you can see further processing of this array. For now, let's call <strong class="source-inline">make_array()</strong> from <strong class="source-inline">SELECT</strong> to build an array of integers and an array of strings:</p>
			<pre class="source-code">ctx.select(makeArray(1, 2).as("ia"),</pre>
			<pre class="source-code">           makeArray("a", "b").as("ta")).fetch();</pre>
			<p>How about a function that combines<a id="_idIndexMarker1595"/> polymorphic types<a id="_idIndexMarker1596"/> and output parameters? Here is one:</p>
			<pre class="source-code">CREATE FUNCTION "dup"(IN "f1" anyelement, </pre>
			<pre class="source-code">   OUT "f2" anyelement, OUT "f3" anyarray)</pre>
			<pre class="source-code">AS 'select $1, array[$1,$1]' LANGUAGE sql;</pre>
			<p>Call it via jOOQ:</p>
			<pre class="source-code">Dup dup = new Dup();</pre>
			<pre class="source-code">dup.setF1(10);</pre>
			<pre class="source-code">dup.execute(ctx.configuration());</pre>
			<pre class="source-code">// call here getF2() and/or getF3()</pre>
			<p>Or use it in a <strong class="source-inline">SELECT</strong> (remember from the previous section that this leads to two statements against the database):</p>
			<pre class="source-code">ctx.select(val(dup(ctx.configuration(), 10).getF2())).fetch();</pre>
			<pre class="source-code">ctx.fetchValue(val(dup(ctx.configuration(), 10).getF2()));</pre>
			<p>You can practice these examples in <em class="italic">PolymorphicFunction</em> for PostgreSQL.</p>
			<h3>Functions returning explicit cursors</h3>
			<p>A function can return<a id="_idIndexMarker1597"/> an explicit cursor (an explicit pointer that points to a result of a query) as well. Most probably, you're familiar with PostgreSQL <strong class="source-inline">REFCURSOR</strong> and Oracle <strong class="source-inline">SYS_REFCURSOR</strong>. Here is an example for Oracle:</p>
			<pre class="source-code">CREATE OR REPLACE NONEDITIONABLE FUNCTION</pre>
			<pre class="source-code">   "GET_CUSTOMER" ("cl" IN NUMBER)</pre>
			<pre class="source-code">  RETURN SYS_REFCURSOR</pre>
			<pre class="source-code">       AS  "cur"  SYS_REFCURSOR;</pre>
			<pre class="source-code">  BEGIN</pre>
			<pre class="source-code">      OPEN "cur" FOR</pre>
			<pre class="source-code">           SELECT *</pre>
			<pre class="source-code">           FROM "CUSTOMER"</pre>
			<pre class="source-code">                       WHERE "CUSTOMER"."CREDIT_LIMIT" &gt; "cl"</pre>
			<pre class="source-code">           ORDER BY "CUSTOMER"."CUSTOMER_NAME";</pre>
			<pre class="source-code">   </pre>
			<pre class="source-code">      RETURN "cur";</pre>
			<pre class="source-code">  END;</pre>
			<p>Calling this function via the generated <strong class="source-inline">jooq.generated.routines.GetCustomer</strong> can be done as follows:</p>
			<pre class="source-code">GetCustomer customers = new GetCustomer();</pre>
			<pre class="source-code">customers.setCl(120000);</pre>
			<pre class="source-code">customers.execute(ctx.configuration());</pre>
			<pre class="source-code">Result&lt;Record&gt; result = customers.getReturnValue();</pre>
			<p>The result is mapped by jOOQ to <strong class="source-inline">Result&lt;Record&gt;</strong>, so a list of records is fitted entirely into memory. For better accommodation of large datasets, jOOQ has some pending feature requests to stream the cursors, so you can check the progress of issues #4503 and #4472 on the jOOQ repository. Alternatively, you can wrap the returned cursor in a table-valued function and fetch the results via a <strong class="source-inline">SELECT</strong> statement using jOOQ's <strong class="source-inline">ResultQuery.fetchLazy()</strong> method, as you saw in <a href="B16833_08.xhtml#_idTextAnchor128"><em class="italic">Chapter 8</em></a>, <em class="italic">Fetching and Mapping</em>.</p>
			<p>Now, going further, you can loop the <strong class="source-inline">Result&lt;Record&gt;</strong> and process each record, but to access a certain column (for instance, the customer name) of a certain row (for instance, the first row), then you can use <strong class="source-inline">getValue()</strong> or <strong class="source-inline">get()</strong> as here:</p>
			<pre class="source-code">String name = (String) result.getValue(0, "CUSTOMER_NAME");</pre>
			<pre class="source-code">String name = result.get(0).get("CUSTOMER_NAME", String.class);</pre>
			<p>To get multiple<a id="_idIndexMarker1598"/> names (or other columns) rely on <strong class="source-inline">getValues()</strong>, which comes in many flavors that you can find in the official documentation.</p>
			<p>Obtaining the same <strong class="source-inline">Result&lt;Record&gt;</strong> can be done more compactly via the generated static <strong class="source-inline">Routines.getCustomer()</strong>:</p>
			<pre class="source-code">Result&lt;Record&gt; result = getCustomer(</pre>
			<pre class="source-code">   ctx.configuration(), 120000);</pre>
			<p>If you need a <strong class="source-inline">Table</strong> instead of this <strong class="source-inline">Result&lt;Record&gt;</strong>, then simply rely on <strong class="source-inline">org.jooq.impl.DSL.table</strong> as in the following two examples:</p>
			<pre class="source-code">Table&lt;?&gt; t = table(result);</pre>
			<pre class="source-code">Table&lt;CustomerRecord&gt; t = table(result.into(CUSTOMER));</pre>
			<p>Next, you can use <strong class="source-inline">t</strong> in queries like any regular <strong class="source-inline">Table</strong>:</p>
			<pre class="source-code">ctx.select(CUSTOMERDETAIL.ADDRESS_LINE_FIRST, </pre>
			<pre class="source-code">           CUSTOMERDETAIL.POSTAL_CODE,</pre>
			<pre class="source-code">           t.field(name("CUSTOMER_NAME")))</pre>
			<pre class="source-code">   .from(t)</pre>
			<pre class="source-code">   .join(CUSTOMERDETAIL)</pre>
			<pre class="source-code">    .on(CUSTOMERDETAIL.CUSTOMER_NUMBER.eq(</pre>
			<pre class="source-code">        t.field(name("CUSTOMER_NUMBER"), Long.class)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>On the other hand, another flavor of <strong class="source-inline">Routines.getCustomer()</strong> returns the result wrapped in a <strong class="source-inline">Field</strong> as <strong class="source-inline">Field&lt;Result&lt;Record&gt;&gt;</strong>. This allows us to use this result as a <strong class="source-inline">Field</strong>. For instance, here is a <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">ctx.select(getCustomer(field(</pre>
			<pre class="source-code">     select(avg(CUSTOMER.CREDIT_LIMIT))</pre>
			<pre class="source-code">        .from(CUSTOMER)))).fetch();    </pre>
			<p>You can practice these examples in <em class="italic">CursorFunction</em> for Oracle.</p>
			<p>How about a function<a id="_idIndexMarker1599"/> that returns multiple cursors? Here is a sample that was written for PostgreSQL:</p>
			<pre class="source-code">CREATE OR REPLACE FUNCTION "get_offices_multiple"() </pre>
			<pre class="source-code">  RETURNS SETOF REFCURSOR </pre>
			<pre class="source-code">AS $$</pre>
			<pre class="source-code"> DECLARE</pre>
			<pre class="source-code">  "ref1" REFCURSOR;           </pre>
			<pre class="source-code">  "ref2" REFCURSOR;           </pre>
			<pre class="source-code"> BEGIN</pre>
			<pre class="source-code"> OPEN "ref1" FOR </pre>
			<pre class="source-code">  SELECT "public"."office"."city", "public"."office"."country" </pre>
			<pre class="source-code">  FROM "public"."office" </pre>
			<pre class="source-code">  WHERE "public"."office"."internal_budget" &lt; 100000;  </pre>
			<pre class="source-code">  RETURN NEXT "ref1"; </pre>
			<pre class="source-code"> OPEN "ref2" FOR </pre>
			<pre class="source-code">  SELECT "public"."office"."city", "public"."office"."country"</pre>
			<pre class="source-code">  FROM "public"."office" </pre>
			<pre class="source-code">  WHERE "public"."office"."internal_budget" &gt; 100000;  </pre>
			<pre class="source-code"> RETURN NEXT "ref2";    </pre>
			<pre class="source-code">END;</pre>
			<pre class="source-code">$$ LANGUAGE plpgsql;</pre>
			<p>In this case, each cursor produces a <strong class="source-inline">Result&lt;Record&gt;</strong> wrapped in a generated <strong class="source-inline">Record</strong> class. Here, we have<a id="_idIndexMarker1600"/> two cursors, therefore two <strong class="source-inline">Result&lt;Record&gt;</strong> wrapped in two instances of the generated <strong class="source-inline">GetOfficesMultipleRecord</strong>. When we call <strong class="source-inline">Routines.getOfficesMultiple(Configuration c)</strong> we get a <strong class="source-inline">Result&lt;GetOfficesMultipleRecord&gt;</strong> that can be expanded as follows:</p>
			<pre class="source-code">Result&lt;GetOfficesMultipleRecord&gt; results = </pre>
			<pre class="source-code">        getOfficesMultiple(ctx.configuration());</pre>
			<pre class="source-code">for (GetOfficesMultipleRecord result : results) {</pre>
			<pre class="source-code">  Result&lt;Record&gt; records = result.getGetOfficesMultiple();</pre>
			<pre class="source-code">  System.out.println("-------------------------");</pre>
			<pre class="source-code">  for (Record r : records) {</pre>
			<pre class="source-code">    System.out.println(r.get("city") + ", " + r.get("country"));</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>You can practice these examples in <em class="italic">CursorFunction</em> for PostgreSQL.</p>
			<h3>Table-valued functions</h3>
			<p>Apart from database views, one<a id="_idIndexMarker1601"/> of the underrated features of SQL is table-valued functions. This is not the first<a id="_idIndexMarker1602"/> time in this book that we've discussed this feature, but this time, let's add a few more details. So, a table-valued function is a function that returns a set of data as a table data type. The returned table can be used just like a regular table.</p>
			<p>Table-valued functions are not supported in MySQL, but they are supported in PostgreSQL, Oracle, and SQL Server. Next is a snippet of code from a PostgreSQL table-valued function (notice the <strong class="source-inline">RETURNS TABLE</strong> syntax, which indicates that the <strong class="source-inline">SELECT</strong> query from the function returns the data as a table to whatever calls the function):</p>
			<pre class="source-code">CREATE OR REPLACE FUNCTION "product_of_product_line"(</pre>
			<pre class="source-code">  IN "p_line_in" VARCHAR)</pre>
			<pre class="source-code">RETURNS TABLE("p_id" BIGINT, "p_name" VARCHAR, </pre>
			<pre class="source-code">              "p_line" VARCHAR) LANGUAGE plpgsql </pre>
			<pre class="source-code">AS $$ </pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">  RETURN QUERY</pre>
			<pre class="source-code">  SELECT ...;     </pre>
			<pre class="source-code">  END; </pre>
			<pre class="source-code">$$;</pre>
			<p>By default, the jOOQ Code Generator will generate for this function a class named <strong class="source-inline">ProductOfProductLine</strong> in the <strong class="source-inline">jooq.generated.tables</strong> package, not in the <strong class="source-inline">jooq.generated.routines</strong> package. The explanation is simple; jOOQ (like most databases) treats table-valued functions as ordinary tables that can be used in the <strong class="source-inline">FROM</strong> clause of <strong class="source-inline">SELECT</strong> like any other table. An exception from this practice is Oracle, where it is quite common to treat them as standalone routines – in this context, jOOQ has a flag setting that allows us to indicate whether table-valued functions should be treated as ordinary tables (generated in <strong class="source-inline">jooq.generated.tables</strong>) or as plain routines (generated in <strong class="source-inline">jooq.generated.routines</strong>). This is detailed in <a href="B16833_06.xhtml#_idTextAnchor093"><em class="italic">Chapter 6</em></a>, <em class="italic">Tackling Different Kinds of JOIN Statements</em>.</p>
			<p>Calling a table-valued function (with arguments) can be done via the <strong class="source-inline">call()</strong> method:</p>
			<pre class="source-code">ProductOfProductLine popl = new ProductOfProductLine();</pre>
			<pre class="source-code">Table&lt;ProductOfProductLineRecord&gt; t = popl.call("Trains");</pre>
			<pre class="source-code">Result&lt;ProductOfProductLineRecord&gt; r = </pre>
			<pre class="source-code">   ctx.fetch(popl.call("Trains"));</pre>
			<pre class="source-code">Result&lt;ProductOfProductLineRecord&gt; r = </pre>
			<pre class="source-code">   ctx.selectFrom(popl.call("Trains")).fetch();</pre>
			<p>In queries, we may<a id="_idIndexMarker1603"/> prefer to use the <strong class="source-inline">PRODUCT_OF_PRODUCT_LINE</strong> static field that<a id="_idIndexMarker1604"/> was generated by the jOOQ generator in <strong class="source-inline">ProductOfProductLine</strong>. Both of the following examples produce the same SQL:</p>
			<pre class="source-code">ctx.selectFrom(PRODUCT_OF_PRODUCT_LINE.call("Trains"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">ctx.selectFrom(PRODUCT_OF_PRODUCT_LINE(val("Trains")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here are two more examples of calling this table-valued function in the <strong class="source-inline">FROM</strong> clause:</p>
			<pre class="source-code">ctx.selectFrom(PRODUCT_OF_PRODUCT_LINE.call("Trains"))</pre>
			<pre class="source-code">   .where(PRODUCT_OF_PRODUCT_LINE.P_NAME.like("1962%"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">ctx.select(PRODUCT_OF_PRODUCT_LINE.P_ID, </pre>
			<pre class="source-code">           PRODUCT_OF_PRODUCT_LINE.P_NAME)</pre>
			<pre class="source-code">   .from(PRODUCT_OF_PRODUCT_LINE.call("Classic Cars"))</pre>
			<pre class="source-code">   .where(PRODUCT_OF_PRODUCT_LINE.P_ID.gt(100L))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Since a table-valued function returns a table, we should be able to use them in joins. But the regular <strong class="source-inline">JOIN</strong> feature doesn't allow us to join a table-valued function, so we need another approach. Here is where <strong class="source-inline">CROSS APPLY</strong> and <strong class="source-inline">OUTER APPLY</strong> (or <strong class="source-inline">LATERAL</strong>) enter into the scene. In <a href="B16833_06.xhtml#_idTextAnchor093"><em class="italic">Chapter 6</em></a>, <em class="italic">Tackling Different Kinds of JOIN Statements</em>, you saw an example of using <strong class="source-inline">CROSS</strong>/<strong class="source-inline">OUTER APPLY</strong> to solve the popular task of joining two tables based on the results of a TOP-N query. So, <strong class="source-inline">CROSS</strong>/<strong class="source-inline">OUTER APPLY</strong> allows us to combine in a query the results returned by a table-valued function with the results of other tables<a id="_idIndexMarker1605"/> or, in short, to join table-valued functions<a id="_idIndexMarker1606"/> to other tables.</p>
			<p>For instance, let's use <strong class="source-inline">CROSS</strong>/<strong class="source-inline">OUTER APPLY</strong> (you can think of it as a <strong class="source-inline">Stream.flatMap()</strong> in Java) to join the <strong class="source-inline">PRODUCTLINE</strong> table to our table-valued function. Let's say that we have added a new <strong class="source-inline">PRODUCTLINE</strong> without products named <em class="italic">Helicopters</em> and let's see how <strong class="source-inline">CROSS APPLY</strong> works: </p>
			<pre class="source-code">ctx.select(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE</pre>
			<pre class="source-code">   .TEXT_DESCRIPTION, PRODUCT_OF_PRODUCT_LINE.asterisk())</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .crossApply(PRODUCT_OF_PRODUCT_LINE(</pre>
			<pre class="source-code">               PRODUCTLINE.PRODUCT_LINE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Since the <em class="italic">Helicopters</em> product line has no products, <strong class="source-inline">CROSS APPLY</strong> will not fetch it because <strong class="source-inline">CROSS APPLY</strong> acts as <strong class="source-inline">CROSS JOIN LATERAL</strong>. How about <strong class="source-inline">OUTER APPLY</strong>?</p>
			<pre class="source-code">ctx.select(PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE</pre>
			<pre class="source-code">     .TEXT_DESCRIPTION, PRODUCT_OF_PRODUCT_LINE.asterisk())</pre>
			<pre class="source-code">   .from(PRODUCTLINE)</pre>
			<pre class="source-code">   .outerApply(PRODUCT_OF_PRODUCT_LINE(</pre>
			<pre class="source-code">               PRODUCTLINE.PRODUCT_LINE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>On the other hand, <strong class="source-inline">OUTER APPLY</strong> acts as <strong class="source-inline">LEFT OUTER JOIN LATERAL</strong>, so the <em class="italic">Helicopters</em> product line is returned as well.</p>
			<p>Lukas Eder shared an opinion here: <em class="italic">"In fact, for historic reasons, APPLY or LATERAL is optional in at least Db2, Oracle, and PostgreSQL, under some conditions. SQL Server had APPLY for a long time, but the others introduced LATERAL only relatively recently. I personally don't understand the value of making LATERAL explicit. It's always clear what an implicit LATERAL means..."</em></p>
			<p>You can check out these examples<a id="_idIndexMarker1607"/> in the bundled<a id="_idIndexMarker1608"/> code, <em class="italic">TableValuedFunction</em> for PostgreSQL, Oracle, and SQL Server.</p>
			<h3>Oracle's package</h3>
			<p>Oracle allows<a id="_idIndexMarker1609"/> us to group the functions/procedures that are commonly logically related into a package. A package has two parts: the first part contains<a id="_idIndexMarker1610"/> the public items and is known as the <em class="italic">package specification</em>, while the second part, known as the <em class="italic">package body</em>, provides the code of the cursors<a id="_idIndexMarker1611"/> or subprograms declared in the package specification. If no cursors/subprograms were declared in the package specification, then the package body can be skipped. If you are not an Oracle fan, then the following syntax should help you to digest this topic a little bit easier:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/Figure_15.2.jpg" alt="Figure 15.2 – Syntax of Oracle package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2 – Syntax of Oracle package</p>
			<p>Lukas Eder shared<a id="_idIndexMarker1612"/> an analogy that's useful to better understand this topic: <em class="italic">"If it helps, package specifications are like interfaces, and bodies are like singleton instances, kind of. In a way, like this</em>: <a href="https://twitter.com/lukaseder/status/1443855980693962755">https://twitter.com/lukaseder/status/1443855980693962755</a>."</p>
			<p>Packages sustain modularity, facilitate clear design, and increase code maintainability by hiding the implementation details in the package body. Moreover, packages are loaded into memory as a whole at the first invocation of a function/procedure so any subsequent invocations of functions/procedures from this package require no disk I/O. While more information on using Oracle packages<a id="_idIndexMarker1613"/> is available in the official documentation, let's have an example:</p>
			<pre class="source-code">CREATE OR REPLACE PACKAGE "DEPARTMENT_PKG" AS</pre>
			<pre class="source-code"> TYPE "BGT" IS RECORD ("LOCAL_BUDGET" FLOAT, "CASH" FLOAT);</pre>
			<pre class="source-code">  FUNCTION "GET_BGT"("p_profit" IN FLOAT)</pre>
			<pre class="source-code">    RETURN "BGT";</pre>
			<pre class="source-code">  FUNCTION "GET_MAX_CASH"</pre>
			<pre class="source-code">    RETURN FLOAT; </pre>
			<pre class="source-code">END "DEPARTMENT_PKG";</pre>
			<pre class="source-code">/</pre>
			<pre class="source-code">CREATE OR REPLACE PACKAGE BODY "DEPARTMENT_PKG"</pre>
			<pre class="source-code">-- check bundled code for this skipped part</pre>
			<pre class="source-code">END"DEPARTMENT_PKG";</pre>
			<pre class="source-code">/</pre>
			<p>A spicy tip from Lukas Eder: <em class="italic">"The '</em><strong class="source-inline">/</strong><em class="italic">' is a SQL*Plus 'spool' token (also supported by SQL Developer), and not an actual PL/SQL syntax element. For example, it doesn't work in DBeaver.</em></p>
			<p>And, another<a id="_idIndexMarker1614"/> tip regarding quoted identifiers: <em class="italic">Might be a good reminder that, to be better interoperable with non-jOOQ code, perhaps not using quoted identifiers is better. It will be a PITA if all callers will have to always quote that identifier if they're not using jOOQ :)"</em></p>
			<p>So, here we have a package named <strong class="source-inline">DEPARTMENT_PKG</strong> containing a user-defined type named <strong class="source-inline">BGT</strong> and two functions, <strong class="source-inline">GET_BGT()</strong> and <strong class="source-inline">GET_MAX_CASH()</strong>. At the source code generation stage, jOOQ will reflect this package and its<a id="_idIndexMarker1615"/> content via Java sub-packages as follows:</p>
			<ul>
				<li><strong class="source-inline">jooq.generated.packages</strong> – Contains the <strong class="source-inline">DepartmentPkg</strong> class representing the package and exposing the <strong class="source-inline">DEPARTMENT_PKG</strong> static that can be used to call the functions as <strong class="source-inline">DEPARTMENT_PKG.getMaxCash()</strong> and <strong class="source-inline">DEPARTMENT_PKG.getBgt()</strong> and get the result as a <strong class="source-inline">Field</strong>.</li>
				<li><strong class="source-inline">jooq.generated.packages.department_pkg</strong> – Contains the <strong class="source-inline">GetBgt</strong> and <strong class="source-inline">GetMaxCash</strong> classes representing the two functions from the package. Moreover, it contains the <strong class="source-inline">UDTs</strong> class containing the static <strong class="source-inline">BGT</strong> for <strong class="source-inline">CLASSICMODELS.DEPARTMENT_PKG.BGT</strong> (<strong class="source-inline">jooq.generated.packages.department_pkg.udt.Bgt.BGT</strong>).</li>
				<li><strong class="source-inline">jooq.generated.packages.department_pkg.udt</strong> – Contains the class <strong class="source-inline">Bgt</strong> mapping the <strong class="source-inline">BGT</strong> UDT type as an extension of <strong class="source-inline">UDTImpl</strong>.</li>
				<li><strong class="source-inline">jooq.generated.packages.department_pkg.udt.records</strong> – Contains the <strong class="source-inline">BgtRecord</strong> class representing the <strong class="source-inline">BGT</strong> UDT type as an extension of <strong class="source-inline">UDTRecordImpl</strong>.</li>
			</ul>
			<p>Calling these two functions (<strong class="source-inline">GET_BGT()</strong> and <strong class="source-inline">GET_MAX_CASH()</strong>) can be done by instantiating the <strong class="source-inline">GetMaxCash</strong> class, respectively the <strong class="source-inline">GetBgt</strong> class and call <strong class="source-inline">execute()</strong> as follows:</p>
			<pre class="source-code">GetMaxCash gmc = new GetMaxCash();</pre>
			<pre class="source-code">gmc.execute(ctx.configuration());</pre>
			<pre class="source-code">double resultGmc = gmc.getReturnValue();</pre>
			<pre class="source-code">GetBgt bgt = new GetBgt();</pre>
			<pre class="source-code">bgt.setPProfit(50000.0);</pre>
			<pre class="source-code">bgt.execute(ctx.configuration());</pre>
			<pre class="source-code">BgtRecord resultBgt = bgt.getReturnValue();</pre>
			<p>We can also<a id="_idIndexMarker1616"/> compact these examples via the statics <strong class="source-inline">DepartmentPkg.getBgt()</strong> and <strong class="source-inline">DepartmentPkg.getMaxCash()</strong> as follows:</p>
			<pre class="source-code">double resultGmc = getMaxCash(ctx.configuration());</pre>
			<pre class="source-code">BgtRecord resultBgt = getBgt(ctx.configuration(), 50000.0);</pre>
			<p>Calling these functions from queries is also possible. For instance, here are two trivial examples of calling them in <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">ctx.select(getMaxCash()).fetch();</pre>
			<pre class="source-code">double mc = ctx.fetchValue(getMaxCash());</pre>
			<pre class="source-code">The rendered SQL:</pre>
			<pre class="source-code">SELECT "CLASSICMODELS"."department_pkg"."get_max_cash"() </pre>
			<pre class="source-code">FROM DUAL</pre>
			<p>Here is another example that uses both functions in the same query:</p>
			<pre class="source-code">ctx.select(OFFICE.OFFICE_CODE, OFFICE.CITY, OFFICE.COUNTRY,</pre>
			<pre class="source-code">           DEPARTMENT.NAME, DEPARTMENT.LOCAL_BUDGET)</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .join(DEPARTMENT)</pre>
			<pre class="source-code">   .on(OFFICE.OFFICE_CODE.eq(DEPARTMENT.OFFICE_CODE)</pre>
			<pre class="source-code">     .and(DEPARTMENT.LOCAL_BUDGET</pre>
			<pre class="source-code">       .in(getBgt(ctx.configuration(),</pre>
			<pre class="source-code">          getMaxCash(ctx.configuration()))</pre>
			<pre class="source-code">            .getLocalBudget())))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Check out these examples next to a few others not presented here in <em class="italic">Package</em> for Oracle.</p>
			<h3>Oracle's member function/procedure</h3>
			<p>Mainly, an Oracle PL/SQL object type <a id="_idIndexMarker1617"/>contains attributes and members (or methods). Attributes or fields have data types and they are used to store data, while members are subprograms (functions/procedures) that are defined in the object type and manipulate the attributes for implementing certain<a id="_idIndexMarker1618"/> functionalities. In this way, Oracle UDTs are a fully-fledged attempt at implementing an Object Relational Database Management System (ORDBMS). PostgreSQL didn't go quite as far as Oracle.</p>
			<p>If you are not an Oracle fan, then the following syntax should shed some light on this topic:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/Figure_15.3.jpg" alt="Figure 15.3 – Syntax of Oracle members&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.3 – Syntax of Oracle members</p>
			<p>Based on this<a id="_idIndexMarker1619"/> syntax, let's have an example. Our <strong class="source-inline">MANAGER</strong> table has<a id="_idIndexMarker1620"/> a field named <strong class="source-inline">MANAGER_EVALUATION</strong> that is of type <strong class="source-inline">EVALUATION_CRITERIA</strong> (in jOOQ, of type <strong class="source-inline">TableField&lt;ManagerRecord, EvaluationCriteriaRecord&gt;</strong>) defined as follows:</p>
			<pre class="source-code">CREATE OR REPLACE TYPE "EVALUATION_CRITERIA" AS OBJECT (</pre>
			<pre class="source-code">  "communication_ability" NUMBER(7), </pre>
			<pre class="source-code">  "ethics" NUMBER(7), </pre>
			<pre class="source-code">  "performance" NUMBER(7), </pre>
			<pre class="source-code">  "employee_input" NUMBER(7),</pre>
			<pre class="source-code">  MEMBER FUNCTION "IMPROVE"("k" NUMBER) </pre>
			<pre class="source-code">      RETURN "EVALUATION_CRITERIA",</pre>
			<pre class="source-code">  MAP MEMBER FUNCTION "SCORE" RETURN NUMBER</pre>
			<pre class="source-code">);</pre>
			<pre class="source-code">CREATE OR REPLACE TYPE BODY "EVALUATION_CRITERIA" AS</pre>
			<pre class="source-code">-- check bundled code for this skipped part</pre>
			<pre class="source-code">END;</pre>
			<p>Here, we have an object type containing four<a id="_idIndexMarker1621"/> attributes (<strong class="source-inline">communication_ability</strong>, <strong class="source-inline">ethics</strong>, <strong class="source-inline">performance</strong>, and <strong class="source-inline">employee_input</strong>), two member functions (<strong class="source-inline">IMPROVE()</strong> and <strong class="source-inline">SCORE()</strong>), and no member procedures. </p>
			<p>The jOOQ Code Generator produces the following artifacts:</p>
			<ul>
				<li><strong class="source-inline">jooq.generated.udt</strong> – In this package, we have the UDT type named <strong class="source-inline">EvaluationCriteria</strong>, representing an extension of jOOQ's <strong class="source-inline">UDTImpl&lt;EvaluationCriteriaRecord&gt;</strong>. It contains the statics <strong class="source-inline">EVALUATION_CRITERIA</strong>, <strong class="source-inline">COMMUNICATION_ABILITY</strong>, <strong class="source-inline">ETHICS</strong>, <strong class="source-inline">PERFORMANCE</strong>, and <strong class="source-inline">EMPLOYEE_INPUT</strong> to refer to these UDT attributes and several flavors of the <strong class="source-inline">improve()</strong> and <strong class="source-inline">score()</strong> member functions returning the plain result or wrapped in a <strong class="source-inline">Field</strong>.</li>
				<li><strong class="source-inline">jooq.generated.udt.records</strong> – Contains the <strong class="source-inline">EvaluationCriteriaRecord</strong> representing the UDT record as an extension of the jOOQ's <strong class="source-inline">UDTRecordImpl&lt;EvaluationCriteriaRecord&gt;</strong>. The <strong class="source-inline">EvaluationCriteriaRecord</strong> contains getters/setters for the object type attributes and contains the methods <strong class="source-inline">improve()</strong> and <strong class="source-inline">score()</strong> as well. These methods encapsulate the code needed to call the actual <strong class="source-inline">improve()</strong> and <strong class="source-inline">score()</strong> member functions.</li>
				<li><strong class="source-inline">jooq.generated.udt.evaluation_criteria</strong> – Contains the <strong class="source-inline">Improve</strong> and <strong class="source-inline">Score</strong> classes (routines), so a class for each member function. Both <strong class="source-inline">EvaluationCriteria</strong> and <strong class="source-inline">EvaluationCriteriaRecord</strong> use these classes internally.</li>
			</ul>
			<p>So, we can distinguish between calling the member functions starting from an empty record or from an existing record (for instance, a record fetched from the database). The conventional approach for starting from an empty record relies on <strong class="source-inline">DSLContext.newRecord()</strong>:</p>
			<pre class="source-code">EvaluationCriteriaRecord ecr = </pre>
			<pre class="source-code">   ctx.newRecord(EVALUATION_CRITERIA);        </pre>
			<p>The created record is already attached. Alternatively, we can instantiate <strong class="source-inline">EvaluationCriteriaRecord</strong> or use <strong class="source-inline">EVALUATION_CRITERIA.newRecord()</strong>, but the resulting record is not attached to a configuration (database), so you'll have to explicitly attach it by calling <strong class="source-inline">attach()</strong>.</p>
			<p>Next, we set the values<a id="_idIndexMarker1622"/> of the attributes and call the member functions. Here, we call the <strong class="source-inline">score()</strong> method, which returns a <strong class="source-inline">BigDecimal</strong>:</p>
			<pre class="source-code">ecr.setCommunicationAbility(58);</pre>
			<pre class="source-code">ecr.setEthics(30);</pre>
			<pre class="source-code">ecr.setPerformance(26);</pre>
			<pre class="source-code">ecr.setEmployeeInput(59);</pre>
			<pre class="source-code">BigDecimal result = ecr.score();</pre>
			<p>On the other hand, the <strong class="source-inline">improve()</strong> methods increase the evaluation attributes by the given value and return a new <strong class="source-inline">EvaluationCriteriaRecord</strong>:</p>
			<pre class="source-code">EvaluationCriteriaRecord newEcr = ecr.improve(10);        </pre>
			<p>The <strong class="source-inline">newEcr</strong> record has <strong class="source-inline">communication_ability</strong> at <em class="italic">68</em> instead of <em class="italic">58</em>, <strong class="source-inline">ethics</strong> at <em class="italic">40</em> instead of <em class="italic">30</em>, and <strong class="source-inline">performance</strong> at <em class="italic">36</em> instead of <em class="italic">26</em>. Only <strong class="source-inline">employee_input</strong> remains unchanged.</p>
			<p>We can use <strong class="source-inline">ecr</strong>/<strong class="source-inline">newEcr</strong> in queries as well. Here is an example of using <strong class="source-inline">newEcr</strong> that originates from an empty<a id="_idIndexMarker1623"/> record next to <strong class="source-inline">MANAGER.MANAGER_EVALUATION</strong>, which is fetched from the database (remember that <strong class="source-inline">MANAGER.MANAGER_EVALUATION</strong> is a <strong class="source-inline">TableField&lt;ManagerRecord, EvaluationCriteriaRecord&gt;</strong>):</p>
			<pre class="source-code">ctx.select(MANAGER.MANAGER_ID, MANAGER.MANAGER_NAME)</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .where(score(MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">     .lt(newEcr.score()))</pre>
			<pre class="source-code">   .fetch();        </pre>
			<p>Here's another example that combines the calls of <strong class="source-inline">improve()</strong> and <strong class="source-inline">score()</strong>:</p>
			<pre class="source-code">ctx.select(MANAGER.MANAGER_ID, MANAGER.MANAGER_NAME)</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .where(score(improve(</pre>
			<pre class="source-code">      MANAGER.MANAGER_EVALUATION, inline(10)))</pre>
			<pre class="source-code">        .gt(BigDecimal.valueOf(57)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Check out these examples next to others omitted here in <em class="italic">MemberFunction</em> for Oracle.</p>
			<h3>User-defined aggregate stored functions</h3>
			<p>Oracle and SQL Server allow<a id="_idIndexMarker1624"/> us to define aggregate stored<a id="_idIndexMarker1625"/> functions (if you are not familiar with this topic, then please search these on Google: <em class="italic">Oracle User-Defined Aggregate Functions Interface</em> for Oracle and <em class="italic">SQL Server User-Defined Aggregate Functions</em> for SQL Server).</p>
			<p>Moreover, the code of such functions is quite big to be listed here so please check the bundled code. For Oracle, check the application <em class="italic">UserDefinedAggFunction</em>, which calls a user-defined aggregate function named <strong class="source-inline">secondMax()</strong> that finds the second maximum value:</p>
			<pre class="source-code">ctx.select(secondMax(ORDERDETAIL.QUANTITY_ORDERED), </pre>
			<pre class="source-code">                     ORDERDETAIL.PRODUCT_ID)</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .groupBy(ORDERDETAIL.PRODUCT_ID)</pre>
			<pre class="source-code">   .having(secondMax(ORDERDETAIL.QUANTITY_ORDERED)</pre>
			<pre class="source-code">     .gt(BigDecimal.valueOf(55)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>And for SQL Server, check the application also named <em class="italic">UserDefinedAggFunction</em>. Here, we call an<a id="_idIndexMarker1626"/> aggregate stored function <a id="_idIndexMarker1627"/>named <strong class="source-inline">concatenate()</strong> that simply concatenates the given strings:</p>
			<pre class="source-code">ctx.select(concatenate(EMPLOYEE.FIRST_NAME))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.FIRST_NAME.like("M%"))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In order to work, please pay attention that you need to place the <strong class="source-inline">StringUtilities.dll</strong> DLL file (available in the bundled code) in the path specified in the function code.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor304"/>Stored procedures</h1>
			<p>jOOQ allows you to call stored procedures via the same <strong class="source-inline">Routines</strong> API. Next, let's see several examples of calling<a id="_idIndexMarker1628"/> different kinds of stored procedures.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor305"/>Stored procedures and output parameters</h2>
			<p>For instance, let's consider the following stored procedure<a id="_idIndexMarker1629"/> expressed in Oracle<a id="_idIndexMarker1630"/> and having an <strong class="source-inline">OUT</strong> parameter:</p>
			<pre class="source-code">CREATE OR REPLACE NONEDITIONABLE PROCEDURE </pre>
			<pre class="source-code">   "GET_AVG_PRICE_BY_PRODUCT_LINE" (</pre>
			<pre class="source-code">    "pl" IN VARCHAR2, "average" OUT DECIMAL) AS </pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">   SELECT AVG("PRODUCT"."BUY_PRICE")</pre>
			<pre class="source-code">      INTO "average"</pre>
			<pre class="source-code">      FROM "PRODUCT"</pre>
			<pre class="source-code">      WHERE "PRODUCT"."PRODUCT_LINE" = "pl";</pre>
			<pre class="source-code">END;</pre>
			<p>jOOQ generates the Java version of this stored procedure as a class named <strong class="source-inline">GetAvgPriceByProductLine</strong> in the <strong class="source-inline">jooq.generated.routines</strong> package. The methods of this class allow us to prepare the parameters (each input parameter has associated a setter, while each output parameter has associated a getter) and call our stored procedure as follows:</p>
			<pre class="source-code">GetAvgPriceByProductLine avg = new GetAvgPriceByProductLine();</pre>
			<pre class="source-code">avg.setPl("Classic Cars");</pre>
			<pre class="source-code">avg.execute(ctx.configuration());</pre>
			<pre class="source-code">BigInteger result = avg.getAverage();</pre>
			<p>We can express this more compactly via the generated <strong class="source-inline">jooq.generated.Routines.getAvgPriceByProductLine()</strong> static as follows:</p>
			<pre class="source-code">BigInteger result = getAvgPriceByProductLine(</pre>
			<pre class="source-code">   ctx.configuration(), "Classic Cars");</pre>
			<p>Calling a stored procedure<a id="_idIndexMarker1631"/> in a jOOQ query <a id="_idIndexMarker1632"/>can be done via the <strong class="source-inline">getAvgPriceByProductLine(Configuration configuration, String pl)</strong> flavor as in the following example:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_ID, PRODUCT.PRODUCT_NAME,   </pre>
			<pre class="source-code">           PRODUCT.BUY_PRICE)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .where(PRODUCT.BUY_PRICE.coerce(BigInteger.class)</pre>
			<pre class="source-code">     .gt(getAvgPriceByProductLine(</pre>
			<pre class="source-code">         ctx.configuration(), "Classic Cars"))</pre>
			<pre class="source-code">     .and(PRODUCT.PRODUCT_LINE.eq("Classic Cars")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>jOOQ first renders the call of the stored procedure and fetches the <strong class="source-inline">OUT</strong> parameter value:</p>
			<pre class="source-code">call "CLASSICMODELS"."get_avg_price_by_product_line" (</pre>
			<pre class="source-code">  'Classic Cars', ?)</pre>
			<p>Next, the fetched value (<em class="italic">64</em>, in this example) is used to render the <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">SELECT "CLASSICMODELS"."PRODUCT"."PRODUCT_ID",</pre>
			<pre class="source-code">       "CLASSICMODELS"."PRODUCT"."PRODUCT_NAME",</pre>
			<pre class="source-code">       "CLASSICMODELS"."PRODUCT"."BUY_PRICE"</pre>
			<pre class="source-code">FROM "CLASSICMODELS"."PRODUCT"</pre>
			<pre class="source-code">WHERE ("CLASSICMODELS"."PRODUCT"."BUY_PRICE" &gt; 64</pre>
			<pre class="source-code">  AND "CLASSICMODELS"."PRODUCT"."PRODUCT_LINE" </pre>
			<pre class="source-code">    = 'Classic Cars')</pre>
			<p>Next, let's call a stored procedure<a id="_idIndexMarker1633"/> without output parameters<a id="_idIndexMarker1634"/> that fetches a single result set.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor306"/>Stored procedures fetching a single result set</h2>
			<p>Here is a MySQL example <a id="_idIndexMarker1635"/>of a stored procedure that doesn't contain output parameters and fetches a single result set via <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">DELIMITER $$</pre>
			<pre class="source-code">CREATE PROCEDURE `get_product`(IN `pid` BIGINT)</pre>
			<pre class="source-code">  BEGIN</pre>
			<pre class="source-code">   SELECT * FROM `product` WHERE `product`.`product_id` = `pid`;</pre>
			<pre class="source-code">  END $$</pre>
			<pre class="source-code">DELIMITER</pre>
			<p>Calling this stored procedure from jOOQ can be done via the generated <strong class="source-inline">GetProduct</strong> class:</p>
			<pre class="source-code">GetProduct gp = new GetProduct();</pre>
			<pre class="source-code">gp.setPid(1L);</pre>
			<pre class="source-code">gp.execute(ctx.configuration());</pre>
			<pre class="source-code">Result&lt;Record&gt; result = gp.getResults().get(0);</pre>
			<p>The result is obtained via <strong class="source-inline">gp.getResults()</strong>. Since there is a single<a id="_idIndexMarker1636"/> result (the result set produced by the <strong class="source-inline">SELECT</strong>), we have to call <strong class="source-inline">get(0)</strong>. If there were two results involved (for instance, if we had two <strong class="source-inline">SELECT</strong> statements in the stored procedure), then we would call <strong class="source-inline">get(0)</strong> to get the first result and <strong class="source-inline">get(1)</strong> to get the second result. Or, in the case of even more results, simply loop the results. Notice that, in the case of stored procedures, the <strong class="source-inline">getReturnValue()</strong> method returns <strong class="source-inline">void</strong> since stored procedures don't return results as a stored function (they don't contain a <strong class="source-inline">RETURN</strong> statement). In fact, SQL Server's procedures can return an error code, which is an <strong class="source-inline">int</strong>. You can see that in SQL Server generated code for procedures.</p>
			<p>Calling the previous stored procedure via <strong class="source-inline">Routines.getProduct()</strong> returns <strong class="source-inline">void</strong> as well:</p>
			<pre class="source-code">getProduct(ctx.configuration(), 1L);</pre>
			<p>The results obtained via <strong class="source-inline">getResults()</strong> are of type <strong class="source-inline">Result&lt;Record&gt;</strong>. This can be easily transformed into a regular <strong class="source-inline">Table</strong> as follows:</p>
			<pre class="source-code">Table&lt;?&gt; t = table(gp.getResults().get(0));</pre>
			<pre class="source-code">Table&lt;ProductRecord&gt; t = table(gp.getResults()</pre>
			<pre class="source-code">  .get(0).into(PRODUCT));</pre>
			<p>Next, let's take the <strong class="source-inline">get_product()</strong> stored procedure and let's express it in Oracle by adding an <strong class="source-inline">OUT</strong> parameter <a id="_idIndexMarker1637"/>of type <strong class="source-inline">SYS_REFCURSOR</strong>.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor307"/>Stored procedures with a single cursor</h2>
			<p>The following stored procedure<a id="_idIndexMarker1638"/> fetches the same result set as the previous <strong class="source-inline">get_product()</strong>, but it returns it via a cursor:</p>
			<pre class="source-code">CREATE OR REPLACE NONEDITIONABLE PROCEDURE "GET_PRODUCT"(</pre>
			<pre class="source-code">    "pid" IN NUMBER, "cursor_result" OUT SYS_REFCURSOR) AS </pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">  OPEN "cursor_result" FOR</pre>
			<pre class="source-code">    SELECT * FROM "PRODUCT" </pre>
			<pre class="source-code">    WHERE "PRODUCT"."PRODUCT_ID" = "pid";</pre>
			<pre class="source-code">END;</pre>
			<p>This time, in <strong class="source-inline">GetProduct</strong>, jOOQ generates a getter for the <strong class="source-inline">OUT</strong> parameter named <strong class="source-inline">getCursorResult()</strong>, which allows us to fetch the result as a <strong class="source-inline">Result&lt;Record&gt;</strong>:</p>
			<pre class="source-code">GetProduct gp = new GetProduct();</pre>
			<pre class="source-code">gp.setPid(1L);</pre>
			<pre class="source-code">gp.execute(ctx.configuration());</pre>
			<pre class="source-code">Result&lt;Record&gt; result = gp.getCursorResult();</pre>
			<p>Or you can fetch it more compactly via <strong class="source-inline">Routines.getProduct(Configuration configuration, Number pid)</strong>:</p>
			<pre class="source-code">Result&lt;Record&gt; result = getProduct(ctx.configuration(), 1L);</pre>
			<p>As usual, this <strong class="source-inline">Result&lt;Record&gt;</strong> can be <a id="_idIndexMarker1639"/>easily transformed into a regular <strong class="source-inline">Table</strong>:</p>
			<pre class="source-code">Table&lt;?&gt; t = table(gp.getResults().get(0));</pre>
			<pre class="source-code">Table&lt;?&gt; t = table(getProduct(ctx.configuration(), 1L));</pre>
			<pre class="source-code">Table&lt;ProductRecord&gt; t = </pre>
			<pre class="source-code">    table(gp.getCursorResult().into(PRODUCT)); </pre>
			<pre class="source-code">Table&lt;ProductRecord&gt; t = </pre>
			<pre class="source-code">    table(getProduct(ctx.configuration(), 1L)</pre>
			<pre class="source-code">        .into(PRODUCT));</pre>
			<p>Next, you can use this <strong class="source-inline">Table</strong> in queries.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor308"/>Stored procedures fetching multiple result sets</h2>
			<p>Going further, let's tackle<a id="_idIndexMarker1640"/> a stored procedure returning multiple result sets. Here, it's expressed in MySQL:</p>
			<pre class="source-code">DELIMITER $$</pre>
			<pre class="source-code">CREATE PROCEDURE `get_emps_in_office`(</pre>
			<pre class="source-code">                           IN `in_office_code` VARCHAR(10))</pre>
			<pre class="source-code">  BEGIN</pre>
			<pre class="source-code">    SELECT `office`.`city`, `office`.`country`, </pre>
			<pre class="source-code">                   `office`.`internal_budget`</pre>
			<pre class="source-code">      FROM `office`</pre>
			<pre class="source-code">      WHERE `office`.`office_code`=`in_office_code`;</pre>
			<pre class="source-code">     SELECT `employee`.`employee_number`,</pre>
			<pre class="source-code">            `employee`.`first_name`, `employee`.`last_name`</pre>
			<pre class="source-code">      FROM `employee`</pre>
			<pre class="source-code">      WHERE `employee`.`office_code`=`in_office_code`;</pre>
			<pre class="source-code">  END $$</pre>
			<pre class="source-code">DELIMITER ;</pre>
			<p>As you already<a id="_idIndexMarker1641"/> know, jOOQ generates the <strong class="source-inline">GetEmpsInOffice</strong> class and the result sets are available via <strong class="source-inline">getResults()</strong>:</p>
			<pre class="source-code">GetEmpsInOffice geio = new GetEmpsInOffice();</pre>
			<pre class="source-code">geio.setInOfficeCode("1");</pre>
			<pre class="source-code">geio.execute(ctx.configuration());</pre>
			<pre class="source-code">Results results = geio.getResults();</pre>
			<pre class="source-code">for (Result&lt;Record&gt; result : results) {</pre>
			<pre class="source-code">  System.out.println("Result set:\n");</pre>
			<pre class="source-code">  for (Record record : result) {</pre>
			<pre class="source-code">    System.out.println(record);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">Routines.getEmpsInOffice(Configuration c, String inOfficeCode)</strong> returns<a id="_idIndexMarker1642"/> <strong class="source-inline">void</strong>.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor309"/>Stored procedures with multiple cursors</h2>
			<p>Next, let's<a id="_idIndexMarker1643"/> take the <strong class="source-inline">get_emps_in_office()</strong> stored procedure, and let's express it in Oracle by adding two <strong class="source-inline">OUT</strong> parameters of type <strong class="source-inline">SYS_REFCURSOR</strong>:</p>
			<pre class="source-code">CREATE OR REPLACE NONEDITIONABLE PROCEDURE </pre>
			<pre class="source-code">  "GET_EMPS_IN_OFFICE"("in_office_code" IN VARCHAR,</pre>
			<pre class="source-code">    "cursor_office" OUT SYS_REFCURSOR, </pre>
			<pre class="source-code">    "cursor_employee" OUT SYS_REFCURSOR) AS </pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">  OPEN "cursor_office" FOR</pre>
			<pre class="source-code">    SELECT "OFFICE"."CITY", "OFFICE"."COUNTRY", </pre>
			<pre class="source-code">        "OFFICE"."INTERNAL_BUDGET"</pre>
			<pre class="source-code">    FROM "OFFICE"</pre>
			<pre class="source-code">    WHERE "OFFICE"."OFFICE_CODE" = "in_office_code";</pre>
			<pre class="source-code">  OPEN "cursor_employee" FOR</pre>
			<pre class="source-code">    SELECT "EMPLOYEE"."EMPLOYEE_NUMBER", </pre>
			<pre class="source-code">           "EMPLOYEE"."FIRST_NAME", "EMPLOYEE"."LAST_NAME"</pre>
			<pre class="source-code">    FROM "EMPLOYEE"</pre>
			<pre class="source-code">    WHERE "EMPLOYEE"."OFFICE_CODE" = "in_office_code";</pre>
			<pre class="source-code">END;</pre>
			<p>This time, besides <strong class="source-inline">getResults()</strong>, which you are already familiar with, we can take advantage<a id="_idIndexMarker1644"/> of the getters produced by jOOQ for the <strong class="source-inline">OUT</strong> parameters as follows:</p>
			<pre class="source-code">GetEmpsInOffice geio = new GetEmpsInOffice();</pre>
			<pre class="source-code">geio.setInOfficeCode("1");</pre>
			<pre class="source-code">geio.execute(ctx.configuration());</pre>
			<pre class="source-code">Result&lt;Record&gt; co = geio.getCursorOffice();</pre>
			<pre class="source-code">Result&lt;Record&gt; ce = geio.getCursorEmployee();</pre>
			<p>Also, relying on <strong class="source-inline">Routines.getEmpsInOffice(Configuration c, String inOfficeCode)</strong> is quite convenient:</p>
			<pre class="source-code">GetEmpsInOffice results = </pre>
			<pre class="source-code">   getEmpsInOffice(ctx.configuration(), "1");        </pre>
			<p>Next, you can rely on <strong class="source-inline">results.getCursorInfo()</strong> respectively on <strong class="source-inline">results.getCursorEmployee()</strong> or by looping the results as follows:</p>
			<pre class="source-code">for (Result&lt;Record&gt; result : results.getResults()) {</pre>
			<pre class="source-code">  …</pre>
			<pre class="source-code">}</pre>
			<p>Next, loop each <strong class="source-inline">Result&lt;Record&gt;</strong> as <strong class="source-inline">for (Record record : result) …</strong>.</p>
			<p>Not sure it's worth<a id="_idIndexMarker1645"/> mentioning, but at least Oracle also knows typed <strong class="source-inline">REF CURSORS</strong> (instead of just <strong class="source-inline">SYS_REFCURSOR</strong>), which jOOQ will support as well soon (when you're reading this book, these features should be available): <a href="https://github.com/jOOQ/jOOQ/issues/11708">https://github.com/jOOQ/jOOQ/issues/11708</a>.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor310"/>Calling stored procedures via the CALL statement</h2>
			<p>Finally, let's tackle<a id="_idIndexMarker1646"/> the API of calling a stored procedure via the <strong class="source-inline">CALL</strong> statement<a id="_idIndexMarker1647"/> in an anonymous procedural block and via <strong class="source-inline">CALL</strong> directly. Consider the following stored procedure expressed in Oracle (the complete code is available in the bundled code):</p>
			<pre class="source-code">CREATE OR REPLACE NONEDITIONABLE PROCEDURE </pre>
			<pre class="source-code">    "REFRESH_TOP3_PRODUCT"("p_line_in" IN VARCHAR2) AS </pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">  DELETE FROM "TOP3PRODUCT"; </pre>
			<pre class="source-code">  INSERT INTO ...</pre>
			<pre class="source-code">      FETCH NEXT 3 ROWS ONLY;         </pre>
			<pre class="source-code">END;</pre>
			<p>Calling this stored procedure via the <strong class="source-inline">CALL</strong> statement in an anonymous procedural block can be done via <strong class="source-inline">DSLContext.begin()</strong> as follows:</p>
			<pre class="source-code">ctx.begin(call(name("REFRESH_TOP3_PRODUCT"))</pre>
			<pre class="source-code">   .args(val("Trains")))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Or, call it <a id="_idIndexMarker1648"/>directly <a id="_idIndexMarker1649"/>via <strong class="source-inline">DSLContext.call()</strong>:</p>
			<pre class="source-code">ctx.call(name("REFRESH_TOP3_PRODUCT"))</pre>
			<pre class="source-code">   .args(val("Trains"))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>You can practice all these examples in <em class="italic">CallProcedure</em>.</p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor311"/>jOOQ and creating stored functions/procedures</h1>
			<p>Starting with version 3.15, jOOQ began to add an API for creating stored functions, procedures, and triggers. Among others, we have support for <strong class="source-inline">CREATE FUNCTION</strong>, <strong class="source-inline">CREATE OR REPLACE FUNCTION</strong>, <strong class="source-inline">CREATE PROCEDURE</strong>, <strong class="source-inline">CREATE OR REPLACE PROCEDURE</strong>, <strong class="source-inline">DROP FUNCTION</strong>, and <strong class="source-inline">DROP PROCEDURE</strong>.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor312"/>Creating stored functions</h2>
			<p>For instance, creating<a id="_idIndexMarker1650"/> a scalar function for MySQL can be done as follows:</p>
			<pre class="source-code">Parameter&lt;Integer&gt; quantity = in("quantity", INTEGER);</pre>
			<pre class="source-code">Parameter&lt;Double&gt; listPrice = in("list_price", DOUBLE);</pre>
			<pre class="source-code">Parameter&lt;Double&gt; fractionOfPrice = </pre>
			<pre class="source-code">  in("fraction_of_price", DOUBLE);</pre>
			<pre class="source-code">ctx.createOrReplaceFunction("sale_price_jooq")</pre>
			<pre class="source-code">   .parameters(quantity, listPrice, fractionOfPrice)</pre>
			<pre class="source-code">   .returns(DECIMAL(10, 2))</pre>
			<pre class="source-code">   .deterministic()</pre>
			<pre class="source-code">   .as(return_(listPrice.minus(listPrice</pre>
			<pre class="source-code">     .mul(fractionOfPrice)).mul(quantity)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Here, we create a scalar function having three input parameters created via the intuitive <strong class="source-inline">Parameter</strong> API by specifying<a id="_idIndexMarker1651"/> their name and types. For MySQL, jOOQ renders the following code:</p>
			<pre class="source-code">DROP FUNCTION IF EXISTS `sale_price_jooq`;</pre>
			<pre class="source-code">CREATE FUNCTION `sale_price_jooq`(`quantity` INT, </pre>
			<pre class="source-code">         `list_price` DOUBLE, `fraction_of_price` DOUBLE) </pre>
			<pre class="source-code">RETURNS DECIMAL(10, 2) </pre>
			<pre class="source-code">DETERMINISTIC </pre>
			<pre class="source-code">BEGIN </pre>
			<pre class="source-code">RETURN ((`list_price` - (`list_price` * </pre>
			<pre class="source-code">         `fraction_of_price`)) * `quantity`); </pre>
			<pre class="source-code">END;</pre>
			<p>Notice that in order<a id="_idIndexMarker1652"/> to work, you should be aware of the following note.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In MySQL, we can execute<a id="_idIndexMarker1653"/> statement batches if we turn on the <strong class="source-inline">allowMultiQueries</strong> flag, which defaults to <strong class="source-inline">false</strong>; otherwise, we get an error. The previously generated SQL chains two statements, therefore this flag needs to be turned on – we can do it via the JDBC URL as <strong class="source-inline">jdbc:mysql:…/classicmodels?allowMultiQueries=true</strong>. Alternatively, in this particular case, we can rely on the <strong class="source-inline">dropFunctionIfExists()</strong>,<strong class="source-inline">createFunction()</strong> combo instead of <strong class="source-inline">createOrReplaceFunction()</strong>.  I strongly advise you to take a couple of minutes to read this article by Lukas Eder, which explains<a id="_idIndexMarker1654"/> in detail the implication of this flag in the jOOQ context: <a href="https://blog.jooq.org/mysqls-allowmultiqueries-flag-with-jdbc-and-jooq/">https://blog.jooq.org/mysqls-allowmultiqueries-flag-with-jdbc-and-jooq/</a>.</p>
			<p>You already know how to call this function from jOOQ via the generated code. This means that you have to run this code to create the stored function in the database, and afterward, run the jOOQ Code Generator to obtain the expected jOOQ artifacts. On the other hand, you can call it via plain SQL via the DSL's <strong class="source-inline">function()</strong> as in this example:</p>
			<pre class="source-code">float result = ctx.select(function(name("sale_price_jooq"),</pre>
			<pre class="source-code">  DECIMAL(10, 2), inline(10), inline(20.45), inline(0.33)))</pre>
			<pre class="source-code">  .fetchOneInto(Float.class);</pre>
			<p>You can practice this example in <em class="italic">CreateFunction</em>.</p>
			<p>How about creating<a id="_idIndexMarker1655"/> the following PostgreSQL function having output parameters?</p>
			<pre class="source-code">CREATE OR REPLACE FUNCTION "swap_jooq"(</pre>
			<pre class="source-code">       INOUT "x" INT, INOUT "y" INT) </pre>
			<pre class="source-code">  RETURNS RECORD LANGUAGE PLPGSQL AS $$ </pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">  SELECT "x", "y" INTO "y", "x"; </pre>
			<pre class="source-code">END; $$</pre>
			<p>From jOOQ, this function can be created like this:</p>
			<pre class="source-code">Parameter&lt;Integer&gt; x = inOut("x", INTEGER);</pre>
			<pre class="source-code">Parameter&lt;Integer&gt; y = inOut("y", INTEGER);</pre>
			<pre class="source-code">ctx.createOrReplaceFunction("swap_jooq")</pre>
			<pre class="source-code">   .parameters(x, y)                 </pre>
			<pre class="source-code">   .returns(RECORD)                </pre>
			<pre class="source-code">   .as(begin(select(x, y).into(y, x)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Calling this function can be done via plain SQL as in this example:</p>
			<pre class="source-code">Record1&lt;Record&gt; result = ctx.select(</pre>
			<pre class="source-code">  function(name("swap_jooq"),</pre>
			<pre class="source-code">    RECORD, inline(1), inline(2))).fetchOne();</pre>
			<p>You can practice this example next to another one using <strong class="source-inline">OUT</strong> parameters in <em class="italic">CreateFunction</em> for PostgreSQL. For more examples that allow you to explore this API in detail, please consider<a id="_idIndexMarker1656"/> the bundled code and the jOOQ manual.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor313"/>Creating stored procedures</h2>
			<p>Let's begin with a stored procedure<a id="_idIndexMarker1657"/> expressed in the SQL Server dialect:</p>
			<pre class="source-code">CREATE OR ALTER PROCEDURE [update_msrp_jooq] </pre>
			<pre class="source-code">   @product_id BIGINT, @debit INT AS </pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">  UPDATE [classicmodels].[dbo].[product]</pre>
			<pre class="source-code">  SET [classicmodels].[dbo].[product].[msrp] = </pre>
			<pre class="source-code">      ([classicmodels].[dbo].[product].[msrp] - @debit)</pre>
			<pre class="source-code">WHERE [classicmodels].[dbo].[product].[product_id] = </pre>
			<pre class="source-code">      @product_id; </pre>
			<pre class="source-code">END;</pre>
			<p>This stored procedure, which has two input parameters and updates the <strong class="source-inline">PRODUCT.MSRP</strong> field, can be created through the jOOQ API as follows:</p>
			<pre class="source-code">Parameter&lt;Long&gt; id = in("id", BIGINT);</pre>
			<pre class="source-code">Parameter&lt;Integer&gt; debit = in("debit", INTEGER);        </pre>
			<pre class="source-code">ctx.createOrReplaceProcedure("update_msrp_jooq")</pre>
			<pre class="source-code">   .parameters(id, debit)</pre>
			<pre class="source-code">   .as(update(PRODUCT)</pre>
			<pre class="source-code">        .set(PRODUCT.MSRP, PRODUCT.MSRP.minus(debit))</pre>
			<pre class="source-code">        .where(PRODUCT.PRODUCT_ID.eq(id)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>You already know how to call this procedure from jOOQ via the generated code, so this time, let's call<a id="_idIndexMarker1658"/> it via the <strong class="source-inline">CALL</strong> statement:</p>
			<pre class="source-code">// CALL statement in an anonymous procedural block</pre>
			<pre class="source-code">var result = ctx.begin(call(name("update_msrp_jooq"))</pre>
			<pre class="source-code">       .args(inline(1L), inline(100)))</pre>
			<pre class="source-code">       .execute();</pre>
			<pre class="source-code">// CALL statement directly</pre>
			<pre class="source-code">var result = ctx.call(name("update_msrp_jooq"))</pre>
			<pre class="source-code">       .args(inline(1L), inline(100))</pre>
			<pre class="source-code">       .execute();</pre>
			<p>The returned result represents the number of rows affected by this <strong class="source-inline">UPDATE</strong>. This example is available in <em class="italic">CreateProcedure</em> for SQL Server and PostgreSQL.</p>
			<p>Next, let's pick up an example expressed in Oracle dialect:</p>
			<pre class="source-code">CREATE OR REPLACE NONEDITIONABLE PROCEDURE </pre>
			<pre class="source-code">   "get_avg_price_by_product_line_jooq" (</pre>
			<pre class="source-code">      "pl" IN VARCHAR2,"average" OUT DECIMAL) AS </pre>
			<pre class="source-code">BEGIN</pre>
			<pre class="source-code">   SELECT AVG("CLASSICMODELS"."PRODUCT"."BUY_PRICE")</pre>
			<pre class="source-code">   INTO "average" FROM "CLASSICMODELS"."PRODUCT"</pre>
			<pre class="source-code">   WHERE "CLASSICMODELS"."PRODUCT"."PRODUCT_LINE" = "pl";</pre>
			<pre class="source-code">END;</pre>
			<p>This time, the jOOQ code for creating this procedure is as follows:</p>
			<pre class="source-code">Parameter&lt;String&gt; pl = in("pl", VARCHAR);</pre>
			<pre class="source-code">Parameter&lt;BigDecimal&gt; average = out("average", DECIMAL);</pre>
			<pre class="source-code">ctx.createOrReplaceProcedure(</pre>
			<pre class="source-code">    "get_avg_price_by_product_line_jooq")</pre>
			<pre class="source-code">   .parameters(pl, average)</pre>
			<pre class="source-code">   .as(select(avg(PRODUCT.BUY_PRICE)).into(average)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .where(PRODUCT.PRODUCT_LINE.eq(pl)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Since you are already familiar with this stored procedure<a id="_idIndexMarker1659"/> from the previous section, <em class="italic">Stored procedures and output parameters</em>, you should have no problem calling it. The example is available in <em class="italic">CreateProcedure</em> for Oracle.</p>
			<p>Finally, let's tackle a MySQL stored procedure that fetches a result set via <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">CREATE PROCEDURE `get_office_gt_budget_jooq`(`budget` INT) </pre>
			<pre class="source-code">  BEGIN</pre>
			<pre class="source-code">    SELECT `classicmodels`.`office`.`city`,</pre>
			<pre class="source-code">           `classicmodels`.`office`.`country`,</pre>
			<pre class="source-code">           `classicmodels`.`office`.`state`</pre>
			<pre class="source-code">    FROM `classicmodels`.`office`</pre>
			<pre class="source-code">    WHERE `classicmodels`.`office`.`internal_budget` &gt; `budget`; </pre>
			<pre class="source-code">  END;</pre>
			<p>The jOOQ code that creates the stored procedure is as follows:</p>
			<pre class="source-code">Parameter&lt;Integer&gt; budget = in("budget", INTEGER);</pre>
			<pre class="source-code">ctx.createOrReplaceProcedure("get_office_gt_budget_jooq")</pre>
			<pre class="source-code">   .parameters(budget)</pre>
			<pre class="source-code">   .as(select(OFFICE.CITY, OFFICE.COUNTRY, OFFICE.STATE)</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .where(OFFICE.INTERNAL_BUDGET.gt(budget)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>In order for this<a id="_idIndexMarker1660"/> code to work, we need to turn on the <strong class="source-inline">allowMultiQueries</strong> flag as explained in the previous section, <em class="italic">Creating stored functions</em>.</p>
			<p>You can find this example next to another one that fetches two result sets in the application named <em class="italic">CreateProcedure</em> for MySQL.</p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor314"/>Summary</h1>
			<p>In this chapter, you've learned how to call and create some typical stored functions and procedures. Since these are powerful SQL tools, jOOQ strives to provide a comprehensive API to cover the tons of possibilities to express these artifacts in different dialects. Most probably, by the time you read this book, jOOQ will have already enriched this API even further and more examples will be available in the bundled code.</p>
			<p>In the next chapter, we tackle aliases and SQL templating.</p>
		</div>
	</body></html>