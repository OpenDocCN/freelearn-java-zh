- en: Managing Processes in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的进程管理
- en: With a very quick tour through some of the big new features of Java 9, as well
    as those from a couple of previous releases, let's turn our attention to applying
    some of these new APIs in a practical manner. We'll start with a simple process
    manager.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速浏览Java 9的一些新特性以及之前几个版本的一些特性，让我们将注意力转向以实际方式应用这些新API。我们将从一个简单的进程管理器开始。
- en: 'While having your application or utility handle all of your user''s concerns
    internally is usually ideal, occasionally you need to run (or **shell out to**)
    an external program for a variety of reasons. From the very first days of Java,
    this was supported by the JDK via the `Runtime` class via a variety of APIs. Here
    is the simplest example:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然让应用程序或实用程序内部处理所有用户的问题通常是理想的，但有时出于各种原因需要运行（或**外部调用**）外部程序。从Java的最初几天起，JDK就通过`Runtime`类和各种API支持了这一点。以下是最简单的示例：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the process has been created, you can track its execution via the `Process`
    class, which has methods such as `getInputStream()`, `getOutputStream()`, and
    `getErrorStream()`. We have also had rudimentary control over the process via
    `destroy()` and `waitFor()`. Java 8 moved things forward by adding `destroyForcibly()`
    and `waitFor(long, TimeUnit)`. Starting with Java 9, these capabilities will be
    expanded. Quoting from the **Java Enhancement Proposal** (**JEP**), we see the
    following reasons for this new functionality:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进程被创建，你可以通过`Process`类跟踪其执行，该类具有`getInputStream()`、`getOutputStream()`和`getErrorStream()`等方法。我们还可以通过`destroy()`和`waitFor()`方法对进程进行基本的控制。Java
    8通过添加`destroyForcibly()`和`waitFor(long, TimeUnit)`方法推动了事物的发展。引用自**Java增强提案**（**JEP**），我们看到了以下新功能的原因：
- en: '*Many enterprise applications and containers involve several Java virtual machines
    and processes and have long-standing needs that include the following:*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多企业应用程序和容器涉及多个Java虚拟机和进程，并且长期存在以下需求：*'
- en: '*The ability to get the pid (or equivalent) of the current Java virtual machine
    and the pid of processes created with the existing API.*'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*能够获取当前Java虚拟机的pid以及使用现有API创建的进程的pid。*'
- en: '*The ability to enumerate processes on the system. Information on each process
    may include its pid, name, state, and perhaps resource usage.*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*能够枚举系统上的进程。每个进程的信息可能包括其pid、名称、状态以及可能的使用资源。*'
- en: '*The ability to deal with process trees, in particular, some means to destroy
    a process tree.*'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*能够处理进程树，特别是提供一种销毁进程树的方法。*'
- en: '*The ability to deal with hundreds of sub-processes, perhaps multiplexing the
    output or error streams to avoid creating a thread per sub-process.*'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*能够处理数百个子进程，可能通过复用输出或错误流来避免为每个子进程创建一个线程。*'
- en: In this chapter, we'll build a simple process manager application, akin to Windows
    Task Manager or *nix's top. There is, of course, little need for a process manager
    written in Java, but this will be an excellent avenue for us to explore these
    new process handling APIs. Additionally, we'll spend some time with other language
    features and APIs, namely, JavaFX and `Optional`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个简单的进程管理应用程序，类似于Windows任务管理器或*nix的top。当然，用Java编写的进程管理器几乎没有需求，但这将是我们探索这些新的进程处理API的绝佳途径。此外，我们还将花一些时间了解其他语言特性和API，即JavaFX和`Optional`。
- en: 'The following topics are covered in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Creating the project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建项目
- en: Bootstrapping the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: Defining the user interface
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义用户界面
- en: Initializing the user interface
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化用户界面
- en: Adding menus
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加菜单
- en: Updating the process list
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新进程列表
- en: With that said, let's get started.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们开始吧。
- en: Creating a project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Typically speaking, it is much better if a build can be reproduced without
    requiring the use of a specific IDE or some other proprietary tool. Fortunately,
    NetBeans offers the ability to create a Maven-based JavaFX project. Click on File
    | New Project and select `Maven`, then JavaFX Application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，如果构建可以在不使用特定IDE或其他专有工具的情况下重现，那就更好了。幸运的是，NetBeans提供了创建基于Maven的JavaFX项目的功能。点击“文件”|“新建项目”，然后选择“Maven”，然后选择JavaFX应用程序：
- en: '![](img/cd7f9cac-f8dd-4668-b89c-cb5d902f767e.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd7f9cac-f8dd-4668-b89c-cb5d902f767e.png)'
- en: 'Next, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，执行以下步骤：
- en: Click on Next.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”。
- en: Enter Project Name as `ProcessManager`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称输入为`ProcessManager`。
- en: Enter Group ID as `com.steeplesoft`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组ID输入为`com.steeplesoft`。
- en: Enter Package as `com.steeplesoft.processmanager`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包输入为`com.steeplesoft.processmanager`。
- en: Select Project Location.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择项目位置。
- en: Click on Finish.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。
- en: 'Consider the following screenshot as an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图作为示例：
- en: '![](img/fa6a4134-f552-4d1e-867a-aa7fd8eb509d.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa6a4134-f552-4d1e-867a-aa7fd8eb509d.png)'
- en: 'Once the new project has been created, we need to update the Maven `pom` to
    use Java 9:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新项目，我们需要更新Maven的`pom`文件以使用Java 9：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, with both NetBeans and Maven configured to use Java 9, we're ready to start
    coding.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，NetBeans和Maven都配置好了使用Java 9，我们准备开始编码。
- en: Bootstrapping the application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用
- en: 'As noted in the introduction, this will be a JavaFX-based application, so we''ll
    start by creating the skeleton for the application. This is a Java 9 application,
    and we intend to make use of the Java Module System. To do that, we need to create
    the module definition file, `module-info.java`, which resides in the root of our
    source tree. This being a Maven-based project, that would be `src/main/java`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，这将是一个基于JavaFX的应用，所以我们将首先创建应用的骨架。这是一个Java 9应用，我们打算使用Java模块系统。为此，我们需要创建模块定义文件`module-info.java`，它位于我们的源树根目录。这是一个基于Maven的项目，所以那将是`src/main/java`：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This small file does a couple of different things. First, it defines a new
    `procman.app` module. Next, it tells the system that this module `requires` two
    JDK modules: `javafx.controls` and `javafx.fxml`. If we did not specify these
    two modules, then our system, which we''ll see below, would not compile, as the
    JDK would not make the required classes and packages available to our application.
    These modules are part of the standard JDK as of Java 9, so that shouldn''t be
    an issue. However, that may change in future versions of Java, and this module
    declaration will help prevent runtime failures in our application by forcing the
    host JVM to provide the module or fail to start. It is also possible to build
    custom Java runtimes via the **J-Link** tool, so missing these modules is still
    a possibility under Java 9\. With our module configured, let''s turn to the application.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小文件做了几件事情。首先，它定义了一个新的`procman.app`模块。接下来，它告诉系统这个模块`requires`两个JDK模块：`javafx.controls`和`javafx.fxml`。如果我们没有指定这两个模块，那么我们下面将要看到的系统将无法编译，因为JDK不会将所需的类和包提供给我们的应用。这些模块是Java
    9标准JDK的一部分，所以这不应该是一个问题。然而，这可能在Java未来的版本中发生变化，并且这个模块声明将帮助我们通过强制宿主JVM提供模块或失败启动来防止应用在运行时出现故障。也有可能通过**J-Link**工具构建自定义的Java运行时，所以在Java
    9下缺少这些模块仍然是一个可能性。在我们的模块配置完成后，让我们转向应用。
- en: The emerging standard directory layout seems to be something like `src/main/java/*<module1>*`,
    `src/main/java/*<module2>*`, and so on. At the time of writing this book, while
    Maven can be coaxed into such a layout, the plugins themselves, while they do
    run under Java 9, do not appear to be module-aware enough to allow us to organize
    our code in such a manner. For that reason, and for the sake of simplicity, we
    will treat one Maven module as one Java module and maintain the standard source
    layout for the projects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 新兴的标准目录布局似乎是这样的：`src/main/java/*<module1>*`，`src/main/java/*<module2>*`，等等。在撰写本书时，虽然Maven可以被诱导采用这种布局，但插件本身，尽管它们在Java
    9下运行，似乎并不足够模块化，以允许我们以这种方式组织我们的代码。因此，为了简单起见，我们将一个Maven模块视为一个Java模块，并保持项目的标准源布局。
- en: 'The first class we will create is the `Application` descendant, which NetBeans
    created for us. It created the `Main` class, which we renamed to `ProcessManager`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的第一个类是`Application`的子类，这是NetBeans为我们创建的。它创建了`Main`类，我们将它重命名为`ProcessManager`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `ProcessManager` class extends the JavaFX base class, `Application`, which
    provides a variety of functionality to start and stop the application. We see
    in the `main()` method that we simply delegate to `Application.launch(String[])`,
    which does the heavy lifting for us in starting our new application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ProcessManager`类扩展了JavaFX的基类`Application`，它提供了启动和停止应用的各种功能。我们在`main()`方法中看到我们只是委托给`Application.launch(String[])`，它为我们启动新应用做了繁重的工作。
- en: The more interesting part of this class is the `start()` method, which is where
    the JavaFX life cycle calls back into our application, giving us the opportunity
    to build the user interface, which we'll do next.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的更有趣的部分是`start()`方法，这是JavaFX生命周期回调到我们的应用的地方，给了我们构建用户界面的机会，我们将在下一部分完成。
- en: Defining the user interface
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户界面
- en: 'When building the user interface for a JavaFX application, you can do it in
    one of two ways: code or markup. To keep our code smaller and more readable, we''ll
    build the user interface using FXML--the XML-based language created specifically
    for JavaFX to express user interfaces. This presents us with another binary choice--do
    we write the XML by hand, or do we use a graphical tool? Again, the choice is
    a simple one--we''ll use a tool, **Scene Builder**, which is a WYSIWYG tool originally
    developed by Oracle and now maintained and supported by Gluon. We will, however,
    also be looking at the XML source so that we can understand what''s being done,
    so if you don''t like using a GUI tool, you won''t be left out.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建 JavaFX 应用程序的用户界面时，你可以有两种方式：代码或标记。为了使我们的代码更小、更易读，我们将使用 FXML 构建用户界面——这是一种专门为
    JavaFX 创建的基于 XML 的语言，用于表达用户界面。这给我们带来了另一个二选一的选择——我们是手动编写 XML，还是使用图形工具？同样，选择很简单——我们将使用一个工具，**Scene
    Builder**，这是一个最初由 Oracle 开发并由 Gluon 维护和支持的所见即所得工具。然而，我们还将查看 XML 源代码，以便了解正在进行的操作，所以如果你不喜欢使用
    GUI 工具，你也不会被排除在外。
- en: 'Installing and using Scene Builder is, as you would expect, pretty straightforward.
    It can be downloaded from [http://gluonhq.com/labs/scene-builder/](http://gluonhq.com/labs/scene-builder/).
    Once installed, you need to tell NetBeans where to find it, which can be done
    in the Settings window, under Java | JavaFX, as you can see in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和使用 Scene Builder，正如你所预期的那样，相当简单。它可以从 [http://gluonhq.com/labs/scene-builder/](http://gluonhq.com/labs/scene-builder/)
    下载。一旦安装，你需要在 NetBeans 的设置窗口中指定其位置，这可以在 Java | JavaFX 下的设置窗口完成，如下面的截图所示：
- en: '![](img/81811a5e-6f76-48b8-89f6-088e568110ce.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/81811a5e-6f76-48b8-89f6-088e568110ce.png)'
- en: 'We are now ready to create the FXML file. Under the `resources` directory in
    the Project View, create a new folder called `fxml`, and in that folder, create
    a file called `procman.fxml`, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建 FXML 文件。在项目视图中的 `resources` 目录下，创建一个名为 `fxml` 的新文件夹，并在该文件夹中创建一个名为
    `procman.fxml` 的文件，如下所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`BorderPane` is a container that defines five regions--`top`, `bottom`, `left`,
    `right`, and `center`, giving us a fairly coarsely-grained control over where
    on the form the controls should appear. Typically, with `BorderPane`, each area
    uses a nested container to provide the finer-grained control often necessary.
    For our needs, this level of control will be perfect.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`BorderPane` 是一个容器，定义了五个区域——`top`、`bottom`、`left`、`right` 和 `center`，这使我们能够相当粗略地控制控件在表单上的位置。通常，使用
    `BorderPane`，每个区域都使用嵌套容器来提供通常必要的更细粒度的控制。对于我们的需求，这种级别的控制将非常完美。'
- en: 'The primary concern of the user interface is the list of processes, so we''ll
    start with the controls for that. From Scene Builder, we want to click on the
    `Controls` section on the accordion on the left, then scroll down to `TableView`.
    Click on this and drag it to the `CENTER` region on the form, as shown here in
    this screenshot from Scene Builder:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面的主要关注点是进程列表，所以我们将从这里开始，使用 Scene Builder，我们想要点击左侧手风琴上的“控件”部分，然后向下滚动到“TableView”。点击它并将其拖到表单上的“CENTER”区域，如
    Scene Builder 中的这个截图所示：
- en: '![](img/d31ced44-1013-43bd-9262-c0709044c806.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d31ced44-1013-43bd-9262-c0709044c806.png)'
- en: 'The resulting FXML should look something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 FXML 应该看起来像这样：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With no components in the other areas, `TableView` will expand to fill the window's
    full area, which is what we want for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他区域没有组件的情况下，`TableView` 将扩展以填充窗口的全部区域，这是我们目前想要的。
- en: Initializing the user interface
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化用户界面
- en: 'While the FXML defines the structure of the user interface, we do need some
    Java code to initialize various elements, respond to actions, and so forth. This
    class, referred to as the controller, is simply a class that extends `javafx.fxml.Initializable`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FXML 定义了用户界面的结构，但我们确实需要一些 Java 代码来初始化各种元素、响应用户操作等。这个类被称为控制器，它只是一个扩展了 `javafx.fxml.Initializable`
    的类：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `initialize()` method comes from the interface, and is used by the JavaFX
    runtime to initialize the controller when it is created in the call to `FXMLLoader.load()`
    from the preceding `Application` class. Note the `@FXML` annotation on the instance
    variable `processList`. When JavaFX initializes the controller, before the `initialize()`
    method is called, the system looks for FXML elements that specify an `fx:id` attribute,
    and assigns that reference to the appropriate instance variable in the controller.
    To complete this connection, we must make one more change to our FXML file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize()` 方法来自接口，并由 JavaFX 运行时在从先前的 `Application` 类调用 `FXMLLoader.load()`
    时创建控制器时使用。注意实例变量 `processList` 上的 `@FXML` 注解。当 JavaFX 初始化控制器时，在调用 `initialize()`
    方法之前，系统会查找指定 `fx:id` 属性的 FXML 元素，并将该引用分配给控制器中适当的实例变量。为了完成这个连接，我们必须对我们的 FXML 文件进行最后一次更改：'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The change can also be made in Scene Builder as seen in this screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该更改也可以在 Scene Builder 中进行，如本截图所示：
- en: '![](img/799dc8e9-e32a-4810-8ff6-53b08e4b30ab.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/799dc8e9-e32a-4810-8ff6-53b08e4b30ab.png)'
- en: The value of the fx:id attribute must match the name of an instance variable
    that has been annotated with `@FXML`. When `initialize` is called, `processList`
    will have a valid reference to `TableView` that we can manipulate in our Java
    code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: fx:id 属性的值必须与已用 `@FXML` 注释的实例变量的名称匹配。当调用 `initialize` 时，`processList` 将具有对 `TableView`
    的有效引用，我们可以在 Java 代码中对其进行操作。
- en: The value of fx:id can be set via Scene Builder as well. To set the value, click
    on the control in the form editor, then expand the Code section in the accordion
    on the right. In the fx:id field, type in the name of the desired variable name.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: fx:id 的值也可以通过 Scene Builder 设置。要设置值，请点击表单编辑器中的控件，然后在右侧折叠面板中展开代码部分。在 fx:id 字段中，输入所需的变量名。
- en: 'The final piece of the puzzle is specifying the controller for the FXML file.
    In the XML source, you can set this via the `fx:controller` attribute on the root
    element of the user interface:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是指定 FXML 文件的控制器。在 XML 源中，您可以通过用户界面根元素的 `fx:controller` 属性来设置此属性：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This can also be set via Scene Builder. In the Document section of the accordion
    on the left, expand the Controller section and enter the desired fully-qualified
    class name in the Controller class field:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过 Scene Builder 设置。在左侧折叠面板的文档部分中，展开控制器部分，并在控制器类字段中输入所需的完全限定类名：
- en: '![](img/979ca94b-075a-4410-98c2-6aa383bf9217.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/979ca94b-075a-4410-98c2-6aa383bf9217.png)'
- en: With those pieces in place, we can begin the work of initializing `TableView`,
    which gets us back to our primary interest, the process handling APIs. Our starting
    point is `ProcessHandles.allProcesses()`. From the Javadoc, you learn that this
    method returns **a snapshot of all processes visible to the current process**.
    From each `ProcessHandle` in the stream, we can get information about the process
    ID, its state, children, parents, and so on. Each `ProcessHandle` also has a nested
    object, `Info`, that contains a snapshot of information about the process. Since
    not all information is available across the various supported platforms and it
    is limited by the privileges of the current process, the properties on the `Info`
    object are the `Optional<T>` instances, indicating that the values may or may
    not be set. It's probably worth the time to take a quick look at what `Optional<T>`
    is.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些组件就绪后，我们可以开始初始化 `TableView` 的工作，这使我们回到了我们的主要兴趣点，即处理 API 的过程。我们的起点是 `ProcessHandles.allProcesses()`。从
    Javadoc 中，你了解到这个方法返回 **当前进程可见的所有进程的快照**。从流中的每个 `ProcessHandle`，我们可以获取关于进程 ID、其状态、子进程、父进程等信息。每个
    `ProcessHandle` 还有一个嵌套对象 `Info`，其中包含关于进程的信息快照。由于不是所有信息都在各种支持的平台上可用，并且受到当前进程权限的限制，`Info`
    对象上的属性是 `Optional<T>` 实例，表示值可能已设置也可能未设置。花点时间快速了解一下 `Optional<T>` 是什么可能是有益的。
- en: 'The Javadoc describes `Optional<T>` as a **container object which may or may
    not contain a non-null value**. Inspired by Scala and Haskell, `Optional<T>` was
    introduced in Java 8 to allow API authors to provide a more null-safe interface.
    Prior to Java 8, a method on `ProcessHandle.Info` may be defined like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc 将 `Optional<T>` 描述为 **一个可能包含或不包含非空值的容器对象**。受 Scala 和 Haskell 的启发，`Optional<T>`
    在 Java 8 中被引入，以允许 API 作者提供更安全的空值接口。在 Java 8 之前，`ProcessHandle.Info` 上的方法可能定义如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To consume the API, the developer would likely write something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消费 API，开发者可能会编写类似以下的内容：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the developer fails to check for null explicitly, `NullPointerException`
    is almost certain to occur at some point. By using `Optional<T>`, the API author
    signals to the user that the return value may be null and should be handled carefully.
    The updated code, then, may look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者未能显式检查空值，则几乎肯定会在某个时刻发生 `NullPointerException`。通过使用 `Optional<T>`，API 作者向用户表明返回值可能为空，并且应该小心处理。因此，更新的代码可能如下所示：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, in one concise line, we can get the value, if it is present, or a default
    if it is not. The `ProcessHandle.Info` API makes extensive use of this construct
    as we'll see later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在一行简洁的代码中获取值，如果存在，或者如果没有值，则返回默认值。`ProcessHandle.Info` API 广泛使用这种结构，我们将在后面看到。
- en: 'What else does `Optional` afford us as developers? There are a number of instance
    methods that can help clarify null-handling code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 还为我们开发者提供了什么？有许多实例方法可以帮助澄清空值处理代码：'
- en: '`filter(Predicate<? super T> predicate)`: With this method, we filter the contents
    of `Optional`. Rather than using an `if...else` block, we can pass the `filter()`
    method a `Predicate` and do the test inline. A `Predicate` is a `@FunctionalInterface`
    that takes an input and returns a Boolean. For example, some uses of the JavaFX
    `Dialog` may return `Optional<ButtonType>`. If we wanted to do something **only**
    if the user clicked a specific button, say, OK, we could filter `Optional` like
    this:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter(Predicate<? super T> predicate)`: 使用此方法，我们可以过滤 `Optional` 的内容。而不是使用
    `if...else` 块，我们可以将 `Predicate` 传递给 `filter()` 方法并直接进行测试。`Predicate` 是一个 `@FunctionalInterface`，它接受一个输入并返回一个布尔值。例如，一些
    JavaFX `Dialog` 的使用可能返回 `Optional<ButtonType>`。如果我们只想在用户点击特定按钮（例如，确定）时执行某些操作，我们可以这样过滤
    `Optional`：'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`map(Function<? super T,? extends U> mapper)`: The `map` function allows us
    to pass the contents of `Optional` to a function, which will perform some processing
    on it, and return it. The return from the function, though, will be wrapped in
    an `Optional`:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map(Function<? super T,? extends U> mapper)`: `map` 函数允许我们将 `Optional` 的内容传递给一个函数，该函数将对其进行一些处理，并返回它。然而，函数的返回值将被包装在
    `Optional` 中：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the double wrapping in `Optional` for `upper2`. If `Function` returns `Optional`,
    it will be wrapped in another `Optional`, giving us this odd double wrap, which
    is less than desirable. Fortunately, we have an alternative.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Optional` 中 `upper2` 的双重包装。如果 `Function` 返回 `Optional`，它将被另一个 `Optional`
    包装，从而产生这种不希望的双重包装。幸运的是，我们有另一种选择。
- en: '`flatMap(Function<? super T,Optional<U>> mapper)`: The `flatMap` function combines
    two functional ideas--maps and flatten. If the result of `Function` is an `Optional`
    object, rather than double wrapping the value, it is flattened to a single `Optional`
    object. Revisiting the preceding example, we get this:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap(Function<? super T,Optional<U>> mapper)`: `flatMap` 函数结合了两个函数式思想--映射和扁平化。如果
    `Function` 的结果是 `Optional` 对象，而不是双重包装值，它将被扁平化为单个 `Optional` 对象。回顾先前的示例，我们得到如下结果：'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that `upper3`, unlike `upper2`, is a single `Optional`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 `upper2` 不同，`upper3` 是一个单独的 `Optional`：
- en: '`get()`: This returns the wrapped value, if present. If there is no value,
    a `NoSuchElementException` error is thrown.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 如果存在，则返回包装的值。如果没有值，则抛出 `NoSuchElementException` 错误。'
- en: '`ifPresent(Consumer<? super T> action)`: If the `Optional` object contains
    a value, it is passed to the `Consumer`. If there is no value present, nothing
    happens.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresent(Consumer<? super T> action)`: 如果 `Optional` 对象包含一个值，则将其传递给 `Consumer`。如果没有值，则不执行任何操作。'
- en: '`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`: Like `ifPresent()`,
    this will pass the value to the `Consumer` if there is one present. If no value
    is present, the `Runnable emptyAction` is executed.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`: 与 `ifPresent()`
    类似，如果存在值，它将传递给 `Consumer`。如果没有值，则执行 `Runnable emptyAction`。'
- en: '`isPresent()`: This simply returns true if the `Optional` object contains a
    value.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPresent()`: 这个方法简单地返回 `Optional` 对象是否包含一个值。'
- en: '`or(Supplier<Optional<T>> supplier)`: If the `Optional` object has a value,
    the `Optional` is described. If there is no value present, an `Optional` object
    produced by the `Supplier` is returned.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or(Supplier<Optional<T>> supplier)`: 如果 `Optional` 对象有一个值，则描述该 `Optional`。如果没有值，则返回由
    `Supplier` 产生的 `Optional` 对象。'
- en: '`orElse(T other)`: If the `Optional` object contains a value, it is returned.
    If there is no value, `other` is returned.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElse(T other)`: 如果 `Optional` 对象包含一个值，则返回该值。如果没有值，则返回 `other`。'
- en: '`orElseGet(Supplier<? extends T> supplier)`: This works just like `orElse()`
    mentioned earlier, but, if no value is present, the result of the `Supplier` is
    returned.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseGet(Supplier<? extends T> supplier)`: 这与前面提到的 `orElse()` 的工作方式相同，但如果不存在值，则返回
    `Supplier` 的结果。'
- en: '`orElseThrow(Supplier<? extends X> exceptionSupplier)`: If there is a value
    present, it is returned. If there is no value, the `Exception` provided by the
    `Supplier` is thrown.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseThrow(Supplier<? extends X> exceptionSupplier)`: 如果存在值，则返回该值。如果不存在值，则抛出由
    `Supplier` 提供的 `Exception`。'
- en: '`Optional` also has several static methods that facilitate the creation of
    the `Optional` instances, some of which are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 还有一些静态方法，这些方法有助于创建 `Optional` 实例，其中一些如下：'
- en: '`empty()`: This returns an empty `Optional` object.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty()`: 这返回一个空的 `Optional` 对象。'
- en: '`of(T value)`: This returns an `Optional` object describing the non-null value.
    If the value is null, a `NullPointerException` is thrown.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of(T value)`: 这返回一个描述非空值的 `Optional` 对象。如果值为空，则抛出 `NullPointerException`。'
- en: '`ofNullable(T value)`: This returns an `Optional` object describing the value.
    If the value is null, an empty `Optional` is returned.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ofNullable(T value)`: 这返回一个描述值的 `Optional` 对象。如果值为空，则返回一个空的 `Optional`。'
- en: With that very brief introduction to `Optional<T>` under our belts, let's see
    how its presence affects our application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握了 `Optional<T>` 的简要介绍之后，让我们看看它的存在如何影响我们的应用程序。
- en: 'Returning our attention to the `initialize()` method, then, our first step
    is to get the list of processes to display. The streams API makes this extremely
    simple:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转回到 `initialize()` 方法，我们的第一步是获取要显示的进程列表。流 API 使得这一点非常简单：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `allProcesses()` method returns `Stream<ProcessHandle>`, which allows us
    to apply the new stream operations to our problem. In this case, we just want
    to create a `List` of all of the `ProcessHandle` instances, so we call `collect()`,
    which is a stream operation that takes in a `Collector`. There are a number of
    options from which we could choose, but we want a `List`, so we use `Collectors.toList()`,
    which will collect each item in the stream and eventually return a `List` when
    the stream terminates. Note that the parameterized type of `List` will match that
    of `Stream`, which is `ProcessHandle` in this case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`allProcesses()` 方法返回 `Stream<ProcessHandle>`，这允许我们将新的流操作应用于我们的问题。在这种情况下，我们只想创建一个包含所有
    `ProcessHandle` 实例的 `List`，因此我们调用 `collect()`，这是一个接受 `Collector` 的流操作。我们可以从多个选项中选择，但我们需要一个
    `List`，所以我们使用 `Collectors.toList()`，它将收集流中的每个项目，并在流结束时返回一个 `List`。请注意，`List` 的参数化类型将与
    `Stream` 相匹配，在这种情况下是 `ProcessHandle`。'
- en: 'This one line, then, gets us a `List<ProcessHandle>` of every process on the
    system that the current process can see, but that only gets us halfway. The `TableView`
    API doesn''t accept a `List<T>`. It only supports `ObservableList<T>`, but what
    is that? Its Javadoc defines it very simply--*A list that allows listeners to
    track changes when they occur*. To put it another way, when this list changes,
    `TableView` will be told about it automatically and will redraw itself. Once we
    associate `TableView` with this list, all we have to worry about is the data,
    and the control will handle the rest. Creating `ObservableList` is pretty straightforward:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码，然后，为我们提供了一个 `List<ProcessHandle>`，其中包含当前进程可以看到的系统中每个进程，但这只完成了一半。`TableView`
    API 不接受 `List<T>`。它只支持 `ObservableList<T>`，但那是什么？它的 Javadoc 定义得非常简单--*一个允许监听器在变化发生时跟踪更改的列表*。换句话说，当这个列表发生变化时，`TableView`
    将自动被告知并重新绘制自己。一旦我们将 `TableView` 与这个列表关联起来，我们只需要担心数据，控制将处理其余部分。创建 `ObservableList`
    非常简单：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our case, the `TableView` instance is injected by the runtime (included here
    for clarity), and we create the `ObservableList` via `FXCollections.observableArrayList()`.
    In `initialize()`, we set the `ObservableList` on the `TableView` via `setItems()`,
    then populate the `ObservableList` via `setAll()`. With that, our `TableView`
    has all the data it needs to render itself. Almost. It has the **data** to render,
    but **how** does it do it? Where does each field of `ProcessHandle.Info` go? To
    answer that, we have to define the columns on the table, and tell each column
    where to get its data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`TableView` 实例由运行时注入（此处包含以供参考），我们通过 `FXCollections.observableArrayList()`
    创建 `ObservableList`。在 `initialize()` 中，我们通过 `setItems()` 将 `ObservableList` 设置在
    `TableView` 上，然后通过 `setAll()` 填充 `ObservableList`。这样，我们的 `TableView` 就拥有了渲染自身所需的所有数据。几乎是这样。它有渲染所需的数据，但它**如何**渲染呢？`ProcessHandle.Info`
    的每个字段去哪里了？为了回答这个问题，我们必须定义表上的列，并告诉每个列从哪里获取其数据。
- en: 'To do that, we need to create several `TableColumn<S,T>` instances. The `TableColumn`
    is responsible for displaying not only its column heading (as appropriate), but
    also the value of each cell. However, you have to tell it **how** to display the
    cell. That is done via a cell value factory. Under Java 7, that API would get
    us code like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要创建几个 `TableColumn<S,T>` 实例。`TableColumn` 负责显示其列标题（如适当），以及每个单元格的值。然而，你必须告诉它**如何**显示单元格。这是通过单元格值工厂来完成的。在Java
    7中，这个API会得到如下代码：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I''ll go ahead and say it for you: that''s really ugly. Fortunately, we can
    put lambdas and type inference to work for us, to make that a lot more pleasant
    to read:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我先为你说出来：这真的很丑陋。幸运的是，我们可以利用lambda表达式和类型推断来简化代码，使其更容易阅读：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That''s fourteen lines of code replaced by six. Much prettier. Now, we just
    have to do that five more times, once for each column. As improved as the preceding
    code may be, there''s still quite a bit of repeated code. Again, Java 8 functional
    interfaces can help us clean the code up a bit more. For each column, we want
    to specify the header, a width, and what to extract from `ProcessHandle.Info`.
    We can encapsulate that with this method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将十四行代码替换为六行。看起来更漂亮了。现在，我们只需要再这样做五次，每次对应一个列。尽管前面的代码已经有所改进，但仍然有相当多的重复代码。再次强调，Java
    8 函数式接口可以帮助我们进一步清理代码。对于每一列，我们想要指定标题、宽度和从 `ProcessHandle.Info` 中提取的内容。我们可以用这个方法来封装这些：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Function<T,R>` interface is `FunctionalInterface`, which represents a
    function that takes in one type, `T`, and returns another, `R`. In our case, we''re
    defining this method as one that takes as parameters a `String`, an `int`, and
    a function that takes in `ProcessHandle` and returns a generic type. That may
    be hard to picture, but with this method defined, we can replace the preceding
    code and the others like it with calls to this method. The same preceding code
    can now be condensed to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T,R>` 接口是 `FunctionalInterface`，它代表一个接受一个类型 `T` 并返回另一个类型 `R` 的函数。在我们的例子中，我们定义这个方法为接受一个
    `String`、一个 `int` 以及一个接受 `ProcessHandle` 并返回泛型类型的函数作为参数。这可能有点难以想象，但有了这个方法定义，我们可以用对这个方法的调用替换前面的代码以及类似的代码。现在，前面的相同代码可以简化为这样：'
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we just need to add these columns to the control, which we can do with
    this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将这些列添加到控件中，我们可以用这个方法来完成：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that every method we're using on `ProcessHandle.Info` returns the `Optional<T>`
    we looked at in the preceding code. Since it does this, we have a very nice and
    clean API to get the information we want (or a reasonable default) without the
    specter of a `NullPointerException` in production.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `ProcessHandle.Info` 上使用的每个方法都返回我们在前面代码中看到的 `Optional<T>`。由于它这样做，我们有一个非常优雅且干净的API来获取我们想要的信息（或合理的默认值），而无需在生产环境中担心
    `NullPointerException`。
- en: 'If we run the application now, we should get something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们应该得到类似这样的结果：
- en: '![](img/d410b6b6-9f06-4918-b874-24bfdb36f054.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d410b6b6-9f06-4918-b874-24bfdb36f054.png)'
- en: It's looking good so far, but it's not quite ready yet. We want to be able to
    start new processes as well as kill existing ones. Both of those will require
    menus, so we'll add those next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 目前看起来不错，但还不是完全准备好。我们希望能够启动新的进程以及终止现有的进程。这两者都需要菜单，所以我们将添加这些菜单。
- en: Adding menus
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加菜单
- en: 'Menus in JavaFX start with a component called `MenuBar`. We want this menu
    to be at the top of the window, of course, so we add the component to the `top`
    section of our `BorderPane`. If you use Scene Builder, you will end up with something
    like this in your FXML file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX中的菜单从 `MenuBar` 组件开始。我们当然希望这个菜单在窗口的顶部，所以我们将组件添加到我们的 `BorderPane` 的 `top`
    部分。如果你使用Scene Builder，你的FXML文件最终会变成这样：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We won''t be needing the edit menu, so we can remove that section from the
    FXML file (or by right-clicking on the second `Menu` entry in Scene Builder and
    clicking on Delete). To create the menu items we do want, we add the appropriate
    `MenuItem` entries to the `item` element under the `File` element:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要编辑菜单，所以我们可以从FXML文件中删除该部分（或者在Scene Builder中右键单击第二个 `Menu` 条目并点击删除）。要创建我们想要的菜单项，我们向
    `File` 元素下的 `item` 元素添加适当的 `MenuItem` 条目：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each of these `MenuItem` entries has three attributes defined:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些 `MenuItem` 条目都定义了三个属性：
- en: '`mnemonicParsing`: This instructs JavaFX to use any letter prefixed with an
    underscore as a keyboard shortcut'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnemonicParsing`：这指示JavaFX使用任何以下划线开头字母作为键盘快捷键'
- en: '`onAction`: This identifies the method on the controller that will be called
    when `MenuItem` is activated/clicked'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAction`：这标识了当 `MenuItem` 被激活/点击时将在控制器上被调用的方法'
- en: '`text`: This defines the label of `MenuItem`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：这定义了 `MenuItem` 的标签'
- en: 'The most interesting part is `onAction` and its relationship with the controller.
    JavaFX, of course, already knows that this form is backed by `com.steeplesoft.procman.
    Controller`, so it will look for a method with the following signature:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是 `onAction` 以及它与控制器的关系。JavaFX 当然知道这个形式是由 `com.steeplesoft.procman.Controller`
    支持的，所以它会寻找具有以下签名的方：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`ActionEvent` is a class that is used in a number of scenarios by JavaFX. In
    our case, we have methods specifically for each menu item, so the event itself
    isn''t too terribly interesting. Let''s take a look at each handler, starting
    with the simplest--`closeApplication`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionEvent` 是一个在 JavaFX 中被用于多种场景的类。在我们的情况下，我们有针对每个菜单项的特定方法，所以事件本身并不太有趣。让我们看看每个处理程序，从最简单的
    `closeApplication` 开始：'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's nothing much to see here; when the menu item is clicked, we exit the
    application by calling `Platform.exit()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么可看的；当菜单项被点击时，我们通过调用 `Platform.exit()` 来退出应用程序。
- en: 'Next up, let''s see how to kill a process:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何终止一个进程：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have quite a bit going on here. The first thing we do is to create an `Alert`
    box of type `CONFIRMATION`, which asks the user to confirm the request. The dialog
    has two buttons: `YES` and `NO`. Once the dialog has been created, we call `showAndWait()`,
    which does as its name implies--it shows the dialog and waits for the user''s
    response. It returns `Optional<ButtonType>`, which holds the type of the button
    that the user clicked on, which will either be `ButtonType.YES` or `ButtonType.NO`,
    given the type of `Alert` box we''ve created. With `Optional`, we can apply `filter()`
    to find only the type of button that we''re interested in, which is `ButtonType.YES`,
    the result of which is another `Optional`. If the user clicked on yes, `ifPresent()`
    will return true (thanks to our filter), and the lambda we passed in will be executed.
    Very nice and concise.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有很多事情要做。我们首先做的是创建一个类型为 `CONFIRMATION` 的 `Alert` 对话框，该对话框要求用户确认请求。对话框有两个按钮：`YES`
    和 `NO`。一旦对话框创建完成，我们就调用 `showAndWait()`，正如其名称所暗示的那样——它会显示对话框并等待用户的响应。它返回 `Optional<ButtonType>`，该类型包含用户点击的按钮类型，这将是
    `ButtonType.YES` 或 `ButtonType.NO`，这取决于我们创建的 `Alert` 对话框类型。使用 `Optional`，我们可以应用
    `filter()` 来找到我们感兴趣的按钮类型，即 `ButtonType.YES`，这将返回另一个 `Optional`。如果用户点击了是，`ifPresent()`
    将返回 true（多亏了我们的过滤器），然后我们传递的 lambda 将被执行。非常棒且简洁。
- en: The next area of interest is that lambda. Once we've identified **that** the
    user would like to kill a process, we need to identify **which** process to kill.
    To do that, we ask `TableView` which row is selected via `TableView.getSelectionModel()
    .getSelectedItem()`. We do need to check for null (alas, there's no `Optional`
    here) in the event that the user has not actually selected a row. If it is non-null,
    we can call `destroy()` on the `ProcessHandle` the `TableView` gives us. We then
    call `processListUpdater.updateList()` to refresh the UI. We'll take a look at
    that later.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个感兴趣的区域是 lambda。一旦我们确定用户想要终止一个进程，我们需要确定要终止哪个进程。为此，我们通过 `TableView.getSelectionModel()
    .getSelectedItem()` 询问 `TableView` 哪一行被选中。如果我们需要检查 null（唉，这里没有 `Optional`），我们必须这样做，以防用户实际上没有选择任何行。如果它非空，我们可以在
    `TableView` 给我们的 `ProcessHandle` 上调用 `destroy()`。然后我们调用 `processListUpdater.updateList()`
    来刷新 UI。我们稍后再来看这个。
- en: 'Our final action handler has to run the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的动作处理程序必须运行以下命令：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is, in many ways, similar to the preceding `killProcessHandler()` method--we
    create a dialog, set some options, call `showAndWait()`, then process `Optional`.
    Unfortunately, the dialog doesn't support the builder pattern, meaning we don't
    have a nice, fluid API to build the dialog, so we do it in several discrete steps.
    Processing `Optional` is also similar. We call `ifPresent()` to see if the dialog
    returned a command line (that is, the user entered some text **and** pressed OK),
    and pass that to the lambda if present.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这与前面的 `killProcessHandler()` 方法相似——我们创建一个对话框，设置一些选项，调用 `showAndWait()`，然后处理
    `Optional`。不幸的是，对话框不支持构建器模式，这意味着我们没有漂亮的、流畅的 API 来构建对话框，所以我们分几个离散的步骤来做。处理 `Optional`
    也类似。我们调用 `ifPresent()` 来查看对话框是否返回了一个命令行（即用户输入了一些文本并且按下了 OK），如果有的话，将其传递给 lambda。
- en: Let's take a quick look at the lambda. This is another example of a multiline
    lambda. Whereas most lambdas we've seen so far have been simple, one-line functions,
    remember that a lambda **can** span multiple lines. All that needs to be done
    to support that is to wrap the block in curly braces as we've done, and it's business
    as usual. Care must be taken with multiline lambdas like this, as any gains in
    readability and conciseness that lambdas give us can be quickly obscured or erased
    by a lambda body that grows too large. In those instances, extracting the code
    out to a method and using a method reference might be the wise thing to do. Ultimately,
    the decision is yours, but remember the words of Uncle Bob Martin--*Clarity is
    king*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下lambda。这是另一个多行lambda的例子。虽然我们之前看到的lambda大多数都是简单的单行函数，但请记住，lambda**可以**跨越多行。为了支持这一点，我们只需要像我们这样做，用大括号包裹代码块，然后一切照旧。对于这样的多行lambda，必须小心，因为lambda给我们带来的可读性和简洁性的任何收益都可能很快被一个变得太大的lambda体所掩盖或消除。在这些情况下，将代码提取到方法中并使用方法引用可能是明智的选择。最终，决定权在你，但请记住Uncle
    Bob Martin的话--*清晰是王道*。
- en: 'One final item on the topic of menus. To be even more useful, the application
    should provide a context menu that will allow the user to right-click on a process
    and kill it from there, as opposed to clicking on the row, moving the mouse to
    the `File` menu, and more. Adding a context menu is a simple operation. All we
    need to do is modify our `TableView` definition in FXML like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于菜单的一个最后项目。为了更加有用，应用程序应该提供一个上下文菜单，允许用户右键单击一个进程并从那里将其终止，而不是点击行，将鼠标移动到`File`菜单，等等。添加上下文菜单是一个简单的操作。我们只需要像这样修改我们的`TableView`定义在FXML中：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are adding a `contextMenu` child to our `TableView`. Much like its
    sibling, `MenuBar`, `contextMenu` has an `items` child, which, in turn, has 0
    or more `MenuItem` children. In this case, the `MenuItem` for `Kill Process...`
    looks remarkably like that under `File`, with the only difference being the `mnemonicProcessing`
    information. We're even reusing the `ActionEvent` handler, so there's no extra
    coding, and the behavior for killing a process is always the same, regardless
    of which menu item you click on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向我们的`TableView`添加了一个`contextMenu`子项。与它的兄弟`MenuBar`类似，`contextMenu`有一个`items`子项，该子项反过来又有0个或多个`MenuItem`子项。在这种情况下，`Kill
    Process...`的`MenuItem`看起来与`File`下的非常相似，唯一的区别是`mnemonicProcessing`信息。我们甚至重用了`ActionEvent`处理程序，所以没有额外的编码，无论你点击哪个菜单项，终止进程的行为总是相同的。
- en: Updating the process list
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新进程列表
- en: If the application started and showed a list of processes, but never updated
    that list, it wouldn't be very useful at all. What we then need is a way to update
    the list periodically, and for that, we'll use a `Thread`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序启动并显示了一个进程列表，但从未更新过该列表，那么它将毫无用处。我们需要的，是能够定期更新列表的方法，为此，我们将使用一个`Thread`。
- en: As you may or may not know, a `Thread` is roughly a means to run a task in the
    background (the Javadoc describes it as a *thread of execution in a program*).
    A system can be single or multithreaded, depending on the needs and runtime environment
    of the system. And multithreaded programming is hard to get right. Luckily, our
    use case here is fairly simple, but we must still exercise caution, or we'll see
    some really unexpected behavior.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知或不知，`Thread`大致是一种在后台运行任务的方式（Javadoc将其描述为程序中的*执行线程*）。一个系统可以是单线程或多线程的，这取决于系统的需求和运行时环境。多线程编程很难做对。幸运的是，我们的用例相当简单，但我们仍然必须谨慎行事，否则我们会看到一些非常意外的行为。
- en: 'Ordinarily, the advice you would get when creating a `Thread` is to implement
    a `Runnable` interface, which you will then pass to the thread''s constructor,
    and that''s very good advice, as it makes your class hierarchy much more flexible,
    since you''re not tied to a concrete base class (`Runnable` is an `interface`).
    In our case, however, we have a relatively simple system that has little to gain
    from that approach, so we''ll extend `Thread` directly and simplify our code a
    little as well as encapsulating our desired behavior. Let''s take a look at our
    new class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当你创建一个`Thread`时，你会得到这样的建议：实现一个`Runnable`接口，然后将它传递给线程的构造函数，这是一个非常好的建议，因为它使你的类层次结构更加灵活，因为你不会绑定到一个具体的基类（`Runnable`是一个`interface`）。然而，在我们的案例中，我们有一个相对简单的系统，从这个方法中获得的收益很小，所以我们将直接扩展`Thread`并简化我们的代码，同时封装我们期望的行为。让我们看看我们的新类：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have a pretty basic class, which we've given a reasonable and meaningful
    name that extends `Thread`. In the constructor, note that we call `setDaemon(true)`.
    This will allow our application to exit as expected and not block, waiting for
    the thread to terminate. We've also defined a `shutdown()` method, which we'll
    use from our application to stop the thread.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个相当基础的类，我们给它起了一个合理且具有意义的名字，它扩展了`Thread`类。在构造函数中，请注意我们调用了`setDaemon(true)`。这将允许我们的应用程序按预期退出，而不是阻塞等待线程终止。我们还定义了一个`shutdown()`方法，我们将从应用程序中使用它来停止线程。
- en: The `Thread` class does have various state control methods, such as `stop()`,
    `suspend()`, `resume()`, and more, but these have all been deprecated as they
    are considered inherently unsafe. Search for the article, Why are `Thread.stop`,
    `Thread.suspend`, and `Thread.resume` deprecated? If you would like more details;
    however, the suggested best practice now is to use a control flag, like we've
    done with `running`, to signal to the `Thread` class that it needs to clean up
    and shut down.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类确实有各种状态控制方法，如`stop()`、`suspend()`、`resume()`等，但这些都已被弃用，因为它们被认为固有不安全。搜索文章《为什么`Thread.stop`、`Thread.suspend`和`Thread.resume`被弃用？》，如果你想了解更多细节；然而，现在的建议最佳实践是使用控制标志，就像我们用`running`做的那样，向`Thread`类发出信号，表明它需要清理和关闭。'
- en: 'Finally, we have the heart of our `Thread` class, `run()`, which loops infinitely
    (or until `running` becomes false), sleeping for five seconds after performing
    its work. The actual work is done in `updateList()`, which builds the list of
    processes, updates `ObservableList` we discussed earlier, and then instructs `TableView`
    to re-sort itself, based on the user''s sort selection, if any. This is a public
    method, allowing us to call this at need, as we did in `killProcessHandler()`.
    That leaves us with the following block of code to set it up:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了`Thread`类的核心，即`run()`方法，它无限循环（或者直到`running`变为false），在执行完工作后休眠五秒钟。实际的工作是在`updateList()`中完成的，它构建进程列表，更新我们之前讨论过的`ObservableList`，然后指示`TableView`根据用户的排序选择重新排序（如果有的话）。这是一个公共方法，允许我们在需要时调用它，就像我们在`killProcessHandler()`中做的那样。这让我们有了以下代码块来设置它：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code will shut it down, which we''ve already seen in `closeHandler()`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将关闭它，这我们在`closeHandler()`中已经看到了：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The eagle-eyed will notice that `updateList()` has the `synchronized` keyword
    on it. This is to prevent any sort of race condition that might be caused by calling
    this method from multiple threads. Imagine the scenario where the user decides
    to kill a process and clicks on OK on the confirmation dialog at the exact moment
    the thread wakes up (this type of thing happens more often than you might think).
    We could conceivably have two threads calling `updateList()` at the same time,
    resulting in the first thread hitting `processView.sort()` just as the second
    is hitting `processList.setAll()`. What happens when `sort()` is called while
    another thread is rebuilding the list? It's hard to say for sure, but it could
    be catastrophic, so we want to disallow that. The `synchronized` keyword instructs
    the JVM to allow only one thread to execute the method at a time, causing all
    others to queue up, waiting their turn (note that their execution order is non-deterministic,
    so you can't base any expectations on the order in which threads get to run a
    `synchronized` method). This avoids the potential for a race condition, and ensures
    that our program doesn't crash.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 留意细节的人会注意到`updateList()`上有`synchronized`关键字。这是为了防止由于从多个线程调用此方法而可能引起的任何类型的竞争条件。想象一下这样的场景：当用户决定终止一个进程，并在线程唤醒时点击确认对话框上的OK按钮（这类事情发生的频率可能比你想象的要高）。我们可能有两个线程同时调用`updateList()`，结果第一个线程在第二个线程击中`processView.sort()`时刚好触发了`processList.setAll()`。当另一个线程正在重建列表时调用`sort()`会发生什么？很难确定，但可能会造成灾难性的后果，所以我们想禁止这种情况。`synchronized`关键字指示JVM只允许一次只有一个线程执行该方法，导致其他所有线程排队等待轮到它们（请注意，它们的执行顺序是非确定性的，所以你不能根据线程运行`synchronized`方法的顺序来建立任何期望）。这避免了竞争条件的发生，并确保我们的程序不会崩溃。
- en: While appropriate here, care must be taken with `synchronized` methods, as acquiring
    and releasing the locks can be expensive (though much less so with modern JVMs)
    and, more importantly, it forces threads to run sequentially when they hit this
    method call, which can cause a very undesirable lag in the application, especially
    in GUI applications. Keep that in mind when writing your own multithreaded applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这里是合适的，但在使用`同步`方法时必须小心，因为获取和释放锁可能代价高昂（尽管在现代化的JVM中要小得多），更重要的是，它强制线程在遇到这个方法调用时按顺序运行，这可能导致应用程序中出现非常不希望出现的延迟，尤其是在GUI应用程序中。在编写自己的多线程应用程序时，请记住这一点。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that in place, our application is complete. While not a terribly complex
    application, it does include several interesting technologies such as JavaFX,
    Lambdas, Streams, `ProcessHandle` plus related classes, and Threads.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们的应用程序就完成了。虽然这不是一个特别复杂的应用程序，但它确实包括了几个有趣的技术，例如JavaFX、Lambda表达式、Streams、`ProcessHandle`以及相关的类，还有线程。
- en: In the next chapter, we'll build a simple command-line utility to find duplicate
    files. Through that, we'll get hands-on experience with the new File I/O APIs,
    the Java Persistence API (JPA), file hashing, and some more JavaFX.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个简单的命令行工具来查找重复文件。通过这个过程，我们将亲身体验新的文件I/O API、Java持久化API（JPA）、文件哈希以及一些JavaFX。
