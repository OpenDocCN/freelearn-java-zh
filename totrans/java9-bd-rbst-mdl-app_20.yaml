- en: Managing Processes in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a very quick tour through some of the big new features of Java 9, as well
    as those from a couple of previous releases, let's turn our attention to applying
    some of these new APIs in a practical manner. We'll start with a simple process
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'While having your application or utility handle all of your user''s concerns
    internally is usually ideal, occasionally you need to run (or **shell out to**)
    an external program for a variety of reasons. From the very first days of Java,
    this was supported by the JDK via the `Runtime` class via a variety of APIs. Here
    is the simplest example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the process has been created, you can track its execution via the `Process`
    class, which has methods such as `getInputStream()`, `getOutputStream()`, and
    `getErrorStream()`. We have also had rudimentary control over the process via
    `destroy()` and `waitFor()`. Java 8 moved things forward by adding `destroyForcibly()`
    and `waitFor(long, TimeUnit)`. Starting with Java 9, these capabilities will be
    expanded. Quoting from the **Java Enhancement Proposal** (**JEP**), we see the
    following reasons for this new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Many enterprise applications and containers involve several Java virtual machines
    and processes and have long-standing needs that include the following:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The ability to get the pid (or equivalent) of the current Java virtual machine
    and the pid of processes created with the existing API.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The ability to enumerate processes on the system. Information on each process
    may include its pid, name, state, and perhaps resource usage.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The ability to deal with process trees, in particular, some means to destroy
    a process tree.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The ability to deal with hundreds of sub-processes, perhaps multiplexing the
    output or error streams to avoid creating a thread per sub-process.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll build a simple process manager application, akin to Windows
    Task Manager or *nix's top. There is, of course, little need for a process manager
    written in Java, but this will be an excellent avenue for us to explore these
    new process handling APIs. Additionally, we'll spend some time with other language
    features and APIs, namely, JavaFX and `Optional`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrapping the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the process list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that said, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically speaking, it is much better if a build can be reproduced without
    requiring the use of a specific IDE or some other proprietary tool. Fortunately,
    NetBeans offers the ability to create a Maven-based JavaFX project. Click on File
    | New Project and select `Maven`, then JavaFX Application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd7f9cac-f8dd-4668-b89c-cb5d902f767e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter Project Name as `ProcessManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter Group ID as `com.steeplesoft`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter Package as `com.steeplesoft.processmanager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Project Location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following screenshot as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa6a4134-f552-4d1e-867a-aa7fd8eb509d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the new project has been created, we need to update the Maven `pom` to
    use Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, with both NetBeans and Maven configured to use Java 9, we're ready to start
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As noted in the introduction, this will be a JavaFX-based application, so we''ll
    start by creating the skeleton for the application. This is a Java 9 application,
    and we intend to make use of the Java Module System. To do that, we need to create
    the module definition file, `module-info.java`, which resides in the root of our
    source tree. This being a Maven-based project, that would be `src/main/java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This small file does a couple of different things. First, it defines a new
    `procman.app` module. Next, it tells the system that this module `requires` two
    JDK modules: `javafx.controls` and `javafx.fxml`. If we did not specify these
    two modules, then our system, which we''ll see below, would not compile, as the
    JDK would not make the required classes and packages available to our application.
    These modules are part of the standard JDK as of Java 9, so that shouldn''t be
    an issue. However, that may change in future versions of Java, and this module
    declaration will help prevent runtime failures in our application by forcing the
    host JVM to provide the module or fail to start. It is also possible to build
    custom Java runtimes via the **J-Link** tool, so missing these modules is still
    a possibility under Java 9\. With our module configured, let''s turn to the application.'
  prefs: []
  type: TYPE_NORMAL
- en: The emerging standard directory layout seems to be something like `src/main/java/*<module1>*`,
    `src/main/java/*<module2>*`, and so on. At the time of writing this book, while
    Maven can be coaxed into such a layout, the plugins themselves, while they do
    run under Java 9, do not appear to be module-aware enough to allow us to organize
    our code in such a manner. For that reason, and for the sake of simplicity, we
    will treat one Maven module as one Java module and maintain the standard source
    layout for the projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first class we will create is the `Application` descendant, which NetBeans
    created for us. It created the `Main` class, which we renamed to `ProcessManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our `ProcessManager` class extends the JavaFX base class, `Application`, which
    provides a variety of functionality to start and stop the application. We see
    in the `main()` method that we simply delegate to `Application.launch(String[])`,
    which does the heavy lifting for us in starting our new application.
  prefs: []
  type: TYPE_NORMAL
- en: The more interesting part of this class is the `start()` method, which is where
    the JavaFX life cycle calls back into our application, giving us the opportunity
    to build the user interface, which we'll do next.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When building the user interface for a JavaFX application, you can do it in
    one of two ways: code or markup. To keep our code smaller and more readable, we''ll
    build the user interface using FXML--the XML-based language created specifically
    for JavaFX to express user interfaces. This presents us with another binary choice--do
    we write the XML by hand, or do we use a graphical tool? Again, the choice is
    a simple one--we''ll use a tool, **Scene Builder**, which is a WYSIWYG tool originally
    developed by Oracle and now maintained and supported by Gluon. We will, however,
    also be looking at the XML source so that we can understand what''s being done,
    so if you don''t like using a GUI tool, you won''t be left out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing and using Scene Builder is, as you would expect, pretty straightforward.
    It can be downloaded from [http://gluonhq.com/labs/scene-builder/](http://gluonhq.com/labs/scene-builder/).
    Once installed, you need to tell NetBeans where to find it, which can be done
    in the Settings window, under Java | JavaFX, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81811a5e-6f76-48b8-89f6-088e568110ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now ready to create the FXML file. Under the `resources` directory in
    the Project View, create a new folder called `fxml`, and in that folder, create
    a file called `procman.fxml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`BorderPane` is a container that defines five regions--`top`, `bottom`, `left`,
    `right`, and `center`, giving us a fairly coarsely-grained control over where
    on the form the controls should appear. Typically, with `BorderPane`, each area
    uses a nested container to provide the finer-grained control often necessary.
    For our needs, this level of control will be perfect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary concern of the user interface is the list of processes, so we''ll
    start with the controls for that. From Scene Builder, we want to click on the
    `Controls` section on the accordion on the left, then scroll down to `TableView`.
    Click on this and drag it to the `CENTER` region on the form, as shown here in
    this screenshot from Scene Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d31ced44-1013-43bd-9262-c0709044c806.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The resulting FXML should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With no components in the other areas, `TableView` will expand to fill the window's
    full area, which is what we want for now.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the FXML defines the structure of the user interface, we do need some
    Java code to initialize various elements, respond to actions, and so forth. This
    class, referred to as the controller, is simply a class that extends `javafx.fxml.Initializable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initialize()` method comes from the interface, and is used by the JavaFX
    runtime to initialize the controller when it is created in the call to `FXMLLoader.load()`
    from the preceding `Application` class. Note the `@FXML` annotation on the instance
    variable `processList`. When JavaFX initializes the controller, before the `initialize()`
    method is called, the system looks for FXML elements that specify an `fx:id` attribute,
    and assigns that reference to the appropriate instance variable in the controller.
    To complete this connection, we must make one more change to our FXML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The change can also be made in Scene Builder as seen in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/799dc8e9-e32a-4810-8ff6-53b08e4b30ab.png)'
  prefs: []
  type: TYPE_IMG
- en: The value of the fx:id attribute must match the name of an instance variable
    that has been annotated with `@FXML`. When `initialize` is called, `processList`
    will have a valid reference to `TableView` that we can manipulate in our Java
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The value of fx:id can be set via Scene Builder as well. To set the value, click
    on the control in the form editor, then expand the Code section in the accordion
    on the right. In the fx:id field, type in the name of the desired variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of the puzzle is specifying the controller for the FXML file.
    In the XML source, you can set this via the `fx:controller` attribute on the root
    element of the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be set via Scene Builder. In the Document section of the accordion
    on the left, expand the Controller section and enter the desired fully-qualified
    class name in the Controller class field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/979ca94b-075a-4410-98c2-6aa383bf9217.png)'
  prefs: []
  type: TYPE_IMG
- en: With those pieces in place, we can begin the work of initializing `TableView`,
    which gets us back to our primary interest, the process handling APIs. Our starting
    point is `ProcessHandles.allProcesses()`. From the Javadoc, you learn that this
    method returns **a snapshot of all processes visible to the current process**.
    From each `ProcessHandle` in the stream, we can get information about the process
    ID, its state, children, parents, and so on. Each `ProcessHandle` also has a nested
    object, `Info`, that contains a snapshot of information about the process. Since
    not all information is available across the various supported platforms and it
    is limited by the privileges of the current process, the properties on the `Info`
    object are the `Optional<T>` instances, indicating that the values may or may
    not be set. It's probably worth the time to take a quick look at what `Optional<T>`
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Javadoc describes `Optional<T>` as a **container object which may or may
    not contain a non-null value**. Inspired by Scala and Haskell, `Optional<T>` was
    introduced in Java 8 to allow API authors to provide a more null-safe interface.
    Prior to Java 8, a method on `ProcessHandle.Info` may be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To consume the API, the developer would likely write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the developer fails to check for null explicitly, `NullPointerException`
    is almost certain to occur at some point. By using `Optional<T>`, the API author
    signals to the user that the return value may be null and should be handled carefully.
    The updated code, then, may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, in one concise line, we can get the value, if it is present, or a default
    if it is not. The `ProcessHandle.Info` API makes extensive use of this construct
    as we'll see later.
  prefs: []
  type: TYPE_NORMAL
- en: 'What else does `Optional` afford us as developers? There are a number of instance
    methods that can help clarify null-handling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter(Predicate<? super T> predicate)`: With this method, we filter the contents
    of `Optional`. Rather than using an `if...else` block, we can pass the `filter()`
    method a `Predicate` and do the test inline. A `Predicate` is a `@FunctionalInterface`
    that takes an input and returns a Boolean. For example, some uses of the JavaFX
    `Dialog` may return `Optional<ButtonType>`. If we wanted to do something **only**
    if the user clicked a specific button, say, OK, we could filter `Optional` like
    this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`map(Function<? super T,? extends U> mapper)`: The `map` function allows us
    to pass the contents of `Optional` to a function, which will perform some processing
    on it, and return it. The return from the function, though, will be wrapped in
    an `Optional`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note the double wrapping in `Optional` for `upper2`. If `Function` returns `Optional`,
    it will be wrapped in another `Optional`, giving us this odd double wrap, which
    is less than desirable. Fortunately, we have an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: '`flatMap(Function<? super T,Optional<U>> mapper)`: The `flatMap` function combines
    two functional ideas--maps and flatten. If the result of `Function` is an `Optional`
    object, rather than double wrapping the value, it is flattened to a single `Optional`
    object. Revisiting the preceding example, we get this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `upper3`, unlike `upper2`, is a single `Optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get()`: This returns the wrapped value, if present. If there is no value,
    a `NoSuchElementException` error is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifPresent(Consumer<? super T> action)`: If the `Optional` object contains
    a value, it is passed to the `Consumer`. If there is no value present, nothing
    happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`: Like `ifPresent()`,
    this will pass the value to the `Consumer` if there is one present. If no value
    is present, the `Runnable emptyAction` is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isPresent()`: This simply returns true if the `Optional` object contains a
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or(Supplier<Optional<T>> supplier)`: If the `Optional` object has a value,
    the `Optional` is described. If there is no value present, an `Optional` object
    produced by the `Supplier` is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orElse(T other)`: If the `Optional` object contains a value, it is returned.
    If there is no value, `other` is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orElseGet(Supplier<? extends T> supplier)`: This works just like `orElse()`
    mentioned earlier, but, if no value is present, the result of the `Supplier` is
    returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orElseThrow(Supplier<? extends X> exceptionSupplier)`: If there is a value
    present, it is returned. If there is no value, the `Exception` provided by the
    `Supplier` is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Optional` also has several static methods that facilitate the creation of
    the `Optional` instances, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`empty()`: This returns an empty `Optional` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of(T value)`: This returns an `Optional` object describing the non-null value.
    If the value is null, a `NullPointerException` is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ofNullable(T value)`: This returns an `Optional` object describing the value.
    If the value is null, an empty `Optional` is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that very brief introduction to `Optional<T>` under our belts, let's see
    how its presence affects our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning our attention to the `initialize()` method, then, our first step
    is to get the list of processes to display. The streams API makes this extremely
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `allProcesses()` method returns `Stream<ProcessHandle>`, which allows us
    to apply the new stream operations to our problem. In this case, we just want
    to create a `List` of all of the `ProcessHandle` instances, so we call `collect()`,
    which is a stream operation that takes in a `Collector`. There are a number of
    options from which we could choose, but we want a `List`, so we use `Collectors.toList()`,
    which will collect each item in the stream and eventually return a `List` when
    the stream terminates. Note that the parameterized type of `List` will match that
    of `Stream`, which is `ProcessHandle` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'This one line, then, gets us a `List<ProcessHandle>` of every process on the
    system that the current process can see, but that only gets us halfway. The `TableView`
    API doesn''t accept a `List<T>`. It only supports `ObservableList<T>`, but what
    is that? Its Javadoc defines it very simply--*A list that allows listeners to
    track changes when they occur*. To put it another way, when this list changes,
    `TableView` will be told about it automatically and will redraw itself. Once we
    associate `TableView` with this list, all we have to worry about is the data,
    and the control will handle the rest. Creating `ObservableList` is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the `TableView` instance is injected by the runtime (included here
    for clarity), and we create the `ObservableList` via `FXCollections.observableArrayList()`.
    In `initialize()`, we set the `ObservableList` on the `TableView` via `setItems()`,
    then populate the `ObservableList` via `setAll()`. With that, our `TableView`
    has all the data it needs to render itself. Almost. It has the **data** to render,
    but **how** does it do it? Where does each field of `ProcessHandle.Info` go? To
    answer that, we have to define the columns on the table, and tell each column
    where to get its data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to create several `TableColumn<S,T>` instances. The `TableColumn`
    is responsible for displaying not only its column heading (as appropriate), but
    also the value of each cell. However, you have to tell it **how** to display the
    cell. That is done via a cell value factory. Under Java 7, that API would get
    us code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll go ahead and say it for you: that''s really ugly. Fortunately, we can
    put lambdas and type inference to work for us, to make that a lot more pleasant
    to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s fourteen lines of code replaced by six. Much prettier. Now, we just
    have to do that five more times, once for each column. As improved as the preceding
    code may be, there''s still quite a bit of repeated code. Again, Java 8 functional
    interfaces can help us clean the code up a bit more. For each column, we want
    to specify the header, a width, and what to extract from `ProcessHandle.Info`.
    We can encapsulate that with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Function<T,R>` interface is `FunctionalInterface`, which represents a
    function that takes in one type, `T`, and returns another, `R`. In our case, we''re
    defining this method as one that takes as parameters a `String`, an `int`, and
    a function that takes in `ProcessHandle` and returns a generic type. That may
    be hard to picture, but with this method defined, we can replace the preceding
    code and the others like it with calls to this method. The same preceding code
    can now be condensed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we just need to add these columns to the control, which we can do with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that every method we're using on `ProcessHandle.Info` returns the `Optional<T>`
    we looked at in the preceding code. Since it does this, we have a very nice and
    clean API to get the information we want (or a reasonable default) without the
    specter of a `NullPointerException` in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the application now, we should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d410b6b6-9f06-4918-b874-24bfdb36f054.png)'
  prefs: []
  type: TYPE_IMG
- en: It's looking good so far, but it's not quite ready yet. We want to be able to
    start new processes as well as kill existing ones. Both of those will require
    menus, so we'll add those next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Menus in JavaFX start with a component called `MenuBar`. We want this menu
    to be at the top of the window, of course, so we add the component to the `top`
    section of our `BorderPane`. If you use Scene Builder, you will end up with something
    like this in your FXML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We won''t be needing the edit menu, so we can remove that section from the
    FXML file (or by right-clicking on the second `Menu` entry in Scene Builder and
    clicking on Delete). To create the menu items we do want, we add the appropriate
    `MenuItem` entries to the `item` element under the `File` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these `MenuItem` entries has three attributes defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mnemonicParsing`: This instructs JavaFX to use any letter prefixed with an
    underscore as a keyboard shortcut'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onAction`: This identifies the method on the controller that will be called
    when `MenuItem` is activated/clicked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`: This defines the label of `MenuItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most interesting part is `onAction` and its relationship with the controller.
    JavaFX, of course, already knows that this form is backed by `com.steeplesoft.procman.
    Controller`, so it will look for a method with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`ActionEvent` is a class that is used in a number of scenarios by JavaFX. In
    our case, we have methods specifically for each menu item, so the event itself
    isn''t too terribly interesting. Let''s take a look at each handler, starting
    with the simplest--`closeApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing much to see here; when the menu item is clicked, we exit the
    application by calling `Platform.exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let''s see how to kill a process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have quite a bit going on here. The first thing we do is to create an `Alert`
    box of type `CONFIRMATION`, which asks the user to confirm the request. The dialog
    has two buttons: `YES` and `NO`. Once the dialog has been created, we call `showAndWait()`,
    which does as its name implies--it shows the dialog and waits for the user''s
    response. It returns `Optional<ButtonType>`, which holds the type of the button
    that the user clicked on, which will either be `ButtonType.YES` or `ButtonType.NO`,
    given the type of `Alert` box we''ve created. With `Optional`, we can apply `filter()`
    to find only the type of button that we''re interested in, which is `ButtonType.YES`,
    the result of which is another `Optional`. If the user clicked on yes, `ifPresent()`
    will return true (thanks to our filter), and the lambda we passed in will be executed.
    Very nice and concise.'
  prefs: []
  type: TYPE_NORMAL
- en: The next area of interest is that lambda. Once we've identified **that** the
    user would like to kill a process, we need to identify **which** process to kill.
    To do that, we ask `TableView` which row is selected via `TableView.getSelectionModel()
    .getSelectedItem()`. We do need to check for null (alas, there's no `Optional`
    here) in the event that the user has not actually selected a row. If it is non-null,
    we can call `destroy()` on the `ProcessHandle` the `TableView` gives us. We then
    call `processListUpdater.updateList()` to refresh the UI. We'll take a look at
    that later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final action handler has to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is, in many ways, similar to the preceding `killProcessHandler()` method--we
    create a dialog, set some options, call `showAndWait()`, then process `Optional`.
    Unfortunately, the dialog doesn't support the builder pattern, meaning we don't
    have a nice, fluid API to build the dialog, so we do it in several discrete steps.
    Processing `Optional` is also similar. We call `ifPresent()` to see if the dialog
    returned a command line (that is, the user entered some text **and** pressed OK),
    and pass that to the lambda if present.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the lambda. This is another example of a multiline
    lambda. Whereas most lambdas we've seen so far have been simple, one-line functions,
    remember that a lambda **can** span multiple lines. All that needs to be done
    to support that is to wrap the block in curly braces as we've done, and it's business
    as usual. Care must be taken with multiline lambdas like this, as any gains in
    readability and conciseness that lambdas give us can be quickly obscured or erased
    by a lambda body that grows too large. In those instances, extracting the code
    out to a method and using a method reference might be the wise thing to do. Ultimately,
    the decision is yours, but remember the words of Uncle Bob Martin--*Clarity is
    king*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final item on the topic of menus. To be even more useful, the application
    should provide a context menu that will allow the user to right-click on a process
    and kill it from there, as opposed to clicking on the row, moving the mouse to
    the `File` menu, and more. Adding a context menu is a simple operation. All we
    need to do is modify our `TableView` definition in FXML like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are adding a `contextMenu` child to our `TableView`. Much like its
    sibling, `MenuBar`, `contextMenu` has an `items` child, which, in turn, has 0
    or more `MenuItem` children. In this case, the `MenuItem` for `Kill Process...`
    looks remarkably like that under `File`, with the only difference being the `mnemonicProcessing`
    information. We're even reusing the `ActionEvent` handler, so there's no extra
    coding, and the behavior for killing a process is always the same, regardless
    of which menu item you click on.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the process list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the application started and showed a list of processes, but never updated
    that list, it wouldn't be very useful at all. What we then need is a way to update
    the list periodically, and for that, we'll use a `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: As you may or may not know, a `Thread` is roughly a means to run a task in the
    background (the Javadoc describes it as a *thread of execution in a program*).
    A system can be single or multithreaded, depending on the needs and runtime environment
    of the system. And multithreaded programming is hard to get right. Luckily, our
    use case here is fairly simple, but we must still exercise caution, or we'll see
    some really unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinarily, the advice you would get when creating a `Thread` is to implement
    a `Runnable` interface, which you will then pass to the thread''s constructor,
    and that''s very good advice, as it makes your class hierarchy much more flexible,
    since you''re not tied to a concrete base class (`Runnable` is an `interface`).
    In our case, however, we have a relatively simple system that has little to gain
    from that approach, so we''ll extend `Thread` directly and simplify our code a
    little as well as encapsulating our desired behavior. Let''s take a look at our
    new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have a pretty basic class, which we've given a reasonable and meaningful
    name that extends `Thread`. In the constructor, note that we call `setDaemon(true)`.
    This will allow our application to exit as expected and not block, waiting for
    the thread to terminate. We've also defined a `shutdown()` method, which we'll
    use from our application to stop the thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread` class does have various state control methods, such as `stop()`,
    `suspend()`, `resume()`, and more, but these have all been deprecated as they
    are considered inherently unsafe. Search for the article, Why are `Thread.stop`,
    `Thread.suspend`, and `Thread.resume` deprecated? If you would like more details;
    however, the suggested best practice now is to use a control flag, like we've
    done with `running`, to signal to the `Thread` class that it needs to clean up
    and shut down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the heart of our `Thread` class, `run()`, which loops infinitely
    (or until `running` becomes false), sleeping for five seconds after performing
    its work. The actual work is done in `updateList()`, which builds the list of
    processes, updates `ObservableList` we discussed earlier, and then instructs `TableView`
    to re-sort itself, based on the user''s sort selection, if any. This is a public
    method, allowing us to call this at need, as we did in `killProcessHandler()`.
    That leaves us with the following block of code to set it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will shut it down, which we''ve already seen in `closeHandler()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The eagle-eyed will notice that `updateList()` has the `synchronized` keyword
    on it. This is to prevent any sort of race condition that might be caused by calling
    this method from multiple threads. Imagine the scenario where the user decides
    to kill a process and clicks on OK on the confirmation dialog at the exact moment
    the thread wakes up (this type of thing happens more often than you might think).
    We could conceivably have two threads calling `updateList()` at the same time,
    resulting in the first thread hitting `processView.sort()` just as the second
    is hitting `processList.setAll()`. What happens when `sort()` is called while
    another thread is rebuilding the list? It's hard to say for sure, but it could
    be catastrophic, so we want to disallow that. The `synchronized` keyword instructs
    the JVM to allow only one thread to execute the method at a time, causing all
    others to queue up, waiting their turn (note that their execution order is non-deterministic,
    so you can't base any expectations on the order in which threads get to run a
    `synchronized` method). This avoids the potential for a race condition, and ensures
    that our program doesn't crash.
  prefs: []
  type: TYPE_NORMAL
- en: While appropriate here, care must be taken with `synchronized` methods, as acquiring
    and releasing the locks can be expensive (though much less so with modern JVMs)
    and, more importantly, it forces threads to run sequentially when they hit this
    method call, which can cause a very undesirable lag in the application, especially
    in GUI applications. Keep that in mind when writing your own multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that in place, our application is complete. While not a terribly complex
    application, it does include several interesting technologies such as JavaFX,
    Lambdas, Streams, `ProcessHandle` plus related classes, and Threads.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build a simple command-line utility to find duplicate
    files. Through that, we'll get hands-on experience with the new File I/O APIs,
    the Java Persistence API (JPA), file hashing, and some more JavaFX.
  prefs: []
  type: TYPE_NORMAL
