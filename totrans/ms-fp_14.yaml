- en: Introduction to Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book uses Scala extensively as its primary example language. In this chapter,
    we will briefly overview the language basics. First, we will start from the motivation
    for using it as an example language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Motivation for using Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is supposed to be a quick introduction for the rest of the book,
    and should not be regarded as a full-size tutorial on Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation for using Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary motivation for using Scala for examples in this book is as follows. First
    of all, Scala is a functional language. This means that it has support for almost
    all of the functional programming styles that have been developed so far. Another
    reason for choosing Scala is that it is designed explicitly with object-oriented
    programmers in mind. Scala positions itself as a mix between object-oriented and
    functional languages. This means that new programmers that come from the object-oriented
    world can use Scala as an object-oriented language. This facilitates the transition
    from the object-oriented style. In fact, Scala is often used as Java without semicolons,
    meaning that you can program your Scala programs similarly to how you used to
    program your Java programs. The preceding reasons facilitate transition for new
    programmers greatly. Also, Scala features a very powerful mechanics for functional
    programming. So, you can write functional programs just the way you would do in
    Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: We can even say that Scala is more potent than Haskell because, in some circumstances,
    the object-oriented approach is absolutely necessary. You can access the entire
    JVM infrastructure, meaning that you can use any Java library from Scala easily.
    The infrastructure is very mature and industry-oriented. Unfortunately, you cannot
    say the same thing about Haskell, which is less production-ready than JVM languages.
    Purely functional languages such as Haskell are used in production. However, they
    do not possess as mature infrastructure, say, for dependency management or compile
    tools as does Scala. Even though you can use all of the object-oriented libraries
    from Java in Scala, there is an entire host of native libraries for Scala, which
    are also production-ready and can facilitate a purely functional programming style.
  prefs: []
  type: TYPE_NORMAL
- en: A final thing about Scala worth mentioning is that it is an experimental language.
    This means it is often used as a playground to test new features and research
    in computer science. This means that leading-edge research is available to you
    as a Scala programmer. Combine that with accessibility to JVM, and you get an
    ideal tool to advance your knowledge in computer science while developing real-world
    software.
  prefs: []
  type: TYPE_NORMAL
- en: In short, all of this means that while using Scala, you can use a wide spectrum
    of styles, from a conventional object-oriented approach all the way to leading
    edge functional programming research. This makes it a great language for examples
    in this books.
  prefs: []
  type: TYPE_NORMAL
- en: Scala infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's have a look at the infrastructure developed for Scala. Let's have
    a look at the Scala interpreter first.
  prefs: []
  type: TYPE_NORMAL
- en: Scala interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Scala is a compiled language, it has its own interpreter. It comes
    as part of the standard language distribution, and if you install Scala, you will
    have access to it. Please consult [https://www.scala-lang.org/](https://www.scala-lang.org/)
    on the instructions to install Scala.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the interpreter from the command line by simply typing `scala`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this interpreter, you can run Scala expressions and get evaluations of them
    in real time. Besides ordinary expressions, you can run interpreter-specific expressions
    to tune it up. This kind of expression usually starts with a colon followed by
    a keyword. To access the list of all the relevant Scala interpreter expressions,
    type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58c25f72-880b-48f2-b4ce-54637cb2e50e.png)'
  prefs: []
  type: TYPE_IMG
- en: SBT build tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SBT is a build tool for Scala. It is a dedicated build tool developed specifically
    for Scala. It is possible to integrate Scala with Gradle or Maven, and in fact,
    this is an option that many teams prefer to do. SBT is supposed to be simple,
    but in fact, it is the precise opposite of simple. If you decide to use SBT as
    your Scala build tool, be advised that it possesses a complex infrastructure and
    is not well documented.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is rather powerful. It allows you to write build descriptions in
    a subset of the Scala language. This means that your build scripts are Scala programs
    in themselves. This is not something you get with build tools, such as Gradle
    or Maven.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we do not need to be familiar with SBT. The GitHub repository
    with the examples for this books uses SBT, so you will need some basic familiarity
    with this software to run the examples. However, in this book, we do not feature
    SBT in parts that are crucial to functional programming. If you want to become
    more familiar with this tool, please see the official documentation of SBT.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The backbone of the Scala language is variables and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Variables are defined using the `var` keyword followed by the name of the variable,
    followed by the value you would like to assign to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables defined in the preceding manner are mutable. This means that once
    they are assigned, you can modify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, purely functional programming advocates against this style. Since
    Scala positions itself as a mixture of purely functional and object-oriented styles,
    it offers a way to define an immutable variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try to modify is this variable, you will get a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides all of these, Scala has a similar syntax for functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, a function is just like a value. However, it can be parameterized by arguments,
    and it will evaluate every time you call it. A normal value is evaluated only
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value can be modified with a `lazy` attribute to make it lazily evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you do find this way, it is not evaluated right away but at the time when
    it is called for the first time. In a sense, it is similar to a function in this
    manner, because it is not evaluated right away. However, a function is evaluated
    every time we call it, and this can be not said of a value.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, all of their definitions are specified without the types
    they return. However, Scala is a strongly typed language. The compiler knows the
    types of all its variables. The compiler of Scala is powerful, and it can infer
    the types of its values and variables in a wide range of circumstances so that
    you do not need to provide them explicitly. So, in the preceding code, the compiler
    infers the types of the values, variables, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly specify the type you would like a variable to have as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Also, notice that when you run the code without an explicit type specification
    through a Scala interpreter, the result will be aware of the type.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to the majority of modern programming languages, the Scala language
    has a bunch of control structures; for example, for branching and looping. The
    control structures in question are `if`, `while`, `for`, and pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: If and While
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`if` and `while` are implemented the same way as they are in any other programming
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in such constructs, you can optionally omit the curly braces if
    the body of the construct is a single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is something you can do in many places in Scala. Wherever you have a body
    that consists of a single expression, you can omit the curly braces around this
    expression. There are certain exceptions to this rule, however.
  prefs: []
  type: TYPE_NORMAL
- en: For
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` statement is a little bit more unconventional. In fact, the `for`
    statement is syntactic sugar for an application of the `foreach`, `map`, and `flatMap`
    methods. For example, take a look at the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `for` expression expands to the following method applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So, basically, if a type defines the methods specified in the preceding code,
    you can write the application in terms of the `for` construct. For example, if
    you take an `Option` type that defines `map`, `flatMap`, and `foreach`, you can
    write a program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `for` construct is not called a loop in Scala, but a Monadic flow. This
    is due to the special meaning of the `map` and `flatMap` functions in functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Special constructs in Scala are partial functions and pattern matching. For
    example, you can write expressions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'More complex pattern matching is also possible. For example, given a list,
    we can match on its head and tail, or its head and its second argument and its
    tail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we can perform pattern matching on virtually anything with the help
    of so-called extractors. For example, it is possible to match on a custom data
    type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The semantics of pattern matching is that on runtime, the environment will call
    the `unapply` function on the data type in question, and see whether this function
    returns some result or whether it is a `None`. If some result is returned in an
    option, the result is used to populate the variables in the pattern matching clause.
    Otherwise, the pattern is considered not matched.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding pattern matching statements are very close to the notion of partial
    functions in Scala. The same way pattern matching statements have a certain domain
    of cases that they can handle and throw an exception in all other cases, partial
    functions are defined on a part of their input domain. For example, the preceding
    `match` statement can be converted into a partial function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala features a lot of object-oriented functionality. This means it supports
    inheritance concepts that are core to the object-oriented programming. Moreover,
    since Scala compiles to the Java Virtual Machine, it is essential that it supports
    the same model as Java for Java interoperability reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes in Scala have similar semantics to their Java counterparts. They are
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it is possible to define so-called case classes in Scala. These classes
    are used to represent product types, that is, several types bound together in
    one datatype. For example, you can define a case class for the `User` domain object
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As follows from their name, case classes are primarily used for pattern matching.
    When you are defining a case class, the compiler automatically generates extractors
    for this class, so that it can be used in pattern matching, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the compiler generates convenient `toString`, `equals`, and `hashCode`
    methods for case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Case classes are especially useful when modeling your domain.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of an object-oriented interface is encapsulated in a trait in Scala.
    Similarly to an interface, a trait can have abstract members. However, unlike
    Java interfaces, traits may also have concrete members. These are injected into
    the implementing classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just like in Java, Scala classes can implement more than one trait. However,
    since traits in Scala can have concrete members, a new inheritance model that
    allows for that is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Scala, a so-called linearization model is implemented. This means that whenever
    a class is inherited from multiple traits, they are organized into a clear sequence,
    which determines the priority of inheritance. For example, consider the following
    inheritance case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `Bar` trait will get a priority over the `Foo` trait. This
    allows you to inherit from multiple traits and be aware of the precise sequence
    in which they will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Scala, it is impossible to make a class have static members. However, the
    concept of a static member is present in Java. Since Scala compiles to JVM, it
    needs a way to model this concept from Java. In Scala, a concept of a singleton
    object is used to model static members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can call the members of the singleton object without
    instantiating it or doing anything else with it, directly by its name. This is
    because it is a standalone fully fledged object that is constructed by our `object`
    statement. It exists in a single instance for the entire JVM.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a singleton object can be leveraged to model static members from
    Java. In Scala, there is a concept of a so-called companion object of a trait
    or a class. For any trait or class, if you define an object with the same name
    as the entity in question, it is considered a companion object to it. All of the
    static members of this class are defined as members of this singleton object.
    This allows you a clear separation between object and types. No longer can you
    call a member of a class without instantiating it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a brief overview of the Scala programming language,
    in which the examples in this book are implemented. First of all, we have motivated
    the usage of Scala as an example language by the fact that it supports a wide
    range of programming styles.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we had a look at what makes Scala different from other languages. Please
    keep in mind that this section is meant as a brief overview of the language, and
    you should use more comprehensive tutorials if you are interested in finding out
    more about Scala.
  prefs: []
  type: TYPE_NORMAL
