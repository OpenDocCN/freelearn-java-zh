- en: Chapter 13. Testing Your Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, we covered the most important technologies of the Java
    EE platform. However, every professional developer knows that software development
    should begin from writing tests. At first, it does not sound easy to be able to
    verify the correctness of the execution of EJBs, database-related code, or, for
    example, REST services but it appears really straightforward when using the right
    tools! In this chapter, we will present the fundamental testing framework used
    for Java EE applications testing: the Arquillian. Additionally, we will take a
    look at its extensions and related libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to enterprise testing, from mock objects to the Arquillian framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate an Arquillian test case for our ticket machine application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Eclipse IDE and Maven shell to run Arquillian tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important Arquillian extensions and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word *tests* can be interpreted in multiple ways. Most often, tests perform
    the validation and verification of the application requirements. Tests can be
    performed on multiple levels, covering single methods to whole business features.
    Tests can also cover nonfunctional aspects such as security or performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s introduce categories of tests that validate the functional requirements.
    Mike Cohn has introduced a concept of the test pyramid, which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test types](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the majority of tests in an application are usually tests that
    cover units of code. A unit can be a single method, the most basic feature. Because
    of this scope, these type of tests are called **unit tests**. They can be defined
    as tests written by a programmer to verify that a relatively small piece of functionality
    is doing what it is intended to do. Because the unit is rather small, the number
    of these tests increases rapidly, so they become the fundament of application
    testing appearing on the lowest level of the pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: The next type of tests concerns bigger areas of code. They cover whole services
    or business features. This means they cover multiple units of code and concern
    different modules and libraries. The number of such tests would be lower than
    the number of unit tests. This type of test is often called an **integration test**.
    Integration tests are done to demonstrate that different pieces of the system
    work together; since they cover entire applications, they require much more effort
    to be put together. For example, they usually require resources such as database
    instances and hardware to be allocated for them. Integration tests do a more convincing
    job of demonstrating how the system works (especially to nonprogrammers); at least
    to the extent that the integration test environment resembles the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The last type of tests are UI tests, which can also be called acceptance tests.
    Their number is the smallest in the project; they are usually the most troublesome
    to write to simulate the user interacting with the application. They cover whole
    requirements and features.
  prefs: []
  type: TYPE_NORMAL
- en: Let's leave the topic of nonfunctional tests. For now, you have to only remember
    that they can cover topics related to performance, security, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Instruments used for testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can imagine, each kind of testing uses a different approach and often
    requires different testing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: When you're writing unit tests, you have to just provide some method input parameters,
    and validate if their outcome covers the expectations. To do this in Java, you
    probably already use **JUnit**, **TestNG**, or **Spock**. When you're moving from
    bigger parts of code to testing whole services, some problems may appear. It's
    often hard to separate the code you'd like to test, to make it testable without
    running all the other services. You usually create some mock objects that simulate
    behavior of modules you don't want to include in your test. If you have an object
    whose methods you want to test, and if these methods depend on another object,
    you can create a mock of the dependency rather than an actual instance of that
    dependency. This allows you to test your object in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, one common use case might be in database applications, where
    you would like to test, for example, the user registration process but you don't
    want to run the whole database (which means that you will set its schema, some
    initial data, and finally clean its state manually after the test is complete).
    You can mock just the database interaction and define the behavior of some methods
    execution, for example, your stub will always return four users, which will be
    hardcoded in your test code.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of approach, although very immediate to understand and put into practice,
    has several limitations. Firstly, it relegates you into an artificial environment,
    where you will often make invalid assumptions about the behavior and stability
    of that environment.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you will end up with a hard-to-maintain mock code, which will allow
    your tests to pass and give you the warm feeling of having done a great job.
  prefs: []
  type: TYPE_NORMAL
- en: Thirdly, sometimes it's very hard to isolate a service you'd like to test, and
    code mocking all its interactions can be larger than the code of the meaningful
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: So, even if mock objects may still provide some benefits to start systems, where
    you don't have full implementations of a particular subsystem, it might be good
    to stay as close as possible to the target environment that the code is supposed
    to run in. At some point, The No Mock Movement (**Not Only Mocks Movement**) was
    launched pointing out that mocking often takes too much time, and makes you focus
    on writing mocks instead of writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arquillian** tries to solve these problems. It is a platform that simplifies
    integration testing for Java middleware. It deals with all the plumbing of container
    management, deployment, and framework initialization so that you can focus on
    the task of writing your tests—real tests. Arquillian minimizes the burden on
    you—for the developer—by covering aspects surrounding test execution; some of
    these aspects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the life cycle of the container (start/stop)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling the test class with the dependent classes and resources into a deployable
    archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the test class (for example, resolving the `@Inject`, `@EJB`, and
    `@Resource` injections)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the archive to test applications (deploy/undeploy), and capturing
    results and failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arquillian also has extensions that enhance its features, for example, allowing
    it to perform UI tests or some nonfunctional tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss which instruments are required to run your
    integration tests using Arquillian.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Arquillian
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Arquillian does not depend on a specific build tool, it is commonly
    used with Maven; it offers dependency management and thus simplifies the task
    of including the Arquillian libraries in the application since they are distributed
    in the Central Maven repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the type of archetype you used for generation, you might have
    a different folder structure in your project; this is not an issue. What is really
    important is that you provide the following structure under your `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main/java/`: Place all application Java source files here (under the Java
    package)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main/resources/`: Place all application configuration files here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test/java/`: Place all test Java source files here (under the Java package)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test/resources/`: Place all test configuration files here (for example, `persistence.xml`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So by now, we will be working under `test/java`, which is where we will place
    our first Arquillian test class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an Arquillian test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have been working with JUnit ([http://www.junit.org](http://www.junit.org)),
    you will find a similar Arquillian test, with some extra spice in it.
  prefs: []
  type: TYPE_NORMAL
- en: In order to do this, we will use Eclipse and Maven, just as we have done so
    far. If you are about to add test classes to your project, there is obviously
    no need to create a new project for this purpose. However, for learning purposes,
    we delivered this example in a separate project so that you can see exactly what
    to add in order to run Arquillian tests.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid recreating the whole project from scratch, you could simply
    clone the `ticket-agency-jpa` project and name it `ticket-agency-test`, moving
    the root package from `com.packtpub.wflydevelopment.chapter5` to `com.packtpub.wflydevelopment.chapter13`.
    If this still seems like too much work, you could simply import the `Chapter13`
    project from the book sample.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the pom.xml file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing that is necessary to include in order to run an Arquillian
    test is the `junit` dependency, which is required to run our unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In earlier chapters, we introduced the term **Bill of Materials** (**BOM**).
    Now, we will use the Arquillian BOM in order to import versions of all Arquillian-related
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using Arquillian with JUnit (like mentioned before other possibilities
    are `TestNG`, `Spock`, `JBehave`, and `Cucumber`) so we need to include the appropriate
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After being done with the basic dependencies, we now have to specify the container
    against which the tests will be run. Container adapters are available for the
    more important Java EE Application Servers (WildFly, Glassfish, WebLogic, and
    WebSphere), as well as for some servlet containers such as Tomcat or Jetty. Here,
    we want to use WildFly so we will use an appropriate container adapter. However,
    we have a few possible choices. Container adapters can be divided into three basic
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Embedded**: This is the mode in which a container is run on the same JVM
    instance the tests are running. Often, a container run in this mode is not an
    original one, but packed to a single JAR limited version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managed**: In this mode, the real application server is run on a separate
    JVM. As the name implies, it''s possible to manage the state of the container,
    run it, stop it, and so on. By default, when you run the test, the server is started,
    tests are run against it, and then it is stopped. However, it is possible to configure
    Arquillian to run tests on the already running instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote**: In this mode, we just connect to some existing server instance
    and run tests against it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most universal choice to run tests is the managed container. Tests are
    run on the real server, same as on the production environment, and additionally,
    it is possible to manage its state, allowing for some more advanced tests such
    as testing features related to high-availability or communication between two
    applications that run on different instances. Now, we need to add the appropriate
    container adapter to our `pom.xml` file. To do this, we will create a Maven profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There might be situations in which you'd like to run tests against different
    application servers. It's possible to just define a few Maven profiles and run
    tests a few times, each time activating other profiles. Keep in mind that some
    application servers don't provide all types of the adapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more container-related topic. Our Arquillian tests use a protocol
    to communicate with the micro deployment on the application server. If we don''t
    specify the protocol, the container will choose the default one. In order to specify
    it manually, we will need to add the `org.jboss.arquillian.protocol` dependency
    (named so as it''s compatible with Servlet 3.0 specifications):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Writing your first Arquillian test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the configuration is complete, we will finally code our test. So, create
    a Java class named `TicketTest` under the package `com.packtpub.wflydevelopment.chapter13.test`.
    The first thing that you will add to this class is the following annotation that
    tells JUnit to use Arquillian as the test controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Arquillian then looks for a static method with the `@Deployment` annotation;
    it creates a micro deployment including all the specified classes and resources
    (instead of deploying the whole application), allowing to test only part of the
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The fluent API provided by the **ShrinkWrap** project ([http://www.jboss.org/shrinkwrap](http://www.jboss.org/shrinkwrap))
    makes this technique possible using the `create` method, which accepts the type
    of deployment unit (`WebArchive`) as the argument and all the resources are included
    in this archive. In our case, instead of including all the single classes, we
    use the `addPackage` utility method that adds all the classes that are contained
    in a class package (for example, by adding the `SeatType.class.getPackage()` method,
    we will include all the classes that are in the same package as the `SeatType`
    class). Our project uses the JPA, so we also add persistence configuration; here,
    we specify a path to the `.xml` file, so we can point, for example, to some other
    test configuration using some other non-production database. And, of course, we
    also have to add the empty `beans.xml` file in order to enable the CDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we inject the service we would like to test (yes, it''s possible to
    inject services to test classes) and add one test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `shouldCreateSeatType` method will create a new `SeatType` attribute
    using the `createSeatType` method from the `TicketService` class. Note how we
    inject `TicketService` just as we would if we were running this code on the server
    side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first test case is now ready. We will just need to add an Arquillian configuration
    file named `arquillian.xml` in our project, under `src/test/resources`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to configure the container adapter. In this example, we assume that
    you have set the `JBOSS_HOME` environment variable to the WildFly main directory.
    In this case, no more configurations are required. However, if you want to run
    something non-standard, for example, connect to a remote container with altered
    management ports, then this file is the appropriate place to modify this. When
    you don''t specify `JBOSS_HOME`, you can set the WildFly location using `property`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, this method may be hard to maintain when more than one person is working
    on the project. In order to avoid problems, you can use the system property resolution,
    for instance, `${jbossHome}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you configure the remote container, the configuration would look just like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running Arquillian TicketTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s possible to run Arquillian tests both from Maven and your IDE. You have
    to remember that we declared the container adapter in the Maven profile, so in
    order to run the full build, you have to run the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to run the test from Eclipse, you have to navigate to the project
    properties and select the **Maven** property. In the **Active Maven Profiles**
    field, enter `arquillian-wildfly-managed` (as shown in the following screenshot),
    which we declared earlier in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Arquillian TicketTest](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now all you have to do is right-click on your `TicketServiceTest` class and
    select **Run As JUnit Test**. The Arquillian engine will start, producing the
    outcome of the test in the JUnit view (you can make it visible by navigating to
    **Menu** | **Window** | **Show View** | **JUnit**).
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! The JUnit console accounts for the first test that was run
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use only one container in your test, then a good idea would
    be to set the default Maven profile, by adding the following lines to it in the
    `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running Arquillian tests using Spock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arquillian is not limited to only JUnit. As we mentioned earlier, there are
    already containers, for example, TestNG and Spock; let's focus on the second one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Spock** is a modern testing framework written in Groovy and uses some of
    the Groovy language features to make your tests more readable and easier to write.
    Spock''s primary goal is to test the Groovy code but it is perfect to write all
    kinds of tests for the Java code. Spock introduces a few additional semantics
    with its **Domain Specific Language** (**DSL**) in order to make testing even
    more easier and developer friendly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our previous test example using Spock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can notice a few differences. First of all, it's really Groovy! Secondly,
    the test uses a different runner, `ArquillianSputnik`. What's more, you can already
    notice some Spock DSL here, such as the **given**, **when**, and **then** constructions,
    which come from **behavior-driven development** (**BDD**). The **given** construction
    is expected to put the system in a specific state, **when** describes an action,
    and **then** contains assertions that verify the outcome of an action performed.
  prefs: []
  type: TYPE_NORMAL
- en: This fully working Spock example with the complete `pom.xml` configuration can
    be found in this chapter's example project `named ticket-agency-spock`. More information
    concerning the Arquillian Spock test runner, its features, and usage instructions
    can be found on GitHub at [https://github.com/arquillian/arquillian-testrunner-spock](https://github.com/arquillian/arquillian-testrunner-spock).
    More information concerning Spock can also be found on GitHub at [https://github.com/spockframework/spock](https://github.com/spockframework/spock).
  prefs: []
  type: TYPE_NORMAL
- en: ShrinkWrap Resolver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In almost every Arquillian test, you will probably use ShrinkWrap to create
    micro deployments. After working with it for a bit, you will probably notice some
    shortcomings. You might be wondering what happens when you've got a test that
    relies on some external library; do you need to add all packages from that library?
    The answer is no. **ShrinkWrap Resolver** offers integration with Maven and basic
    Gradle support is also available. You can just write in your test what dependency
    you'd like to include in the archive and it will be deployed with the micro deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the basic example of the ShrinkWrap Resolver Maven integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line means that we want to resolve an artifact with the given
    group ID, artifact ID, and version (Maven coordinates in canonical form) from
    Maven's central repository with all its dependencies, and convert it to a list
    of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with this example, you have to maintain the artifact version both
    in the test code and build file. You can improve this! Just import some dependencies
    data from your `pom.xml` file, so that ShrinkWrap Resolver resolves artifacts
    of the same versions the main project is using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So now, first of all, the `pom.xml` data is loaded, including all depending
    management sections and artifacts versions. Also, the artifact coordinates do
    not have to include the version.
  prefs: []
  type: TYPE_NORMAL
- en: These are the most basic features. You can fully configure the resolver manually,
    the repositories you want to use, Maven profiles to be applied, and much more.
    Let's now grab an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you''re testing your project using JUnit and some fancy assertion
    library. **AssertJ** (successor of **FEST** assertions) is a fluent assertions
    library that allows you to write your project in a more human-readable form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using such a library in every test means you have to include it in every micro
    deployment. There is another thing you will always need: the `beans.xml` file.
    So let''s create some utility classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, now in each test case, you''d have just to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At some point, you might want to do one more thing; instead of adding all your
    libraries manually, you can import them on runtime dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some unfortunate cases in which isolation of a part of the project
    for the micro deployment is not possible. You just add more and more classes to
    it and there is no end. This means that your project might have a poor design,
    but let''s say you want to introduce Arquillian in some existing legacy project
    and you had no influence on its structure. In that case, you might want to import
    not just some classes or packages, but the whole project to your integration test.
    Some people do tricks; they just use the basic ShrinkWrap and import a `.jar`
    or `.war` file using the `ZipImporter` ShrinkWrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is what is really in this archive? You probably import an archive
    created during the previous build since it is created after finishing the tests!
    What''s more, it cannot even exist when you''re just working from the IDE and
    not running the full Maven build! It''s the place where you can use the `MavenImporter`
    class. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Internally, it runs the simplified build, gathering compiled classes
    and resources and packing it to the archive. It does not run inside the complete
    Maven build using some embedded instance, since that would be much too slow. You
    might want to add such a method to your test utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There exists a similar feature for the Gradle project included since ShrinkWrap
    Resolver 2.2.0-alpha-1\. However, it uses the Gradle Tooling API internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At some point, you might be surprised that this last example did not work.
    The reason might be that `arquillian-bom` does not include this ShrinkWrap Resolver
    version. However, it is possible to override the BOM imported versions with another
    BOM. It''s pretty easy; just insert the more important BOM first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: More info about ShinkWrap Resolver can be found on its GitHub repository at
    [https://github.com/shrinkwrap/resolver](https://github.com/shrinkwrap/resolver).
  prefs: []
  type: TYPE_NORMAL
- en: ShrinkWrap Descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one more ShrinkWrap family project. A little less popular and not known
    by many people, it is called **ShrinkWrap Descriptors**. Its goal is to provide
    a fluent API for the creation of descriptor resources you usually create and insert
    inside your micro deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example. Let''s say you''re writing a persistence framework
    extension. While doing this, you use an incredible amount of `persistence.xml`
    files such as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With ShrinkWrap Descriptors, instead of putting all these files in `src/test/resources`
    and then referencing them from particular tests, you can just put some code in
    the test itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Such a `PersistenceDescriptor` class can be exported as `String` or just be
    added to the `ShrinkWrap` archive.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the project contains descriptors ready for all the most important
    `.xml` of Java EE platform. However, it also allows for code generation using
    XSD and DTD files. Be cautious, it's still in alpha stage. It is stable, but the
    API might already be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Real challenges start when you have to include other systems in your testing
    process. Troubles might be caused even by the necessity of testing interactions
    with a relational database. In [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining
    Persistence with CDI"), *Combining Persistence with CDI*, we introduced the JPA.
    Now it's time to describe how you can test your interactions with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few issues that have to be considered when testing database-related
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: How to verify that data was really inserted to the database?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to maintain the database state between tests and how to automatically clean
    it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arquillian persistence extension allows you to test both these things. Before
    running a test, you can seed your database from `.xml`, `.xls`, `.yaml`, `.json`,
    or custom SQL scripts. It''s done by just annotating the test case using the `@UsingDataSet("path-to-seeding-file")`
    annotation. After the test execution, you can compare the database state against
    another file, this time using the `@ShouldMatchDataSet("path-to-dataset")` annotation.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `seats.yml` and `expected-seats.xml` files are just simple YAMLs placed
    in `/src/test/resources/datasets`. The first file contains `SeatType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The second file contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since we're executing a cleanup. Note that the names and values used here are
    the SQL names, not the JPA names.
  prefs: []
  type: TYPE_NORMAL
- en: JPA allows you to use a second-level cache in order to improve the operations
    performance. With this, not all of the operations are instantly reflected on the
    database state. During the tests running, you might be interested in the `@JpaCacheEviction`
    annotation, which makes a cache to evict after every test run. Each test is also
    wrapped in a separate transaction so that it won't influence the execution of
    other tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are some dependencies you need to make this extension work.
    There are exactly three of them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Arquillian in 1.1.4.Final version has a bug that passes all persistence tests
    even when they should not. The 1.1.5.Final version works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: A fully configured example project for this chapter is named `ticket-agency-test-ape`.
  prefs: []
  type: TYPE_NORMAL
- en: The Arquillian Persistence Extension manual is available on GitHub at [https://github.com/arquillian/arquillian-extension-persistence](https://github.com/arquillian/arquillian-extension-persistence).
  prefs: []
  type: TYPE_NORMAL
- en: Arquillian Warp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last Arquillian extension that we will discuss here is **Warp**. Authors
    say that it allows you to write client-side tests that assert server-side logic.
    To be more descriptive, it allows for execution of client side requests, and then
    to execute server side tests. This fills the gap between client-side and server-side
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fully understand the Warp, we have to introduce the `@RunAsClient`
    annotation. It can be placed on a test class or test method and it mentions that
    tests will be executed on the client side and not on the server side. The second
    important annotation is `@Deployment`, which you have already met on method creating
    the archives. However, it can take some parameters that are Boolean value testable.
    If a testable is `false`, it is also executes on the client side, not repacking
    the deployment and so on. However, Warp mixes these two modes and requires `@Deployment(testable=true)`
    and `@RunAsClient` annotations. The test class has to be annotated additionally
    with `@WarpTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Every Warp test uses the following construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'An activity is the client part that makes the requests. Inspection is a server-side
    assertion. It''s also possible to filter some requests by additional specification
    of the Observer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: An Observer can, for example, filter HTTP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at something more concrete. Arquillian Warp also has some
    extensions. Currently, all of them are HTTP oriented; however, it is possible
    to extend Warp to cover non-HTTP use cases. The extensions add some special classes
    for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: JSF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we''re going to look at the JAX-RS part. To do this, we will use the code
    from [Chapter 7](part0038_split_000.html#page "Chapter 7. Adding Web Services
    to Your Applications"), *Adding Web Services to Your Applications*. We want to
    test our REST service. First of all, we need to add all the standard Arquillian-related
    dependencies and the `arquillian.xml` file. For the Warp itself, we will need
    the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For the JAX-RS extension, we will need the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we will use the JAX-RS client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First of all, you can see all the annotations mentioned earlier. We use the
    `ShrinkWrap Resolver MavenImporter` class here to get the whole project in the
    deployment. The `[1]` object is the injection of the application URL. In `[2]`,
    we execute a client request to get the seats and in `[3]`, we do some basic client-side
    assertion. In `[4]`, we test the server side, to check if the appropriate HTTP
    code was returned and so on. In more complex scenarios, we can execute some beans
    logic to confirm that the appropriate state change was performed on the server
    side. This last thing distinguishes the Arquillian Warp from running tests in
    the client mode (a `@RunAsClient` annotation) and doing assertions with `ResteasyWebTarget`.
  prefs: []
  type: TYPE_NORMAL
- en: Some more information concerning this extension can be found at [https://github.com/arquillian/arquillian-extension-warp](https://github.com/arquillian/arquillian-extension-warp).
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We introduced the topic of WebSockets in the earlier chapters. Now let''s see
    how we can test them. To do this in plain Java, we will need a WebSocket client
    implementation; be sure to add **Tyrus** to your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, we will use Tyrus as a base code from [Chapter 8](part0042_split_000.html#page
    "Chapter 8. Adding WebSockets"), *Adding WebSockets*. Our test realizes a simple
    scenario. Using the REST API, we reserve a seat, and as a WebSocket client, we
    wait for a message broadcasting information concerning new reservations. Let''s
    look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is run as described in this chapter''s client mode and uses Tyrus:
    the WebSocket client reference implementation under the hood. The perfect deployment
    for this test is our whole application, so we are going to use `MavenImporter
    [1]`. In the test, we declared a concurrent deque to gather a received messaged
    `[2]` and a latch `[3]`, which we will use to wait in `[7]`. In order to handle
    WebSockets on the client side, we have to declare a handler `[4]`, which specifies
    the behavior on receiving the message. Here, we just add a message to our deque
    and perform a latch countdown. In `[5]`, we have to register the handler so that
    it will be used for an open session. The REST call is executed using a rest-assured
    library, which provides a fluent API to test REST APIs. Finally, in `[8]`, we
    perform some basic assertions concerning the received messages.'
  prefs: []
  type: TYPE_NORMAL
- en: The fully configured `pom.xml` file and a whole working project can be found
    under `ticket-agency-test-websockets`.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing your Arquillian test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that we, on purpose, created just a part of the integration
    tests we needed. We did not reach the last mile, that is, creating seats and reserving
    one. As a matter of fact, if you remember, our ticket application uses `ConversationScope`
    to track the user's navigation. Thus, we need to bind `ConversationScope` into
    our test as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the `Weld` container provides all that you need with `org.jboss.weld.context.bound.BoundConversationContext`,
    which needs to be injected into your test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `@Before` annotation is invoked before each test method and after
    injections have occurred. In our case, it is used to associate `conversationContext`
    with `MutableBoundRequest` before being activated by `conversationContext.activate`.
    This is needed to mimic the conversation behavior from within the Arquillian test
    bed.
  prefs: []
  type: TYPE_NORMAL
- en: Just for completeness, you must be aware that `BoundRequest` interfaces are
    defined in the Weld API to hold a conversation that spans multiple requests, but
    are shorter than a session.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s the full `TicketTest` class, which contains a theatre creation and
    booking seat reservation in the `testTicketAgency` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Additional information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Arquillian project is an evolving framework with many other interesting
    topics. Describing all its extensions, however, is out of the scope of this book.
    However, the other interesting areas to look into are **Drone** and **Graphene**,
    which bring the **WebDriver** and **Page Object** patterns to Arquillian testing.
  prefs: []
  type: TYPE_NORMAL
- en: At some point, you may find yourself creating separate deployment methods in
    each test case. You can change this behavior by the usage of **Arquillian Suite
    Extension**, which allows specifying a deployment for a set of test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Arquillian is fully open source, so you can learn more about it from the online
    documentation that is available at [http://arquillian.org/](http://arquillian.org/).
    When you need some help, or you have an awesome idea for a new feature, you can
    contact the Arquillian community on forums or IRC ([http://arquillian.org/community/](http://arquillian.org/community/)).
    Remember that if you find a bug, don't complain; just file an issue on JBoss JIRA
    at [https://issues.jboss.org](https://issues.jboss.org).
  prefs: []
  type: TYPE_NORMAL
- en: One of the Arquillian contributors John D. Ament has already published a book
    on this topic called *Arquillian Testing Guide*, *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we went through a critical part of enterprise systems: integration
    testing. Historically, one main downside of Java EE is its testability, but Arquillian
    has really solved this issue to a great extent.'
  prefs: []
  type: TYPE_NORMAL
- en: Used as an extension to the JUnit framework, Arquillian excels in checking the
    integration layer that exposes the business logic in an enterprise Java application.
  prefs: []
  type: TYPE_NORMAL
- en: Arquillian hooks into your testing framework to manage the container's life
    cycle. It also bundles the `test` class into a deployable archive with dependent
    classes and resources.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last chapter covering basic Java EE and WildFly features. We started
    with a few session beans, and ended up with web sockets, an asynchronous messaging
    system, RESTful API, and even a little bit of JavaScript. During the course of
    this book, we saw how the newest edition of Java EE provided us with tools to
    create modern and scalable applications. The platform's goal is to help the developer
    to focus on the business logic. This means removing the boilerplate code through
    the whole application stack from the backend to the view layer. In most areas,
    we only covered the most important features of the multiple technologies provided
    by Java EE. There is still plenty to explore!
  prefs: []
  type: TYPE_NORMAL
- en: In the appendix, we will learn a few things about the JBoss Forge tool, which
    can greatly increase the productivity when working with Java EE.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Rapid Development Using JBoss Forge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the appendix of this book, we will give you an overview of JBoss Forge, which
    is a powerful, rapid application development (aimed at Java EE ) and project comprehension
    tool. With Forge, you can start a new project from scratch and generate the skeleton
    for your application just with a few commands. However, it can also be used for
    incremental enhancements for your existing projects using extra plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Forge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to install Forge, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and unzip Forge from [http://forge.jboss.org/](http://forge.jboss.org/)
    into a folder on your hard disk; this folder will be your `FORGE_HOME`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `FORGE_HOME/bin` to your path (Windows, Linux, and Mac OS X).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Unix-based operating systems, this typically means editing your `~/.bashrc`
    or `~/`.profile; you will need to enter the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In Windows systems, you will need to open the **Control Panel** window, then
    navigate to **System Properties** | **Advanced** | **Environment Variables**,
    and add these two entries visually. It is recommended to set user variables for
    Forge, unless you have placed the unzipped distribution in a folder where all
    users can access it.
  prefs: []
  type: TYPE_NORMAL
- en: In case of any problem, check out the online installation guide available at
    [http://forge.jboss.org/document/installation](http://forge.jboss.org/document/installation).
  prefs: []
  type: TYPE_NORMAL
- en: Starting Forge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to start Forge, there is a script named `forge.bat` (or the equivalent
    Forge for Unix). Run the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch the Forge console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting Forge](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The console accepts a large set of commands, such as commands to navigate and
    manipulate the filesystems, to create new projects, to operate on the Forge environment
    and UI generation, and scaffolding commands. It also offers the autocomplete feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to learn the following available commands in current context, press
    the *Tab* key twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the standard commands, it is possible to enrich the syntax of the Forge
    command line with add-ons, which adds superior capabilities to your project creation.
    On [http://forge.jboss.org/addons](http://forge.jboss.org/addons), you can find
    a list of available plugins. For example, we are going to use the `angular-js`
    plugin in order to create a GUI for our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will demonstrate how to use some of the available
    commands in order to create a Java EE 7 application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Java EE 7 application with JBoss Forge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, Forge installation is quite easy; however, creating your first Java EE
    7 application will be even faster! Although, we can create rather advanced applications
    with Forge, for the purpose of learning, we will just use a simple schema that
    contains a user table, which can be built using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we need to do is to create a new project using the `project-new`
    command. Execute the following commands from within the `Forge` shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, you have a new Forge project, which is based on a Maven project structure.
    Arguably, generating a new project isn't Forge's greatest value—the same can be
    achieved with Maven archetypes. The sweet part of Forge is that now you have the
    luxury of defining your own application skeleton interactively after it has already
    been generated. This means that you can create the project using the Maven archetype
    first and then extend it using Forge's intuitive suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the project is created, you can then enter command-list from the shell,
    as shown in the following screenshot, which enlists all the basic commands that
    you can use in Forge 2.12.1 Final:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first Java EE 7 application with JBoss Forge](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to learn more about the single commands, you can use `man` followed
    by the command name, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first Java EE 7 application with JBoss Forge](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you have learned how to get help using Forge, let's get back to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we need to specify what Java and Java EE version we want
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our project already contains Java EE 7 API dependency. Now,
    since we will need to reverse-engineer our database table into Java entities,
    the next step will be to configure the **Java Persistence API** (**JPA**) layer
    for your application. This application will be based on WildFly JPA implementation,
    which is based on the Hibernate provider, referencing a database named Forge.
    This database is reachable at the **Java Naming and Directory Interface** (**JNDI**)
    named `java:jboss/datasources/PostgreSqlDS`. This is shown in the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `persistence.xml` file was generated, and currently the console indicates
    that we are editing it. We can check its content by using the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will use the `jpa-generate-entities-from-tables` command in order
    to generate your `Entity` class. You will need to provide the following **Java
    Database Connectivity** (**JDBC)** connection information:'
  prefs: []
  type: TYPE_NORMAL
- en: The JDBC URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL dialect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JDBC driver class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path in the filesystem where the JDBC driver is located
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package where the entities will be generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can specify all the parameters in a one-line command or complete it interactively.
    The final command would look like this (line breaks added for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After completing the persistence layer, we will now create the GUI application
    using the `scaffold` command, which can be associated with several providers such
    as the AngularJS one. First, let''s install the add-on using the following shell
    command (note that it should be executed in your system''s shell, not in the Forge
    CLI):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation is complete, we need to issue three more commands. First,
    we will prepare the scaffolding framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application now is a web app with AngularJS libraries. Next, we will define
    that we would like to generate a UI for the `Users` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create an `JAX-RS` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: And we are done! The application is now a complete Java EE application with
    REST endpoints, JPA, and an AngularJS UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When these samples were written, JBoss Forge did not fully support all Java
    EE 7 dependencies. This can be fixed by manually modifying the `pom.xml` file
    of the generated project. You should just remove all the dependencies besides
    the one shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, if your `Users` entity doesn''t have an `@javax.persistence.GeneratedValue`
    annotation in its ID field, make sure you add it manually (there is currently
    a bug in the JPA add-on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Building and deploying the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it is time to build your application using the `build` command, which
    will compile and package your application in a web application archive (`forge-demo.war`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `Maven build` command has created an artifact `forge-demo-1.0.0-SNAPSHOT.war`
    in the `target` folder of your project. You can now either manually copy the archive
    into the `deployments` folder of your application server or use the `management`
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the server should have the `java:jboss/datasources/PostgreSqlDS`
    data source defined!
  prefs: []
  type: TYPE_NORMAL
- en: Your Forge-demo application in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access your application at the default URL, `http://localhost:8080/
    forge-demo-1.0.0-SNAPSHOT/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main application screen will contain the list of entities on the left menu.
    If you choose the **Users** position, then you should see a list of users that
    have been added, a **Search** button which can be used to filter across the users,
    and a **Create** button, which obviously will insert some data. This is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your Forge-demo application in action](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By clicking on the **Create** button, you will be taken to the screen that
    allows the insertion of a new user to the database (remember that we have configured
    this application to run against a `PostgreSQL` database). This is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your Forge-demo application in action](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this way, we have created a basic AngularJS app based on Java EE. It can
    be used as a foundation for your project or just a sandbox in which you can try
    out new ideas. Be sure to check out other available add-ons, and remember that
    you will always have the possibility to create your own ones!
  prefs: []
  type: TYPE_NORMAL
