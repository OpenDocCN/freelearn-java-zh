<html><head></head><body>
		<div id="_idContainer005">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor021"/>Chapter 1</em>: Cloud-Native Applications</h1>
			<p>When talking about <strong class="bold">cloud-native applications</strong>, it is important to have a shared understanding of what cloud-native means. There is often an assumption that cloud-native and microservices are the same thing, but actually, microservices are just <em class="italic">one</em> architectural pattern that can be used when building cloud-native applications. That leads us to the questions: what is a cloud-native application, and what are the best practices for building them? This will be the focus of this chapter. </p>
			<p>In particular, we will cover these main topics:</p>
			<ul>
				<li>What is a cloud-native application?</li>
				<li>Introducing distributed computing</li>
				<li>Exploring cloud-native application architectures</li>
				<li>Cloud-native development best practices</li>
			</ul>
			<p>This chapter will provide some grounding for understanding the rest of the book as well as helping you to be successful when building cloud-native applications.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor022"/>What is a cloud-native application?</h1>
			<p>Back in 2010, Paul Freemantle wrote an early blog post about cloud-native (<a href="http://pzf.fremantle.org/2010/05/cloud-native.html">http://pzf.fremantle.org/2010/05/cloud-native.html</a>) and used the analogy of trying to drive a horse-drawn cart on a 6-lane<a id="_idIndexMarker000"/> highway. No matter how much better a highway is as a road, there is a limit to how much a cart can transport and how quickly. You need vehicles that are designed for driving on a highway. The same is true of applications. </p>
			<p>An application designed to run in a traditional data center is not going to run well on the cloud compared to one that was designed specifically to take advantage of the cloud. In other words, a cloud-native application is one that has been specifically designed to take advantage of the capabilities provided by the cloud. The <strong class="bold">Stock Trader</strong> application from <a href="B17377_08_Final_SB_epub.xhtml#_idTextAnchor159"><em class="italic">Chapter 8</em></a>, <em class="italic">Building and Testing Cloud-Native Applications</em>, is an example of such an application. A real-world example of microservices is Netflix.</p>
			<p>Perhaps at its core, the promise of the cloud is being able to get compute resources on-demand, in minutes or seconds rather than days or weeks, and being charged based on incremental usage rather than upfront for potential usage – although, for many, the attraction is just no longer<a id="_idIndexMarker001"/> having to manage and maintain multiple data centers. The commoditization of compute resources that the cloud provides leads to a very different way of thinking about, planning for, and designing applications, and these differences significantly affect the application. One of the key changes in application design is the degree to which applications are distributed. </p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor023"/>Introducing distributed computing</h1>
			<p>Most cloud-native architectures<a id="_idIndexMarker002"/> involve splitting an application into several discrete services that communicate over a network link rather than an in-process method invocation. This makes cloud-native applications implicitly distributed applications, and while <strong class="bold">distributed computing</strong> is nothing new, it does increase the need to understand the benefits and pitfalls of distributed computing. When building distributed applications, it is important to consider and understand the eight fallacies of distributed computing. These are as follows:</p>
			<ul>
				<li>The network is reliable.</li>
				<li>Latency is zero.</li>
				<li>Bandwidth is infinite.</li>
				<li>The network is secure.</li>
				<li>Topology doesn't change.</li>
				<li>There is one administrator.</li>
				<li>Transport cost is zero.</li>
				<li>The network is homogeneous.</li>
			</ul>
			<p>In essence, what these fallacies mean is that a network call is slower, less secure, less reliable, and harder to fix than invoking a Java method call or a C procedure. When creating cloud-native applications, care needs to be taken to ensure these fallacies are correctly accounted for, otherwise, the application will be slow, unreliable, insecure, and impossible to debug. </p>
			<p>An application consisting of multiple services interacting across the network can produce many benefits, such as the ability to individually scale and update services, but care must be taken to design services to minimize the number of network interactions required to deliver the ultimate business solution. </p>
			<p>As a result, several cloud-native <a id="_idIndexMarker003"/>architectures can be used to build cloud-native applications that present different tradeoffs between the benefits and challenges of distributed computing. </p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor024"/>Exploring cloud-native application architectures</h1>
			<p>Since 2019, there has<a id="_idIndexMarker004"/> been increasing discussion in the industry about the pros and cons of microservices as a <strong class="bold">cloud-native application architecture</strong>. This has been driven by many microservice-related failures and as a result, people are now discussing whether some applications would be better off using different architectures. There has even been the start of a renaissance around the idea of building monoliths, after several years of those kinds of applications being seen as an anti-pattern.</p>
			<p>While it is attractive to think of cloud-native as just being a technology choice, it is important to understand how the development processes, organization structure, and culture affect the evolution of cloud-native applications, the system architecture, and any ultimate success. Conway's Law states the following:</p>
			<p><em class="italic">Any organization that designs a system will produce a design whose structure is a copy of the organization's communication structure.</em></p>
			<p>A simple way of thinking of this is if your development organization is successful at building monoliths, it is unlikely to be successful at building microservices without some kind of reorganization. That doesn't mean every team wanting to do cloud-native should go out and reorganize; it means that you should understand your strengths and weaknesses when deciding what architecture to adopt. You should also be open to reorganizing if necessary. </p>
			<p>This section discusses a number of the more popular cloud-native application architectures out there and the pros and cons of using them. Let's start with microservices.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor025"/>Microservices</h2>
			<p>Although Netflix didn't invent the idea of <strong class="bold">microservices</strong>, their use of the architecture did popularize it. A single microservice is designed to do one thing. It doesn't, despite the name, mean that service<a id="_idIndexMarker005"/> is small or lightweight – a single microservice could be <em class="italic">millions</em> of lines of code, but the code in the microservice has <a id="_idIndexMarker006"/>a high level of cohesion. A microservice would never handle ATM withdrawals and also sell movie tickets. Identifying the best way to design a cloud-native application into a series of well-designed microservices is not a simple task; different people might take different views of whether a deposit into and withdrawal from a bank account would warrant a single microservice or two. </p>
			<p>Microservices usually integrate with each other via REST interfaces or messaging systems, although gRPC and GraphQL are growing in popularity. A web-facing microservice is likely to use a REST or GraphQL interface, but an internal one is more likely to use a messaging system such as Apache Kafka. Messaging systems are generally very resilient to network issues, since once the messaging system has accepted the message, it will store the message until it can be successfully processed. </p>
			<p>The key promise of the microservice-based architecture is that each microservice can be independently deployed, updated, and scaled, allowing teams that own disparate microservices to work in parallel, making updates without the need to coordinate. This is perhaps the biggest challenge with microservice architectures. It is relatively common for well-meaning developers who set out to build microservices to end up building a distributed monolith instead. This often occurs because of poorly defined and poorly documented APIs between services and insufficient acceptance testing, resulting in a lack of trust in updating a single microservice without impacting the others. This is called a <em class="italic">distributed monolith</em> because you end up with <a id="_idIndexMarker007"/>all the disadvantages of a monolith and microservices and miss out on the benefits.</p>
			<p>In an ideal world, a development organization building microservices will align the microservices with an individual development team. This may be difficult if there are more microservices than development teams. As the number of microservices a team manages increases, more time will be spent managing the services rather than evolving them.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor026"/>Monoliths</h2>
			<p><strong class="bold">Monoliths</strong> are strongly associated with pre-cloud application architectures and are considered an anti-pattern for <a id="_idIndexMarker008"/>cloud-native applications. For that<a id="_idIndexMarker009"/> reason, it might seem strange that this appears in a discussion of cloud-native architecture. However, there are some reasons for including them. </p>
			<p>The first is really just the reality that monoliths are the simplest kind of application to build. While the individual services cannot be independently scaled, as long as the monolith has been designed to scale, this may not be an issue. </p>
			<p>The second is that there are a lot of monoliths out there and many enterprises are moving them to the cloud. <strong class="bold">MicroProfile</strong> provides <a id="_idIndexMarker010"/>additional APIs to retrofit many cloud-native behaviors into an existing app.  </p>
			<p>The trick with a monolith is ensuring that despite the colocation of services in a single deployment artifact, the monolith can start quickly enough to enable dynamic scaling and restart if there is an application failure.</p>
			<p>Typically, a small development organization will benefit from monoliths since there is only a single application to build, deploy, and manage.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor027"/>Macroservices</h2>
			<p><strong class="bold">Macroservices</strong> sit somewhere <a id="_idIndexMarker011"/>between a monolith and a microservice architecture and are also referred to as <em class="italic">modular monoliths</em>. With<a id="_idIndexMarker012"/> macroservices, the services are combined into a small number of monoliths that interoperate in the same way that a series of microservices<a id="_idIndexMarker013"/> would. </p>
			<p>This provides many of the benefits of microservices but significantly simplifies the operations environment since there are fewer things to manage. If a macro-service has been written well, then individual services in that macro-service can be broken out if they would benefit from <a id="_idIndexMarker014"/>an independent life cycle. A well-known example of a macro-service is <strong class="bold">Stack Overflow</strong>. Stack Overflow (<a href="https://www.infoq.com/news/2015/06/scaling-stack-overflow/">https://www.infoq.com/news/2015/06/scaling-stack-overflow/</a>) is famously a monolith except for the tagging capability, which is handled in another application due to the different performance needs. This split<a id="_idIndexMarker015"/> moves it from being a pure monolith into the realm of <a id="_idIndexMarker016"/>macroservices (although Stack Overflow uses the term <em class="italic">monolith-plus</em>).</p>
			<p>This architecture can work especially well when a development organization is organized into a smaller <a id="_idIndexMarker017"/>number of teams than the number of services.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor028"/>Function as a Service</h2>
			<p><strong class="bold">Function as a Service </strong>(<strong class="bold">FaaS</strong>), often referred to as <em class="italic">serverless</em>, is an architecture where a service is created as a function that<a id="_idIndexMarker018"/> is run when an event occurs. The function is intended to be fast starting and fast executing and can be triggered by things such as HTTP requests or<a id="_idIndexMarker019"/> messages being received. FaaS promises that you can deploy the function to a cloud, and it is started and executed by the event trigger, rather than having to have the function running <em class="italic">just in case</em>. Typically, public cloud providers that support FaaS only charge for the time the function is running. This is very attractive if the event is relatively uncommon since there is no financial cost in having a system running for when an uncommon event occurs. </p>
			<p>The challenge with this architecture is that your function needs to be able to start quickly and usually has to finish executing quickly too; as a result, it isn't suitable for long-running processes. It also doesn't remove the server; the server is still there. Instead, it just shifts the cost from the developer to the cloud provider. If the cloud provider is a public cloud, then that is their problem, since they are charging for the function runtime, but if you are deploying to a private cloud, this becomes your problem, thereby removing some of the benefits.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor029"/>Event sourcing</h2>
			<p>Often, we think of services<a id="_idIndexMarker020"/> as providing a REST endpoint, and services make calls to them. In fact, factor VII of the Twelve-Factor <a id="_idIndexMarker021"/>App (discussed in the next section) <em class="italic">explicitly</em> states this. The problem with this approach is that a REST call is implicitly synchronous and prone to issues if the service provider is running slow or failing. </p>
			<p>When providing an external API to a mobile app or a web browser, a REST API is often the best option. However, for services within an enterprise, there are many benefits to using a messaging system such as Kafka and using <strong class="bold">asynchronous</strong> <strong class="bold">events</strong> instead. A messaging system that can <a id="_idIndexMarker022"/>guarantee that the message will be delivered allows the client and service to be decoupled such that an issue with the service provider doesn't prevent the request from occurring; it just means it'll be processed later. A one-to-many event system makes it easy for a single service to trigger multiple different actions with just a simple message send. Different actions can be taken by different services receiving a copy of the message and if new behavior is required, an additional service can receive the same message without having to change the sending service. A simple illustration of this might be that an event that orders an item can be processed by the payment service, the dispatch service, a reorder service, and a recommendation service that provides recommendations based on past purchases.</p>
			<p>One of the trends <a id="_idIndexMarker023"/>with cloud-native applications is that data is moved from a centralized data store closer to the individual services. Each service operates on data it holds, so if something happens to slow down the data store for one service, it doesn't have a knock-on effect on others. This means that new mechanisms are required to ensure data consistency. Using<a id="_idIndexMarker024"/> events to handle data updates helps with this, since a single event can be distributed to every service that needs to process the update independently. The updates can take effect even if the service is down when the update is triggered. Another advantage of this approach is that if the data store fails, it can be reconstructed by replaying all the events.</p>
			<p>Having chosen the architecture (or architectures) for building your cloud-native application, the next step is to start building it, and to do that, it is a good idea to understand some of the industry best practices around cloud-native application development.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor030"/>Cloud-native development best practices </h1>
			<p>There are many<a id="_idIndexMarker025"/> best practices that, if followed, will improve the chances that your cloud-native application will be a success. Following these best practices doesn't guarantee success, just as ignoring them doesn't guarantee failure, but they do encode key practices that have been shown to enhance the chances of success. The most famous set of best practices is the <strong class="bold">Twelve-Factor App</strong>.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor031"/>Twelve-Factor App</h2>
			<p>The Twelve-Factor App <a id="_idIndexMarker026"/>(<a href="https://12factor.net">https://12factor.net</a>) is a set<a id="_idIndexMarker027"/> of 12 best practices that, if followed, can significantly improve the<a id="_idIndexMarker028"/> chance of success when building cloud-native applications. Some of the factors would be considered obvious by many software developers even outside of cloud-native, but taken together, they form a popular methodology for building cloud-native <a id="_idIndexMarker029"/>applications. The 12 factors are as follows:</p>
			<ul>
				<li>Code base</li>
				<li>Dependencies</li>
				<li>Config</li>
				<li>Backing services</li>
				<li>Build, release, run</li>
				<li>Process</li>
				<li>Port binding</li>
				<li>Concurrency</li>
				<li>Disposability</li>
				<li>Dev/prod parity</li>
				<li>Logs</li>
				<li>Admin processes</li>
			</ul>
			<h3>I – Code base</h3>
			<p>The first factor<a id="_idIndexMarker030"/> states that a cloud-native application consists of a single <strong class="bold">code base</strong> that is tracked in a version control system, such as Git, and that code base will be deployed multiple times. A deployment might be to a test, staging, or production environment. That doesn't mean that the code in the environments will be identical; a test environment will obviously contain code changes that are proposed but haven't been proven as safe for production, but that is still one code base. </p>
			<h3>II – Dependencies</h3>
			<p>It has been common development practice for Java applications to use <strong class="bold">dependencies</strong> stored in Maven repositories such as Maven Central for some time. Tools such as Maven and Gradle require you to <a id="_idIndexMarker031"/>express your dependencies in order to build against them. While this practice absolutely requires this, it goes beyond just build-time dependencies to runtime ones as well. A 12-factor application packages its dependencies into the application to ensure that a single development artifact can be reliably deployed in any suitable environment. This means that having an administrator provide the libraries in a well-known place on the filesystem is not acceptable since there is always a chance the administrator-deployed library and the application-required one are not compatible. </p>
			<p>When considering this practice, it is important to make a clear decision about what the cloud-native application is, since at some point there will be a split between what the application provides and what the deployment environment provides. This factor triggered a trend in enterprise Java away from <strong class="source-inline">WAR</strong> files to executable <strong class="source-inline">JAR</strong> files, since many viewed the application server as an implicit dependency. However, that just shifted the implicit dependency down a level; it didn't remove it. Now the implicit dependency is Java. To a certain extent, containerization addresses this issue and at the same time, it removes the need to rearchitect around an executable <strong class="source-inline">JAR</strong> file.</p>
			<h3>III – Config</h3>
			<p>Since a 12-factor application <a id="_idIndexMarker032"/>may have many deployments and each deployment may connect to different systems with different credentials, it is critical that <strong class="bold">configuration</strong> be externalized into the environment. It is also common to read in the media about security issues caused by a developer accidentally checking credentials into a version control system, which would not happen if the configuration was stored externally to the code base. </p>
			<p>Although this factor states that configuration is stored in environment variables, there are many who are uneasy about the idea of storing security-sensitive configuration in environment variables. The key thing here is to externalize configuration in a way that can be simply provided in production. </p>
			<h3>IV – Backing services</h3>
			<p><strong class="bold">Backing services</strong> are treated as<a id="_idIndexMarker033"/> attached resources. It should be possible to change from one database to another with a simple change in configuration.</p>
			<h3>V – Build, release, run</h3>
			<p>All applications go through some kind of <strong class="bold">build, release, run</strong> process, but a 12-factor application has strict separation <a id="_idIndexMarker034"/>between those phases. The build phase involves turning the application source into the application artifact. The release phase combines the application artifact with the configuration so it can be deployed. The run phase is when it is actually executing. This strict separation means that a configuration change is never made in the run phase since there is no way to roll it back to the release stage. Instead, if a configuration change is required, a new release is made and run. The same is true if a code change is required. There is no changing the code that is running without going through a build and a run. This makes sure that you always know what is running and can easily reproduce issues or roll back to a prior version.</p>
			<h3>VI – Process</h3>
			<p>A 12-factor application consists of one or more <strong class="bold">stateless processes</strong>. This does not mean that each request is mapped to a single process; it is perfectly reasonable in Java to have a single JVM<a id="_idIndexMarker035"/> processing multiple requests at the same time. This means that the application should not rely on any one process being available from one request to another. If a single client is making 20 requests, the assumption must be that each request is handled by a separate process with no state being retained between processes. It is a common pattern to store the server-side state associated with a user.  This state should always be persisted to an external datastore, so if a follow-on request is sent to a different process, there is no impact on the client.</p>
			<h3>VII – Port binding</h3>
			<p>Applications export services via <strong class="bold">port binding</strong>. What this means is that an HTTP application <a id="_idIndexMarker036"/>should not rely on being installed into a web container, but instead it should declare a dependency on the HTTP server and cause it to open a port during startup. This has led many to take the view that a 12-factor Java application must be built as an uber-jar, but this is just one realization of the idea of building a single deployment artifact that binds to ports. An alternative and significantly more useful interpretation is to use containers; containers are very much built around the idea of port binding. It should be noted that this practice does not always apply; for example, a microservice driven by a Kafka message would not bind to a port. Also, many FaaS platforms do not provide an API for port binding. </p>
			<h3>VIII – Concurrency</h3>
			<p><strong class="bold">Concurrency</strong> in Java is typically achieved by increasing the resources allocated to a process so more threads can be created. With 12-factor, you increase the number of instances rather than the <a id="_idIndexMarker037"/>compute capacity. There is a limit to how easy it is to add compute capacity to a single machine, but adding a new virtual machine of equivalent size is relatively easy. This practice is related to factor VI, so they complement and reinforce each other. Although this could be read to suggest a single process per request model, a Java-based application is more than capable of running multiple threads more efficiently than having a 1:1 ratio between process and request. </p>
			<h3>IX – Disposability</h3>
			<p>Every application should be treated as <strong class="bold">disposable</strong>. This means making sure the process starts quickly, shuts down <a id="_idIndexMarker038"/>promptly, and copes with termination. Taking this approach makes the application scale out well and quickly, as well as being resilient to unexpected failure, since a process can be quickly and easily restarted from the last release. </p>
			<h3>X – Dev/prod parity</h3>
			<p>Lots of application problems manifest themselves because of differences between <strong class="bold">development and staging environments</strong>. In the past, this happened because installing and starting all the downstream software was difficult, but the advent of containers has significantly simplified this<a id="_idIndexMarker039"/> experience, making it possible to run many of these systems in earlier environments. The advantage of this is that you no longer experience problems because your development database interprets SQL differently from the dev environment.</p>
			<h3>XI – Logs</h3>
			<p>Applications should write <strong class="bold">logs</strong>, and these <a id="_idIndexMarker040"/>should be written to the process output as opposed to being written to the filesystem. When deployed, the execution environment will take the process output and forward it to a final destination for viewing and long-term storage. This is very useful in Kubernetes, where logs stored inside the container do not persist if the container is destroyed, and they are easier to obtain using the Kubernetes <strong class="source-inline">log</strong> function, which follows the process output and not the log files. </p>
			<h3>XII: Admin processes</h3>
			<p><strong class="bold">Admin processes</strong> should be run as one-off processes separate from the application and they should not run in line with<a id="_idIndexMarker041"/> application startup. The code for these application processes should be managed with the main application such that the release used for normal flow can be used to execute the admin task. This makes sure the application and the admin code do not diverge.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor032"/>Other best practices</h2>
			<p>The concept of the 12-factor application has<a id="_idIndexMarker042"/> been around for a while; it is important to remember with any methodology that what works for some people may not work for others, and sometimes the methodology needs to evolve as our understanding of how to be successful does. As a result, several other best practices are often added to the 12 factors discussed previously. The most common relates to the importance of describing the service API and how to test it to ensure that changes to one service do not require the coordinated deployment of client services.</p>
			<h3>APIs and contract testing</h3>
			<p>While the 12-factor methodology details a lot of useful practices for the creation and execution of cloud-native applications, it does little to talk about how application services interact and <a id="_idIndexMarker043"/>how to ensure that changing one doesn't cause another to need to change. Well-designed and clearly documented <strong class="bold">APIs</strong> are critical to ensuring that changes to a service do not affect the clients. </p>
			<p>It isn't enough to just have documentation for the API; it is also important to ensure that changes to the service provider do not negatively affect the client. Since any bug fix could result in a change, it is often possible for the provider to believe a change is safe and accidentally break a client. This is where <strong class="bold">contract testing</strong> can come in. The advantage of contract testing is that<a id="_idIndexMarker044"/> each system (the client and the server) can be tested to ensure that cha<a id="_idTextAnchor033"/><a id="_idTextAnchor034"/>nges to either do not violate the contract.</p>
			<h3>Security</h3>
			<p>One of the most noticeable gaps in the 12-factor methodology is the lack of best practices around security. From a<a id="_idIndexMarker045"/> certain perspective, this is because there is an existing set of best practices for securing applications and these apply as much to cloud-native applications as they do to traditional applications. For example, the third practice on config addresses, at least partly, how to protect credentials (or other secrets) by externalizing them outside of the application, However, this factor doesn't talk about how to securely inject secrets into the environment and how they are stored and secured. Something that depends on the deployment environment. This is discussed in more detail in <a href="B17377_07_Final_SB_epub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes</em>.</p>
			<p>Breaking things down into microservices adds additional complexity that doesn't apply in a monolith. With a monolith, you can trust the various components of the application because they are co-deployed often in the same process space. However, when a monolith is broken down into microservices and network connections are used, other mechanisms need to be used to <a id="_idIndexMarker046"/>maintain trust. The use of <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) is one such mechanism of managing and establishing trust between microservices. This is discussed in more detail in <a href="B17377_05_Final_SB_epub.xhtml#_idTextAnchor091"><em class="italic">Chapter 5</em></a>, <em class="italic">Enhancing Cloud-Native Applications</em>. </p>
			<h3>GraphQL</h3>
			<p>There is a default <a id="_idIndexMarker047"/>assumption involved in much of cloud-native thought that the APIs exposed are REST-based ones. However, this can lead to increased network calls and excessive data being sent across the network. <strong class="bold">GraphQL</strong> is a relatively new innovation that allows a service client to request the exact information it needs from <a id="_idIndexMarker048"/>a data store over an HTTP connection. A traditional REST API has to provide all the data about the resource, but often only a subset is required. Network bandwidth and client-side data processing is often wasted when using RESTful APIs since data is provided that the client does not use. GraphQL solves this by allowing the client to send a query to the service requesting exactly the data they need and no more. This reduces the data being transported and fetched from the backing data store. MicroProfile provides a Java-based API for writing a GraphQL backend, which <a id="_idIndexMarker049"/>makes it easy to write a service that provides such a query-based API for clients.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor035"/>Summary</h1>
			<p>In this chapter, we have learned what a cloud-native application is and learned about some architectures for building them. We have also learned about some best practices for building cloud-native applications and why they exist, so we can determine whether and when to apply them. This provides a good grounding for applying what you'll learn in the rest of the book to be able to be successful in building and deploying cloud-native applications.</p>
			<p>In the next chapter, we will explore what MicroProfile is and how it can be used to build cloud-native applications.</p>
		</div>
	</body></html>