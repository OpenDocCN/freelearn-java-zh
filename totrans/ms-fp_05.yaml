- en: Effect Types - Abstracting Away Side Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw why side effects may be a source of trouble.
    We also briefly discussed effect types. Effect types are a technique of functional
    programming that allow for the abstraction of side effects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will have a look at how this works. We will learn the philosophy
    behind the pattern. Also, we will see how to sequentially combine side effects
    trapped in effect types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Turning effects into data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequential combination of effect types with Monads – the `map` and `flatMap`
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning effects into data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible to compare the process of writing programs with modeling and describing
    a particular reality. For example, when you are writing an application for warehouse
    management, you are encoding in the rules of logic the concept of an online shop,
    its inventory, the place where the inventory is stored, and the rules according
    to which this inventory can be moved in and out of the warehouse. This is the
    reality of the business domain for which you are writing the application. We can
    say that your goal as a programmer is to model your business domain, that is,
    to encode it using your programming language into specific logical rules—to define
    the way information is to be stored, transformed, and interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the process of execution, programs create their own reality. The
    same way a warehouse, an online shop, and a user are all members of the reality
    of the business domain, some elements are members of the domain of program execution.
    The same way you can define certain phenomena as they happen in your business
    domain, such as inventory shortage or the users buying from your shop, you can
    define certain phenomena that exist in the world of writing and running a program.
  prefs: []
  type: TYPE_NORMAL
- en: Reality is what is on your mind when you are working on a certain level of abstraction.
    When you are working in the business-domain level, one category of thing is on
    your mind. However, when you are creating programs, entirely different things
    are on your mind. These two separate sets of concepts and phenomena can be understood
    as separate realities you're working in.
  prefs: []
  type: TYPE_NORMAL
- en: For example, errors are in the reality of program-execution. The errors' life
    cycle is also the reality of the program execution. Errors can propagate up the
    call stack. When they are handled, they stop propagation. They disrupt programs
    in places where they happen.
  prefs: []
  type: TYPE_NORMAL
- en: Delays are also the reality of program-execution. When you perform a database
    operation, an input-output operation, or wait for a response from a server, you
    deal with delays.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency, modularity, class hierarchies—all of these are elements of your
    programming reality. The programming reality is the concept and phenomena you
    are concerned with when you write your program. This reality, however, does not
    concern your boss, who lives in the reality of the business domain.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, let's name the business-domain reality the first-order reality,
    and the programming reality the second-order reality. Such naming is because the
    business-domain reality is something that you are immediately concerned with.
    The reality of your program is something that arises in the process of solving
    the business-domain problems, the first-order reality.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a programmer focuses only on the first-order reality. They may not
    care about the quality of the code or how it handles the second-order reality.
    Their primary concern is to describe the first order reality and to solve the
    business task. This situation can arise from the lack of experience of a programmer,
    or from a lack of infrastructure that would allow them to deal with the second-order
    reality quickly. Under pressing deadlines, trade-offs sometimes have to be made
    in favor of completing the task rather than the code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it dangerous to ignore the programming reality? Well, because it is a
    reality in itself, independent of the realities that may occur in business. This
    reality still exists, whether you ignore or address it. And if you do not pay
    attention to it, it may escalate in complexity, especially in large code bases.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if there are too many asynchronous computations, you may find yourself
    in the situation of callback hell. In the context of callbacks, it is not easy
    to follow the execution flow of the program. Callback hell is when your program
    relies on callbacks too much, to the point where it starts to be hard to track
    what it does.
  prefs: []
  type: TYPE_NORMAL
- en: When you are dealing with a concurrent program and multithreaded computations,
    if you're not careful, you may end up in a situation of race conditions. Alternatively,
    you may encounter deadlocks or problems with system liveliness. Without specific
    techniques to deal with these, such as an actor system, they may produce bugs
    that are particularly tricky to debug.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not careful about when you throw exceptions and return nulls from
    methods, you can expect pretty much every method to throw an exception or return
    null. Abusing exceptions and nulls by itself should not lead to detrimental bugs,
    but this will still give you a headache.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, mutation is another reality that you are going to face. In the previous
    chapters, we discussed how mutation can increase your mental load.
  prefs: []
  type: TYPE_NORMAL
- en: The several programming situations previously discussed demonstrate the mental
    load that we were talking about so extensively in the previous chapters. It is
    the second-order reality of how programs are run and how they are written. The
    programs are supposed to model the reality of their business domains. However,
    there is an entirely different reality that you encounter when you solve, run,
    or write programs. If you ignore this reality, it will overwhelm you with complexity
    and cause a mental overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of the division function, which we have encountered
    in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first-order reality here is arithmetics. It is the business domain that
    we are trying to model. Precisely, we model an operation of dividing one number
    by another number. That's our first-order reality.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we start to write the code, we quickly encounter the second-order
    reality. That is, the possibility of the division by zero and the necessity to
    handle this case in the program. Now, we move from the world of mathematics and
    our primary business task to the world of programming.
  prefs: []
  type: TYPE_NORMAL
- en: A naive way to handle this reality is to throw an exception in case of division
    by zero. However, if you do not pay enough attention to the second-order reality,
    it will create the mental overhead that we've already discussed. There is nothing
    to warn you about the possibility of an error. There's nothing to force you to
    handle it. Hence, you need to remember all of this yourself, which contributes
    to the complexity of the program you need to keep in mind. The more things you
    need to keep in mind, the harder it is to do this, and the more things can go
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated programmer will think of both the first- and the second-order
    realities when designing their program. They will not only model the business
    domain; they will also design the program so that the complexity of its execution
    does not prevent scalability. Scalability means the size of the code base does
    not contribute to the complexity of the programming of individual components.
  prefs: []
  type: TYPE_NORMAL
- en: To develop a program qualitatively, programmers need specific tools and approaches.
    Functional programming offers one approach.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming follows the fundamental principle of engineering—abstract
    away what repeats. The second-order reality has repeating phenomena. So functional
    programming devises its own abstractions to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to describe both realities at once is harder than learning how
    to describe only the first-order reality. Hence, languages such as Python are
    much easier to learn than, say, Java. Although Java is not a functional language,
    it also provides an infrastructure and a methodology to deal with the complexity
    of programming. At the same time, Python is focused on speed and ease of prototyping.
    Moreover, Java is much simpler than Scala because Scala provides even more abstractions
    and a means for you to control both realities of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is harder to learn the languages that allow for more qualitative
    programming, the value is well worth its price. You learn to control the effects
    of the second-order reality. Not only can you describe your immediate business
    domain, but you are also able to describe the way your program is run. The way
    to scalability and bug-free programming is having control over complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the division by zero example, but take into account the second-order
    reality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is that the second-order reality effect of an error
    gets modeled with the `Try` data structure. The concept of error handling is modeled
    by analyzing the `Try` data structure. It is enforced by the compiler—you cannot
    access the result value unless you analyze the data structure for errors. Hence
    the complexity is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern where we detect a specific phenomenon of the second-order reality
    and create a data structure to encapsulate (reify) it is typical in functional
    programming. In this book, we will be calling the data structures that reify the
    phenomena of the second-order reality **effect types**.
  prefs: []
  type: TYPE_NORMAL
- en: The main point of this section is to look at the side effects from a wide angle
    to see the general pattern behind their abstraction. If you only focus on your
    business domain while ignoring your program's technical reality, the latter will
    create a tough mental load. A sophisticated programmer focuses on both realities
    equally. Functional programming allows you to address them adequately.
  prefs: []
  type: TYPE_NORMAL
- en: The sequential combination of effects with Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing the preceding data structure was cumbersome. The code that has to
    do with analyzing functional data structures turns out to be pretty hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: However, analyzing the data structures is a pattern in the functional world.
    Patterns are abstracted away in programming.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will have a look at some common abstractions that you will
    deal with as a functional programmer when working with effect types.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the map function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we need to build upon the previous example of the custom-division
    function to construct another function. The function is parameterized by an argument, `x`,
    and computes an expression, `2 / x + 3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we express it in terms of our custom-division function? One approach
    is first to perform the division, then analyze its result, and if it is not an
    error, continue with the addition. However, if it is an error, return that error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The situation where we have a computation that returns an effect type, and we
    need to continue it with another computation that returns a raw value that is
    not wrapped in an effect type, is a frequent pattern in functional programming.
    The pattern is to analyze the structure returned by a computation, extract the
    result, and then apply the second computation to this result.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is encapsulated in the `map` method. Most effect types have the
    `map` method defined on them. Here is how the preceding example will look if implemented
    with the help of the `map` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to develop an intuition for the `map` method. First of all, you can
    think of the `map` method as of the following higher-order function—`(A => B)
    => (Try[A] => Try[B])`. This is a higher-order function that accepts an `A =>
    B` function and outputs a `Try[A] => Try[B]` function.
  prefs: []
  type: TYPE_NORMAL
- en: What it means is that if you have a function to convert a value of the `A` type
    into a value of the `B` type, you can also have a function to convert a value
    of the `Try[B]` type to a value of the `Try[B]` type. You can think of the `map`
    function as a lift that allows you to produce functions that work under the `Try` effect
    type from functions that work on the raw values.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the flatMap function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another example of a function that encapsulates a pattern of functional programming
    is `flatMap`. Imagine we need to create a function that computes the following
    mathematical expression: `(2 / x)  / y + 3`. Let''s try to do this with the division
    function that we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code becomes spaghetti-like here. First, we analyze the result of dividing
    `2` by `x`. If successful, we would divide it by `y`. Then we analyze the result
    of that division, and if there was no error, we add `3` to the result.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can no longer use the `map` function because the division by `y` returns
    another try. `map` is a lift for a function that returns a raw value, not `Try`.
    If the logic sounds obscure to you, you are encouraged to try to implement the
    preceding example with the `map` function to see the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap` function exists specifically for this situation. You can think
    of it as of a higher-order function with the `(A => Try[B]) => (Try[A] => Try[B])` signature.
    You can interpret it as follows. If you have a function that produces a value
    wrapped in the `Try` structure, `A => Try[B]`, you can turn it into another function, `Try[A]
    => Try[B]`, that lifts the original function's `A` domain to the domain of `Try[A]`.
    This means that if the original `A => Try[B]` function could be used on the `A`
    raw values, the new `Try[A] => Try[B]` function can be used on `Try[A]` as its
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how it can be implemented with `flatMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We need to extract the raw result from the `Try` data structure we got after
    computing `2`/`x`, and we need to perform another computation on this result.
    This computation, the result divided by `y`, also produces `Try`. With the help
    of `flatMap`, we can lift the `Int => Try[Int]` computation into `Try[Int] =>
    Try[Int]`. In other words, once we have computed `2`/`x`, we can divide its result
    by `y`.
  prefs: []
  type: TYPE_NORMAL
- en: So `flatMap` is for situations when you need to continue a computation with
    another computation, and the continuation will produce a `Try` as its result.
    Compare that to the situation with the `map` function, which requires the continuation
    to produce a raw value. Corresponding versions of `map` and `flatMap` also exist
    for other effect types, such as Option or Future.
  prefs: []
  type: TYPE_NORMAL
- en: One thing can be confusing here regarding the signatures of `map` and `flatMap` that
    we have analyzed. The signatures are functions. They take a function as an input
    and return another function as an output. However, the `map` and `flatMap` methods
    we have called on the `Try` object do not return functions but `Try` objects.
    However, both of our `map` and `flatMap` signatures, as we have discussed previously,
    return a `Try[A] => Try[B]` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the functional world, we view functions outside the context of object-oriented
    programming. Scala is a convenient language because it combines the object-oriented
    and functional approaches. So, functions such as `flatMap` or `map` are defined
    as methods of the `Try` class. However, in functional programming, we get a better
    grasp of the nature of the functions by viewing them outside the context of object-oriented
    programming. In functional programming, they are not viewed as members of any
    class. They are means to transform the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have a function that is defined as a member of some `Dummy` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function `f` takes some argument of type `Int` and outputs some result of
    type `String`. Its signature is `Int => String`. This signature is the signature
    of the function as it is defined inside the `Dummy` class. However, notice that
    since it is defined inside the `Dummy` object, the context of that object is always
    implied. We can use the data of the enclosing object when performing the computation
    inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we decide to bring this function outside the scope of the class?
    Will the `Int => String` signature still reflect the nature of the function? Can
    we even implement it that way? Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer is no because now we do not have the required class context. The
    preceding code produces a compile-time error. If we move the function outside
    the scope of the class, we need to define it with the `Dummy => (Int => String)` signature.
    That is, if we have a `Dummy` object, we can define a function from `Int` to `String`,
    with this object in context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is also possible to have it another way, `Int => (Dummy => String)`,
    without compromising the semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This idea was applied here when analyzing the `map` and `flatMap` signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the philosophy behind side effects. We found
    out that in the process of solving a business-domain problem, programmers end
    up in a reality different from the one of their business logic. The way you write
    the program and the phenomena that happen at runtime constitute a reality of their
    own. If you ignore it, the latter reality can grow in complexity, and this results
    in a mental overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming allows you to address the problem of the second-order
    reality by providing techniques to reify its phenomena into effect types and define
    their behavior in the language of data structures and pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Effect types lessen your mental load because they eliminate the necessity to
    remember all the phenomena that happen in your program, even outside the scope
    of the code you may currently be looking at.
  prefs: []
  type: TYPE_NORMAL
- en: Effect types also make the compiler force you to handle such phenomena. Working
    with effect types can quickly become quite verbose. Hence, functions such as `map`
    and `flatMap` exist to abstract away common scenarios that involve effect types.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which realities does a programmer need to consider when writing a program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does pure functional programming address the problem of complexity in the
    second-order reality?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of taking the second-order reality into account in our
    programs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
