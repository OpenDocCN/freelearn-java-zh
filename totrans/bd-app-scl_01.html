<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Introduction to FP, Reactive, and Scala" id="aid-E9OE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introduction to FP, Reactive, and Scala</h1></div></div></div><p>In our first chapter, we will learn the basic concepts of <span class="strong"><strong>Functional Programing</strong></span> (<span class="strong"><strong>FP</strong></span>), reactive programming, and the Scala language. These concepts are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Setting up a Scala development environment with Eclipse Scala IDE.</li><li class="listitem">Basic constructs of the language like var, val, for, if, switch, and operator overload.</li><li class="listitem">The difference between FP and object-oriented programming.</li><li class="listitem">Principles of pure FP: immutability, no side effects, state discipline, composition, and higher order functions.</li><li class="listitem">Concepts of FP such as lambda, recursion, for comprehensions, partial functions, Monads, currying, and functions.</li><li class="listitem">Pattern Matcher, recursion, reflection, package objects, and concurrency.</li></ul></div><p>Let's get going!</p><div class="section" title="Functional programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec7"/>Functional programming</h1></div></div></div><p>FP is not new at all. The very first implementation of FP is Lisp and is dated from the 1950s. Currently, we are living in a post-functional programming era, where we have the strong math principles and ideas from the 50s mixed with the most modern and beautiful piece of engineering, also know as the <span class="strong"><strong>Java Virtual Machine</strong></span> (<span class="strong"><strong>JVM</strong></span>). Scala is a post-functional programming language built on top of the JVM. Being on top of the JVM gives us a lot of benefits such as the following:</p><p>Scala is a post-functional programming language built on top of the JVM. Being on top of the JVM gives us a lot of benefits such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Reliability and performance</strong></span>: Java is used by 10 out of 10 top websites we have currently, like Netflix, Apple, Uber, Twitter, Yahoo, eBay, Yelp, LinkedIn, Google, Amazon, and many others. JVM is the best solution at scale and is battle-tested by these web-scale companies.</li><li class="listitem"><span class="strong"><strong>Native JVM eco-system</strong></span>: Full access to all of the Java ecosystem including frameworks, libraries, servers, and tools.</li><li class="listitem"><span class="strong"><strong>Operations leverage</strong></span>: Your operation team can run Scala in the same way they run Java.</li><li class="listitem"><span class="strong"><strong>Legacy code leverage</strong></span>: Scala allows you to easily integrate Scala code with Java code. This feature is great because it enables Java legacy system integration inside the box.</li><li class="listitem"><span class="strong"><strong>Java interoperability</strong></span>: A code written in Scala can be accessed in Java.</li></ul></div><p>Scala was created in 2001 at EPFL by Martin Odersky. Scala is a strong static-typed language, and was inspired by another functional language called <span class="strong"><strong>Haskell</strong></span>. Scala addresses several criticisms of the Java language, and delivers a better developer experience through less code and more concise programs, without losing performance.</p><p>Scala and Java share the same infrastructure as the JVM, but in terms of design, Scala is a different language in comparison with Java. Java is an imperative object-oriented language and Scala is a post-functional, multiparadigm programing language. FP works with different principles than <span class="strong"><strong>object-oriented programing</strong></span> (<span class="strong"><strong>OOP</strong></span>). OOP got very popular and well established in enterprise thanks to languages like Java, C#, Ruby, and Python. However, languages like Scala, Clojure, F#, and Swift are gaining a huge momentum, and FP has grown a lot in the last 10 years. Most of the new languages are pure functional, post-functional, or hybrid (like Java 8). In this book, you will see Scala code compared with Java code so you can see by yourself how Scala is way more compact, objective, and direct than Java and imperative OOP languages.</p><p>FP started at academia and spread to the world; FP is everywhere. Big Data and Stream processing solutions like Hadoop and Spark (built on top of Scala and Akka) are built on top of FP ideas and principles. FP spread to UI with <span class="strong"><strong>RxJavaScript </strong></span>- you can even find FP in a database with Datomic (Clojure). Languages like Clojure and Scala made FP more practical and attractive to enterprise and professional developers. In this book, we will be exploring both principles and practical aspects of the Scala language.</p></div></div>
<div class="section" title="Principles of functional programming"><div class="titlepage" id="aid-F8902"><div><div><h1 class="title"><a id="ch01lvl1sec8"/>Principles of functional programming</h1></div></div></div><p>FP is a way of thinking, a specific style of constructing and building programs. Having an FP language helps a lot in terms of syntax, but at the end of the day, it's all about ideas and developer mindset. FP favors disciplined state management and immutability in a declarative programming way rather than the imperative programming mostly used by OOP languages such as Java, Python, and Ruby.</p><p>FP has roots in math back to <span class="strong"><strong>Lambda calculus </strong></span>- a formal system developed in the 1930s. Lambda calculus is a mathematical abstraction and not a programming language, but it is easy to see its concepts in programming languages nowadays.</p><p>Imperative programming uses statements to change the program state. In other words, this means you give commands to the program to perform actions. This way of thinking describes a sequence of steps on how the program needs to operate. What you need to keep in mind is the kind of style focus on how FP works in a different way, focusing on what the program should accomplish without telling the program how to do it. When you are coding in FP, you tend to use fewer variables, for loops, and IFS, and write more functions and make function composition.</p><p>The following are the CORE principles of FP:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Immutability</li><li class="listitem">Disciplined state</li><li class="listitem">Pure functions and no side effects/disciplined states</li><li class="listitem">First class functions and high order functions</li><li class="listitem">Type systems</li><li class="listitem">Referential transparency</li></ul></div><p>Let's understand these principles in detail.</p><div class="section" title="Immutability"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec6"/>Immutability</h2></div></div></div><p>The concept of immutability is the CORE of FP, and it means that once you assign a value to something, that value won't change. This is very important, because it eliminates side effects (anything outside of the local function scope), for instance, changing other variables outside the function. Immutability makes it easier to read code, because you know the function that you are using is a pure function. Since your function has a disciplined state and does not change other variables outside of the function, you don't need to look at the code outside the function definition. This sounds like you're not working with state at all, so how would it be possible to write professional applications this way? Well, you will change state but in a very disciplined way. You will create another instance or another pointer to that instance, but you won't change that variable's value. Having immutability is the key to having better, faster, and more correct programs, because you don't need to use locks and your code is parallel by nature.</p></div><div class="section" title="Disciplined state"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec7"/>Disciplined state</h2></div></div></div><p>Shared mutable state is evil, because it is much harder to scale and to run it concurrently. What is shared mutable state? A simple way to see it is as a global variable that all your functions have access to. Why is this bad? First of all, because it is hard to keep this state correct since there are many functions that have direct access to this state. Second, if you are performing refactoring, this kind of code is often the hardest to refactor as well. It's also hard to read this code. This is because you can never trust the local method, since your local method is just one part of the program. And with mutable state, you need to look up for all the functions that use that variable, in order to understand the logic. It's hard to debug for the very same reason. When you are coding with FP principles in mind, you avoid, as much as possible, having a shared mutable state. Of course you can have state, but you should keep it local, which means inside your function. This is the state discipline: you use state, but in a very disciplined way. This is simple, but it could be hard especially if you are a professional developer, because this aspect is now usual to see in enterprise languages such as Java, .NET, Ruby, and Python.</p></div><div class="section" title="Pure functions and no side effects"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec8"/>Pure functions and no side effects</h2></div></div></div><p>Pure functions are the ones with no side effects. Side effects are bad, because they are unpredictable and make your software hard to test. Let's say you have a method that receives no parameters and returns nothing--this is one of the worst things we could have, because how do you test it? How can you reuse this code? This is not what we call a pure function. What are the possible side effects? Database call, global variables, IO call, and so on. This makes sense, but you cannot have a program with just pure functions, because it won't be practical.</p></div><div class="section" title="First-class functions and higher-order functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec9"/>First-class functions and higher-order functions</h2></div></div></div><p>First-class means that the language treats functions as first-class citizens. In other words, it means having language support to pass functions as arguments to other functions and to return values as functions. First-class function also implies that the language allows you to store functions as variables or any other data structure.</p><p>Higher-order functions are related to First-class functions, but they are not the same thing. Higher-order functions often means language support for partial functional application and Currying. Higher-order functions are a mathematical concept where functions operate with other functions.</p><p>Partial functions are when you can fix a value (argument) to a particular function, which you may or may not change later on. This is great for function composition.</p><p>Currying is a technique to transform a function with multiple parameters in a sequence of functions with each function having a single argument. Scala language does not force currying, however, languages like ML and Haskell almost always use this kind of technique.</p></div><div class="section" title="Type systems"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Type systems</h2></div></div></div><p>Type system is all about the compiler. The idea is simple: you create a type system, and by doing so, you leverage the compiler to avoid all kinds of mistakes and errors. This is because the compiler helps in making sure that you only have the right types as arguments, turn statements, function composition, and so on. The compiler will not allow you do make any basic mistakes. Scala and Haskell are examples of languages that are Strong-type. Meanwhile, Common Lisp, Scheme, and Clojure are dynamic languages that may accept wrong values during compilation time. One of the biggest benefits of the strong type system is that you have to write fewer tests, because the compiler will take care of several issues for you. For instance, if you have a function that receives a string, it could be dangerous, because you can pass pretty much anything in a string. However, if you have a function that receives a type called salesman, then you don't write a validation to check if it is a salesman. All this may sound silly, but in a real application, this saves lots of lines of code and makes you program better. Another great benefit of strong typing is that you have better documentation, as your code becomes your documentation, and it's way more clear what you can or can't do.</p></div><div class="section" title="Referential transparency"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Referential transparency</h2></div></div></div><p>Referential transparency is a concept which works close with pure functions and immutability since your program has fewer assignment statements, and often when you have it, you tend to never change that value. This is great because you eliminate side effects with this technique. During program execution, any variable can be replaced since there are no side effects, and the program becomes referentially transparent. Scala language makes this concept very clear the moment you declare a variable.</p></div></div>
<div class="section" title="Installing Java 8 and Scala 2.11" id="aid-G6PI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec9"/>Installing Java 8 and Scala 2.11</h1></div></div></div><p>Scala requires JVM to work, so we need get the JDK 8 before installing Scala. Go to the Oracle website, and download and install JDK 8 from <a class="ulink" href="http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html">http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html</a>.</p><p>Once you've downloaded Java, we need to add Java to the <code class="literal">PATH</code> variable; otherwise, you can use the terminal. We do this as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ cd ~/</strong></span>
<span class="strong"><strong>$ wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "</strong></span>
<span class="strong"><strong>http://download.oracle.com/otn-pub/java/jdk/8u77-b03/jdk-8u77-linux-i586.tar.gz"</strong></span>
<span class="strong"><strong>$ tar -xzvf $ jdk-8u77-linux-x64.tar.gz </strong></span>
<span class="strong"><strong>$ rm -f jdk-8u77-linux-x64.tar.gz</strong></span>
</pre><p>The next step is to create the environment variable called <code class="literal">JAVA_HOME</code>, and to put the Java 8 binaries in the <code class="literal">PATH</code> variable. In Linux, we need to edit the <code class="literal">~/.bashrc</code> file, and export the variables we need, like in the following:</p><pre class="programlisting">
<span class="strong"><strong>export JAVA_HOME=~/jdk1.8.0_77</strong></span>
<span class="strong"><strong>export PATH=$PATH:$JAVA_HOME/bin</strong></span>
</pre><p>Save the file, and then on the same terminal we need to source the file via <code class="literal">$ source ~/.bashrc</code>
</p><p>Now we can test our Java 8 installation. Just type in <code class="literal">$ java -version</code>. You should see something like the following:</p><pre class="programlisting">
<span class="strong"><strong>$ java -version</strong></span>
<span class="strong"><strong>java version "1.8.0_77"</strong></span>
<span class="strong"><strong>Java(TM) SE Runtime Environment (build 1.8.0_77-b03)</strong></span>
<span class="strong"><strong>Java HotSpot(TM) Server VM (build 25.77-b03, mixed mode)</strong></span>
</pre><p>Let's get started. We will be using the latest Scala version 2.11.8. However, the code inside this book should work with any Scala 2.11.x version. First of all, let's download Scala from <a class="ulink" href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>.</p><p>Scala works on Windows, Mac, and Linux. For this book, I will show how to use Scala on Ubuntu Linux(Debian-based). Open your browser and go to <a class="ulink" href="http://www.scala-lang.org/download/">http://www.scala-lang.org/download/</a>.</p><p>Download <code class="literal">scala 2.11.8</code>: it will be a TGZ file. Extract it and add it to your path; otherwise, you can use the terminal. Do this as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ cd ~/</strong></span>
<span class="strong"><strong>$ wget http://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz</strong></span>
<span class="strong"><strong>$ tar -xzvf scala-2.11.8.tgz</strong></span>
<span class="strong"><strong>$ rm -rf scala-2.11.8.tgz</strong></span>
</pre><p>The next step is to create the environment variable called <code class="literal">SCALA_HOME</code>, and to put the Scala binaries in the <code class="literal">PATH</code> variable. In Linux, we need to edit the <code class="literal">~/.bashrc</code> file and export the variables we need, like in the following:</p><pre class="programlisting">
<span class="strong"><strong>export SCALA_HOME=~/scala-2.11.8/</strong></span>
<span class="strong"><strong>export PATH=$PATH:$SCALA_HOME/bin</strong></span>
</pre><p>Save the file, and then, on the same terminal, we need to source the file via <code class="literal">$ source ~/.bashrc</code>.</p><p>Now we can test our Scala installation. Just type in <code class="literal">$ scala -version</code>. You should see something like the following:</p><pre class="programlisting">
<span class="strong"><strong>$ scala -version</strong></span>
<span class="strong"><strong>Scala code runner version 2.11.8 -- Copyright 2002-2016, LAMP/EPFL</strong></span>
</pre><p>You have successfully installed Java 8 and Scala 2.11. Now we are ready to start learning the FP principles in Scala. For this, we will be using the Scala REPL in the beginning. Scala REPL is bundled with the default Scala installation, and you just need to type <code class="literal">$ scala</code> in your terminal as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
<span class="strong"><strong>Scala REPL</strong></span>
</pre><p>Congratulations! You have installed Java 8 and Scala 2.11 successfully.</p></div>
<div class="section" title="Read Eval Print and Loop - REPL" id="aid-H5A41"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Read Eval Print and Loop - REPL</h1></div></div></div><p>
<span class="strong"><strong>Read Eval Print and Loop</strong></span> (<span class="strong"><strong>REPL</strong></span>) is also know as a language shell. Many other languages have shells, like Lisp, Python, and Ruby for instance. The REPL is a simple environment to experiment the language in. It's possible to write very complex programs using REPL, but this is not the REPL goal. Using REPL does not invalidate the usage of an IDE like Eclipse or IntelliJ IDEA. REPL is ideal for testing simple commands and programs without having to spend much time configuring projects like you do with an IDE. The Scala REPL allows you to create a variable, functions, classes, and complex functions as well. There is a history of every command you perform; there is some level of autocomplete too. As a REPL user, you can print variable values and call functions.</p></div>
<div class="section" title="Scala Hello World using the REPL" id="aid-I3QM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Scala Hello World using the REPL</h1></div></div></div><p>Let's get started. Go ahead, open your terminal, and type <code class="literal">$ scala</code> in order to open the Scala REPL. Once the REPL is open, you can just type <code class="literal">"Hello World"</code>. By doing this, you perform two operations: eval and print. The Scala REPL will create a variable called <code class="literal">res0</code>, and store your String there. Then it will print the content of the <code class="literal">res0</code> variable.</p><div class="section" title="Scala REPL Hello World program"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Scala REPL Hello World program</h2></div></div></div><p>We will see how to create Hello World program in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; "Hello World"</strong></span>
<span class="strong"><strong>res0: String = Hello World</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
</pre><p>Scala is a hybrid language, which means it is object-oriented and functional as well. You can create classes and objects in Scala. Next we will create a complete Hello World application using classes.</p></div><div class="section" title="Scala object-oriented HelloWorld program"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Scala object-oriented HelloWorld program</h2></div></div></div><p>We will see how to create object-oriented HelloWorld program in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; object HelloWorld {</strong></span>
<span class="strong"><strong>     |   def main(args:Array[String]) = println("Hello World")</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined object HelloWorld</strong></span>
<span class="strong"><strong>scala&gt; HelloWorld.main(null)</strong></span>
<span class="strong"><strong>Hello World</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>The first thing you need to realize is that we use the word object instead of class. The Scala language has different constructs compared to Java. Object is a singleton in Scala. It's the same as coding the singleton pattern in Java.</p><p>Next we see the word <code class="literal">def</code> that is used in Scala to create functions. In the preceding program, we create the main function similar to the way we do it in Java, and we call the built-in function <code class="literal">println</code> in order to print the String Hello World. Scala imports some Java objects and packages by default. Coding in Scala does not require you to type, for instance, <code class="literal">System.out.println("Hello World")</code>, but you can if you want. Let's take a look at it in the following code:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; System.out.println("Hello World") </strong></span>
<span class="strong"><strong>Hello World</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>We can and we will do better. Scala has some abstractions for a console application, so we can write this code with a lesser number of lines of code. To accomplish this goal, we need to extend the Scala class App. When we extend from App, we perform inheritance and we don't need to define the main function. We can just put all the code in the body of the class, which is very convenient and makes the code clean and simple to read.</p></div><div class="section" title="Scala HelloWorld App in the Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Scala HelloWorld App in the Scala REPL</h2></div></div></div><p>We will see how to create Scala HelloWorld App in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; object HelloWorld extends App {</strong></span>
<span class="strong"><strong>     |  println("Hello World")</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined object HelloWorld</strong></span>
<span class="strong"><strong>scala&gt; HelloWorld</strong></span>
<span class="strong"><strong>object HelloWorld</strong></span>
<span class="strong"><strong>scala&gt; HelloWorld.main(null)</strong></span>
<span class="strong"><strong>Hello World</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>After coding the HelloWorld object in the Scala REPL we can ask the REPL what HelloWorld is, and as you might realize, the REPL will answer that HelloWorld is an object. This is a very convenient Scala way to code console applications, because we can have a Hello World application with just three lines of code. Sadly, to have the same program in Java, it required way more code. Java is a great language for performance, but it is a verbose language compared with Scala, for instance.</p></div><div class="section" title="Java HelloWorld application"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Java HelloWorld application</h2></div></div></div><p>We will see how to create Java HelloWorld application as follows:</p><pre class="programlisting">    package scalabook.javacode.chap1; &#13;
 &#13;
    public class HelloWorld { &#13;
      public static void main(String args[]){ &#13;
        System.out.println("Hellow World"); &#13;
      } &#13;
    } &#13;
</pre><p>The Java app required six lines of code, while in Scala, we were able to do the same with 50% less code (three lines of code). This is a very simple application. When we are coding complex applications, this difference gets bigger, as a Scala application ends up with way less code than Java.</p><p>Remember, we use an object in Scala in order to have a Singleton (Design Pattern that makes sure you have just one instance of a class), and if we want the same in Java, the code would be something like the following:</p><pre class="programlisting">    package scalabook.javacode.chap1; &#13;
 &#13;
    public class HelloWorldSingleton { &#13;
   &#13;
      private HelloWorldSingleton(){} &#13;
   &#13;
      private static class SingletonHelper{ &#13;
        private static final HelloWorldSingleton INSTANCE =  &#13;
        new HelloWorldSingleton(); &#13;
      } &#13;
   &#13;
      public static HelloWorldSingleton getInstance(){ &#13;
        return SingletonHelper.INSTANCE; &#13;
      } &#13;
   &#13;
      public void sayHello(){ &#13;
        System.out.println("Hello World"); &#13;
      } &#13;
   &#13;
      public static void main(String[] args) { &#13;
        getInstance().sayHello(); &#13;
      } &#13;
    } &#13;
</pre><p>It's not just about the size of the code, but also about consistency and the language providing more abstractions for you. If you write less code, you will have fewer bugs in your software at the end of the day.</p></div></div>
<div class="section" title="Scala language - the basics" id="aid-J2B81"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Scala language - the basics</h1></div></div></div><p>Scala is a statically typed language with a very expressive type system which enforces abstractions in a safe yet coherent manner. All values in Scala are Java objects (primitives which are unboxed at runtime), because at the end of the day, Scala runs on the Java JVM. Scala enforces immutability as a core FP principle. This enforcement happens in multiple aspects of the Scala language, for instance, when you create a variable, you do it in an immutable way, when you use an collection, you will use a immutable collection. Scala also lets you use mutable variables and mutable structures, but by design, it favors immutable ones.</p></div>
<div class="section" title="Scala variables - var and val" id="aid-K0RQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Scala variables - var and val</h1></div></div></div><p>When you are coding in Scala, you create variables using the operator <code class="literal">var</code>, or you can use the operator <code class="literal">val</code>. The operator <code class="literal">var</code> allows you to create a mutable state, which is fine as long as you make it local, follow the CORE-FP principles and avoid a mutable shared state.</p><div class="section" title="Scala REPL var usage"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Scala REPL var usage</h2></div></div></div><p>We will see how to use var in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala&#13;
Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).&#13;
Type in expressions for evaluation. Or try :help.&#13;
    &#13;
scala&gt; var x = 10&#13;
x: Int = 10&#13;
    &#13;
scala&gt; x&#13;
res0: Int = 10&#13;
&#13;
scala&gt; x = 11&#13;
x: Int = 11&#13;
    &#13;
scala&gt; x &#13;
res1: Int = 11&#13;
    &#13;
scala&gt; &#13;
</strong></span>
</pre><p>However, Scala has a more interesting construct called <code class="literal">val</code>. Using the <code class="literal">val</code> operator makes your variables immutable, and this means you can't change the value once you've set it. If you try to change the value of the <code class="literal">val</code> variable in Scala, the compiler will give you an error. As a Scala developer, you should use the variable <code class="literal">val</code> as much as possible, because that's a good FP mindset, and it will make your programs better. In Scala, everything is an object; there are no primitives -- the <code class="literal">var</code> and <code class="literal">val</code> rules apply for everything it could but an <code class="literal">Int</code> or <code class="literal">String</code> or even a class.</p></div><div class="section" title="Scala val usage at the Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Scala val usage at the Scala REPL</h2></div></div></div><p>We will see how to use val in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val x = 10</strong></span>
<span class="strong"><strong>x: Int = 10</strong></span>
<span class="strong"><strong>scala&gt; x</strong></span>
<span class="strong"><strong>res0: Int = 10</strong></span>
<span class="strong"><strong>scala&gt; x = 11</strong></span>
<span class="strong"><strong>&lt;console&gt;:12: error: reassignment to val</strong></span>
<span class="strong"><strong>       x = 11</strong></span>
<span class="strong"><strong>         ^</strong></span>
<span class="strong"><strong>scala&gt; x</strong></span>
<span class="strong"><strong>res1: Int = 10</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre></div></div>
<div class="section" title="Creating immutable variables" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Creating immutable variables</h1></div></div></div><p>Right now, let's see how we define the most common types in Scala such as <code class="literal">Int</code>, <code class="literal">Double</code>, <code class="literal">Boolean</code>, and <code class="literal">String</code>. Remember, you can create these variables using <code class="literal">val</code> or <code class="literal">var</code> depending on your needs.</p><div class="section" title="Scala variable type in the Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Scala variable type in the Scala REPL</h2></div></div></div><p>We will see Scala variable type in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val x = 10</strong></span>
<span class="strong"><strong>x: Int = 10</strong></span>
<span class="strong"><strong>scala&gt; val y = 11.1</strong></span>
<span class="strong"><strong>y: Double = 11.1</strong></span>
<span class="strong"><strong>scala&gt; val b = true</strong></span>
<span class="strong"><strong>b: Boolean = true</strong></span>
<span class="strong"><strong>scala&gt; val f = false</strong></span>
<span class="strong"><strong>f: Boolean = false</strong></span>
<span class="strong"><strong>scala&gt; val s = "A Simple String"</strong></span>
<span class="strong"><strong>s: String = A Simple String</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>For the variables in the preceding code, we did not define the type. Scala language figures it out for us. However, it is possible to specify the type if you want. In Scala, the type comes after the name of the variable.</p></div><div class="section" title="Scala variables with explicit typing at the Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Scala variables with explicit typing at the Scala REPL</h2></div></div></div><p>We will see Scala variables with explicit typing at Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val x:Int = 10</strong></span>
<span class="strong"><strong>x: Int = 10</strong></span>
<span class="strong"><strong>scala&gt; val y:Double = 11.1</strong></span>
<span class="strong"><strong>y: Double = 11.1</strong></span>
<span class="strong"><strong>scala&gt; val s:String = "My String "</strong></span>
<span class="strong"><strong>s: String = "My String "</strong></span>
<span class="strong"><strong>scala&gt; val b:Boolean = true</strong></span>
<span class="strong"><strong>b: Boolean = true</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre></div></div>
<div class="section" title="Scala conditional and loops statements"><div class="titlepage" id="aid-LTSU2"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Scala conditional and loops statements</h1></div></div></div><p>Like any other language, Scala has support for conditional statements like <code class="literal">if</code> and <code class="literal">else</code>. While Java has a switch statement, Scala has a more powerful and functional structure called Pattern Matcher, which we will cover later in this chapter. Scala allows you to use <code class="literal">if</code> statements during variable assignments, which is very practical as well as useful.</p><div class="section" title="If statements in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>If statements in Scala REPL</h2></div></div></div><p>We will see how to use <code class="literal">if</code> statements in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val x = 10</strong></span>
<span class="strong"><strong>x: Int = 10</strong></span>
<span class="strong"><strong>scala&gt; if (x == 10) </strong></span>
<span class="strong"><strong>     | println ("X is 10")</strong></span>
<span class="strong"><strong>X is 10</strong></span>
<span class="strong"><strong>scala&gt; val y = if (x == 10 ) 11</strong></span>
<span class="strong"><strong>y: AnyVal = 11</strong></span>
<span class="strong"><strong>scala&gt; y</strong></span>
<span class="strong"><strong>res1: AnyVal = 11</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>In the preceding code, you can see that we set the variable <code class="literal">y</code> based on an <code class="literal">if</code> condition. Scala <code class="literal">if</code> conditions are very powerful, and they also can be used in return statements.</p></div><div class="section" title="If statements in return statements in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>If statements in return statements in Scala REPL</h2></div></div></div><p>We will see how to use <code class="literal">if</code> statements in return statements in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val x = 10</strong></span>
<span class="strong"><strong>x: Int = 10</strong></span>
<span class="strong"><strong>scala&gt; def someFunction = if (x == 10) "X is 10"</strong></span>
<span class="strong"><strong>someFunction: Any</strong></span>
<span class="strong"><strong>scala&gt; someFunction</strong></span>
<span class="strong"><strong>res0: Any = X is 10</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Scala supports <code class="literal">else</code> statements too, and you also can use them in variables and return statements as wellas follows:</p><pre class="programlisting">
<span class="strong"><strong>~$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val x = 10</strong></span>
<span class="strong"><strong>x: Int = 10</strong></span>
<span class="strong"><strong>scala&gt; if (x==10){</strong></span>
<span class="strong"><strong>     |   println("X is 10")</strong></span>
<span class="strong"><strong>     | } else {</strong></span>
<span class="strong"><strong>     |   println ("X is something else")</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>X is 10</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Now you will learn how to use for loops in Scala. For loops are very powerful in Scala. We will start with the basics and later we will move on to functional loops used for comprehensions, also know as <code class="literal">List</code> comprehensions.</p><p>In Scala, for loops work with ranges, which is another Scala data structure that represents numbers from a starting point to an end point. The range is created using the left arrow operator(<code class="literal">&lt;-</code>). Scala allows you to have multiple ranges in the same for loop as long as you use the semicolon(<code class="literal">;</code>).</p><p>You also can use <code class="literal">if</code> statements in order to filter data inside for loops, and work smoothly with <code class="literal">List</code> structures. Scala allows you to create variables inside a for loop as well. Right now, let's see some code which illustrates the various for loop usages in Scala language.</p></div><div class="section" title="Basic for loop in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Basic for loop in Scala REPL</h2></div></div></div><p>We will see how to use basic for loop in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; for ( i &lt;- 1 to 10)</strong></span>
<span class="strong"><strong>     | println("i * " + i + " = " +  i * 10)</strong></span>
<span class="strong"><strong>i * 1 = 10</strong></span>
<span class="strong"><strong>i * 2 = 20</strong></span>
<span class="strong"><strong>i * 3 = 30</strong></span>
<span class="strong"><strong>i * 4 = 40</strong></span>
<span class="strong"><strong>i * 5 = 50</strong></span>
<span class="strong"><strong>i * 6 = 60</strong></span>
<span class="strong"><strong>i * 7 = 70</strong></span>
<span class="strong"><strong>i * 8 = 80</strong></span>
<span class="strong"><strong>i * 9 = 90</strong></span>
<span class="strong"><strong>i * 10 = 100</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
</pre><p>Right now, we will create a for loop using a Scala data structure called <code class="literal">List</code>. This is very useful, because in the first line of code, you can define a <code class="literal">List</code> as well as set its values in the same line. Since we are using the <code class="literal">List</code> structure, you don't need to pass any other argument besides the <code class="literal">List</code> itself.</p></div><div class="section" title="For with List in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>For with List in Scala REPL</h2></div></div></div><p>We will see how to <code class="literal">use</code> for with <code class="literal">List</code> in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val listOfValues = List(1,2,3,4,5,6,7,8,9,10)</strong></span>
<span class="strong"><strong>listOfValues: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</strong></span>
<span class="strong"><strong>scala&gt; for ( i&lt;- listOfValues ) println(i)</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>3</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>5</strong></span>
<span class="strong"><strong>6</strong></span>
<span class="strong"><strong>7</strong></span>
<span class="strong"><strong>8</strong></span>
<span class="strong"><strong>9</strong></span>
<span class="strong"><strong>10</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Next, we can use for loops with <code class="literal">if</code> statements in order to apply some filtering. Later in this book, we will approach a more functional way to approach filtering using functions. For this code, let's say we want to get just the even numbers on the list and print them.</p></div><div class="section" title="For with if statements for filtering - Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>For with if statements for filtering - Scala REPL</h2></div></div></div><p>We will see how to use <code class="literal">for</code> with <code class="literal">if</code> statements in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val listOfValues = List(1,2,3,4,5,6,7,8,9,10)</strong></span>
<span class="strong"><strong>listOfValues: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</strong></span>
<span class="strong"><strong>scala&gt; for ( i&lt;- listOfValues ) if  (i % 2== 0) println(i)</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>6</strong></span>
<span class="strong"><strong>8</strong></span>
<span class="strong"><strong>10</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre></div><div class="section" title="Java code for filtering even numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Java code for filtering even numbers</h2></div></div></div><p>In Scala language, we just need two lines of code to perform this filtering, whereas in Java it would have required at least eleven lines of code as you see in the following code:</p><pre class="programlisting">    package scalabook.javacode.chap1; 
 
    import java.util.Arrays; 
    import java.util.List; 
 
    public class ForLoopsEvenNumberFiltering { 
      public static void main(String[] args) { 
        List&lt;Integer&gt; listOfValues = Arrays.asList( 
          new Integer[]{1,2,3,4,5,6,7,8,9,10}); 
        for(Integer i : listOfValues){ 
          if (i%2==0) System.out.println(i); 
        } 
      } 
    } 
</pre></div></div>
<div class="section" title="For comprehensions" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>For comprehensions</h1></div></div></div><p>Also known as list or sequence comprehensions, for comprehensions are one of the FP ways to perform loops. This is a language support to create <code class="literal">List</code> structure or collections based on other collections. This task is performed in a <code class="literal">SetBuilder</code> notation. Another way to accomplish the same goal would be by using the <code class="literal">Map</code> and <code class="literal">filter</code> functions, which we will cover later in this chapter. For comprehensions can be used in a generator form, which would introduce new variables and values, or in a reductionist way, which would filter values resulting into a new collection or sequence. The syntax is: <code class="literal">for (expt) yield e</code>, where the <code class="literal">yield</code> operator will add new values to a new collection/sequence that will be created from the original sequence.</p><div class="section" title="For comprehension in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>For comprehension in Scala REPL</h2></div></div></div><p>We will see how to use <code class="literal">for</code> comprehension in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val names = Set("Diego", "James", "John", "Sam", "Christophe")</strong></span>
<span class="strong"><strong>names: scala.collection.immutable.Set[String] = Set(John, Sam, Diego, James, Christophe)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val brazilians = for {</strong></span>
<span class="strong"><strong>     |   name &lt;- names  </strong></span>
<span class="strong"><strong>     |   initial &lt;- name.substring(0, 1)</strong></span>
<span class="strong"><strong>     |     } yield if (name.contains("Die")) name</strong></span>
<span class="strong"><strong>brazillians: scala.collection.immutable.Set[Any] = Set((), Diego)</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>In the preceding code, we create a set of names. As you can see, Scala, by default, prefers immutable data structures and uses <code class="literal">immutable.Set</code>. When we apply the <code class="literal">for</code> loop, we are simply filtering only the <code class="literal">names</code> which contain a specific substring, and then, using the <code class="literal">yield</code> operator, we are creating a new <code class="literal">Set</code> structure. The <code class="literal">yield</code> operator will keep the structure you are using. For instance, if we use <code class="literal">List</code> structure, it would create a <code class="literal">List</code> instead of a <code class="literal">Set structure</code>, the <code class="literal">yield</code> operator will always keep the same data collection you have on the variable. Another interesting aspect of the preceding code is the fact that we are holding the result of the <code class="literal">for</code> comprehension in a variable called Brazilians. Java does not have <code class="literal">for</code> comprehensions, but we could use similar code although it would require way more lines of code.</p></div><div class="section" title="Java code for performing filtering with collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>Java code for performing filtering with collections</h2></div></div></div><p>We will see how to use Java code for performing filtering with collections as follows:</p><pre class="programlisting">    package scalabook.javacode.chap1; &#13;
 &#13;
    import java.util.LinkedHashSet; &#13;
    import java.util.Set; &#13;
 &#13;
    public class JavaNoForComprehension { &#13;
      public static void main(String[] args) { &#13;
     &#13;
        Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(); &#13;
        Set&lt;String&gt; brazillians = new LinkedHashSet&lt;&gt;(); &#13;
     &#13;
        names.add("Diego"); &#13;
        names.add("James"); &#13;
        names.add("John"); &#13;
        names.add("Sam"); &#13;
        names.add("Christophe"); &#13;
     &#13;
        for (String name: names){ &#13;
          if (name.contains("Die")) brazillians.add(name);  &#13;
        } &#13;
     &#13;
        System.out.println(brazillians); &#13;
      } &#13;
    } &#13;
</pre></div></div>
<div class="section" title="Scala collections"><div class="titlepage" id="aid-NQU22"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Scala collections</h1></div></div></div><p>In the previous section, we saw how to create the <code class="literal">List</code> and <code class="literal">Set</code> structures in Scala in an immutable way. Now we will learn to work with the <code class="literal">List</code> and <code class="literal">Set</code> structures in a mutable way, and also with other collections such as sequences, tuples, and Maps. Let's take a look at the Scala collections hierarchy tree, as shown in the following diagram:</p><p>
</p><div class="mediaobject"><img src="../Images/image00231.jpeg" alt="Scala collections"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Now let's take a look at the Scala Seq class hierarchy. As you can see, Seq is traversable as well.</p><p>
</p><div class="mediaobject"><img src="../Images/image00232.jpeg" alt="Scala collections"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Scala collections extend from traversable, which is the main trait of all collection's descends. <code class="literal">List</code> structures, for instance, extend from Seq class hierarchy, which means sequence - <code class="literal">List</code> is a kind of sequence. All these trees are immutable or mutable depending on the Scala package you end up using.</p><p>Let's see how to perform basic mutable operations with <code class="literal">List</code> structures in Scala. In order to have filter and removal operations, we need use a <code class="literal">Buffer</code> sequence as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; var ms = scala.collection.mutable.ListBuffer(1,2,3)</strong></span>
<span class="strong"><strong>ms: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3)</strong></span>
<span class="strong"><strong>scala&gt; ms += 4</strong></span>
<span class="strong"><strong>res0: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4)</strong></span>
<span class="strong"><strong>scala&gt; ms += 5</strong></span>
<span class="strong"><strong>res1: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4, 5)</strong></span>
<span class="strong"><strong>scala&gt; ms += 6</strong></span>
<span class="strong"><strong>res2: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4, 5, 6)</strong></span>
<span class="strong"><strong>scala&gt; ms(1)</strong></span>
<span class="strong"><strong>res3: Int = 2</strong></span>
<span class="strong"><strong>scala&gt; ms(5)</strong></span>
<span class="strong"><strong>res4: Int = 6</strong></span>
<span class="strong"><strong>scala&gt; ms -= 5</strong></span>
<span class="strong"><strong>res5: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4, 6)</strong></span>
<span class="strong"><strong>scala&gt; ms -= 6</strong></span>
<span class="strong"><strong>res6: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4)</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Let's see the next set of code.</p><div class="section" title="Creating, removing, and getting an item from a mutable list in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>Creating, removing, and getting an item from a mutable list in Scala REPL</h2></div></div></div><p>We will see how to create, remove, and get an item from a mutable list in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; var names = scala.collection.mutable.SortedSet[String]("Diego", "Poletto", "Jackson")</strong></span>
<span class="strong"><strong>names: scala.collection.mutable.SortedSet[String] = TreeSet(Diego, Jackson, Poletto)</strong></span>
<span class="strong"><strong>scala&gt; names += "Sam"</strong></span>
<span class="strong"><strong>res2: scala.collection.mutable.SortedSet[String] = TreeSet(Diego, Jackson, Poletto, Sam)</strong></span>
<span class="strong"><strong>scala&gt; names("Diego")</strong></span>
<span class="strong"><strong>res4: Boolean = true</strong></span>
<span class="strong"><strong>scala&gt; names -= "Jackson"</strong></span>
<span class="strong"><strong>res5: scala.collection.mutable.SortedSet[String] = TreeSet(Diego, Poletto, Sam)</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Have you ever wanted to return multiple values in a method? Well, in Java you have to create a class, but in Scala, there is a more convenient way to perform this task, and you won't need to create new classes each time. Tuples allow you to return or simply hold multiple values in methods without having to create a specific type.</p></div><div class="section" title="Scala tuples"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Scala tuples</h2></div></div></div><p>We will see Scala tuples as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val config = ("localhost", 8080)</strong></span>
<span class="strong"><strong>config: (String, Int) = (localhost,8080)</strong></span>
<span class="strong"><strong>scala&gt; config._1</strong></span>
<span class="strong"><strong>res0: String = localhost</strong></span>
<span class="strong"><strong>scala&gt; config._2</strong></span>
<span class="strong"><strong>res1: Int = 8080</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Scala has special methods called <code class="literal">_1</code> and <code class="literal">_2</code> which you can use to retrieve a tuple's values. The only thing you have to keep in mind is the fact that values are kept in the order of insertion in the tuple.</p><p>Scala has a very practical and useful collection library. A Map, for instance, is a key/value pair that can be retrieved based on the key, which is unique. However, Map values do not need to be unique. Like other Scala collections, you have mutable and immutable Map collections. Keep in mind that Scala favors immutable collections over mutable ones.</p></div><div class="section" title="Scala immutable Map in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>Scala immutable Map in Scala REPL</h2></div></div></div><p>We will see Scala immutable Map in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val numbers = Map("one"   -&gt; 1, </strong></span>
<span class="strong"><strong>     |                   "two"   -&gt; 2,</strong></span>
<span class="strong"><strong>     |                   "three" -&gt; 3,</strong></span>
<span class="strong"><strong>     |                   "four"  -&gt; 4,</strong></span>
<span class="strong"><strong>     |                   "five"  -&gt; 5,</strong></span>
<span class="strong"><strong>     |                   "six"   -&gt; 6,</strong></span>
<span class="strong"><strong>     |                   "seven" -&gt; 7,</strong></span>
<span class="strong"><strong>     |                   "eight" -&gt; 8,</strong></span>
<span class="strong"><strong>     |                   "nine"  -&gt; 9,</strong></span>
<span class="strong"><strong>     |                   "ten"   -&gt; 10)</strong></span>
<span class="strong"><strong>numbers: scala.collection.immutable.Map[String,Int] = Map(four -&gt; 4, three -&gt; 3, two -&gt; 2, six -&gt; 6, seven -&gt; 7, ten -&gt; 10, five -&gt; 5, nine -&gt; 9, one -&gt; 1, eight -&gt; 8)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; numbers.keys</strong></span>
<span class="strong"><strong>res0: Iterable[String] = Set(four, three, two, six, seven, ten, five, nine, one, eight)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; numbers.values</strong></span>
<span class="strong"><strong>res1: Iterable[Int] = MapLike(4, 3, 2, 6, 7, 10, 5, 9, 1, 8)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; numbers("one")</strong></span>
<span class="strong"><strong>res2: Int = 1</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>As you can see, Scala uses <code class="literal">scala.collection.immutable.Map</code> when you create a Map using <code class="literal">Map()</code>. Both keys and values are iterable, and you can have access to all the keys with the <code class="literal">keys</code> method or to all the values using the <code class="literal">values</code> method.</p></div><div class="section" title="Scala mutable Maps at Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>Scala mutable Maps at Scala REPL</h2></div></div></div><p>We will see Scala mutable Map in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val map = scala.collection.mutable.HashMap.empty[Int,String]</strong></span>
<span class="strong"><strong>map: scala.collection.mutable.HashMap[Int,String] = Map()</strong></span>
<span class="strong"><strong>scala&gt; map += (1 -&gt; "one")</strong></span>
<span class="strong"><strong>res0: map.type = Map(1 -&gt; one)</strong></span>
<span class="strong"><strong>scala&gt; map += (2 -&gt; "two")</strong></span>
<span class="strong"><strong>res1: map.type = Map(2 -&gt; two, 1 -&gt; one)</strong></span>
<span class="strong"><strong>scala&gt; map += (3 -&gt; "three")</strong></span>
<span class="strong"><strong>res2: map.type = Map(2 -&gt; two, 1 -&gt; one, 3 -&gt; three)</strong></span>
<span class="strong"><strong>scala&gt; map += (4 -&gt; "mutable")</strong></span>
<span class="strong"><strong>res3: map.type = Map(2 -&gt; two, 4 -&gt; mutable, 1 -&gt; one, 3 -&gt; three)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
</pre><p>If you are dealing with mutable state, you have to be explicit and this is great in Scala, because it increases developers' awareness and avoids mutable shared state by default. So, in order to have a mutable Map, we need to explicitly create the Map with <code class="literal">scala.collection.mutable.HashMap</code>.</p></div></div>
<div class="section" title="Monads"><div class="titlepage" id="aid-OPEK2"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Monads</h1></div></div></div><p>Monads are combinable parametrized container types which have support for higher-order functions. Remember higher-order functions are functions which receive functions as parameters and return functions as results. One of the most used functions in FP is Map. Map takes a function, applies it to each element in the container, and returns a new container.</p><div class="section" title="Scala Map function in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Scala Map function in Scala REPL</h2></div></div></div><p>We will see Map function in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val numbers = List(1,2,3,4,5,6)</strong></span>
<span class="strong"><strong>numbers: List[Int] = List(1, 2, 3, 4, 5, 6)</strong></span>
<span class="strong"><strong>scala&gt; def doubleIt(i:Int):Double = i * 2</strong></span>
<span class="strong"><strong>doubleIt: (i: Int)Double</strong></span>
<span class="strong"><strong>scala&gt; val doubled = numbers.map( doubleIt _ )</strong></span>
<span class="strong"><strong>doubled: List[Double] = List(2.0, 4.0, 6.0, 8.0, 10.0, 12.0)</strong></span>
<span class="strong"><strong>scala&gt; val doubled = numbers.map( 2.0 * _ )</strong></span>
<span class="strong"><strong>doubled: List[Int] = List(2.0, 4.0, 6.0, 8.0, 10.0, 12.0)</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>In the preceding code, we created a list of numbers containing 1,2,3,4,5, and 6. We also defined a Scala function called <code class="literal">doubleIt</code>, which receives an integer and multiplies it by <code class="literal">2.0</code> resulting in a double number. The <code class="literal">map</code> function calls <code class="literal">doubleIt</code> for each element in the <code class="literal">List (1,2,3,4,5,6)</code>, and the result is a new container, a brand new <code class="literal">List</code> instance containing the new values.</p><p>Scala has some syntactical sugar which helps us to be more productive. For instance, you may realize that in the previous code, we also did - <code class="literal">2.0 * _</code>. The underscore is a special operator for this specific case -- it means the current value is being iterated into the collection. Scala will create a function from this expression for us.</p><p>As you might have realized, <code class="literal">map</code> functions are pretty useful for lots of reasons: one reason is that you can do complex computations without using the <code class="literal">for</code> loop explicitly, and this makes your code functional. Secondly, we can use a <code class="literal">map</code> function to convert element types from one type to another. That's what we did in the previous code: we transformed a list of integers into a list of doubles. Look at the following:</p><pre class="programlisting">
<span class="strong"><strong>scala&gt; val one = Some(1)  </strong></span>
<span class="strong"><strong>one: Some[Int] = Some(1)</strong></span>
<span class="strong"><strong>scala&gt; val oneString = one.map(_.toString)</strong></span>
<span class="strong"><strong>oneString: Option[String] = Some(1)</strong></span>
</pre><p>The <code class="literal">map</code> function operates over several data structures and not only collections, as you can see in the previous code. You can use the <code class="literal">map</code> function on pretty much everything in Scala language.</p><p>The <code class="literal">map</code> function is great, but you can end up with nested structures. That's why, when we are working with Monads, we use a slightly different version of the <code class="literal">map</code> function called <code class="literal">flatMap</code>, which works in a very similar way to the <code class="literal">map</code> function, but returns the values in a flat form instead of nested values.</p><p>In order to have a monad, you need to have a method called <code class="literal">flatMap</code>. Other function languages such as Haskell call <code class="literal">flatMap</code> as <code class="literal">bind</code>, and use the operator <code class="literal">&gt;&gt;=</code>. The syntax changes with the language, but the concept is the same.</p><p>Monads can be built in different ways. In Scala, we need a single argument constructor which will work as a monad factory. Basically, the constructor receives one type, <code class="literal">A</code>, and returns <code class="literal">Monad[A]</code> or just <code class="literal">M[A]</code>. For instance, <code class="literal">unit(A)</code> for a <code class="literal">List</code> will be <code class="literal">== List[A]</code> and <code class="literal">unit(A)</code>, where a is an Option <code class="literal">== Option[A]</code>. In Scala, you don't need to have unit; this is optional. To have a monad in Scala, you need to have map and <code class="literal">flatMap</code> implemented.</p><p>Working with Monads will make you write a little bit more code than before. However, you will get a way better API, which will be easier to reuse and your potential complexity will be managed, because you won't need to write a complex code full of <code class="literal">if</code> and for loops. The possibilities are expressed through the types, and the compiler can check it for you. Let us see a simple monad example in Scala language:</p></div><div class="section" title="Option Monad in Scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>Option Monad in Scala</h2></div></div></div><p>We will see option Monad in Scala as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val a:Option[Int] = Some(1)</strong></span>
<span class="strong"><strong>a: Option[Int] = Some(1)</strong></span>
<span class="strong"><strong>scala&gt; a.get</strong></span>
<span class="strong"><strong>res0: Int = 1</strong></span>
<span class="strong"><strong>scala&gt; val b:Option[Int] = None</strong></span>
<span class="strong"><strong>b: Option[Int] = None</strong></span>
<span class="strong"><strong>scala&gt; b.get</strong></span>
<span class="strong"><strong>java.util.NoSuchElementException: None.get</strong></span>
<span class="strong"><strong>  at scala.None$.get(Option.scala:347)</strong></span>
<span class="strong"><strong>  at scala.None$.get(Option.scala:345)</strong></span>
<span class="strong"><strong>  ... 32 elided</strong></span>
<span class="strong"><strong>scala&gt; b.getOrElse(0)</strong></span>
<span class="strong"><strong>res2: Int = 0</strong></span>
<span class="strong"><strong>scala&gt; a == b</strong></span>
<span class="strong"><strong>res3: Boolean = false</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
</pre><p>In Haskell, this also known as the Maybe monad. Option means optional value, because we are not 100% sure if the value will be present. In order to express a value, we use the <code class="literal">Some</code> type, and in order to express the lack of value, we use none. Option Monads are great, they make your code more explicit, because a method might receive or return an option, which means you are explicitly saying this could be null. However, this technique is not only more expressive but also safer, since you won't get a null pointer, because you have a container around the value. Although, if you call the method <code class="literal">get</code> in <code class="literal">Option</code> and it is none, you will get a <code class="literal">NoSuchelementException</code>. In order to fix this, you can use the method <code class="literal">getOrElse</code>, and you can supply a fallback value which will be used in the case of none. Alright, but you might be wondering where the <code class="literal">flatMap</code> method is. Don't worry, Scala implements this method for us into the <code class="literal">Option</code> abstraction, so you can  use it with no issues.</p><pre class="programlisting">
<span class="strong"><strong>scala&gt; val c = Some("one")</strong></span>
<span class="strong"><strong>c: Some[String] = Some(one)</strong></span>
<span class="strong"><strong>scala&gt; c.flatMap( s =&gt; Some(s.toUpperCase) )</strong></span>
<span class="strong"><strong>res6: Option[String] = Some(ONE)</strong></span>
</pre><p>The Scala REPL can perform autocomplete for you. If you type <span class="strong"><strong>C</strong></span> + <span class="strong"><strong>Tab</strong></span>, you will see all the available methods for the <code class="literal">Some</code> class. The <code class="literal">map</code> function is available for you to use, and as I said before, there is no unit function in Scala whatsoever. However, it is not wrong if you add in your APIs.</p></div><div class="section" title="A list of all methods using the Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>A list of all methods using the Scala REPL</h2></div></div></div><p>Following are the list of all methods using the Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val c = Some("one")</strong></span>
<span class="strong"><strong>c: Some[String] = Some(one)</strong></span>
<span class="strong"><strong>scala&gt; c.</strong></span>
<span class="strong"><strong>++             count       foreach              iterator     productArity   seq         toBuffer             unzip          </strong></span>
<span class="strong"><strong>++:            drop        genericBuilder       last         productElement size        toIndexedSeq         unzip3         </strong></span>
<span class="strong"><strong>/:             dropRight   get                  lastOption   productIterator slice      toIterable           view           </strong></span>
<span class="strong"><strong>:\             dropWhile   getOrElse            map          productPrefix  sliding     toIterator           withFilter     </strong></span>
<span class="strong"><strong>WithFilter     equals      groupBy              max          &#13;
reduce         span        toLeft               x              </strong></span>
<span class="strong"><strong>addString      exists      grouped              maxBy        &#13;
reduceLeft     splitAt     toList               zip           </strong></span>
<span class="strong"><strong>aggregate      filter      hasDefiniteSize      min          reduceLeftOption stringPrefix   toMap           zipAll         </strong></span>
<span class="strong"><strong>canEqual       filterNot   hashCode             minBy        reduceOption   sum         toRight              zipWithIndex   </strong></span>
<span class="strong"><strong>collect        find        head                 mkString     reduceRight    tail        toSeq                </strong></span>
<span class="strong"><strong>collectFirst   &#13;
flatMap        headOption  nonEmpty             reduceRightOption   tails          toSet       </strong></span>
<span class="strong"><strong>companion            flatten     &#13;
init           orElse      repr                 take           &#13;
toStream       </strong></span>
<span class="strong"><strong>contains    fold                 inits                orNull         sameElements takeRight           toString                       </strong></span>
<span class="strong"><strong>copy           foldLeft    isDefined            par          &#13;
scan           takeWhile   toTraversable        </strong></span>
<span class="strong"><strong>copyToArray    foldRight      isEmpty     partition            scanLeft            &#13;
to             toVector    </strong></span>
<span class="strong"><strong>copyToBuffer         forall      isTraversableAgain product scanRight            toArray        &#13;
transpose                      </strong></span>
<span class="strong"><strong>scala&gt; c</strong></span>
</pre></div></div>
<div class="section" title="Scala class, traits, and OO programming" id="aid-PNV61"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Scala class, traits, and OO programming</h1></div></div></div><p>As a hybrid post-functional language, Scala allows you to write OO code and create classes as well. Right now we will learn how to create classes and functions inside classes, and also how to work with traits, which are similar to Java interfaces in concept but way more powerful in practice.</p><div class="section" title="A simple Scala class in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>A simple Scala class in Scala REPL</h2></div></div></div><p>We will see a simple Scala class in Scala REPL as follows:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; class Calculator {</strong></span>
<span class="strong"><strong>     |    def add(a: Int, b: Int): Int = a + b</strong></span>
<span class="strong"><strong>     |    def multiply(n: Int, f: Int): Int = n * f</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class Calculator</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val c = new Calculator</strong></span>
<span class="strong"><strong>c: Calculator = Calculator@380fb434</strong></span>
<span class="strong"><strong>scala&gt; c.add(1,2)</strong></span>
<span class="strong"><strong>res0: Int = 3</strong></span>
<span class="strong"><strong>scala&gt; c.multiply(3,2)</strong></span>
<span class="strong"><strong>res1: Int = 6</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>At first glance, the preceding code looks like Java. But let's add constructors, getters, and setters, and then you can see how much we can accomplish with just a few lines of code.</p></div><div class="section" title="Scala plain old Java object in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>Scala plain old Java object in Scala REPL</h2></div></div></div><p>Following is a Scala plain old Java object in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; class Person(</strong></span>
<span class="strong"><strong>     |   @scala.beans.BeanProperty var name:String = "",</strong></span>
<span class="strong"><strong>     |   @scala.beans.BeanProperty var age:Int = 0</strong></span>
<span class="strong"><strong>     | ){</strong></span>
<span class="strong"><strong>     |    name = name.toUpperCase</strong></span>
<span class="strong"><strong>     |    override def toString = "name: " + name + " age: " + age</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class Person</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val p  = new Person("Diego",31)</strong></span>
<span class="strong"><strong>p: Person = name: DIEGO age: 31</strong></span>
<span class="strong"><strong>scala&gt; val p1 = new Person(age = 31, name = "Diego")</strong></span>
<span class="strong"><strong>p1: Person = name: DIEGO age: 31</strong></span>
<span class="strong"><strong>scala&gt; p.getAge</strong></span>
<span class="strong"><strong>res0: Int = 31</strong></span>
<span class="strong"><strong>scala&gt; p1.getName</strong></span>
<span class="strong"><strong>res1: String = DIEGO</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
</pre><p>Constructors in Scala are just lines of code. You might realize that we get the <code class="literal">name</code> variable, and apply a function to change the given name to upper case in the preceding example. If you want, you can put as many lines as you want, and you can perform as many computations as you wish.</p><p>On this same code, we perform method overriding as well, because we override the <code class="literal">toString</code> method. In Scala, in order to do an override, you need to use the <code class="literal">override</code> operator in front of the function definition.</p><p>We just wrote a <span class="strong"><strong>Plain Old Java Object</strong></span> (<span class="strong"><strong>POJO</strong></span>) with very few lines of code in Scala. Scala has a special annotation called <code class="literal">@scala.beans.BeanProperty</code>, which generates the getter and setter method for you. This is very useful, and saves lots of lines of code. However, the target needs to be public; you can't a apply <code class="literal">BeanProperty</code> annotation on top of a private <code class="literal">var</code> or <code class="literal">val</code> object.</p></div><div class="section" title="Person class in Java"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Person class in Java</h2></div></div></div><p>Following is a Person class in Java:</p><pre class="programlisting">    package scalabook.javacode.chap1; &#13;
 &#13;
    public class JavaPerson { &#13;
   &#13;
      private String name; &#13;
      private Integer age; &#13;
   &#13;
      public JavaPerson() {} &#13;
 &#13;
      public JavaPerson(String name, Integer age) { &#13;
        super(); &#13;
        this.name = name; &#13;
        this.age = age; &#13;
      } &#13;
 &#13;
      public JavaPerson(String name) { &#13;
        super(); &#13;
        this.name = name; &#13;
      } &#13;
 &#13;
      public JavaPerson(Integer age) { &#13;
        super(); &#13;
        this.age = age; &#13;
      } &#13;
     &#13;
      public Integer getAge() { &#13;
        return age; &#13;
      } &#13;
 &#13;
      public void setAge(Integer age) { &#13;
        this.age = age; &#13;
      } &#13;
 &#13;
      public String getName() { &#13;
        return name; &#13;
      } &#13;
 &#13;
      public void setName(String name) { &#13;
        this.name = name; &#13;
      } &#13;
   &#13;
    } &#13;
</pre></div></div>
<div class="section" title="Traits and inheritance"><div class="titlepage" id="aid-QMFO2"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Traits and inheritance</h1></div></div></div><p>It's possible to do inheritance in Scala as well. For such a task, you use the operator <code class="literal">extend</code> after the class definition. Scala just allows you to extend one class, just like Java. Java does not allow multiple inheritance like C++. However, Scala allows it by using the Mixing technique with traits. Scala traits are like Java interface, but you can also add concrete code, and you are allowed to have as many traits as you want in your code.</p><div class="section" title="Scala inheritance code in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>Scala inheritance code in Scala REPL</h2></div></div></div><p>Following is a Scala inheritance code in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; class Person(</strong></span>
<span class="strong"><strong>     |   @scala.beans.BeanProperty var name:String = "",</strong></span>
<span class="strong"><strong>     |   @scala.beans.BeanProperty var age:Int = 0</strong></span>
<span class="strong"><strong>     | ){</strong></span>
<span class="strong"><strong>     |    name = name.toUpperCase</strong></span>
<span class="strong"><strong>     |    override def toString = "name: " + name + " age: " + age</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class Person</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; class LowerCasePerson(name:String,age:Int) extends Person(name,age) {</strong></span>
<span class="strong"><strong>     |    setName(name.toLowerCase)</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class LowerCasePerson</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val p  = new LowerCasePerson("DIEGO PACHECO",31)</strong></span>
<span class="strong"><strong>p: LowerCasePerson = name: diego pacheco age: 31</strong></span>
<span class="strong"><strong>scala&gt; p.getName</strong></span>
<span class="strong"><strong>res0: String = diego pacheco</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
</pre><p>Scala does not make constructors inheritance like Java. So you need to rewrite the constructors and pass the values through a super class. All code inside the class will be the secondary constructor. All code inside parentheses <code class="literal">()</code> in the class definition will be the primary constructor. It's possible to have multiple constructors using the <code class="literal">this</code> operator. For this particular implementation, we changed the default behavior and added new constructor code in order to make the given name lower case, instead of the default uppercase defined by the <code class="literal">Person</code> superclass.</p></div><div class="section" title="Scala traits sample code in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>Scala traits sample code in Scala REPL</h2></div></div></div><p>Following is a Scala traits sample code in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; trait Car</strong></span>
<span class="strong"><strong>defined trait Car</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; trait SportCar {</strong></span>
<span class="strong"><strong>     |    val brand:String </strong></span>
<span class="strong"><strong>     |    def run():String = "Rghhhhh Rghhhhh Rghhhhh...."</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined trait SportCar</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; trait Printable {</strong></span>
<span class="strong"><strong>     |    def printIt:Unit </strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined trait Printable</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; class BMW extends Car with SportCar with Printable{</strong></span>
<span class="strong"><strong>     |    override val brand = "BMW"</strong></span>
<span class="strong"><strong>     |    override def printIt:Unit = println(brand + " does " + run() )</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class BMW</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val x1 = new BMW</strong></span>
<span class="strong"><strong>x1: BMW = BMW@22a71081</strong></span>
<span class="strong"><strong>scala&gt; x1.printIt</strong></span>
<span class="strong"><strong>BMW does Rghhhhh Rghhhhh Rghhhhh....</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>In the preceding code, we created multiple traits. One is called Car, which is the mother trait. Traits support inheritance as well, and we have it with the <code class="literal">SportCar</code> trait which extends from the <code class="literal">Car</code> trait. The <code class="literal">SportCar</code> trait demands a variable called brand, and defines a concrete implementation of the function run. Finally, we have a class called <code class="literal">BMW</code> which extends from multiple traits -- this technique is called <span class="strong"><strong>mixing.</strong></span>
</p></div><div class="section" title="Scala traits using variable mixing technique at Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec40"/>Scala traits using variable mixing technique at Scala REPL</h2></div></div></div><p>Following is a Scala traits using variable mixing technique at Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; trait SportCar {</strong></span>
<span class="strong"><strong>     |    def run():String = "Rghhhhh Rghhhhh Rghhhhh...."</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined trait SportCar</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val bmw = new Object with SportCar</strong></span>
<span class="strong"><strong>bmw: SportCar = $anon$1@ed17bee</strong></span>
<span class="strong"><strong>scala&gt; bmw.run</strong></span>
<span class="strong"><strong>res0: String = Rghhhhh Rghhhhh Rghhhhh....</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Scala is a very powerful language indeed. It's possible to add traits to a variable at runtime. When you define a variable, you can use the <code class="literal">with</code> operator after the assignment. This is a very useful feature, because it makes it easier to make function composition. You can have multiple specialized traits and just add them in your variables as you need them.</p><p>Scala allows you to create the <code class="literal">type</code> alias as well, this is a very simple technique which will increase the readability of your code. It's just a simple alias.</p></div><div class="section" title="Scala type alias sample in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec41"/>Scala type alias sample in Scala REPL</h2></div></div></div><p>Following is a Scala type alias sample in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; type Email = String</strong></span>
<span class="strong"><strong>defined type alias Email</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val e = new Email("me@mail.com.br")</strong></span>
<span class="strong"><strong>e: String = me@mail.com.br</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>When you are coding with Scala, it is highly recommended that you use the <code class="literal">type</code> alias and traits for everything, because that way you will get more advantages with your compiler, and you will avoid writing unnecessary code and unnecessary unit tests.</p></div></div>
<div class="section" title="Case classes" id="aid-RL0A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Case classes</h1></div></div></div><p>We are not done yet in terms of the OO features in Scala; there is another very interesting way to work with classes in Scala: the so-called case classes. Case classes are great because you can have a class with way less number of lines of code and case classes can be part of a Pattern Matcher.</p><div class="section" title="Scala case classes feature in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec42"/>Scala case classes feature in Scala REPL</h2></div></div></div><p>Following is a Scala case classes feature in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; case class Person(name: String, age: Int)</strong></span>
<span class="strong"><strong>defined class Person</strong></span>
<span class="strong"><strong>scala&gt; val p = Person("Diego",31)</strong></span>
<span class="strong"><strong>p: Person = Person(Diego,31)</strong></span>
<span class="strong"><strong>scala&gt; val p2 = Person("Diego",32)</strong></span>
<span class="strong"><strong>p2: Person = Person(Diego,32)</strong></span>
<span class="strong"><strong>scala&gt; p.name</strong></span>
<span class="strong"><strong>res0: String = Diego</strong></span>
<span class="strong"><strong>scala&gt; p.age</strong></span>
<span class="strong"><strong>res1: Int = 31</strong></span>
<span class="strong"><strong>scala&gt; p == p </strong></span>
<span class="strong"><strong>res2: Boolean = true</strong></span>
<span class="strong"><strong>scala&gt; p.toString</strong></span>
<span class="strong"><strong>res3: String = Person(Diego,31)</strong></span>
<span class="strong"><strong>scala&gt; p.hashCode</strong></span>
<span class="strong"><strong>res4: Int = 668670772</strong></span>
<span class="strong"><strong>scala&gt; p.equals(p2)</strong></span>
<span class="strong"><strong>res5: Boolean = false</strong></span>
<span class="strong"><strong>scala&gt; p.equals(p)</strong></span>
<span class="strong"><strong>res6: Boolean = true</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>This is the Scala way to work with classes. Because this is so much easier and compact, you pretty much create a class with one line of code, and you can have the <code class="literal">equals</code> and <code class="literal">hashcode</code> methods for free.</p></div></div>
<div class="section" title="Pattern Matcher" id="aid-SJGS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec22"/>Pattern Matcher</h1></div></div></div><p>When you code in Java, you can use a Switch statement. However, in Scala, we have a more powerful feature called Pattern Matcher, which is a kind of switch but on steroids.</p><div class="section" title="Simple Pattern Matcher in Scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec43"/>Simple Pattern Matcher in Scala</h2></div></div></div><p>Following is a Simple Pattern Matcher in Scala:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; def resolve(choice:Int):String = choice match {</strong></span>
<span class="strong"><strong>     |     case 1 =&gt; "yes"</strong></span>
<span class="strong"><strong>     |     case 0 =&gt; "no"</strong></span>
<span class="strong"><strong>     |     case _ =&gt; throw new IllegalArgumentException("Valid arguments are: 0 or 1. Your arg is: 
           " + choice)</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>resolve: (choice: Int)String</strong></span>
<span class="strong"><strong>scala&gt; println(resolve(0))</strong></span>
<span class="strong"><strong>no</strong></span>
<span class="strong"><strong>scala&gt; println(resolve(1))</strong></span>
<span class="strong"><strong>yes</strong></span>
<span class="strong"><strong>scala&gt; try {</strong></span>
<span class="strong"><strong>     |   println(resolve(33))</strong></span>
<span class="strong"><strong>     | } catch{</strong></span>
<span class="strong"><strong>     |   case e:Exception =&gt; println("Something Went Worng. EX: " + e)</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>Something Went Worng. EX: java.lang.IllegalArgumentException: Valid arguments are: 0 or 1. Your arg is: 33</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Scala uses Pattern Matcher for error handling. Java does not have Pattern Matcher like Scala. It's similar to a switch statement; however, Pattern Matcher can be used in a method return statement as you can see in the preceding code. Scala developers can specify a special operator called <code class="literal">_</code> (Underscore), which allows you to specify anything in the Pattern Matcher scope. This behavior is similar to <code class="literal">else</code> in an <code class="literal">if</code> conditional. However, in Scala, you can use <code class="literal">_</code> in several places, and not only as the otherwise clause, like in Java switch.</p><p>Error handling in Scala is similar to error handling in Java. We use try...catch blocks. The main difference is that you have to use Pattern Matcher in Scala, which is great because it adds more flexibility to your code. Pattern Matcher in Scala can operate against many data structures like case classes, collections, integers, and strings.</p><p>The preceding code is pretty simple and straightforward. Next we will see a more complex and advanced code using the Scala Pattern Matcher feature.</p></div><div class="section" title="Advanced pattern matcher in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec44"/>Advanced pattern matcher in Scala REPL</h2></div></div></div><p>Following is an Advanced Pattern Matcher using Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; def factorial(n:Int):Int = n match {</strong></span>
<span class="strong"><strong>     |     case 0 =&gt; 1</strong></span>
<span class="strong"><strong>     |     case n =&gt; n * factorial(n - 1)</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>factorial: (n: Int)Int</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println(factorial(3))</strong></span>
<span class="strong"><strong>6</strong></span>
<span class="strong"><strong>scala&gt; println(factorial(6))</strong></span>
<span class="strong"><strong>720</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
</pre><p>Pattern Matcher can be used in a very functional way. For instance, in the preceding code, we use the Pattern Matcher for recursion. There is no need to create a variable to store the result, we can put the Pattern Matcher straight to the function return, which is very convenient and saves lots of lines of code.</p></div><div class="section" title="Advanced complex pattern matcher in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec45"/>Advanced complex pattern matcher in Scala REPL</h2></div></div></div><p>Following is an Advanced complex Pattern Matcher using Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; trait Color</strong></span>
<span class="strong"><strong>defined trait Color</strong></span>
<span class="strong"><strong>scala&gt; case class Red(saturation: Int)   extends Color</strong></span>
<span class="strong"><strong>defined class Red</strong></span>
<span class="strong"><strong>scala&gt; case class Green(saturation: Int) extends Color</strong></span>
<span class="strong"><strong>defined class Green</strong></span>
<span class="strong"><strong>scala&gt; case class Blue(saturation: Int)  extends Color</strong></span>
<span class="strong"><strong>defined class Blue</strong></span>
<span class="strong"><strong>scala&gt; def matcher(arg:Any): String = arg match {</strong></span>
<span class="strong"><strong>     |   case "Scala"                            =&gt; "A Awesome Language"</strong></span>
<span class="strong"><strong>     |   case x: Int                               =&gt; "An Int with value " + x</strong></span>
<span class="strong"><strong>     |   case Red(100)                        =&gt; "Red sat 100"</strong></span>
<span class="strong"><strong>     |   case Red(_)                            =&gt; "Any kind of RED sat"</strong></span>
<span class="strong"><strong>     |   case Green(s) if s == 233       =&gt; "Green sat 233"</strong></span>
<span class="strong"><strong>     |   case Green(s)                          =&gt; "Green sat " + s</strong></span>
<span class="strong"><strong>     |   case c: Color                           =&gt; "Some Color: " + c</strong></span>
<span class="strong"><strong>     |   case w: Any                            =&gt; "Whatever: " + w</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>matcher: (arg: Any)String</strong></span>
<span class="strong"><strong>scala&gt; println(matcher("Scala"))</strong></span>
<span class="strong"><strong>A Awesome Language</strong></span>
<span class="strong"><strong>scala&gt; println(matcher(1))</strong></span>
<span class="strong"><strong>An Int with value 1</strong></span>
<span class="strong"><strong>scala&gt; println(matcher(Red(100)))</strong></span>
<span class="strong"><strong>Red sat 100</strong></span>
<span class="strong"><strong>scala&gt; println(matcher(Red(160)))</strong></span>
<span class="strong"><strong>Any kind of RED sat</strong></span>
<span class="strong"><strong>scala&gt; println(matcher(Green(160)))</strong></span>
<span class="strong"><strong>Green sat 160</strong></span>
<span class="strong"><strong>scala&gt; println(matcher(Green(233)))</strong></span>
<span class="strong"><strong>Green sat 233</strong></span>
<span class="strong"><strong>scala&gt; println(matcher(Blue(111)))</strong></span>
<span class="strong"><strong>Some Color: Blue(111)</strong></span>
<span class="strong"><strong>scala&gt; println(matcher(false))</strong></span>
<span class="strong"><strong>Whatever: false</strong></span>
<span class="strong"><strong>scala&gt; println(matcher(new Object))</strong></span>
<span class="strong"><strong>Whatever: java.lang.Object@b56c222</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>The Scala Pattern Matcher is really amazing. We just used an <code class="literal">if</code> statement in the middle of the Pattern Matcher, and also <code class="literal">_</code> to specify a match for any kind of red value. We also used case classes in the middle of the Pattern Matcher expressions.</p></div></div>
<div class="section" title="Partial functions" id="aid-TI1E1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec23"/>Partial functions</h1></div></div></div><p>Partial functions are great for function composition. They can operate with case statements as we just learned from Pattern Matcher. Partial functions are great in the sense of function composition. They allow us to define a function in steps. Scala frameworks and libraries use this feature a lot to create abstractions and callback mechanisms. It's also possible to check if a partial function is being supplied or not.</p><p>Partial functions are predictable, because the caller can check beforehand if the value will be applied to the partial function or not. Partial function can be coded with or without case-like statements.</p><div class="section" title="Simple Partial function in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec46"/>Simple Partial function in Scala REPL</h2></div></div></div><p>Following is a simple Partial function using Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val positiveNumber = new PartialFunction[Int, Int] {</strong></span>
<span class="strong"><strong>     |   def apply(n:Int) = n / n</strong></span>
<span class="strong"><strong>     |   def isDefinedAt(n:Int) = n != 0</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>positiveNumber: PartialFunction[Int,Int] = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println( positiveNumber.isDefinedAt(6) )</strong></span>
<span class="strong"><strong>true</strong></span>
<span class="strong"><strong>scala&gt; println( positiveNumber.isDefinedAt(0) )</strong></span>
<span class="strong"><strong>false</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println( positiveNumber(6) ) </strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>scala&gt; println( positiveNumber(0) ) </strong></span>
<span class="strong"><strong>  java.lang.ArithmeticException: / by zero</strong></span>
<span class="strong"><strong>  at $anon$1.apply$mcII$sp(&lt;console&gt;:12)</strong></span>
<span class="strong"><strong>  ... 32 elided</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Partial functions are Scala classes. They have some methods you need to provide, for instance, <code class="literal">apply</code> and <code class="literal">isDefinedAt</code>. The function <code class="literal">isDefinedAt</code> is used by the caller to check if the <code class="literal">PartialFunction</code> will accept and operate with the value supplied. The <code class="literal">apply</code> function will do the work when the <code class="literal">PartialFunction</code> is executed by Scala.</p></div><div class="section" title="Scala PartialFunction without OO using case statements in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec47"/>Scala PartialFunction without OO using case statements in Scala REPL</h2></div></div></div><p>Following is a Scala PartialFunction without OO using case statements in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val positiveNumber:PartialFunction[Int, Int]  =  {</strong></span>
<span class="strong"><strong>     |   case n: Int if n != 0 =&gt; n / n</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>positiveNumber: PartialFunction[Int,Int] = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println( positiveNumber.isDefinedAt(6) )</strong></span>
<span class="strong"><strong>true</strong></span>
<span class="strong"><strong>scala&gt; println( positiveNumber.isDefinedAt(0) )</strong></span>
<span class="strong"><strong>false</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println( positiveNumber(6) ) </strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>scala&gt; println( positiveNumber(0) ) </strong></span>
<span class="strong"><strong>scala.MatchError: 0 (of class java.lang.Integer)</strong></span>
<span class="strong"><strong>  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:253)</strong></span>
<span class="strong"><strong>  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:251)</strong></span>
<span class="strong"><strong>  at $anonfun$1.applyOrElse(&lt;console&gt;:11)</strong></span>
<span class="strong"><strong>  at $anonfun$1.applyOrElse(&lt;console&gt;:11)</strong></span>
<span class="strong"><strong>  at scala.runtime.AbstractPartialFunction$mcII$sp.apply$mcII$sp&#13;
  (AbstractPartialFunction.scala:36)</strong></span>
<span class="strong"><strong>  ... 32 elided</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Scala was a more fluent way to work with <code class="literal">PartialFunction</code> using the <code class="literal">case</code> statements. When you use the <code class="literal">case</code> statements, you don't need to supply the <code class="literal">apply</code> and <code class="literal">isDefinedAt</code> functions, since the Pattern Matcher takes care of that.</p></div><div class="section" title="PartialFunction composition in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec48"/>PartialFunction composition in Scala REPL</h2></div></div></div><p>Following is a PartialFunction composition in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; val even:PartialFunction[Int, String] = {</strong></span>
<span class="strong"><strong>     |   case i if i%2 == 0 =&gt; "even"</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>even: PartialFunction[Int,String] = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val odd:PartialFunction[Int, String] = { case _ =&gt; "odd"}</strong></span>
<span class="strong"><strong>odd: PartialFunction[Int,String] = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val evenOrOdd:(Int =&gt; String) = even orElse odd</strong></span>
<span class="strong"><strong>evenOrOdd: Int =&gt; String = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println( evenOrOdd(1) == "odd"  )</strong></span>
<span class="strong"><strong>true</strong></span>
<span class="strong"><strong>scala&gt; println( evenOrOdd(2) == "even" )</strong></span>
<span class="strong"><strong>true</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>Scala allows us to compose as many <code class="literal">PartialFunctions</code> as we want. <code class="literal">PartialFunction</code> composition happens with the <code class="literal">orElse</code> function. In the preceding code, we defined an immutable variable called <code class="literal">even</code>, which verifies even numbers. Secondly, we created a second immutable variable called <code class="literal">odd</code>, which checks for odd numbers. Then we did the composition, and created a third <code class="literal">PartialFunction</code> called <code class="literal">evenOrOdd</code> with compose even and odd using the <code class="literal">orElse</code> operator.</p></div></div>
<div class="section" title="Package objects" id="aid-UGI01"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec24"/>Package objects</h1></div></div></div><p>Scala has packages like Java. However, Scala packages are also objects, and you can have code inside a package. Java does not have the same power as Scala in terms of packages. If you add code to a package, it will be available to all classes and functions within that package.</p><div class="section" title="package.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec49"/>package.scala</h2></div></div></div><p>Your <code class="literal">package.scala</code> file should contain the following code</p><pre class="programlisting">    package com.packait.scala.book &#13;
 &#13;
    package object commons { &#13;
   &#13;
      val PI = 3.1415926 &#13;
   &#13;
      object constraintsHolder { &#13;
        val ODD = "Odd" &#13;
        val EVEN = "Even" &#13;
      } &#13;
   &#13;
      def isOdd(n:Int):String  = if (n%2==0) constraintsHolder.ODD else &#13;
      null   &#13;
 &#13;
      def isEven(n:Int):String = if (n%2!=0) constraintsHolder.EVEN &#13;
      else null &#13;
   &#13;
      def show(s:String) = println(s) &#13;
   &#13;
    } &#13;
</pre><p>This is the Scala package object. There is this special token called <code class="literal">package</code> object which you use to define common code to all classes, objects, and functions that are defined inside this package or sub-package. For this case, we define a value of PI as a constant and also one object holder containing the String values for <code class="literal">Odd</code> and <code class="literal">Even</code>. There are also three helper functions, which can and will be used by the classes inside this package.</p></div><div class="section" title="MainApp.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec50"/>MainApp.scala</h2></div></div></div><p>Your <code class="literal">MainApp.scala</code> file should contain the following code</p><pre class="programlisting">    package com.packait.scala.book.commons &#13;
 &#13;
    object MainApp extends App { &#13;
   &#13;
      show("PI is: " + PI) &#13;
      show(constraintsHolder.getClass.toString()) &#13;
   &#13;
      show( isOdd(2) ) &#13;
      show( isOdd(6) ) &#13;
 &#13;
      show( isEven(3) ) &#13;
      show( isEven(7) ) &#13;
   &#13;
    } &#13;
</pre><p>As you can see in the preceding code, this new object is placed in the package: <code class="literal">com.packait.scala.book.commons</code>. Another interesting thing is the fact that we don't have any import statement here because of the <code class="literal">package</code> object feature. When you compile and run this program, you will see the following output:</p><pre class="programlisting">
<span class="strong"><strong>PI is: 3.1415926</strong></span>
<span class="strong"><strong>class com.packait.scala.book.commons.package$constraintsHolder$</strong></span>
<span class="strong"><strong>Odd</strong></span>
<span class="strong"><strong>Odd</strong></span>
<span class="strong"><strong>Even</strong></span>
<span class="strong"><strong>Even</strong></span>
</pre><p>Scala uses the <code class="literal">Package</code> object a great deal providing lots of shortcuts and convenience for all Scala developers. The following is the Scala <code class="literal">package</code> object definition:</p><pre class="programlisting">    /*                     __                                               &#13;
    *\ &#13;
    **     ________ ___   / /  ___     Scala API                            &#13;
    ** &#13;
    **    / __/ __// _ | / /  / _ |    (c) 2003-2013, LAMP/EPFL             &#13;
    ** &#13;
    **  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               &#13;
    ** &#13;
    ** /____/\___/_/ |_/____/_/ | |                                         &#13;
    ** &#13;
    **                          |/                                          &#13;
    ** &#13;
    \*                                                                      &#13;
    */ &#13;
 &#13;
    /** &#13;
     * Core Scala types. They are always available without an explicit &#13;
     import. &#13;
     * @contentDiagram hideNodes "scala.Serializable" &#13;
     */ &#13;
    package object scala { &#13;
      type Throwable = java.lang.Throwable &#13;
      type Exception = java.lang.Exception &#13;
      type Error     = java.lang.Error &#13;
 &#13;
      type RuntimeException                = java.lang.RuntimeException &#13;
      type NullPointerException            = &#13;
      java.lang.NullPointerException &#13;
      type ClassCastException              = &#13;
      java.lang.ClassCastException &#13;
      type IndexOutOfBoundsException       = &#13;
      java.lang.IndexOutOfBoundsException &#13;
      type ArrayIndexOutOfBoundsException  = &#13;
      java.lang.ArrayIndexOutOfBoundsException &#13;
      type StringIndexOutOfBoundsException = &#13;
      java.lang.StringIndexOutOfBoundsException &#13;
      type UnsupportedOperationException   = &#13;
      java.lang.UnsupportedOperationException &#13;
      type IllegalArgumentException        = &#13;
      java.lang.IllegalArgumentException &#13;
      type NoSuchElementException          = &#13;
      java.util.NoSuchElementException &#13;
      type NumberFormatException           = &#13;
      java.lang.NumberFormatException &#13;
      type AbstractMethodError             = &#13;
      java.lang.AbstractMethodError &#13;
      type InterruptedException            = &#13;
      java.lang.InterruptedException &#13;
 &#13;
      // A dummy used by the specialization annotation. &#13;
      val AnyRef = new Specializable { &#13;
        override def toString = "object AnyRef" &#13;
      } &#13;
 &#13;
      type TraversableOnce[+A] = scala.collection.TraversableOnce[A] &#13;
 &#13;
      type Traversable[+A] = scala.collection.Traversable[A] &#13;
      val Traversable = scala.collection.Traversable &#13;
 &#13;
      type Iterable[+A] = scala.collection.Iterable[A] &#13;
      val Iterable = scala.collection.Iterable &#13;
 &#13;
      type Seq[+A] = scala.collection.Seq[A] &#13;
      val Seq = scala.collection.Seq &#13;
 &#13;
      type IndexedSeq[+A] = scala.collection.IndexedSeq[A] &#13;
      val IndexedSeq = scala.collection.IndexedSeq &#13;
 &#13;
      type Iterator[+A] = scala.collection.Iterator[A] &#13;
      val Iterator = scala.collection.Iterator &#13;
 &#13;
      type BufferedIterator[+A] = scala.collection.BufferedIterator[A] &#13;
 &#13;
      type List[+A] = scala.collection.immutable.List[A] &#13;
      val List = scala.collection.immutable.List &#13;
 &#13;
      val Nil = scala.collection.immutable.Nil &#13;
 &#13;
      type ::[A] = scala.collection.immutable.::[A] &#13;
      val :: = scala.collection.immutable.:: &#13;
 &#13;
      val +: = scala.collection.+: &#13;
      val :+ = scala.collection.:+ &#13;
     &#13;
      type Stream[+A] = scala.collection.immutable.Stream[A] &#13;
      val Stream = scala.collection.immutable.Stream &#13;
      val #:: = scala.collection.immutable.Stream.#:: &#13;
 &#13;
      type Vector[+A] = scala.collection.immutable.Vector[A] &#13;
      val Vector = scala.collection.immutable.Vector &#13;
 &#13;
      type StringBuilder = scala.collection.mutable.StringBuilder &#13;
      val StringBuilder = scala.collection.mutable.StringBuilder &#13;
 &#13;
      type Range = scala.collection.immutable.Range &#13;
      val Range = scala.collection.immutable.Range &#13;
 &#13;
      // Numeric types which were moved into scala.math.* &#13;
 &#13;
      type BigDecimal = scala.math.BigDecimal &#13;
      val BigDecimal = scala.math.BigDecimal &#13;
 &#13;
      type BigInt = scala.math.BigInt &#13;
      val BigInt = scala.math.BigInt &#13;
 &#13;
      type Equiv[T] = scala.math.Equiv[T] &#13;
      val Equiv = scala.math.Equiv &#13;
 &#13;
      type Fractional[T] = scala.math.Fractional[T] &#13;
      val Fractional = scala.math.Fractional &#13;
 &#13;
      type Integral[T] = scala.math.Integral[T] &#13;
      val Integral = scala.math.Integral &#13;
 &#13;
      type Numeric[T] = scala.math.Numeric[T] &#13;
      val Numeric = scala.math.Numeric &#13;
 &#13;
      type Ordered[T] = scala.math.Ordered[T] &#13;
      val Ordered = scala.math.Ordered &#13;
 &#13;
      type Ordering[T] = scala.math.Ordering[T] &#13;
      val Ordering = scala.math.Ordering &#13;
 &#13;
      type PartialOrdering[T] = scala.math.PartialOrdering[T] &#13;
      type PartiallyOrdered[T] = scala.math.PartiallyOrdered[T] &#13;
 &#13;
      type Either[+A, +B] = scala.util.Either[A, B] &#13;
      val Either = scala.util.Either &#13;
 &#13;
      type Left[+A, +B] = scala.util.Left[A, B] &#13;
      val Left = scala.util.Left &#13;
 &#13;
      type Right[+A, +B] = scala.util.Right[A, B] &#13;
      val Right = scala.util.Right &#13;
 &#13;
      // Annotations which we might move to annotation.* &#13;
    /* &#13;
      type SerialVersionUID = annotation.SerialVersionUID &#13;
      type deprecated = annotation.deprecated &#13;
      type deprecatedName = annotation.deprecatedName &#13;
      type inline = annotation.inline &#13;
      type native = annotation.native &#13;
      type noinline = annotation.noinline &#13;
      type remote = annotation.remote &#13;
      type specialized = annotation.specialized &#13;
      type transient = annotation.transient &#13;
      type throws  = annotation.throws &#13;
      type unchecked = annotation.unchecked.unchecked &#13;
      type volatile = annotation.volatile &#13;
      */ &#13;
    } &#13;
</pre></div></div>
<div class="section" title="Functions" id="aid-VF2I1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec25"/>Functions</h1></div></div></div><p>Like any great FP language, Scala has lots of built-in functions. These functions make our code more fluent and functional; now it's time to learn some of these functions:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; // Creates the numbers 1,2,3,4,5 and them multiply they by 2 and creates a new Vector</strong></span>
<span class="strong"><strong>scala&gt; println ((1 to 5).map(_*2))   </strong></span>
<span class="strong"><strong>Vector(2, 4, 6, 8, 10)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Creates 1,2,3 and sum them all with each orher and return the total</strong></span>
<span class="strong"><strong>scala&gt; println ( (1 to 3).reduceLeft(_+_) )</strong></span>
<span class="strong"><strong>6</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Creates 1,2,3 and multiply each number by it self and return a Vector</strong></span>
<span class="strong"><strong>scala&gt; println ( (1 to 3).map( x=&gt; x*x ) )</strong></span>
<span class="strong"><strong>Vector(1, 4, 9)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Creates numbers 1,2,3,4 ans 5 filter only Odd numbers them multiply them odds by 2 and return a Vector</strong></span>
<span class="strong"><strong>scala&gt; println ( (1 to 5) filter { _%2 == 0 } map { _*2 } )</strong></span>
<span class="strong"><strong>Vector(4, 8)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Creates a List with 1 to 5 and them print each element being multiplyed by 2</strong></span>
<span class="strong"><strong>scala&gt; List(1,2,3,4,5).foreach ( (i:Int) =&gt; println(i * 2 ) )</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>6</strong></span>
<span class="strong"><strong>8</strong></span>
<span class="strong"><strong>10</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Creates a List with 1 to 5 and then print each element being multiplied by 2</strong></span>
<span class="strong"><strong>scala&gt; List(1,2,3,4,5).foreach ( i =&gt; println(i * 2) )</strong></span>
<span class="strong"><strong>2</strong></span>
<span class="strong"><strong>4</strong></span>
<span class="strong"><strong>6</strong></span>
<span class="strong"><strong>8</strong></span>
<span class="strong"><strong>10</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Drops 3 elements from the lists</strong></span>
<span class="strong"><strong>scala&gt; println( List(2,3,4,5,6).drop(3))</strong></span>
<span class="strong"><strong>List(5, 6)</strong></span>
<span class="strong"><strong>scala&gt; println( List(2,3,4,5,6) drop 3 )</strong></span>
<span class="strong"><strong>List(5, 6)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Zip 2 lists into a single one: It will take 1 element of each list and create a pair List</strong></span>
<span class="strong"><strong>scala&gt; println(  List(1,2,3,4).zip( List(6,7,8) )) </strong></span>
<span class="strong"><strong>List((1,6), (2,7), (3,8))</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Take nested lists and create a single list with flat elements</strong></span>
<span class="strong"><strong>scala&gt; println( List(List(1, 2), List(3, 4)).flatten )</strong></span>
<span class="strong"><strong>List(1, 2, 3, 4)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Finds a person in a List by Age</strong></span>
<span class="strong"><strong>scala&gt; case class Person(age:Int,name:String)</strong></span>
<span class="strong"><strong>defined class Person</strong></span>
<span class="strong"><strong>scala&gt; println( List(Person(31,"Diego"),Person(40,"Nilseu")).find( (p:Person) =&gt; p.age &lt;= 33 ) )</strong></span>
<span class="strong"><strong>Some(Person(31,Diego))</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre></div>
<div class="section" title="Partial application" id="aid-10DJ41"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec26"/>Partial application</h1></div></div></div><p>In Scala, the underscore(<code class="literal">_</code>) means different things in different contexts. The underscore can be used to partially apply a function. It means a value will be supplied later. This feature is useful for function composition and allows you to reuse functions. Let's see some code.</p><div class="section" title="Partial function in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec51"/>Partial function in Scala REPL</h2></div></div></div><p>Following is an example using Partial function in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; def sum(a:Int,b:Int) = a+b</strong></span>
<span class="strong"><strong>sum: (a: Int, b: Int)Int</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val add6 = sum(6,_:Int)</strong></span>
<span class="strong"><strong>add6: Int =&gt; Int = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println(add6(1))</strong></span>
<span class="strong"><strong>7</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>In the preceding code, first, we define a function called <code class="literal">sum</code>, which takes two <code class="literal">Int</code> parameters and calculates a sum of these two parameters. Later, we define a function and hold it as a variable called <code class="literal">add6</code>. For the <code class="literal">add6</code> function definition, we just call the sum function passing <code class="literal">6</code> and <code class="literal">_</code>. Scala will get the parameter passed through <code class="literal">add6</code>, and pass it through the <code class="literal">sum</code> function.</p></div></div>
<div class="section" title="Curried functions" id="aid-11C3M1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec27"/>Curried functions</h1></div></div></div><p>This feature is very popular in function languages like Haskell. Curried functions are similar to partial applications, because they allow some arguments to pass now and others later. However, they are a little bit different.</p><div class="section" title="Curried functions - Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec52"/>Curried functions - Scala REPL</h2></div></div></div><p>Following is an example using curried function in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; // Function Definition</strong></span>
<span class="strong"><strong>scala&gt; def sum(x:Int)(y:Int):Int = x+y</strong></span>
<span class="strong"><strong>sum: (x: Int)(y: Int)Int</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Function call - Calling a curried function </strong></span>
<span class="strong"><strong>scala&gt; sum(2)(3)</strong></span>
<span class="strong"><strong>res0: Int = 5</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Doing partial with Curried functions</strong></span>
<span class="strong"><strong>scala&gt; val add3 = sum(3) _</strong></span>
<span class="strong"><strong>add3: Int =&gt; Int = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; // Supply the last argument now</strong></span>
<span class="strong"><strong>scala&gt; add3(3)</strong></span>
<span class="strong"><strong>res1: Int = 6</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>For the preceding code, we create a curried function in the function definition. Scala allows us to transform regular/normal functions into curried functions. The following code shows the usage of the <code class="literal">curried</code> function.</p></div><div class="section" title="Curried transformation in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec53"/>Curried transformation in Scala REPL</h2></div></div></div><p>Following is an example using curried transformation in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; def normalSum(x:Int,y:Int):Int=x+y</strong></span>
<span class="strong"><strong>normalSum: (x: Int, y: Int)Int</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val curriedSum = (normalSum _).curried</strong></span>
<span class="strong"><strong>curriedSum: Int =&gt; (Int =&gt; Int) = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val add3= curriedSum(3)</strong></span>
<span class="strong"><strong>add3: Int =&gt; Int = &lt;function1&gt;</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println(add3(3))</strong></span>
<span class="strong"><strong>6</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre></div></div>
<div class="section" title="Operator overloading" id="aid-12AK81"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec28"/>Operator overloading</h1></div></div></div><p>Like C++, Scala permits operator overload. This feature is great for creating custom<span class="strong"><strong> Domain Specific Languages</strong></span> (<span class="strong"><strong>DSL</strong></span>), which can be useful to create better software abstractions or even internal or external APIs for developers, or for business people. You should use this feature with wisdom -- imagine if all frameworks decide to overload the same operators with implicits! You might run into trouble. Scala is a very flexible language compared to Java. However, you need to be careful, otherwise you could create code that's hard to maintain or even incompatible with other Scala applications, libraries, or functions.</p><div class="section" title="Scala operator overloading in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec54"/>Scala operator overloading in Scala REPL</h2></div></div></div><p>Following is an example using Scala operator overloading in Scala REPL:</p><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; case class MyNumber(value:Int){</strong></span>
<span class="strong"><strong>     | def +(that:MyNumber):MyNumber = new MyNumber(that.value + this.value)</strong></span>
<span class="strong"><strong>     | def +(that:Int):MyNumber = new MyNumber(that + this.value)</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>defined class MyNumber</strong></span>
<span class="strong"><strong>scala&gt; val v = new MyNumber(5)</strong></span>
<span class="strong"><strong>v: MyNumber = MyNumber(5)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println(v)</strong></span>
<span class="strong"><strong>MyNumber(5)</strong></span>
<span class="strong"><strong>scala&gt; println(v + v)</strong></span>
<span class="strong"><strong>MyNumber(10)</strong></span>
<span class="strong"><strong>scala&gt; println(v + new MyNumber(4))</strong></span>
<span class="strong"><strong>MyNumber(9)</strong></span>
<span class="strong"><strong>scala&gt; println(v + 8)</strong></span>
<span class="strong"><strong>MyNumber(13)</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>As you can see, we have two functions called <code class="literal">+</code>. One of this functions receives a <code class="literal">MyNumber</code> case class, and the other receives a <code class="literal">Int</code> value. You can use OO in Scala with regular classes and functions as well if you wish. We're also favoring immutability here because we always create a new instance of <code class="literal">MyNumber</code> when the operation <code class="literal">+</code> happens.</p></div></div>
<div class="section" title="Implicits" id="aid-1394Q1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec29"/>Implicits</h1></div></div></div><p>Implicits allow you to do magic in Scala. With great power comes great responsibility. Implicits allow to you create very powerful DSL, but they also allow you to get crazy, so do it with wisdom. You are allowed to have implicit functions, classes, and objects. The Scala language and other core frameworks from the Scala ecosystem like Akka and PlayFramework use implicits many times.</p><div class="section" title="Scala Implicits in SCALA REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec55"/>Scala Implicits in SCALA REPL</h2></div></div></div><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; implicit def transformStringtoInt(n:String) = n.toInt</strong></span>
<span class="strong"><strong>warning: there was one feature warning; re-run with -feature for details</strong></span>
<span class="strong"><strong>transformStringtoInt: (n: String)Int</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val s:String = "123456"</strong></span>
<span class="strong"><strong>s: String = 123456</strong></span>
<span class="strong"><strong>scala&gt; println(s)</strong></span>
<span class="strong"><strong>123456</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val i:Int = s</strong></span>
<span class="strong"><strong>i: Int = 123456</strong></span>
<span class="strong"><strong>scala&gt; println(i)</strong></span>
<span class="strong"><strong>123456</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>To use implicits, you need to use the keyword <code class="literal">implicit</code> before a function. Scala will implicitly call that function when it is appropriate. For this case, it will call to convert the <code class="literal">String</code> type to <code class="literal">Int</code> type as we can see.</p></div><div class="section" title="Implicit Parameter at Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec56"/>Implicit Parameter at Scala REPL</h2></div></div></div><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; implicit val yValue:Int = 6</strong></span>
<span class="strong"><strong>yValue: Int = 6</strong></span>
<span class="strong"><strong>scala&gt; def sum(x:Int)(implicit yValue:Int) = x + yValue</strong></span>
<span class="strong"><strong>sum: (x: Int)(implicit yValue: Int)Int</strong></span>
<span class="strong"><strong>scala&gt; val result = sum(10)</strong></span>
<span class="strong"><strong>result: Int = 16</strong></span>
<span class="strong"><strong>scala&gt; println(result)</strong></span>
<span class="strong"><strong>16</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>For this other case, given in the last code, we use an implicit parameter in the function <code class="literal">sum</code>. We also used a curried function here. We defined the <code class="literal">implicit</code> function first, and then called the <code class="literal">sum</code> function. This technique is good for externalized functions configuration and values you would let it hard code. It also saves lines of code, because you don't need to pass a parameter to all functions all the time, so it's quite handy.</p></div></div>
<div class="section" title="Futures" id="aid-147LC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec30"/>Futures</h1></div></div></div><p>Futures enable an efficient way to write parallel operations in a nonblocking IO fashion. Futures are placeholder objects for values that might not exist yet. Futures are composable, and they work with callbacks instead of traditional blocking code.</p><div class="section" title="Simple Future code in Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec57"/>Simple Future code in Scala REPL</h2></div></div></div><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; import concurrent.Future</strong></span>
<span class="strong"><strong>import concurrent.Future</strong></span>
<span class="strong"><strong>scala&gt; import concurrent.ExecutionContext.Implicits.global</strong></span>
<span class="strong"><strong>import concurrent.ExecutionContext.Implicits.global</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; val f: Future[String] = Future { "Hello world!" }</strong></span>
<span class="strong"><strong>f: scala.concurrent.Future[String] = Success(Hello world!)</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println("Result: " + f.value.get.get)</strong></span>
<span class="strong"><strong>Result: Hello world!</strong></span>
<span class="strong"><strong>scala&gt; </strong></span>
<span class="strong"><strong>scala&gt; println("Result: " + f)</strong></span>
<span class="strong"><strong>Result: Success(Hello world!)</strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>In order to work with futures in Scala, we have to import <code class="literal">concurrent.Future</code>. We also need an executor, which is a way to work with threads. Scala has a default set of execution services. You can tweak it if you like, however, for now we can just use the defaults; to do that, we just import <code class="literal">concurrent.ExecutionContext.Implicits.global</code>.</p><p>It's possible to retrieve the <code class="literal">Future</code> value. Scala has a very explicit API, which makes the developer's life easier, and also gives good samples for how we should code our own APIs. Future has a method called <code class="literal">value</code>, which returns <code class="literal">Option[scala.util.Try[A]]</code> where <code class="literal">A</code> is the generic type you are using for the future; for our case, it's a String <code class="literal">A</code>. <code class="literal">Try</code> is a different way to do a try...catch, and this is safer, because the caller knows beforehand that the code they are calling may fail. <code class="literal">Try[Optional]</code> means that Scala will try to run some code and the code may fail -- even if it does not fail, you might receive <code class="literal">None</code> or <code class="literal">Some</code>. This type of system makes everybody's lives better, because you can have <code class="literal">Some</code> or <code class="literal">None</code> as the Option return. Futures are a kind of callback. For our previous sample code, the result was obtained quite quickly, however, we often use futures to call external APIs, REST services, Microservices, SOAP Webservices, or any code that takes time to run and might not get completed. Futures also work with Pattern Matcher. Let's see another sample code.</p></div><div class="section" title="A complete Future sample at Scala REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec58"/>A complete Future sample at Scala REPL</h2></div></div></div><pre class="programlisting">
<span class="strong"><strong>$ scala</strong></span>
<span class="strong"><strong>Welcome to Scala 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_77).</strong></span>
<span class="strong"><strong>Type in expressions for evaluation. Or try :help.</strong></span>
<span class="strong"><strong>scala&gt; import concurrent.Future</strong></span>
<span class="strong"><strong>import concurrent.Future</strong></span>
<span class="strong"><strong>scala&gt; import concurrent.ExecutionContext.Implicits.global</strong></span>
<span class="strong"><strong>import concurrent.ExecutionContext.Implicits.global</strong></span>
<span class="strong"><strong>scala&gt; import scala.util.{Success, Failure}</strong></span>
<span class="strong"><strong>import scala.util.{Success, Failure}</strong></span>
<span class="strong"><strong>scala&gt; def createFuture():Future[Int] = {</strong></span>
<span class="strong"><strong>     | Future { </strong></span>
<span class="strong"><strong>     | val r = scala.util.Random</strong></span>
<span class="strong"><strong>     | if (r.nextInt(100)%2==0) 0 else throw new RuntimeException("ODD numbers are not good here :( ")</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>createFuture: ()scala.concurrent.Future[Int]</strong></span>
<span class="strong"><strong>scala&gt; def evaluateFuture(f:Future[_]) {</strong></span>
<span class="strong"><strong>     | f.onComplete {</strong></span>
<span class="strong"><strong>     | case Success(i) =&gt; println(s"A Success $i ")</strong></span>
<span class="strong"><strong>     | case Failure(e) =&gt; println(s"Something went wrong. Ex: ${e.getMessage}")</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>     | }</strong></span>
<span class="strong"><strong>evaluateFuture: (f: scala.concurrent.Future[_])Unit</strong></span>
<span class="strong"><strong>scala&gt; evaluateFuture(createFuture)</strong></span>
<span class="strong"><strong>scala&gt; Something went wrong. Ex: ODD numbers are not good here :( </strong></span>
<span class="strong"><strong>evaluateFuture(createFuture)</strong></span>
<span class="strong"><strong>A Success 0 </strong></span>
<span class="strong"><strong>scala&gt; evaluateFuture(createFuture)</strong></span>
<span class="strong"><strong>Something went wrong. Ex: ODD numbers are not good here :( </strong></span>
<span class="strong"><strong>scala&gt; evaluateFuture(createFuture)</strong></span>
<span class="strong"><strong>Something went wrong. Ex: ODD numbers are not good here :( </strong></span>
<span class="strong"><strong>scala&gt; evaluateFuture(createFuture)</strong></span>
<span class="strong"><strong>A Success 0 </strong></span>
<span class="strong"><strong>scala&gt; evaluateFuture(createFuture)</strong></span>
<span class="strong"><strong>A Success 0 </strong></span>
<span class="strong"><strong>scala&gt;</strong></span>
</pre><p>There is a function called <code class="literal">createFuture</code>, which creates <code class="literal">Future[Int]</code> each time you call it. In the preceding code, we use <code class="literal">scala.util.Random</code> to generate random numbers between 0 and 99. If the number is even, we return a <code class="literal">0</code>, which means success. However, if the number is odd, we return a <code class="literal">RuntimeException</code>, which will mean a failure.</p><p>There is a second function called <code class="literal">evaluateFuture</code>, which receives any Future. We allow a result of any kind of generic parameterized type of function, because we used the magic underscore <code class="literal">_</code>. Then we apply Pattern Matcher with two case classes: <code class="literal">Success</code> and <code class="literal">Failure</code>. In both the cases, we just print on <code class="literal">stdin</code>. We also use another interesting and handy Scala feature called String interpolation. We need to we start the String with <code class="literal">s</code> before <code class="literal">""</code>. This allows us to use expressions with <code class="literal">$</code> and <code class="literal">${}</code> to evaluate any variable in the context. This is a different approach for String concatenation from what we have done so far. Later, we made <code class="literal">6</code> calls for the <code class="literal">evaluteFuture</code> function, passing a new Future each time, created by the function <code class="literal">createFuture</code>.</p></div></div>
<div class="section" title="Reactive Programing and RxScala" id="aid-1565U1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec31"/>Reactive Programing and RxScala</h1></div></div></div><p>Reactive programming is better, scalable, and a faster way to build applications. Reactive Programing can be done with OO languages, however, they make a lot of sense with FP languages. When FP is married to Reactive Programing, we get something called <span class="strong"><strong>Functional Reactive Programing</strong></span> (<span class="strong"><strong>FRP</strong></span>). Scala FRP can be used for many purposes like GUI, Robotics, and Music, because it gives you a better model to model time. Reactive programming is a new technique, which works with Streams(also known as Data Flows). Streams is a way to think and code applications in a way which can express data transformations and flow. The main idea is to propagate changes through a circuit or flow. Yes, we are talking about a new way to do async programming.</p><p>The main library for Reactive Programing is called <span class="strong"><strong>Reactive Extensions</strong></span> (<span class="strong"><strong>Rx</strong></span>) - <a class="ulink" href="http://reactivex.io/">http://reactivex.io/</a>), originally built for .NET by Eric Meijer. It combines the best ideas from the Observer and Iterator Patterns, and FP. Rx has implementations for many languages like Scala, Java, Python, .NET, PHP, and others (<a class="ulink" href="https://github.com/ReactiveX">https://github.com/ReactiveX</a>). Coding with Rx is easy, and you can create Streams, combine with query-like operators, and also listen (subscribe) to any observable Streams to perform data transformations. Rx is used by many successful companies today like Netflix, GitHub, Microsoft, SoundCloud, Couchbase, Airbnb, Trello, and several others. In this book, we will use RxScala, which is the Scala implementation of the Reactive Streams.</p><p>The following table shows the main class/concepts you need to know in order to work with Rx.</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><span class="strong"><strong>Term / Class</strong></span></p>
</td><td>
<p><span class="strong"><strong>Concept</strong></span></p>
</td></tr><tr><td>
<p>Observable</p>
</td><td>
<p>Create async composable Streams from sources.</p>
</td></tr><tr><td>
<p>Observer</p>
</td><td>
<p>A callback function type.</p>
</td></tr><tr><td>
<p>Subscription</p>
</td><td>
<p>The bound between the Subscriber and the Observable. Receives notifications from Observables.</p>
</td></tr></tbody></table></div><p>Reactive Streams is also the name of a common specification trying to consolidate and standardize the reactive stream processing, There are several implementations such as RxJava/RxScala, Reactor, Akka, Slick, and Vert.x. You can find more at <a class="ulink" href="https://github.com/reactive-streams/reactive-streams-jvm">https://github.com/reactive-streams/reactive-streams-jvm</a>. </p><p>Back to the Observables -- we can perform all kinds of operations with observables. For instance, we can filter, select, aggregate, compose, perform time-based operations, and apply backpressure. There are two big wins with Observables instead of callbacks. First of all, Observables are not opinionated about how low-level I/O and threading happens, and secondly, when you are doing complex code, callbacks tend to be nested, and that is when things get ugly and hard to read. Observables have a simple way to do composition thanks to FP.</p><p>Observables push values to consumers whenever values are available, which is great because then the values can arrive in sync or async fashion. Rx provides a series of collection operators to do all sorts of data transformations you may need. Let's see some code now. We will use RxScala version 0.26.1, which is compatible with RxJava version 1.1.1+. RxScala is just a wrapper for RxJava (Created by Netflix). Why not use RxJava straight? Because the syntax won't be pleasant; with RxScala, we can have a fluent Scala experience. RxJava is great, however, Java syntax for this is not pleasant - as Scala is, in fact, pretty ugly.</p><div class="section" title="Simple Observables Scala with RxScala"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec59"/>Simple Observables Scala with RxScala</h2></div></div></div><pre class="programlisting">package scalabook.rx.chap1 &#13;
 &#13;
import rx.lang.scala.Observable &#13;
import scala.concurrent.duration._ &#13;
 &#13;
object SimpleRX extends App { &#13;
   &#13;
  val o = Observable. &#13;
            interval(100 millis). &#13;
            take(5)             &#13;
             &#13;
  o.subscribe( x =&gt; println(s"Got it: $x") )             &#13;
  Thread.sleep(1000)           &#13;
             &#13;
  Observable. &#13;
      just(1, 2, 3, 4). &#13;
      reduce(_+_). &#13;
      subscribe( r =&gt; println(s"Sum 1,2,3,4 is $r in a Rx Way")) &#13;
   &#13;
} &#13;
</pre><p>If you run this preceding Scala program, you will see the following output:</p></div><div class="section" title="Simple Observables Scala with RxScala - Execution in the console"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec60"/>Simple Observables Scala with RxScala - Execution in the console</h2></div></div></div><pre class="programlisting">Got it: 0 &#13;
Got it: 1 &#13;
Got it: 2 &#13;
Got it: 3 &#13;
Got it: 4 &#13;
Sum 1,2,3,4 is 10 in a Rx Way &#13;
</pre><p>If you try to run this code in the Scala REPL, it will fail, because we need the RxScala and RxJava dependencies. For this, we will need SBT and dependency management. Do not worry, we will cover how to work with SBT in our Scala application in the next chapter.</p><p>Going back to the observables, we need to import the Scala Observable. Make sure you get it from the Scala package, because if you get the Java one, you will have issues: in the very first part of the code, we will get numbers starting from 0 each 100 milliseconds, and this code would run forever. To avoid this, we use the take function to put a limit into the collection, so we will get the first five values. Then, later, we subscribe to the observer, and when data is ready, our code will run. For the first sample, it's pretty easy, we are just printing the values we have got. There is a thread sleep in this program, otherwise, the program would terminate, and you would not see any value on the console.</p><p>The second part of the code does something more interesting. First of all, it creates an Observable from a static list of values, which are 1,2,3, and 4. We apply a reduce function into the elements, which will sum all the elements with each other, and then we subscribe and print the result.</p></div><div class="section" title="Complex Scala with RxScala Observables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec61"/>Complex Scala with RxScala Observables</h2></div></div></div><pre class="programlisting">package scalabook.rx.chap1 &#13;
 &#13;
import rx.lang.scala.Observable &#13;
 &#13;
object ComplexRxScala extends App { &#13;
   &#13;
  Observable. &#13;
      just(1,2,3,4,5,6,7,8,9,10).       // 1,2,3,4,5,6,7,8,9,10 &#13;
      filter( x =&gt; x%2==0).             // 2,4,6,8,10 &#13;
      take(2).                          // 2,4 &#13;
      reduce(_+_).                      // 6 &#13;
      subscribe( r =&gt; println(s"#1 $r")) &#13;
   &#13;
   val o1 = Observable. &#13;
            just(1,2,3,4,5,6,7,8,9,10).  // 1,2,3,4,5,6,7,8,9,10 &#13;
            filter( x =&gt; x%2==0).        // 2, 4, 6, 8, 10 &#13;
            take(3).                     // 2, 4 ,6     &#13;
            map( n =&gt; n * n)             // 4, 16, 36 &#13;
   &#13;
   val o2 = Observable.                  &#13;
            just(1,2,3,4,5,6,7,8,9,10). // 1,2,3,4,5,6,7,8,9,10  &#13;
            filter( x =&gt; x%2!=0).       // 1, 3, 5, 7, 9    &#13;
            take(3).                    // 1, 3, 5 &#13;
            map( n =&gt; n * n)            // 1, 9, 25 &#13;
            &#13;
   val o3 = o1. &#13;
           merge(o2).                  // 2,16, 36, 1, 9, 25 &#13;
           subscribe( r =&gt; println(s"#2 $r")) &#13;
       &#13;
} &#13;
</pre><p>The preceding first part of the code creates an Observable with numbers from 1 to 10, and then applies a <code class="literal">filter</code> function, which will get only the even numbers. It then reduces them, calculates their sum, and lastly, prints the solution. You can visualize it as depicted in the following image:</p><p>
</p><div class="mediaobject"><img src="../Images/image00233.jpeg" alt="Complex Scala with RxScala Observables"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>For the second part of the code, we create two different observables. The first one is with even numbers and the second one is with odd numbers. These two observables are decoupled from each other; you can control as many observables you want. Later on, the code uses a merge function to join these two observables into a third and new observable containing the content of the first and second observables.</p><p>
</p><div class="mediaobject"><img src="../Images/image00234.jpeg" alt="Complex Scala with RxScala Observables"/><div class="caption"><p>Merging 2 Observables</p></div></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>There are many functions and options, and you can see the whole list at <a class="ulink" href="http://rxmarbles.com/">http://rxmarbles.com/</a> and <a class="ulink" href="https://github.com/ReactiveX/RxScala">https://github.com/ReactiveX/RxScala</a>. For the sake of simplicity, for now, we are just working with numbers. Later, we will use this to do more advance compositions including database calls and external web services calls.</p></div></div>
<div class="section" title="Summary" id="aid-164MG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we learned the basic concepts of FP, Reactive Programing, and the Scala language. We learned about the basic constructs of the Scala language and Functional Programming, functions, collections, and OO in Scala, and concurrent programming with Futures.</p><p>Next, we will see how to use SBT to build Scala projects. We will learn how to compile and run Scala applications using SBT.</p></div></body></html>