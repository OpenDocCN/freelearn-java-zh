- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving the Web Layer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we complete our web application by adding a web endpoint. We
    will learn how to write HTTP integration tests using the built-in Java HTTP client.
    We will test-drive the web adapter code that runs this endpoint, using an open
    source HTTP server framework. This web adapter is responsible for converting HTTP
    requests into commands we can execute in our domain layer. At the end of the chapter,
    we will assemble all the pieces of our application into a microservice. The web
    adapter and database adapters will be linked to the domain model using dependency
    injection. We will need to run a few manual database commands, install a web client
    called Postman, and then we can play our game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter15](B18384_15.xhtml#_idTextAnchor314).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Before attempting to run the final application, perform the following steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the **Postgres** database is running locally.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the database setup steps from [*Chapter 14*](B18384_14.xhtml#_idTextAnchor293)
    *, Driving the Database Layer,* have been completed.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Postgres pqsl** command terminal and enter the following SQL command:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Install **Postman** by following the instructions at [https://www.postman.com/downloads/](B18384_15.xhtml#_idTextAnchor313).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting a new game
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will test-drive a web adapter that will provide our domain
    model with an HTTP API. External web clients will be able to send HTTP requests
    to this endpoint to trigger actions in our domain model so that we can play the
    game. The API will return appropriate HTTP responses, indicating the score for
    the submitted guess and reporting when the game is over.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The following open source libraries will be used to help us write the code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`Molecule`: This is a lightweight HTTP framework'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Undertow`: This is a lightweight HTTP web server that powers the Molecule
    framework'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GSON`: This is a Google library that converts between Java objects and JSON
    structured data'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start building, we first add the required libraries as dependencies to the
    `build.gradle` file. Then we can begin writing an integration test for our HTTP
    endpoint and test-drive the implementation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Adding required libraries to the project
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to add the three libraries Molecule, Undertow, and Gson to the `build.gradle`
    file before we can use them:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `build.gradle` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Writing the failing test
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will follow the normal TDD cycle to create our web adapter. When writing
    tests for objects in the adapter layer, we must focus on testing the translation
    between objects in our domain layer and communications with external systems.
    Our adapter layer will use the Molecule HTTP framework to handle HTTP requests
    and responses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循正常的TDD周期来创建我们的Web适配器。在为适配器层中的对象编写测试时，我们必须专注于测试领域层中的对象与外部系统之间的通信之间的转换。我们的适配器层将使用Molecule
    HTTP框架来处理HTTP请求和响应。
- en: As we have used hexagonal architecture and started with the domain layer, we
    already know that the game logic is working. The goal of this test is to prove
    that the web adapter layer is performing its responsibility. That is to translate
    HTTP requests and responses to objects in our domain layer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使用了六边形架构并从领域层开始，我们已经知道游戏逻辑正在工作。这次测试的目标是证明网络适配器层正在履行其职责。也就是说，将 HTTP 请求和响应转换为我们的领域层中的对象。
- en: 'As ever, we begin by creating a test class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先创建一个测试类：
- en: 'First, we write our test class. We’ll call it `WordzEndpointTest`, and it belongs
    in the `com.wordz.adapters.api` package:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们编写我们的测试类。我们将称之为 `WordzEndpointTest`，并且它属于 `com.wordz.adapters.api` 包：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason for including this package is as part of our hexagonal architecture.
    Code in this web adapter is allowed to use anything from the domain model. The
    domain model itself is unaware of the existence of this web adapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 包含这个包的原因是作为我们六边形架构的一部分。在这个Web适配器中的代码允许使用领域模型中的任何东西。领域模型本身对这个Web适配器的存在一无所知。
- en: 'Our first test will be to start a new game:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项测试将是启动一个新的游戏：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This test needs to capture the design decision that surrounds our intended
    web API. One decision is that when a game has successfully started, we will return
    a simple `204 No Content` HTTP status code. We will start with the assert to capture
    this decision:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个测试需要捕捉围绕我们打算构建的Web API的设计决策。一个决策是，当游戏成功启动时，我们将返回一个简单的 `204 No Content` HTTP
    状态码。我们将从断言开始来捕捉这个决策：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we write the Act step. The action here is for an external HTTP client
    to send a request to our web endpoint. To achieve this, we use the built-in HTTP
    client provided by Java itself. We arrange the code to send the request, and then
    discard any HTTP response body, as our design does not return a body:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编写行动步骤。这里的行动是为外部HTTP客户端发送一个请求到我们的Web端点。为了实现这一点，我们使用Java本身提供的内置HTTP客户端。我们安排代码发送请求，然后丢弃任何HTTP响应体，因为我们的设计不返回体：
- en: '[PRE12]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Arrange step is where we capture our decisions about the HTTP request to
    send. In order to start a new game, we need a `Player` object to identify the
    player. We will send this as a `Json` object in the `Request` body. The request
    will cause a state change on our server, so we choose the HTTP `POST` method to
    represent that. Finally, we choose a route whose path is `/start`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安排步骤是我们捕捉关于要发送的HTTP请求的决定。为了启动一个新的游戏，我们需要一个 `Player` 对象来识别玩家。我们将把这个作为 `Json`
    对象发送到 `Request` 体的内容。这个请求将在我们的服务器上引起状态变化，所以我们选择HTTP `POST` 方法来表示这一点。最后，我们选择一个路径为
    `/start` 的路由：
- en: '[PRE22]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We see the `Gson` library being used to convert a `Player` object into its JSON
    representation. We also see a `POST` method is constructed and sent to the `/start`
    path on `localhost`. Eventually, we will want to move the `localhost` detail into
    configuration. But, for now, it will get the test working on our local machine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `Gson` 库被用来将 `Player` 对象转换为它的JSON表示。我们还看到构建了一个 `POST` 方法并发送到 `localhost`
    上的 `/start` 路径。最终，我们希望将 `localhost` 的细节移动到配置中。但，目前，它将使测试在我们的本地机器上工作。
- en: 'We can run our integration test and confirm that it fails:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行我们的集成测试并确认它失败：
- en: '![Figure 15.1 – A failed test – no HTTP server](img/Figure_15.01_B18384.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 一个失败的测试 – 没有HTTP服务器](img/Figure_15.01_B18384.jpg)'
- en: Figure 15.1 – A failed test – no HTTP server
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 一个失败的测试 – 没有HTTP服务器
- en: Unsurprisingly, this test fails because it cannot connect to an HTTP server.
    Fixing that is our next task.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 并非意外，这个测试失败了，因为它无法连接到HTTP服务器。修复这个问题是我们的下一个任务。
- en: Creating our HTTP server
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的HTTP服务器
- en: 'The failing test allows us to test-drive code that implements an HTTP server.
    We will use the Molecule library to provide HTTP services to us:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的测试允许我们测试驱动实现HTTP服务器的代码。我们将使用Molecule库为我们提供HTTP服务：
- en: 'Add an endpoint class, which we will call `class WordzEndpoint`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个端点类，我们将称之为 `class WordzEndpoint`：
- en: '[PRE39]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The two parameters passed into the `WordzEndpoint` constructor define the host
    and port that the web endpoint will run on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `WordzEndpoint` 构造函数的两个参数定义了网络端点将运行在的主机和端口。
- en: 'Using the IDE, we generate the class:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用IDE，我们生成类：
- en: '[PRE44]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, we’re not going to store the host and port details in fields.
    Instead, we are going to start a `WebServer` using a class from the Molecule library.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不会将主机和端口详情存储在字段中。相反，我们将使用Molecule库中的类启动一个`WebServer`。
- en: 'Create a `WebServer` using the Molecule library:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Molecule库创建`WebServer`：
- en: '[PRE49]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding code is enough to start an HTTP server running and allow the test
    to connect to it. Our HTTP server does nothing useful in terms of playing our
    game. We need to add some routes to this server along with the code to respond
    to them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码足以启动一个运行的HTTP服务器，并允许测试连接到它。我们的HTTP服务器在玩游戏方面没有任何有用的功能。我们需要向这个服务器添加一些路由以及响应它们的代码。
- en: Adding routes to the HTTP server
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向HTTP服务器添加路由
- en: 'To be useful, the HTTP endpoint must respond to HTTP commands, interpret them,
    and send them as commands to our domain layer. As design decisions, we decide
    on the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了变得有用，HTTP端点必须响应HTTP命令，解释它们，并将它们作为命令发送到我们的域层。作为设计决策，我们决定以下内容：
- en: That a `/start` route must be called to start the game
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要调用`/start`路由来启动游戏
- en: That we will use the HTTP `POST` method
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用HTTP `POST`方法
- en: That we will identify which player the game belongs to as JSON data in the `POST`
    body
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将识别游戏属于哪个玩家，作为`POST`体中的JSON数据
- en: 'To add routes to the HTTP server, do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要向HTTP服务器添加路由，请执行以下操作：
- en: 'Test-drive the `/start` route. To work in small steps, initially, we will return
    a `NOT_IMPLEMENTED` HTTP response code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`/start`路由。为了分步工作，最初，我们将返回`NOT_IMPLEMENTED` HTTP响应代码：
- en: '[PRE57]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can run the `WordzEndpointTest` integration test:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行`WordzEndpointTest`集成测试：
- en: '![Figure 15.2 – An incorrect HTTP status](img/Figure_15.02_B18384.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 – 错误的HTTP状态](img/Figure_15.02_B18384.jpg)'
- en: Figure 15.2 – An incorrect HTTP status
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – 错误的HTTP状态
- en: The test fails, as expected. We have made progress because the test now fails
    for a different reason. We can now connect to the web endpoint, but it does not
    return the right HTTP response. Our next task is to connect this web endpoint
    to the domain layer code and take the relevant actions to start a game.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，测试失败了。我们已经取得了进展，因为测试现在失败的原因不同了。我们现在可以连接到网络端点，但它没有返回正确的HTTP响应。我们的下一个任务是连接这个网络端点到域层代码，并采取相关行动来启动一个游戏。
- en: Connecting to the domain layer
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到域层
- en: 'Our next task is to receive an HTTP request and translate that into domain
    layer calls. This involves parsing JSON request data, using the Google Gson library,
    into Java objects, then sending that response data to the `class` `Wordz` port:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个任务是接收一个HTTP请求并将其转换为域层调用。这涉及到使用Google Gson库解析JSON请求数据，将其转换为Java对象，然后将响应数据发送到`Wordz`类的端口：
- en: 'Add the code to call the domain layer port implemented as `class Wordz`. We
    will use `Mockito` to create a test double for this object. This allows us to
    test only the web endpoint code, decoupled from all other code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加调用作为`class Wordz`实现的域层端口的代码。我们将使用`Mockito`为此对象创建一个测试双胞胎。这允许我们仅测试Web端点代码，而无需与其他所有代码解耦：
- en: '[PRE76]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We need to provide our `class Wordz` domain object to the `class WordzEndpoint`
    object. We use dependency injection to inject it into the constructor:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将我们的`class Wordz`域对象提供给`class WordzEndpoint`对象。我们使用依赖注入将其注入到构造函数中：
- en: '[PRE86]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, we need to add the code to start a game. To do that, we first extract
    the `Player` object from the JSON data in the `request` body. That identifies
    which player to start a game for. Then we call the `wordz.newGame()` method. If
    it is successful, we return an HTTP status code of `204 No Content`, indicating
    success:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加启动游戏的代码。为此，我们首先从`request`体中的JSON数据中提取`Player`对象。这确定了为哪个玩家启动游戏。然后我们调用`wordz.newGame()`方法。如果成功，我们返回HTTP状态码`204
    No Content`，表示成功：
- en: '[PRE92]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, we can run the test, however, it fails:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行测试，然而，它失败了：
- en: '![Figure 15.3 – An incorrect HTTP response](img/Figure_15.03_B18384.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 – 错误的HTTP响应](img/Figure_15.03_B18384.jpg)'
- en: Figure 15.3 – An incorrect HTTP response
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 错误的HTTP响应
- en: It failed because the return value from `wordz.newGame()` was false. The mock
    object needs to be set up to return `true`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败了，因为`wordz.newGame()`的返回值是false。需要设置模拟对象以返回`true`。
- en: 'Return the correct value from the `mockWordz` stub:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`mockWordz`存根返回正确的值：
- en: '[PRE110]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Then, run the test:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行测试：
- en: '![Figure 15.4 – The test passes](img/Figure_15.04_B18384.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4 – 测试通过](img/Figure_15.04_B18384.jpg)'
- en: Figure 15.4 – The test passes
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 – 测试通过
- en: The integration test passes. The HTTP request has been received, called the
    domain layer code to start a new game, and the HTTP response is returned. The
    next step is to consider refactoring.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通过了。HTTP请求已被接收，调用了领域层代码以启动新游戏，并返回了HTTP响应。下一步是考虑重构。
- en: Refactoring the start game code
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构启动游戏代码
- en: As usual, once a test passes, we consider what – if anything – we need to refactor.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，一旦测试通过，我们就考虑是否需要重构。
- en: 'It will be worthwhile to refactor the test to simplify writing new tests by
    collating common code into one place:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试重构以简化新测试的编写，将常用代码汇总到一个地方将是有价值的：
- en: '[PRE118]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Handling errors when starting a game
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理启动游戏时的错误
- en: 'One of our design decisions is that a player cannot start a game when one is
    in progress. We need to test-drive this behavior. We choose to return an HTTP
    status of `409 Conflict` to indicate that a game is already in progress for a
    player and a new one cannot be started for them:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计决策之一是玩家在游戏进行中时不能开始游戏。我们需要测试驱动这种行为。我们选择返回HTTP状态码`409 Conflict`，以指示玩家的游戏已经开始，无法为他们启动新的游戏：
- en: 'Write the test to return a `409 Conflict` if the game is already in progress:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试以返回`409 Conflict`，如果游戏已经开始：
- en: '[PRE119]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Next, run the test. It should fail, as we have yet to write the implementation
    code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行测试。它应该失败，因为我们还没有编写实现代码：
- en: '![Figure 15.5 – A failing test](img/Figure_15.05_B18384.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 – 失败的测试](img/Figure_15.05_B18384.jpg)'
- en: Figure 15.5 – A failing test
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 失败的测试
- en: 'Test-drive the code to report that the game cannot be restarted:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过测试驱动代码报告游戏无法重启：
- en: '[PRE132]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Run the test again:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试：
- en: '![Figure 15\. 6 – The test passes](img/Figure_15.06_B18384.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6 – 测试通过](img/Figure_15.06_B18384.jpg)'
- en: Figure 15\. 6 – The test passes
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – 测试通过
- en: The test passes when run on its own now that the implementation is in place.
    Let’s run all the `WordzEndpointTests` tests to double-check our progress.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实现到位后，单独运行测试时测试通过。让我们运行所有`WordzEndpointTests`测试以双重检查我们的进度。
- en: 'Run all `WordzEndpointTests`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有`WordzEndpointTests`：
- en: '![Figure 15.7 – Test failure due to restarting the server](img/Figure_15.07_B18384.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7 – 由于重启服务器导致的测试失败](img/Figure_15.07_B18384.jpg)'
- en: Figure 15.7 – Test failure due to restarting the server
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 – 由于重启服务器导致的测试失败
- en: Unexpectedly, the tests fail when run one after the other.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 意外的是，当依次运行时，测试失败了。
- en: Fixing the unexpectedly failing tests
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复意外失败的测试
- en: When we run all of the tests, they now fail. The tests all previously ran correctly
    when run one at a time. A recent change has clearly broken something. We lost
    our test isolation at some point. This error message indicates the web server
    is being started twice on the same port, which is not possible.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行所有测试时，它们现在都失败了。当单独运行时，所有测试之前都运行正确。最近的一个更改显然破坏了某些东西。我们在某个时候失去了测试隔离。这个错误信息表明，Web服务器正在同一端口上启动两次，这是不可能的。
- en: 'The options are to stop the web server after each test or to only start the
    web server once for all tests. As this is intended to be a long-running microservice,
    only starting once seems the better choice here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是每个测试后停止Web服务器，或者只为所有测试启动一次Web服务器。由于这是一个长期运行的微服务，这里只启动一次似乎是一个更好的选择：
- en: 'Add a `@BeforeAll` annotation to only start the HTTP server once:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`@BeforeAll`注解以仅启动HTTP服务器一次：
- en: '[PRE150]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'We change the `@BeforeEach` annotation to a `@BeforeAll` annotation to make
    the endpoint creation only happen once per test. To support this, we also must
    create the mock and use an annotation on the test itself to control the life cycle
    of objects:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`@BeforeEach`注解更改为`@BeforeAll`注解，以便端点创建只在每个测试中发生一次。为了支持这一点，我们还必须创建模拟并使用注解在测试本身上以控制对象的生命周期：
- en: '[PRE156]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Both tests in `WordzEndpointTest` now pass.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`WordzEndpointTest`中的两个测试现在都通过了。'
- en: 'With all tests passing again, we can consider refactoring the code. A readability
    improvement will come from extracting an `extractPlayer()` method. We can also
    make the conditional HTTP status code more concise:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有测试再次通过后，我们可以考虑重构代码。通过提取`extractPlayer()`方法，我们可以提高可读性。我们还可以使条件HTTP状态码更简洁：
- en: '[PRE157]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: We have now completed the major part of the coding needed to start a game. To
    handle the remaining error condition, we can now test-drive the code to return
    `400 BAD REQUEST` if the `Player` object cannot be read from the JSON payload.
    We will omit that code here. In the next section, we will move on to test-driving
    the code for guessing the target word.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了启动游戏所需的主要编码部分。为了处理剩余的错误条件，我们现在可以测试驱动代码，如果无法从JSON有效负载中读取`Player`对象，则返回`400
    BAD REQUEST`。我们在这里省略了那段代码。在下一节中，我们将继续测试驱动猜测目标单词的代码。
- en: Playing the game
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏玩法
- en: In this section, we will test-drive the code to play the game. This involves
    submitting multiple guess attempts to the endpoint until a game-over response
    is received.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试驱动代码来玩游戏。这涉及到向端点提交多个猜测尝试，直到收到游戏结束的响应。
- en: 'We start by creating an integration test for the new `/guess` route in our
    endpoint:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为端点中的新`/guess`路由创建一个集成测试：
- en: 'The first step is to code the Arrange step. Our domain model provides the `assess()`
    method on `class Wordz` to assess the score for a guess, along with reporting
    whether the game is over. To test-drive this, we set up the `mockWordz` stub to
    return a valid `GuessResult` object when the `assess()` method is called:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是编写Arrange步骤。我们的领域模型在`Wordz`类上提供了`assess()`方法来评估猜测的分数，并报告游戏是否结束。为了驱动测试，我们设置了`mockWordz`存根，当调用`assess()`方法时返回一个有效的`GuessResult`对象：
- en: '[PRE177]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The Act step will call our endpoint with a web request submitting the guess.
    Our design decision is to send an HTTP `POST` request to the `/guess` route. The
    `request` body will contain a JSON representation of the guessed word. To create
    this, we will use `record GuessRequest` and use Gson to convert that into JSON
    for us:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Act步骤将调用我们的端点，提交一个包含猜测的Web请求。我们的设计决策是向`/guess`路由发送HTTP `POST`请求。`request`体将包含猜测单词的JSON表示。为此，我们将使用`record
    GuessRequest`并使用Gson将其转换为JSON：
- en: '[PRE185]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Next, we define the record:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义记录：
- en: '[PRE198]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Then, we send the request over HTTP to our endpoint, awaiting the response:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过HTTP将请求发送到我们的端点，等待响应：
- en: '[PRE202]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Then, we extract the returned body data and assert it against our expectations:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们提取返回的体数据，并对其与我们的预期进行断言：
- en: '[PRE218]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: One API design decision here is to return the per-letter scores as a five-character
    `String` object. The single letters `X`, `C`, and `P` are used to indicate incorrect,
    correct, and partially correct letters. We capture this decision in the assertion.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的一个API设计决策是返回每个字母的分数作为一个五字符的`String`对象。单个字母`X`、`C`和`P`用来表示不正确、正确和部分正确的字母。我们在断言中捕捉这个决策。
- en: 'We define a record to represent the JSON data structure we will return as a
    response from our endpoint:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个记录来表示我们将作为端点响应返回的JSON数据结构：
- en: '[PRE244]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'As we have decided to `POST` to a new `/guess` route, we need to add this route
    to the routing table. We also need to bind it to a method that will take action,
    which we will call `guessWord()`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们决定向新的`/guess`路由`POST`，我们需要将此路由添加到路由表中。我们还需要将其绑定到一个将采取行动的方法，我们将称之为`guessWord()`：
- en: '[PRE248]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: We add an `IllegalStateException` to rethrow any problems that occur when starting
    the HTTP server. For this application, this exception may propagate upwards and
    cause the application to stop running. Without a working web server, none of the
    web code makes sense to run.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`IllegalStateException`来重新抛出在启动HTTP服务器时发生的任何问题。对于这个应用程序，这个异常可能会向上传播并导致应用程序停止运行。没有工作的Web服务器，所有的Web代码都没有意义去运行。
- en: 'We implement the `guessWord()` method with code to extract the `request` data
    from the `POST` body:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用代码实现了`guessWord()`方法，用于从`POST`请求体中提取`request`数据：
- en: '[PRE263]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'Now we have the `request` data, it’s time to call our domain layer to do the
    real work. We will capture the `GuessResult` object returned, so we can base our
    HTTP response from the endpoint on it:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`request`数据，是时候调用我们的领域层来完成实际工作了。我们将捕获返回的`GuessResult`对象，这样我们就可以根据端点上的HTTP响应来构建：
- en: '[PRE276]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'We choose to return a different format of data from our endpoint compared to
    the `GuessResult` object returned from our domain model. We will need to transform
    the result from the domain model:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择从我们的端点返回与从领域模型返回的`GuessResult`对象不同的数据格式。我们需要将领域模型的结果转换：
- en: '[PRE288]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'We add an empty version of the object doing the transformation, which is `class
    GuessHttpResponseMapper`. In this first step, it will simply return `null`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个执行转换的空版本的对象，即`class GuessHttpResponseMapper`。在这个第一步中，它将简单地返回`null`：
- en: '[PRE307]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'This is enough to compile and be able to run the `WordzEndpointTest` test:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就足够编译并运行`WordzEndpointTest`测试了：
- en: '![Figure 15.8 – The test fails](img/Figure_15.08_B18384.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8 – 测试失败](img/Figure_15.08_B18384.jpg)'
- en: Figure 15.8 – The test fails
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 测试失败
- en: With a failing test in place, we can now test-drive the details of the transform
    class. To do this, we switch to adding a new unit test called `class GuessHttpResponseMapperTest`.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置了一个失败的测试之后，我们现在可以测试驱动转换类的细节。为此，我们切换到添加一个名为`class GuessHttpResponseMapperTest`的新单元测试。
- en: Note
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The details of this are omitted but can be found on GitHub – it follows the
    standard approach used throughout the book.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节被省略了，但可以在GitHub上找到 – 它遵循本书中使用的标准方法。
- en: 'Once we have test-driven the detailed implementation of `class GuessHttpResponseMapper`,
    we can rerun the integration test:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们通过测试驱动了`class GuessHttpResponseMapper`的详细实现，我们可以重新运行集成测试：
- en: '![Figure 15.9 – The endpoint test passes](img/Figure_15.09_B18384.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图15.9 – 端点测试通过](img/Figure_15.09_B18384.jpg)'
- en: Figure 15.9 – The endpoint test passes
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – 端点测试通过
- en: As we see in the preceding image, the integration test has passed! Time for
    a well-earned coffee break. Well, mine’s a nice English breakfast tea, but that’s
    just me. After that, we can test-drive the response to any errors that occurred.
    Then it’s time to bring the microservice together. In the next section, we will
    assemble our application into a running microservice.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图像中看到的那样，集成测试已经通过！是时候享受一杯应得的咖啡了。嗯，我的选择是美味的英式早餐茶，但那只是我个人的喜好。之后，我们可以测试驱动对发生的任何错误做出的响应。然后是时候将微服务组合在一起了。在下一节中，我们将组装我们的应用程序以运行微服务。
- en: Integrating the application
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成应用程序
- en: In this section, we will bring together the components of our test-driven application.
    We will form a microservice that runs our endpoint and provides the frontend web
    interface to our service. It will use the Postgres database for storage.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将汇集我们的测试驱动应用程序的组件。我们将形成一个运行端点并提供服务前端网络界面的微服务。它将使用Postgres数据库进行存储。
- en: 'We need to write a short `main()` method to link together the major components
    of our code. This will involve creating concrete objects and injecting dependencies
    into constructors. The `main()` method exists on `class WordzApplication`, which
    is the entry point to our fully integrated web service:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个简短的`main()`方法来将我们代码的主要组件链接在一起。这涉及到创建具体对象并将依赖注入到构造函数中。`main()`方法位于`class
    WordzApplication`中，这是我们完全集成的网络服务的入口点：
- en: '[PRE314]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: The `main()` method instantiates the domain model, and dependency injects the
    concrete version of our adapter classes into it. One notable detail is the `waitUntilTerminated()`method.
    This prevents `main()` from terminating until the application is closed down.
    This, in turn, keeps the HTTP endpoint responding to requests.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`方法实例化了领域模型，并将我们适配器类的具体版本依赖注入其中。一个值得注意的细节是`waitUntilTerminated()`方法。这防止`main()`在应用程序关闭之前终止。这反过来又使HTTP端点能够响应请求。'
- en: Configuration data for the application is held in `class WordzConfiguration`.
    This has default settings for the endpoint host and port settings, along with
    database connection settings. These can also be passed in as command line arguments.
    The class and its associated test can be seen in the GitHub code for this chapter.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的配置数据存储在`class WordzConfiguration`中。它为端点主机和端口设置以及数据库连接设置提供了默认设置。这些也可以作为命令行参数传入。该类及其关联的测试可以在本章的GitHub代码中找到。
- en: In the next section, we will use the Wordz web service application using the
    popular HTTP testing tool, Postman.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Wordz网络服务应用程序，使用流行的HTTP测试工具Postman。
- en: Using the application
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序
- en: To use our newly assembled web application, first ensure that the database setup
    steps and the Postman installation described in the *Technical requirements* section
    have been successfully completed. Then run the `main()` method of `class` `WordzApplication`
    in IntelliJ. That starts the endpoint, ready to accept requests.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们新组装的网络应用程序，首先确保*技术要求*部分中描述的数据库设置步骤和Postman安装已成功完成。然后在IntelliJ中运行`class
    WordzApplication`的`main()`方法。这启动了端点，准备接受请求。
- en: 'Once the service is running, the way we interact with it is by sending HTTP
    requests to the endpoint. Launch Postman and (on macOS) a window that looks like
    this will appear:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务运行，我们与之交互的方式是通过向端点发送HTTP请求。启动Postman，在macOS上，会出现一个类似这样的窗口：
- en: '![Figure 15.10 – Postman home screen](img/Figure_15.10_B18384.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![图15.10 – Postman主屏幕](img/Figure_15.10_B18384.jpg)'
- en: Figure 15.10 – Postman home screen
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – Postman主屏幕
- en: We first need to start a game. To do that, we need to send HTTP `POST` requests
    to the `/start` route on our endpoint. By default, this will be available at `http://localhost:8080/start`.
    We need to send a body, containing the JSON `{"``name":"testuser"}` text.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要开始一个游戏。为此，我们需要向端点的`/start`路由发送HTTP `POST`请求。默认情况下，这将可在`http://localhost:8080/start`处访问。我们需要发送一个包含JSON文本`{"name":"testuser"}`的正文。
- en: 'We can send this request from Postman. We click the **Create a request** button
    on the home page. This takes us to a view where we can enter the URL, select the
    **POST** method and type our JSON body data:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从Postman发送这个请求。我们在主页上点击**创建请求**按钮。这会带我们到一个可以输入URL、选择**POST**方法并输入我们的JSON正文数据的视图：
- en: 'Create a **POST** request to start the game:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**POST**请求来开始游戏：
- en: '![Figure 15.11 – Start a new game](img/Figure_15.11_B18384.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图15.11 – 开始新游戏](img/Figure_15.11_B18384.jpg)'
- en: Figure 15.11 – Start a new game
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 – 开始新游戏
- en: Click the blue `testuser`. The endpoint performed as expected and sent an HTTP
    status code of `204 No Content`. This can be seen in the response panel, towards
    the bottom of the screenshot.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 点击蓝色的`testuser`。端点按预期执行并发送了HTTP状态码`204 No Content`。这可以在截图的底部看到响应面板中。
- en: 'A quick check of the contents of the `game` table in the database shows that
    a row for this game has been created:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查数据库中`game`表的内容显示，已经为这个游戏创建了一个行：
- en: '[PRE315]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'We can now make our first guess at the word. Let’s try a guess of `"STARE"`.
    The **POST** request for this and the response from our endpoint appears, as shown
    in the following screenshot:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以对单词进行第一次猜测。让我们尝试一个猜测`"STARE"`。这个猜测的**POST**请求和端点的响应如下所示：
- en: '![Figure 15.12 – Score returned](img/Figure_15.12_B18384.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图15.12 – 返回的分数](img/Figure_15.12_B18384.jpg)'
- en: Figure 15.12 – Score returned
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 – 返回的分数
- en: The endpoint returns an HTTP status code of `200 OK`. This time, a body of JSON
    formatted data is returned. We see `"scores":"PXPPC"` indicating that the first
    letter of our guess, `S`, appears in the word somewhere but not in the first position.
    The second letter of our guess, `T`, is incorrect and does not appear in the target
    word. We got two more part-correct letters and one final correct letter in our
    guess, which was the letter `E` at the end.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 端点返回HTTP状态码`200 OK`。这次，返回了一个JSON格式的数据体。我们看到`"scores":"PXPPC"`表示我们的猜测的第一个字母`S`在单词的某个位置出现，但不在第一个位置。我们猜测的第二个字母`T`是错误的，并且不在目标单词中。我们在猜测中得到了两个更多部分正确的字母和一个最终正确的字母，即末尾的字母`E`。
- en: The response also shows `"isGameOver":false`. We haven’t finished the game yet.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 响应还显示`"isGameOver":false`。我们还没有完成游戏。
- en: 'We will make one more guess, cheating slightly. Let’s send a `"ARISE"`:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再猜一次，稍微作弊一下。让我们发送一个`"ARISE"`：
- en: '![Figure 15.13 – A successful guess](img/Figure_15.13_B18384.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![图15.13 – 成功的猜测](img/Figure_15.13_B18384.jpg)'
- en: Figure 15.13 – A successful guess
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13 – 成功的猜测
- en: Winner! We see `"scores":"CCCCC"` telling us all five letters of our guess are
    correct. `"isGameOver":true` tells us that our game has ended, on this occasion,
    successfully.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利！我们看到`"scores":"CCCCC"`告诉我们我们猜测的所有五个字母都是正确的。`"isGameOver":true`告诉我们我们的游戏已经结束，在这种情况下，是成功结束的。
- en: We’ve successfully played one game of Wordz using our microservice.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地使用我们的微服务玩了一局Wordz。
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section, we have completed our Wordz application. We used an integration
    test with TDD to drive out an HTTP endpoint for Wordz. We used open source HTTP
    libraries – Molecule, Gson, and Undertow. We made effective use of hexagonal architecture.
    Using ports and adapters, these frameworks became an implementation detail rather
    than a defining feature of our design.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经完成了Wordz应用程序。我们使用TDD的集成测试来驱动Wordz的HTTP端点。我们使用了开源的HTTP库 – Molecule、Gson和Undertow。我们有效地使用了六边形架构。使用端口和适配器，这些框架变成了实现细节而不是我们设计的定义特征。
- en: We assembled our final application to bring together the business logic held
    in the domain layer with the Postgres database adapter and the HTTP endpoint adapter.
    Working together, our application forms a small microservice.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组装了最终的应用程序，将领域层中持有的业务逻辑与Postgres数据库适配器和HTTP端点适配器结合起来。我们的应用程序一起工作，形成了一个小型微服务。
- en: In this final chapter, we have arrived at a small-scale yet typical microservice
    comprising an HTTP API and a SQL database. We’ve developed the code test first,
    using tests to guide our design choices. We have applied the SOLID principles
    to improve how our software fits together. We have learned how the ports and adapters
    of hexagonal architecture simplify the design of code that works with external
    systems. Using hexagonal architecture is a natural fit for TDD, allowing us to
    develop our core application logic with FIRST unit tests. We have created both
    a database adapter and an HTTP adapter test first, using integration tests. We
    applied the rhythms of TDD – Red, Green, Refactor and Arrange, Act and Assert
    to our work. We have applied test doubles using the Mockito library to stand in
    for external systems, simplifying the development.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后一部分，我们到达了一个小型但典型的微服务，它包含一个HTTP API和一个SQL数据库。我们首先使用测试来指导我们的设计选择，开发了代码。我们应用了SOLID原则来改进软件的组装方式。我们学习了如何使用六边形架构的端口和适配器简化与外部系统交互的代码设计。使用六边形架构是TDD的自然选择，它允许我们使用FIRST单元测试来开发核心应用程序逻辑。我们首先创建了数据库适配器和HTTP适配器测试，然后使用集成测试。我们应用了TDD的节奏——红、绿、重构和安排、行动和断言到我们的工作中。我们使用Mockito库应用了测试替身，以替代外部系统，简化了开发。
- en: In this book, we have covered a wide range of TDD and software design techniques.
    We can now create code with fewer defects, and that is safer and easier to work
    with.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们涵盖了广泛的测试驱动开发（TDD）和软件设计技术。现在我们可以编写出缺陷更少的代码，这使得代码更安全且易于使用。
- en: Questions and answers
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: What further work could be done?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以做什么进一步的工作？
- en: Further work could include adding a **Continuous Integration (CI)** pipeline
    so that whenever we commit code, the application gets pulled from source control,
    built, and all tests run. We could consider deployment and automation of that.
    One example might be to package up the Wordz application and the Postgres database
    as a Docker image. It would be good to add database schema automation, using a
    tool such as Flyway.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '进一步的工作可以包括添加一个**持续集成（CI）**管道，这样每次我们提交代码时，应用程序都会从源代码控制中拉取，构建，并运行所有测试。我们可以考虑部署和自动化这个过程。一个例子可能是将Wordz应用程序和Postgres数据库打包成一个Docker镜像。添加数据库模式自动化，使用像Flyway这样的工具会很好。 '
- en: Could we replace the Molecule library and use something else for our web endpoint?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否替换Molecule库，并使用其他东西来构建我们的网络端点？
- en: Yes. As the web endpoint sits in our adapter layer of the hexagonal architecture,
    it does not affect the core functionality in the domain model. Any suitable web
    framework could be used.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。因为网络端点位于六边形架构的适配器层，所以它不会影响领域模型中的核心功能。任何合适的网络框架都可以使用。
- en: Further reading
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://martinfowler.com/articles/richardsonMaturityModel.html](B18384_15.xhtml#_idTextAnchor321)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://martinfowler.com/articles/richardsonMaturityModel.html](B18384_15.xhtml#_idTextAnchor321)'
- en: An overview of what a REST web interface means, along with some common variations
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 关于REST网络接口的概述，以及一些常见的变化
- en: '*Java OOP Done Right*, Alan Mellor, ISBN 9781527284449'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java OOP Done Right*，艾伦·梅勒，ISBN 9781527284449'
- en: The author’s book gives some more details on OO basics with some useful design
    patterns
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 作者的书籍对面向对象（OO）基础和一些有用的设计模式进行了更详细的介绍
- en: https://www.postman.com/
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://www.postman.com/
- en: A popular testing tool that sends HTTP requests and displays responses
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的测试工具，它发送HTTP请求并显示响应
- en: '[http://molecule.vtence.com/](B18384_15.xhtml#_idTextAnchor319)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://molecule.vtence.com/](B18384_15.xhtml#_idTextAnchor319)'
- en: A lightweight HTTP framework for Java
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 一个轻量级的Java HTTP框架
- en: '[https://undertow.io/](B18384_15.xhtml#_idTextAnchor318)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://undertow.io/](B18384_15.xhtml#_idTextAnchor318)'
- en: An HTTP server for Java that works well with the Molecule framework
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 与Molecule框架配合良好的Java HTTP服务器
- en: '[https://github.com/google/gson](B18384_15.xhtml#_idTextAnchor317)'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/google/gson](B18384_15.xhtml#_idTextAnchor317)'
- en: Google’s library to convert between Java objects and the JSON format
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: Google用于在Java对象和JSON格式之间转换的库
- en: '[https://aws.amazon.com/what-is/restful-api/](B18384_15.xhtml#_idTextAnchor316)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/what-is/restful-api/](B18384_15.xhtml#_idTextAnchor316)'
- en: Amazon’s guide to REST APIs
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊的REST API指南
- en: '[https://docs.oracle.com/en/java/javase/12/docs/api/java.net.http/java/net/http/HttpClient.html](B18384_15.xhtml#_idTextAnchor315)'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.oracle.com/en/java/javase/12/docs/api/java.net.http/java/net/http/HttpClient.html](B18384_15.xhtml#_idTextAnchor315)'
- en: Official Java documentation about the test HHTP client used in this chapter
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的测试HTTP客户端的官方Java文档
