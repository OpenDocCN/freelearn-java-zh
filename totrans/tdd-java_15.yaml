- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving the Web Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we complete our web application by adding a web endpoint. We
    will learn how to write HTTP integration tests using the built-in Java HTTP client.
    We will test-drive the web adapter code that runs this endpoint, using an open
    source HTTP server framework. This web adapter is responsible for converting HTTP
    requests into commands we can execute in our domain layer. At the end of the chapter,
    we will assemble all the pieces of our application into a microservice. The web
    adapter and database adapters will be linked to the domain model using dependency
    injection. We will need to run a few manual database commands, install a web client
    called Postman, and then we can play our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter15](B18384_15.xhtml#_idTextAnchor314).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before attempting to run the final application, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the **Postgres** database is running locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the database setup steps from [*Chapter 14*](B18384_14.xhtml#_idTextAnchor293)
    *, Driving the Database Layer,* have been completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **Postgres pqsl** command terminal and enter the following SQL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Install **Postman** by following the instructions at [https://www.postman.com/downloads/](B18384_15.xhtml#_idTextAnchor313).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting a new game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will test-drive a web adapter that will provide our domain
    model with an HTTP API. External web clients will be able to send HTTP requests
    to this endpoint to trigger actions in our domain model so that we can play the
    game. The API will return appropriate HTTP responses, indicating the score for
    the submitted guess and reporting when the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following open source libraries will be used to help us write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Molecule`: This is a lightweight HTTP framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Undertow`: This is a lightweight HTTP web server that powers the Molecule
    framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GSON`: This is a Google library that converts between Java objects and JSON
    structured data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start building, we first add the required libraries as dependencies to the
    `build.gradle` file. Then we can begin writing an integration test for our HTTP
    endpoint and test-drive the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding required libraries to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to add the three libraries Molecule, Undertow, and Gson to the `build.gradle`
    file before we can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Writing the failing test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will follow the normal TDD cycle to create our web adapter. When writing
    tests for objects in the adapter layer, we must focus on testing the translation
    between objects in our domain layer and communications with external systems.
    Our adapter layer will use the Molecule HTTP framework to handle HTTP requests
    and responses.
  prefs: []
  type: TYPE_NORMAL
- en: As we have used hexagonal architecture and started with the domain layer, we
    already know that the game logic is working. The goal of this test is to prove
    that the web adapter layer is performing its responsibility. That is to translate
    HTTP requests and responses to objects in our domain layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As ever, we begin by creating a test class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we write our test class. We’ll call it `WordzEndpointTest`, and it belongs
    in the `com.wordz.adapters.api` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reason for including this package is as part of our hexagonal architecture.
    Code in this web adapter is allowed to use anything from the domain model. The
    domain model itself is unaware of the existence of this web adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first test will be to start a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This test needs to capture the design decision that surrounds our intended
    web API. One decision is that when a game has successfully started, we will return
    a simple `204 No Content` HTTP status code. We will start with the assert to capture
    this decision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we write the Act step. The action here is for an external HTTP client
    to send a request to our web endpoint. To achieve this, we use the built-in HTTP
    client provided by Java itself. We arrange the code to send the request, and then
    discard any HTTP response body, as our design does not return a body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Arrange step is where we capture our decisions about the HTTP request to
    send. In order to start a new game, we need a `Player` object to identify the
    player. We will send this as a `Json` object in the `Request` body. The request
    will cause a state change on our server, so we choose the HTTP `POST` method to
    represent that. Finally, we choose a route whose path is `/start`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see the `Gson` library being used to convert a `Player` object into its JSON
    representation. We also see a `POST` method is constructed and sent to the `/start`
    path on `localhost`. Eventually, we will want to move the `localhost` detail into
    configuration. But, for now, it will get the test working on our local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run our integration test and confirm that it fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.1 – A failed test – no HTTP server](img/Figure_15.01_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – A failed test – no HTTP server
  prefs: []
  type: TYPE_NORMAL
- en: Unsurprisingly, this test fails because it cannot connect to an HTTP server.
    Fixing that is our next task.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our HTTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The failing test allows us to test-drive code that implements an HTTP server.
    We will use the Molecule library to provide HTTP services to us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an endpoint class, which we will call `class WordzEndpoint`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The two parameters passed into the `WordzEndpoint` constructor define the host
    and port that the web endpoint will run on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the IDE, we generate the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we’re not going to store the host and port details in fields.
    Instead, we are going to start a `WebServer` using a class from the Molecule library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WebServer` using the Molecule library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is enough to start an HTTP server running and allow the test
    to connect to it. Our HTTP server does nothing useful in terms of playing our
    game. We need to add some routes to this server along with the code to respond
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routes to the HTTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be useful, the HTTP endpoint must respond to HTTP commands, interpret them,
    and send them as commands to our domain layer. As design decisions, we decide
    on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: That a `/start` route must be called to start the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That we will use the HTTP `POST` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That we will identify which player the game belongs to as JSON data in the `POST`
    body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add routes to the HTTP server, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test-drive the `/start` route. To work in small steps, initially, we will return
    a `NOT_IMPLEMENTED` HTTP response code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run the `WordzEndpointTest` integration test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.2 – An incorrect HTTP status](img/Figure_15.02_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – An incorrect HTTP status
  prefs: []
  type: TYPE_NORMAL
- en: The test fails, as expected. We have made progress because the test now fails
    for a different reason. We can now connect to the web endpoint, but it does not
    return the right HTTP response. Our next task is to connect this web endpoint
    to the domain layer code and take the relevant actions to start a game.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the domain layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next task is to receive an HTTP request and translate that into domain
    layer calls. This involves parsing JSON request data, using the Google Gson library,
    into Java objects, then sending that response data to the `class` `Wordz` port:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to call the domain layer port implemented as `class Wordz`. We
    will use `Mockito` to create a test double for this object. This allows us to
    test only the web endpoint code, decoupled from all other code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to provide our `class Wordz` domain object to the `class WordzEndpoint`
    object. We use dependency injection to inject it into the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add the code to start a game. To do that, we first extract
    the `Player` object from the JSON data in the `request` body. That identifies
    which player to start a game for. Then we call the `wordz.newGame()` method. If
    it is successful, we return an HTTP status code of `204 No Content`, indicating
    success:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run the test, however, it fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.3 – An incorrect HTTP response](img/Figure_15.03_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – An incorrect HTTP response
  prefs: []
  type: TYPE_NORMAL
- en: It failed because the return value from `wordz.newGame()` was false. The mock
    object needs to be set up to return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return the correct value from the `mockWordz` stub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, run the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.4 – The test passes](img/Figure_15.04_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – The test passes
  prefs: []
  type: TYPE_NORMAL
- en: The integration test passes. The HTTP request has been received, called the
    domain layer code to start a new game, and the HTTP response is returned. The
    next step is to consider refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the start game code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, once a test passes, we consider what – if anything – we need to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be worthwhile to refactor the test to simplify writing new tests by
    collating common code into one place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Handling errors when starting a game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of our design decisions is that a player cannot start a game when one is
    in progress. We need to test-drive this behavior. We choose to return an HTTP
    status of `409 Conflict` to indicate that a game is already in progress for a
    player and a new one cannot be started for them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the test to return a `409 Conflict` if the game is already in progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, run the test. It should fail, as we have yet to write the implementation
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.5 – A failing test](img/Figure_15.05_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – A failing test
  prefs: []
  type: TYPE_NORMAL
- en: 'Test-drive the code to report that the game cannot be restarted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15\. 6 – The test passes](img/Figure_15.06_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15\. 6 – The test passes
  prefs: []
  type: TYPE_NORMAL
- en: The test passes when run on its own now that the implementation is in place.
    Let’s run all the `WordzEndpointTests` tests to double-check our progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run all `WordzEndpointTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Test failure due to restarting the server](img/Figure_15.07_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Test failure due to restarting the server
  prefs: []
  type: TYPE_NORMAL
- en: Unexpectedly, the tests fail when run one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the unexpectedly failing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we run all of the tests, they now fail. The tests all previously ran correctly
    when run one at a time. A recent change has clearly broken something. We lost
    our test isolation at some point. This error message indicates the web server
    is being started twice on the same port, which is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options are to stop the web server after each test or to only start the
    web server once for all tests. As this is intended to be a long-running microservice,
    only starting once seems the better choice here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `@BeforeAll` annotation to only start the HTTP server once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We change the `@BeforeEach` annotation to a `@BeforeAll` annotation to make
    the endpoint creation only happen once per test. To support this, we also must
    create the mock and use an annotation on the test itself to control the life cycle
    of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Both tests in `WordzEndpointTest` now pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all tests passing again, we can consider refactoring the code. A readability
    improvement will come from extracting an `extractPlayer()` method. We can also
    make the conditional HTTP status code more concise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now completed the major part of the coding needed to start a game. To
    handle the remaining error condition, we can now test-drive the code to return
    `400 BAD REQUEST` if the `Player` object cannot be read from the JSON payload.
    We will omit that code here. In the next section, we will move on to test-driving
    the code for guessing the target word.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will test-drive the code to play the game. This involves
    submitting multiple guess attempts to the endpoint until a game-over response
    is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating an integration test for the new `/guess` route in our
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to code the Arrange step. Our domain model provides the `assess()`
    method on `class Wordz` to assess the score for a guess, along with reporting
    whether the game is over. To test-drive this, we set up the `mockWordz` stub to
    return a valid `GuessResult` object when the `assess()` method is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Act step will call our endpoint with a web request submitting the guess.
    Our design decision is to send an HTTP `POST` request to the `/guess` route. The
    `request` body will contain a JSON representation of the guessed word. To create
    this, we will use `record GuessRequest` and use Gson to convert that into JSON
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define the record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we send the request over HTTP to our endpoint, awaiting the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we extract the returned body data and assert it against our expectations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One API design decision here is to return the per-letter scores as a five-character
    `String` object. The single letters `X`, `C`, and `P` are used to indicate incorrect,
    correct, and partially correct letters. We capture this decision in the assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a record to represent the JSON data structure we will return as a
    response from our endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we have decided to `POST` to a new `/guess` route, we need to add this route
    to the routing table. We also need to bind it to a method that will take action,
    which we will call `guessWord()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add an `IllegalStateException` to rethrow any problems that occur when starting
    the HTTP server. For this application, this exception may propagate upwards and
    cause the application to stop running. Without a working web server, none of the
    web code makes sense to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement the `guessWord()` method with code to extract the `request` data
    from the `POST` body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have the `request` data, it’s time to call our domain layer to do the
    real work. We will capture the `GuessResult` object returned, so we can base our
    HTTP response from the endpoint on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We choose to return a different format of data from our endpoint compared to
    the `GuessResult` object returned from our domain model. We will need to transform
    the result from the domain model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE294]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE295]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE296]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE297]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE298]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE299]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE300]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE301]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE302]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE303]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE304]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE305]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE306]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add an empty version of the object doing the transformation, which is `class
    GuessHttpResponseMapper`. In this first step, it will simply return `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE308]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE309]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE310]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE311]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE312]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE313]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is enough to compile and be able to run the `WordzEndpointTest` test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.8 – The test fails](img/Figure_15.08_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – The test fails
  prefs: []
  type: TYPE_NORMAL
- en: With a failing test in place, we can now test-drive the details of the transform
    class. To do this, we switch to adding a new unit test called `class GuessHttpResponseMapperTest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The details of this are omitted but can be found on GitHub – it follows the
    standard approach used throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have test-driven the detailed implementation of `class GuessHttpResponseMapper`,
    we can rerun the integration test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.9 – The endpoint test passes](img/Figure_15.09_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – The endpoint test passes
  prefs: []
  type: TYPE_NORMAL
- en: As we see in the preceding image, the integration test has passed! Time for
    a well-earned coffee break. Well, mine’s a nice English breakfast tea, but that’s
    just me. After that, we can test-drive the response to any errors that occurred.
    Then it’s time to bring the microservice together. In the next section, we will
    assemble our application into a running microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will bring together the components of our test-driven application.
    We will form a microservice that runs our endpoint and provides the frontend web
    interface to our service. It will use the Postgres database for storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to write a short `main()` method to link together the major components
    of our code. This will involve creating concrete objects and injecting dependencies
    into constructors. The `main()` method exists on `class WordzApplication`, which
    is the entry point to our fully integrated web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: The `main()` method instantiates the domain model, and dependency injects the
    concrete version of our adapter classes into it. One notable detail is the `waitUntilTerminated()`method.
    This prevents `main()` from terminating until the application is closed down.
    This, in turn, keeps the HTTP endpoint responding to requests.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration data for the application is held in `class WordzConfiguration`.
    This has default settings for the endpoint host and port settings, along with
    database connection settings. These can also be passed in as command line arguments.
    The class and its associated test can be seen in the GitHub code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use the Wordz web service application using the
    popular HTTP testing tool, Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Using the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use our newly assembled web application, first ensure that the database setup
    steps and the Postman installation described in the *Technical requirements* section
    have been successfully completed. Then run the `main()` method of `class` `WordzApplication`
    in IntelliJ. That starts the endpoint, ready to accept requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the service is running, the way we interact with it is by sending HTTP
    requests to the endpoint. Launch Postman and (on macOS) a window that looks like
    this will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Postman home screen](img/Figure_15.10_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Postman home screen
  prefs: []
  type: TYPE_NORMAL
- en: We first need to start a game. To do that, we need to send HTTP `POST` requests
    to the `/start` route on our endpoint. By default, this will be available at `http://localhost:8080/start`.
    We need to send a body, containing the JSON `{"``name":"testuser"}` text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can send this request from Postman. We click the **Create a request** button
    on the home page. This takes us to a view where we can enter the URL, select the
    **POST** method and type our JSON body data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **POST** request to start the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Start a new game](img/Figure_15.11_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – Start a new game
  prefs: []
  type: TYPE_NORMAL
- en: Click the blue `testuser`. The endpoint performed as expected and sent an HTTP
    status code of `204 No Content`. This can be seen in the response panel, towards
    the bottom of the screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick check of the contents of the `game` table in the database shows that
    a row for this game has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now make our first guess at the word. Let’s try a guess of `"STARE"`.
    The **POST** request for this and the response from our endpoint appears, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.12 – Score returned](img/Figure_15.12_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – Score returned
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint returns an HTTP status code of `200 OK`. This time, a body of JSON
    formatted data is returned. We see `"scores":"PXPPC"` indicating that the first
    letter of our guess, `S`, appears in the word somewhere but not in the first position.
    The second letter of our guess, `T`, is incorrect and does not appear in the target
    word. We got two more part-correct letters and one final correct letter in our
    guess, which was the letter `E` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: The response also shows `"isGameOver":false`. We haven’t finished the game yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make one more guess, cheating slightly. Let’s send a `"ARISE"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.13 – A successful guess](img/Figure_15.13_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – A successful guess
  prefs: []
  type: TYPE_NORMAL
- en: Winner! We see `"scores":"CCCCC"` telling us all five letters of our guess are
    correct. `"isGameOver":true` tells us that our game has ended, on this occasion,
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully played one game of Wordz using our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we have completed our Wordz application. We used an integration
    test with TDD to drive out an HTTP endpoint for Wordz. We used open source HTTP
    libraries – Molecule, Gson, and Undertow. We made effective use of hexagonal architecture.
    Using ports and adapters, these frameworks became an implementation detail rather
    than a defining feature of our design.
  prefs: []
  type: TYPE_NORMAL
- en: We assembled our final application to bring together the business logic held
    in the domain layer with the Postgres database adapter and the HTTP endpoint adapter.
    Working together, our application forms a small microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In this final chapter, we have arrived at a small-scale yet typical microservice
    comprising an HTTP API and a SQL database. We’ve developed the code test first,
    using tests to guide our design choices. We have applied the SOLID principles
    to improve how our software fits together. We have learned how the ports and adapters
    of hexagonal architecture simplify the design of code that works with external
    systems. Using hexagonal architecture is a natural fit for TDD, allowing us to
    develop our core application logic with FIRST unit tests. We have created both
    a database adapter and an HTTP adapter test first, using integration tests. We
    applied the rhythms of TDD – Red, Green, Refactor and Arrange, Act and Assert
    to our work. We have applied test doubles using the Mockito library to stand in
    for external systems, simplifying the development.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have covered a wide range of TDD and software design techniques.
    We can now create code with fewer defects, and that is safer and easier to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What further work could be done?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further work could include adding a **Continuous Integration (CI)** pipeline
    so that whenever we commit code, the application gets pulled from source control,
    built, and all tests run. We could consider deployment and automation of that.
    One example might be to package up the Wordz application and the Postgres database
    as a Docker image. It would be good to add database schema automation, using a
    tool such as Flyway.
  prefs: []
  type: TYPE_NORMAL
- en: Could we replace the Molecule library and use something else for our web endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. As the web endpoint sits in our adapter layer of the hexagonal architecture,
    it does not affect the core functionality in the domain model. Any suitable web
    framework could be used.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://martinfowler.com/articles/richardsonMaturityModel.html](B18384_15.xhtml#_idTextAnchor321)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of what a REST web interface means, along with some common variations
  prefs: []
  type: TYPE_NORMAL
- en: '*Java OOP Done Right*, Alan Mellor, ISBN 9781527284449'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The author’s book gives some more details on OO basics with some useful design
    patterns
  prefs: []
  type: TYPE_NORMAL
- en: https://www.postman.com/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A popular testing tool that sends HTTP requests and displays responses
  prefs: []
  type: TYPE_NORMAL
- en: '[http://molecule.vtence.com/](B18384_15.xhtml#_idTextAnchor319)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lightweight HTTP framework for Java
  prefs: []
  type: TYPE_NORMAL
- en: '[https://undertow.io/](B18384_15.xhtml#_idTextAnchor318)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An HTTP server for Java that works well with the Molecule framework
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/google/gson](B18384_15.xhtml#_idTextAnchor317)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google’s library to convert between Java objects and the JSON format
  prefs: []
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/what-is/restful-api/](B18384_15.xhtml#_idTextAnchor316)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon’s guide to REST APIs
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.oracle.com/en/java/javase/12/docs/api/java.net.http/java/net/http/HttpClient.html](B18384_15.xhtml#_idTextAnchor315)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official Java documentation about the test HHTP client used in this chapter
  prefs: []
  type: TYPE_NORMAL
